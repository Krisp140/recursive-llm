# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-debug-tools/src/ReactDebugHooks.js

commit fd1256a5618d335d5eb563858e0841869b97b1ad
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Nov 5 10:02:59 2018 -0800

    Add Debug Tools Package for Introspection of Hooks (#14085)
    
    * Add debug tools package
    
    * Add basic implementation
    
    * Implement inspection of the current state of hooks using the fiber tree
    
    * Support useContext hooks inspection by backtracking from the Fiber
    
    I'm not sure this is safe because the return fibers may not be current
    but close enough and it's fast.
    
    We use this to set up the current values of the providers.
    
    * rm copypasta
    
    * Use lastIndexOf
    
    Just in case. I don't know of any scenario where this can happen.
    
    * Support ForwardRef
    
    * Add test for memo and custom hooks
    
    * Support defaultProps resolution

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
new file mode 100644
index 0000000000..61d468bd07
--- /dev/null
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -0,0 +1,530 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
+import type {Fiber} from 'react-reconciler/src/ReactFiber';
+import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
+
+import ErrorStackParser from 'error-stack-parser';
+import ReactSharedInternals from 'shared/ReactSharedInternals';
+import {
+  FunctionComponent,
+  SimpleMemoComponent,
+  ContextProvider,
+  ForwardRef,
+} from 'shared/ReactWorkTags';
+
+const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
+
+// Used to track hooks called during a render
+
+type HookLogEntry = {
+  primitive: string,
+  stackError: Error,
+  value: mixed,
+};
+
+let hookLog: Array<HookLogEntry> = [];
+
+// Primitives
+
+type BasicStateAction<S> = (S => S) | S;
+
+type Dispatch<A> = A => void;
+
+let primitiveStackCache: null | Map<string, Array<any>> = null;
+
+function getPrimitiveStackCache(): Map<string, Array<any>> {
+  // This initializes a cache of all primitive hooks so that the top
+  // most stack frames added by calling the primitive hook can be removed.
+  if (primitiveStackCache === null) {
+    let cache = new Map();
+    let readHookLog;
+    try {
+      // Use all hooks here to add them to the hook log.
+      Dispatcher.useContext(({_currentValue: null}: any));
+      Dispatcher.useState(null);
+      Dispatcher.useReducer((s, a) => s, null);
+      Dispatcher.useRef(null);
+      Dispatcher.useMutationEffect(() => {});
+      Dispatcher.useLayoutEffect(() => {});
+      Dispatcher.useEffect(() => {});
+      Dispatcher.useImperativeMethods(undefined, () => null);
+      Dispatcher.useCallback(() => {});
+      Dispatcher.useMemo(() => null);
+    } finally {
+      readHookLog = hookLog;
+      hookLog = [];
+    }
+    for (let i = 0; i < readHookLog.length; i++) {
+      let hook = readHookLog[i];
+      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));
+    }
+    primitiveStackCache = cache;
+  }
+  return primitiveStackCache;
+}
+
+let currentHook: null | Hook = null;
+function nextHook(): null | Hook {
+  let hook = currentHook;
+  if (hook !== null) {
+    currentHook = hook.next;
+  }
+  return hook;
+}
+
+function readContext<T>(
+  context: ReactContext<T>,
+  observedBits: void | number | boolean,
+): T {
+  // For now we don't expose readContext usage in the hooks debugging info.
+  return context._currentValue;
+}
+
+function useContext<T>(
+  context: ReactContext<T>,
+  observedBits: void | number | boolean,
+): T {
+  hookLog.push({
+    primitive: 'Context',
+    stackError: new Error(),
+    value: context._currentValue,
+  });
+  return context._currentValue;
+}
+
+function useState<S>(
+  initialState: (() => S) | S,
+): [S, Dispatch<BasicStateAction<S>>] {
+  let hook = nextHook();
+  let state: S =
+    hook !== null
+      ? hook.memoizedState
+      : typeof initialState === 'function'
+        ? initialState()
+        : initialState;
+  hookLog.push({primitive: 'State', stackError: new Error(), value: state});
+  return [state, (action: BasicStateAction<S>) => {}];
+}
+
+function useReducer<S, A>(
+  reducer: (S, A) => S,
+  initialState: S,
+  initialAction: A | void | null,
+): [S, Dispatch<A>] {
+  let hook = nextHook();
+  let state = hook !== null ? hook.memoizedState : initialState;
+  hookLog.push({
+    primitive: 'Reducer',
+    stackError: new Error(),
+    value: state,
+  });
+  return [state, (action: A) => {}];
+}
+
+function useRef<T>(initialValue: T): {current: T} {
+  let hook = nextHook();
+  let ref = hook !== null ? hook.memoizedState : {current: initialValue};
+  hookLog.push({
+    primitive: 'Ref',
+    stackError: new Error(),
+    value: ref.current,
+  });
+  return ref;
+}
+
+function useMutationEffect(
+  create: () => mixed,
+  inputs: Array<mixed> | void | null,
+): void {
+  nextHook();
+  hookLog.push({
+    primitive: 'MutationEffect',
+    stackError: new Error(),
+    value: create,
+  });
+}
+
+function useLayoutEffect(
+  create: () => mixed,
+  inputs: Array<mixed> | void | null,
+): void {
+  nextHook();
+  hookLog.push({
+    primitive: 'LayoutEffect',
+    stackError: new Error(),
+    value: create,
+  });
+}
+
+function useEffect(
+  create: () => mixed,
+  inputs: Array<mixed> | void | null,
+): void {
+  nextHook();
+  hookLog.push({primitive: 'Effect', stackError: new Error(), value: create});
+}
+
+function useImperativeMethods<T>(
+  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
+  create: () => T,
+  inputs: Array<mixed> | void | null,
+): void {
+  nextHook();
+  // We don't actually store the instance anywhere if there is no ref callback
+  // and if there is a ref callback it might not store it but if it does we
+  // have no way of knowing where. So let's only enable introspection of the
+  // ref itself if it is using the object form.
+  let instance = undefined;
+  if (ref !== null && typeof ref === 'object') {
+    instance = ref.current;
+  }
+  hookLog.push({
+    primitive: 'ImperativeMethods',
+    stackError: new Error(),
+    value: instance,
+  });
+}
+
+function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
+  let hook = nextHook();
+  hookLog.push({
+    primitive: 'Callback',
+    stackError: new Error(),
+    value: hook !== null ? hook.memoizedState[0] : callback,
+  });
+  return callback;
+}
+
+function useMemo<T>(
+  nextCreate: () => T,
+  inputs: Array<mixed> | void | null,
+): T {
+  let hook = nextHook();
+  let value = hook !== null ? hook.memoizedState[0] : nextCreate();
+  hookLog.push({primitive: 'Memo', stackError: new Error(), value});
+  return value;
+}
+
+const Dispatcher = {
+  readContext,
+  useCallback,
+  useContext,
+  useEffect,
+  useImperativeMethods,
+  useLayoutEffect,
+  useMemo,
+  useMutationEffect,
+  useReducer,
+  useRef,
+  useState,
+};
+
+// Inspect
+
+type HooksNode = {
+  name: string,
+  value: mixed,
+  subHooks: Array<HooksNode>,
+};
+type HooksTree = Array<HooksNode>;
+
+// Don't assume
+//
+// We can't assume that stack frames are nth steps away from anything.
+// E.g. we can't assume that the root call shares all frames with the stack
+// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
+// in a wrapper constructor like a polyfill. That'll add an extra frame.
+// Similar things can happen with the call to the dispatcher. The top frame
+// may not be the primitive. Likewise the primitive can have fewer stack frames
+// such as when a call to useState got inlined to use dispatcher.useState.
+//
+// We also can't assume that the last frame of the root call is the same
+// frame as the last frame of the hook call because long stack traces can be
+// truncated to a stack trace limit.
+
+let mostLikelyAncestorIndex = 0;
+
+function findSharedIndex(hookStack, rootStack, rootIndex) {
+  let source = rootStack[rootIndex].source;
+  hookSearch: for (let i = 0; i < hookStack.length; i++) {
+    if (hookStack[i].source === source) {
+      // This looks like a match. Validate that the rest of both stack match up.
+      for (
+        let a = rootIndex + 1, b = i + 1;
+        a < rootStack.length && b < hookStack.length;
+        a++, b++
+      ) {
+        if (hookStack[b].source !== rootStack[a].source) {
+          // If not, give up and try a different match.
+          continue hookSearch;
+        }
+      }
+      return i;
+    }
+  }
+  return -1;
+}
+
+function findCommonAncestorIndex(rootStack, hookStack) {
+  let rootIndex = findSharedIndex(
+    hookStack,
+    rootStack,
+    mostLikelyAncestorIndex,
+  );
+  if (rootIndex !== -1) {
+    return rootIndex;
+  }
+  // If the most likely one wasn't a hit, try any other frame to see if it is shared.
+  // If that takes more than 5 frames, something probably went wrong.
+  for (let i = 0; i < rootStack.length && i < 5; i++) {
+    rootIndex = findSharedIndex(hookStack, rootStack, i);
+    if (rootIndex !== -1) {
+      mostLikelyAncestorIndex = i;
+      return rootIndex;
+    }
+  }
+  return -1;
+}
+
+function isReactWrapper(functionName, primitiveName) {
+  if (!functionName) {
+    return false;
+  }
+  let expectedPrimitiveName = 'use' + primitiveName;
+  if (functionName.length < expectedPrimitiveName.length) {
+    return false;
+  }
+  return (
+    functionName.lastIndexOf(expectedPrimitiveName) ===
+    functionName.length - expectedPrimitiveName.length
+  );
+}
+
+function findPrimitiveIndex(hookStack, hook) {
+  let stackCache = getPrimitiveStackCache();
+  let primitiveStack = stackCache.get(hook.primitive);
+  if (primitiveStack === undefined) {
+    return -1;
+  }
+  for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
+    if (primitiveStack[i].source !== hookStack[i].source) {
+      // If the next two frames are functions called `useX` then we assume that they're part of the
+      // wrappers that the React packager or other packages adds around the dispatcher.
+      if (
+        i < hookStack.length - 1 &&
+        isReactWrapper(hookStack[i].functionName, hook.primitive)
+      ) {
+        i++;
+      }
+      if (
+        i < hookStack.length - 1 &&
+        isReactWrapper(hookStack[i].functionName, hook.primitive)
+      ) {
+        i++;
+      }
+      return i;
+    }
+  }
+  return -1;
+}
+
+function parseTrimmedStack(rootStack, hook) {
+  // Get the stack trace between the primitive hook function and
+  // the root function call. I.e. the stack frames of custom hooks.
+  let hookStack = ErrorStackParser.parse(hook.stackError);
+  let rootIndex = findCommonAncestorIndex(rootStack, hookStack);
+  let primitiveIndex = findPrimitiveIndex(hookStack, hook);
+  if (
+    rootIndex === -1 ||
+    primitiveIndex === -1 ||
+    rootIndex - primitiveIndex < 2
+  ) {
+    // Something went wrong. Give up.
+    return null;
+  }
+  return hookStack.slice(primitiveIndex, rootIndex - 1);
+}
+
+function parseCustomHookName(functionName: void | string): string {
+  if (!functionName) {
+    return '';
+  }
+  let startIndex = functionName.lastIndexOf('.');
+  if (startIndex === -1) {
+    startIndex = 0;
+  }
+  if (functionName.substr(startIndex, 3) === 'use') {
+    startIndex += 3;
+  }
+  return functionName.substr(startIndex);
+}
+
+function buildTree(rootStack, readHookLog): HooksTree {
+  let rootChildren = [];
+  let prevStack = null;
+  let levelChildren = rootChildren;
+  let stackOfChildren = [];
+  for (let i = 0; i < readHookLog.length; i++) {
+    let hook = readHookLog[i];
+    let stack = parseTrimmedStack(rootStack, hook);
+    if (stack !== null) {
+      // Note: The indices 0 <= n < length-1 will contain the names.
+      // The indices 1 <= n < length will contain the source locations.
+      // That's why we get the name from n - 1 and don't check the source
+      // of index 0.
+      let commonSteps = 0;
+      if (prevStack !== null) {
+        // Compare the current level's stack to the new stack.
+        while (commonSteps < stack.length && commonSteps < prevStack.length) {
+          let stackSource = stack[stack.length - commonSteps - 1].source;
+          let prevSource = prevStack[prevStack.length - commonSteps - 1].source;
+          if (stackSource !== prevSource) {
+            break;
+          }
+          commonSteps++;
+        }
+        // Pop back the stack as many steps as were not common.
+        for (let j = prevStack.length - 1; j > commonSteps; j--) {
+          levelChildren = stackOfChildren.pop();
+        }
+      }
+      // The remaining part of the new stack are custom hooks. Push them
+      // to the tree.
+      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
+        let children = [];
+        levelChildren.push({
+          name: parseCustomHookName(stack[j - 1].functionName),
+          value: undefined, // TODO: Support custom inspectable values.
+          subHooks: children,
+        });
+        stackOfChildren.push(levelChildren);
+        levelChildren = children;
+      }
+      prevStack = stack;
+    }
+    levelChildren.push({
+      name: hook.primitive,
+      value: hook.value,
+      subHooks: [],
+    });
+  }
+  return rootChildren;
+}
+
+export function inspectHooks<Props>(
+  renderFunction: Props => React$Node,
+  props: Props,
+): HooksTree {
+  let previousDispatcher = ReactCurrentOwner.currentDispatcher;
+  let readHookLog;
+  ReactCurrentOwner.currentDispatcher = Dispatcher;
+  let ancestorStackError;
+  try {
+    ancestorStackError = new Error();
+    renderFunction(props);
+  } finally {
+    readHookLog = hookLog;
+    hookLog = [];
+    ReactCurrentOwner.currentDispatcher = previousDispatcher;
+  }
+  let rootStack = ErrorStackParser.parse(ancestorStackError);
+  return buildTree(rootStack, readHookLog);
+}
+
+function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
+  let current = fiber;
+  while (current) {
+    if (current.tag === ContextProvider) {
+      const providerType: ReactProviderType<any> = current.type;
+      const context: ReactContext<any> = providerType._context;
+      if (!contextMap.has(context)) {
+        // Store the current value that we're going to restore later.
+        contextMap.set(context, context._currentValue);
+        // Set the inner most provider value on the context.
+        context._currentValue = current.memoizedProps.value;
+      }
+    }
+    current = current.return;
+  }
+}
+
+function restoreContexts(contextMap: Map<ReactContext<any>, any>) {
+  contextMap.forEach((value, context) => (context._currentValue = value));
+}
+
+function inspectHooksOfForwardRef<Props, Ref>(
+  renderFunction: (Props, Ref) => React$Node,
+  props: Props,
+  ref: Ref,
+): HooksTree {
+  let previousDispatcher = ReactCurrentOwner.currentDispatcher;
+  let readHookLog;
+  ReactCurrentOwner.currentDispatcher = Dispatcher;
+  let ancestorStackError;
+  try {
+    ancestorStackError = new Error();
+    renderFunction(props, ref);
+  } finally {
+    readHookLog = hookLog;
+    hookLog = [];
+    ReactCurrentOwner.currentDispatcher = previousDispatcher;
+  }
+  let rootStack = ErrorStackParser.parse(ancestorStackError);
+  return buildTree(rootStack, readHookLog);
+}
+
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    // Resolve default props. Taken from ReactElement
+    const props = Object.assign({}, baseProps);
+    const defaultProps = Component.defaultProps;
+    for (let propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
+  }
+  return baseProps;
+}
+
+export function inspectHooksOfFiber(fiber: Fiber) {
+  if (
+    fiber.tag !== FunctionComponent &&
+    fiber.tag !== SimpleMemoComponent &&
+    fiber.tag !== ForwardRef
+  ) {
+    throw new Error(
+      'Unknown Fiber. Needs to be a function component to inspect hooks.',
+    );
+  }
+  // Warm up the cache so that it doesn't consume the currentHook.
+  getPrimitiveStackCache();
+  let type = fiber.type;
+  let props = fiber.memoizedProps;
+  if (type !== fiber.elementType) {
+    props = resolveDefaultProps(type, props);
+  }
+  // Set up the current hook so that we can step through and read the
+  // current state from them.
+  currentHook = (fiber.memoizedState: Hook);
+  let contextMap = new Map();
+  try {
+    setupContexts(contextMap, fiber);
+    if (fiber.tag === ForwardRef) {
+      return inspectHooksOfForwardRef(type.render, props, fiber.ref);
+    }
+    return inspectHooks(type, props);
+  } finally {
+    currentHook = null;
+    restoreContexts(contextMap);
+  }
+}

commit c2a2d8a539bf02e40c43d36adc2826e228f30955
Author: Sophie Alpert <git@sophiebits.com>
Date:   Tue Nov 27 13:05:13 2018 -0800

    Remove useMutationEffect (#14336)
    
    useMutationEffect has problems (namely, refs aren't attached at the time that it runs) and we're not positive it's necessary. useLayoutEffect runs at the same time as componentDidMount/Update so it's sufficient for all existing use cases; it can be used in any case that useEffect happens too late. Until we figure out what we want to do, let's delete it.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 61d468bd07..1132834e73 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -52,7 +52,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useState(null);
       Dispatcher.useReducer((s, a) => s, null);
       Dispatcher.useRef(null);
-      Dispatcher.useMutationEffect(() => {});
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeMethods(undefined, () => null);
@@ -140,18 +139,6 @@ function useRef<T>(initialValue: T): {current: T} {
   return ref;
 }
 
-function useMutationEffect(
-  create: () => mixed,
-  inputs: Array<mixed> | void | null,
-): void {
-  nextHook();
-  hookLog.push({
-    primitive: 'MutationEffect',
-    stackError: new Error(),
-    value: create,
-  });
-}
-
 function useLayoutEffect(
   create: () => mixed,
   inputs: Array<mixed> | void | null,
@@ -221,7 +208,6 @@ const Dispatcher = {
   useImperativeMethods,
   useLayoutEffect,
   useMemo,
-  useMutationEffect,
   useReducer,
   useRef,
   useState,

commit 19ef0ec116a2c5fd1a8dc86d38c2185d62abc6a1
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Jan 8 14:39:52 2019 -0800

    Separate current owner and dispatcher (#14548)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1132834e73..b3283b1021 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,7 +20,7 @@ import {
   ForwardRef,
 } from 'shared/ReactWorkTags';
 
-const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
+const ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
 
 // Used to track hooks called during a render
 
@@ -409,9 +409,9 @@ export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
 ): HooksTree {
-  let previousDispatcher = ReactCurrentOwner.currentDispatcher;
+  let previousDispatcher = ReactCurrentDispatcher.current;
   let readHookLog;
-  ReactCurrentOwner.currentDispatcher = Dispatcher;
+  ReactCurrentDispatcher.current = Dispatcher;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -419,7 +419,7 @@ export function inspectHooks<Props>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    ReactCurrentOwner.currentDispatcher = previousDispatcher;
+    ReactCurrentDispatcher.current = previousDispatcher;
   }
   let rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
@@ -451,9 +451,9 @@ function inspectHooksOfForwardRef<Props, Ref>(
   props: Props,
   ref: Ref,
 ): HooksTree {
-  let previousDispatcher = ReactCurrentOwner.currentDispatcher;
+  let previousDispatcher = ReactCurrentDispatcher.current;
   let readHookLog;
-  ReactCurrentOwner.currentDispatcher = Dispatcher;
+  ReactCurrentDispatcher.current = Dispatcher;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -461,7 +461,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    ReactCurrentOwner.currentDispatcher = previousDispatcher;
+    ReactCurrentDispatcher.current = previousDispatcher;
   }
   let rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);

commit b4ad8e947150a1a0b486a388e2d4762d3eee51ee
Author: Sunil Pai <threepointone@oculus.com>
Date:   Thu Jan 10 13:37:50 2019 +0000

    rename useImperativeMethods -> useImperativeHandle (#14565)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b3283b1021..9b5a3b4994 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -54,7 +54,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useRef(null);
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useEffect(() => {});
-      Dispatcher.useImperativeMethods(undefined, () => null);
+      Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useCallback(() => {});
       Dispatcher.useMemo(() => null);
     } finally {
@@ -159,7 +159,7 @@ function useEffect(
   hookLog.push({primitive: 'Effect', stackError: new Error(), value: create});
 }
 
-function useImperativeMethods<T>(
+function useImperativeHandle<T>(
   ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
   create: () => T,
   inputs: Array<mixed> | void | null,
@@ -174,7 +174,7 @@ function useImperativeMethods<T>(
     instance = ref.current;
   }
   hookLog.push({
-    primitive: 'ImperativeMethods',
+    primitive: 'ImperativeHandle',
     stackError: new Error(),
     value: instance,
   });
@@ -205,7 +205,7 @@ const Dispatcher = {
   useCallback,
   useContext,
   useEffect,
-  useImperativeMethods,
+  useImperativeHandle,
   useLayoutEffect,
   useMemo,
   useReducer,

commit f290138d329aa7aa635d88868705b23372e9f004
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Jan 10 12:56:52 2019 -0800

    react-debug-tools accepts currentDispatcher ref as param (#14556)
    
    * react-debug-tools accepts currentDispatcher ref as param
    
    * ReactDebugHooks injected dispatcher ref is optional

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 9b5a3b4994..b00df7e46d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,7 +20,7 @@ import {
   ForwardRef,
 } from 'shared/ReactWorkTags';
 
-const ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
 // Used to track hooks called during a render
 
@@ -408,10 +408,17 @@ function buildTree(rootStack, readHookLog): HooksTree {
 export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
+  currentDispatcher: ?CurrentDispatcherRef,
 ): HooksTree {
-  let previousDispatcher = ReactCurrentDispatcher.current;
+  // DevTools will pass the current renderer's injected dispatcher.
+  // Other apps might compile debug hooks as part of their app though.
+  if (currentDispatcher == null) {
+    currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+  }
+
+  let previousDispatcher = currentDispatcher.current;
   let readHookLog;
-  ReactCurrentDispatcher.current = Dispatcher;
+  currentDispatcher.current = Dispatcher;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -419,7 +426,7 @@ export function inspectHooks<Props>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    ReactCurrentDispatcher.current = previousDispatcher;
+    currentDispatcher.current = previousDispatcher;
   }
   let rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
@@ -450,10 +457,11 @@ function inspectHooksOfForwardRef<Props, Ref>(
   renderFunction: (Props, Ref) => React$Node,
   props: Props,
   ref: Ref,
+  currentDispatcher: CurrentDispatcherRef,
 ): HooksTree {
-  let previousDispatcher = ReactCurrentDispatcher.current;
+  let previousDispatcher = currentDispatcher.current;
   let readHookLog;
-  ReactCurrentDispatcher.current = Dispatcher;
+  currentDispatcher.current = Dispatcher;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -461,7 +469,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    ReactCurrentDispatcher.current = previousDispatcher;
+    currentDispatcher.current = previousDispatcher;
   }
   let rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
@@ -482,7 +490,16 @@ function resolveDefaultProps(Component, baseProps) {
   return baseProps;
 }
 
-export function inspectHooksOfFiber(fiber: Fiber) {
+export function inspectHooksOfFiber(
+  fiber: Fiber,
+  currentDispatcher: ?CurrentDispatcherRef,
+) {
+  // DevTools will pass the current renderer's injected dispatcher.
+  // Other apps might compile debug hooks as part of their app though.
+  if (currentDispatcher == null) {
+    currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+  }
+
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
@@ -506,9 +523,14 @@ export function inspectHooksOfFiber(fiber: Fiber) {
   try {
     setupContexts(contextMap, fiber);
     if (fiber.tag === ForwardRef) {
-      return inspectHooksOfForwardRef(type.render, props, fiber.ref);
+      return inspectHooksOfForwardRef(
+        type.render,
+        props,
+        fiber.ref,
+        currentDispatcher,
+      );
     }
-    return inspectHooks(type, props);
+    return inspectHooks(type, props, currentDispatcher);
   } finally {
     currentHook = null;
     restoreContexts(contextMap);

commit edb1f595649b013a59a18f43c03a57035ddea19e
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Mon Jan 14 14:53:22 2019 -0800

    Support configurable labels for custom hooks (#14559)
    
    * react-debug-tools accepts currentDispatcher ref as param
    
    * ReactDebugHooks injected dispatcher ref is optional
    
    * Support custom values for custom hooks
    
    * PR feedback:
    
    1. Renamed useDebugValueLabel hook to useDebugValue
    2. Wrapped useDebugValue internals in if-DEV so that it could be removed from production builds.
    
    * PR feedback:
    
    1. Fixed some minor typos
    2. Added inline comment explaining the purpose of  rollupDebugValues()
    3. Refactored rollupDebugValues() to use a for loop rather than filter()
    4. Improve check for useDebugValue hook to lessen the chance of a false positive
    5. Added optional formatter function param to useDebugValue
    
    * Nitpick renamed a method

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b00df7e46d..1256c8fa83 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -55,6 +55,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
+      Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
       Dispatcher.useMemo(() => null);
     } finally {
@@ -180,6 +181,14 @@ function useImperativeHandle<T>(
   });
 }
 
+function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
+  hookLog.push({
+    primitive: 'DebugValue',
+    stackError: new Error(),
+    value: typeof formatterFn === 'function' ? formatterFn(value) : value,
+  });
+}
+
 function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
   let hook = nextHook();
   hookLog.push({
@@ -206,6 +215,7 @@ const Dispatcher = {
   useContext,
   useEffect,
   useImperativeHandle,
+  useDebugValue,
   useLayoutEffect,
   useMemo,
   useReducer,
@@ -388,7 +398,7 @@ function buildTree(rootStack, readHookLog): HooksTree {
         let children = [];
         levelChildren.push({
           name: parseCustomHookName(stack[j - 1].functionName),
-          value: undefined, // TODO: Support custom inspectable values.
+          value: undefined,
           subHooks: children,
         });
         stackOfChildren.push(levelChildren);
@@ -402,9 +412,47 @@ function buildTree(rootStack, readHookLog): HooksTree {
       subHooks: [],
     });
   }
+
+  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
+  processDebugValues(rootChildren, null);
+
   return rootChildren;
 }
 
+// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
+// That hook adds user-provided values to the hooks tree,
+// but these values aren't intended to appear alongside of the other hooks.
+// Instead they should be attributed to their parent custom hook.
+// This method walks the tree and assigns debug values to their custom hook owners.
+function processDebugValues(
+  hooksTree: HooksTree,
+  parentHooksNode: HooksNode | null,
+): void {
+  let debugValueHooksNodes: Array<HooksNode> = [];
+
+  for (let i = 0; i < hooksTree.length; i++) {
+    const hooksNode = hooksTree[i];
+    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {
+      hooksTree.splice(i, 1);
+      i--;
+      debugValueHooksNodes.push(hooksNode);
+    } else {
+      processDebugValues(hooksNode.subHooks, hooksNode);
+    }
+  }
+
+  // Bubble debug value labels to their custom hook owner.
+  // If there is no parent hook, just ignore them for now.
+  // (We may warn about this in the future.)
+  if (parentHooksNode !== null) {
+    if (debugValueHooksNodes.length === 1) {
+      parentHooksNode.value = debugValueHooksNodes[0].value;
+    } else if (debugValueHooksNodes.length > 1) {
+      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);
+    }
+  }
+}
+
 export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,

commit 7ab8a8e979ff47296d381f71605187f358f96697
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 16 12:49:31 2019 -0800

    Added Flow type to keep hooks dispatchers in-sync (#14599)
    
    * Added Flow type to keep hooks dispatchers in-sync

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1256c8fa83..b53fab87d4 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -10,6 +10,7 @@
 import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
+import typeof {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberDispatcher';
 
 import ErrorStackParser from 'error-stack-parser';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
@@ -209,7 +210,7 @@ function useMemo<T>(
   return value;
 }
 
-const Dispatcher = {
+const Dispatcher: DispatcherType = {
   readContext,
   useCallback,
   useContext,

commit cb1ff430e8c473a8a6bddd592106891251bbf5bf
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jan 29 16:32:15 2019 -0800

    Phased dispatcher (#14701)
    
    * Move DEV-only function right above where it's used
    
    I don't like looking at this top-level function #petty
    
    * Use different dispatchers for functions & classes
    
    Classes support readContext, but not any of the other dispatcher
    methods. Function support all methods.
    
    This is a more robust version of our previous strategy of checking
    whether `currentlyRenderingFiber` is null.
    
    As a next step, we can use a separate dispatcher for each phase of the
    render cycle (mount versus update).
    
    * Use separate dispatchers for mount and update
    
    * Remove mount code from update path
    
    Deletes mount-specific code from the update path, since it should be
    unreachable. To continue supporting progressive enhancement (mounting
    new hooks at the end of the list), we detect when there are no more
    current hooks and switch back to the mount dispatcher. Progressive
    enhancement isn't officially supported yet, so it will continue to warn.
    
    * Factoring nits
    
    * Fix Flow
    
    Had to cheat more than I would like
    
    * More Flow nits
    
    * Switch back to using a special dispatcher for nested hooks in DEV
    
    In order for this strategy to work, I had to revert progressive
    enhancement support (appending hooks to the end). It was previously a
    warning but now it results in an error. We'll reconsider later.
    
    * Always pass args to updateState and updateReducer
    
    Even though the extra args are only used on mount, to ensure
    type consistency.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b53fab87d4..426d20a132 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -10,7 +10,7 @@
 import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
-import typeof {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberDispatcher';
+import type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberHooks';
 
 import ErrorStackParser from 'error-stack-parser';
 import ReactSharedInternals from 'shared/ReactSharedInternals';

commit ba6477aa3cc0b189f4c9b805bf20edb2a2d94e91
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jan 29 17:39:24 2019 -0800

    Improve Reducer Hook's lazy init API (#14723)
    
    * Improve Reducer Hook's lazy init API
    
    * Use generic type for initilizer input
    
    Still requires an `any` cast in the case where `init` function is
    not provided.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 426d20a132..63d53b8508 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -115,13 +115,18 @@ function useState<S>(
   return [state, (action: BasicStateAction<S>) => {}];
 }
 
-function useReducer<S, A>(
+function useReducer<S, I, A>(
   reducer: (S, A) => S,
-  initialState: S,
-  initialAction: A | void | null,
+  initialArg: I,
+  init?: I => S,
 ): [S, Dispatch<A>] {
   let hook = nextHook();
-  let state = hook !== null ? hook.memoizedState : initialState;
+  let state;
+  if (hook !== null) {
+    state = hook.memoizedState;
+  } else {
+    state = init !== undefined ? init(initialArg) : ((initialArg: any): S);
+  }
   hookLog.push({
     primitive: 'Reducer',
     stackError: new Error(),

commit 66eb29374239945c3a512a88aa2480637f62e5cc
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jan 31 10:11:47 2019 -0800

    Restrict effect return type to a function or nothing (#14119)
    
    * Restrict effect return type to a function or nothing
    
    We already warn in dev if the wrong type is returned. This updates the
    Flow type.
    
    * Restrict return type further
    
    * Assume Effect hook returns either a function or undefined
    
    * Tweak warning message

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 63d53b8508..2dc1ddb02c 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -147,7 +147,7 @@ function useRef<T>(initialValue: T): {current: T} {
 }
 
 function useLayoutEffect(
-  create: () => mixed,
+  create: () => (() => void) | void,
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
@@ -159,7 +159,7 @@ function useLayoutEffect(
 }
 
 function useEffect(
-  create: () => mixed,
+  create: () => (() => void) | void,
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();

commit bb2939ccc23c9895d798f889d9c32848be43225e
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Feb 28 14:37:55 2019 -0800

    Support editable useState hooks in DevTools (#14906)
    
    * ReactDebugHooks identifies State and Reducer hooks as editable
    * Inject overrideHookState() method to DevTools to support editing in DEV builds
    * Added an integration test for React DevTools, react-debug-tools, and overrideHookState

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2dc1ddb02c..12e3021d8a 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -232,6 +232,8 @@ const Dispatcher: DispatcherType = {
 // Inspect
 
 type HooksNode = {
+  id: number | null,
+  isStateEditable: boolean,
   name: string,
   value: mixed,
   subHooks: Array<HooksNode>,
@@ -373,6 +375,7 @@ function buildTree(rootStack, readHookLog): HooksTree {
   let rootChildren = [];
   let prevStack = null;
   let levelChildren = rootChildren;
+  let nativeHookID = 0;
   let stackOfChildren = [];
   for (let i = 0; i < readHookLog.length; i++) {
     let hook = readHookLog[i];
@@ -403,6 +406,8 @@ function buildTree(rootStack, readHookLog): HooksTree {
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
         let children = [];
         levelChildren.push({
+          id: null,
+          isStateEditable: false,
           name: parseCustomHookName(stack[j - 1].functionName),
           value: undefined,
           subHooks: children,
@@ -412,8 +417,22 @@ function buildTree(rootStack, readHookLog): HooksTree {
       }
       prevStack = stack;
     }
+    const {primitive} = hook;
+
+    // For now, the "id" of stateful hooks is just the stateful hook index.
+    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
+    const id =
+      primitive === 'Context' || primitive === 'DebugValue'
+        ? null
+        : nativeHookID++;
+
+    // For the time being, only State and Reducer hooks support runtime overrides.
+    const isStateEditable = primitive === 'Reducer' || primitive === 'State';
+
     levelChildren.push({
-      name: hook.primitive,
+      id,
+      isStateEditable,
+      name: primitive,
       value: hook.value,
       subHooks: [],
     });

commit 720db4cbe675e80820ec81abab499492309b9252
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Fri Jun 21 03:12:40 2019 +0100

    [Flare] Add useEvent hook implementation (#15927)
    
    * [Flare] Add useEvent hook implementation
    
    Validate hooks have decendent event components
    
    Few fixes and displayName changes
    
    Fix more responder bugs
    
    Update error codes
    
    * Add another test
    
    * Address feedback

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 12e3021d8a..2e029d382e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -215,6 +215,10 @@ function useMemo<T>(
   return value;
 }
 
+function useEvent() {
+  throw new Error('TODO: not yet implemented');
+}
+
 const Dispatcher: DispatcherType = {
   readContext,
   useCallback,
@@ -227,6 +231,7 @@ const Dispatcher: DispatcherType = {
   useReducer,
   useRef,
   useState,
+  useEvent,
 };
 
 // Inspect

commit 509889119360ed83ca6ef3f83bcf01e5aa7dcd81
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Jul 23 23:46:44 2019 +0100

    [Flare] Redesign core event system (#16163)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2e029d382e..b49813d708 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -215,7 +215,7 @@ function useMemo<T>(
   return value;
 }
 
-function useEvent() {
+function useListener() {
   throw new Error('TODO: not yet implemented');
 }
 
@@ -231,7 +231,7 @@ const Dispatcher: DispatcherType = {
   useReducer,
   useRef,
   useState,
-  useEvent,
+  useListener,
 };
 
 // Inspect

commit 5b08f7b43fed206c66988f852ba36f0f0e7ffa13
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Jul 25 16:55:39 2019 +0100

    [Flare] Adds useListener implementation to ReactDebugHooks (#16205)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b49813d708..1de7794bbe 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -7,7 +7,11 @@
  * @flow
  */
 
-import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
+import type {
+  ReactContext,
+  ReactProviderType,
+  ReactEventResponder,
+} from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
 import type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberHooks';
@@ -21,6 +25,8 @@ import {
   ForwardRef,
 } from 'shared/ReactWorkTags';
 
+const emptyObject = {};
+
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
 // Used to track hooks called during a render
@@ -215,8 +221,17 @@ function useMemo<T>(
   return value;
 }
 
-function useListener() {
-  throw new Error('TODO: not yet implemented');
+function useListener(
+  responder: ReactEventResponder<any, any>,
+  hookProps: ?Object,
+): void {
+  const listenerProps = hookProps || emptyObject;
+  // Don't put the actual event responder object in, just its displayName
+  const value = {
+    responder: responder.displayName || 'EventResponder',
+    props: listenerProps,
+  };
+  hookLog.push({primitive: 'Listener', stackError: new Error(), value});
 }
 
 const Dispatcher: DispatcherType = {

commit 42794557ca44a8c05c71aab698d44d1294236538
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Aug 1 19:08:54 2019 +0100

    [Flare] Tweaks to Flare system design and API (#16264)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1de7794bbe..c4a65ac5ba 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -11,6 +11,7 @@ import type {
   ReactContext,
   ReactProviderType,
   ReactEventResponder,
+  ReactEventResponderListener,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
@@ -25,8 +26,6 @@ import {
   ForwardRef,
 } from 'shared/ReactWorkTags';
 
-const emptyObject = {};
-
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
 // Used to track hooks called during a render
@@ -221,17 +220,20 @@ function useMemo<T>(
   return value;
 }
 
-function useListener(
+function useResponder(
   responder: ReactEventResponder<any, any>,
-  hookProps: ?Object,
-): void {
-  const listenerProps = hookProps || emptyObject;
+  listenerProps: Object,
+): ReactEventResponderListener<any, any> {
   // Don't put the actual event responder object in, just its displayName
   const value = {
     responder: responder.displayName || 'EventResponder',
     props: listenerProps,
   };
-  hookLog.push({primitive: 'Listener', stackError: new Error(), value});
+  hookLog.push({primitive: 'Responder', stackError: new Error(), value});
+  return {
+    responder,
+    props: listenerProps,
+  };
 }
 
 const Dispatcher: DispatcherType = {
@@ -246,7 +248,7 @@ const Dispatcher: DispatcherType = {
   useReducer,
   useRef,
   useState,
-  useListener,
+  useResponder,
 };
 
 // Inspect

commit edc46d7be7ce8fff2b5c21a00eb6741efbb9ef42
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Tue Aug 13 17:53:28 2019 -0700

    Misc Flow and import fixes
    
    1. Fixed all reported Flow errors
    2. Added a few missing package declarations
    3. Deleted ReactDebugHooks fork in favor of react-debug-tools

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c4a65ac5ba..994745b8a7 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -253,14 +253,14 @@ const Dispatcher: DispatcherType = {
 
 // Inspect
 
-type HooksNode = {
+export type HooksNode = {
   id: number | null,
   isStateEditable: boolean,
   name: string,
   value: mixed,
   subHooks: Array<HooksNode>,
 };
-type HooksTree = Array<HooksNode>;
+export type HooksTree = Array<HooksNode>;
 
 // Don't assume
 //

commit 685ed561f22ea062281a4c570c7067e6020457c4
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Fri Oct 18 12:48:43 2019 -0700

    Migrate useDeferredValue and useTransition (#17058)
    
    Migrated useDeferredValue and useTransition from Facebook's www repo into ReactFiberHooks.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 994745b8a7..07e94cd720 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -14,8 +14,9 @@ import type {
   ReactEventResponderListener,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
-import type {Hook} from 'react-reconciler/src/ReactFiberHooks';
+import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
 import type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberHooks';
+import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig';
 
 import ErrorStackParser from 'error-stack-parser';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
@@ -236,6 +237,28 @@ function useResponder(
   };
 }
 
+function useTransition(
+  config: SuspenseConfig | null | void,
+): [(() => void) => void, boolean] {
+  nextHook();
+  hookLog.push({
+    primitive: 'Transition',
+    stackError: new Error(),
+    value: config,
+  });
+  return [callback => {}, false];
+}
+
+function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
+  nextHook();
+  hookLog.push({
+    primitive: 'DeferredValue',
+    stackError: new Error(),
+    value,
+  });
+  return value;
+}
+
 const Dispatcher: DispatcherType = {
   readContext,
   useCallback,
@@ -249,6 +272,8 @@ const Dispatcher: DispatcherType = {
   useRef,
   useState,
   useResponder,
+  useTransition,
+  useDeferredValue,
 };
 
 // Inspect

commit 7dc9745427046d462506e9788878ba389e176b8a
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Dec 18 18:25:43 2019 +0000

    [Flight] Chunks API (#17398)
    
    * Add feature flags
    
    * Add Chunk type and constructor
    
    * Wire up Chunk support in the reconciler
    
    * Update reconciler to reconcile Chunks against the render method
    
    This allows the query and args to be updated.
    
    * Drop the ref. Chunks cannot have refs anyway.
    
    * Add Chunk checks in more missing cases
    
    * Rename secondArg
    
    * Add test and fix lazy chunks
    
    Not really a supported use case but for consistency I guess.
    
    * Fix fragment test

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 07e94cd720..34c3e43b81 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -25,6 +25,7 @@ import {
   SimpleMemoComponent,
   ContextProvider,
   ForwardRef,
+  Chunk,
 } from 'shared/ReactWorkTags';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
@@ -623,7 +624,8 @@ export function inspectHooksOfFiber(
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
-    fiber.tag !== ForwardRef
+    fiber.tag !== ForwardRef &&
+    fiber.tag !== Chunk
   ) {
     throw new Error(
       'Unknown Fiber. Needs to be a function component to inspect hooks.',

commit b979db4e7215957f03c4221622f0b115a868439a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 13:54:11 2020 +0000

    Bump Prettier (#17811)
    
    * Bump Prettier
    
    * Reformat
    
    * Use non-deprecated option

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 34c3e43b81..0ff4d4278b 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -116,8 +116,8 @@ function useState<S>(
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
-        ? initialState()
-        : initialState;
+      ? initialState()
+      : initialState;
   hookLog.push({primitive: 'State', stackError: new Error(), value: state});
   return [state, (action: BasicStateAction<S>) => {}];
 }

commit e706721490e50d0bd6af2cd933dbf857fd8b61ed
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 14:50:44 2020 +0000

    Update Flow to 0.84 (#17805)
    
    * Update Flow to 0.84
    
    * Fix violations
    
    * Use inexact object syntax in files from fbsource
    
    * Fix warning extraction to use a modern parser
    
    * Codemod inexact objects to new syntax
    
    * Tighten types that can be exact
    
    * Revert unintentional formatting changes from codemod

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 0ff4d4278b..26011eb894 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -36,6 +36,7 @@ type HookLogEntry = {
   primitive: string,
   stackError: Error,
   value: mixed,
+  ...
 };
 
 let hookLog: Array<HookLogEntry> = [];
@@ -142,7 +143,7 @@ function useReducer<S, I, A>(
   return [state, (action: A) => {}];
 }
 
-function useRef<T>(initialValue: T): {current: T} {
+function useRef<T>(initialValue: T): {|current: T|} {
   let hook = nextHook();
   let ref = hook !== null ? hook.memoizedState : {current: initialValue};
   hookLog.push({
@@ -174,7 +175,7 @@ function useEffect(
 }
 
 function useImperativeHandle<T>(
-  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
+  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
   create: () => T,
   inputs: Array<mixed> | void | null,
 ): void {
@@ -285,6 +286,7 @@ export type HooksNode = {
   name: string,
   value: mixed,
   subHooks: Array<HooksNode>,
+  ...
 };
 export type HooksTree = Array<HooksNode>;
 

commit 6faf6f5eb1705eef39a1d762d6ee381930f36775
Author: Nicolas Gallagher <necolas@fb.com>
Date:   Fri Jan 24 10:52:38 2020 -0800

    Update to flow 0.97 (#17892)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 26011eb894..99f7ae8905 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -117,7 +117,8 @@ function useState<S>(
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
-      ? initialState()
+      ? // $FlowFixMe: Flow doesn't like mixed types
+        initialState()
       : initialState;
   hookLog.push({primitive: 'State', stackError: new Error(), value: state});
   return [state, (action: BasicStateAction<S>) => {}];

commit 65bbda7f169394005252b46a5992ece5a2ffadad
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 20 23:56:40 2020 -0800

    Rename Chunks API to Blocks (#18086)
    
    Sounds like this is the name we're going with. This also helps us
    distinguish it from other "chunking" implementation details.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 99f7ae8905..d515bac08e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -25,7 +25,7 @@ import {
   SimpleMemoComponent,
   ContextProvider,
   ForwardRef,
-  Chunk,
+  Block,
 } from 'shared/ReactWorkTags';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
@@ -628,7 +628,7 @@ export function inspectHooksOfFiber(
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
     fiber.tag !== ForwardRef &&
-    fiber.tag !== Chunk
+    fiber.tag !== Block
   ) {
     throw new Error(
       'Unknown Fiber. Needs to be a function component to inspect hooks.',

commit e1c7e651feb7d8f0339db5720cfb61b036ee7290
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed Feb 26 09:28:35 2020 -0800

    Update ReactDebugHooks to handle composite hooks (#18130)
    
    The useState hook has always composed the useReducer hook. 1:1 composition like this is fine.
    
    But some more recent hooks (e.g. useTransition, useDeferredValue) compose multiple hooks internally. This breaks react-debug-tools because it causes off-by-N errors when the debug tools re-renders the function.
    
    For example, if a component were to use the useTransition and useMemo hooks, the normal hooks dispatcher would create a list of first state, then callback, then memo hooks, but the debug tools package would expect a list of transition then memo. This can break user code and cause runtime errors in both the react-debug-tools package and in product code.
    
    This PR fixes the currently broken hooks by updating debug tools to be aware of the composite hooks (how many times it should call nextHook essentially) and adds tests to make sure they don't get out of sync again. We'll need to add similar tests for future composite hooks (like useMutableSource #18000).

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index d515bac08e..c2d3ed0a2a 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -243,7 +243,11 @@ function useResponder(
 function useTransition(
   config: SuspenseConfig | null | void,
 ): [(() => void) => void, boolean] {
-  nextHook();
+  // useTransition() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // State
+  nextHook(); // Callback
   hookLog.push({
     primitive: 'Transition',
     stackError: new Error(),
@@ -253,7 +257,11 @@ function useTransition(
 }
 
 function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
-  nextHook();
+  // useDeferredValue() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // State
+  nextHook(); // Effect
   hookLog.push({
     primitive: 'DeferredValue',
     stackError: new Error(),

commit 160505b0ca143fa458926b623a05cf2645ba799a
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Mar 10 20:31:12 2020 +0000

    ReactDOM.useEvent: Add more scaffolding for useEvent hook (#18271)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c2d3ed0a2a..db93a50e6f 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -39,6 +39,11 @@ type HookLogEntry = {
   ...
 };
 
+type ReactDebugListenerMap = {|
+  clear: () => void,
+  setListener: (instance: EventTarget, callback: ?(Event) => void) => void,
+|};
+
 let hookLog: Array<HookLogEntry> = [];
 
 // Primitives
@@ -256,6 +261,16 @@ function useTransition(
   return [callback => {}, false];
 }
 
+const noOp = () => {};
+
+function useEvent(event: any): ReactDebugListenerMap {
+  hookLog.push({primitive: 'Event', stackError: new Error(), value: event});
+  return {
+    clear: noOp,
+    setListener: noOp,
+  };
+}
+
 function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
   // useDeferredValue() composes multiple hooks internally.
   // Advance the current hook index the same number of times
@@ -285,6 +300,7 @@ const Dispatcher: DispatcherType = {
   useResponder,
   useTransition,
   useDeferredValue,
+  useEvent,
 };
 
 // Inspect

commit 322cdcd3abfaca985a001a12247f02c5d31d311e
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed Mar 11 12:34:39 2020 -0700

    useMutableSource hook (#18000)
    
    useMutableSource hook
    
    useMutableSource() enables React components to safely and efficiently read from a mutable external source in Concurrent Mode. The API will detect mutations that occur during a render to avoid tearing and it will automatically schedule updates when the source is mutated.
    
    RFC: reactjs/rfcs#147

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index db93a50e6f..ae7c0b87d3 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -8,6 +8,9 @@
  */
 
 import type {
+  MutableSource,
+  MutableSourceGetSnapshotFn,
+  MutableSourceSubscribeFn,
   ReactContext,
   ReactProviderType,
   ReactEventResponder,
@@ -72,6 +75,16 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
       Dispatcher.useMemo(() => null);
+      Dispatcher.useMutableSource(
+        {
+          _source: {},
+          _getVersion: () => 1,
+          _workInProgressVersionPrimary: null,
+          _workInProgressVersionSecondary: null,
+        },
+        () => null,
+        () => () => {},
+      );
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -229,6 +242,23 @@ function useMemo<T>(
   return value;
 }
 
+function useMutableSource<Source, Snapshot>(
+  source: MutableSource<Source>,
+  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
+  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+): Snapshot {
+  // useMutableSource() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // MutableSource
+  nextHook(); // State
+  nextHook(); // Effect
+  nextHook(); // Effect
+  const value = getSnapshot(source._source);
+  hookLog.push({primitive: 'MutableSource', stackError: new Error(), value});
+  return value;
+}
+
 function useResponder(
   responder: ReactEventResponder<any, any>,
   listenerProps: Object,
@@ -299,6 +329,7 @@ const Dispatcher: DispatcherType = {
   useState,
   useResponder,
   useTransition,
+  useMutableSource,
   useDeferredValue,
   useEvent,
 };

commit 99d271228dc0831c9d613bab20032081a286e1c0
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Mar 12 09:12:06 2020 +0000

    ReactDOM.useEvent: more scaffolding changes (#18282)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index ae7c0b87d3..17b4b43263 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -44,7 +44,7 @@ type HookLogEntry = {
 
 type ReactDebugListenerMap = {|
   clear: () => void,
-  setListener: (instance: EventTarget, callback: ?(Event) => void) => void,
+  setListener: (target: EventTarget, callback: ?(Event) => void) => void,
 |};
 
 let hookLog: Array<HookLogEntry> = [];

commit c5d2fc7127654e43de59fff865b74765a103c4a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 21 15:22:01 2020 -0700

    Move some files out of /shared and rename to upper case (#18363)
    
    * Rename lower case isomorphic default exports modules to upper case named exports
    
    We're somewhat inconsistent here between e.g. ReactLazy and memo.
    
    Let's pick one.
    
    This also moves the responder, fundamental, scope creators from shared
    since they're isomorphic and same as the other creators.
    
    * Move some files that are specific to the react-reconciler from shared
    
    Individual renderers are allowed to deep require into the reconciler.
    
    * Move files specific to react-dom from shared
    
    react-interactions is right now dom specific (it wasn't before) so we can
    type check it together with other dom stuff. Avoids the need for
    a shared ReactDOMTypes to be checked by RN for example.
    
    * Move ReactWorkTags to the reconciler
    
    * Move createPortal to export from reconciler
    
    Otherwise Noop can't access it since it's not allowed deep requires.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 17b4b43263..175b51485d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -29,7 +29,7 @@ import {
   ContextProvider,
   ForwardRef,
   Block,
-} from 'shared/ReactWorkTags';
+} from 'react-reconciler/src/ReactWorkTags';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 

commit a16b34974508cd23ce0844ad09a0e37a879d5591
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Mar 26 13:29:54 2020 +0000

    ReactDOM.useEvent: Add support for experimental scopes API (#18375)
    
    * ReactDOM.useEvent: Add support for experimental scopes API

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 175b51485d..a338dd0526 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -15,6 +15,7 @@ import type {
   ReactProviderType,
   ReactEventResponder,
   ReactEventResponderListener,
+  ReactScopeMethods,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
@@ -44,7 +45,10 @@ type HookLogEntry = {
 
 type ReactDebugListenerMap = {|
   clear: () => void,
-  setListener: (target: EventTarget, callback: ?(Event) => void) => void,
+  setListener: (
+    target: EventTarget | ReactScopeMethods,
+    callback: ?(Event) => void,
+  ) => void,
 |};
 
 let hookLog: Array<HookLogEntry> = [];

commit 90e90ac8e0d16113b9566ef5feea3da11e5f4458
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 30 19:16:28 2020 -0700

    Revert useEvent PRs (#18438)
    
    * Revert "ReactDOM.useEvent: enable on internal www and add inspection test (#18395)"
    
    This reverts commit e0ab1a429d178d86e13f073f8451d24033bc1838.
    
    * Revert "ReactDOM.useEvent: Add support for experimental scopes API (#18375)"
    
    This reverts commit a16b34974508cd23ce0844ad09a0e37a879d5591.
    
    * ReactDOM.useEvent: Add support for experimental scopes API

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a338dd0526..175b51485d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -15,7 +15,6 @@ import type {
   ReactProviderType,
   ReactEventResponder,
   ReactEventResponderListener,
-  ReactScopeMethods,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
@@ -45,10 +44,7 @@ type HookLogEntry = {
 
 type ReactDebugListenerMap = {|
   clear: () => void,
-  setListener: (
-    target: EventTarget | ReactScopeMethods,
-    callback: ?(Event) => void,
-  ) => void,
+  setListener: (target: EventTarget, callback: ?(Event) => void) => void,
 |};
 
 let hookLog: Array<HookLogEntry> = [];

commit dc3c6c9565ba1710c89c2072b6d809cee8abd40c
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed Apr 1 12:45:26 2020 +0100

    ReactDOM.useEvent: revert and add guard for null stateNode (#18441)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 175b51485d..a338dd0526 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -15,6 +15,7 @@ import type {
   ReactProviderType,
   ReactEventResponder,
   ReactEventResponderListener,
+  ReactScopeMethods,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
 import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
@@ -44,7 +45,10 @@ type HookLogEntry = {
 
 type ReactDebugListenerMap = {|
   clear: () => void,
-  setListener: (target: EventTarget, callback: ?(Event) => void) => void,
+  setListener: (
+    target: EventTarget | ReactScopeMethods,
+    callback: ?(Event) => void,
+  ) => void,
 |};
 
 let hookLog: Array<HookLogEntry> = [];

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a338dd0526..1fab259eb1 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -65,7 +65,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
   if (primitiveStackCache === null) {
-    let cache = new Map();
+    const cache = new Map();
     let readHookLog;
     try {
       // Use all hooks here to add them to the hook log.
@@ -94,7 +94,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       hookLog = [];
     }
     for (let i = 0; i < readHookLog.length; i++) {
-      let hook = readHookLog[i];
+      const hook = readHookLog[i];
       cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));
     }
     primitiveStackCache = cache;
@@ -104,7 +104,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
 let currentHook: null | Hook = null;
 function nextHook(): null | Hook {
-  let hook = currentHook;
+  const hook = currentHook;
   if (hook !== null) {
     currentHook = hook.next;
   }
@@ -134,8 +134,8 @@ function useContext<T>(
 function useState<S>(
   initialState: (() => S) | S,
 ): [S, Dispatch<BasicStateAction<S>>] {
-  let hook = nextHook();
-  let state: S =
+  const hook = nextHook();
+  const state: S =
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
@@ -151,7 +151,7 @@ function useReducer<S, I, A>(
   initialArg: I,
   init?: I => S,
 ): [S, Dispatch<A>] {
-  let hook = nextHook();
+  const hook = nextHook();
   let state;
   if (hook !== null) {
     state = hook.memoizedState;
@@ -167,8 +167,8 @@ function useReducer<S, I, A>(
 }
 
 function useRef<T>(initialValue: T): {|current: T|} {
-  let hook = nextHook();
-  let ref = hook !== null ? hook.memoizedState : {current: initialValue};
+  const hook = nextHook();
+  const ref = hook !== null ? hook.memoizedState : {current: initialValue};
   hookLog.push({
     primitive: 'Ref',
     stackError: new Error(),
@@ -227,7 +227,7 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
 }
 
 function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
-  let hook = nextHook();
+  const hook = nextHook();
   hookLog.push({
     primitive: 'Callback',
     stackError: new Error(),
@@ -240,8 +240,8 @@ function useMemo<T>(
   nextCreate: () => T,
   inputs: Array<mixed> | void | null,
 ): T {
-  let hook = nextHook();
-  let value = hook !== null ? hook.memoizedState[0] : nextCreate();
+  const hook = nextHook();
+  const value = hook !== null ? hook.memoizedState[0] : nextCreate();
   hookLog.push({primitive: 'Memo', stackError: new Error(), value});
   return value;
 }
@@ -367,7 +367,7 @@ export type HooksTree = Array<HooksNode>;
 let mostLikelyAncestorIndex = 0;
 
 function findSharedIndex(hookStack, rootStack, rootIndex) {
-  let source = rootStack[rootIndex].source;
+  const source = rootStack[rootIndex].source;
   hookSearch: for (let i = 0; i < hookStack.length; i++) {
     if (hookStack[i].source === source) {
       // This looks like a match. Validate that the rest of both stack match up.
@@ -412,7 +412,7 @@ function isReactWrapper(functionName, primitiveName) {
   if (!functionName) {
     return false;
   }
-  let expectedPrimitiveName = 'use' + primitiveName;
+  const expectedPrimitiveName = 'use' + primitiveName;
   if (functionName.length < expectedPrimitiveName.length) {
     return false;
   }
@@ -423,8 +423,8 @@ function isReactWrapper(functionName, primitiveName) {
 }
 
 function findPrimitiveIndex(hookStack, hook) {
-  let stackCache = getPrimitiveStackCache();
-  let primitiveStack = stackCache.get(hook.primitive);
+  const stackCache = getPrimitiveStackCache();
+  const primitiveStack = stackCache.get(hook.primitive);
   if (primitiveStack === undefined) {
     return -1;
   }
@@ -453,9 +453,9 @@ function findPrimitiveIndex(hookStack, hook) {
 function parseTrimmedStack(rootStack, hook) {
   // Get the stack trace between the primitive hook function and
   // the root function call. I.e. the stack frames of custom hooks.
-  let hookStack = ErrorStackParser.parse(hook.stackError);
-  let rootIndex = findCommonAncestorIndex(rootStack, hookStack);
-  let primitiveIndex = findPrimitiveIndex(hookStack, hook);
+  const hookStack = ErrorStackParser.parse(hook.stackError);
+  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);
+  const primitiveIndex = findPrimitiveIndex(hookStack, hook);
   if (
     rootIndex === -1 ||
     primitiveIndex === -1 ||
@@ -482,14 +482,14 @@ function parseCustomHookName(functionName: void | string): string {
 }
 
 function buildTree(rootStack, readHookLog): HooksTree {
-  let rootChildren = [];
+  const rootChildren = [];
   let prevStack = null;
   let levelChildren = rootChildren;
   let nativeHookID = 0;
-  let stackOfChildren = [];
+  const stackOfChildren = [];
   for (let i = 0; i < readHookLog.length; i++) {
-    let hook = readHookLog[i];
-    let stack = parseTrimmedStack(rootStack, hook);
+    const hook = readHookLog[i];
+    const stack = parseTrimmedStack(rootStack, hook);
     if (stack !== null) {
       // Note: The indices 0 <= n < length-1 will contain the names.
       // The indices 1 <= n < length will contain the source locations.
@@ -499,8 +499,9 @@ function buildTree(rootStack, readHookLog): HooksTree {
       if (prevStack !== null) {
         // Compare the current level's stack to the new stack.
         while (commonSteps < stack.length && commonSteps < prevStack.length) {
-          let stackSource = stack[stack.length - commonSteps - 1].source;
-          let prevSource = prevStack[prevStack.length - commonSteps - 1].source;
+          const stackSource = stack[stack.length - commonSteps - 1].source;
+          const prevSource =
+            prevStack[prevStack.length - commonSteps - 1].source;
           if (stackSource !== prevSource) {
             break;
           }
@@ -514,7 +515,7 @@ function buildTree(rootStack, readHookLog): HooksTree {
       // The remaining part of the new stack are custom hooks. Push them
       // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
-        let children = [];
+        const children = [];
         levelChildren.push({
           id: null,
           isStateEditable: false,
@@ -563,7 +564,7 @@ function processDebugValues(
   hooksTree: HooksTree,
   parentHooksNode: HooksNode | null,
 ): void {
-  let debugValueHooksNodes: Array<HooksNode> = [];
+  const debugValueHooksNodes: Array<HooksNode> = [];
 
   for (let i = 0; i < hooksTree.length; i++) {
     const hooksNode = hooksTree[i];
@@ -599,7 +600,7 @@ export function inspectHooks<Props>(
     currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
   }
 
-  let previousDispatcher = currentDispatcher.current;
+  const previousDispatcher = currentDispatcher.current;
   let readHookLog;
   currentDispatcher.current = Dispatcher;
   let ancestorStackError;
@@ -611,7 +612,7 @@ export function inspectHooks<Props>(
     hookLog = [];
     currentDispatcher.current = previousDispatcher;
   }
-  let rootStack = ErrorStackParser.parse(ancestorStackError);
+  const rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
 }
 
@@ -642,7 +643,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   ref: Ref,
   currentDispatcher: CurrentDispatcherRef,
 ): HooksTree {
-  let previousDispatcher = currentDispatcher.current;
+  const previousDispatcher = currentDispatcher.current;
   let readHookLog;
   currentDispatcher.current = Dispatcher;
   let ancestorStackError;
@@ -654,7 +655,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
     hookLog = [];
     currentDispatcher.current = previousDispatcher;
   }
-  let rootStack = ErrorStackParser.parse(ancestorStackError);
+  const rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
 }
 
@@ -663,7 +664,7 @@ function resolveDefaultProps(Component, baseProps) {
     // Resolve default props. Taken from ReactElement
     const props = Object.assign({}, baseProps);
     const defaultProps = Component.defaultProps;
-    for (let propName in defaultProps) {
+    for (const propName in defaultProps) {
       if (props[propName] === undefined) {
         props[propName] = defaultProps[propName];
       }
@@ -695,7 +696,7 @@ export function inspectHooksOfFiber(
   }
   // Warm up the cache so that it doesn't consume the currentHook.
   getPrimitiveStackCache();
-  let type = fiber.type;
+  const type = fiber.type;
   let props = fiber.memoizedProps;
   if (type !== fiber.elementType) {
     props = resolveDefaultProps(type, props);
@@ -703,7 +704,7 @@ export function inspectHooksOfFiber(
   // Set up the current hook so that we can step through and read the
   // current state from them.
   currentHook = (fiber.memoizedState: Hook);
-  let contextMap = new Map();
+  const contextMap = new Map();
   try {
     setupContexts(contextMap, fiber);
     if (fiber.tag === ForwardRef) {

commit 3278d242184a13add3f25f683b77ef9a6a2305f3
Author: Luna Ruan <luna@fb.com>
Date:   Mon Apr 6 17:17:27 2020 -0700

    Add useOpaqueIdentifier Hook (#17322)
    
    * Add useOpaqueIdentifier Hook
    
    We currently use unique IDs in a lot of places. Examples are:
      * `<label for="ID">`
      * `aria-labelledby`
    
    This can cause some issues:
      1. If we server side render and then hydrate, this could cause an
         hydration ID mismatch
      2. If we server side render one part of the page and client side
         render another part of the page, the ID for one part could be
         different than the ID for another part even though they are
         supposed to be the same
      3. If we conditionally render something with an ID ,  this might also
         cause an ID mismatch because the ID will be different on other
         parts of the page
    
    This PR creates a new hook `useUniqueId` that generates a different
    unique ID based on whether the hook was called on the server or client.
    If the hook is called during hydration, it generates an opaque object
    that will rerender the hook so that the IDs match.
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1fab259eb1..7b34a50394 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -18,12 +18,16 @@ import type {
   ReactScopeMethods,
 } from 'shared/ReactTypes';
 import type {Fiber} from 'react-reconciler/src/ReactFiber';
+import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
+
 import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
 import type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberHooks';
 import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig';
+import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
+import {REACT_OPAQUE_ID_TYPE} from 'shared/ReactSymbols';
 import {
   FunctionComponent,
   SimpleMemoComponent,
@@ -61,6 +65,8 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
+let currentFiber: Fiber | null = null;
+
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
@@ -319,6 +325,23 @@ function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
   return value;
 }
 
+function useOpaqueIdentifier(): OpaqueIDType | void {
+  const hook = nextHook(); // State
+  if (currentFiber && currentFiber.mode === NoMode) {
+    nextHook(); // Effect
+  }
+  let value = hook === null ? undefined : hook.memoizedState;
+  if (value && value.$$typeof === REACT_OPAQUE_ID_TYPE) {
+    value = undefined;
+  }
+  hookLog.push({
+    primitive: 'OpaqueIdentifier',
+    stackError: new Error(),
+    value,
+  });
+  return value;
+}
+
 const Dispatcher: DispatcherType = {
   readContext,
   useCallback,
@@ -336,6 +359,7 @@ const Dispatcher: DispatcherType = {
   useMutableSource,
   useDeferredValue,
   useEvent,
+  useOpaqueIdentifier,
 };
 
 // Inspect
@@ -684,6 +708,8 @@ export function inspectHooksOfFiber(
     currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
   }
 
+  currentFiber = fiber;
+
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&

commit d686f3f16a796025ce32cfb431b70eef6de1934e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 19:44:52 2020 -0700

    Add `.old` prefix to reconciler modules

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 7b34a50394..d794b28782 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -17,12 +17,15 @@ import type {
   ReactEventResponderListener,
   ReactScopeMethods,
 } from 'shared/ReactTypes';
-import type {Fiber} from 'react-reconciler/src/ReactFiber';
+import type {Fiber} from 'react-reconciler/src/ReactFiber.old';
 import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 
-import type {Hook, TimeoutConfig} from 'react-reconciler/src/ReactFiberHooks';
-import type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactFiberHooks';
-import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig';
+import type {
+  Hook,
+  TimeoutConfig,
+  Dispatcher as DispatcherType,
+} from 'react-reconciler/src/ReactFiberHooks.old';
+import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig.old';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';

commit 376d5c1b5aa17724c5fea9412f8fcde14a7b23f1
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 23:48:24 2020 -0700

    Split cross-package types from implementation
    
    Some of our internal reconciler types have leaked into other packages.
    Usually, these types are treated as opaque; we don't read and write
    to its fields. This is good.
    
    However, the type is often passed back to a reconciler method. For
    example, React DOM creates a FiberRoot with `createContainer`, then
    passes that root to `updateContainer`. It doesn't do anything with the
    root except pass it through, but because `updateContainer` expects a
    full FiberRoot, React DOM is still coupled to all its fields.
    
    I don't know if there's an idiomatic way to handle this in Flow. Opaque
    types are simlar, but those only work within a single file. AFAIK,
    there's no way to use a package as the boundary for opaqueness.
    
    The immediate problem this presents is that the reconciler refactor will
    involve changes to our internal data structures. I don't want to have to
    fork every single package that happens to pass through a Fiber or
    FiberRoot, or access any one of its fields. So my current plan is to
    share the same Flow type across both forks. The shared type will be a
    superset of each implementation's type, e.g. Fiber will have both an
    `expirationTime` field and a `lanes` field. The implementations will
    diverge, but not the types.
    
    To do this, I lifted the type definitions into a separate module.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index d794b28782..6489b8f568 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -17,15 +17,13 @@ import type {
   ReactEventResponderListener,
   ReactScopeMethods,
 } from 'shared/ReactTypes';
-import type {Fiber} from 'react-reconciler/src/ReactFiber.old';
-import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
-
 import type {
-  Hook,
-  TimeoutConfig,
+  Fiber,
   Dispatcher as DispatcherType,
-} from 'react-reconciler/src/ReactFiberHooks.old';
-import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig.old';
+} from 'react-reconciler/src/ReactInternalTypes';
+import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
+
+import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
@@ -70,6 +68,15 @@ let primitiveStackCache: null | Map<string, Array<any>> = null;
 
 let currentFiber: Fiber | null = null;
 
+type Hook = {
+  memoizedState: any,
+  next: Hook | null,
+};
+
+type TimeoutConfig = {|
+  timeoutMs: number,
+|};
+
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.

commit d53988a9d108b9480ff161a6e85ca26760ada615
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Apr 14 22:06:46 2020 +0100

    ReactDOM.useEvent: add useEvent interaction hook (#18604)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 6489b8f568..a65c78174d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -52,7 +52,7 @@ type ReactDebugListenerMap = {|
   clear: () => void,
   setListener: (
     target: EventTarget | ReactScopeMethods,
-    callback: ?(Event) => void,
+    callback: ?(SyntheticEvent<EventTarget>) => void,
   ) => void,
 |};
 

commit ff431b7fc43ee9022db094a673afbac7088bcfa2
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Apr 21 16:40:44 2020 +0100

    Remove ReactDOM.useEvent and associated types+tests (#18689)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a65c78174d..c9be0d66f7 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -15,7 +15,6 @@ import type {
   ReactProviderType,
   ReactEventResponder,
   ReactEventResponderListener,
-  ReactScopeMethods,
 } from 'shared/ReactTypes';
 import type {
   Fiber,
@@ -48,14 +47,6 @@ type HookLogEntry = {
   ...
 };
 
-type ReactDebugListenerMap = {|
-  clear: () => void,
-  setListener: (
-    target: EventTarget | ReactScopeMethods,
-    callback: ?(SyntheticEvent<EventTarget>) => void,
-  ) => void,
-|};
-
 let hookLog: Array<HookLogEntry> = [];
 
 // Primitives
@@ -311,16 +302,6 @@ function useTransition(
   return [callback => {}, false];
 }
 
-const noOp = () => {};
-
-function useEvent(event: any): ReactDebugListenerMap {
-  hookLog.push({primitive: 'Event', stackError: new Error(), value: event});
-  return {
-    clear: noOp,
-    setListener: noOp,
-  };
-}
-
 function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
   // useDeferredValue() composes multiple hooks internally.
   // Advance the current hook index the same number of times
@@ -368,7 +349,6 @@ const Dispatcher: DispatcherType = {
   useTransition,
   useMutableSource,
   useDeferredValue,
-  useEvent,
   useOpaqueIdentifier,
 };
 

commit 5227a37868c4bf3133ba5f2b3b39cac9175d7ea9
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Tue Jul 28 12:38:13 2020 -0400

    Add "unstable_" prefix to experimental mutable source APIs (#19472)
    
    * Add "unstbale_" prefix to mutable source APIs
    
    * DebugHooks no longer calls useMutableSource() on init
    
    This was causing an observable behavioral difference between experimental DEV and PROD builds.
    
    We don't initialize stack position for other composite hooks (e.g. useDeferredValue, useTransition, useOpaqueIdentifier). If we did, it would cause the same obesrvable behavioral difference.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c9be0d66f7..4dbaaccbf3 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -86,16 +86,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
       Dispatcher.useMemo(() => null);
-      Dispatcher.useMutableSource(
-        {
-          _source: {},
-          _getVersion: () => 1,
-          _workInProgressVersionPrimary: null,
-          _workInProgressVersionSecondary: null,
-        },
-        () => null,
-        () => () => {},
-      );
     } finally {
       readHookLog = hookLog;
       hookLog = [];

commit b61174fb7b09580c1ec2a8f55e73204b706d2935
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed Aug 5 15:13:29 2020 +0100

    Remove the deprecated React Flare event system (#19520)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 4dbaaccbf3..31e03102b4 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -13,8 +13,6 @@ import type {
   MutableSourceSubscribeFn,
   ReactContext,
   ReactProviderType,
-  ReactEventResponder,
-  ReactEventResponderListener,
 } from 'shared/ReactTypes';
 import type {
   Fiber,
@@ -260,22 +258,6 @@ function useMutableSource<Source, Snapshot>(
   return value;
 }
 
-function useResponder(
-  responder: ReactEventResponder<any, any>,
-  listenerProps: Object,
-): ReactEventResponderListener<any, any> {
-  // Don't put the actual event responder object in, just its displayName
-  const value = {
-    responder: responder.displayName || 'EventResponder',
-    props: listenerProps,
-  };
-  hookLog.push({primitive: 'Responder', stackError: new Error(), value});
-  return {
-    responder,
-    props: listenerProps,
-  };
-}
-
 function useTransition(
   config: SuspenseConfig | null | void,
 ): [(() => void) => void, boolean] {
@@ -335,7 +317,6 @@ const Dispatcher: DispatcherType = {
   useReducer,
   useRef,
   useState,
-  useResponder,
   useTransition,
   useMutableSource,
   useDeferredValue,

commit 92fcd46cc79bbf45df4ce86b0678dcef3b91078d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 28 12:52:56 2020 -0500

    Replace SuspenseConfig object with an integer (#19706)
    
    Now that the options in SuspenseConfig are no longer supported, the
    only thing we use it for is to track whether an update is part of
    a transition.
    
    I've renamed `ReactCurrentBatchConfig.suspense` to
    `ReactCurrentBatchConfig.transition`, and changed the type to a number.
    The number is always either 0 or 1. I could have made it a boolean;
    however, most likely this will eventually be either a Lane or an
    incrementing identifier.
    
    The `withSuspenseConfig` export still exists until we've removed
    all the callers from www.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 31e03102b4..7c6736f5ca 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,7 +20,7 @@ import type {
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 
-import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberSuspenseConfig';
+import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberTransition';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';

commit ddd1faa1972b614dfbfae205f2aa4a6c0b39a759
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 28 13:49:01 2020 -0500

    Remove config argument from useTransition (#19719)
    
    And `useDeferredValue`.
    
    The options were already disabled in previous commits, so this doesn't
    change any behavior. I upated type signatures and cleaned up the hook
    implementation a bit — no longer have to wrap the `start` method with
    `useCallback`, because its only remaining dependency is a `setState`
    method, which never changes. Instead, we can store the `start` method
    on a ref.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 7c6736f5ca..24d74bd309 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,7 +20,6 @@ import type {
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 
-import type {SuspenseConfig} from 'react-reconciler/src/ReactFiberTransition';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
@@ -62,10 +61,6 @@ type Hook = {
   next: Hook | null,
 };
 
-type TimeoutConfig = {|
-  timeoutMs: number,
-|};
-
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
@@ -258,9 +253,7 @@ function useMutableSource<Source, Snapshot>(
   return value;
 }
 
-function useTransition(
-  config: SuspenseConfig | null | void,
-): [(() => void) => void, boolean] {
+function useTransition(): [(() => void) => void, boolean] {
   // useTransition() composes multiple hooks internally.
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.
@@ -269,12 +262,12 @@ function useTransition(
   hookLog.push({
     primitive: 'Transition',
     stackError: new Error(),
-    value: config,
+    value: undefined,
   });
   return [callback => {}, false];
 }
 
-function useDeferredValue<T>(value: T, config: TimeoutConfig | null | void): T {
+function useDeferredValue<T>(value: T): T {
   // useDeferredValue() composes multiple hooks internally.
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.

commit 56e9feead0f91075ba0a4f725c9e4e343bca1c67
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Oct 31 02:03:45 2020 -0400

    Remove Blocks (#20138)
    
    * Remove Blocks
    
    * Remove Flight Server Runtime
    
    There's no need for this now that the JSResource is part of the bundler
    protocol. Might need something for Webpack plugin specifically later.
    
    * Devtools

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 24d74bd309..39f8f5118c 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -30,7 +30,6 @@ import {
   SimpleMemoComponent,
   ContextProvider,
   ForwardRef,
-  Block,
 } from 'react-reconciler/src/ReactWorkTags';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
@@ -667,8 +666,7 @@ export function inspectHooksOfFiber(
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
-    fiber.tag !== ForwardRef &&
-    fiber.tag !== Block
+    fiber.tag !== ForwardRef
   ) {
     throw new Error(
       'Unknown Fiber. Needs to be a function component to inspect hooks.',

commit e23673b511a2eab6ddcb848a4150105c954f289a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 3 03:44:56 2020 +0000

    [Flight] Add getCacheForType() to the dispatcher (#20315)
    
    * Remove react/unstable_cache
    
    We're probably going to make it available via the dispatcher. Let's remove this for now.
    
    * Add readContext() to the dispatcher
    
    On the server, it will be per-request.
    
    On the client, there will be some way to shadow it.
    
    For now, I provide it on the server, and throw on the client.
    
    * Use readContext() from react-fetch
    
    This makes it work on the server (but not on the client until we implement it there.)
    
    Updated the test to use Server Components. Now it passes.
    
    * Fixture: Add fetch from a Server Component
    
    * readCache -> getCacheForType<T>
    
    * Add React.unstable_getCacheForType
    
    * Add a feature flag
    
    * Fix Flow
    
    * Add react-suspense-test-utils and port tests
    
    * Remove extra Map lookup
    
    * Unroll async/await because build system
    
    * Add some error coverage and retry
    
    * Add unstable_getCacheForType to Flight entry

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 39f8f5118c..ce62b5ce8b 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -23,6 +23,7 @@ import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
+import invariant from 'shared/invariant';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import {REACT_OPAQUE_ID_TYPE} from 'shared/ReactSymbols';
 import {
@@ -100,6 +101,10 @@ function nextHook(): null | Hook {
   return hook;
 }
 
+function getCacheForType<T>(resourceType: () => T): T {
+  invariant(false, 'Not implemented.');
+}
+
 function readContext<T>(
   context: ReactContext<T>,
   observedBits: void | number | boolean,
@@ -298,6 +303,7 @@ function useOpaqueIdentifier(): OpaqueIDType | void {
 }
 
 const Dispatcher: DispatcherType = {
+  getCacheForType,
   readContext,
   useCallback,
   useContext,

commit 27659559ebfd6b7119bfc0ff02ecb851c135020c
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Jan 4 07:46:20 2021 -0800

    Add useRefresh hook to react-debug-tools (#20460)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index ce62b5ce8b..eb7a8f6d4e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -73,6 +73,10 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useState(null);
       Dispatcher.useReducer((s, a) => s, null);
       Dispatcher.useRef(null);
+      if (typeof Dispatcher.useCacheRefresh === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useCacheRefresh();
+      }
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
@@ -171,6 +175,16 @@ function useRef<T>(initialValue: T): {|current: T|} {
   return ref;
 }
 
+function useCacheRefresh(): () => void {
+  const hook = nextHook();
+  hookLog.push({
+    primitive: 'CacheRefresh',
+    stackError: new Error(),
+    value: hook !== null ? hook.memoizedState : function refresh() {},
+  });
+  return () => {};
+}
+
 function useLayoutEffect(
   create: () => (() => void) | void,
   inputs: Array<mixed> | void | null,
@@ -305,6 +319,7 @@ function useOpaqueIdentifier(): OpaqueIDType | void {
 const Dispatcher: DispatcherType = {
   getCacheForType,
   readContext,
+  useCacheRefresh,
   useCallback,
   useContext,
   useEffect,

commit 6d3ecb70dceb225af0cd990b46d6c44b852c1d82
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 19 17:36:51 2021 -0500

    Remove unstable_changedBits (#20953)
    
    We added this unstable feature a few years ago, as a way to opt out of
    context updates, but it didn't prove useful in practice.
    
    We have other proposals for how to address the same problem, like
    context selectors.
    
    Since it was prefixed with `unstable_`, we should be able to remove it
    without consequence. The hook API already warned if you used it.
    
    Even if someone is using it somewhere, it's meant to be an optimization
    only, so if they are using the API properly, it should not have any
    semantic impact.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index eb7a8f6d4e..d78f629374 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -109,18 +109,12 @@ function getCacheForType<T>(resourceType: () => T): T {
   invariant(false, 'Not implemented.');
 }
 
-function readContext<T>(
-  context: ReactContext<T>,
-  observedBits: void | number | boolean,
-): T {
+function readContext<T>(context: ReactContext<T>): T {
   // For now we don't expose readContext usage in the hooks debugging info.
   return context._currentValue;
 }
 
-function useContext<T>(
-  context: ReactContext<T>,
-  observedBits: void | number | boolean,
-): T {
+function useContext<T>(context: ReactContext<T>): T {
   hookLog.push({
     primitive: 'Context',
     stackError: new Error(),

commit a632f7de3bd35eaf6d5082054af4da92dd37cf20
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Apr 20 12:21:44 2021 -0400

    Flip tuple order of useTransition (#20976)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index d78f629374..2127082557 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -265,7 +265,7 @@ function useMutableSource<Source, Snapshot>(
   return value;
 }
 
-function useTransition(): [(() => void) => void, boolean] {
+function useTransition(): [boolean, (() => void) => void] {
   // useTransition() composes multiple hooks internally.
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.
@@ -276,7 +276,7 @@ function useTransition(): [(() => void) => void, boolean] {
     stackError: new Error(),
     value: undefined,
   });
-  return [callback => {}, false];
+  return [false, callback => {}];
 }
 
 function useDeferredValue<T>(value: T): T {

commit ab390c65eefb7f395468c18ee2b059bf35c7cd03
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu Jul 1 13:08:46 2021 -0400

    ReactDebugHooks optionally includes fileName, and line/column numbers (#21781)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2127082557..7d2679b319 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -332,12 +332,20 @@ const Dispatcher: DispatcherType = {
 
 // Inspect
 
+export type HookSource = {
+  lineNumber: number | null,
+  columnNumber: number | null,
+  fileName: string | null,
+  functionName: string | null,
+};
+
 export type HooksNode = {
   id: number | null,
   isStateEditable: boolean,
   name: string,
   value: mixed,
   subHooks: Array<HooksNode>,
+  hookSource?: HookSource,
   ...
 };
 export type HooksTree = Array<HooksNode>;
@@ -473,7 +481,11 @@ function parseCustomHookName(functionName: void | string): string {
   return functionName.substr(startIndex);
 }
 
-function buildTree(rootStack, readHookLog): HooksTree {
+function buildTree(
+  rootStack,
+  readHookLog,
+  includeHooksSource: boolean,
+): HooksTree {
   const rootChildren = [];
   let prevStack = null;
   let levelChildren = rootChildren;
@@ -508,13 +520,25 @@ function buildTree(rootStack, readHookLog): HooksTree {
       // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
         const children = [];
-        levelChildren.push({
+        const stackFrame = stack[j];
+        const levelChild: HooksNode = {
           id: null,
           isStateEditable: false,
           name: parseCustomHookName(stack[j - 1].functionName),
           value: undefined,
           subHooks: children,
-        });
+        };
+
+        if (includeHooksSource) {
+          levelChild.hookSource = {
+            lineNumber: stackFrame.lineNumber,
+            columnNumber: stackFrame.columnNumber,
+            functionName: stackFrame.functionName,
+            fileName: stackFrame.fileName,
+          };
+        }
+
+        levelChildren.push(levelChild);
         stackOfChildren.push(levelChildren);
         levelChildren = children;
       }
@@ -531,14 +555,33 @@ function buildTree(rootStack, readHookLog): HooksTree {
 
     // For the time being, only State and Reducer hooks support runtime overrides.
     const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-
-    levelChildren.push({
+    const levelChild: HooksNode = {
       id,
       isStateEditable,
       name: primitive,
       value: hook.value,
       subHooks: [],
-    });
+    };
+
+    if (includeHooksSource) {
+      const hookSource: HookSource = {
+        lineNumber: null,
+        functionName: null,
+        fileName: null,
+        columnNumber: null,
+      };
+      if (stack && stack.length >= 1) {
+        const stackFrame = stack[0];
+        hookSource.lineNumber = stackFrame.lineNumber;
+        hookSource.functionName = stackFrame.functionName;
+        hookSource.fileName = stackFrame.fileName;
+        hookSource.columnNumber = stackFrame.columnNumber;
+      }
+
+      levelChild.hookSource = hookSource;
+    }
+
+    levelChildren.push(levelChild);
   }
 
   // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
@@ -585,6 +628,7 @@ export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
   currentDispatcher: ?CurrentDispatcherRef,
+  includeHooksSource?: boolean = false,
 ): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
@@ -605,7 +649,7 @@ export function inspectHooks<Props>(
     currentDispatcher.current = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
+  return buildTree(rootStack, readHookLog, includeHooksSource);
 }
 
 function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
@@ -634,6 +678,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   props: Props,
   ref: Ref,
   currentDispatcher: CurrentDispatcherRef,
+  includeHooksSource: boolean,
 ): HooksTree {
   const previousDispatcher = currentDispatcher.current;
   let readHookLog;
@@ -648,7 +693,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
     currentDispatcher.current = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
+  return buildTree(rootStack, readHookLog, includeHooksSource);
 }
 
 function resolveDefaultProps(Component, baseProps) {
@@ -669,6 +714,7 @@ function resolveDefaultProps(Component, baseProps) {
 export function inspectHooksOfFiber(
   fiber: Fiber,
   currentDispatcher: ?CurrentDispatcherRef,
+  includeHooksSource?: boolean = false,
 ) {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
@@ -706,9 +752,10 @@ export function inspectHooksOfFiber(
         props,
         fiber.ref,
         currentDispatcher,
+        includeHooksSource,
       );
     }
-    return inspectHooks(type, props, currentDispatcher);
+    return inspectHooks(type, props, currentDispatcher, includeHooksSource);
   } finally {
     currentHook = null;
     restoreContexts(contextMap);

commit 77912d9a05d7a90287fabdec76486f25869b2981
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 7 13:20:24 2021 -0400

    Wire up the native API for useSyncExternalStore (#22237)
    
    Adds useSyncExternalStore to the internal dispatcher, and exports
    the native API from the React package without yet implementing it.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 7d2679b319..0e2364f672 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -265,6 +265,13 @@ function useMutableSource<Source, Snapshot>(
   return value;
 }
 
+function useSyncExternalStore<T>(
+  subscribe: (() => void) => () => void,
+  getSnapshot: () => T,
+): T {
+  throw new Error('Not yet implemented');
+}
+
 function useTransition(): [boolean, (() => void) => void] {
   // useTransition() composes multiple hooks internally.
   // Advance the current hook index the same number of times
@@ -326,6 +333,7 @@ const Dispatcher: DispatcherType = {
   useState,
   useTransition,
   useMutableSource,
+  useSyncExternalStore,
   useDeferredValue,
   useOpaqueIdentifier,
 };

commit cfd81933286f3a63734ba0ac1650019487c402ff
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 7 13:58:20 2021 -0400

    Add useSyncExternalStore to react-debug-tools (#22240)
    
    Adds support for useSyncExternalStore to react-debug-tools, which in
    turn adds support for React Devtools.
    
    Test plan: I added a test to ReactHooksInspectionIntegration, based on
    existing one for useMutableSource.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 0e2364f672..131a0003dc 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -269,7 +269,19 @@ function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
 ): T {
-  throw new Error('Not yet implemented');
+  // useSyncExternalStore() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // SyncExternalStore
+  nextHook(); // LayoutEffect
+  nextHook(); // Effect
+  const value = getSnapshot();
+  hookLog.push({
+    primitive: 'SyncExternalStore',
+    stackError: new Error(),
+    value,
+  });
+  return value;
 }
 
 function useTransition(): [boolean, (() => void) => void] {

commit 33226fadaac7b23634852eee78c4f1c84c5b2bbb
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 13 11:07:46 2021 -0400

    Check for store mutations before commit (#22290)
    
    * [useSyncExternalStore] Remove extra hook object
    
    Because we already track `getSnapshot` and `value` on the store
    instance, we don't need to also track them as effect dependencies. And
    because the effect doesn't require any clean-up, we don't need to track
    a `destroy` function.
    
    So, we don't need to store any additional state for this effect. We can
    call `pushEffect` directly, and only during renders where something
    has changed.
    
    This saves some memory, but my main motivation is because I plan to use
    this same logic to schedule a pre-commit consistency check. (See the
    inline comments for more details.)
    
    * Split shouldTimeSlice into two separate functions
    
    Lanes that are blocking (SyncLane, and DefaultLane inside a blocking-
    by-default root) are always blocking for a given root. Whereas expired
    lanes can expire while the render phase is already in progress.
    
    I want to check if a lane is blocking without checking whether it
    expired, so I split `shouldTimeSlice` into two separate functions.
    
    I'll use this in the next step.
    
    * Check for store mutations before commit
    
    When a store is read for the first time, or when `subscribe` or
    `getSnapshot` changes, during a concurrent render, we have to check
    at the end of the render phase whether the store was mutated by
    an concurrent event.
    
    In the userspace shim, we perform this check in a layout effect, and
    patch up any inconsistencies by scheduling another render + commit.
    However, even though we patch them up in the next render, the parent
    layout effects that fire in the original render will still observe an
    inconsistent tree.
    
    In the native implementation, we can instead check for inconsistencies
    right after the root is completed, before entering the commit phase. If
    we do detect a mutaiton, we can discard the tree and re-render before
    firing any effects. The re-render is synchronous to block further
    concurrent mutations (which is also what we do to recover from tearing
    bugs that result in an error). After the synchronous re-render, we can
    assume the tree the tree is consistent and continue with the normal
    algorithm for finishing a completed root (i.e. either suspend
    or commit).
    
    The result is that layout effects will always observe a consistent tree.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 131a0003dc..94fbaeec05 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -273,7 +273,6 @@ function useSyncExternalStore<T>(
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.
   nextHook(); // SyncExternalStore
-  nextHook(); // LayoutEffect
   nextHook(); // Effect
   const value = getSnapshot();
   hookLog.push({

commit 263cfa6ecb9879ecb629d4e04a8c26422b4c4ff9
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Sep 14 10:27:09 2021 -0400

    [Experimental] Add useInsertionEffect (#21913)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 94fbaeec05..c1258c2dcd 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -78,6 +78,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         Dispatcher.useCacheRefresh();
       }
       Dispatcher.useLayoutEffect(() => {});
+      Dispatcher.useInsertionEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useDebugValue(null);
@@ -191,6 +192,18 @@ function useLayoutEffect(
   });
 }
 
+function useInsertionEffect(
+  create: () => mixed,
+  inputs: Array<mixed> | void | null,
+): void {
+  nextHook();
+  hookLog.push({
+    primitive: 'InsertionEffect',
+    stackError: new Error(),
+    value: create,
+  });
+}
+
 function useEffect(
   create: () => (() => void) | void,
   inputs: Array<mixed> | void | null,
@@ -338,6 +351,7 @@ const Dispatcher: DispatcherType = {
   useImperativeHandle,
   useDebugValue,
   useLayoutEffect,
+  useInsertionEffect,
   useMemo,
   useReducer,
   useRef,

commit 8209de269531767b33d8db26eda41db38bfb6a27
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 20 00:11:50 2021 -0400

    Delete useMutableSource implementation (#22292)
    
    This API was replaced by useSyncExternalStore

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c1258c2dcd..a57c38ab10 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -7,13 +7,7 @@
  * @flow
  */
 
-import type {
-  MutableSource,
-  MutableSourceGetSnapshotFn,
-  MutableSourceSubscribeFn,
-  ReactContext,
-  ReactProviderType,
-} from 'shared/ReactTypes';
+import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
 import type {
   Fiber,
   Dispatcher as DispatcherType,
@@ -261,23 +255,6 @@ function useMemo<T>(
   return value;
 }
 
-function useMutableSource<Source, Snapshot>(
-  source: MutableSource<Source>,
-  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
-  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
-): Snapshot {
-  // useMutableSource() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  nextHook(); // MutableSource
-  nextHook(); // State
-  nextHook(); // Effect
-  nextHook(); // Effect
-  const value = getSnapshot(source._source);
-  hookLog.push({primitive: 'MutableSource', stackError: new Error(), value});
-  return value;
-}
-
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
@@ -357,7 +334,6 @@ const Dispatcher: DispatcherType = {
   useRef,
   useState,
   useTransition,
-  useMutableSource,
   useSyncExternalStore,
   useDeferredValue,
   useOpaqueIdentifier,

commit 86b3e2461da28d9c074b04f42e4ca69773902fec
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 20 11:31:02 2021 -0400

    Implement useSyncExternalStore on server (#22347)
    
    Adds a third argument called `getServerSnapshot`.
    
    On the server, React calls this one instead of the normal `getSnapshot`.
    We also call it during hydration.
    
    So it represents the snapshot that is used to generate the initial,
    server-rendered HTML. The purpose is to avoid server-client mismatches.
    What we render during hydration needs to match up exactly with what we
    render on the server.
    
    The pattern is for the server to send down a serialized copy of the
    store that was used to generate the initial HTML. On the client, React
    will call either `getSnapshot` or `getServerSnapshot` on the client as
    appropriate, depending on whether it's currently hydrating.
    
    The argument is optional for fully client rendered use cases. If the
    user does attempt to omit `getServerSnapshot`, and the hook is called
    on the server, React will abort that subtree on the server and
    revert to client rendering, up to the nearest Suspense boundary.
    
    For the userspace shim, we will need to use a heuristic (canUseDOM)
    to determine whether we are in a server environment. I'll do that in
    a follow up.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a57c38ab10..cddbb0810f 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -258,6 +258,7 @@ function useMemo<T>(
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
+  getServerSnapshot?: () => T,
 ): T {
   // useSyncExternalStore() composes multiple hooks internally.
   // Advance the current hook index the same number of times

commit 82c8fa90be86fc0afcbff2dc39486579cff1ac9a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 21 23:38:24 2021 -0400

    Add back useMutableSource temporarily (#22396)
    
    Recoil uses useMutableSource behind a flag. I thought this was fine
    because Recoil isn't used in any concurrent roots, so the behavior
    would be the same, but it turns out that it is used by concurrent
    roots in a few places.
    
    I'm not expecting it to be hard to migrate to useSyncExternalStore, but
    to de-risk the change I'm going to roll it out gradually with a flag. In
    the meantime, I've added back the useMutableSource API.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index cddbb0810f..aa4d2d60fd 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -7,7 +7,13 @@
  * @flow
  */
 
-import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
+import type {
+  MutableSource,
+  MutableSourceGetSnapshotFn,
+  MutableSourceSubscribeFn,
+  ReactContext,
+  ReactProviderType,
+} from 'shared/ReactTypes';
 import type {
   Fiber,
   Dispatcher as DispatcherType,
@@ -255,6 +261,23 @@ function useMemo<T>(
   return value;
 }
 
+function useMutableSource<Source, Snapshot>(
+  source: MutableSource<Source>,
+  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
+  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+): Snapshot {
+  // useMutableSource() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // MutableSource
+  nextHook(); // State
+  nextHook(); // Effect
+  nextHook(); // Effect
+  const value = getSnapshot(source._source);
+  hookLog.push({primitive: 'MutableSource', stackError: new Error(), value});
+  return value;
+}
+
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
@@ -335,6 +358,7 @@ const Dispatcher: DispatcherType = {
   useRef,
   useState,
   useTransition,
+  useMutableSource,
   useSyncExternalStore,
   useDeferredValue,
   useOpaqueIdentifier,

commit a724a3b578dce77d427bef313102a4d0e978d9b4
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Sep 30 15:01:28 2021 -0400

    [RFC] Codemod invariant -> throw new Error (#22435)
    
    * Hoist error codes import to module scope
    
    When this code was written, the error codes map (`codes.json`) was
    created on-the-fly, so we had to lazily require from inside the visitor.
    
    Because `codes.json` is now checked into source, we can import it a
    single time in module scope.
    
    * Minify error constructors in production
    
    We use a script to minify our error messages in production. Each message
    is assigned an error code, defined in `scripts/error-codes/codes.json`.
    Then our build script replaces the messages with a link to our
    error decoder page, e.g. https://reactjs.org/docs/error-decoder.html/?invariant=92
    
    This enables us to write helpful error messages without increasing the
    bundle size.
    
    Right now, the script only works for `invariant` calls. It does not work
    if you throw an Error object. This is an old Facebookism that we don't
    really need, other than the fact that our error minification script
    relies on it.
    
    So, I've updated the script to minify error constructors, too:
    
    Input:
      Error(`A ${adj} message that contains ${noun}`);
    Output:
      Error(formatProdErrorMessage(ERR_CODE, adj, noun));
    
    It only works for constructors that are literally named Error, though we
    could add support for other names, too.
    
    As a next step, I will add a lint rule to enforce that errors written
    this way must have a corresponding error code.
    
    * Minify "no fallback UI specified" error in prod
    
    This error message wasn't being minified because it doesn't use
    invariant. The reason it didn't use invariant is because this particular
    error is created without begin thrown — it doesn't need to be thrown
    because it's located inside the error handling part of the runtime.
    
    Now that the error minification script supports Error constructors, we
    can minify it by assigning it a production error code in
    `scripts/error-codes/codes.json`.
    
    To support the use of Error constructors more generally, I will add a
    lint rule that enforces each message has a corresponding error code.
    
    * Lint rule to detect unminified errors
    
    Adds a lint rule that detects when an Error constructor is used without
    a corresponding production error code.
    
    We already have this for `invariant`, but not for regular errors, i.e.
    `throw new Error(msg)`. There's also nothing that enforces the use of
    `invariant` besides convention.
    
    There are some packages where we don't care to minify errors. These are
    packages that run in environments where bundle size is not a concern,
    like react-pg. I added an override in the ESLint config to ignore these.
    
    * Temporarily add invariant codemod script
    
    I'm adding this codemod to the repo temporarily, but I'll revert it
    in the same PR. That way we don't have to check it in but it's still
    accessible (via the PR) if we need it later.
    
    * [Automated] Codemod invariant -> Error
    
    This commit contains only automated changes:
    
    npx jscodeshift -t scripts/codemod-invariant.js packages --ignore-pattern="node_modules/**/*"
    yarn linc --fix
    yarn prettier
    
    I will do any manual touch ups in separate commits so they're easier
    to review.
    
    * Remove temporary codemod script
    
    This reverts the codemod script and ESLint config I added temporarily
    in order to perform the invariant codemod.
    
    * Manual touch ups
    
    A few manual changes I made after the codemod ran.
    
    * Enable error code transform per package
    
    Currently we're not consistent about which packages should have their
    errors minified in production and which ones should.
    
    This adds a field to the bundle configuration to control whether to
    apply the transform. We should decide what the criteria is going
    forward. I think it's probably a good idea to minify any package that
    gets sent over the network. So yes to modules that run in the browser,
    and no to modules that run on the server and during development only.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index aa4d2d60fd..957838ed58 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -23,7 +23,6 @@ import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
-import invariant from 'shared/invariant';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import {REACT_OPAQUE_ID_TYPE} from 'shared/ReactSymbols';
 import {
@@ -107,7 +106,7 @@ function nextHook(): null | Hook {
 }
 
 function getCacheForType<T>(resourceType: () => T): T {
-  invariant(false, 'Not implemented.');
+  throw new Error('Not implemented.');
 }
 
 function readContext<T>(context: ReactContext<T>): T {

commit ebf9ae8579230e7b1ed0b1d243e1cf802f56938b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 1 16:30:44 2021 -0400

    useId (#22644)
    
    * Add useId to dispatcher
    
    * Initial useId implementation
    
    Ids are base 32 strings whose binary representation corresponds to the
    position of a node in a tree.
    
    Every time the tree forks into multiple children, we add additional bits
    to the left of the sequence that represent the position of the child
    within the current level of children.
    
        00101       00010001011010101
        ╰─┬─╯       ╰───────┬───────╯
      Fork 5 of 20       Parent id
    
    The leading 0s are important. In the above example, you only need 3 bits
    to represent slot 5. However, you need 5 bits to represent all the forks
    at the current level, so we must account for the empty bits at the end.
    
    For this same reason, slots are 1-indexed instead of 0-indexed.
    Otherwise, the zeroth id at a level would be indistinguishable from
    its parent.
    
    If a node has only one child, and does not materialize an id (i.e. does
    not contain a useId hook), then we don't need to allocate any space in
    the sequence. It's treated as a transparent indirection. For example,
    these two trees produce the same ids:
    
    <>                          <>
      <Indirection>               <A />
        <A />                     <B />
      </Indirection>            </>
      <B />
    </>
    
    However, we cannot skip any materializes an id. Otherwise, a parent id
    that does not fork would be indistinguishable from its child id. For
    example, this tree does not fork, but the parent and child must have
    different ids.
    
    <Parent>
      <Child />
    </Parent>
    
    To handle this scenario, every time we materialize an id, we allocate a
    new level with a single slot. You can think of this as a fork with only
    one prong, or an array of children with length 1.
    
    It's possible for the the size of the sequence to exceed 32 bits, the
    max size for bitwise operations. When this happens, we make more room by
    converting the right part of the id to a string and storing it in an
    overflow variable. We use a base 32 string representation, because 32 is
    the largest power of 2 that is supported by toString(). We want the base
    to be large so that the resulting ids are compact, and we want the base
    to be a power of 2 because every log2(base) bits corresponds to a single
    character, i.e. every log2(32) = 5 bits. That means we can lop bits off
    the end 5 at a time without affecting the final result.
    
    * Incremental hydration
    
    Stores the tree context on the dehydrated Suspense boundary's state
    object so it resume where it left off.
    
    * Add useId to react-debug-tools
    
    * Add selective hydration test
    
    Demonstrates that selective hydration works and ids are preserved even
    after subsequent client updates.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 957838ed58..eed8c46df7 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -341,6 +341,17 @@ function useOpaqueIdentifier(): OpaqueIDType | void {
   return value;
 }
 
+function useId(): string {
+  const hook = nextHook();
+  const id = hook !== null ? hook.memoizedState : '';
+  hookLog.push({
+    primitive: 'Id',
+    stackError: new Error(),
+    value: id,
+  });
+  return id;
+}
+
 const Dispatcher: DispatcherType = {
   getCacheForType,
   readContext,
@@ -361,6 +372,7 @@ const Dispatcher: DispatcherType = {
   useSyncExternalStore,
   useDeferredValue,
   useOpaqueIdentifier,
+  useId,
 };
 
 // Inspect

commit 75f3ddebfa0d9885ce8df42571cf0c09ad6c0a3b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 1 18:02:39 2021 -0400

    Remove experimental useOpaqueIdentifier API (#22672)
    
    useId is the updated version of this API.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index eed8c46df7..895e753598 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -18,13 +18,9 @@ import type {
   Fiber,
   Dispatcher as DispatcherType,
 } from 'react-reconciler/src/ReactInternalTypes';
-import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
-
-import {NoMode} from 'react-reconciler/src/ReactTypeOfMode';
 
 import ErrorStackParser from 'error-stack-parser';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
-import {REACT_OPAQUE_ID_TYPE} from 'shared/ReactSymbols';
 import {
   FunctionComponent,
   SimpleMemoComponent,
@@ -53,8 +49,6 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-let currentFiber: Fiber | null = null;
-
 type Hook = {
   memoizedState: any,
   next: Hook | null,
@@ -324,23 +318,6 @@ function useDeferredValue<T>(value: T): T {
   return value;
 }
 
-function useOpaqueIdentifier(): OpaqueIDType | void {
-  const hook = nextHook(); // State
-  if (currentFiber && currentFiber.mode === NoMode) {
-    nextHook(); // Effect
-  }
-  let value = hook === null ? undefined : hook.memoizedState;
-  if (value && value.$$typeof === REACT_OPAQUE_ID_TYPE) {
-    value = undefined;
-  }
-  hookLog.push({
-    primitive: 'OpaqueIdentifier',
-    stackError: new Error(),
-    value,
-  });
-  return value;
-}
-
 function useId(): string {
   const hook = nextHook();
   const id = hook !== null ? hook.memoizedState : '';
@@ -371,7 +348,6 @@ const Dispatcher: DispatcherType = {
   useMutableSource,
   useSyncExternalStore,
   useDeferredValue,
-  useOpaqueIdentifier,
   useId,
 };
 
@@ -767,8 +743,6 @@ export function inspectHooksOfFiber(
     currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
   }
 
-  currentFiber = fiber;
-
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&

commit 1ad8d81292415e26ac070dec03ad84c11fbe207d
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Feb 23 19:34:24 2022 -0500

    Remove object-assign polyfill (#23351)
    
    * Remove object-assign polyfill
    
    We really rely on a more modern environment where this is typically
    polyfilled anyway and we don't officially support IE with more extensive
    polyfilling anyway. So all environments should have the native version
    by now.
    
    * Use shared/assign instead of Object.assign in code
    
    This is so that we have one cached local instance in the bundle.
    
    Ideally we should have a compile do this for us but we already follow
    this pattern with hasOwnProperty, isArray, Object.is etc.
    
    * Transform Object.assign to now use shared/assign
    
    We need this to use the shared instance when Object.spread is used.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 895e753598..0ffec00bd3 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,6 +20,7 @@ import type {
 } from 'react-reconciler/src/ReactInternalTypes';
 
 import ErrorStackParser from 'error-stack-parser';
+import assign from 'shared/assign';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import {
   FunctionComponent,
@@ -720,7 +721,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
 function resolveDefaultProps(Component, baseProps) {
   if (Component && Component.defaultProps) {
     // Resolve default props. Taken from ReactElement
-    const props = Object.assign({}, baseProps);
+    const props = assign({}, baseProps);
     const defaultProps = Component.defaultProps;
     for (const propName in defaultProps) {
       if (props[propName] === undefined) {

commit 42f15b324f50d0fd98322c21646ac3013e30344a
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Feb 24 17:28:18 2022 -0500

    [DevTools][Transition Tracing] onTransitionComplete and onTransitionStart implmentation (#23313)
    
    * add transition name to startTransition
    
    Add a transitionName to start transition, store the transition start time and name in the batch config, and pass it to the root on render
    
    * Transition Tracing Types and Consts
    
    * Root begin work
    
    The root operates as a tracing marker that has all transitions on it. This PR only tested the root with one transition so far
    
    - Store transitions in memoizedState. Do this in updateHostRoot AND attemptEarlyBailoutIfNoScheduledUpdate. We need to do this in the latter part because even if the root itself doesn't have an update, it could still have new transitions in its transitionLanes map that we need to process.
    
    * Transition Tracing commit phase
    
    - adds a module scoped pending transition callbacks object that contains all transition callbacks that have not yet been processed. This  contains all callbacks before the next paint occurs.
    - Add code in the mutation phase to:
            * For the root, if there are transitions that were initialized during this commit in the root transition lanes map, add a transition start call to the pending transition callbacks object. Then, remove the transitions from the root transition lanes map.
            * For roots, in the commit phase, add a transition complete call
    
    We add this code in the mutation phase because we can't add it to the passive phase because then the paint might have occurred before we even know which callbacks to call
    
    * Process Callbacks after paint
    
    At the end of the commit phase, call scheduleTransitionCallbacks to schedule all pending transition callbacks to be called after paint. Then clear the callbacks

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 0ffec00bd3..b715985906 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -13,6 +13,7 @@ import type {
   MutableSourceSubscribeFn,
   ReactContext,
   ReactProviderType,
+  StartTransitionOptions,
 } from 'shared/ReactTypes';
 import type {
   Fiber,
@@ -291,7 +292,10 @@ function useSyncExternalStore<T>(
   return value;
 }
 
-function useTransition(): [boolean, (() => void) => void] {
+function useTransition(): [
+  boolean,
+  (callback: () => void, options?: StartTransitionOptions) => void,
+] {
   // useTransition() composes multiple hooks internally.
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.

commit 0415b18a100043df164bcd40639f9373e3358350
Author: Mengdi "Monday" Chen <mengdi@fb.com>
Date:   Wed Mar 30 11:07:12 2022 -0400

    [ReactDebugTools] add custom error type for future new hooks (#24168)
    
    * [ReactDebugTools] add custom error type for future new hooks
    
    * update per review comments
    
    * remove unused argument

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b715985906..49bf65e313 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -356,6 +356,23 @@ const Dispatcher: DispatcherType = {
   useId,
 };
 
+// create a proxy to throw a custom error
+// in case future versions of React adds more hooks
+const DispatcherProxyHandler = {
+  get(target, prop) {
+    if (target.hasOwnProperty(prop)) {
+      return target[prop];
+    }
+    const error = new Error('Missing method in Dispatcher: ' + prop);
+    // Note: This error name needs to stay in sync with react-devtools-shared
+    // TODO: refactor this if we ever combine the devtools and debug tools packages
+    error.name = 'UnsupportedFeatureError';
+    throw error;
+  },
+};
+
+const DispatcherProxy = new Proxy(Dispatcher, DispatcherProxyHandler);
+
 // Inspect
 
 export type HookSource = {
@@ -664,7 +681,7 @@ export function inspectHooks<Props>(
 
   const previousDispatcher = currentDispatcher.current;
   let readHookLog;
-  currentDispatcher.current = Dispatcher;
+  currentDispatcher.current = DispatcherProxy;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -708,7 +725,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
 ): HooksTree {
   const previousDispatcher = currentDispatcher.current;
   let readHookLog;
-  currentDispatcher.current = Dispatcher;
+  currentDispatcher.current = DispatcherProxy;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();

commit c89a15c716febe71b7d857f839829cd1dc74918f
Author: Mengdi "Monday" Chen <mengdi@fb.com>
Date:   Fri Apr 1 14:38:11 2022 -0400

    [ReactDebugTools] wrap uncaught error from rendering user's component (#24216)
    
    * [ReactDebugTools] wrap uncaught error from rendering user's component
    
    * fix lint
    
    * make error names more package specific
    
    * update per review comments
    
    * fix tests
    
    * fix lint
    
    * fix tests
    
    * fix lint
    
    * fix error name & nits
    
    * try catch instead of mocking error
    
    * fix test for older node.js version
    
    * avoid false positive from try-catch in tests

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 49bf65e313..3657ed2db0 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -366,7 +366,7 @@ const DispatcherProxyHandler = {
     const error = new Error('Missing method in Dispatcher: ' + prop);
     // Note: This error name needs to stay in sync with react-devtools-shared
     // TODO: refactor this if we ever combine the devtools and debug tools packages
-    error.name = 'UnsupportedFeatureError';
+    error.name = 'ReactDebugToolsUnsupportedHookError';
     throw error;
   },
 };
@@ -667,6 +667,30 @@ function processDebugValues(
   }
 }
 
+function handleRenderFunctionError(error: any): void {
+  // original error might be any type.
+  if (
+    error instanceof Error &&
+    error.name === 'ReactDebugToolsUnsupportedHookError'
+  ) {
+    throw error;
+  }
+  // If the error is not caused by an unsupported feature, it means
+  // that the error is caused by user's code in renderFunction.
+  // In this case, we should wrap the original error inside a custom error
+  // so that devtools can give a clear message about it.
+  // $FlowFixMe: Flow doesn't know about 2nd argument of Error constructor
+  const wrapperError = new Error('Error rendering inspected component', {
+    cause: error,
+  });
+  // Note: This error name needs to stay in sync with react-devtools-shared
+  // TODO: refactor this if we ever combine the devtools and debug tools packages
+  wrapperError.name = 'ReactDebugToolsRenderError';
+  // this stage-4 proposal is not supported by all environments yet.
+  wrapperError.cause = error;
+  throw wrapperError;
+}
+
 export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
@@ -686,6 +710,8 @@ export function inspectHooks<Props>(
   try {
     ancestorStackError = new Error();
     renderFunction(props);
+  } catch (error) {
+    handleRenderFunctionError(error);
   } finally {
     readHookLog = hookLog;
     hookLog = [];
@@ -730,6 +756,8 @@ function inspectHooksOfForwardRef<Props, Ref>(
   try {
     ancestorStackError = new Error();
     renderFunction(props, ref);
+  } catch (error) {
+    handleRenderFunctionError(error);
   } finally {
     readHookLog = hookLog;
     hookLog = [];

commit 72ebc703ac8abacd44fdeb1e3d66eb28b75e5a5b
Author: Mengdi Chen <mengdi@fb.com>
Date:   Fri Jun 17 14:43:10 2022 -0400

    [DevTools] fix useDeferredValue to match reconciler change (#24742)
    
    * [DevTools] fix useDeferredValue to match reconciler change
    
    * fixup
    
    * update test to catch original issue
    
    * fix lint
    
    * add safer tests for other composite hooks

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 3657ed2db0..940873725c 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -310,15 +310,11 @@ function useTransition(): [
 }
 
 function useDeferredValue<T>(value: T): T {
-  // useDeferredValue() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  nextHook(); // State
-  nextHook(); // Effect
+  const hook = nextHook();
   hookLog.push({
     primitive: 'DeferredValue',
     stackError: new Error(),
-    value,
+    value: hook !== null ? hook.memoizedState : value,
   });
   return value;
 }

commit a473d08fcee187f957b844b53b2eee2d2714630b
Author: Jan Kassens <jan@kassens.net>
Date:   Thu Sep 8 11:46:07 2022 -0400

    Update to Flow from 0.97 to 0.122 (#25204)
    
    * flow 0.122
    * update ReactModel type

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 940873725c..7cfb576fad 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -683,6 +683,7 @@ function handleRenderFunctionError(error: any): void {
   // TODO: refactor this if we ever combine the devtools and debug tools packages
   wrapperError.name = 'ReactDebugToolsRenderError';
   // this stage-4 proposal is not supported by all environments yet.
+  // $FlowFixMe Flow doesn't have this type yet.
   wrapperError.cause = error;
   throw wrapperError;
 }

commit 8a9e7b6cefb5e7e94333c7d5fe2cca6541776d5b
Author: Jan Kassens <jan@kassens.net>
Date:   Fri Sep 9 10:13:58 2022 -0400

    Flow: implicit-inexact-object=error (#25210)
    
    * implicit-inexact-object=error
    * default everything ambiguous to exact object
    * inexact where exact causes errors

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 7cfb576fad..68305e4a93 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -51,10 +51,10 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type Hook = {
+type Hook = {|
   memoizedState: any,
   next: Hook | null,
-};
+|};
 
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
@@ -371,12 +371,12 @@ const DispatcherProxy = new Proxy(Dispatcher, DispatcherProxyHandler);
 
 // Inspect
 
-export type HookSource = {
+export type HookSource = {|
   lineNumber: number | null,
   columnNumber: number | null,
   fileName: string | null,
   functionName: string | null,
-};
+|};
 
 export type HooksNode = {
   id: number | null,

commit 8003ab9cf5c711eb00f741bbd89def56b066b999
Author: Jan Kassens <jan@kassens.net>
Date:   Fri Sep 9 16:03:48 2022 -0400

    Flow: remove explicit object syntax (#25223)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 68305e4a93..2cb6e7fbdf 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -51,10 +51,10 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type Hook = {|
+type Hook = {
   memoizedState: any,
   next: Hook | null,
-|};
+};
 
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
@@ -154,7 +154,7 @@ function useReducer<S, I, A>(
   return [state, (action: A) => {}];
 }
 
-function useRef<T>(initialValue: T): {|current: T|} {
+function useRef<T>(initialValue: T): {current: T} {
   const hook = nextHook();
   const ref = hook !== null ? hook.memoizedState : {current: initialValue};
   hookLog.push({
@@ -208,7 +208,7 @@ function useEffect(
 }
 
 function useImperativeHandle<T>(
-  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
+  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
   create: () => T,
   inputs: Array<mixed> | void | null,
 ): void {
@@ -371,12 +371,12 @@ const DispatcherProxy = new Proxy(Dispatcher, DispatcherProxyHandler);
 
 // Inspect
 
-export type HookSource = {|
+export type HookSource = {
   lineNumber: number | null,
   columnNumber: number | null,
   fileName: string | null,
   functionName: string | null,
-|};
+};
 
 export type HooksNode = {
   id: number | null,

commit 346c7d4c43a0717302d446da9e7423a8e28d8996
Author: Jan Kassens <jan@kassens.net>
Date:   Tue Sep 13 17:57:38 2022 -0400

    straightford explicit types (#25253)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2cb6e7fbdf..a09da97f90 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -783,7 +783,7 @@ export function inspectHooksOfFiber(
   fiber: Fiber,
   currentDispatcher: ?CurrentDispatcherRef,
   includeHooksSource?: boolean = false,
-) {
+): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {

commit 6e3bc8a2e82d6fb627315b97f946f4ff2ee367de
Author: Tianyu Yao <skyyao@fb.com>
Date:   Fri Sep 16 11:24:03 2022 -0700

    [DevTools] Check if Proxy exists before creating DispatcherProxy (#25278)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a09da97f90..6409647772 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -367,7 +367,11 @@ const DispatcherProxyHandler = {
   },
 };
 
-const DispatcherProxy = new Proxy(Dispatcher, DispatcherProxyHandler);
+// `Proxy` may not exist on some platforms
+const DispatcherProxy =
+  typeof Proxy === 'undefined'
+    ? Dispatcher
+    : new Proxy(Dispatcher, DispatcherProxyHandler);
 
 // Inspect
 

commit 3b6826ed9e76207d9ab7a513a069fd67b69599a8
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Oct 4 15:39:26 2022 -0400

    Flow: inference_mode=constrain_writes
    
    This mode is going to be the new default in Flow going forward.
    There was an unfortuante large number of suppressions in this update.
    
    More on the changes can be found in this [Flow blog post](https://medium.com/flow-type/new-flow-language-rule-constrained-writes-4c70e375d190).
    
    Added some of the required annotations using the provided codemod:
    
    ```sh
    node_modules/.bin/flow codemod annotate-declarations --write .
    ```
    
    ghstack-source-id: 0b168e1b23f1305083e71d0b931b732e94705c73
    Pull Request resolved: https://github.com/facebook/react/pull/25422

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 6409647772..2bd458d067 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -217,7 +217,7 @@ function useImperativeHandle<T>(
   // and if there is a ref callback it might not store it but if it does we
   // have no way of knowing where. So let's only enable introspection of the
   // ref itself if it is using the object form.
-  let instance = undefined;
+  let instance: ?T = undefined;
   if (ref !== null && typeof ref === 'object') {
     instance = ref.current;
   }
@@ -716,6 +716,7 @@ export function inspectHooks<Props>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
+    // $FlowFixMe[incompatible-use] found when upgrading Flow
     currentDispatcher.current = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
@@ -723,7 +724,7 @@ export function inspectHooks<Props>(
 }
 
 function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
-  let current = fiber;
+  let current: null | Fiber = fiber;
   while (current) {
     if (current.tag === ContextProvider) {
       const providerType: ReactProviderType<any> = current.type;

commit a8c16a00406a204f0153c21023a04ca9a68411da
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Oct 12 23:13:39 2022 -0400

    Split Cache into its own Dispatcher (#25474)
    
    * Missing Hooks
    
    * Remove www forks. These can use __SECRET... instead.
    
    * Move cache to separate dispatcher
    
    These will be available in more contexts than just render.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2bd458d067..74ca5568f1 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -101,10 +101,6 @@ function nextHook(): null | Hook {
   return hook;
 }
 
-function getCacheForType<T>(resourceType: () => T): T {
-  throw new Error('Not implemented.');
-}
-
 function readContext<T>(context: ReactContext<T>): T {
   // For now we don't expose readContext usage in the hooks debugging info.
   return context._currentValue;
@@ -331,7 +327,6 @@ function useId(): string {
 }
 
 const Dispatcher: DispatcherType = {
-  getCacheForType,
   readContext,
   useCacheRefresh,
   useCallback,

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 74ca5568f1..5971c38a97 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 0b4f443020af386f2b48c47c074cb504ed672dc8
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jan 9 15:46:48 2023 -0500

    [flow] enable enforce_local_inference_annotations (#25921)
    
    This setting is an incremental path to the next Flow version enforcing
    type annotations on most functions (except some inline callbacks).
    
    Used
    ```
    node_modules/.bin/flow codemod annotate-functions-and-classes --write .
    ```
    to add a majority of the types with some hand cleanup when for large
    inferred objects that should just be `Fiber` or weird constructs
    including `any`.
    
    Suppressed the remaining issues.
    
    Builds on #25918

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 5971c38a97..fbe4dc2f36 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -350,7 +350,7 @@ const Dispatcher: DispatcherType = {
 // create a proxy to throw a custom error
 // in case future versions of React adds more hooks
 const DispatcherProxyHandler = {
-  get(target, prop) {
+  get(target: DispatcherType, prop: string) {
     if (target.hasOwnProperty(prop)) {
       return target[prop];
     }
@@ -404,7 +404,7 @@ export type HooksTree = Array<HooksNode>;
 
 let mostLikelyAncestorIndex = 0;
 
-function findSharedIndex(hookStack, rootStack, rootIndex) {
+function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
   const source = rootStack[rootIndex].source;
   hookSearch: for (let i = 0; i < hookStack.length; i++) {
     if (hookStack[i].source === source) {
@@ -425,7 +425,7 @@ function findSharedIndex(hookStack, rootStack, rootIndex) {
   return -1;
 }
 
-function findCommonAncestorIndex(rootStack, hookStack) {
+function findCommonAncestorIndex(rootStack: any, hookStack: any) {
   let rootIndex = findSharedIndex(
     hookStack,
     rootStack,
@@ -446,7 +446,7 @@ function findCommonAncestorIndex(rootStack, hookStack) {
   return -1;
 }
 
-function isReactWrapper(functionName, primitiveName) {
+function isReactWrapper(functionName: any, primitiveName: string) {
   if (!functionName) {
     return false;
   }
@@ -460,7 +460,7 @@ function isReactWrapper(functionName, primitiveName) {
   );
 }
 
-function findPrimitiveIndex(hookStack, hook) {
+function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
   const stackCache = getPrimitiveStackCache();
   const primitiveStack = stackCache.get(hook.primitive);
   if (primitiveStack === undefined) {
@@ -488,7 +488,7 @@ function findPrimitiveIndex(hookStack, hook) {
   return -1;
 }
 
-function parseTrimmedStack(rootStack, hook) {
+function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
   // Get the stack trace between the primitive hook function and
   // the root function call. I.e. the stack frames of custom hooks.
   const hookStack = ErrorStackParser.parse(hook.stackError);
@@ -520,8 +520,8 @@ function parseCustomHookName(functionName: void | string): string {
 }
 
 function buildTree(
-  rootStack,
-  readHookLog,
+  rootStack: any,
+  readHookLog: Array<HookLogEntry>,
   includeHooksSource: boolean,
 ): HooksTree {
   const rootChildren = [];
@@ -764,7 +764,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   return buildTree(rootStack, readHookLog, includeHooksSource);
 }
 
-function resolveDefaultProps(Component, baseProps) {
+function resolveDefaultProps(Component: any, baseProps: any) {
   if (Component && Component.defaultProps) {
     // Resolve default props. Taken from ReactElement
     const props = assign({}, baseProps);

commit e2424f33b3ad727321fc12e75c5e94838e84c2b5
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jan 9 17:00:36 2023 -0500

    [flow] enable exact_empty_objects (#25973)
    
    This enables the "exact_empty_objects" setting for Flow which makes
    empty objects exact instead of building up the type as properties are
    added in code below. This is in preparation to Flow 191 which makes this
    the default and removes the config.
    
    More about the change in the Flow blog
    [here](https://medium.com/flow-type/improved-handling-of-the-empty-object-in-flow-ead91887e40c).

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index fbe4dc2f36..56c6e376da 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -524,7 +524,7 @@ function buildTree(
   readHookLog: Array<HookLogEntry>,
   includeHooksSource: boolean,
 ): HooksTree {
-  const rootChildren = [];
+  const rootChildren: Array<HooksNode> = [];
   let prevStack = null;
   let levelChildren = rootChildren;
   let nativeHookID = 0;
@@ -557,7 +557,7 @@ function buildTree(
       // The remaining part of the new stack are custom hooks. Push them
       // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
-        const children = [];
+        const children: Array<HooksNode> = [];
         const stackFrame = stack[j];
         const levelChild: HooksNode = {
           id: null,

commit 6ddcbd4f96cb103de3978617a53c200baf5b546c
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Feb 9 17:07:39 2023 -0500

    [flow] enable LTI inference mode (#26104)
    
    This is the next generation inference mode for Flow.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 56c6e376da..c6ee8a6d25 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -60,13 +60,13 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
   if (primitiveStackCache === null) {
-    const cache = new Map();
+    const cache = new Map<string, Array<any>>();
     let readHookLog;
     try {
       // Use all hooks here to add them to the hook log.
       Dispatcher.useContext(({_currentValue: null}: any));
       Dispatcher.useState(null);
-      Dispatcher.useReducer((s, a) => s, null);
+      Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
       if (typeof Dispatcher.useCacheRefresh === 'function') {
         // This type check is for Flow only.
@@ -809,7 +809,7 @@ export function inspectHooksOfFiber(
   // Set up the current hook so that we can step through and read the
   // current state from them.
   currentHook = (fiber.memoizedState: Hook);
-  const contextMap = new Map();
+  const contextMap = new Map<ReactContext<$FlowFixMe>, $FlowFixMe>();
   try {
     setupContexts(contextMap, fiber);
     if (fiber.tag === ForwardRef) {

commit afea1d0c536e0336735b0ea5c74f635527b65785
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Mar 27 13:43:04 2023 +0200

    [flow] make Flow suppressions explicit on the error (#26487)
    
    Added an explicit type to all $FlowFixMe suppressions to reduce
    over-suppressions of new errors that might be caused on the same lines.
    
    Also removes suppressions that aren't used (e.g. in a `@noflow` file as
    they're purely misleading)
    
    Test Plan:
    yarn flow-ci

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c6ee8a6d25..44d99922df 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -123,7 +123,7 @@ function useState<S>(
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
-      ? // $FlowFixMe: Flow doesn't like mixed types
+      ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
         initialState()
       : initialState;
   hookLog.push({primitive: 'State', stackError: new Error(), value: state});
@@ -674,7 +674,7 @@ function handleRenderFunctionError(error: any): void {
   // that the error is caused by user's code in renderFunction.
   // In this case, we should wrap the original error inside a custom error
   // so that devtools can give a clear message about it.
-  // $FlowFixMe: Flow doesn't know about 2nd argument of Error constructor
+  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor
   const wrapperError = new Error('Error rendering inspected component', {
     cause: error,
   });
@@ -682,7 +682,7 @@ function handleRenderFunctionError(error: any): void {
   // TODO: refactor this if we ever combine the devtools and debug tools packages
   wrapperError.name = 'ReactDebugToolsRenderError';
   // this stage-4 proposal is not supported by all environments yet.
-  // $FlowFixMe Flow doesn't have this type yet.
+  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.
   wrapperError.cause = error;
   throw wrapperError;
 }

commit 767f52237cf7892ad07726f21e3e8bacfc8af839
Author: Sophie Alpert <git@sophiebits.com>
Date:   Wed Apr 19 14:26:01 2023 -0700

    Use .slice() for all substring-ing (#26677)
    
    - substr is Annex B
    - substring silently flips its arguments if they're in the "wrong order", which is confusing
    - slice is better than sliced bread (no pun intended) and also it works the same way on Arrays so there's less to remember
    
    ---
    
    > I'd be down to just lint and enforce a single form just for the potential compression savings by using a repeated string.
    
    _Originally posted by @sebmarkbage in https://github.com/facebook/react/pull/26663#discussion_r1170455401_

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 44d99922df..bed4c2fead 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -513,10 +513,10 @@ function parseCustomHookName(functionName: void | string): string {
   if (startIndex === -1) {
     startIndex = 0;
   }
-  if (functionName.substr(startIndex, 3) === 'use') {
+  if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     startIndex += 3;
   }
-  return functionName.substr(startIndex);
+  return functionName.slice(startIndex);
 }
 
 function buildTree(

commit 7ce765ec321a6f213019b56b36f9dccb2a8a7d5c
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Apr 23 14:50:17 2023 -0400

    Clean up enableUseHook flag (#26707)
    
    This has been statically enabled everywhere for months.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index bed4c2fead..362e5f36d2 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -106,6 +106,13 @@ function readContext<T>(context: ReactContext<T>): T {
   return context._currentValue;
 }
 
+function use<T>(): T {
+  // TODO: What should this do if it receives an unresolved promise?
+  throw new Error(
+    'Support for `use` not yet implemented in react-debug-tools.',
+  );
+}
+
 function useContext<T>(context: ReactContext<T>): T {
   hookLog.push({
     primitive: 'Context',
@@ -327,6 +334,7 @@ function useId(): string {
 }
 
 const Dispatcher: DispatcherType = {
+  use,
   readContext,
   useCacheRefresh,
   useCallback,

commit 25b99efe0c9c9d593c86829386c86740d409fa8c
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Apr 25 09:19:25 2023 -0700

    [DevTools] Add support for useMemoCache (#26696)
    
    useMemoCache wasn't previously supported in the DevTools, so any attempt
    to inspect a component using the hook would result in a
    `dispatcher.useMemoCache is not a function (it is undefined)` error.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 362e5f36d2..42fc7fbe16 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -51,9 +51,19 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
+type MemoCache = {
+  data: Array<Array<any>>,
+  index: number,
+};
+
+type FunctionComponentUpdateQueue = {
+  memoCache?: MemoCache | null,
+};
+
 type Hook = {
   memoizedState: any,
   next: Hook | null,
+  updateQueue: FunctionComponentUpdateQueue | null,
 };
 
 function getPrimitiveStackCache(): Map<string, Array<any>> {
@@ -79,6 +89,10 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
       Dispatcher.useMemo(() => null);
+      if (typeof Dispatcher.useMemoCache === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useMemoCache(0);
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -333,6 +347,38 @@ function useId(): string {
   return id;
 }
 
+function useMemoCache(size: number): Array<any> {
+  const hook = nextHook();
+  let memoCache: MemoCache;
+  if (
+    hook !== null &&
+    hook.updateQueue !== null &&
+    hook.updateQueue.memoCache != null
+  ) {
+    memoCache = hook.updateQueue.memoCache;
+  } else {
+    memoCache = {
+      data: [],
+      index: 0,
+    };
+  }
+
+  let data = memoCache.data[memoCache.index];
+  if (data === undefined) {
+    const MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+    data = new Array(size);
+    for (let i = 0; i < size; i++) {
+      data[i] = MEMO_CACHE_SENTINEL;
+    }
+  }
+  hookLog.push({
+    primitive: 'MemoCache',
+    stackError: new Error(),
+    value: data,
+  });
+  return data;
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -345,6 +391,7 @@ const Dispatcher: DispatcherType = {
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
+  useMemoCache,
   useReducer,
   useRef,
   useState,

commit 80d9a40114bb43c07d021e8254790852f450bd2b
Author: Noah Lemen <noah.lemen@gmail.com>
Date:   Tue Jun 27 12:45:46 2023 -0400

    Remove useMutableSource (#27011)
    
    ## Summary
    
    This PR cleans up `useMutableSource`. This has been blocked by a
    remaining dependency internally at Meta, but that has now been deleted.
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    ## How did you test this change?
    
    ```
    yarn flow
    yarn lint
    yarn test --prod
    ```
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 42fc7fbe16..6c8acd1e2f 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -8,9 +8,6 @@
  */
 
 import type {
-  MutableSource,
-  MutableSourceGetSnapshotFn,
-  MutableSourceSubscribeFn,
   ReactContext,
   ReactProviderType,
   StartTransitionOptions,
@@ -273,23 +270,6 @@ function useMemo<T>(
   return value;
 }
 
-function useMutableSource<Source, Snapshot>(
-  source: MutableSource<Source>,
-  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
-  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
-): Snapshot {
-  // useMutableSource() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  nextHook(); // MutableSource
-  nextHook(); // State
-  nextHook(); // Effect
-  nextHook(); // Effect
-  const value = getSnapshot(source._source);
-  hookLog.push({primitive: 'MutableSource', stackError: new Error(), value});
-  return value;
-}
-
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
@@ -396,7 +376,6 @@ const Dispatcher: DispatcherType = {
   useRef,
   useState,
   useTransition,
-  useMutableSource,
   useSyncExternalStore,
   useDeferredValue,
   useId,

commit be67db46b60d94f9fbefccf2523429af25873e5b
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 10 16:39:02 2023 -0400

    Add optional initialValue argument to useDeferredValue (#27500)
    
    Adds a second argument to useDeferredValue called initialValue:
    
    ```js
    const value = useDeferredValue(finalValue, initialValue);
    ```
    
    During the initial render of a component, useDeferredValue will return
    initialValue. Once that render finishes, it will spawn an additional
    render to switch to finalValue.
    
    This same sequence should occur whenever the hook is hidden and revealed
    again, i.e. by a Suspense or Activity, though this part is not yet
    implemented.
    
    When initialValue is not provided, useDeferredValue has no effect during
    initial render, but during an update, it will remain on the previous
    value, then spawn an additional render to switch to the new value. (This
    is the same behavior that exists today.)
    
    During SSR, initialValue is always used, if provided.
    
    This feature is currently behind an experimental flag. We plan to ship
    it in a non-breaking release.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 6c8acd1e2f..2d75ff127e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -306,7 +306,7 @@ function useTransition(): [
   return [false, callback => {}];
 }
 
-function useDeferredValue<T>(value: T): T {
+function useDeferredValue<T>(value: T, initialValue?: T): T {
   const hook = nextHook();
   hookLog.push({
     primitive: 'DeferredValue',

commit a4195750779dbd9a13e1615fbbd493bf2c5768ca
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Tue Oct 17 18:39:10 2023 +0100

    fix[devtools/useMemoCache]: add stub for useMemoCache in ReactDebugHook (#27472)
    
    Currently, we have this error in our logs of the internal version of
    React DevTools:
    ```
    TypeError: Cannot read properties of undefined (reading 'memoCache')
        at Proxy.useMemoCache (chrome-extension://dnjnjgbfilfphmojnmhliehogmojhclc/build/react_devtools_backend_compact.js:151:71)
    ```
    
    Looking at the build files of the extension, it fails here:
    https://github.com/facebook/react/blob/dddfe688206dafa5646550d351eb9a8e9c53654a/packages/react-debug-tools/src/ReactDebugHooks.js#L333-L337
    
    Looks like `updateQueue` can be `undefined`, as it is not defined in
    hook object here:
    https://github.com/facebook/react/blob/dddfe688206dafa5646550d351eb9a8e9c53654a/packages/react-reconciler/src/ReactFiberHooks.js#L180-L186
    
    ~~Also, it looks like `useMemoCache` implementation doesn't expect this,
    so it should also result into TypeError here, line 1114:~~
    
    https://github.com/facebook/react/blob/dddfe688206dafa5646550d351eb9a8e9c53654a/packages/react-reconciler/src/ReactFiberHooks.js#L1108-L1115
    
    ~~Should this also be updated?~~

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2d75ff127e..8215c731a6 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -48,19 +48,9 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type MemoCache = {
-  data: Array<Array<any>>,
-  index: number,
-};
-
-type FunctionComponentUpdateQueue = {
-  memoCache?: MemoCache | null,
-};
-
 type Hook = {
   memoizedState: any,
   next: Hook | null,
-  updateQueue: FunctionComponentUpdateQueue | null,
 };
 
 function getPrimitiveStackCache(): Map<string, Array<any>> {
@@ -327,36 +317,11 @@ function useId(): string {
   return id;
 }
 
+// useMemoCache is an implementation detail of Forget's memoization
+// it should not be called directly in user-generated code
+// we keep it as a stub for dispatcher
 function useMemoCache(size: number): Array<any> {
-  const hook = nextHook();
-  let memoCache: MemoCache;
-  if (
-    hook !== null &&
-    hook.updateQueue !== null &&
-    hook.updateQueue.memoCache != null
-  ) {
-    memoCache = hook.updateQueue.memoCache;
-  } else {
-    memoCache = {
-      data: [],
-      index: 0,
-    };
-  }
-
-  let data = memoCache.data[memoCache.index];
-  if (data === undefined) {
-    const MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
-    data = new Array(size);
-    for (let i = 0; i < size; i++) {
-      data[i] = MEMO_CACHE_SENTINEL;
-    }
-  }
-  hookLog.push({
-    primitive: 'MemoCache',
-    stackError: new Error(),
-    value: data,
-  });
-  return data;
+  return [];
 }
 
 const Dispatcher: DispatcherType = {
@@ -725,7 +690,7 @@ export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
   currentDispatcher: ?CurrentDispatcherRef,
-  includeHooksSource?: boolean = false,
+  includeHooksSource: boolean = false,
 ): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
@@ -816,7 +781,7 @@ function resolveDefaultProps(Component: any, baseProps: any) {
 export function inspectHooksOfFiber(
   fiber: Fiber,
   currentDispatcher: ?CurrentDispatcherRef,
-  includeHooksSource?: boolean = false,
+  includeHooksSource: boolean = false,
 ): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.

commit aec521a96d3f1bebc2ba38553d14f4989c6e88e0
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Tue Nov 14 18:23:39 2023 +0000

    fix[devtools/useMemoCache]: implement a working copy of useMemoCache (#27659)
    
    In https://github.com/facebook/react/pull/27472 I've removed broken
    `useMemoCache` implementation and replaced it with a stub. It actually
    produces errors when trying to inspect components, which are compiled
    with Forget.
    
    The main difference from the implementation in
    https://github.com/facebook/react/pull/26696 is that we are using
    corresponding `Fiber` here, which has patched `updateQueue` with
    `memoCache`. Previously we would check it on a hook object, which
    doesn't have `updateQueue`.
    
    Tested on pages, which are using Forget and by inspecting elements,
    which are transpiled with Forget.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 8215c731a6..7e2e2effb1 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -26,6 +26,7 @@ import {
   ContextProvider,
   ForwardRef,
 } from 'react-reconciler/src/ReactWorkTags';
+import {REACT_MEMO_CACHE_SENTINEL} from 'shared/ReactSymbols';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
@@ -93,7 +94,9 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
   return primitiveStackCache;
 }
 
+let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
+
 function nextHook(): null | Hook {
   const hook = currentHook;
   if (hook !== null) {
@@ -319,9 +322,31 @@ function useId(): string {
 
 // useMemoCache is an implementation detail of Forget's memoization
 // it should not be called directly in user-generated code
-// we keep it as a stub for dispatcher
 function useMemoCache(size: number): Array<any> {
-  return [];
+  const fiber = currentFiber;
+  // Don't throw, in case this is called from getPrimitiveStackCache
+  if (fiber == null) {
+    return [];
+  }
+
+  // $FlowFixMe[incompatible-use]: updateQueue is mixed
+  const memoCache = fiber.updateQueue?.memoCache;
+  if (memoCache == null) {
+    return [];
+  }
+
+  let data = memoCache.data[memoCache.index];
+  if (data === undefined) {
+    data = memoCache.data[memoCache.index] = new Array(size);
+    for (let i = 0; i < size; i++) {
+      data[i] = REACT_MEMO_CACHE_SENTINEL;
+    }
+  }
+
+  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.
+
+  memoCache.index++;
+  return data;
 }
 
 const Dispatcher: DispatcherType = {
@@ -699,9 +724,11 @@ export function inspectHooks<Props>(
   }
 
   const previousDispatcher = currentDispatcher.current;
-  let readHookLog;
   currentDispatcher.current = DispatcherProxy;
+
+  let readHookLog;
   let ancestorStackError;
+
   try {
     ancestorStackError = new Error();
     renderFunction(props);
@@ -798,19 +825,25 @@ export function inspectHooksOfFiber(
       'Unknown Fiber. Needs to be a function component to inspect hooks.',
     );
   }
+
   // Warm up the cache so that it doesn't consume the currentHook.
   getPrimitiveStackCache();
+
+  // Set up the current hook so that we can step through and read the
+  // current state from them.
+  currentHook = (fiber.memoizedState: Hook);
+  currentFiber = fiber;
+
   const type = fiber.type;
   let props = fiber.memoizedProps;
   if (type !== fiber.elementType) {
     props = resolveDefaultProps(type, props);
   }
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
-  currentHook = (fiber.memoizedState: Hook);
-  const contextMap = new Map<ReactContext<$FlowFixMe>, $FlowFixMe>();
+
+  const contextMap = new Map<ReactContext<any>, any>();
   try {
     setupContexts(contextMap, fiber);
+
     if (fiber.tag === ForwardRef) {
       return inspectHooksOfForwardRef(
         type.render,
@@ -820,9 +853,12 @@ export function inspectHooksOfFiber(
         includeHooksSource,
       );
     }
+
     return inspectHooks(type, props, currentDispatcher, includeHooksSource);
   } finally {
+    currentFiber = null;
     currentHook = null;
+
     restoreContexts(contextMap);
   }
 }

commit f498aa299292d4d1e999f66d1c769440ad10d57c
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Dec 4 16:10:36 2023 -0500

    Flow: make more objects exact (#27790)
    
    This makes a couple objects more exact. Nothing critical, just noticed
    this old branch I had created when doing some Flow upgrades in the past.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 7e2e2effb1..1110415482 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -36,7 +36,6 @@ type HookLogEntry = {
   primitive: string,
   stackError: Error,
   value: mixed,
-  ...
 };
 
 let hookLog: Array<HookLogEntry> = [];
@@ -408,7 +407,6 @@ export type HooksNode = {
   value: mixed,
   subHooks: Array<HooksNode>,
   hookSource?: HookSource,
-  ...
 };
 export type HooksTree = Array<HooksNode>;
 

commit 85cc01743bc992a689770a4f37e3d5441f14f082
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Fri Feb 2 23:18:16 2024 +0100

    DevTools: Add support for useOptimistic Hook (#27982)
    
    ## Summary
    
    Add support for `useOptimistic` Hook fixing "Unsupported hook in the
    react-debug-tools package: Missing method in Dispatcher: useOptimistic"
    when inspecting components using `useOptimistic`
    
    ## How did you test this change?
    
    - Added test following the same pattern as for `useDeferredValue`

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1110415482..9eab7a4a6b 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -80,6 +80,11 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         // This type check is for Flow only.
         Dispatcher.useMemoCache(0);
       }
+
+      if (typeof Dispatcher.useOptimistic === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -348,6 +353,25 @@ function useMemoCache(size: number): Array<any> {
   return data;
 }
 
+function useOptimistic<S, A>(
+  passthrough: S,
+  reducer: ?(S, A) => S,
+): [S, (A) => void] {
+  const hook = nextHook();
+  let state;
+  if (hook !== null) {
+    state = hook.memoizedState;
+  } else {
+    state = passthrough;
+  }
+  hookLog.push({
+    primitive: 'Optimistic',
+    stackError: new Error(),
+    value: state,
+  });
+  return [state, (action: A) => {}];
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -361,6 +385,7 @@ const Dispatcher: DispatcherType = {
   useInsertionEffect,
   useMemo,
   useMemoCache,
+  useOptimistic,
   useReducer,
   useRef,
   useState,

commit 56cd10beb40586d09e91157e8f6ac531478a62be
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Mon Feb 5 15:39:45 2024 +0100

    DevTools: Add support for useFormState (#28232)
    
    ## Summary
    
    Add support for `useFormState` Hook fixing "Unsupported hook in the
    react-debug-tools package: Missing method in Dispatcher: useFormState"
    when inspecting components using `useFormState`
    
    ## How did you test this change?
    
    - Added test to ReactHooksInspectionIntegration
    - Added dedicated section for form actions to devtools-shell
    ![Screenshot 2024-02-04 at 12 02
    05](https://github.com/facebook/react/assets/12292047/bb274789-64b8-4594-963e-87c4b6962144)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 9eab7a4a6b..b4b0f97e2e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -8,6 +8,7 @@
  */
 
 import type {
+  Awaited,
   ReactContext,
   ReactProviderType,
   StartTransitionOptions,
@@ -80,11 +81,14 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         // This type check is for Flow only.
         Dispatcher.useMemoCache(0);
       }
-
       if (typeof Dispatcher.useOptimistic === 'function') {
         // This type check is for Flow only.
         Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
       }
+      if (typeof Dispatcher.useFormState === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -372,6 +376,27 @@ function useOptimistic<S, A>(
   return [state, (action: A) => {}];
 }
 
+function useFormState<S, P>(
+  action: (Awaited<S>, P) => S,
+  initialState: Awaited<S>,
+  permalink?: string,
+): [Awaited<S>, (P) => void] {
+  const hook = nextHook(); // FormState
+  nextHook(); // ActionQueue
+  let state;
+  if (hook !== null) {
+    state = hook.memoizedState;
+  } else {
+    state = initialState;
+  }
+  hookLog.push({
+    primitive: 'FormState',
+    stackError: new Error(),
+    value: state,
+  });
+  return [state, (payload: P) => {}];
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -393,6 +418,7 @@ const Dispatcher: DispatcherType = {
   useSyncExternalStore,
   useDeferredValue,
   useId,
+  useFormState,
 };
 
 // create a proxy to throw a custom error

commit 04b59928d867dae1639f12f19700347d8f5d4cac
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Feb 8 18:47:40 2024 +0100

    DevTools: Add support for use(Context) (#28233)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b4b0f97e2e..e8dc2578be 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -12,6 +12,7 @@ import type {
   ReactContext,
   ReactProviderType,
   StartTransitionOptions,
+  Usable,
 } from 'shared/ReactTypes';
 import type {
   Fiber,
@@ -27,7 +28,10 @@ import {
   ContextProvider,
   ForwardRef,
 } from 'react-reconciler/src/ReactWorkTags';
-import {REACT_MEMO_CACHE_SENTINEL} from 'shared/ReactSymbols';
+import {
+  REACT_MEMO_CACHE_SENTINEL,
+  REACT_CONTEXT_TYPE,
+} from 'shared/ReactSymbols';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
@@ -118,11 +122,30 @@ function readContext<T>(context: ReactContext<T>): T {
   return context._currentValue;
 }
 
-function use<T>(): T {
-  // TODO: What should this do if it receives an unresolved promise?
-  throw new Error(
-    'Support for `use` not yet implemented in react-debug-tools.',
-  );
+function use<T>(usable: Usable<T>): T {
+  if (usable !== null && typeof usable === 'object') {
+    // $FlowFixMe[method-unbinding]
+    if (typeof usable.then === 'function') {
+      // TODO: What should this do if it receives an unresolved promise?
+      throw new Error(
+        'Support for `use(Promise)` not yet implemented in react-debug-tools.',
+      );
+    } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
+      const context: ReactContext<T> = (usable: any);
+      const value = readContext(context);
+
+      hookLog.push({
+        primitive: 'Use',
+        stackError: new Error(),
+        value,
+      });
+
+      return value;
+    }
+  }
+
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  throw new Error('An unsupported type was passed to use(): ' + String(usable));
 }
 
 function useContext<T>(context: ReactContext<T>): T {
@@ -660,7 +683,9 @@ function buildTree(
     // For now, the "id" of stateful hooks is just the stateful hook index.
     // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
     const id =
-      primitive === 'Context' || primitive === 'DebugValue'
+      primitive === 'Context' ||
+      primitive === 'DebugValue' ||
+      primitive === 'Use'
         ? null
         : nativeHookID++;
 

commit 7a32d718b9ea0eb9ea86e9d21d56a5af6c4ce9ed
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Feb 12 17:54:28 2024 -0500

    [Debug Tools] Introspect Promises in use() (#28297)
    
    Alternative to #28295.
    
    Instead of stashing all of the Usables eagerly, we can extract them by
    replaying the render when we need them like we do with any other hook.
    We already had an implementation of `use()` but it wasn't quite
    complete.
    
    These can also include further DebugInfo on them such as what Server
    Component rendered the Promise or async debug info. This is nice just to
    see which use() calls were made in the side-panel but it can also be
    used to gather everything that might have suspended.
    
    Together with https://github.com/facebook/react/pull/28286 we cover the
    case when a Promise was used a child and if it was unwrapped with use().
    Notably we don't cover a Promise that was thrown (although we do support
    that in a Server Component which maybe we shouldn't). Throwing a Promise
    isn't officially supported though and that use case should move to the
    use() Hook.
    
    The pattern of conditionally suspending based on cache also isn't really
    supported with the use() pattern. You should always call use() if you
    previously called use() with the same input. This also ensures that we
    can track what might have suspended rather than what actually did.
    
    One limitation of this strategy is that it's hard to find all the places
    something might suspend in a tree without rerendering all the fibers
    again. So we might need to still add something to the tree to indicate
    which Fibers may have further debug info / thenables.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index e8dc2578be..962d7d8bba 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -13,6 +13,8 @@ import type {
   ReactProviderType,
   StartTransitionOptions,
   Usable,
+  Thenable,
+  ReactDebugInfo,
 } from 'shared/ReactTypes';
 import type {
   Fiber,
@@ -41,6 +43,7 @@ type HookLogEntry = {
   primitive: string,
   stackError: Error,
   value: mixed,
+  debugInfo: ReactDebugInfo | null,
 };
 
 let hookLog: Array<HookLogEntry> = [];
@@ -93,6 +96,27 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         // This type check is for Flow only.
         Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
       }
+      if (typeof Dispatcher.use === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.use(
+          ({
+            $$typeof: REACT_CONTEXT_TYPE,
+            _currentValue: null,
+          }: any),
+        );
+        Dispatcher.use({
+          then() {},
+          status: 'fulfilled',
+          value: null,
+        });
+        try {
+          Dispatcher.use(
+            ({
+              then() {},
+            }: any),
+          );
+        } catch (x) {}
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -122,22 +146,57 @@ function readContext<T>(context: ReactContext<T>): T {
   return context._currentValue;
 }
 
+const SuspenseException: mixed = new Error(
+  "Suspense Exception: This is not a real error! It's an implementation " +
+    'detail of `use` to interrupt the current render. You must either ' +
+    'rethrow it immediately, or move the `use` call outside of the ' +
+    '`try/catch` block. Capturing without rethrowing will lead to ' +
+    'unexpected behavior.\n\n' +
+    'To handle async errors, wrap your component in an error boundary, or ' +
+    "call the promise's `.catch` method and pass the result to `use`",
+);
+
 function use<T>(usable: Usable<T>): T {
   if (usable !== null && typeof usable === 'object') {
     // $FlowFixMe[method-unbinding]
     if (typeof usable.then === 'function') {
-      // TODO: What should this do if it receives an unresolved promise?
-      throw new Error(
-        'Support for `use(Promise)` not yet implemented in react-debug-tools.',
-      );
+      const thenable: Thenable<any> = (usable: any);
+      switch (thenable.status) {
+        case 'fulfilled': {
+          const fulfilledValue: T = thenable.value;
+          hookLog.push({
+            primitive: 'Promise',
+            stackError: new Error(),
+            value: fulfilledValue,
+            debugInfo:
+              thenable._debugInfo === undefined ? null : thenable._debugInfo,
+          });
+          return fulfilledValue;
+        }
+        case 'rejected': {
+          const rejectedError = thenable.reason;
+          throw rejectedError;
+        }
+      }
+      // If this was an uncached Promise we have to abandon this attempt
+      // but we can still emit anything up until this point.
+      hookLog.push({
+        primitive: 'Unresolved',
+        stackError: new Error(),
+        value: thenable,
+        debugInfo:
+          thenable._debugInfo === undefined ? null : thenable._debugInfo,
+      });
+      throw SuspenseException;
     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
       const context: ReactContext<T> = (usable: any);
       const value = readContext(context);
 
       hookLog.push({
-        primitive: 'Use',
+        primitive: 'Context (use)',
         stackError: new Error(),
         value,
+        debugInfo: null,
       });
 
       return value;
@@ -153,6 +212,7 @@ function useContext<T>(context: ReactContext<T>): T {
     primitive: 'Context',
     stackError: new Error(),
     value: context._currentValue,
+    debugInfo: null,
   });
   return context._currentValue;
 }
@@ -168,7 +228,12 @@ function useState<S>(
       ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
         initialState()
       : initialState;
-  hookLog.push({primitive: 'State', stackError: new Error(), value: state});
+  hookLog.push({
+    primitive: 'State',
+    stackError: new Error(),
+    value: state,
+    debugInfo: null,
+  });
   return [state, (action: BasicStateAction<S>) => {}];
 }
 
@@ -188,6 +253,7 @@ function useReducer<S, I, A>(
     primitive: 'Reducer',
     stackError: new Error(),
     value: state,
+    debugInfo: null,
   });
   return [state, (action: A) => {}];
 }
@@ -199,6 +265,7 @@ function useRef<T>(initialValue: T): {current: T} {
     primitive: 'Ref',
     stackError: new Error(),
     value: ref.current,
+    debugInfo: null,
   });
   return ref;
 }
@@ -209,6 +276,7 @@ function useCacheRefresh(): () => void {
     primitive: 'CacheRefresh',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : function refresh() {},
+    debugInfo: null,
   });
   return () => {};
 }
@@ -222,6 +290,7 @@ function useLayoutEffect(
     primitive: 'LayoutEffect',
     stackError: new Error(),
     value: create,
+    debugInfo: null,
   });
 }
 
@@ -234,6 +303,7 @@ function useInsertionEffect(
     primitive: 'InsertionEffect',
     stackError: new Error(),
     value: create,
+    debugInfo: null,
   });
 }
 
@@ -242,7 +312,12 @@ function useEffect(
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
-  hookLog.push({primitive: 'Effect', stackError: new Error(), value: create});
+  hookLog.push({
+    primitive: 'Effect',
+    stackError: new Error(),
+    value: create,
+    debugInfo: null,
+  });
 }
 
 function useImperativeHandle<T>(
@@ -263,6 +338,7 @@ function useImperativeHandle<T>(
     primitive: 'ImperativeHandle',
     stackError: new Error(),
     value: instance,
+    debugInfo: null,
   });
 }
 
@@ -271,6 +347,7 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
     primitive: 'DebugValue',
     stackError: new Error(),
     value: typeof formatterFn === 'function' ? formatterFn(value) : value,
+    debugInfo: null,
   });
 }
 
@@ -280,6 +357,7 @@ function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
     primitive: 'Callback',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState[0] : callback,
+    debugInfo: null,
   });
   return callback;
 }
@@ -290,7 +368,12 @@ function useMemo<T>(
 ): T {
   const hook = nextHook();
   const value = hook !== null ? hook.memoizedState[0] : nextCreate();
-  hookLog.push({primitive: 'Memo', stackError: new Error(), value});
+  hookLog.push({
+    primitive: 'Memo',
+    stackError: new Error(),
+    value,
+    debugInfo: null,
+  });
   return value;
 }
 
@@ -309,6 +392,7 @@ function useSyncExternalStore<T>(
     primitive: 'SyncExternalStore',
     stackError: new Error(),
     value,
+    debugInfo: null,
   });
   return value;
 }
@@ -326,6 +410,7 @@ function useTransition(): [
     primitive: 'Transition',
     stackError: new Error(),
     value: undefined,
+    debugInfo: null,
   });
   return [false, callback => {}];
 }
@@ -336,6 +421,7 @@ function useDeferredValue<T>(value: T, initialValue?: T): T {
     primitive: 'DeferredValue',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : value,
+    debugInfo: null,
   });
   return value;
 }
@@ -347,6 +433,7 @@ function useId(): string {
     primitive: 'Id',
     stackError: new Error(),
     value: id,
+    debugInfo: null,
   });
   return id;
 }
@@ -395,6 +482,7 @@ function useOptimistic<S, A>(
     primitive: 'Optimistic',
     stackError: new Error(),
     value: state,
+    debugInfo: null,
   });
   return [state, (action: A) => {}];
 }
@@ -416,6 +504,7 @@ function useFormState<S, P>(
     primitive: 'FormState',
     stackError: new Error(),
     value: state,
+    debugInfo: null,
   });
   return [state, (payload: P) => {}];
 }
@@ -480,6 +569,7 @@ export type HooksNode = {
   name: string,
   value: mixed,
   subHooks: Array<HooksNode>,
+  debugInfo: null | ReactDebugInfo,
   hookSource?: HookSource,
 };
 export type HooksTree = Array<HooksNode>;
@@ -546,6 +636,15 @@ function isReactWrapper(functionName: any, primitiveName: string) {
   if (!functionName) {
     return false;
   }
+  switch (primitiveName) {
+    case 'Context':
+    case 'Context (use)':
+    case 'Promise':
+    case 'Unresolved':
+      if (functionName.endsWith('use')) {
+        return true;
+      }
+  }
   const expectedPrimitiveName = 'use' + primitiveName;
   if (functionName.length < expectedPrimitiveName.length) {
     return false;
@@ -661,6 +760,7 @@ function buildTree(
           name: parseCustomHookName(stack[j - 1].functionName),
           value: undefined,
           subHooks: children,
+          debugInfo: null,
         };
 
         if (includeHooksSource) {
@@ -678,25 +778,29 @@ function buildTree(
       }
       prevStack = stack;
     }
-    const {primitive} = hook;
+    const {primitive, debugInfo} = hook;
 
     // For now, the "id" of stateful hooks is just the stateful hook index.
     // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
     const id =
       primitive === 'Context' ||
+      primitive === 'Context (use)' ||
       primitive === 'DebugValue' ||
-      primitive === 'Use'
+      primitive === 'Promise' ||
+      primitive === 'Unresolved'
         ? null
         : nativeHookID++;
 
     // For the time being, only State and Reducer hooks support runtime overrides.
     const isStateEditable = primitive === 'Reducer' || primitive === 'State';
+    const name = primitive === 'Context (use)' ? 'Context' : primitive;
     const levelChild: HooksNode = {
       id,
       isStateEditable,
-      name: primitive,
+      name: name,
       value: hook.value,
       subHooks: [],
+      debugInfo: debugInfo,
     };
 
     if (includeHooksSource) {
@@ -762,6 +866,11 @@ function processDebugValues(
 
 function handleRenderFunctionError(error: any): void {
   // original error might be any type.
+  if (error === SuspenseException) {
+    // An uncached Promise was used. We can't synchronously resolve the rest of
+    // the Hooks but we can at least show what ever we got so far.
+    return;
+  }
   if (
     error instanceof Error &&
     error.name === 'ReactDebugToolsUnsupportedHookError'

commit 14fd9630ee04387f4361da289393234e2b7d93b6
Author: dan <dan.abramov@me.com>
Date:   Tue Feb 13 15:04:49 2024 +0000

    Switch <Context> to mean <Context.Provider> (#28226)
    
    Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
    since the introduction of Hooks, the `<Context.Consumer>` API is rarely
    used. The goal here is to make the common case cleaner:
    
    ```js
    const ThemeContext = createContext('light')
    
    function App() {
      return (
        <ThemeContext value="dark">
          ...
        </ThemeContext>
      )
    }
    
    function Button() {
      const theme = use(ThemeContext)
      // ...
    }
    ```
    
    This is technically a breaking change, but we've been warning about
    rendering `<Context>` directly for several years by now, so it's
    unlikely much code in the wild depends on the old behavior. [Proof that
    it warns today (check
    console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)
    
    ---
    
    **The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
    switches `createContext` implementation so that `Context.Provider ===
    Context`.
    
    The main assumption that changed is that a Provider's fiber type is now
    the context itself (rather than an intermediate object). Whereas a
    Consumer's fiber type is now always an intermediate object (rather than
    it being sometimes the context itself and sometimes an intermediate
    object).
    
    My methodology was to start with the relevant symbols, work tags, and
    types, and work my way backwards to all usages.
    
    This might break tooling that depends on inspecting React's internal
    fields. I've added DevTools support in the second commit. This didn't
    need explicit versioning—the structure tells us enough.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 962d7d8bba..103cfa08f0 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -10,7 +10,6 @@
 import type {
   Awaited,
   ReactContext,
-  ReactProviderType,
   StartTransitionOptions,
   Usable,
   Thenable,
@@ -931,8 +930,11 @@ function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
   let current: null | Fiber = fiber;
   while (current) {
     if (current.tag === ContextProvider) {
-      const providerType: ReactProviderType<any> = current.type;
-      const context: ReactContext<any> = providerType._context;
+      let context: ReactContext<any> = current.type;
+      if ((context: any)._context !== undefined) {
+        // Support inspection of pre-19+ providers.
+        context = (context: any)._context;
+      }
       if (!contextMap.has(context)) {
         // Store the current value that we're going to restore later.
         contextMap.set(context, context._currentValue);

commit f0e808e5bcbfdaa24a8a0893cd718f4d189f2369
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Feb 14 11:07:35 2024 -0500

    [Debug Tools] Always use includeHooksSource option (#28309)
    
    This option was added defensively but it's not needed. There's no cost
    to including it always.
    
    I suspect this optional was added mainly to avoid needing to update
    tests. That's not a reason to have an unnecessary public API though.
    
    We have a praxis for dealing with source location in tests to avoid them
    failing tests. I also ported them to inline snapshots so that additions
    to the protocol isn't such a pain.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 103cfa08f0..e6a85b86a8 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -569,7 +569,7 @@ export type HooksNode = {
   value: mixed,
   subHooks: Array<HooksNode>,
   debugInfo: null | ReactDebugInfo,
-  hookSource?: HookSource,
+  hookSource: null | HookSource,
 };
 export type HooksTree = Array<HooksNode>;
 
@@ -716,7 +716,6 @@ function parseCustomHookName(functionName: void | string): string {
 function buildTree(
   rootStack: any,
   readHookLog: Array<HookLogEntry>,
-  includeHooksSource: boolean,
 ): HooksTree {
   const rootChildren: Array<HooksNode> = [];
   let prevStack = null;
@@ -760,16 +759,13 @@ function buildTree(
           value: undefined,
           subHooks: children,
           debugInfo: null,
-        };
-
-        if (includeHooksSource) {
-          levelChild.hookSource = {
+          hookSource: {
             lineNumber: stackFrame.lineNumber,
             columnNumber: stackFrame.columnNumber,
             functionName: stackFrame.functionName,
             fileName: stackFrame.fileName,
-          };
-        }
+          },
+        };
 
         levelChildren.push(levelChild);
         stackOfChildren.push(levelChildren);
@@ -800,26 +796,25 @@ function buildTree(
       value: hook.value,
       subHooks: [],
       debugInfo: debugInfo,
+      hookSource: null,
     };
 
-    if (includeHooksSource) {
-      const hookSource: HookSource = {
-        lineNumber: null,
-        functionName: null,
-        fileName: null,
-        columnNumber: null,
-      };
-      if (stack && stack.length >= 1) {
-        const stackFrame = stack[0];
-        hookSource.lineNumber = stackFrame.lineNumber;
-        hookSource.functionName = stackFrame.functionName;
-        hookSource.fileName = stackFrame.fileName;
-        hookSource.columnNumber = stackFrame.columnNumber;
-      }
-
-      levelChild.hookSource = hookSource;
+    const hookSource: HookSource = {
+      lineNumber: null,
+      functionName: null,
+      fileName: null,
+      columnNumber: null,
+    };
+    if (stack && stack.length >= 1) {
+      const stackFrame = stack[0];
+      hookSource.lineNumber = stackFrame.lineNumber;
+      hookSource.functionName = stackFrame.functionName;
+      hookSource.fileName = stackFrame.fileName;
+      hookSource.columnNumber = stackFrame.columnNumber;
     }
 
+    levelChild.hookSource = hookSource;
+
     levelChildren.push(levelChild);
   }
 
@@ -897,7 +892,6 @@ export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
   currentDispatcher: ?CurrentDispatcherRef,
-  includeHooksSource: boolean = false,
 ): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
@@ -923,7 +917,7 @@ export function inspectHooks<Props>(
     currentDispatcher.current = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog, includeHooksSource);
+  return buildTree(rootStack, readHookLog);
 }
 
 function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
@@ -955,7 +949,6 @@ function inspectHooksOfForwardRef<Props, Ref>(
   props: Props,
   ref: Ref,
   currentDispatcher: CurrentDispatcherRef,
-  includeHooksSource: boolean,
 ): HooksTree {
   const previousDispatcher = currentDispatcher.current;
   let readHookLog;
@@ -972,7 +965,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
     currentDispatcher.current = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog, includeHooksSource);
+  return buildTree(rootStack, readHookLog);
 }
 
 function resolveDefaultProps(Component: any, baseProps: any) {
@@ -993,7 +986,6 @@ function resolveDefaultProps(Component: any, baseProps: any) {
 export function inspectHooksOfFiber(
   fiber: Fiber,
   currentDispatcher: ?CurrentDispatcherRef,
-  includeHooksSource: boolean = false,
 ): HooksTree {
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
@@ -1035,11 +1027,10 @@ export function inspectHooksOfFiber(
         props,
         fiber.ref,
         currentDispatcher,
-        includeHooksSource,
       );
     }
 
-    return inspectHooks(type, props, currentDispatcher, includeHooksSource);
+    return inspectHooks(type, props, currentDispatcher);
   } finally {
     currentFiber = null;
     currentHook = null;

commit 47beb96ccf1085fe048c4d79d1f762566166d94e
Author: James Vaughan <james@jamesbvaughan.com>
Date:   Thu Feb 22 06:42:52 2024 -0500

    Add useSyncExternalStore and useTransition to getPrimitiveStackCache (#28399)
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn test --debug --watch TestName`,
    open `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    This solves the problem of the devtools extension failing to parse hook
    names for components that make use of `useSyncExternalStore` or
    `useTransition`.
    
    See #27889
    
    ## How did you test this change?
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    
    I tested this against my own codebases and against the example repro
    project that I linked in #27889.
    
    To test, I opened up the Components tab of the dev tools extension,
    selected a component with hooks that make use of `useSyncExternalStore`
    or `useTransition`, clicked the "parse hook names" magic wand button,
    and observed that it now succeeds.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index e6a85b86a8..1b285b562e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -82,6 +82,13 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
+      Dispatcher.useTransition();
+      Dispatcher.useSyncExternalStore(
+        () => () => {},
+        () => null,
+        () => null,
+      );
+      Dispatcher.useDeferredValue(null);
       Dispatcher.useMemo(() => null);
       if (typeof Dispatcher.useMemoCache === 'function') {
         // This type check is for Flow only.

commit aed00dacfb79d17c53218404c52b1c7aa59c4a89
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Sat Feb 24 11:54:26 2024 +0100

    devtools: Use context displayName for context hook name (#25954)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 1b285b562e..487aebe630 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -39,6 +39,7 @@ type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 // Used to track hooks called during a render
 
 type HookLogEntry = {
+  displayName: string | null,
   primitive: string,
   stackError: Error,
   value: mixed,
@@ -171,6 +172,7 @@ function use<T>(usable: Usable<T>): T {
         case 'fulfilled': {
           const fulfilledValue: T = thenable.value;
           hookLog.push({
+            displayName: null,
             primitive: 'Promise',
             stackError: new Error(),
             value: fulfilledValue,
@@ -187,6 +189,7 @@ function use<T>(usable: Usable<T>): T {
       // If this was an uncached Promise we have to abandon this attempt
       // but we can still emit anything up until this point.
       hookLog.push({
+        displayName: null,
         primitive: 'Unresolved',
         stackError: new Error(),
         value: thenable,
@@ -199,6 +202,7 @@ function use<T>(usable: Usable<T>): T {
       const value = readContext(context);
 
       hookLog.push({
+        displayName: context.displayName || 'Context',
         primitive: 'Context (use)',
         stackError: new Error(),
         value,
@@ -215,6 +219,7 @@ function use<T>(usable: Usable<T>): T {
 
 function useContext<T>(context: ReactContext<T>): T {
   hookLog.push({
+    displayName: context.displayName || null,
     primitive: 'Context',
     stackError: new Error(),
     value: context._currentValue,
@@ -235,6 +240,7 @@ function useState<S>(
         initialState()
       : initialState;
   hookLog.push({
+    displayName: null,
     primitive: 'State',
     stackError: new Error(),
     value: state,
@@ -256,6 +262,7 @@ function useReducer<S, I, A>(
     state = init !== undefined ? init(initialArg) : ((initialArg: any): S);
   }
   hookLog.push({
+    displayName: null,
     primitive: 'Reducer',
     stackError: new Error(),
     value: state,
@@ -268,6 +275,7 @@ function useRef<T>(initialValue: T): {current: T} {
   const hook = nextHook();
   const ref = hook !== null ? hook.memoizedState : {current: initialValue};
   hookLog.push({
+    displayName: null,
     primitive: 'Ref',
     stackError: new Error(),
     value: ref.current,
@@ -279,6 +287,7 @@ function useRef<T>(initialValue: T): {current: T} {
 function useCacheRefresh(): () => void {
   const hook = nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'CacheRefresh',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : function refresh() {},
@@ -293,6 +302,7 @@ function useLayoutEffect(
 ): void {
   nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'LayoutEffect',
     stackError: new Error(),
     value: create,
@@ -306,6 +316,7 @@ function useInsertionEffect(
 ): void {
   nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'InsertionEffect',
     stackError: new Error(),
     value: create,
@@ -319,6 +330,7 @@ function useEffect(
 ): void {
   nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'Effect',
     stackError: new Error(),
     value: create,
@@ -341,6 +353,7 @@ function useImperativeHandle<T>(
     instance = ref.current;
   }
   hookLog.push({
+    displayName: null,
     primitive: 'ImperativeHandle',
     stackError: new Error(),
     value: instance,
@@ -350,6 +363,7 @@ function useImperativeHandle<T>(
 
 function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
   hookLog.push({
+    displayName: null,
     primitive: 'DebugValue',
     stackError: new Error(),
     value: typeof formatterFn === 'function' ? formatterFn(value) : value,
@@ -360,6 +374,7 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
 function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
   const hook = nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'Callback',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState[0] : callback,
@@ -375,6 +390,7 @@ function useMemo<T>(
   const hook = nextHook();
   const value = hook !== null ? hook.memoizedState[0] : nextCreate();
   hookLog.push({
+    displayName: null,
     primitive: 'Memo',
     stackError: new Error(),
     value,
@@ -395,6 +411,7 @@ function useSyncExternalStore<T>(
   nextHook(); // Effect
   const value = getSnapshot();
   hookLog.push({
+    displayName: null,
     primitive: 'SyncExternalStore',
     stackError: new Error(),
     value,
@@ -413,6 +430,7 @@ function useTransition(): [
   nextHook(); // State
   nextHook(); // Callback
   hookLog.push({
+    displayName: null,
     primitive: 'Transition',
     stackError: new Error(),
     value: undefined,
@@ -424,6 +442,7 @@ function useTransition(): [
 function useDeferredValue<T>(value: T, initialValue?: T): T {
   const hook = nextHook();
   hookLog.push({
+    displayName: null,
     primitive: 'DeferredValue',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : value,
@@ -436,6 +455,7 @@ function useId(): string {
   const hook = nextHook();
   const id = hook !== null ? hook.memoizedState : '';
   hookLog.push({
+    displayName: null,
     primitive: 'Id',
     stackError: new Error(),
     value: id,
@@ -485,6 +505,7 @@ function useOptimistic<S, A>(
     state = passthrough;
   }
   hookLog.push({
+    displayName: null,
     primitive: 'Optimistic',
     stackError: new Error(),
     value: state,
@@ -507,6 +528,7 @@ function useFormState<S, P>(
     state = initialState;
   }
   hookLog.push({
+    displayName: null,
     primitive: 'FormState',
     stackError: new Error(),
     value: state,
@@ -780,7 +802,7 @@ function buildTree(
       }
       prevStack = stack;
     }
-    const {primitive, debugInfo} = hook;
+    const {displayName, primitive, debugInfo} = hook;
 
     // For now, the "id" of stateful hooks is just the stateful hook index.
     // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
@@ -795,7 +817,7 @@ function buildTree(
 
     // For the time being, only State and Reducer hooks support runtime overrides.
     const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-    const name = primitive === 'Context (use)' ? 'Context' : primitive;
+    const name = displayName || primitive;
     const levelChild: HooksNode = {
       id,
       isStateEditable,

commit fb10a2c66a923d218471b535fdaf0dbc530417ee
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Wed Feb 28 23:52:59 2024 +0100

    Devtools: Unwrap Promise in useFormState (#28319)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 487aebe630..446ac84631 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -521,19 +521,62 @@ function useFormState<S, P>(
 ): [Awaited<S>, (P) => void] {
   const hook = nextHook(); // FormState
   nextHook(); // ActionQueue
-  let state;
+  const stackError = new Error();
+  let value;
+  let debugInfo = null;
+  let error = null;
+
   if (hook !== null) {
-    state = hook.memoizedState;
+    const actionResult = hook.memoizedState;
+    if (
+      typeof actionResult === 'object' &&
+      actionResult !== null &&
+      // $FlowFixMe[method-unbinding]
+      typeof actionResult.then === 'function'
+    ) {
+      const thenable: Thenable<Awaited<S>> = (actionResult: any);
+      switch (thenable.status) {
+        case 'fulfilled': {
+          value = thenable.value;
+          debugInfo =
+            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          break;
+        }
+        case 'rejected': {
+          const rejectedError = thenable.reason;
+          error = rejectedError;
+          break;
+        }
+        default:
+          // If this was an uncached Promise we have to abandon this attempt
+          // but we can still emit anything up until this point.
+          error = SuspenseException;
+          debugInfo =
+            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          value = thenable;
+      }
+    } else {
+      value = (actionResult: any);
+    }
   } else {
-    state = initialState;
+    value = initialState;
   }
+
   hookLog.push({
     displayName: null,
     primitive: 'FormState',
-    stackError: new Error(),
-    value: state,
-    debugInfo: null,
+    stackError: stackError,
+    value: value,
+    debugInfo: debugInfo,
   });
+
+  if (error !== null) {
+    throw error;
+  }
+
+  // value being a Thenable is equivalent to error being not null
+  // i.e. we only reach this point with Awaited<S>
+  const state = ((value: any): Awaited<S>);
   return [state, (payload: P) => {}];
 }
 

commit 0066e0b68d90cc71a137f26b7c5bf6af73398fc2
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Wed Mar 6 15:38:01 2024 +0100

    Devtools: Display actual pending state when inspecting `useTransition` (#28499)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 446ac84631..68ac2587be 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -427,16 +427,19 @@ function useTransition(): [
   // useTransition() composes multiple hooks internally.
   // Advance the current hook index the same number of times
   // so that subsequent hooks have the right memoized state.
-  nextHook(); // State
+  const stateHook = nextHook();
   nextHook(); // Callback
+
+  const isPending = stateHook !== null ? stateHook.memoizedState : false;
+
   hookLog.push({
     displayName: null,
     primitive: 'Transition',
     stackError: new Error(),
-    value: undefined,
+    value: isPending,
     debugInfo: null,
   });
-  return [false, callback => {}];
+  return [isPending, () => {}];
 }
 
 function useDeferredValue<T>(value: T, initialValue?: T): T {

commit 17eaacaac167addf0c4358b4983f054073a0626d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 12 15:50:11 2024 -0400

    Add pending state to useFormState (#28514)
    
    ## Overview
    
    Adds a `pending` state to useFormState, which will be replaced by
    `useActionState` in the next diff. We will keep `useFormState` around
    for backwards compatibility, but functionally it will work the same as
    `useActionState`, which has an `isPending` state returned.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 68ac2587be..20e3d89e1b 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -521,8 +521,9 @@ function useFormState<S, P>(
   action: (Awaited<S>, P) => S,
   initialState: Awaited<S>,
   permalink?: string,
-): [Awaited<S>, (P) => void] {
+): [Awaited<S>, (P) => void, boolean] {
   const hook = nextHook(); // FormState
+  nextHook(); // PendingState
   nextHook(); // ActionQueue
   const stackError = new Error();
   let value;
@@ -580,7 +581,9 @@ function useFormState<S, P>(
   // value being a Thenable is equivalent to error being not null
   // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-  return [state, (payload: P) => {}];
+
+  // TODO: support displaying pending value
+  return [state, (payload: P) => {}, false];
 }
 
 const Dispatcher: DispatcherType = {

commit 7268dacf70cd6a7f5705a19053aad46b5289ab72
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Mar 14 15:41:50 2024 +0100

    Devtools: Ensure component control flow is consistent with commit when using `useDeferredValue (#28508)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 20e3d89e1b..8e1809435d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -444,14 +444,15 @@ function useTransition(): [
 
 function useDeferredValue<T>(value: T, initialValue?: T): T {
   const hook = nextHook();
+  const prevValue = hook !== null ? hook.memoizedState : value;
   hookLog.push({
     displayName: null,
     primitive: 'DeferredValue',
     stackError: new Error(),
-    value: hook !== null ? hook.memoizedState : value,
+    value: prevValue,
     debugInfo: null,
   });
-  return value;
+  return prevValue;
 }
 
 function useId(): string {

commit 5cec48e145f6b43879b9ef40cdda812b88fff31c
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Wed Mar 20 12:16:42 2024 +0100

    DevTools: Read context values from context dependencies (#28467)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 8e1809435d..a6770ccd34 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -16,6 +16,8 @@ import type {
   ReactDebugInfo,
 } from 'shared/ReactTypes';
 import type {
+  ContextDependency,
+  Dependencies,
   Fiber,
   Dispatcher as DispatcherType,
 } from 'react-reconciler/src/ReactInternalTypes';
@@ -33,6 +35,7 @@ import {
   REACT_MEMO_CACHE_SENTINEL,
   REACT_CONTEXT_TYPE,
 } from 'shared/ReactSymbols';
+import hasOwnProperty from 'shared/hasOwnProperty';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
 
@@ -139,6 +142,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
 let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
+let currentContextDependency: null | ContextDependency<mixed> = null;
 
 function nextHook(): null | Hook {
   const hook = currentHook;
@@ -149,8 +153,29 @@ function nextHook(): null | Hook {
 }
 
 function readContext<T>(context: ReactContext<T>): T {
-  // For now we don't expose readContext usage in the hooks debugging info.
-  return context._currentValue;
+  if (currentFiber === null) {
+    // Hook inspection without access to the Fiber tree
+    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
+    return context._currentValue;
+  } else {
+    if (currentContextDependency === null) {
+      throw new Error(
+        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',
+      );
+    }
+
+    // For now we don't expose readContext usage in the hooks debugging info.
+    const value = hasOwnProperty.call(currentContextDependency, 'memoizedValue')
+      ? // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+        ((currentContextDependency.memoizedValue: any): T)
+      : // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
+        // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+        ((currentContextDependency.context._currentValue: any): T);
+    // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+    currentContextDependency = currentContextDependency.next;
+
+    return value;
+  }
 }
 
 const SuspenseException: mixed = new Error(
@@ -218,14 +243,15 @@ function use<T>(usable: Usable<T>): T {
 }
 
 function useContext<T>(context: ReactContext<T>): T {
+  const value = readContext(context);
   hookLog.push({
     displayName: context.displayName || null,
     primitive: 'Context',
     stackError: new Error(),
-    value: context._currentValue,
+    value: value,
     debugInfo: null,
   });
-  return context._currentValue;
+  return value;
 }
 
 function useState<S>(
@@ -1090,15 +1116,44 @@ export function inspectHooksOfFiber(
   currentHook = (fiber.memoizedState: Hook);
   currentFiber = fiber;
 
+  if (hasOwnProperty.call(currentFiber, 'dependencies')) {
+    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
+    const dependencies = currentFiber.dependencies;
+    currentContextDependency =
+      dependencies !== null ? dependencies.firstContext : null;
+  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {
+    const dependencies: Dependencies = (currentFiber: any).dependencies_old;
+    currentContextDependency =
+      dependencies !== null ? dependencies.firstContext : null;
+  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {
+    const dependencies: Dependencies = (currentFiber: any).dependencies_new;
+    currentContextDependency =
+      dependencies !== null ? dependencies.firstContext : null;
+  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {
+    const contextDependencies = (currentFiber: any).contextDependencies;
+    currentContextDependency =
+      contextDependencies !== null ? contextDependencies.first : null;
+  } else {
+    throw new Error(
+      'Unsupported React version. This is a bug in React Debug Tools.',
+    );
+  }
+
   const type = fiber.type;
   let props = fiber.memoizedProps;
   if (type !== fiber.elementType) {
     props = resolveDefaultProps(type, props);
   }
 
+  // Only used for versions of React without memoized context value in context dependencies.
   const contextMap = new Map<ReactContext<any>, any>();
   try {
-    setupContexts(contextMap, fiber);
+    if (
+      currentContextDependency !== null &&
+      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
+    ) {
+      setupContexts(contextMap, fiber);
+    }
 
     if (fiber.tag === ForwardRef) {
       return inspectHooksOfForwardRef(
@@ -1113,6 +1168,7 @@ export function inspectHooksOfFiber(
   } finally {
     currentFiber = null;
     currentHook = null;
+    currentContextDependency = null;
 
     restoreContexts(contextMap);
   }

commit 5c65b27587c0507d66a84e055de948fc62d471d4
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Mar 22 13:03:44 2024 -0400

    Add `React.useActionState` (#28491)
    
    ## Overview
    
    _Depends on https://github.com/facebook/react/pull/28514_
    
    This PR adds a new React hook called `useActionState` to replace and
    improve the ReactDOM `useFormState` hook.
    
    ## Motivation
    
    This hook intends to fix some of the confusion and limitations of the
    `useFormState` hook.
    
    The `useFormState` hook is only exported from the `ReactDOM` package and
    implies that it is used only for the state of `<form>` actions, similar
    to `useFormStatus` (which is only for `<form>` element status). This
    leads to understandable confusion about why `useFormState` does not
    provide a `pending` state value like `useFormStatus` does.
    
    The key insight is that the `useFormState` hook does not actually return
    the state of any particular form at all. Instead, it returns the state
    of the _action_ passed to the hook, wrapping it and returning a
    trackable action to add to a form, and returning the last returned value
    of the action given. In fact, `useFormState` doesn't need to be used in
    a `<form>` at all.
    
    Thus, adding a `pending` value to `useFormState` as-is would thus be
    confusing because it would only return the pending state of the _action_
    given, not the `<form>` the action is passed to. Even if we wanted to
    tie them together, the returned `action` can be passed to multiple
    forms, creating confusing and conflicting pending states during multiple
    form submissions.
    
    Additionally, since the action is not related to any particular
    `<form>`, the hook can be used in any renderer - not only `react-dom`.
    For example, React Native could use the hook to wrap an action, pass it
    to a component that will unwrap it, and return the form result state and
    pending state. It's renderer agnostic.
    
    To fix these issues, this PR:
    - Renames `useFormState` to `useActionState`
    - Adds a `pending` state to the returned tuple
    - Moves the hook to the `'react'` package
    
    ## Reference
    
    The `useFormState` hook allows you to track the pending state and return
    value of a function (called an "action"). The function passed can be a
    plain JavaScript client function, or a bound server action to a
    reference on the server. It accepts an optional `initialState` value
    used for the initial render, and an optional `permalink` argument for
    renderer specific pre-hydration handling (such as a URL to support
    progressive hydration in `react-dom`).
    
    Type:
    
    ```ts
    function useActionState<State>(
            action: (state: Awaited<State>) => State | Promise<State>,
            initialState: Awaited<State>,
            permalink?: string,
        ): [state: Awaited<State>, dispatch: () => void, boolean];
    ```
    
    The hook returns a tuple with:
    - `state`: the last state the action returned
    - `dispatch`: the method to call to dispatch the wrapped action
    - `pending`: the pending state of the action and any state updates
    contained
    
    Notably, state updates inside of the action dispatched are wrapped in a
    transition to keep the page responsive while the action is completing
    and the UI is updated based on the result.
    
    ## Usage
    
    The `useActionState` hook can be used similar to `useFormState`:
    
    ```js
    import { useActionState } from "react"; // not react-dom
    
    function Form({ formAction }) {
      const [state, action, isPending] = useActionState(formAction);
    
      return (
        <form action={action}>
          <input type="email" name="email" disabled={isPending} />
          <button type="submit" disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </form>
      );
    }
    ```
    
    But it doesn't need to be used with a `<form/>` (neither did
    `useFormState`, hence the confusion):
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(someAction);
    
      async function handleSubmit() {
        // See caveats below
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    ## Benefits
    
    One of the benefits of using this hook is the automatic tracking of the
    return value and pending states of the wrapped function. For example,
    the above example could be accomplished via:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction }) {
      const ref = useRef(null);
      const [state, setState] = useState(null);
      const [isPending, setIsPending] = useTransition();
    
      function handleSubmit() {
        startTransition(async () => {
          const response = await someAction({ email: ref.current.value });
          setState(response);
        });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    However, this hook adds more benefits when used with render specific
    elements like react-dom `<form>` elements and Server Action. With
    `<form>` elements, React will automatically support replay actions on
    the form if it is submitted before hydration has completed, providing a
    form of partial progressive enhancement: enhancement for when javascript
    is enabled but not ready.
    
    Additionally, with the `permalink` argument and Server Actions,
    frameworks can provide full progressive enhancement support, submitting
    the form to the URL provided along with the FormData from the form. On
    submission, the Server Action will be called during the MPA navigation,
    similar to any raw HTML app, server rendered, and the result returned to
    the client without any JavaScript on the client.
    
    ## Caveats
    There are a few Caveats to this new hook:
    **Additional state update**: Since we cannot know whether you use the
    pending state value returned by the hook, the hook will always set the
    `isPending` state at the beginning of the first chained action,
    resulting in an additional state update similar to `useTransition`. In
    the future a type-aware compiler could optimize this for when the
    pending state is not accessed.
    
    **Pending state is for the action, not the handler**: The difference is
    subtle but important, the pending state begins when the return action is
    dispatched and will revert back after all actions and transitions have
    settled. The mechanism for this under the hook is the same as
    useOptimisitic.
    
    Concretely, what this means is that the pending state of
    `useActionState` will not represent any actions or sync work performed
    before dispatching the action returned by `useActionState`. Hopefully
    this is obvious based on the name and shape of the API, but there may be
    some temporary confusion.
    
    As an example, let's take the above example and await another action
    inside of it:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(someAction);
    
      async function handleSubmit() {
        await someOtherAction();
    
        // The pending state does not start until this call.
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    
    ```
    
    Since the pending state is related to the action, and not the handler or
    form it's attached to, the pending state only changes when the action is
    dispatched. To solve, there are two options.
    
    First (recommended): place the other function call inside of the action
    passed to `useActionState`:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(async (data) => {
        // Pending state is true already.
        await someOtherAction();
        return someAction(data);
      });
    
      async function handleSubmit() {
        // The pending state starts at this call.
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    For greater control, you can also wrap both in a transition and use the
    `isPending` state of the transition:
    
    ```js
    import { useActionState, useTransition, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
    
      // isPending is used from the transition wrapping both action calls.
      const [isPending, startTransition] = useTransition();
    
      // isPending not used from the individual action.
      const [state, action] = useActionState(someAction);
    
      async function handleSubmit() {
        startTransition(async () => {
          // The transition pending state has begun.
          await someOtherAction();
          await action({ email: ref.current.value });
        });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    A similar technique using `useOptimistic` is preferred over using
    `useTransition` directly, and is left as an exercise to the reader.
    
    ## Thanks
    
    Thanks to @ryanflorence @mjackson @wesbos
    (https://github.com/facebook/react/issues/27980#issuecomment-1960685940)
    and [Allan
    Lasser](https://allanlasser.com/posts/2024-01-26-avoid-using-reacts-useformstatus)
    for their feedback and suggestions on `useFormStatus` hook.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a6770ccd34..8d7477490d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -106,6 +106,10 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         // This type check is for Flow only.
         Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
       }
+      if (typeof Dispatcher.useActionState === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
+      }
       if (typeof Dispatcher.use === 'function') {
         // This type check is for Flow only.
         Dispatcher.use(
@@ -613,6 +617,75 @@ function useFormState<S, P>(
   return [state, (payload: P) => {}, false];
 }
 
+function useActionState<S, P>(
+  action: (Awaited<S>, P) => S,
+  initialState: Awaited<S>,
+  permalink?: string,
+): [Awaited<S>, (P) => void, boolean] {
+  const hook = nextHook(); // FormState
+  nextHook(); // PendingState
+  nextHook(); // ActionQueue
+  const stackError = new Error();
+  let value;
+  let debugInfo = null;
+  let error = null;
+
+  if (hook !== null) {
+    const actionResult = hook.memoizedState;
+    if (
+      typeof actionResult === 'object' &&
+      actionResult !== null &&
+      // $FlowFixMe[method-unbinding]
+      typeof actionResult.then === 'function'
+    ) {
+      const thenable: Thenable<Awaited<S>> = (actionResult: any);
+      switch (thenable.status) {
+        case 'fulfilled': {
+          value = thenable.value;
+          debugInfo =
+            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          break;
+        }
+        case 'rejected': {
+          const rejectedError = thenable.reason;
+          error = rejectedError;
+          break;
+        }
+        default:
+          // If this was an uncached Promise we have to abandon this attempt
+          // but we can still emit anything up until this point.
+          error = SuspenseException;
+          debugInfo =
+            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          value = thenable;
+      }
+    } else {
+      value = (actionResult: any);
+    }
+  } else {
+    value = initialState;
+  }
+
+  hookLog.push({
+    displayName: null,
+    primitive: 'ActionState',
+    stackError: stackError,
+    value: value,
+    debugInfo: debugInfo,
+  });
+
+  if (error !== null) {
+    throw error;
+  }
+
+  // value being a Thenable is equivalent to error being not null
+  // i.e. we only reach this point with Awaited<S>
+  const state = ((value: any): Awaited<S>);
+
+  // TODO: support displaying pending value
+  return [state, (payload: P) => {}, false];
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -635,6 +708,7 @@ const Dispatcher: DispatcherType = {
   useDeferredValue,
   useId,
   useFormState,
+  useActionState,
 };
 
 // create a proxy to throw a custom error

commit d50323eb845c5fde0d720cae888bf35dedd05506
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Apr 8 19:23:23 2024 -0400

    Flatten ReactSharedInternals (#28783)
    
    This is similar to #28771 but for isomorphic. We need a make over for
    these dispatchers anyway so this is the first step. Also helps flush out
    some internals usage that will break anyway.
    
    It flattens the inner mutable objects onto the ReactSharedInternals.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 8d7477490d..cb9d940354 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -37,7 +37,7 @@ import {
 } from 'shared/ReactSymbols';
 import hasOwnProperty from 'shared/hasOwnProperty';
 
-type CurrentDispatcherRef = typeof ReactSharedInternals.ReactCurrentDispatcher;
+type CurrentDispatcherRef = typeof ReactSharedInternals;
 
 // Used to track hooks called during a render
 
@@ -1075,11 +1075,11 @@ export function inspectHooks<Props>(
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+    currentDispatcher = ReactSharedInternals;
   }
 
-  const previousDispatcher = currentDispatcher.current;
-  currentDispatcher.current = DispatcherProxy;
+  const previousDispatcher = currentDispatcher.H;
+  currentDispatcher.H = DispatcherProxy;
 
   let readHookLog;
   let ancestorStackError;
@@ -1093,7 +1093,7 @@ export function inspectHooks<Props>(
     readHookLog = hookLog;
     hookLog = [];
     // $FlowFixMe[incompatible-use] found when upgrading Flow
-    currentDispatcher.current = previousDispatcher;
+    currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
@@ -1129,9 +1129,9 @@ function inspectHooksOfForwardRef<Props, Ref>(
   ref: Ref,
   currentDispatcher: CurrentDispatcherRef,
 ): HooksTree {
-  const previousDispatcher = currentDispatcher.current;
+  const previousDispatcher = currentDispatcher.H;
   let readHookLog;
-  currentDispatcher.current = DispatcherProxy;
+  currentDispatcher.H = DispatcherProxy;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -1141,7 +1141,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    currentDispatcher.current = previousDispatcher;
+    currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
@@ -1169,7 +1169,7 @@ export function inspectHooksOfFiber(
   // DevTools will pass the current renderer's injected dispatcher.
   // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+    currentDispatcher = ReactSharedInternals;
   }
 
   if (

commit 4f5c812a3c4e52d9ea5d908a27a317ac0f26590a
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Apr 11 22:00:54 2024 +0200

    DevTools: Rely on sourcemaps to compute hook name of built-in hooks in newer versions (#28593)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index cb9d940354..a5a4080a71 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -47,6 +47,7 @@ type HookLogEntry = {
   stackError: Error,
   value: mixed,
   debugInfo: ReactDebugInfo | null,
+  dispatcherHookName: string,
 };
 
 let hookLog: Array<HookLogEntry> = [];
@@ -131,6 +132,8 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
           );
         } catch (x) {}
       }
+
+      Dispatcher.useId();
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -207,6 +210,7 @@ function use<T>(usable: Usable<T>): T {
             value: fulfilledValue,
             debugInfo:
               thenable._debugInfo === undefined ? null : thenable._debugInfo,
+            dispatcherHookName: 'Use',
           });
           return fulfilledValue;
         }
@@ -224,6 +228,7 @@ function use<T>(usable: Usable<T>): T {
         value: thenable,
         debugInfo:
           thenable._debugInfo === undefined ? null : thenable._debugInfo,
+        dispatcherHookName: 'Use',
       });
       throw SuspenseException;
     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
@@ -236,6 +241,7 @@ function use<T>(usable: Usable<T>): T {
         stackError: new Error(),
         value,
         debugInfo: null,
+        dispatcherHookName: 'Use',
       });
 
       return value;
@@ -254,6 +260,7 @@ function useContext<T>(context: ReactContext<T>): T {
     stackError: new Error(),
     value: value,
     debugInfo: null,
+    dispatcherHookName: 'Context',
   });
   return value;
 }
@@ -275,6 +282,7 @@ function useState<S>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
+    dispatcherHookName: 'State',
   });
   return [state, (action: BasicStateAction<S>) => {}];
 }
@@ -297,6 +305,7 @@ function useReducer<S, I, A>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
+    dispatcherHookName: 'Reducer',
   });
   return [state, (action: A) => {}];
 }
@@ -310,6 +319,7 @@ function useRef<T>(initialValue: T): {current: T} {
     stackError: new Error(),
     value: ref.current,
     debugInfo: null,
+    dispatcherHookName: 'Ref',
   });
   return ref;
 }
@@ -322,6 +332,7 @@ function useCacheRefresh(): () => void {
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : function refresh() {},
     debugInfo: null,
+    dispatcherHookName: 'CacheRefresh',
   });
   return () => {};
 }
@@ -337,6 +348,7 @@ function useLayoutEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
+    dispatcherHookName: 'LayoutEffect',
   });
 }
 
@@ -351,6 +363,7 @@ function useInsertionEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
+    dispatcherHookName: 'InsertionEffect',
   });
 }
 
@@ -365,6 +378,7 @@ function useEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
+    dispatcherHookName: 'Effect',
   });
 }
 
@@ -388,6 +402,7 @@ function useImperativeHandle<T>(
     stackError: new Error(),
     value: instance,
     debugInfo: null,
+    dispatcherHookName: 'ImperativeHandle',
   });
 }
 
@@ -398,6 +413,7 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
     stackError: new Error(),
     value: typeof formatterFn === 'function' ? formatterFn(value) : value,
     debugInfo: null,
+    dispatcherHookName: 'DebugValue',
   });
 }
 
@@ -409,6 +425,7 @@ function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState[0] : callback,
     debugInfo: null,
+    dispatcherHookName: 'Callback',
   });
   return callback;
 }
@@ -425,6 +442,7 @@ function useMemo<T>(
     stackError: new Error(),
     value,
     debugInfo: null,
+    dispatcherHookName: 'Memo',
   });
   return value;
 }
@@ -446,6 +464,7 @@ function useSyncExternalStore<T>(
     stackError: new Error(),
     value,
     debugInfo: null,
+    dispatcherHookName: 'SyncExternalStore',
   });
   return value;
 }
@@ -468,6 +487,7 @@ function useTransition(): [
     stackError: new Error(),
     value: isPending,
     debugInfo: null,
+    dispatcherHookName: 'Transition',
   });
   return [isPending, () => {}];
 }
@@ -481,6 +501,7 @@ function useDeferredValue<T>(value: T, initialValue?: T): T {
     stackError: new Error(),
     value: prevValue,
     debugInfo: null,
+    dispatcherHookName: 'DeferredValue',
   });
   return prevValue;
 }
@@ -494,6 +515,7 @@ function useId(): string {
     stackError: new Error(),
     value: id,
     debugInfo: null,
+    dispatcherHookName: 'Id',
   });
   return id;
 }
@@ -544,6 +566,7 @@ function useOptimistic<S, A>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
+    dispatcherHookName: 'Optimistic',
   });
   return [state, (action: A) => {}];
 }
@@ -603,6 +626,7 @@ function useFormState<S, P>(
     stackError: stackError,
     value: value,
     debugInfo: debugInfo,
+    dispatcherHookName: 'FormState',
   });
 
   if (error !== null) {
@@ -672,6 +696,7 @@ function useActionState<S, P>(
     stackError: stackError,
     value: value,
     debugInfo: debugInfo,
+    dispatcherHookName: 'ActionState',
   });
 
   if (error !== null) {
@@ -759,8 +784,7 @@ export type HooksTree = Array<HooksNode>;
 // of a hook call. A simple way to demonstrate this is wrapping `new Error()`
 // in a wrapper constructor like a polyfill. That'll add an extra frame.
 // Similar things can happen with the call to the dispatcher. The top frame
-// may not be the primitive. Likewise the primitive can have fewer stack frames
-// such as when a call to useState got inlined to use dispatcher.useState.
+// may not be the primitive.
 //
 // We also can't assume that the last frame of the root call is the same
 // frame as the last frame of the hook call because long stack traces can be
@@ -810,27 +834,8 @@ function findCommonAncestorIndex(rootStack: any, hookStack: any) {
   return -1;
 }
 
-function isReactWrapper(functionName: any, primitiveName: string) {
-  if (!functionName) {
-    return false;
-  }
-  switch (primitiveName) {
-    case 'Context':
-    case 'Context (use)':
-    case 'Promise':
-    case 'Unresolved':
-      if (functionName.endsWith('use')) {
-        return true;
-      }
-  }
-  const expectedPrimitiveName = 'use' + primitiveName;
-  if (functionName.length < expectedPrimitiveName.length) {
-    return false;
-  }
-  return (
-    functionName.lastIndexOf(expectedPrimitiveName) ===
-    functionName.length - expectedPrimitiveName.length
-  );
+function isReactWrapper(functionName: any, wrapperName: string) {
+  return parseHookName(functionName) === wrapperName;
 }
 
 function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
@@ -841,17 +846,18 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
   }
   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
     if (primitiveStack[i].source !== hookStack[i].source) {
-      // If the next two frames are functions called `useX` then we assume that they're part of the
-      // wrappers that the React packager or other packages adds around the dispatcher.
+      // If the next frame is a method from the dispatcher, we
+      // assume that the next frame after that is the actual public API call.
+      // This prohibits nesting dispatcher calls in hooks.
       if (
         i < hookStack.length - 1 &&
-        isReactWrapper(hookStack[i].functionName, hook.primitive)
+        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
       ) {
         i++;
       }
       if (
         i < hookStack.length - 1 &&
-        isReactWrapper(hookStack[i].functionName, hook.primitive)
+        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
       ) {
         i++;
       }
@@ -872,21 +878,41 @@ function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
     primitiveIndex === -1 ||
     rootIndex - primitiveIndex < 2
   ) {
-    // Something went wrong. Give up.
-    return null;
+    if (primitiveIndex === -1) {
+      // Something went wrong. Give up.
+      return [null, null];
+    } else {
+      return [hookStack[primitiveIndex - 1], null];
+    }
   }
-  return hookStack.slice(primitiveIndex, rootIndex - 1);
+  return [
+    hookStack[primitiveIndex - 1],
+    hookStack.slice(primitiveIndex, rootIndex - 1),
+  ];
 }
 
-function parseCustomHookName(functionName: void | string): string {
+function parseHookName(functionName: void | string): string {
   if (!functionName) {
     return '';
   }
-  let startIndex = functionName.lastIndexOf('.');
+  let startIndex = functionName.lastIndexOf('[as ');
+
+  if (startIndex !== -1) {
+    // Workaround for sourcemaps in Jest and Chrome.
+    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"
+    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"
+    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));
+  }
+  startIndex = functionName.lastIndexOf('.');
   if (startIndex === -1) {
     startIndex = 0;
+  } else {
+    startIndex += 1;
   }
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
+    if (functionName.length - startIndex === 3) {
+      return 'Use';
+    }
     startIndex += 3;
   }
   return functionName.slice(startIndex);
@@ -903,7 +929,17 @@ function buildTree(
   const stackOfChildren = [];
   for (let i = 0; i < readHookLog.length; i++) {
     const hook = readHookLog[i];
-    const stack = parseTrimmedStack(rootStack, hook);
+    const parseResult = parseTrimmedStack(rootStack, hook);
+    const primitiveFrame = parseResult[0];
+    const stack = parseResult[1];
+    let displayName = hook.displayName;
+    if (displayName === null && primitiveFrame !== null) {
+      displayName =
+        parseHookName(primitiveFrame.functionName) ||
+        // Older versions of React do not have sourcemaps.
+        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.
+        parseHookName(hook.dispatcherHookName);
+    }
     if (stack !== null) {
       // Note: The indices 0 <= n < length-1 will contain the names.
       // The indices 1 <= n < length will contain the source locations.
@@ -934,7 +970,7 @@ function buildTree(
         const levelChild: HooksNode = {
           id: null,
           isStateEditable: false,
-          name: parseCustomHookName(stack[j - 1].functionName),
+          name: parseHookName(stack[j - 1].functionName),
           value: undefined,
           subHooks: children,
           debugInfo: null,
@@ -952,7 +988,7 @@ function buildTree(
       }
       prevStack = stack;
     }
-    const {displayName, primitive, debugInfo} = hook;
+    const {primitive, debugInfo} = hook;
 
     // For now, the "id" of stateful hooks is just the stateful hook index.
     // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).

commit 734956ace6450bc0c95d8d749dee74f4a140597b
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Apr 16 10:28:16 2024 +0200

    Devtools: Add support for useFormStatus (#28413)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index a5a4080a71..e7f3fb0ee5 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -21,6 +21,7 @@ import type {
   Fiber,
   Dispatcher as DispatcherType,
 } from 'react-reconciler/src/ReactInternalTypes';
+import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 
 import ErrorStackParser from 'error-stack-parser';
 import assign from 'shared/assign';
@@ -134,6 +135,11 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       }
 
       Dispatcher.useId();
+
+      if (typeof Dispatcher.useHostTransitionStatus === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useHostTransitionStatus();
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -711,6 +717,27 @@ function useActionState<S, P>(
   return [state, (payload: P) => {}, false];
 }
 
+function useHostTransitionStatus(): TransitionStatus {
+  const status = readContext<TransitionStatus>(
+    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue
+    ({
+      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.
+      _currentValue: null,
+    }: ReactContext<TransitionStatus>),
+  );
+
+  hookLog.push({
+    displayName: null,
+    primitive: 'HostTransitionStatus',
+    stackError: new Error(),
+    value: status,
+    debugInfo: null,
+    dispatcherHookName: 'HostTransitionStatus',
+  });
+
+  return status;
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -734,6 +761,7 @@ const Dispatcher: DispatcherType = {
   useId,
   useFormState,
   useActionState,
+  useHostTransitionStatus,
 };
 
 // create a proxy to throw a custom error
@@ -854,12 +882,11 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
       ) {
         i++;
-      }
-      if (
-        i < hookStack.length - 1 &&
-        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
-      ) {
-        i++;
+        // Guard against the dispatcher call being inlined.
+        // At this point we wouldn't be able to recover the actual React Hook name.
+        if (i < hookStack.length - 1) {
+          i++;
+        }
       }
       return i;
     }
@@ -997,7 +1024,8 @@ function buildTree(
       primitive === 'Context (use)' ||
       primitive === 'DebugValue' ||
       primitive === 'Promise' ||
-      primitive === 'Unresolved'
+      primitive === 'Unresolved' ||
+      primitive === 'HostTransitionStatus'
         ? null
         : nativeHookID++;
 

commit f5f2799a8d0b37487c9674159846cbb7696febd3
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu May 2 22:08:41 2024 +0200

    DevTools: Fix inspecting components with multiple reads of the same Context in React 17 (#28974)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index e7f3fb0ee5..145dae4ddb 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -177,15 +177,20 @@ function readContext<T>(context: ReactContext<T>): T {
       );
     }
 
+    let value: T;
     // For now we don't expose readContext usage in the hooks debugging info.
-    const value = hasOwnProperty.call(currentContextDependency, 'memoizedValue')
-      ? // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-        ((currentContextDependency.memoizedValue: any): T)
-      : // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
-        // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-        ((currentContextDependency.context._currentValue: any): T);
-    // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-    currentContextDependency = currentContextDependency.next;
+    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
+      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+      value = ((currentContextDependency.memoizedValue: any): T);
+
+      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+      currentContextDependency = currentContextDependency.next;
+    } else {
+      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
+      // Multiple reads of the same context were also only tracked as a single dependency.
+      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
+      value = context._currentValue;
+    }
 
     return value;
   }

commit fb61a1b515c5ea0e31b0dac19184454a79c4baf1
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Thu May 30 16:11:56 2024 +0100

    fix[ReactDebugHooks/find-primitive-index]: remove some assumptions (#29652)
    
    Partially reverts https://github.com/facebook/react/pull/28593.
    
    While rolling out RDT 5.2.0, I've observed some issues on React Native
    side: hooks inspection for some complex hook trees, like in
    AnimatedView, were broken. After some debugging, I've noticed a
    difference between what is in frame's source.
    
    The difference is in the top-most frame, where with V8 it will correctly
    pick up the `Type` as `Proxy` in `hookStack`, but for Hermes it will be
    `Object`. This means that for React Native this top most frame is
    skipped, since sources are identical.
    
    Here I am reverting back to the previous logic, where we check each
    frame if its a part of the wrapper, but also updated `isReactWrapper`
    function to have an explicit case for `useFormStatus` support.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 145dae4ddb..09ba351235 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -868,7 +868,12 @@ function findCommonAncestorIndex(rootStack: any, hookStack: any) {
 }
 
 function isReactWrapper(functionName: any, wrapperName: string) {
-  return parseHookName(functionName) === wrapperName;
+  const hookName = parseHookName(functionName);
+  if (wrapperName === 'HostTransitionStatus') {
+    return hookName === wrapperName || hookName === 'FormStatus';
+  }
+
+  return hookName === wrapperName;
 }
 
 function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
@@ -878,21 +883,24 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
     return -1;
   }
   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
+    // Note: there is no guarantee that we will find the top-most primitive frame in the stack
+    // For React Native (uses Hermes), these source fields will be identical and skipped
     if (primitiveStack[i].source !== hookStack[i].source) {
-      // If the next frame is a method from the dispatcher, we
-      // assume that the next frame after that is the actual public API call.
-      // This prohibits nesting dispatcher calls in hooks.
+      // If the next two frames are functions called `useX` then we assume that they're part of the
+      // wrappers that the React package or other packages adds around the dispatcher.
+      if (
+        i < hookStack.length - 1 &&
+        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
+      ) {
+        i++;
+      }
       if (
         i < hookStack.length - 1 &&
         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
       ) {
         i++;
-        // Guard against the dispatcher call being inlined.
-        // At this point we wouldn't be able to recover the actual React Hook name.
-        if (i < hookStack.length - 1) {
-          i++;
-        }
       }
+
       return i;
     }
   }
@@ -1040,7 +1048,7 @@ function buildTree(
     const levelChild: HooksNode = {
       id,
       isStateEditable,
-      name: name,
+      name,
       value: hook.value,
       subHooks: [],
       debugInfo: debugInfo,

commit 21129d34a5b12ece1901cfa89d139acaef76de57
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jul 8 14:11:11 2024 -0400

    Upgrade flow to 0.235.0 (#30118)
    
    See [Flow
    changelog](https://github.com/facebook/flow/blob/main/Changelog.md) for
    changes in this version.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 09ba351235..d7ffc6626c 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -774,6 +774,7 @@ const Dispatcher: DispatcherType = {
 const DispatcherProxyHandler = {
   get(target: DispatcherType, prop: string) {
     if (target.hasOwnProperty(prop)) {
+      // $FlowFixMe[invalid-computed-prop]
       return target[prop];
     }
     const error = new Error('Missing method in Dispatcher: ' + prop);

commit b7e7f1a3fab87e8fc19e86a8088a9e0fe4710973
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jul 22 16:09:01 2024 -0400

    [BE] upgrade prettier to 3.3.3 (#30420)
    
    Mostly just changes in ternary formatting.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index d7ffc6626c..69827f2bf0 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -284,9 +284,9 @@ function useState<S>(
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
-      ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
-        initialState()
-      : initialState;
+        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
+          initialState()
+        : initialState;
   hookLog.push({
     displayName: null,
     primitive: 'State',

commit 1350a85980d1bf5e63c16a4a889861246f4cc107
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Jul 26 14:38:24 2024 -0400

    Add unstable context bailout for profiling (#30407)
    
    **This API is not intended to ship. This is a temporary unstable hook
    for internal performance profiling.**
    
    This PR exposes `unstable_useContextWithBailout`, which takes a compare
    function in addition to Context. The comparison function is run to
    determine if Context propagation and render should bail out earlier.
    `unstable_useContextWithBailout` returns the full Context value, same as
    `useContext`.
    
    We can profile this API against `useContext` to better measure the cost
    of Context value updates and gather more data around propagation and
    render performance.
    
    The bailout logic and test cases are based on
    https://github.com/facebook/react/pull/20646
    
    Additionally, this implementation allows multiple values to be compared
    in one hook by returning a tuple to avoid requiring additional Context
    consumer hooks.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 69827f2bf0..edbef05e25 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -37,6 +37,7 @@ import {
   REACT_CONTEXT_TYPE,
 } from 'shared/ReactSymbols';
 import hasOwnProperty from 'shared/hasOwnProperty';
+import type {ContextDependencyWithSelect} from '../../react-reconciler/src/ReactInternalTypes';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals;
 
@@ -155,7 +156,10 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
 let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
-let currentContextDependency: null | ContextDependency<mixed> = null;
+let currentContextDependency:
+  | null
+  | ContextDependency<mixed>
+  | ContextDependencyWithSelect<mixed> = null;
 
 function nextHook(): null | Hook {
   const hook = currentHook;

commit 8308d2f1fe90ec0b5a5cde147b97c6e78581710a
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Fri Aug 30 10:34:52 2024 +0100

    fix[react-devtools/ReactDebugHooks]: support unstable prefixes in hooks and useContextWithBailout (#30837)
    
    Related - https://github.com/facebook/react/pull/30407.
    
    This is experimental-only and FB-only hook. Without these changes,
    inspecting an element that is using this hook will throw an error,
    because this hook is missing in Dispatcher implementation from React
    DevTools, which overrides the original one to build the hook tree.
    
    ![Screenshot 2024-08-28 at 18 42
    55](https://github.com/user-attachments/assets/e3bccb92-74fb-4e4a-8181-03d13f8512c0)
    
    One nice thing from it is that in case of any potential regressions
    related to this experiment, we can quickly triage which implementation
    of `useContext` is used by inspecting an element in React DevTools.
    
    Ideally, I should've added some component that is using this hook to
    `react-devtools-shell`, so it can be manually tested, but I can't do it
    without rewriting the infra for it. This is because this hook is only
    available from fb-www builds, and not experimental.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index edbef05e25..c54e591321 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,6 +20,7 @@ import type {
   Dependencies,
   Fiber,
   Dispatcher as DispatcherType,
+  ContextDependencyWithSelect,
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 
@@ -37,7 +38,6 @@ import {
   REACT_CONTEXT_TYPE,
 } from 'shared/ReactSymbols';
 import hasOwnProperty from 'shared/hasOwnProperty';
-import type {ContextDependencyWithSelect} from '../../react-reconciler/src/ReactInternalTypes';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals;
 
@@ -76,6 +76,13 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
     try {
       // Use all hooks here to add them to the hook log.
       Dispatcher.useContext(({_currentValue: null}: any));
+      if (typeof Dispatcher.unstable_useContextWithBailout === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.unstable_useContextWithBailout(
+          ({_currentValue: null}: any),
+          null,
+        );
+      }
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
@@ -280,6 +287,22 @@ function useContext<T>(context: ReactContext<T>): T {
   return value;
 }
 
+function unstable_useContextWithBailout<T>(
+  context: ReactContext<T>,
+  select: (T => Array<mixed>) | null,
+): T {
+  const value = readContext(context);
+  hookLog.push({
+    displayName: context.displayName || null,
+    primitive: 'ContextWithBailout',
+    stackError: new Error(),
+    value: value,
+    debugInfo: null,
+    dispatcherHookName: 'ContextWithBailout',
+  });
+  return value;
+}
+
 function useState<S>(
   initialState: (() => S) | S,
 ): [S, Dispatch<BasicStateAction<S>>] {
@@ -753,6 +776,7 @@ const Dispatcher: DispatcherType = {
   useCacheRefresh,
   useCallback,
   useContext,
+  unstable_useContextWithBailout,
   useEffect,
   useImperativeHandle,
   useDebugValue,
@@ -954,6 +978,11 @@ function parseHookName(functionName: void | string): string {
   } else {
     startIndex += 1;
   }
+
+  if (functionName.slice(startIndex).startsWith('unstable_')) {
+    startIndex += 'unstable_'.length;
+  }
+
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     if (functionName.length - startIndex === 3) {
       return 'Use';

commit e210d08180a63f42079b91acaa7f6af15eef6d32
Author: Sam Zhou <sam@developersam.com>
Date:   Mon Sep 9 08:41:44 2024 -0700

    [flow] Upgrade Flow to 0.245.2 (#30919)
    
    ## Summary
    
    This PR bumps Flow all the way to the latest 0.245.2.
    
    Most of the suppressions comes from Flow v0.239.0's change to include
    undefined in the return of `Array.pop`.
    
    I also enabled `react.custom_jsx_typing=true` and added custom jsx
    typing to match the old behavior that `React.createElement` is
    effectively any typed. This is necessary since various builtin
    components like `React.Fragment` is actually symbol in the React repo
    instead of `React.AbstractComponent<...>`. It can be made more accurate
    by customizing the `React$CustomJSXFactory` type, but I will leave it to
    the React team to decide.
    
    ## How did you test this change?
    
    `yarn flow` for all the renderers

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index c54e591321..55a1454142 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -1033,6 +1033,7 @@ function buildTree(
         }
         // Pop back the stack as many steps as were not common.
         for (let j = prevStack.length - 1; j > commonSteps; j--) {
+          // $FlowFixMe[incompatible-type]
           levelChildren = stackOfChildren.pop();
         }
       }

commit babde5d1826365bfb794abdb7de4bd21f7b02356
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Sep 19 13:42:49 2024 -0400

    [lint] Add no-optional-chaining (#31003)
    
    ## Overview
    
    Adds a lint rule to prevent optional chaining to catch issues like
    https://github.com/facebook/react/pull/30982 until we support optional
    chaining without a bundle impact.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 55a1454142..44d6840038 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -567,8 +567,9 @@ function useMemoCache(size: number): Array<any> {
     return [];
   }
 
-  // $FlowFixMe[incompatible-use]: updateQueue is mixed
-  const memoCache = fiber.updateQueue?.memoCache;
+  const memoCache =
+    // $FlowFixMe[incompatible-use]: updateQueue is mixed
+    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
   if (memoCache == null) {
     return [];
   }

commit b15135b9f59e4d40e1142342f97cfa18d228d0d4
Author: lauren <poteto@users.noreply.github.com>
Date:   Thu Nov 14 12:10:51 2024 -0500

    [ez] Update useMemoCache return type (#31539)
    
    Use `mixed` instead of `any`

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 44d6840038..b1e7a0272a 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -560,7 +560,7 @@ function useId(): string {
 
 // useMemoCache is an implementation detail of Forget's memoization
 // it should not be called directly in user-generated code
-function useMemoCache(size: number): Array<any> {
+function useMemoCache(size: number): Array<mixed> {
   const fiber = currentFiber;
   // Don't throw, in case this is called from getPrimitiveStackCache
   if (fiber == null) {

commit 92c0f5f85fed42024b17bf6595291f9f5d6e8734
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Nov 15 17:52:24 2024 -0500

    Track separate SuspendedOnAction flag by rethrowing a separate SuspenseActionException sentinel (#31554)
    
    This lets us track separately if something was suspended on an Action
    using useActionState rather than suspended on Data.
    
    This approach feels quite bloated and it seems like we'd eventually
    might want to read more information about the Promise that suspended and
    the context it suspended in. As a more general reason for suspending.
    
    The way useActionState works in combination with the prewarming is quite
    unfortunate because 1) it renders blocking to update the isPending flag
    whether you use it or not 2) it prewarms and suspends the useActionState
    3) then it does another third render to get back into the useActionState
    position again.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index b1e7a0272a..2a0c57154e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -214,7 +214,7 @@ const SuspenseException: mixed = new Error(
     '`try/catch` block. Capturing without rethrowing will lead to ' +
     'unexpected behavior.\n\n' +
     'To handle async errors, wrap your component in an error boundary, or ' +
-    "call the promise's `.catch` method and pass the result to `use`",
+    "call the promise's `.catch` method and pass the result to `use`.",
 );
 
 function use<T>(usable: Usable<T>): T {

commit ef63718a27407b6d6b262d6be92e6bf0a87ff1a3
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Dec 13 13:58:18 2024 -0500

    Remove enableAsyncActions (#31757)
    
    Based on https://github.com/facebook/react/pull/31756
    
    This is landed everywhere

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2a0c57154e..eccaa6a67b 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -104,22 +104,14 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       );
       Dispatcher.useDeferredValue(null);
       Dispatcher.useMemo(() => null);
+      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
+      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
+      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
+      Dispatcher.useHostTransitionStatus();
       if (typeof Dispatcher.useMemoCache === 'function') {
         // This type check is for Flow only.
         Dispatcher.useMemoCache(0);
       }
-      if (typeof Dispatcher.useOptimistic === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
-      }
-      if (typeof Dispatcher.useFormState === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
-      }
-      if (typeof Dispatcher.useActionState === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
-      }
       if (typeof Dispatcher.use === 'function') {
         // This type check is for Flow only.
         Dispatcher.use(
@@ -143,11 +135,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       }
 
       Dispatcher.useId();
-
-      if (typeof Dispatcher.useHostTransitionStatus === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useHostTransitionStatus();
-      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];

commit 909ed63e0adc162a95a4704d3ed07a956dcf9cd1
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Dec 16 12:32:07 2024 -0500

    Clean up context access profiling experiment (#31806)
    
    We introduced the `unstable_useContextWithBailout` API to run compiler
    based experiments. This API was designed to be an experiment proxy for
    alternative approaches which would be heavier to implement. The
    experiment turned out to be inconclusive. Since most of our performance
    critical usage is already optimized, we weren't able to find a clear win
    with this approach.
    
    Since we don't have further plans for this API, let's clean it up.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index eccaa6a67b..d2cea81f57 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -20,7 +20,6 @@ import type {
   Dependencies,
   Fiber,
   Dispatcher as DispatcherType,
-  ContextDependencyWithSelect,
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 
@@ -76,13 +75,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
     try {
       // Use all hooks here to add them to the hook log.
       Dispatcher.useContext(({_currentValue: null}: any));
-      if (typeof Dispatcher.unstable_useContextWithBailout === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.unstable_useContextWithBailout(
-          ({_currentValue: null}: any),
-          null,
-        );
-      }
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
@@ -150,10 +142,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
 let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
-let currentContextDependency:
-  | null
-  | ContextDependency<mixed>
-  | ContextDependencyWithSelect<mixed> = null;
+let currentContextDependency: null | ContextDependency<mixed> = null;
 
 function nextHook(): null | Hook {
   const hook = currentHook;
@@ -274,22 +263,6 @@ function useContext<T>(context: ReactContext<T>): T {
   return value;
 }
 
-function unstable_useContextWithBailout<T>(
-  context: ReactContext<T>,
-  select: (T => Array<mixed>) | null,
-): T {
-  const value = readContext(context);
-  hookLog.push({
-    displayName: context.displayName || null,
-    primitive: 'ContextWithBailout',
-    stackError: new Error(),
-    value: value,
-    debugInfo: null,
-    dispatcherHookName: 'ContextWithBailout',
-  });
-  return value;
-}
-
 function useState<S>(
   initialState: (() => S) | S,
 ): [S, Dispatch<BasicStateAction<S>>] {
@@ -764,7 +737,6 @@ const Dispatcher: DispatcherType = {
   useCacheRefresh,
   useCallback,
   useContext,
-  unstable_useContextWithBailout,
   useEffect,
   useImperativeHandle,
   useDebugValue,

commit 5b51a2b9e249f264b1345cc35b275464ae3ef6eb
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Thu Jan 16 15:42:53 2025 +0000

    fix[DevTools]: support useResourceEffect (#32088)
    
    Since we've started experimenting with it, I've started seeing a spike
    in errors:
    ```
    Unsupported hook in the react-debug-tools package: Missing method in Dispatcher: useResourceEffect
    ```
    
    Adding missing hook to the `Dispatcher` that is proxied by React
    DevTools.
    
    I can't really add an example that will use it to our RDT testing shell,
    because it uses experimental builds of `react`, which don't have this
    hook. I've tested it manually by rebuilding artifacts with
    `enableUseResourceEffectHook` flag enabled.
    
    ![Screenshot 2025-01-16 at 15 20
    00](https://github.com/user-attachments/assets/a0d63fd6-1f17-4710-a2b2-82d484b8987f)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index d2cea81f57..2e1fcb19a6 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -731,6 +731,24 @@ function useHostTransitionStatus(): TransitionStatus {
   return status;
 }
 
+function useResourceEffect(
+  create: () => mixed,
+  createDeps: Array<mixed> | void | null,
+  update: ((resource: mixed) => void) | void,
+  updateDeps: Array<mixed> | void | null,
+  destroy: ((resource: mixed) => void) | void,
+) {
+  nextHook();
+  hookLog.push({
+    displayName: null,
+    primitive: 'ResourceEffect',
+    stackError: new Error(),
+    value: create,
+    debugInfo: null,
+    dispatcherHookName: 'ResourceEffect',
+  });
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -755,6 +773,7 @@ const Dispatcher: DispatcherType = {
   useFormState,
   useActionState,
   useHostTransitionStatus,
+  useResourceEffect,
 };
 
 // create a proxy to throw a custom error
@@ -943,6 +962,10 @@ function parseHookName(functionName: void | string): string {
     startIndex += 'unstable_'.length;
   }
 
+  if (functionName.slice(startIndex).startsWith('unstable_')) {
+    startIndex += 'experimental_'.length;
+  }
+
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     if (functionName.length - startIndex === 3) {
       return 'Use';

commit b000019578a417ec0a1aeec8bda689db240cb28e
Author: Ruslan Lesiutin <rdlesyutin@gmail.com>
Date:   Wed Jan 22 14:15:48 2025 +0000

    DevTools: support useEffectEvent and forward-fix experimental prefix support (#32106)
    
    - Adds support for `experimental_useEffectEvent`, now DevTools will be
    able to display this hook for inspected element
    - Added a use case to DevTools shell, couldn't add case, because we are
    using ReactTestRenderer, which has the corresponding flag disabled.
    - Forward-fix logic for handling `experimental` prefix that was added in
    https://github.com/facebook/react/pull/32088.
    
    ![Screenshot 2025-01-16 at 21 24
    12](https://github.com/user-attachments/assets/6fb8ff2a-be47-47b5-bbfc-73d3a586657c)

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 2e1fcb19a6..f30489b7f6 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -127,6 +127,13 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       }
 
       Dispatcher.useId();
+
+      if (typeof Dispatcher.useResourceEffect === 'function') {
+        Dispatcher.useResourceEffect(() => ({}), []);
+      }
+      if (typeof Dispatcher.useEffectEvent === 'function') {
+        Dispatcher.useEffectEvent((args: empty) => {});
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -749,6 +756,20 @@ function useResourceEffect(
   });
 }
 
+function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
+  nextHook();
+  hookLog.push({
+    displayName: null,
+    primitive: 'EffectEvent',
+    stackError: new Error(),
+    value: callback,
+    debugInfo: null,
+    dispatcherHookName: 'EffectEvent',
+  });
+
+  return callback;
+}
+
 const Dispatcher: DispatcherType = {
   use,
   readContext,
@@ -773,6 +794,7 @@ const Dispatcher: DispatcherType = {
   useFormState,
   useActionState,
   useHostTransitionStatus,
+  useEffectEvent,
   useResourceEffect,
 };
 
@@ -962,7 +984,7 @@ function parseHookName(functionName: void | string): string {
     startIndex += 'unstable_'.length;
   }
 
-  if (functionName.slice(startIndex).startsWith('unstable_')) {
+  if (functionName.slice(startIndex).startsWith('experimental_')) {
     startIndex += 'experimental_'.length;
   }
 

commit 899e3d1297ec15a5aa8d73e2f1bd478918090a12
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 13:52:25 2025 -0500

    [crud] Narrow resource type (#32203)
    
    Small refactor to the `resource` type to narrow it to an arbitrary
    object or void/null instead of the top type. This makes the overload on
    useEffect simpler since the return type of create is no longer widened
    to the top type when we merge their definitions.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32203).
    * #32206
    * #32205
    * #32204
    * __->__ #32203

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index f30489b7f6..9c310723b2 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -739,11 +739,11 @@ function useHostTransitionStatus(): TransitionStatus {
 }
 
 function useResourceEffect(
-  create: () => mixed,
+  create: () => {...} | void | null,
   createDeps: Array<mixed> | void | null,
-  update: ((resource: mixed) => void) | void,
+  update: ((resource: {...} | void | null) => void) | void,
   updateDeps: Array<mixed> | void | null,
-  destroy: ((resource: mixed) => void) | void,
+  destroy: ((resource: {...} | void | null) => void) | void,
 ) {
   nextHook();
   hookLog.push({

commit 2c5fd26c07c0fb94ff21a6c10c5a757ef3c5d6a4
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:18:50 2025 -0500

    [crud] Merge useResourceEffect into useEffect (#32205)
    
    Merges the useResourceEffect API into useEffect while keeping the
    underlying implementation the same. useResourceEffect will be removed in
    the next diff.
    
    To fork between behavior we rely on a `typeof` check for the updater or
    destroy function in addition to the CRUD feature flag. This does now
    have to be checked every time (instead of inlined statically like before
    due to them being different hooks) which will incur some non-zero amount
    (possibly negligble) of overhead for every effect.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32205).
    * #32206
    * __->__ #32205

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 9c310723b2..f45ccfecdc 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -373,8 +373,11 @@ function useInsertionEffect(
 }
 
 function useEffect(
-  create: () => (() => void) | void,
-  inputs: Array<mixed> | void | null,
+  create: (() => (() => void) | void) | (() => {...} | void | null),
+  createDeps: Array<mixed> | void | null,
+  update?: ((resource: {...} | void | null) => void) | void,
+  updateDeps?: Array<mixed> | void | null,
+  destroy?: ((resource: {...} | void | null) => void) | void,
 ): void {
   nextHook();
   hookLog.push({

commit a69b80d07e5d1bf363ed15d6209a55b35e0765c2
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:19:34 2025 -0500

    [crud] Remove useResourceEffect (#32206)
    
    Removes useResourceEffect.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32206).
    * __->__ #32206
    * #32205

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index f45ccfecdc..114080d03e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -128,9 +128,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
       Dispatcher.useId();
 
-      if (typeof Dispatcher.useResourceEffect === 'function') {
-        Dispatcher.useResourceEffect(() => ({}), []);
-      }
       if (typeof Dispatcher.useEffectEvent === 'function') {
         Dispatcher.useEffectEvent((args: empty) => {});
       }
@@ -741,24 +738,6 @@ function useHostTransitionStatus(): TransitionStatus {
   return status;
 }
 
-function useResourceEffect(
-  create: () => {...} | void | null,
-  createDeps: Array<mixed> | void | null,
-  update: ((resource: {...} | void | null) => void) | void,
-  updateDeps: Array<mixed> | void | null,
-  destroy: ((resource: {...} | void | null) => void) | void,
-) {
-  nextHook();
-  hookLog.push({
-    displayName: null,
-    primitive: 'ResourceEffect',
-    stackError: new Error(),
-    value: create,
-    debugInfo: null,
-    dispatcherHookName: 'ResourceEffect',
-  });
-}
-
 function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
   nextHook();
   hookLog.push({
@@ -798,7 +777,6 @@ const Dispatcher: DispatcherType = {
   useActionState,
   useHostTransitionStatus,
   useEffectEvent,
-  useResourceEffect,
 };
 
 // create a proxy to throw a custom error

commit a53da6abe1593483098df2baf927fe07d80153a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 13 16:06:01 2025 -0500

    Add useSwipeTransition Hook Behind Experimental Flag (#32373)
    
    This Hook will be used to drive a View Transition based on a gesture.
    
    ```js
    const [value, startGesture] = useSwipeTransition(prev, current, next);
    ```
    
    The `enableSwipeTransition` flag will depend on `enableViewTransition`
    flag but we may decide to ship them independently. This PR doesn't do
    anything interesting yet. There will be a lot more PRs to build out the
    actual functionality. This is just wiring up the plumbing for the new
    Hook.
    
    This first PR is mainly concerned with how the whole starts (and stops).
    The core API is the `startGesture` function (although there will be
    other conveniences added in the future). You can call this to start a
    gesture with a source provider. You can call this multiple times in one
    event to batch multiple Hooks listening to the same provider. However,
    each render can only handle one source provider at a time and so it does
    one render per scheduled gesture provider.
    
    This uses a separate `GestureLane` to drive gesture renders by marking
    the Hook as having an update on that lane. Then schedule a render. These
    renders should be blocking and in the same microtask as the
    `startGesture` to ensure it can block the paint. So it's similar to
    sync.
    
    It may not be possible to finish it synchronously e.g. if something
    suspends. If so, it just tries again later when it can like any other
    render. This can also happen because it also may not be possible to
    drive more than one gesture at a time like if we're limited to one View
    Transition per document. So right now you can only run one gesture at a
    time in practice.
    
    These renders never commit. This means that we can't clear the
    `GestureLane` the normal way. Instead, we have to clear only the root's
    `pendingLanes` if we don't have any new renders scheduled. Then wait
    until something else updates the Fiber after all gestures on it have
    stopped before it really clears.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 114080d03e..798cdec438 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -14,6 +14,7 @@ import type {
   Usable,
   Thenable,
   ReactDebugInfo,
+  StartGesture,
 } from 'shared/ReactTypes';
 import type {
   ContextDependency,
@@ -131,6 +132,9 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       if (typeof Dispatcher.useEffectEvent === 'function') {
         Dispatcher.useEffectEvent((args: empty) => {});
       }
+      if (typeof Dispatcher.useSwipeTransition === 'function') {
+        Dispatcher.useSwipeTransition(null, null, null);
+      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -752,31 +756,50 @@ function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
   return callback;
 }
 
+function useSwipeTransition<T>(
+  previous: T,
+  current: T,
+  next: T,
+): [T, StartGesture] {
+  nextHook();
+  hookLog.push({
+    displayName: null,
+    primitive: 'SwipeTransition',
+    stackError: new Error(),
+    value: current,
+    debugInfo: null,
+    dispatcherHookName: 'SwipeTransition',
+  });
+  return [current, () => () => {}];
+}
+
 const Dispatcher: DispatcherType = {
-  use,
   readContext,
-  useCacheRefresh,
+
+  use,
   useCallback,
   useContext,
   useEffect,
   useImperativeHandle,
-  useDebugValue,
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
-  useMemoCache,
-  useOptimistic,
   useReducer,
   useRef,
   useState,
+  useDebugValue,
+  useDeferredValue,
   useTransition,
   useSyncExternalStore,
-  useDeferredValue,
   useId,
+  useHostTransitionStatus,
   useFormState,
   useActionState,
-  useHostTransitionStatus,
+  useOptimistic,
+  useMemoCache,
+  useCacheRefresh,
   useEffectEvent,
+  useSwipeTransition,
 };
 
 // create a proxy to throw a custom error

commit 313332d111a2fba2db94c584334d8895e8d73c61
Author: lauren <poteto@users.noreply.github.com>
Date:   Wed Mar 26 12:04:57 2025 -0400

    [crud] Revert CRUD overload (#32741)
    
    Cleans up this experiment. After some internal experimentation we are
    deprioritizing this project for now and may revisit it at a later point.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 798cdec438..5cf93c587d 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -374,11 +374,8 @@ function useInsertionEffect(
 }
 
 function useEffect(
-  create: (() => (() => void) | void) | (() => {...} | void | null),
-  createDeps: Array<mixed> | void | null,
-  update?: ((resource: {...} | void | null) => void) | void,
-  updateDeps?: Array<mixed> | void | null,
-  destroy?: ((resource: {...} | void | null) => void) | void,
+  create: () => (() => void) | void,
+  deps: Array<mixed> | void | null,
 ): void {
   nextHook();
   hookLog.push({

commit 0a7cf20b220a9f719e06fd8a12dfde3ab029c651
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 1 11:43:33 2025 -0400

    Remove useSwipeTransition (#32786)
    
    Stacked on #32785.
    
    This is now replaced by `startGestureTransition` added in #32785.
    
    I also renamed the flag from `enableSwipeTransition` to
    `enableGestureTransition` to correspond to the new name.

diff --git a/packages/react-debug-tools/src/ReactDebugHooks.js b/packages/react-debug-tools/src/ReactDebugHooks.js
index 5cf93c587d..8242b27d4e 100644
--- a/packages/react-debug-tools/src/ReactDebugHooks.js
+++ b/packages/react-debug-tools/src/ReactDebugHooks.js
@@ -14,7 +14,6 @@ import type {
   Usable,
   Thenable,
   ReactDebugInfo,
-  StartGesture,
 } from 'shared/ReactTypes';
 import type {
   ContextDependency,
@@ -132,9 +131,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       if (typeof Dispatcher.useEffectEvent === 'function') {
         Dispatcher.useEffectEvent((args: empty) => {});
       }
-      if (typeof Dispatcher.useSwipeTransition === 'function') {
-        Dispatcher.useSwipeTransition(null, null, null);
-      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -753,23 +749,6 @@ function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
   return callback;
 }
 
-function useSwipeTransition<T>(
-  previous: T,
-  current: T,
-  next: T,
-): [T, StartGesture] {
-  nextHook();
-  hookLog.push({
-    displayName: null,
-    primitive: 'SwipeTransition',
-    stackError: new Error(),
-    value: current,
-    debugInfo: null,
-    dispatcherHookName: 'SwipeTransition',
-  });
-  return [current, () => () => {}];
-}
-
 const Dispatcher: DispatcherType = {
   readContext,
 
@@ -796,7 +775,6 @@ const Dispatcher: DispatcherType = {
   useMemoCache,
   useCacheRefresh,
   useEffectEvent,
-  useSwipeTransition,
 };
 
 // create a proxy to throw a custom error

