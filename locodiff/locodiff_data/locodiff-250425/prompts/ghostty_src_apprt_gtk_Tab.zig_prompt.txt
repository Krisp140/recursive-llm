# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/apprt/gtk/Tab.zig

commit 5c0b668517214e062bfcdfee7dc4046b35cf1edc
Author: Nathan Fisher <nfisher.sr@gmail.com>
Date:   Tue Sep 26 17:06:45 2023 -0400

    Begin working on a skeleton for splits in Linux/Gtk

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
new file mode 100644
index 00000000..ac33631f
--- /dev/null
+++ b/src/apprt/gtk/Tab.zig
@@ -0,0 +1,35 @@
+const Tab = @This();
+
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+
+const Paned = @import("Paned.zig");
+const Surface = @import("Surface.zig");
+const Window = @import("Window.zig");
+const c = import("c.zig");
+
+const Child = union(enum) {
+    surface: *Surface,
+    paned: *Paned,
+}
+
+window: *Window,
+label_text: *c.GtkLabel,
+close_button: *c.GtkButton,
+child: Child,
+
+pub fn create(alloc: Allocator, window: *Window) !*Tab {
+    var tab = try alloc.create(Tab);
+    errdefer alloc.destroy(paned);
+    try tab.init(window);
+}
+
+pub fn init(self: *Tab, window) !void {
+    self.* = .{
+        window = Window,
+        label_text = undefined,
+        close_button = undefined,
+        child = undefined,
+    };
+    // todo - write the function and initialize everything
+}
\ No newline at end of file

commit 1b16c2dd232d8defbaa992ebf490baf1d0418b62
Author: Nathan Fisher <nfisher.sr@gmail.com>
Date:   Tue Sep 26 19:14:30 2023 -0400

    Add to Tab.init and fix compilation errors

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index ac33631f..b0121294 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -6,30 +6,56 @@ const Allocator = std.mem.Allocator;
 const Paned = @import("Paned.zig");
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
-const c = import("c.zig");
+const c = @import("c.zig");
 
 const Child = union(enum) {
     surface: *Surface,
     paned: *Paned,
-}
+};
 
 window: *Window,
 label_text: *c.GtkLabel,
 close_button: *c.GtkButton,
+// We'll put our children into this box instead of packing them directly, so
+// that we can send the box into `c.g_signal_connect_data` for the close button
+box: *c.GtkBox,
+// The child can be either a Surface if the tab is not split or a Paned
 child: Child,
+// We'll update this every time a Surface gains focus, so that we have it
+// when we switch to another Tab. Then when we switch back to this tab, we
+// can easily re-focus that terminal.
+focus_child: *Surface,
 
 pub fn create(alloc: Allocator, window: *Window) !*Tab {
     var tab = try alloc.create(Tab);
-    errdefer alloc.destroy(paned);
+    errdefer alloc.destroy(tab);
     try tab.init(window);
 }
 
-pub fn init(self: *Tab, window) !void {
+pub fn init(self: *Tab, window: *Window) !void {
     self.* = .{
-        window = Window,
-        label_text = undefined,
-        close_button = undefined,
-        child = undefined,
+        .window = window,
+        .label_text = undefined,
+        .close_button = undefined,
+        .box = undefined,
+        .child = undefined,
+        .focus_child = undefined,
     };
-    // todo - write the function and initialize everything
-}
\ No newline at end of file
+
+    // Build the tab label
+    const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
+    const label_box: *c.GtkBox = @ptrCast(label_box_widget);
+    const label_text_widget = c.gtk_label_new("Ghostty");
+    const label_text: *c.GtkLabel = @ptrCast(label_text_widget);
+    self.label_text = label_text;
+    c.gtk_box_append(label_box, label_text_widget);
+    const label_close_widget = c.gtk_button_new_from_icon_name("window-close");
+    const label_close: *c.GtkButton = @ptrCast(label_close_widget);
+    c.gtk_button_has_frame(label_close, 0);
+    c.gtk_box_append(label_box, label_close_widget);
+    self.close_button = label_close;
+    const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
+    const box: *c.GtkBox = @ptrCast(box_widget);
+    self.box = box;
+    // todo - write the rest of function and initialize a new Surface
+}

commit 5b5c2c9ab27b7b7e1791144ed54e74f03ab14e67
Author: Nathan Fisher <nfisher.sr@gmail.com>
Date:   Thu Sep 28 19:09:13 2023 -0400

    Fill out the rest of `Tab.init()`

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index b0121294..d0cce365 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -2,7 +2,8 @@ const Tab = @This();
 
 const std = @import("std");
 const Allocator = std.mem.Allocator;
-
+const font = @import("../../font/main.zig");
+const CoreSurface = @import("../../Surface.zig");
 const Paned = @import("Paned.zig");
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
@@ -26,13 +27,13 @@ child: Child,
 // can easily re-focus that terminal.
 focus_child: *Surface,
 
-pub fn create(alloc: Allocator, window: *Window) !*Tab {
+pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
-    try tab.init(window);
+    try tab.init(window, _parent);
 }
 
-pub fn init(self: *Tab, window: *Window) !void {
+pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.* = .{
         .window = window,
         .label_text = undefined,
@@ -42,6 +43,17 @@ pub fn init(self: *Tab, window: *Window) !void {
         .focus_child = undefined,
     };
 
+    // Grab a surface allocation we'll need it later.
+    var surface = try self.app.core_app.alloc.create(Surface);
+    errdefer self.app.core_app.alloc.destroy(surface);
+
+    // Inherit the parent's font size if we are configured to.
+    const font_size: ?font.face.DesiredSize = font_size: {
+        if (!window.app.config.@"window-inherit-font-size") break :font_size null;
+        const parent = parent_ orelse break :font_size null;
+        break :font_size parent.font_size;
+    };
+
     // Build the tab label
     const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
     const label_box: *c.GtkBox = @ptrCast(label_box_widget);
@@ -54,8 +66,60 @@ pub fn init(self: *Tab, window: *Window) !void {
     c.gtk_button_has_frame(label_close, 0);
     c.gtk_box_append(label_box, label_close_widget);
     self.close_button = label_close;
+
+    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), surface, null, c.G_CONNECT_DEFAULT);
+
+    // Wide style GTK tabs
+    if (self.app.config.@"gtk-wide-tabs") {
+        c.gtk_widget_set_hexpand(label_box_widget, 1);
+        c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
+        c.gtk_widget_set_hexpand(label_text, 1);
+        c.gtk_widget_set_halign(label_text, c.GTK_ALIGN_FILL);
+    }
+
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
-    const box: *c.GtkBox = @ptrCast(box_widget);
-    self.box = box;
-    // todo - write the rest of function and initialize a new Surface
+    c.gtk_widget_set_hexpand(box_widget, 1);
+    c.gtk_widget_set_vexpand(box_widget, 1);
+    self.box = ptrCast(box_widget);
+
+    // Initialize the GtkGLArea and attach it to our surface.
+    // The surface starts in the "unrealized" state because we have to
+    // wait for the "realize" callback from GTK to know that the OpenGL
+    // context is ready. See Surface docs for more info.
+    const gl_area = c.gtk_gl_area_new();
+    c.gtk_widget_set_hexpand(gl_area, 1);
+    c.gtk_widget_set_vexpand(gl_area, 1);
+    try surface.init(self.app, .{
+        .window = self,
+        .gl_area = @ptrCast(gl_area),
+        .title_label = @ptrCast(label_text),
+        .font_size = font_size,
+    });
+    errdefer surface.deinit();
+
+    c.gtk_box_pack_start(self.box, gl_area);
+    const page_idx = c.gtk_notebook_append_page(self.notebook, box_widget, label_box_widget);
+    if (page_idx < 0) {
+        log.warn("failed to add page to notebook", .{});
+        return error.GtkAppendPageFailed;
+    }
+
+    // Tab settings
+    c.gtk_notebook_set_tab_reorderable(self.notebook, gl_area, 1);
+    c.gtk_notebook_set_tab_detachable(self.notebook, gl_area, 1);
+
+    // If we have multiple tabs, show the tab bar.
+    if (c.gtk_notebook_get_n_pages(self.notebook) > 1) {
+        c.gtk_notebook_set_show_tabs(self.notebook, 1);
+    }
+
+    // Set the userdata of the close button so it points to this page.
+    c.g_object_set_data(@ptrCast(box), GHOSTTY_TAB, self);
+
+    // Switch to the new tab
+    c.gtk_notebook_set_current_page(self.notebook, page_idx);
+
+    // We need to grab focus after it is added to the window. When
+    // creating a window we want to always focus on the widget.
+    _ = c.gtk_widget_grab_focus(box_widget);
 }

commit aba1b85503b07d1a898c7739dc0ca72c7d914b6b
Author: Nathan Fisher <nfisher.sr@gmail.com>
Date:   Sat Sep 30 00:43:17 2023 -0400

    Add `Parent` and `Child` types for tracking splits; Add methods for
    adding start and end children in `Paned` widget;

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d0cce365..7cfad8e6 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -9,6 +9,10 @@ const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
 const c = @import("c.zig");
 
+const log = std.log.scoped(.gtk);
+
+const GHOSTTY_TAB = "ghostty_tab";
+
 const Child = union(enum) {
     surface: *Surface,
     paned: *Paned,
@@ -30,7 +34,7 @@ focus_child: *Surface,
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
-    try tab.init(window, _parent);
+    try tab.init(window, parent_);
 }
 
 pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
@@ -80,7 +84,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
     c.gtk_widget_set_hexpand(box_widget, 1);
     c.gtk_widget_set_vexpand(box_widget, 1);
-    self.box = ptrCast(box_widget);
+    self.box = @ptrCast(box_widget);
 
     // Initialize the GtkGLArea and attach it to our surface.
     // The surface starts in the "unrealized" state because we have to
@@ -114,7 +118,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     }
 
     // Set the userdata of the close button so it points to this page.
-    c.g_object_set_data(@ptrCast(box), GHOSTTY_TAB, self);
+    c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
     // Switch to the new tab
     c.gtk_notebook_set_current_page(self.notebook, page_idx);
@@ -123,3 +127,8 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // creating a window we want to always focus on the widget.
     _ = c.gtk_widget_grab_focus(box_widget);
 }
+
+fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
+    _ = ud;
+    // todo
+}

commit d88898fc61176c36fbf928a97a21068b076d2be5
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Oct 19 13:04:15 2023 +0200

    gtk: get 1st version of GTK splits working

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 7cfad8e6..3855a60d 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -2,20 +2,33 @@ const Tab = @This();
 
 const std = @import("std");
 const Allocator = std.mem.Allocator;
+const assert = std.debug.assert;
 const font = @import("../../font/main.zig");
 const CoreSurface = @import("../../Surface.zig");
 const Paned = @import("Paned.zig");
+const Parent = @import("parent.zig").Parent;
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
 const c = @import("c.zig");
 
 const log = std.log.scoped(.gtk);
 
-const GHOSTTY_TAB = "ghostty_tab";
+pub const GHOSTTY_TAB = "ghostty_tab";
 
-const Child = union(enum) {
+pub const Child = union(enum) {
     surface: *Surface,
     paned: *Paned,
+
+    empty,
+
+    const Self = @This();
+
+    pub fn is_empty(self: Self) bool {
+        switch (self) {
+            Child.empty => return true,
+            else => return false,
+        }
+    }
 };
 
 window: *Window,
@@ -35,6 +48,7 @@ pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
     try tab.init(window, parent_);
+    return tab;
 }
 
 pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
@@ -48,8 +62,11 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     };
 
     // Grab a surface allocation we'll need it later.
-    var surface = try self.app.core_app.alloc.create(Surface);
-    errdefer self.app.core_app.alloc.destroy(surface);
+    var surface = try window.app.core_app.alloc.create(Surface);
+    errdefer window.app.core_app.alloc.destroy(surface);
+    self.child = Child{ .surface = surface };
+    // TODO: this needs to change
+    self.focus_child = surface;
 
     // Inherit the parent's font size if we are configured to.
     const font_size: ?font.face.DesiredSize = font_size: {
@@ -60,25 +77,35 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Build the tab label
     const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
-    const label_box: *c.GtkBox = @ptrCast(label_box_widget);
+    const label_box = @as(*c.GtkBox, @ptrCast(label_box_widget));
     const label_text_widget = c.gtk_label_new("Ghostty");
     const label_text: *c.GtkLabel = @ptrCast(label_text_widget);
     self.label_text = label_text;
     c.gtk_box_append(label_box, label_text_widget);
     const label_close_widget = c.gtk_button_new_from_icon_name("window-close");
     const label_close: *c.GtkButton = @ptrCast(label_close_widget);
-    c.gtk_button_has_frame(label_close, 0);
+    c.gtk_button_set_has_frame(label_close, 0);
     c.gtk_box_append(label_box, label_close_widget);
     self.close_button = label_close;
 
-    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), surface, null, c.G_CONNECT_DEFAULT);
+    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
 
     // Wide style GTK tabs
-    if (self.app.config.@"gtk-wide-tabs") {
+    if (window.app.config.@"gtk-wide-tabs") {
         c.gtk_widget_set_hexpand(label_box_widget, 1);
         c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
-        c.gtk_widget_set_hexpand(label_text, 1);
-        c.gtk_widget_set_halign(label_text, c.GTK_ALIGN_FILL);
+        c.gtk_widget_set_hexpand(label_text_widget, 1);
+        c.gtk_widget_set_halign(label_text_widget, c.GTK_ALIGN_FILL);
+
+        // This ensures that tabs are always equal width. If they're too
+        // long, they'll be truncated with an ellipsis.
+        c.gtk_label_set_max_width_chars(@ptrCast(label_text), 1);
+        c.gtk_label_set_ellipsize(@ptrCast(label_text), c.PANGO_ELLIPSIZE_END);
+
+        // We need to set a minimum width so that at a certain point
+        // the notebook will have an arrow button rather than shrinking tabs
+        // to an unreadably small size.
+        c.gtk_widget_set_size_request(@ptrCast(label_text), 100, 1);
     }
 
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
@@ -93,42 +120,86 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     const gl_area = c.gtk_gl_area_new();
     c.gtk_widget_set_hexpand(gl_area, 1);
     c.gtk_widget_set_vexpand(gl_area, 1);
-    try surface.init(self.app, .{
-        .window = self,
+    try surface.init(window.app, .{
+        .window = window,
+        .tab = self,
+        .parent = .{ .tab = self },
         .gl_area = @ptrCast(gl_area),
         .title_label = @ptrCast(label_text),
         .font_size = font_size,
     });
     errdefer surface.deinit();
 
-    c.gtk_box_pack_start(self.box, gl_area);
-    const page_idx = c.gtk_notebook_append_page(self.notebook, box_widget, label_box_widget);
+    c.gtk_box_append(self.box, gl_area);
+    const page_idx = c.gtk_notebook_append_page(window.notebook, box_widget, label_box_widget);
     if (page_idx < 0) {
         log.warn("failed to add page to notebook", .{});
         return error.GtkAppendPageFailed;
     }
 
     // Tab settings
-    c.gtk_notebook_set_tab_reorderable(self.notebook, gl_area, 1);
-    c.gtk_notebook_set_tab_detachable(self.notebook, gl_area, 1);
+    c.gtk_notebook_set_tab_reorderable(window.notebook, gl_area, 1);
+    c.gtk_notebook_set_tab_detachable(window.notebook, gl_area, 1);
 
     // If we have multiple tabs, show the tab bar.
-    if (c.gtk_notebook_get_n_pages(self.notebook) > 1) {
-        c.gtk_notebook_set_show_tabs(self.notebook, 1);
+    if (c.gtk_notebook_get_n_pages(window.notebook) > 1) {
+        c.gtk_notebook_set_show_tabs(window.notebook, 1);
     }
 
-    // Set the userdata of the close button so it points to this page.
+    // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
     // Switch to the new tab
-    c.gtk_notebook_set_current_page(self.notebook, page_idx);
+    c.gtk_notebook_set_current_page(window.notebook, page_idx);
 
     // We need to grab focus after it is added to the window. When
     // creating a window we want to always focus on the widget.
-    _ = c.gtk_widget_grab_focus(box_widget);
+    const widget = @as(*c.GtkWidget, @ptrCast(gl_area));
+    _ = c.gtk_widget_grab_focus(widget);
+}
+
+pub fn removeChild(self: *Tab) void {
+    // Remove old child from box.
+    const widget = switch (self.child) {
+        .surface => |surface| @as(*c.GtkWidget, @ptrCast(surface.gl_area)),
+        .paned => |paned| @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned))),
+        .empty => return,
+    };
+    c.gtk_box_remove(self.box, widget);
+    self.child = .empty;
+}
+
+pub fn setChild(self: *Tab, newChild: Child) void {
+    const parent = Parent{ .tab = self };
+
+    switch (newChild) {
+        .surface => |surface| {
+            surface.setParent(parent);
+            const widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
+            c.gtk_box_append(self.box, widget);
+        },
+        .paned => |paned| {
+            paned.parent = parent;
+            const widget = @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned)));
+            c.gtk_box_append(self.box, widget);
+        },
+        .empty => return,
+    }
+
+    self.child = newChild;
+}
+
+pub fn setChildSurface(self: *Tab, surface: *Surface, gl_area: *c.GtkWidget) !void {
+    c.gtk_box_append(self.box, gl_area);
+
+    const parent = Parent{ .tab = self };
+    surface.setParent(parent);
+
+    self.child = .{ .surface = surface };
 }
 
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
-    _ = ud;
-    // todo
+    const tab: *Tab = @ptrCast(@alignCast(ud));
+    _ = tab;
+    log.info("tab close click\n", .{});
 }

commit 2d7a81c0dbb76c050fcff5a51f71f0ec074cd820
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Oct 19 16:15:57 2023 +0200

    gtk: cleanup code in *Paned

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 3855a60d..165eef38 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -18,17 +18,7 @@ pub const GHOSTTY_TAB = "ghostty_tab";
 pub const Child = union(enum) {
     surface: *Surface,
     paned: *Paned,
-
-    empty,
-
-    const Self = @This();
-
-    pub fn is_empty(self: Self) bool {
-        switch (self) {
-            Child.empty => return true,
-            else => return false,
-        }
-    }
+    none,
 };
 
 window: *Window,
@@ -163,10 +153,10 @@ pub fn removeChild(self: *Tab) void {
     const widget = switch (self.child) {
         .surface => |surface| @as(*c.GtkWidget, @ptrCast(surface.gl_area)),
         .paned => |paned| @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned))),
-        .empty => return,
+        .none => return,
     };
     c.gtk_box_remove(self.box, widget);
-    self.child = .empty;
+    self.child = .none;
 }
 
 pub fn setChild(self: *Tab, newChild: Child) void {
@@ -183,23 +173,15 @@ pub fn setChild(self: *Tab, newChild: Child) void {
             const widget = @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned)));
             c.gtk_box_append(self.box, widget);
         },
-        .empty => return,
+        .none => return,
     }
 
     self.child = newChild;
 }
 
-pub fn setChildSurface(self: *Tab, surface: *Surface, gl_area: *c.GtkWidget) !void {
-    c.gtk_box_append(self.box, gl_area);
-
-    const parent = Parent{ .tab = self };
-    surface.setParent(parent);
-
-    self.child = .{ .surface = surface };
-}
-
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     _ = tab;
+    // TODO: Fix tab closing logic
     log.info("tab close click\n", .{});
 }

commit 8afcce666a94de5691e43b5a77bc5b57a6a85133
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Fri Oct 20 09:16:11 2023 +0200

    gtk: wire up close-tab button

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 165eef38..2fde5b37 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -181,7 +181,6 @@ pub fn setChild(self: *Tab, newChild: Child) void {
 
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
-    _ = tab;
-    // TODO: Fix tab closing logic
-    log.info("tab close click\n", .{});
+    const window = tab.window;
+    window.closeTab(tab);
 }

commit 19f7b37bb393c122a4a66bf40a19b7b23a1bfd69
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Tue Oct 24 06:54:41 2023 +0200

    gtk: move Child/Parent/Position into same file

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 2fde5b37..e076ebee 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -6,7 +6,8 @@ const assert = std.debug.assert;
 const font = @import("../../font/main.zig");
 const CoreSurface = @import("../../Surface.zig");
 const Paned = @import("Paned.zig");
-const Parent = @import("parent.zig").Parent;
+const Parent = @import("relation.zig").Parent;
+const Child = @import("relation.zig").Child;
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
 const c = @import("c.zig");
@@ -15,12 +16,6 @@ const log = std.log.scoped(.gtk);
 
 pub const GHOSTTY_TAB = "ghostty_tab";
 
-pub const Child = union(enum) {
-    surface: *Surface,
-    paned: *Paned,
-    none,
-};
-
 window: *Window,
 label_text: *c.GtkLabel,
 close_button: *c.GtkButton,

commit 790cd84203c33f7898bcc109a0a566ab497875fa
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Oct 26 06:47:48 2023 +0200

    gtk: refator Parent/Tab/Paned and how they interact

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index e076ebee..c7781980 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -144,34 +144,18 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 }
 
 pub fn removeChild(self: *Tab) void {
-    // Remove old child from box.
-    const widget = switch (self.child) {
-        .surface => |surface| @as(*c.GtkWidget, @ptrCast(surface.gl_area)),
-        .paned => |paned| @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned))),
-        .none => return,
-    };
+    const widget = self.child.widget() orelse return;
     c.gtk_box_remove(self.box, widget);
+
     self.child = .none;
 }
 
-pub fn setChild(self: *Tab, newChild: Child) void {
-    const parent = Parent{ .tab = self };
-
-    switch (newChild) {
-        .surface => |surface| {
-            surface.setParent(parent);
-            const widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
-            c.gtk_box_append(self.box, widget);
-        },
-        .paned => |paned| {
-            paned.parent = parent;
-            const widget = @as(*c.GtkWidget, @ptrCast(@alignCast(paned.paned)));
-            c.gtk_box_append(self.box, widget);
-        },
-        .none => return,
-    }
+pub fn setChild(self: *Tab, child: Child) void {
+    const widget = child.widget() orelse return;
+    c.gtk_box_append(self.box, widget);
 
-    self.child = newChild;
+    child.setParent(.{ .tab = self });
+    self.child = child;
 }
 
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {

commit a7717289eb181b03d439226969a5f8d79a799f3b
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Oct 26 20:22:38 2023 +0200

    gtk: fix tab settings after introducing *Tab

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index c7781980..a1a55435 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -123,8 +123,8 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     }
 
     // Tab settings
-    c.gtk_notebook_set_tab_reorderable(window.notebook, gl_area, 1);
-    c.gtk_notebook_set_tab_detachable(window.notebook, gl_area, 1);
+    c.gtk_notebook_set_tab_reorderable(window.notebook, box_widget, 1);
+    c.gtk_notebook_set_tab_detachable(window.notebook, box_widget, 1);
 
     // If we have multiple tabs, show the tab bar.
     if (c.gtk_notebook_get_n_pages(window.notebook) > 1) {

commit dc0f6e3a5b54f6750f475594c2d805b8795096cd
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Oct 26 20:24:32 2023 +0200

    WIP: gtk: handle split surfaces when closing tab/window

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index a1a55435..b4b75237 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -163,3 +163,17 @@ fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const window = tab.window;
     window.closeTab(tab);
 }
+
+pub fn close(self: *Tab) void {
+    switch (self.child) {
+        .none => return,
+        .surface => {
+            // TODO: I'm not 100% but I don't think we have to do something
+            return;
+        },
+        .paned => |paned| {
+            paned.deinit(self.window.app.core_app.alloc);
+            self.window.app.core_app.alloc.destroy(paned);
+        },
+    }
+}

commit fde6289880036e802bec9de76363686411d8ce08
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Oct 28 07:34:30 2023 +0200

    gtk: rename and refactor Tab.deinit

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index b4b75237..cf604c79 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -164,13 +164,9 @@ fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     window.closeTab(tab);
 }
 
-pub fn close(self: *Tab) void {
+pub fn deinit(self: *Tab) void {
     switch (self.child) {
-        .none => return,
-        .surface => {
-            // TODO: I'm not 100% but I don't think we have to do something
-            return;
-        },
+        .none, .surface => return,
         .paned => |paned| {
             paned.deinit(self.window.app.core_app.alloc);
             self.window.app.core_app.alloc.destroy(paned);

commit eed2bb30781b1593549a849bd4eeeab63b084a71
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Oct 28 07:51:30 2023 +0200

    gtk: refactor code and add comments to Paned

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index cf604c79..cdd5e2b4 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -158,12 +158,6 @@ pub fn setChild(self: *Tab, child: Child) void {
     self.child = child;
 }
 
-fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
-    const tab: *Tab = @ptrCast(@alignCast(ud));
-    const window = tab.window;
-    window.closeTab(tab);
-}
-
 pub fn deinit(self: *Tab) void {
     switch (self.child) {
         .none, .surface => return,
@@ -173,3 +167,9 @@ pub fn deinit(self: *Tab) void {
         },
     }
 }
+
+fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
+    const tab: *Tab = @ptrCast(@alignCast(ud));
+    const window = tab.window;
+    window.closeTab(tab);
+}

commit 633a3e2e8551f5044a02e3d8ad1722ffaf752799
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Oct 28 08:09:43 2023 +0200

    gtk: remove duplication of new surface creation

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index cdd5e2b4..86a7dead 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -46,27 +46,14 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .focus_child = undefined,
     };
 
-    // Grab a surface allocation we'll need it later.
-    var surface = try window.app.core_app.alloc.create(Surface);
-    errdefer window.app.core_app.alloc.destroy(surface);
-    self.child = Child{ .surface = surface };
-    // TODO: this needs to change
-    self.focus_child = surface;
-
-    // Inherit the parent's font size if we are configured to.
-    const font_size: ?font.face.DesiredSize = font_size: {
-        if (!window.app.config.@"window-inherit-font-size") break :font_size null;
-        const parent = parent_ orelse break :font_size null;
-        break :font_size parent.font_size;
-    };
-
     // Build the tab label
     const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
     const label_box = @as(*c.GtkBox, @ptrCast(label_box_widget));
     const label_text_widget = c.gtk_label_new("Ghostty");
     const label_text: *c.GtkLabel = @ptrCast(label_text_widget);
-    self.label_text = label_text;
     c.gtk_box_append(label_box, label_text_widget);
+    self.label_text = label_text;
+
     const label_close_widget = c.gtk_button_new_from_icon_name("window-close");
     const label_close: *c.GtkButton = @ptrCast(label_close_widget);
     c.gtk_button_set_has_frame(label_close, 0);
@@ -93,29 +80,24 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         c.gtk_widget_set_size_request(@ptrCast(label_text), 100, 1);
     }
 
+    // Create a Box in which we'll later keep either Surface or Paned
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
     c.gtk_widget_set_hexpand(box_widget, 1);
     c.gtk_widget_set_vexpand(box_widget, 1);
     self.box = @ptrCast(box_widget);
 
-    // Initialize the GtkGLArea and attach it to our surface.
-    // The surface starts in the "unrealized" state because we have to
-    // wait for the "realize" callback from GTK to know that the OpenGL
-    // context is ready. See Surface docs for more info.
-    const gl_area = c.gtk_gl_area_new();
-    c.gtk_widget_set_hexpand(gl_area, 1);
-    c.gtk_widget_set_vexpand(gl_area, 1);
-    try surface.init(window.app, .{
-        .window = window,
-        .tab = self,
-        .parent = .{ .tab = self },
-        .gl_area = @ptrCast(gl_area),
-        .title_label = @ptrCast(label_text),
-        .font_size = font_size,
-    });
+    // Create the Surface
+    const surface = try self.newSurface(parent_);
     errdefer surface.deinit();
 
-    c.gtk_box_append(self.box, gl_area);
+    self.child = Child{ .surface = surface };
+    // // TODO: this needs to change
+    self.focus_child = surface;
+
+    // Add Surface to the Tab
+    const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
+    c.gtk_box_append(self.box, gl_area_widget);
+
     const page_idx = c.gtk_notebook_append_page(window.notebook, box_widget, label_box_widget);
     if (page_idx < 0) {
         log.warn("failed to add page to notebook", .{});
@@ -137,10 +119,45 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Switch to the new tab
     c.gtk_notebook_set_current_page(window.notebook, page_idx);
 
-    // We need to grab focus after it is added to the window. When
-    // creating a window we want to always focus on the widget.
-    const widget = @as(*c.GtkWidget, @ptrCast(gl_area));
-    _ = c.gtk_widget_grab_focus(widget);
+    // We need to grab focus after Surface and Tab is added to the window. When
+    // creating a Tab we want to always focus on the widget.
+    _ = c.gtk_widget_grab_focus(gl_area_widget);
+}
+
+/// Allocates and initializes a new Surface, but doesn't add it to the Tab yet.
+/// Can also be added to a Paned.
+pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
+    // Grab a surface allocation we'll need it later.
+    var surface = try self.window.app.core_app.alloc.create(Surface);
+    errdefer self.window.app.core_app.alloc.destroy(surface);
+
+    // Inherit the parent's font size if we are configured to.
+    const font_size: ?font.face.DesiredSize = font_size: {
+        if (!self.window.app.config.@"window-inherit-font-size") break :font_size null;
+        const parent = parent_ orelse break :font_size null;
+        break :font_size parent.font_size;
+    };
+
+    // Initialize the GtkGLArea and attach it to our surface.
+    // The surface starts in the "unrealized" state because we have to
+    // wait for the "realize" callback from GTK to know that the OpenGL
+    // context is ready. See Surface docs for more info.
+    const gl_area = c.gtk_gl_area_new();
+    c.gtk_widget_set_hexpand(gl_area, 1);
+    c.gtk_widget_set_vexpand(gl_area, 1);
+
+    try surface.init(self.window.app, .{
+        .window = self.window,
+        .tab = self,
+        .parent = .{
+            .tab = self,
+        },
+        .gl_area = @ptrCast(gl_area),
+        .title_label = @ptrCast(self.label_text),
+        .font_size = font_size,
+    });
+
+    return surface;
 }
 
 pub fn removeChild(self: *Tab) void {

commit 8c58bf222d44da9c09d96006cdbb93e2282db600
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Oct 28 08:21:17 2023 +0200

    gtk: move logic of splitting surface in a tab to Tab

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 86a7dead..315db2ff 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -4,7 +4,9 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const assert = std.debug.assert;
 const font = @import("../../font/main.zig");
+const input = @import("../../input.zig");
 const CoreSurface = @import("../../Surface.zig");
+
 const Paned = @import("Paned.zig");
 const Parent = @import("relation.zig").Parent;
 const Child = @import("relation.zig").Child;
@@ -160,6 +162,28 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
     return surface;
 }
 
+/// Splits the current child surface into a Paned in given direction. Child of
+/// Tab must be a Surface.
+pub fn splitSurface(self: *Tab, direction: input.SplitDirection) !void {
+    assert(self.child == .surface);
+
+    const surface = switch (self.child) {
+        .surface => |s| s,
+        else => unreachable,
+    };
+    self.removeChild();
+
+    // Create a Paned with two Surfaces.
+    const paned = try Paned.create(self.window.app.core_app.alloc, self.window, surface, direction);
+
+    // Add Paned to the Tab.
+    self.setChild(.{ .paned = paned });
+
+    // Focus on new surface
+    paned.focusSurfaceInPosition(.end);
+}
+
+/// Remove the current child from the Tab. Noop if no child set.
 pub fn removeChild(self: *Tab) void {
     const widget = self.child.widget() orelse return;
     c.gtk_box_remove(self.box, widget);
@@ -167,6 +191,7 @@ pub fn removeChild(self: *Tab) void {
     self.child = .none;
 }
 
+/// Sets child to given child and sets parent on child.
 pub fn setChild(self: *Tab, child: Child) void {
     const widget = child.widget() orelse return;
     c.gtk_box_append(self.box, widget);
@@ -175,6 +200,7 @@ pub fn setChild(self: *Tab, child: Child) void {
     self.child = child;
 }
 
+/// Deinits tab by deiniting child if child is Paned.
 pub fn deinit(self: *Tab) void {
     switch (self.child) {
         .none, .surface => return,

commit ab93579bf6f8d0199c3b8d46d8e6ab695b783f63
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Tue Oct 31 20:38:17 2023 +0100

    gtk: port new-tab behavior over after rebase and refactor
    
    This is the new behavior from #776.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 315db2ff..5ded58f4 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -100,7 +100,14 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
     c.gtk_box_append(self.box, gl_area_widget);
 
-    const page_idx = c.gtk_notebook_append_page(window.notebook, box_widget, label_box_widget);
+    // Add the notebook page (create tab). We create the tab after our
+    // current selected tab if we have one.
+    const page_idx = c.gtk_notebook_insert_page(
+        window.notebook,
+        box_widget,
+        label_box_widget,
+        c.gtk_notebook_get_current_page(window.notebook) + 1,
+    );
     if (page_idx < 0) {
         log.warn("failed to add page to notebook", .{});
         return error.GtkAppendPageFailed;

commit f1e81563d96376b03e8e19163aa79aa801793baf
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Wed Nov 1 06:28:50 2023 +0100

    gtk: always remember focused surface before grabbing focus

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 5ded58f4..69093b65 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -93,8 +93,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     errdefer surface.deinit();
 
     self.child = Child{ .surface = surface };
-    // // TODO: this needs to change
-    self.focus_child = surface;
 
     // Add Surface to the Tab
     const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
@@ -122,6 +120,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         c.gtk_notebook_set_show_tabs(window.notebook, 1);
     }
 
+    // TODO: This needs to happen before we show the page
+    self.focus_child = surface;
+
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 

commit b1e368566490382622682c29e570ef68c87354fb
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Wed Nov 1 06:56:16 2023 +0100

    gtk: find first surface to focus on if sibling is Paned

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 69093b65..bdeda014 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -188,7 +188,7 @@ pub fn splitSurface(self: *Tab, direction: input.SplitDirection) !void {
     self.setChild(.{ .paned = paned });
 
     // Focus on new surface
-    paned.focusSurfaceInPosition(.end);
+    paned.focusFirstSurfaceInPosition(.end);
 }
 
 /// Remove the current child from the Tab. Noop if no child set.

commit b60133fd34efa0f2a8540f16a1fbe3e67303565a
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Wed Nov 1 07:52:24 2023 +0100

    gtk: keep buffer of surface title, update if focused

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index bdeda014..6c38cc6b 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -120,9 +120,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         c.gtk_notebook_set_show_tabs(window.notebook, 1);
     }
 
-    // TODO: This needs to happen before we show the page
-    self.focus_child = surface;
-
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
@@ -131,7 +128,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // We need to grab focus after Surface and Tab is added to the window. When
     // creating a Tab we want to always focus on the widget.
-    _ = c.gtk_widget_grab_focus(gl_area_widget);
+    surface.grabFocus();
 }
 
 /// Allocates and initializes a new Surface, but doesn't add it to the Tab yet.

commit 290b79ad621c3db0d8fecc8e7260dc85616a9dbd
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Wed Nov 1 08:18:01 2023 +0100

    gtk: restore "inherit working directory" behavior

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 6c38cc6b..d4504f96 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -159,6 +159,7 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
         .parent = .{
             .tab = self,
         },
+        .parentSurface = parent_ != null,
         .gl_area = @ptrCast(gl_area),
         .title_label = @ptrCast(self.label_text),
         .font_size = font_size,

commit ba2992d4d08c32035219f12458a0260d05d207c7
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Wed Nov 1 09:21:15 2023 +0100

    gtk: remove fields on Paned we don't need

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d4504f96..2945f42a 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -180,7 +180,7 @@ pub fn splitSurface(self: *Tab, direction: input.SplitDirection) !void {
     self.removeChild();
 
     // Create a Paned with two Surfaces.
-    const paned = try Paned.create(self.window.app.core_app.alloc, self.window, surface, direction);
+    const paned = try Paned.create(self.window.app.core_app.alloc, surface, direction);
 
     // Add Paned to the Tab.
     self.setChild(.{ .paned = paned });

commit d65a804eddac7a7386c8bb90d4214636eb235db7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 21:12:08 2023 -0700

    apprt/gtk: working on some reorg

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 2945f42a..185a0268 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -1,3 +1,6 @@
+/// The state associated with a single tab in the window.
+///
+/// A tab can contain one or more terminals due to splits.
 const Tab = @This();
 
 const std = @import("std");
@@ -20,7 +23,6 @@ pub const GHOSTTY_TAB = "ghostty_tab";
 
 window: *Window,
 label_text: *c.GtkLabel,
-close_button: *c.GtkButton,
 // We'll put our children into this box instead of packing them directly, so
 // that we can send the box into `c.g_signal_connect_data` for the close button
 box: *c.GtkBox,
@@ -38,11 +40,12 @@ pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     return tab;
 }
 
+/// Initialize the tab, create a surface, and add it to the window. "self"
+/// needs to be a stable pointer, since it is used for GTK events.
 pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.* = .{
         .window = window,
         .label_text = undefined,
-        .close_button = undefined,
         .box = undefined,
         .child = undefined,
         .focus_child = undefined,
@@ -56,13 +59,11 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     c.gtk_box_append(label_box, label_text_widget);
     self.label_text = label_text;
 
+    // Build the close button for the tab
     const label_close_widget = c.gtk_button_new_from_icon_name("window-close");
     const label_close: *c.GtkButton = @ptrCast(label_close_widget);
     c.gtk_button_set_has_frame(label_close, 0);
     c.gtk_box_append(label_box, label_close_widget);
-    self.close_button = label_close;
-
-    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
 
     // Wide style GTK tabs
     if (window.app.config.@"gtk-wide-tabs") {
@@ -88,11 +89,10 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     c.gtk_widget_set_vexpand(box_widget, 1);
     self.box = @ptrCast(box_widget);
 
-    // Create the Surface
+    // Create the initial surface since all tabs start as a single non-split
     const surface = try self.newSurface(parent_);
     errdefer surface.deinit();
-
-    self.child = Child{ .surface = surface };
+    self.child = .{ .surface = surface };
 
     // Add Surface to the Tab
     const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
@@ -123,6 +123,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
+    // Attach all events
+    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
+
     // Switch to the new tab
     c.gtk_notebook_set_current_page(window.notebook, page_idx);
 
@@ -131,6 +134,17 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     surface.grabFocus();
 }
 
+/// Deinits tab by deiniting child if child is Paned.
+pub fn deinit(self: *Tab) void {
+    switch (self.child) {
+        .none, .surface => return,
+        .paned => |paned| {
+            paned.deinit(self.window.app.core_app.alloc);
+            self.window.app.core_app.alloc.destroy(paned);
+        },
+    }
+}
+
 /// Allocates and initializes a new Surface, but doesn't add it to the Tab yet.
 /// Can also be added to a Paned.
 pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
@@ -206,17 +220,6 @@ pub fn setChild(self: *Tab, child: Child) void {
     self.child = child;
 }
 
-/// Deinits tab by deiniting child if child is Paned.
-pub fn deinit(self: *Tab) void {
-    switch (self.child) {
-        .none, .surface => return,
-        .paned => |paned| {
-            paned.deinit(self.window.app.core_app.alloc);
-            self.window.app.core_app.alloc.destroy(paned);
-        },
-    }
-}
-
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     const window = tab.window;

commit 00c02e88d299604b040a3b83767e2aebf49f0177
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 21:49:24 2023 -0700

    apprt/gtk: remove Window from Surface, use container only

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 185a0268..8ac45a24 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -168,7 +168,6 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
     c.gtk_widget_set_vexpand(gl_area, 1);
 
     try surface.init(self.window.app, .{
-        .window = self.window,
         .tab = self,
         .parent = .{
             .tab = self,

commit 14570b8a6c51518487e5aaeb37b74cb4e0975abc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 22:05:51 2023 -0700

    apprt/gtk: get rid of title label option, we can infer it on container

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 8ac45a24..495ec899 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -174,7 +174,6 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
         },
         .parentSurface = parent_ != null,
         .gl_area = @ptrCast(gl_area),
-        .title_label = @ptrCast(self.label_text),
         .font_size = font_size,
     });
 

commit 97b9708dd125ad3b55570f81dd2874db3a1f4ca2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 22:17:26 2023 -0700

    apprt/gtk: remove tab option from surface

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 495ec899..a16f9f06 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -168,7 +168,6 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
     c.gtk_widget_set_vexpand(gl_area, 1);
 
     try surface.init(self.window.app, .{
-        .tab = self,
         .parent = .{
             .tab = self,
         },
@@ -176,6 +175,7 @@ pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
         .gl_area = @ptrCast(gl_area),
         .font_size = font_size,
     });
+    surface.setContainer(.{ .tab_ = self });
 
     return surface;
 }

commit f1547465cc227f63aa1038da59b715af41b3fa58
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 22:38:22 2023 -0700

    apprt/gtk: new surface options down to just a couple

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index a16f9f06..b1abbfbf 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -148,33 +148,14 @@ pub fn deinit(self: *Tab) void {
 /// Allocates and initializes a new Surface, but doesn't add it to the Tab yet.
 /// Can also be added to a Paned.
 pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
-    // Grab a surface allocation we'll need it later.
-    var surface = try self.window.app.core_app.alloc.create(Surface);
-    errdefer self.window.app.core_app.alloc.destroy(surface);
-
-    // Inherit the parent's font size if we are configured to.
-    const font_size: ?font.face.DesiredSize = font_size: {
-        if (!self.window.app.config.@"window-inherit-font-size") break :font_size null;
-        const parent = parent_ orelse break :font_size null;
-        break :font_size parent.font_size;
-    };
-
-    // Initialize the GtkGLArea and attach it to our surface.
-    // The surface starts in the "unrealized" state because we have to
-    // wait for the "realize" callback from GTK to know that the OpenGL
-    // context is ready. See Surface docs for more info.
-    const gl_area = c.gtk_gl_area_new();
-    c.gtk_widget_set_hexpand(gl_area, 1);
-    c.gtk_widget_set_vexpand(gl_area, 1);
-
-    try surface.init(self.window.app, .{
+    const alloc = self.window.app.core_app.alloc;
+    var surface = try Surface.create(alloc, self.window.app, .{
+        .parent2 = parent_,
         .parent = .{
             .tab = self,
         },
-        .parentSurface = parent_ != null,
-        .gl_area = @ptrCast(gl_area),
-        .font_size = font_size,
     });
+    errdefer surface.destroy(alloc);
     surface.setContainer(.{ .tab_ = self });
 
     return surface;

commit 83b0096dfcd7c50a1c80e54f98e9758451fba6d7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 1 22:43:49 2023 -0700

    apprt/gtk: get rid of one newsurface call

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index b1abbfbf..d480abbf 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -90,8 +90,12 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.box = @ptrCast(box_widget);
 
     // Create the initial surface since all tabs start as a single non-split
-    const surface = try self.newSurface(parent_);
-    errdefer surface.deinit();
+    var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
+        .parent2 = parent_,
+        .parent = .{ .tab = self },
+    });
+    errdefer surface.destroy(window.app.core_app.alloc);
+    surface.setContainer(.{ .tab_ = self });
     self.child = .{ .surface = surface };
 
     // Add Surface to the Tab

commit 79a9d417d17efa596a307edc89c21fc236b9886b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 2 09:38:06 2023 -0700

    apprt/gtk: working on new Split

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d480abbf..474871da 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -149,22 +149,6 @@ pub fn deinit(self: *Tab) void {
     }
 }
 
-/// Allocates and initializes a new Surface, but doesn't add it to the Tab yet.
-/// Can also be added to a Paned.
-pub fn newSurface(self: *Tab, parent_: ?*CoreSurface) !*Surface {
-    const alloc = self.window.app.core_app.alloc;
-    var surface = try Surface.create(alloc, self.window.app, .{
-        .parent2 = parent_,
-        .parent = .{
-            .tab = self,
-        },
-    });
-    errdefer surface.destroy(alloc);
-    surface.setContainer(.{ .tab_ = self });
-
-    return surface;
-}
-
 /// Splits the current child surface into a Paned in given direction. Child of
 /// Tab must be a Surface.
 pub fn splitSurface(self: *Tab, direction: input.SplitDirection) !void {

commit 4c1300ab691f540aacde7c67f05a7295d42b6ab7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 2 10:48:57 2023 -0700

    apprt/gkt: a lot of things are broken

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 474871da..9417d005 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -22,12 +22,21 @@ const log = std.log.scoped(.gtk);
 pub const GHOSTTY_TAB = "ghostty_tab";
 
 window: *Window,
+
+/// The tab label.
 label_text: *c.GtkLabel,
-// We'll put our children into this box instead of packing them directly, so
-// that we can send the box into `c.g_signal_connect_data` for the close button
+
+/// We'll put our children into this box instead of packing them
+/// directly, so that we can send the box into `c.g_signal_connect_data`
+/// for the close button
 box: *c.GtkBox,
+
+/// The element of this tab so that we can handle splits and so on.
+elem: Surface.Container.Elem,
+
 // The child can be either a Surface if the tab is not split or a Paned
 child: Child,
+
 // We'll update this every time a Surface gains focus, so that we have it
 // when we switch to another Tab. Then when we switch back to this tab, we
 // can easily re-focus that terminal.
@@ -47,6 +56,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .window = window,
         .label_text = undefined,
         .box = undefined,
+        .elem = undefined,
         .child = undefined,
         .focus_child = undefined,
     };
@@ -92,11 +102,11 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Create the initial surface since all tabs start as a single non-split
     var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
         .parent2 = parent_,
-        .parent = .{ .tab = self },
     });
     errdefer surface.destroy(window.app.core_app.alloc);
     surface.setContainer(.{ .tab_ = self });
     self.child = .{ .surface = surface };
+    self.elem = .{ .surface = surface };
 
     // Add Surface to the Tab
     const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
@@ -178,6 +188,17 @@ pub fn removeChild(self: *Tab) void {
     self.child = .none;
 }
 
+// TODO: move this
+/// Replace the surface element that this tab is showing.
+pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
+    // Remove our previous widget
+    c.gtk_box_remove(self.box, self.elem.widget());
+
+    // Add our new one
+    c.gtk_box_append(self.box, elem.widget());
+    self.elem = elem;
+}
+
 /// Sets child to given child and sets parent on child.
 pub fn setChild(self: *Tab, child: Child) void {
     const widget = child.widget() orelse return;

commit 17445a7d8746f3a0df86dbaf2a17211da056e269
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 2 11:00:01 2023 -0700

    apprt/gtk: nested splits are good

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 9417d005..3110f06b 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -159,27 +159,6 @@ pub fn deinit(self: *Tab) void {
     }
 }
 
-/// Splits the current child surface into a Paned in given direction. Child of
-/// Tab must be a Surface.
-pub fn splitSurface(self: *Tab, direction: input.SplitDirection) !void {
-    assert(self.child == .surface);
-
-    const surface = switch (self.child) {
-        .surface => |s| s,
-        else => unreachable,
-    };
-    self.removeChild();
-
-    // Create a Paned with two Surfaces.
-    const paned = try Paned.create(self.window.app.core_app.alloc, surface, direction);
-
-    // Add Paned to the Tab.
-    self.setChild(.{ .paned = paned });
-
-    // Focus on new surface
-    paned.focusFirstSurfaceInPosition(.end);
-}
-
 /// Remove the current child from the Tab. Noop if no child set.
 pub fn removeChild(self: *Tab) void {
     const widget = self.child.widget() orelse return;

commit 06b40a8b89e3d99694a53f91ac975be0da296c0d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 2 11:15:25 2023 -0700

    apprt/gtk: closing tabs works again

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 3110f06b..78b4953d 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -178,6 +178,13 @@ pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     self.elem = elem;
 }
 
+// TODO: move this
+/// The surface element is closing. If we're the direct parent
+/// then that means our tab is also closing.
+pub fn closeElem(self: *Tab) void {
+    self.window.closeTab(self);
+}
+
 /// Sets child to given child and sets parent on child.
 pub fn setChild(self: *Tab, child: Child) void {
     const widget = child.widget() orelse return;

commit 956fcf73490df80e53ea431a2706758c3583daff
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Nov 18 14:11:57 2023 +0100

    gtk: fix compilation error after rebase

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 78b4953d..1a0d52a1 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -84,13 +84,13 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
         // This ensures that tabs are always equal width. If they're too
         // long, they'll be truncated with an ellipsis.
-        c.gtk_label_set_max_width_chars(@ptrCast(label_text), 1);
-        c.gtk_label_set_ellipsize(@ptrCast(label_text), c.PANGO_ELLIPSIZE_END);
+        c.gtk_label_set_max_width_chars(label_text, 1);
+        c.gtk_label_set_ellipsize(label_text, c.PANGO_ELLIPSIZE_END);
 
         // We need to set a minimum width so that at a certain point
         // the notebook will have an arrow button rather than shrinking tabs
         // to an unreadably small size.
-        c.gtk_widget_set_size_request(@ptrCast(label_text), 100, 1);
+        c.gtk_widget_set_size_request(label_text_widget, 100, 1);
     }
 
     // Create a Box in which we'll later keep either Surface or Paned

commit ecbe91071408c5fa2627989d199b324b4ca77639
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Mon Nov 20 07:04:14 2023 +0100

    gtk: fix closing of surfaces by releasing the ref to gl_area

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 1a0d52a1..d1d33893 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -151,7 +151,8 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 /// Deinits tab by deiniting child if child is Paned.
 pub fn deinit(self: *Tab) void {
     switch (self.child) {
-        .none, .surface => return,
+        .none => return,
+        .surface => |s| s.shutdown(),
         .paned => |paned| {
             paned.deinit(self.window.app.core_app.alloc);
             self.window.app.core_app.alloc.destroy(paned);

commit 8cf9d97ac315cf1346f0542552c623be1e13d62b
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Thu Nov 23 19:45:19 2023 +0100

    gtk: fix replacing of splits, remove dead code

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d1d33893..afa3383b 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -10,9 +10,6 @@ const font = @import("../../font/main.zig");
 const input = @import("../../input.zig");
 const CoreSurface = @import("../../Surface.zig");
 
-const Paned = @import("Paned.zig");
-const Parent = @import("relation.zig").Parent;
-const Child = @import("relation.zig").Child;
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
 const c = @import("c.zig");
@@ -34,9 +31,6 @@ box: *c.GtkBox,
 /// The element of this tab so that we can handle splits and so on.
 elem: Surface.Container.Elem,
 
-// The child can be either a Surface if the tab is not split or a Paned
-child: Child,
-
 // We'll update this every time a Surface gains focus, so that we have it
 // when we switch to another Tab. Then when we switch back to this tab, we
 // can easily re-focus that terminal.
@@ -57,7 +51,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .label_text = undefined,
         .box = undefined,
         .elem = undefined,
-        .child = undefined,
         .focus_child = undefined,
     };
 
@@ -93,7 +86,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         c.gtk_widget_set_size_request(label_text_widget, 100, 1);
     }
 
-    // Create a Box in which we'll later keep either Surface or Paned
+    // Create a Box in which we'll later keep either Surface or Split
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
     c.gtk_widget_set_hexpand(box_widget, 1);
     c.gtk_widget_set_vexpand(box_widget, 1);
@@ -105,7 +98,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     });
     errdefer surface.destroy(window.app.core_app.alloc);
     surface.setContainer(.{ .tab_ = self });
-    self.child = .{ .surface = surface };
     self.elem = .{ .surface = surface };
 
     // Add Surface to the Tab
@@ -148,29 +140,16 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     surface.grabFocus();
 }
 
-/// Deinits tab by deiniting child if child is Paned.
+/// Deinits tab by deiniting child elem.
 pub fn deinit(self: *Tab) void {
-    switch (self.child) {
-        .none => return,
-        .surface => |s| s.shutdown(),
-        .paned => |paned| {
-            paned.deinit(self.window.app.core_app.alloc);
-            self.window.app.core_app.alloc.destroy(paned);
-        },
-    }
-}
-
-/// Remove the current child from the Tab. Noop if no child set.
-pub fn removeChild(self: *Tab) void {
-    const widget = self.child.widget() orelse return;
-    c.gtk_box_remove(self.box, widget);
-
-    self.child = .none;
+    self.elem.shutdown();
 }
 
 // TODO: move this
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
+    // _ = c.g_object_ref_sink(self.elem.widget());
+
     // Remove our previous widget
     c.gtk_box_remove(self.box, self.elem.widget());
 
@@ -186,15 +165,6 @@ pub fn closeElem(self: *Tab) void {
     self.window.closeTab(self);
 }
 
-/// Sets child to given child and sets parent on child.
-pub fn setChild(self: *Tab, child: Child) void {
-    const widget = child.widget() orelse return;
-    c.gtk_box_append(self.box, widget);
-
-    child.setParent(.{ .tab = self });
-    self.child = child;
-}
-
 fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     const window = tab.window;

commit 0065bae0d43959ed973092b6c50dfa86c6b0977d
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Nov 25 13:46:48 2023 +0100

    gtk: get closing of tabs working again (closing windows still broken)

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index afa3383b..fc16c8e3 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -142,7 +142,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
 /// Deinits tab by deiniting child elem.
 pub fn deinit(self: *Tab) void {
-    self.elem.shutdown();
+    self.elem.destroy();
 }
 
 // TODO: move this

commit a18fb4a6615c3a63c5024e65d09d036044b76949
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Nov 25 15:24:07 2023 +0100

    gtk: fix closing of windows that contains splits

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index fc16c8e3..867956d0 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -141,15 +141,13 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 }
 
 /// Deinits tab by deiniting child elem.
-pub fn deinit(self: *Tab) void {
-    self.elem.destroy();
+pub fn deinit(self: *Tab, alloc: Allocator) void {
+    self.elem.deinit(alloc);
 }
 
 // TODO: move this
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
-    // _ = c.g_object_ref_sink(self.elem.widget());
-
     // Remove our previous widget
     c.gtk_box_remove(self.box, self.elem.widget());
 

commit 3fef4fce5682975230f39a678e7858c33ba2a66e
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Nov 25 16:21:42 2023 +0100

    gtk: move surface destroy through deref

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 867956d0..4b7ef5cc 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -96,7 +96,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
         .parent2 = parent_,
     });
-    errdefer surface.destroy(window.app.core_app.alloc);
+    errdefer surface.unref();
     surface.setContainer(.{ .tab_ = self });
     self.elem = .{ .surface = surface };
 

commit 7e9dce054f39c3b44a70f9c8d6fbfd3f8ec80b03
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sun Nov 26 13:18:43 2023 +0100

    gtk: remove unneeded method setContainer on Surface
    
    We don't need to update the titles, etc. since that's done by
    `grabFocus` and that then makes the method not that useful. Removing for
    now.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 4b7ef5cc..d8c006ce 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -97,7 +97,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .parent2 = parent_,
     });
     errdefer surface.unref();
-    surface.setContainer(.{ .tab_ = self });
+    surface.container = .{ .tab_ = self };
     self.elem = .{ .surface = surface };
 
     // Add Surface to the Tab

commit 89f4cf11c79bb706949f9b29710e6170192f139a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 30 21:46:43 2023 -0800

    apprt/gtk: rename parent2 to parent

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d8c006ce..96acfea0 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -94,7 +94,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Create the initial surface since all tabs start as a single non-split
     var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
-        .parent2 = parent_,
+        .parent = parent_,
     });
     errdefer surface.unref();
     surface.container = .{ .tab_ = self };

commit c7eeda1f00e02978cb63cbb3640cf9f53f3c7139
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 1 08:08:06 2023 -0800

    apprt/gtk: code aesthetic changes

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 96acfea0..c25f4ad5 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -18,9 +18,10 @@ const log = std.log.scoped(.gtk);
 
 pub const GHOSTTY_TAB = "ghostty_tab";
 
+/// The window that owns this tab.
 window: *Window,
 
-/// The tab label.
+/// The tab label. The tab label is the text that appears on the tab.
 label_text: *c.GtkLabel,
 
 /// We'll put our children into this box instead of packing them
@@ -86,7 +87,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         c.gtk_widget_set_size_request(label_text_widget, 100, 1);
     }
 
-    // Create a Box in which we'll later keep either Surface or Split
+    // Create a Box in which we'll later keep either Surface or Split.
+    // Using a box makes it easier to maintain the tab contents because
+    // we never need to change the root widget of the notebook page (tab).
     const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
     c.gtk_widget_set_hexpand(box_widget, 1);
     c.gtk_widget_set_vexpand(box_widget, 1);
@@ -145,6 +148,12 @@ pub fn deinit(self: *Tab, alloc: Allocator) void {
     self.elem.deinit(alloc);
 }
 
+/// Deinit and deallocate the tab.
+pub fn destroy(self: *Tab, alloc: Allocator) void {
+    self.deinit(alloc);
+    alloc.destroy(self);
+}
+
 // TODO: move this
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {

commit dd39b29f30e078418e4ce366c35c33eff52a527f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 1 08:52:08 2023 -0800

    apprt/gtk: we don't need to keep track of Tabs

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index c25f4ad5..e6a41779 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -134,6 +134,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Attach all events
     _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
+    _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
 
     // Switch to the new tab
     c.gtk_notebook_set_current_page(window.notebook, page_idx);
@@ -177,3 +178,12 @@ fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const window = tab.window;
     window.closeTab(tab);
 }
+
+fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
+    _ = v;
+    log.debug("tab box destroy", .{});
+
+    // When our box is destroyed, we want to destroy our tab, too.
+    const tab: *Tab = @ptrCast(@alignCast(ud));
+    tab.destroy(tab.window.app.core_app.alloc);
+}

commit 14ef6fb2f9e0db71a4012b4a1830ccc5519f2541
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 1 09:07:37 2023 -0800

    apprt/gtk: add comments, rename some funcs

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index e6a41779..fff5b951 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -166,10 +166,8 @@ pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     self.elem = elem;
 }
 
-// TODO: move this
-/// The surface element is closing. If we're the direct parent
-/// then that means our tab is also closing.
-pub fn closeElem(self: *Tab) void {
+/// Remove this tab from the window.
+pub fn remove(self: *Tab) void {
     self.window.closeTab(self);
 }
 

commit fc7013fc2e32d382f30256d18012067f23b13eaa
Author: Denys Pavlov <me@denys.me>
Date:   Wed Dec 13 11:07:23 2023 -0500

    gtk: close tabs with middle-click
    
    Follow the behaviour of other tabbed interfaces like browsers, editors,
    and file-managers.
    
    GTK code is based on `/src/apprt/gtk/ImguiWidget.zig`

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index fff5b951..d6ac452e 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -132,9 +132,15 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
+    // Clicks
+    const gesture_tab_click = c.gtk_gesture_click_new();
+    c.gtk_gesture_single_set_button(@ptrCast(gesture_tab_click), 0);
+    c.gtk_widget_add_controller(label_box_widget, @ptrCast(gesture_tab_click));
+
     // Attach all events
     _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
+    _ = c.g_signal_connect_data(gesture_tab_click, "pressed", c.G_CALLBACK(&gtkTabClick), self, null, c.G_CONNECT_DEFAULT);
 
     // Switch to the new tab
     c.gtk_notebook_set_current_page(window.notebook, page_idx);
@@ -185,3 +191,17 @@ fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     tab.destroy(tab.window.app.core_app.alloc);
 }
+
+fn gtkTabClick(
+    gesture: *c.GtkGestureClick,
+    _: c.gint,
+    _: c.gdouble,
+    _: c.gdouble,
+    ud: ?*anyopaque,
+) callconv(.C) void {
+    const self: *Tab = @ptrCast(@alignCast(ud));
+    const gtk_button = c.gtk_gesture_single_get_current_button(@ptrCast(gesture));
+    if (gtk_button == c.GDK_BUTTON_MIDDLE) {
+        self.remove();
+    }
+}

commit 2aa1874f945dd480265d37ff93ce64729492951f
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Fri Jan 12 17:35:15 2024 +0100

    gtk: append new tabs at the end if config is set
    
    This adds a new config option: `window-append-new-tabs` (please: if you
    have a better name, let me know). If this is set to true, then new GTK
    tabs aren't added after the current tab, but after at the end.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d6ac452e..d6a56132 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -107,13 +107,21 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
     c.gtk_box_append(self.box, gl_area_widget);
 
-    // Add the notebook page (create tab). We create the tab after our
-    // current selected tab if we have one.
+    // Add the notebook page (create tab).
+    const parent_page_idx = parent_page_idx: {
+        // If this option is enabled we append the new tab to the end of the notebook.
+        if (window.app.config.@"window-append-new-tabs") {
+            break :parent_page_idx c.gtk_notebook_get_n_pages(window.notebook);
+        }
+        // Otherwise we add it after the current tab.
+        break :parent_page_idx c.gtk_notebook_get_current_page(window.notebook) + 1;
+    };
+
     const page_idx = c.gtk_notebook_insert_page(
         window.notebook,
         box_widget,
         label_box_widget,
-        c.gtk_notebook_get_current_page(window.notebook) + 1,
+        parent_page_idx,
     );
     if (page_idx < 0) {
         log.warn("failed to add page to notebook", .{});

commit 81b9a6b623b25951b2a7f5f3d7cf4dee3197f6a7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jan 12 09:50:47 2024 -0800

    config: rename window-append-new-tab to window-new-tab-position

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d6a56132..875e80d5 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -108,13 +108,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     c.gtk_box_append(self.box, gl_area_widget);
 
     // Add the notebook page (create tab).
-    const parent_page_idx = parent_page_idx: {
-        // If this option is enabled we append the new tab to the end of the notebook.
-        if (window.app.config.@"window-append-new-tabs") {
-            break :parent_page_idx c.gtk_notebook_get_n_pages(window.notebook);
-        }
-        // Otherwise we add it after the current tab.
-        break :parent_page_idx c.gtk_notebook_get_current_page(window.notebook) + 1;
+    const parent_page_idx = switch (window.app.config.@"window-new-tab-position") {
+        .current => c.gtk_notebook_get_current_page(window.notebook) + 1,
+        .end => c.gtk_notebook_get_n_pages(window.notebook),
     };
 
     const page_idx = c.gtk_notebook_insert_page(

commit 137359bcb5d8e479fbb2575146742d380615415e
Author: Igor Anic <igor.anic@gmail.com>
Date:   Wed Mar 27 20:04:17 2024 +0100

    gtk: use symbolic icon for tab close
    
    On my system (xorg Ubuntu 24.04, Adwaita:dark theme) tab close icon was
    red while in all other applications was more discrete. With adding
    `-symbolic` to the icon name now looks like all other application.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 875e80d5..a41c72d9 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -64,7 +64,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.label_text = label_text;
 
     // Build the close button for the tab
-    const label_close_widget = c.gtk_button_new_from_icon_name("window-close");
+    const label_close_widget = c.gtk_button_new_from_icon_name("window-close-symbolic");
     const label_close: *c.GtkButton = @ptrCast(label_close_widget);
     c.gtk_button_set_has_frame(label_close, 0);
     c.gtk_box_append(label_box, label_close_widget);

commit 8858c2ba4e59b7226ca3b9cfa6e58d4823796307
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 6 15:00:52 2024 -0700

    apprt/gtk: convert surface to overlay so we can support the url overlay

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index a41c72d9..32b0c788 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -104,8 +104,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.elem = .{ .surface = surface };
 
     // Add Surface to the Tab
-    const gl_area_widget = @as(*c.GtkWidget, @ptrCast(surface.gl_area));
-    c.gtk_box_append(self.box, gl_area_widget);
+    c.gtk_box_append(self.box, surface.primaryWidget());
 
     // Add the notebook page (create tab).
     const parent_page_idx = switch (window.app.config.@"window-new-tab-position") {

commit 9409e3072fcb0e22a8a4bc8378bb7238099a7bc2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 16 14:57:43 2024 -0700

    apprt/gtk: remove usingnamespace

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 32b0c788..42a18711 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -12,7 +12,7 @@ const CoreSurface = @import("../../Surface.zig");
 
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
-const c = @import("c.zig");
+const c = @import("c.zig").c;
 
 const log = std.log.scoped(.gtk);
 

commit 0e22695ec48cfd74c2fe5366996746012ab1eb27
Author: Paul <paul@plutojl.org>
Date:   Sat Jun 8 13:23:38 2024 +0200

    gtk: use adwaita tab view when possible
    
    add tab bar view

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 42a18711..8a2f0551 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -55,37 +55,23 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .focus_child = undefined,
     };
 
-    // Build the tab label
-    const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
-    const label_box = @as(*c.GtkBox, @ptrCast(label_box_widget));
-    const label_text_widget = c.gtk_label_new("Ghostty");
-    const label_text: *c.GtkLabel = @ptrCast(label_text_widget);
-    c.gtk_box_append(label_box, label_text_widget);
-    self.label_text = label_text;
-
-    // Build the close button for the tab
-    const label_close_widget = c.gtk_button_new_from_icon_name("window-close-symbolic");
-    const label_close: *c.GtkButton = @ptrCast(label_close_widget);
-    c.gtk_button_set_has_frame(label_close, 0);
-    c.gtk_box_append(label_box, label_close_widget);
-
-    // Wide style GTK tabs
-    if (window.app.config.@"gtk-wide-tabs") {
-        c.gtk_widget_set_hexpand(label_box_widget, 1);
-        c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
-        c.gtk_widget_set_hexpand(label_text_widget, 1);
-        c.gtk_widget_set_halign(label_text_widget, c.GTK_ALIGN_FILL);
-
-        // This ensures that tabs are always equal width. If they're too
-        // long, they'll be truncated with an ellipsis.
-        c.gtk_label_set_max_width_chars(label_text, 1);
-        c.gtk_label_set_ellipsize(label_text, c.PANGO_ELLIPSIZE_END);
-
-        // We need to set a minimum width so that at a certain point
-        // the notebook will have an arrow button rather than shrinking tabs
-        // to an unreadably small size.
-        c.gtk_widget_set_size_request(label_text_widget, 100, 1);
-    }
+    // // Wide style GTK tabs
+    // if (window.app.config.@"gtk-wide-tabs") {
+    //     c.gtk_widget_set_hexpand(label_box_widget, 1);
+    //     c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
+    //     c.gtk_widget_set_hexpand(label_text_widget, 1);
+    //     c.gtk_widget_set_halign(label_text_widget, c.GTK_ALIGN_FILL);
+
+    //     // This ensures that tabs are always equal width. If they're too
+    //     // long, they'll be truncated with an ellipsis.
+    //     c.gtk_label_set_max_width_chars(label_text, 1);
+    //     c.gtk_label_set_ellipsize(label_text, c.PANGO_ELLIPSIZE_END);
+
+    //     // We need to set a minimum width so that at a certain point
+    //     // the notebook will have an arrow button rather than shrinking tabs
+    //     // to an unreadably small size.
+    //     c.gtk_widget_set_size_request(label_text_widget, 100, 1);
+    // }
 
     // Create a Box in which we'll later keep either Surface or Split.
     // Using a box makes it easier to maintain the tab contents because
@@ -106,47 +92,51 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Add Surface to the Tab
     c.gtk_box_append(self.box, surface.primaryWidget());
 
-    // Add the notebook page (create tab).
-    const parent_page_idx = switch (window.app.config.@"window-new-tab-position") {
-        .current => c.gtk_notebook_get_current_page(window.notebook) + 1,
-        .end => c.gtk_notebook_get_n_pages(window.notebook),
-    };
+    try window.notebook.addTab(box_widget, "Ghostty");
 
-    const page_idx = c.gtk_notebook_insert_page(
-        window.notebook,
-        box_widget,
-        label_box_widget,
-        parent_page_idx,
-    );
-    if (page_idx < 0) {
-        log.warn("failed to add page to notebook", .{});
-        return error.GtkAppendPageFailed;
-    }
+    // const notebook: *c.GtkNotebook = window.notebook.as_notebook();
 
-    // Tab settings
-    c.gtk_notebook_set_tab_reorderable(window.notebook, box_widget, 1);
-    c.gtk_notebook_set_tab_detachable(window.notebook, box_widget, 1);
+    // // Add the notebook page (create tab).
+    // const parent_page_idx = switch (window.app.config.@"window-new-tab-position") {
+    //     .current => c.gtk_notebook_get_current_page(notebook) + 1,
+    //     .end => c.gtk_notebook_get_n_pages(notebook),
+    // };
 
-    // If we have multiple tabs, show the tab bar.
-    if (c.gtk_notebook_get_n_pages(window.notebook) > 1) {
-        c.gtk_notebook_set_show_tabs(window.notebook, 1);
-    }
+    // const page_idx = c.gtk_notebook_insert_page(
+    //     notebook,
+    //     box_widget,
+    //     label_box_widget,
+    //     parent_page_idx,
+    // );
+    // if (page_idx < 0) {
+    //     log.warn("failed to add page to notebook", .{});
+    //     return error.GtkAppendPageFailed;
+    // }
+
+    // // Tab settings
+    // c.gtk_notebook_set_tab_reorderable(notebook, box_widget, 1);
+    // c.gtk_notebook_set_tab_detachable(notebook, box_widget, 1);
+
+    // // If we have multiple tabs, show the tab bar.
+    // if (c.gtk_notebook_get_n_pages(notebook) > 1) {
+    //     c.gtk_notebook_set_show_tabs(notebook, 1);
+    // }
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
-    // Clicks
-    const gesture_tab_click = c.gtk_gesture_click_new();
-    c.gtk_gesture_single_set_button(@ptrCast(gesture_tab_click), 0);
-    c.gtk_widget_add_controller(label_box_widget, @ptrCast(gesture_tab_click));
+    // // Clicks
+    // const gesture_tab_click = c.gtk_gesture_click_new();
+    // c.gtk_gesture_single_set_button(@ptrCast(gesture_tab_click), 0);
+    // c.gtk_widget_add_controller(label_box_widget, @ptrCast(gesture_tab_click));
 
-    // Attach all events
-    _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
-    _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
-    _ = c.g_signal_connect_data(gesture_tab_click, "pressed", c.G_CALLBACK(&gtkTabClick), self, null, c.G_CONNECT_DEFAULT);
+    // // Attach all events
+    // _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
+    // _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
+    // _ = c.g_signal_connect_data(gesture_tab_click, "pressed", c.G_CALLBACK(&gtkTabClick), self, null, c.G_CONNECT_DEFAULT);
 
-    // Switch to the new tab
-    c.gtk_notebook_set_current_page(window.notebook, page_idx);
+    // // Switch to the new tab
+    // c.gtk_notebook_set_current_page(notebook, page_idx);
 
     // We need to grab focus after Surface and Tab is added to the window. When
     // creating a Tab we want to always focus on the widget.
@@ -175,6 +165,18 @@ pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     self.elem = elem;
 }
 
+pub fn setLabelText(self: *Tab, title: [:0]const u8) void {
+    switch (self.window.notebook) {
+        .adw_tab_view => |tab_view| {
+            const page = c.adw_tab_view_get_page(tab_view, @ptrCast(self.box));
+            c.adw_tab_page_set_title(page, title.ptr);
+        },
+        .gtk_notebook => {
+            c.gtk_label_set_text(self.label_text, title.ptr);
+        }
+    }
+}
+
 /// Remove this tab from the window.
 pub fn remove(self: *Tab) void {
     self.window.closeTab(self);

commit 42c93d89fcee98e6473bb103898c8ac2ea21e502
Author: Paul <paul@plutojl.org>
Date:   Sat Jun 8 14:25:35 2024 +0200

    adw: move notebook to its own file

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 8a2f0551..a58917b0 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -92,7 +92,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Add Surface to the Tab
     c.gtk_box_append(self.box, surface.primaryWidget());
 
-    try window.notebook.addTab(box_widget, "Ghostty");
+    try window.notebook.addTab(self, "Ghostty");
 
     // const notebook: *c.GtkNotebook = window.notebook.as_notebook();
 
@@ -132,12 +132,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // // Attach all events
     // _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
-    // _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
+    _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
     // _ = c.g_signal_connect_data(gesture_tab_click, "pressed", c.G_CALLBACK(&gtkTabClick), self, null, c.G_CONNECT_DEFAULT);
 
-    // // Switch to the new tab
-    // c.gtk_notebook_set_current_page(notebook, page_idx);
-
     // We need to grab focus after Surface and Tab is added to the window. When
     // creating a Tab we want to always focus on the widget.
     surface.grabFocus();
@@ -166,15 +163,7 @@ pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
 }
 
 pub fn setLabelText(self: *Tab, title: [:0]const u8) void {
-    switch (self.window.notebook) {
-        .adw_tab_view => |tab_view| {
-            const page = c.adw_tab_view_get_page(tab_view, @ptrCast(self.box));
-            c.adw_tab_page_set_title(page, title.ptr);
-        },
-        .gtk_notebook => {
-            c.gtk_label_set_text(self.label_text, title.ptr);
-        }
-    }
+    self.window.notebook.setTabLabel(self, title);
 }
 
 /// Remove this tab from the window.

commit 9c8a9f3d6be5a45fbd409edd4f56a662e2df8f96
Author: Paul Berg <paul.berg@univ-ubs.fr>
Date:   Mon Jun 10 09:29:39 2024 +0200

    adw: respect gtk-wide-tabs
    
    update

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index a58917b0..fce4c0a6 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -92,6 +92,8 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // Add Surface to the Tab
     c.gtk_box_append(self.box, surface.primaryWidget());
 
+    // Set the userdata of the box to point to this tab.
+    c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
     try window.notebook.addTab(self, "Ghostty");
 
     // const notebook: *c.GtkNotebook = window.notebook.as_notebook();
@@ -122,18 +124,11 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     //     c.gtk_notebook_set_show_tabs(notebook, 1);
     // }
 
-    // Set the userdata of the box to point to this tab.
-    c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
 
-    // // Clicks
-    // const gesture_tab_click = c.gtk_gesture_click_new();
-    // c.gtk_gesture_single_set_button(@ptrCast(gesture_tab_click), 0);
-    // c.gtk_widget_add_controller(label_box_widget, @ptrCast(gesture_tab_click));
+    // 
 
     // // Attach all events
-    // _ = c.g_signal_connect_data(label_close, "clicked", c.G_CALLBACK(&gtkTabCloseClick), self, null, c.G_CONNECT_DEFAULT);
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
-    // _ = c.g_signal_connect_data(gesture_tab_click, "pressed", c.G_CALLBACK(&gtkTabClick), self, null, c.G_CONNECT_DEFAULT);
 
     // We need to grab focus after Surface and Tab is added to the window. When
     // creating a Tab we want to always focus on the widget.
@@ -171,7 +166,7 @@ pub fn remove(self: *Tab) void {
     self.window.closeTab(self);
 }
 
-fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
+pub fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     const window = tab.window;
     window.closeTab(tab);
@@ -186,7 +181,7 @@ fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     tab.destroy(tab.window.app.core_app.alloc);
 }
 
-fn gtkTabClick(
+pub fn gtkTabClick(
     gesture: *c.GtkGestureClick,
     _: c.gint,
     _: c.gdouble,

commit bdf618d7af7d58d71b12061aa083cb532cc035b5
Author: Paul <paul@plutojl.org>
Date:   Wed Jun 12 20:43:41 2024 +0200

    gtk: adw toolbar view
    
    gate toolbar view on ADWAITA_MINOR >= 4
    
    use the right destructor on window creation errors

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index fce4c0a6..aa0c36a5 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -124,10 +124,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     //     c.gtk_notebook_set_show_tabs(notebook, 1);
     // }
 
-
-    // 
-
-    // // Attach all events
+    // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
 
     // We need to grab focus after Surface and Tab is added to the window. When
@@ -174,7 +171,7 @@ pub fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
 
 fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     _ = v;
-    log.debug("tab box destroy", .{});
+    log.info("tab box destroy", .{});
 
     // When our box is destroyed, we want to destroy our tab, too.
     const tab: *Tab = @ptrCast(@alignCast(ud));

commit 0c286a049a03058ff847dd5a7371c6134c3f5019
Author: Paul Berg <paul.berg@univ-ubs.fr>
Date:   Tue Aug 20 11:46:04 2024 +0200

    gtk: add adwaita banner

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index aa0c36a5..3595bb97 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -55,24 +55,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .focus_child = undefined,
     };
 
-    // // Wide style GTK tabs
-    // if (window.app.config.@"gtk-wide-tabs") {
-    //     c.gtk_widget_set_hexpand(label_box_widget, 1);
-    //     c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
-    //     c.gtk_widget_set_hexpand(label_text_widget, 1);
-    //     c.gtk_widget_set_halign(label_text_widget, c.GTK_ALIGN_FILL);
-
-    //     // This ensures that tabs are always equal width. If they're too
-    //     // long, they'll be truncated with an ellipsis.
-    //     c.gtk_label_set_max_width_chars(label_text, 1);
-    //     c.gtk_label_set_ellipsize(label_text, c.PANGO_ELLIPSIZE_END);
-
-    //     // We need to set a minimum width so that at a certain point
-    //     // the notebook will have an arrow button rather than shrinking tabs
-    //     // to an unreadably small size.
-    //     c.gtk_widget_set_size_request(label_text_widget, 100, 1);
-    // }
-
     // Create a Box in which we'll later keep either Surface or Split.
     // Using a box makes it easier to maintain the tab contents because
     // we never need to change the root widget of the notebook page (tab).
@@ -96,34 +78,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
     try window.notebook.addTab(self, "Ghostty");
 
-    // const notebook: *c.GtkNotebook = window.notebook.as_notebook();
-
-    // // Add the notebook page (create tab).
-    // const parent_page_idx = switch (window.app.config.@"window-new-tab-position") {
-    //     .current => c.gtk_notebook_get_current_page(notebook) + 1,
-    //     .end => c.gtk_notebook_get_n_pages(notebook),
-    // };
-
-    // const page_idx = c.gtk_notebook_insert_page(
-    //     notebook,
-    //     box_widget,
-    //     label_box_widget,
-    //     parent_page_idx,
-    // );
-    // if (page_idx < 0) {
-    //     log.warn("failed to add page to notebook", .{});
-    //     return error.GtkAppendPageFailed;
-    // }
-
-    // // Tab settings
-    // c.gtk_notebook_set_tab_reorderable(notebook, box_widget, 1);
-    // c.gtk_notebook_set_tab_detachable(notebook, box_widget, 1);
-
-    // // If we have multiple tabs, show the tab bar.
-    // if (c.gtk_notebook_get_n_pages(notebook) > 1) {
-    //     c.gtk_notebook_set_show_tabs(notebook, 1);
-    // }
-
     // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
 
@@ -171,7 +125,7 @@ pub fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
 
 fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     _ = v;
-    log.info("tab box destroy", .{});
+    log.debug("tab box destroy", .{});
 
     // When our box is destroyed, we want to destroy our tab, too.
     const tab: *Tab = @ptrCast(@alignCast(ud));

commit f35671417c7e3bb6863d9f50bd95c0a1cd897945
Author: Tristan Partin <tristan@partin.io>
Date:   Thu Sep 12 23:17:14 2024 +0100

    apprt/gtk: use AdwTabOverview
    
    An additional way to manage tabs.
    
    Signed-off-by: Tristan Partin <tristan@partin.io>

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 3595bb97..e3134903 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -37,6 +37,10 @@ elem: Surface.Container.Elem,
 // can easily re-focus that terminal.
 focus_child: *Surface,
 
+/// If the notebook implementation is AdwTabView, then this is the tab's
+/// AdwTabPage.
+tab_page: *c.GObject,
+
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
@@ -53,6 +57,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .box = undefined,
         .elem = undefined,
         .focus_child = undefined,
+        .tab_page = undefined,
     };
 
     // Create a Box in which we'll later keep either Surface or Split.
@@ -76,7 +81,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
-    try window.notebook.addTab(self, "Ghostty");
+    self.tab_page = try window.notebook.addTab(self, "Ghostty");
 
     // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);

commit fced4370d3e7b664f3e1252c562cfcb03376a4a2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 12 16:06:14 2024 -0700

    apprt/gtk: some tweaks, avoid uninitialized memory access, use optionals

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index e3134903..415e5fb4 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -38,8 +38,9 @@ elem: Surface.Container.Elem,
 focus_child: *Surface,
 
 /// If the notebook implementation is AdwTabView, then this is the tab's
-/// AdwTabPage.
-tab_page: *c.GObject,
+/// AdwTabPage. If we have libadwaita disabled then this will be undefined
+/// memory and is unsafe to use.
+adw_tab_page: *c.GObject,
 
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
@@ -57,7 +58,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .box = undefined,
         .elem = undefined,
         .focus_child = undefined,
-        .tab_page = undefined,
+        .adw_tab_page = undefined,
     };
 
     // Create a Box in which we'll later keep either Surface or Split.
@@ -81,7 +82,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
-    self.tab_page = try window.notebook.addTab(self, "Ghostty");
+    if (try window.notebook.addTab(self, "Ghostty")) |page| {
+        self.adw_tab_page = page;
+    }
 
     // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);

commit b935c7d46c09ede4a9364c222bf79062d67e8805
Author: Paul Berg <paul@plutojl.org>
Date:   Fri Sep 13 13:36:13 2024 +0200

    apprt/gtk: remove adw_tab_page from tab

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 415e5fb4..3595bb97 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -37,11 +37,6 @@ elem: Surface.Container.Elem,
 // can easily re-focus that terminal.
 focus_child: *Surface,
 
-/// If the notebook implementation is AdwTabView, then this is the tab's
-/// AdwTabPage. If we have libadwaita disabled then this will be undefined
-/// memory and is unsafe to use.
-adw_tab_page: *c.GObject,
-
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
@@ -58,7 +53,6 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .box = undefined,
         .elem = undefined,
         .focus_child = undefined,
-        .adw_tab_page = undefined,
     };
 
     // Create a Box in which we'll later keep either Surface or Split.
@@ -82,9 +76,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
-    if (try window.notebook.addTab(self, "Ghostty")) |page| {
-        self.adw_tab_page = page;
-    }
+    try window.notebook.addTab(self, "Ghostty");
 
     // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);

commit 4a492f24be2929898980db0136bb46f89abac59e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 18 07:29:16 2024 -0700

    apprt/gtk: make focusCurrentTab safe to call at any time

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 3595bb97..1a076271 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -35,7 +35,7 @@ elem: Surface.Container.Elem,
 // We'll update this every time a Surface gains focus, so that we have it
 // when we switch to another Tab. Then when we switch back to this tab, we
 // can easily re-focus that terminal.
-focus_child: *Surface,
+focus_child: ?*Surface,
 
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
@@ -52,7 +52,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .label_text = undefined,
         .box = undefined,
         .elem = undefined,
-        .focus_child = undefined,
+        .focus_child = null,
     };
 
     // Create a Box in which we'll later keep either Surface or Split.

commit 9c2581157659bedcd3b4f2feae041d5933a9455d
Author: Tristan Partin <tristan@partin.io>
Date:   Fri Nov 15 23:22:00 2024 -0600

    apprt/gtk: handle pwd action
    
    Use it as a tooltip for the tab.
    
    Signed-off-by: Tristan Partin <tristan@partin.io>

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 1a076271..82384a44 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -112,6 +112,10 @@ pub fn setLabelText(self: *Tab, title: [:0]const u8) void {
     self.window.notebook.setTabLabel(self, title);
 }
 
+pub fn setTooltipText(self: *Tab, tooltip: [:0]const u8) void {
+    self.window.notebook.setTabTooltip(self, tooltip);
+}
+
 /// Remove this tab from the window.
 pub fn remove(self: *Tab) void {
     self.window.closeTab(self);

commit 0778c674299c72957ee980ce25ce999293e0d4ec
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Sat Nov 2 13:10:22 2024 -0500

    gtk: refactor gtk & adw notebook implementations
    
    Put GTK and libadwaita notebook implementations into separate structs/
    files for clarity.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 82384a44..ed0804fd 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -76,7 +76,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
-    try window.notebook.addTab(self, "Ghostty");
+    window.notebook.addTab(self, "Ghostty");
 
     // Attach all events
     _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);

commit b7b5b9bbf5f570f4669c92e61322469a825d0b33
Author: Leigh Oliver <leigh@leigholiver.com>
Date:   Tue Dec 31 23:40:49 2024 +0000

    fix(gtk): add close confirmation for tabs

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index ed0804fd..1a3b4413 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -121,10 +121,71 @@ pub fn remove(self: *Tab) void {
     self.window.closeTab(self);
 }
 
+/// Helper function to check if any surface in the split hierarchy needs close confirmation
+const needsConfirm = struct {
+    fn check(elem: Surface.Container.Elem) bool {
+        return switch (elem) {
+            .surface => |s| s.core_surface.needsConfirmQuit(),
+            .split => |s| check(s.top_left) or check(s.bottom_right),
+        };
+    }
+}.check;
+
+/// Close the tab, asking for confirmation if any surface requests it.
+fn closeWithConfirmation(tab: *Tab) void {
+    switch (tab.elem) {
+        .surface => |s| s.close(s.core_surface.needsConfirmQuit()),
+        .split => |s| {
+            if (needsConfirm(s.top_left) or needsConfirm(s.bottom_right)) {
+                const alert = c.gtk_message_dialog_new(
+                    tab.window.window,
+                    c.GTK_DIALOG_MODAL,
+                    c.GTK_MESSAGE_QUESTION,
+                    c.GTK_BUTTONS_YES_NO,
+                    "Close this tab?",
+                );
+                c.gtk_message_dialog_format_secondary_text(
+                    @ptrCast(alert),
+                    "All terminal sessions in this tab will be terminated.",
+                );
+
+                // We want the "yes" to appear destructive.
+                const yes_widget = c.gtk_dialog_get_widget_for_response(
+                    @ptrCast(alert),
+                    c.GTK_RESPONSE_YES,
+                );
+                c.gtk_widget_add_css_class(yes_widget, "destructive-action");
+
+                // We want the "no" to be the default action
+                c.gtk_dialog_set_default_response(
+                    @ptrCast(alert),
+                    c.GTK_RESPONSE_NO,
+                );
+
+                _ = c.g_signal_connect_data(alert, "response", c.G_CALLBACK(&gtkTabCloseConfirmation), tab, null, c.G_CONNECT_DEFAULT);
+                c.gtk_widget_show(alert);
+                return;
+            }
+            tab.remove();
+        },
+    }
+}
+
 pub fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
-    const window = tab.window;
-    window.closeTab(tab);
+    tab.closeWithConfirmation();
+}
+
+fn gtkTabCloseConfirmation(
+    alert: *c.GtkMessageDialog,
+    response: c.gint,
+    ud: ?*anyopaque,
+) callconv(.C) void {
+    c.gtk_window_destroy(@ptrCast(alert));
+    if (response == c.GTK_RESPONSE_YES) {
+        const tab: *Tab = @ptrCast(@alignCast(ud));
+        tab.remove();
+    }
 }
 
 fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
@@ -146,6 +207,6 @@ pub fn gtkTabClick(
     const self: *Tab = @ptrCast(@alignCast(ud));
     const gtk_button = c.gtk_gesture_single_get_current_button(@ptrCast(gesture));
     if (gtk_button == c.GDK_BUTTON_MIDDLE) {
-        self.remove();
+        self.closeWithConfirmation();
     }
 }

commit 8c1ad59de761153023fba73913bb168df91c55d5
Author: Leigh Oliver <leigh@leigholiver.com>
Date:   Wed Jan 1 10:14:16 2025 +0000

    remove unnecessary struct

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 1a3b4413..6e28b864 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -122,14 +122,12 @@ pub fn remove(self: *Tab) void {
 }
 
 /// Helper function to check if any surface in the split hierarchy needs close confirmation
-const needsConfirm = struct {
-    fn check(elem: Surface.Container.Elem) bool {
-        return switch (elem) {
-            .surface => |s| s.core_surface.needsConfirmQuit(),
-            .split => |s| check(s.top_left) or check(s.bottom_right),
-        };
-    }
-}.check;
+fn needsConfirm(elem: Surface.Container.Elem) bool {
+    return switch (elem) {
+        .surface => |s| s.core_surface.needsConfirmQuit(),
+        .split => |s| needsConfirm(s.top_left) or needsConfirm(s.bottom_right),
+    };
+}
 
 /// Close the tab, asking for confirmation if any surface requests it.
 fn closeWithConfirmation(tab: *Tab) void {

commit 00137c41895628cc6a068e40445b6670ae3a9012
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jan 10 15:32:25 2025 -0800

    apprt/gtk: adw tab view close confirmation

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 6e28b864..d320daa7 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -130,7 +130,7 @@ fn needsConfirm(elem: Surface.Container.Elem) bool {
 }
 
 /// Close the tab, asking for confirmation if any surface requests it.
-fn closeWithConfirmation(tab: *Tab) void {
+pub fn closeWithConfirmation(tab: *Tab) void {
     switch (tab.elem) {
         .surface => |s| s.close(s.core_surface.needsConfirmQuit()),
         .split => |s| {
@@ -169,21 +169,15 @@ fn closeWithConfirmation(tab: *Tab) void {
     }
 }
 
-pub fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
-    const tab: *Tab = @ptrCast(@alignCast(ud));
-    tab.closeWithConfirmation();
-}
-
 fn gtkTabCloseConfirmation(
     alert: *c.GtkMessageDialog,
     response: c.gint,
     ud: ?*anyopaque,
 ) callconv(.C) void {
+    const tab: *Tab = @ptrCast(@alignCast(ud));
     c.gtk_window_destroy(@ptrCast(alert));
-    if (response == c.GTK_RESPONSE_YES) {
-        const tab: *Tab = @ptrCast(@alignCast(ud));
-        tab.remove();
-    }
+    if (response != c.GTK_RESPONSE_YES) return;
+    tab.remove();
 }
 
 fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
@@ -194,17 +188,3 @@ fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     const tab: *Tab = @ptrCast(@alignCast(ud));
     tab.destroy(tab.window.app.core_app.alloc);
 }
-
-pub fn gtkTabClick(
-    gesture: *c.GtkGestureClick,
-    _: c.gint,
-    _: c.gdouble,
-    _: c.gdouble,
-    ud: ?*anyopaque,
-) callconv(.C) void {
-    const self: *Tab = @ptrCast(@alignCast(ud));
-    const gtk_button = c.gtk_gesture_single_get_current_button(@ptrCast(gesture));
-    if (gtk_button == c.GDK_BUTTON_MIDDLE) {
-        self.closeWithConfirmation();
-    }
-}

commit b3f994a9d2e30fd9f5f3c0c12038d55551b13a6b
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Wed Feb 12 22:19:03 2025 -0600

    gtk: use builder ui files and popovers for menus

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index d320daa7..21492879 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -108,8 +108,8 @@ pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     self.elem = elem;
 }
 
-pub fn setLabelText(self: *Tab, title: [:0]const u8) void {
-    self.window.notebook.setTabLabel(self, title);
+pub fn setTitleText(self: *Tab, title: [:0]const u8) void {
+    self.window.notebook.setTabTitle(self, title);
 }
 
 pub fn setTooltipText(self: *Tab, tooltip: [:0]const u8) void {

commit 23d2d4ec7010c72edc854b4cc472aad08d10abec
Author: Leah Amelia Chen <hi@pluie.me>
Date:   Thu Feb 13 13:45:32 2025 +0100

    gtk: use AdwAlertDialog for close dialogs

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 21492879..78a6253d 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -13,6 +13,8 @@ const CoreSurface = @import("../../Surface.zig");
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
 const c = @import("c.zig").c;
+const adwaita = @import("adwaita.zig");
+const CloseDialog = @import("CloseDialog.zig");
 
 const log = std.log.scoped(.gtk);
 
@@ -132,54 +134,23 @@ fn needsConfirm(elem: Surface.Container.Elem) bool {
 /// Close the tab, asking for confirmation if any surface requests it.
 pub fn closeWithConfirmation(tab: *Tab) void {
     switch (tab.elem) {
-        .surface => |s| s.close(s.core_surface.needsConfirmQuit()),
+        .surface => |s| s.closeWithConfirmation(
+            s.core_surface.needsConfirmQuit(),
+            .{ .tab = tab },
+        ),
         .split => |s| {
-            if (needsConfirm(s.top_left) or needsConfirm(s.bottom_right)) {
-                const alert = c.gtk_message_dialog_new(
-                    tab.window.window,
-                    c.GTK_DIALOG_MODAL,
-                    c.GTK_MESSAGE_QUESTION,
-                    c.GTK_BUTTONS_YES_NO,
-                    "Close this tab?",
-                );
-                c.gtk_message_dialog_format_secondary_text(
-                    @ptrCast(alert),
-                    "All terminal sessions in this tab will be terminated.",
-                );
-
-                // We want the "yes" to appear destructive.
-                const yes_widget = c.gtk_dialog_get_widget_for_response(
-                    @ptrCast(alert),
-                    c.GTK_RESPONSE_YES,
-                );
-                c.gtk_widget_add_css_class(yes_widget, "destructive-action");
-
-                // We want the "no" to be the default action
-                c.gtk_dialog_set_default_response(
-                    @ptrCast(alert),
-                    c.GTK_RESPONSE_NO,
-                );
-
-                _ = c.g_signal_connect_data(alert, "response", c.G_CALLBACK(&gtkTabCloseConfirmation), tab, null, c.G_CONNECT_DEFAULT);
-                c.gtk_widget_show(alert);
+            if (!needsConfirm(s.top_left) and !needsConfirm(s.bottom_right)) {
+                tab.remove();
                 return;
             }
-            tab.remove();
+
+            CloseDialog.show(.{ .tab = tab }) catch |err| {
+                log.err("failed to open close dialog={}", .{err});
+            };
         },
     }
 }
 
-fn gtkTabCloseConfirmation(
-    alert: *c.GtkMessageDialog,
-    response: c.gint,
-    ud: ?*anyopaque,
-) callconv(.C) void {
-    const tab: *Tab = @ptrCast(@alignCast(ud));
-    c.gtk_window_destroy(@ptrCast(alert));
-    if (response != c.GTK_RESPONSE_YES) return;
-    tab.remove();
-}
-
 fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
     _ = v;
     log.debug("tab box destroy", .{});

commit 572fc8b5d78310d86cda493b241bc17714f7d44b
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Sat Mar 8 23:19:16 2025 -0600

    gtk: convert Surface to zig-gobject

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 78a6253d..eecbf435 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -73,8 +73,9 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     surface.container = .{ .tab_ = self };
     self.elem = .{ .surface = surface };
 
+    // FIXME: when Tab.zig is converted to zig-gobject
     // Add Surface to the Tab
-    c.gtk_box_append(self.box, surface.primaryWidget());
+    c.gtk_box_append(self.box, @ptrCast(@alignCast(surface.primaryWidget())));
 
     // Set the userdata of the box to point to this tab.
     c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
@@ -103,10 +104,11 @@ pub fn destroy(self: *Tab, alloc: Allocator) void {
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     // Remove our previous widget
-    c.gtk_box_remove(self.box, self.elem.widget());
+    // FIXME: when Tab.zig is converted to zig-gobject
+    c.gtk_box_remove(self.box, @ptrCast(@alignCast(self.elem.widget())));
 
     // Add our new one
-    c.gtk_box_append(self.box, elem.widget());
+    c.gtk_box_append(self.box, @ptrCast(@alignCast(elem.widget())));
     self.elem = elem;
 }
 

commit 4b1d1e0ed41c3ecb924bfee390af217260d4f87f
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Fri Mar 14 19:37:42 2025 -0500

    gtk: update Tab to use zig-gobject

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index eecbf435..c86545f9 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -1,18 +1,21 @@
-/// The state associated with a single tab in the window.
-///
-/// A tab can contain one or more terminals due to splits.
+//! The state associated with a single tab in the window.
+//!
+//! A tab can contain one or more terminals due to splits.
 const Tab = @This();
 
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const assert = std.debug.assert;
+
+const gobject = @import("gobject");
+const gtk = @import("gtk");
+
 const font = @import("../../font/main.zig");
 const input = @import("../../input.zig");
 const CoreSurface = @import("../../Surface.zig");
 
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
-const c = @import("c.zig").c;
 const adwaita = @import("adwaita.zig");
 const CloseDialog = @import("CloseDialog.zig");
 
@@ -24,12 +27,12 @@ pub const GHOSTTY_TAB = "ghostty_tab";
 window: *Window,
 
 /// The tab label. The tab label is the text that appears on the tab.
-label_text: *c.GtkLabel,
+label_text: *gtk.Label,
 
 /// We'll put our children into this box instead of packing them
 /// directly, so that we can send the box into `c.g_signal_connect_data`
 /// for the close button
-box: *c.GtkBox,
+box: *gtk.Box,
 
 /// The element of this tab so that we can handle splits and so on.
 elem: Surface.Container.Elem,
@@ -46,8 +49,8 @@ pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     return tab;
 }
 
-/// Initialize the tab, create a surface, and add it to the window. "self"
-/// needs to be a stable pointer, since it is used for GTK events.
+/// Initialize the tab, create a surface, and add it to the window. "self" needs
+/// to be a stable pointer, since it is used for GTK events.
 pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.* = .{
         .window = window,
@@ -57,13 +60,14 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .focus_child = null,
     };
 
-    // Create a Box in which we'll later keep either Surface or Split.
-    // Using a box makes it easier to maintain the tab contents because
-    // we never need to change the root widget of the notebook page (tab).
-    const box_widget = c.gtk_box_new(c.GTK_ORIENTATION_VERTICAL, 0);
-    c.gtk_widget_set_hexpand(box_widget, 1);
-    c.gtk_widget_set_vexpand(box_widget, 1);
-    self.box = @ptrCast(box_widget);
+    // Create a Box in which we'll later keep either Surface or Split. Using a
+    // box makes it easier to maintain the tab contents because we never need to
+    // change the root widget of the notebook page (tab).
+    const box = gtk.Box.new(.vertical, 0);
+    const box_widget = box.as(gtk.Widget);
+    box_widget.setHexpand(1);
+    box_widget.setVexpand(1);
+    self.box = box;
 
     // Create the initial surface since all tabs start as a single non-split
     var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
@@ -73,16 +77,21 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     surface.container = .{ .tab_ = self };
     self.elem = .{ .surface = surface };
 
-    // FIXME: when Tab.zig is converted to zig-gobject
     // Add Surface to the Tab
-    c.gtk_box_append(self.box, @ptrCast(@alignCast(surface.primaryWidget())));
+    self.box.append(surface.primaryWidget());
 
     // Set the userdata of the box to point to this tab.
-    c.g_object_set_data(@ptrCast(box_widget), GHOSTTY_TAB, self);
+    self.box.as(gobject.Object).setData(GHOSTTY_TAB, self);
     window.notebook.addTab(self, "Ghostty");
 
     // Attach all events
-    _ = c.g_signal_connect_data(box_widget, "destroy", c.G_CALLBACK(&gtkDestroy), self, null, c.G_CONNECT_DEFAULT);
+    _ = gtk.Widget.signals.destroy.connect(
+        self.box,
+        *Tab,
+        gtkDestroy,
+        self,
+        .{},
+    );
 
     // We need to grab focus after Surface and Tab is added to the window. When
     // creating a Tab we want to always focus on the widget.
@@ -104,11 +113,10 @@ pub fn destroy(self: *Tab, alloc: Allocator) void {
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     // Remove our previous widget
-    // FIXME: when Tab.zig is converted to zig-gobject
-    c.gtk_box_remove(self.box, @ptrCast(@alignCast(self.elem.widget())));
+    self.box.remove(self.elem.widget());
 
     // Add our new one
-    c.gtk_box_append(self.box, @ptrCast(@alignCast(elem.widget())));
+    self.box.append(elem.widget());
     self.elem = elem;
 }
 
@@ -153,11 +161,11 @@ pub fn closeWithConfirmation(tab: *Tab) void {
     }
 }
 
-fn gtkDestroy(v: *c.GtkWidget, ud: ?*anyopaque) callconv(.C) void {
-    _ = v;
+fn gtkDestroy(_: *gtk.Box, self: *Tab) callconv(.C) void {
     log.debug("tab box destroy", .{});
 
+    const alloc = self.window.app.core_app.alloc;
+
     // When our box is destroyed, we want to destroy our tab, too.
-    const tab: *Tab = @ptrCast(@alignCast(ud));
-    tab.destroy(tab.window.app.core_app.alloc);
+    self.destroy(alloc);
 }

commit 946c0c370fef1058016ddf8db8d5edfb9e0e30f8
Author: Gregory Anders <greg@gpanders.com>
Date:   Tue Mar 18 10:12:19 2025 -0500

    Update Adwaita version check for Box unref
    
    As of Adwaita 1.5.0, the GTK Box is not being properly unref'd when the
    parent window is closed. Update the conditional to account for this.
    
    Also add a couple of missing unref()s in errdefers.

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index c86545f9..9d78abb9 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -64,6 +64,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     // box makes it easier to maintain the tab contents because we never need to
     // change the root widget of the notebook page (tab).
     const box = gtk.Box.new(.vertical, 0);
+    errdefer box.unref();
     const box_widget = box.as(gtk.Widget);
     box_widget.setHexpand(1);
     box_widget.setVexpand(1);

commit 5bf10dce1253b948dfb7771797c95c46d8c6a4a1
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Tue Mar 18 14:14:50 2025 -0500

    c804cd3dbb0274f3271736e0b8f279795bdff394

diff --git a/src/apprt/gtk/Tab.zig b/src/apprt/gtk/Tab.zig
index 9d78abb9..57a9644d 100644
--- a/src/apprt/gtk/Tab.zig
+++ b/src/apprt/gtk/Tab.zig
@@ -16,7 +16,6 @@ const CoreSurface = @import("../../Surface.zig");
 
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
-const adwaita = @import("adwaita.zig");
 const CloseDialog = @import("CloseDialog.zig");
 
 const log = std.log.scoped(.gtk);

