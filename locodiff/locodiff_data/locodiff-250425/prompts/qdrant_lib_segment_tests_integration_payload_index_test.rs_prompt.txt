# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/tests/integration/payload_index_test.rs

commit 79e6a2ae2ef8f02b328b5899750e218df63090b7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Jun 7 08:46:49 2023 +0200

    merge integration binaries (segment) (#2033)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
new file mode 100644
index 000000000..68f5934ef
--- /dev/null
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -0,0 +1,679 @@
+use std::collections::HashMap;
+use std::path::Path;
+
+use itertools::Itertools;
+use rand::prelude::StdRng;
+use rand::{Rng, SeedableRng};
+use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
+use segment::entry::entry_point::SegmentEntry;
+use segment::fixtures::payload_fixtures::{
+    generate_diverse_nested_payload, generate_diverse_payload, random_filter, random_nested_filter,
+    random_vector, FLICKING_KEY, GEO_KEY, INT_KEY, INT_KEY_2, LAT_RANGE, LON_RANGE, STR_KEY,
+    STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
+};
+use segment::index::field_index::PrimaryCondition;
+use segment::index::PayloadIndex;
+use segment::segment::Segment;
+use segment::segment_constructor::build_segment;
+use segment::types::{
+    Condition, Distance, FieldCondition, Filter, GeoPoint, GeoRadius, Indexes, IsEmptyCondition,
+    Payload, PayloadField, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
+    VectorStorageType, WithPayload,
+};
+use tempfile::Builder;
+
+use crate::utils::scored_point_ties::ScoredPointTies;
+
+fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
+    let mut rnd = StdRng::seed_from_u64(42);
+    let dim = 5;
+
+    let config = SegmentConfig {
+        vector_data: HashMap::from([(
+            DEFAULT_VECTOR_NAME.to_owned(),
+            VectorDataConfig {
+                size: dim,
+                distance: Distance::Dot,
+                storage_type: VectorStorageType::Memory,
+                index: Indexes::Plain {},
+                quantization_config: None,
+            },
+        )]),
+        payload_storage_type: Default::default(),
+    };
+
+    let mut plain_segment = build_segment(path_plain, &config, true).unwrap();
+    let mut struct_segment = build_segment(path_struct, &config, true).unwrap();
+
+    let num_points = 3000;
+    let points_to_delete = 500;
+    let points_to_clear = 500;
+
+    let mut opnum = 0;
+    struct_segment
+        .create_field_index(opnum, INT_KEY_2, Some(&PayloadSchemaType::Integer.into()))
+        .unwrap();
+
+    opnum += 1;
+    for n in 0..num_points {
+        let idx = n.into();
+        let vector = random_vector(&mut rnd, dim);
+        let payload: Payload = generate_diverse_payload(&mut rnd);
+
+        plain_segment
+            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .unwrap();
+        struct_segment
+            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .unwrap();
+        plain_segment
+            .set_full_payload(opnum, idx, &payload)
+            .unwrap();
+        struct_segment
+            .set_full_payload(opnum, idx, &payload)
+            .unwrap();
+
+        opnum += 1;
+    }
+
+    struct_segment
+        .create_field_index(opnum, STR_KEY, Some(&PayloadSchemaType::Keyword.into()))
+        .unwrap();
+    struct_segment
+        .create_field_index(opnum, INT_KEY, None)
+        .unwrap();
+    struct_segment
+        .create_field_index(opnum, GEO_KEY, Some(&PayloadSchemaType::Geo.into()))
+        .unwrap();
+    struct_segment
+        .create_field_index(opnum, TEXT_KEY, Some(&PayloadSchemaType::Text.into()))
+        .unwrap();
+    struct_segment
+        .create_field_index(
+            opnum,
+            FLICKING_KEY,
+            Some(&PayloadSchemaType::Integer.into()),
+        )
+        .unwrap();
+
+    for _ in 0..points_to_clear {
+        opnum += 1;
+        let idx_to_remove = rnd.gen_range(0..num_points);
+        plain_segment
+            .clear_payload(opnum, idx_to_remove.into())
+            .unwrap();
+        struct_segment
+            .clear_payload(opnum, idx_to_remove.into())
+            .unwrap();
+    }
+
+    for _ in 0..points_to_delete {
+        opnum += 1;
+        let idx_to_remove = rnd.gen_range(0..num_points);
+        plain_segment
+            .delete_point(opnum, idx_to_remove.into())
+            .unwrap();
+        struct_segment
+            .delete_point(opnum, idx_to_remove.into())
+            .unwrap();
+    }
+
+    for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
+        for index in indexes {
+            assert!(index.indexed_points() < num_points as usize);
+            if field != FLICKING_KEY {
+                assert!(
+                    index.indexed_points()
+                        > (num_points as usize - points_to_delete - points_to_clear)
+                );
+            }
+        }
+    }
+
+    (struct_segment, plain_segment)
+}
+
+fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
+    let mut rnd = StdRng::seed_from_u64(42);
+    let dim = 5;
+
+    let config = SegmentConfig {
+        vector_data: HashMap::from([(
+            DEFAULT_VECTOR_NAME.to_owned(),
+            VectorDataConfig {
+                size: dim,
+                distance: Distance::Dot,
+                storage_type: VectorStorageType::Memory,
+                index: Indexes::Plain {},
+                quantization_config: None,
+            },
+        )]),
+        payload_storage_type: Default::default(),
+    };
+
+    let mut plain_segment = build_segment(path_plain, &config, true).unwrap();
+    let mut struct_segment = build_segment(path_struct, &config, true).unwrap();
+
+    let num_points = 3000;
+    let points_to_delete = 500;
+    let points_to_clear = 500;
+
+    // Nested payload keys
+    let nested_str_key = format!("{}.{}.{}", STR_KEY, "nested_1", "nested_2");
+    let nested_str_proj_key = format!("{}.{}[].{}", STR_PROJ_KEY, "nested_1", "nested_2");
+    let deep_nested_str_proj_key =
+        format!("{}[].{}[].{}", STR_ROOT_PROJ_KEY, "nested_1", "nested_2");
+
+    let mut opnum = 0;
+    struct_segment
+        .create_field_index(
+            opnum,
+            &nested_str_key,
+            Some(&PayloadSchemaType::Keyword.into()),
+        )
+        .unwrap();
+
+    struct_segment
+        .create_field_index(
+            opnum,
+            &nested_str_proj_key,
+            Some(&PayloadSchemaType::Keyword.into()),
+        )
+        .unwrap();
+
+    struct_segment
+        .create_field_index(
+            opnum,
+            &deep_nested_str_proj_key,
+            Some(&PayloadSchemaType::Keyword.into()),
+        )
+        .unwrap();
+
+    eprintln!("{}", deep_nested_str_proj_key);
+
+    opnum += 1;
+    for n in 0..num_points {
+        let idx = n.into();
+        let vector = random_vector(&mut rnd, dim);
+        let payload: Payload = generate_diverse_nested_payload(&mut rnd);
+
+        plain_segment
+            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .unwrap();
+        struct_segment
+            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .unwrap();
+        plain_segment
+            .set_full_payload(opnum, idx, &payload)
+            .unwrap();
+        struct_segment
+            .set_full_payload(opnum, idx, &payload)
+            .unwrap();
+
+        opnum += 1;
+    }
+
+    for _ in 0..points_to_clear {
+        opnum += 1;
+        let idx_to_remove = rnd.gen_range(0..num_points);
+        plain_segment
+            .clear_payload(opnum, idx_to_remove.into())
+            .unwrap();
+        struct_segment
+            .clear_payload(opnum, idx_to_remove.into())
+            .unwrap();
+    }
+
+    for _ in 0..points_to_delete {
+        opnum += 1;
+        let idx_to_remove = rnd.gen_range(0..num_points);
+        plain_segment
+            .delete_point(opnum, idx_to_remove.into())
+            .unwrap();
+        struct_segment
+            .delete_point(opnum, idx_to_remove.into())
+            .unwrap();
+    }
+
+    for (_field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
+        for index in indexes {
+            assert!(index.indexed_points() < num_points as usize);
+            assert!(
+                index.indexed_points() > (num_points as usize - points_to_delete - points_to_clear)
+            );
+        }
+    }
+
+    (struct_segment, plain_segment)
+}
+
+#[test]
+fn test_is_empty_conditions() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+
+    let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+        is_empty: PayloadField {
+            key: "flicking".to_string(),
+        },
+    }));
+
+    let estimation_struct = struct_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    let estimation_plain = plain_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    let real_number = plain_segment
+        .payload_index
+        .borrow()
+        .query_points(&filter)
+        .count();
+
+    eprintln!("estimation_plain = {estimation_plain:#?}");
+    eprintln!("estimation_struct = {estimation_struct:#?}");
+    eprintln!("real_number = {real_number:#?}");
+
+    assert!(estimation_plain.max >= real_number);
+    assert!(estimation_plain.min <= real_number);
+
+    assert!(estimation_struct.max >= real_number);
+    assert!(estimation_struct.min <= real_number);
+
+    assert!(
+        (estimation_struct.exp as f64 - real_number as f64).abs()
+            <= (estimation_plain.exp as f64 - real_number as f64).abs()
+    );
+}
+
+#[test]
+fn test_cardinality_estimation() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
+
+    let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
+        INT_KEY.to_owned(),
+        Range {
+            lt: None,
+            gt: None,
+            gte: Some(50.),
+            lte: Some(100.),
+        },
+    )));
+
+    let estimation = struct_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    let payload_index = struct_segment.payload_index.borrow();
+    let filter_context = payload_index.filter_context(&filter);
+    let exact = struct_segment
+        .id_tracker
+        .borrow()
+        .iter_ids()
+        .filter(|x| filter_context.check(*x))
+        .collect_vec()
+        .len();
+
+    eprintln!("exact = {exact:#?}");
+    eprintln!("estimation = {estimation:#?}");
+
+    assert!(exact <= estimation.max);
+    assert!(exact >= estimation.min);
+}
+
+#[test]
+fn test_root_nested_array_filter_cardinality_estimation() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, _) = build_test_segments_nested_payload(dir1.path(), dir2.path());
+
+    // rely on test data from `build_test_segments_nested_payload`
+    let nested_key = "nested_1[].nested_2";
+    let nested_match =
+        FieldCondition::new_match(nested_key.to_owned(), "some value".to_owned().into());
+    let filter = Filter::new_must(Condition::new_nested(
+        STR_ROOT_PROJ_KEY.to_string(),
+        Filter::new_must(Condition::Field(nested_match)),
+    ));
+
+    let estimation = struct_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    // not empty primary clauses
+    assert_eq!(estimation.primary_clauses.len(), 1);
+    eprintln!("primary_clauses = {:#?}", estimation.primary_clauses);
+    let primary_clause = estimation.primary_clauses.first().unwrap();
+
+    let expected_primary_clause = FieldCondition::new_match(
+        format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key), // full key expected
+        "some value".to_owned().into(),
+    );
+
+    match primary_clause {
+        PrimaryCondition::Condition(field_condition) => {
+            assert_eq!(field_condition, &expected_primary_clause);
+        }
+        o => panic!("unexpected primary clause: {:?}", o),
+    }
+
+    let payload_index = struct_segment.payload_index.borrow();
+    let filter_context = payload_index.filter_context(&filter);
+    let exact = struct_segment
+        .id_tracker
+        .borrow()
+        .iter_ids()
+        .filter(|x| filter_context.check(*x))
+        .collect_vec()
+        .len();
+
+    eprintln!("exact = {exact:#?}");
+    eprintln!("estimation = {estimation:#?}");
+
+    assert!(exact <= estimation.max);
+    assert!(exact >= estimation.min);
+}
+
+#[test]
+fn test_nesting_nested_array_filter_cardinality_estimation() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, _) = build_test_segments_nested_payload(dir1.path(), dir2.path());
+
+    // rely on test data from `build_test_segments_nested_payload`
+    let nested_match_key = "nested_2";
+    let nested_match =
+        FieldCondition::new_match(nested_match_key.to_owned(), "some value".to_owned().into());
+    let filter = Filter::new_must(Condition::new_nested(
+        STR_ROOT_PROJ_KEY.to_string(),
+        Filter::new_must(Condition::new_nested(
+            "nested_1".to_string(),
+            Filter::new_must(Condition::Field(nested_match)),
+        )),
+    ));
+
+    let estimation = struct_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    // not empty primary clauses
+    assert_eq!(estimation.primary_clauses.len(), 1);
+    eprintln!("primary_clauses = {:#?}", estimation.primary_clauses);
+    let primary_clause = estimation.primary_clauses.first().unwrap();
+
+    let expected_primary_clause = FieldCondition::new_match(
+        format!("{}[].nested_1[].{}", STR_ROOT_PROJ_KEY, nested_match_key), // full key expected
+        "some value".to_owned().into(),
+    );
+
+    match primary_clause {
+        PrimaryCondition::Condition(field_condition) => {
+            assert_eq!(field_condition, &expected_primary_clause);
+        }
+        o => panic!("unexpected primary clause: {:?}", o),
+    }
+
+    let payload_index = struct_segment.payload_index.borrow();
+    let filter_context = payload_index.filter_context(&filter);
+    let exact = struct_segment
+        .id_tracker
+        .borrow()
+        .iter_ids()
+        .filter(|x| filter_context.check(*x))
+        .collect_vec()
+        .len();
+
+    eprintln!("exact = {exact:#?}");
+    eprintln!("estimation = {estimation:#?}");
+
+    assert!(exact <= estimation.max);
+    assert!(exact >= estimation.min);
+}
+
+#[test]
+fn test_struct_payload_index() {
+    // Compare search with plain and struct indexes
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let dim = 5;
+
+    let mut rnd = rand::thread_rng();
+
+    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+
+    let attempts = 100;
+    for _i in 0..attempts {
+        let query_vector = random_vector(&mut rnd, dim);
+        let query_filter = random_filter(&mut rnd, 3);
+
+        let plain_result = plain_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+        let struct_result = struct_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = struct_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        // Perform additional sort to break ties by score
+        let mut plain_result_sorted_ties: Vec<ScoredPointTies> =
+            plain_result.iter().map(|x| x.clone().into()).collect_vec();
+        plain_result_sorted_ties.sort();
+
+        let mut struct_result_sorted_ties: Vec<ScoredPointTies> =
+            struct_result.iter().map(|x| x.clone().into()).collect_vec();
+        struct_result_sorted_ties.sort();
+
+        plain_result_sorted_ties
+                .into_iter()
+                .zip(struct_result_sorted_ties.into_iter())
+                .map(|(r1, r2)| (r1.scored_point, r2.scored_point))
+                .for_each(|(r1, r2)| {
+                    assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
+                    assert!((r1.score - r2.score) < 0.0001)
+                });
+    }
+}
+
+#[test]
+fn test_struct_payload_geo_index() {
+    // Compare search with plain and struct indexes
+    let mut rnd = rand::thread_rng();
+
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let dim = 5;
+
+    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+
+    let attempts = 100;
+    for _i in 0..attempts {
+        let query_vector = random_vector(&mut rnd, dim);
+        let r_meters = rnd.gen_range(1.0..10000.0);
+        let geo_radius = GeoRadius {
+            center: GeoPoint {
+                lon: rnd.gen_range(LON_RANGE),
+                lat: rnd.gen_range(LAT_RANGE),
+            },
+            radius: r_meters,
+        };
+
+        let condition = Condition::Field(FieldCondition::new_geo_radius(
+            "geo_key".to_string(),
+            geo_radius,
+        ));
+
+        let query_filter = Filter {
+            should: None,
+            must: Some(vec![condition]),
+            must_not: None,
+        };
+
+        let plain_result = plain_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = plain_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        let struct_result = struct_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = struct_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        plain_result
+            .iter()
+            .zip(struct_result.iter())
+            .for_each(|(r1, r2)| {
+                assert_eq!(r1.id, r2.id);
+                assert!((r1.score - r2.score) < 0.0001)
+            });
+    }
+}
+
+#[test]
+fn test_struct_payload_index_nested_fields() {
+    // Compare search with plain and struct indexes
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let dim = 5;
+
+    let mut rnd = rand::thread_rng();
+
+    let (struct_segment, plain_segment) =
+        build_test_segments_nested_payload(dir1.path(), dir2.path());
+
+    let attempts = 100;
+    for _i in 0..attempts {
+        let query_vector = random_vector(&mut rnd, dim);
+        let query_filter = random_nested_filter(&mut rnd);
+        let plain_result = plain_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload {
+                    enable: true,
+                    payload_selector: None,
+                },
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+        let struct_result = struct_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload {
+                    enable: true,
+                    payload_selector: None,
+                },
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = struct_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        // warning: report flakiness at https://github.com/qdrant/qdrant/issues/534
+        plain_result
+                .iter()
+                .zip(struct_result.iter())
+                .for_each(|(r1, r2)| {
+                    assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
+                    assert!((r1.score - r2.score) < 0.0001)
+                });
+    }
+}

commit ab7ab03a327aab401f11e858bb8df400e52b809d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jun 9 00:05:00 2023 +0200

    Fix batch request with duplicated filter (#2051)
    
    * fix double usage of iterator
    
    * tests

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 68f5934ef..bcf89de39 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -274,7 +274,7 @@ fn test_is_empty_conditions() {
         .payload_index
         .borrow()
         .query_points(&filter)
-        .count();
+        .len();
 
     eprintln!("estimation_plain = {estimation_plain:#?}");
     eprintln!("estimation_struct = {estimation_struct:#?}");

commit 4016aa6af5186c679649967d58df1eef1e43d104
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Jun 14 13:56:16 2023 -0400

    Optimize `is_empty` (#2073)
    
    * optimize is_empty condition for hitting index
    
    * Optimize is_null too, simplify checker
    
    * refactor: introduce values_is_empty() for indexes
    - use `.then()` instead of `&&`
    
    * cargo fmt
    
    * improve comments
    
    * Revert "Optimize is_null too, simplify checker"
    
    This reverts commit b9ebfe5ff28319090194cd5eb88a399b8f607fbf.
    
    * changes from review
    
    * update `test_is_empty_conditions` test for comparing indexed vs not indexed results

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index bcf89de39..1ce3a3b9e 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -256,7 +256,7 @@ fn test_is_empty_conditions() {
 
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
-            key: "flicking".to_string(),
+            key: FLICKING_KEY.to_string(),
         },
     }));
 
@@ -270,11 +270,13 @@ fn test_is_empty_conditions() {
         .borrow()
         .estimate_cardinality(&filter);
 
-    let real_number = plain_segment
-        .payload_index
-        .borrow()
-        .query_points(&filter)
-        .len();
+    let plain_result = plain_segment.payload_index.borrow().query_points(&filter);
+
+    let real_number = plain_result.len();
+
+    let struct_result = struct_segment.payload_index.borrow().query_points(&filter);
+
+    assert_eq!(plain_result, struct_result);
 
     eprintln!("estimation_plain = {estimation_plain:#?}");
     eprintln!("estimation_struct = {estimation_struct:#?}");

commit 396714f7faa04ac6a64d63c784adfda25d468737
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Jul 5 00:30:15 2023 +0200

    Add missed vector preprocess (#2203)
    
    * test missed preprocess after segment update
    
    * missed preprocess
    
    * remove preprocess_named_vectors fn
    
    * are you happy clippy
    
    * fix integration tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 1ce3a3b9e..a0b74dafd 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -61,10 +61,10 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
         let payload: Payload = generate_diverse_payload(&mut rnd);
 
         plain_segment
-            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector))
             .unwrap();
         struct_segment
-            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector))
             .unwrap();
         plain_segment
             .set_full_payload(opnum, idx, &payload)
@@ -198,10 +198,10 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         let payload: Payload = generate_diverse_nested_payload(&mut rnd);
 
         plain_segment
-            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector))
             .unwrap();
         struct_segment
-            .upsert_point(opnum, idx, &only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector))
             .unwrap();
         plain_segment
             .set_full_payload(opnum, idx, &payload)

commit 7044bf8e038d9676378d93dac484e1c2bacc0ffe
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jul 10 11:24:14 2023 +0200

    Fix set payload index to handle type change (#2235)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index a0b74dafd..442c43a39 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1,25 +1,34 @@
 use std::collections::HashMap;
 use std::path::Path;
+use std::sync::Arc;
 
+use atomic_refcell::AtomicRefCell;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
+use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::fixtures::payload_fixtures::{
     generate_diverse_nested_payload, generate_diverse_payload, random_filter, random_nested_filter,
     random_vector, FLICKING_KEY, GEO_KEY, INT_KEY, INT_KEY_2, LAT_RANGE, LON_RANGE, STR_KEY,
     STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
 };
 use segment::index::field_index::PrimaryCondition;
+use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::PayloadIndex;
+use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
+use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
 use segment::segment_constructor::build_segment;
+use segment::types::PayloadFieldSchema::FieldType;
+use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     Condition, Distance, FieldCondition, Filter, GeoPoint, GeoRadius, Indexes, IsEmptyCondition,
-    Payload, PayloadField, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
-    VectorStorageType, WithPayload,
+    Payload, PayloadField, PayloadSchemaType, PointOffsetType, Range, SegmentConfig,
+    VectorDataConfig, VectorStorageType, WithPayload,
 };
+use serde_json::json;
 use tempfile::Builder;
 
 use crate::utils::scored_point_ties::ScoredPointTies;
@@ -679,3 +688,62 @@ fn test_struct_payload_index_nested_fields() {
                 });
     }
 }
+
+#[test]
+fn test_update_payload_index_type() {
+    let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let mut payload_storage = InMemoryPayloadStorage::default();
+
+    let point_num = 10;
+    let mut points = HashMap::new();
+
+    let mut payloads: Vec<Payload> = vec![];
+    for i in 0..point_num {
+        let payload = json!({
+            "field": i,
+        });
+        payloads.push(payload.into());
+    }
+
+    for (idx, payload) in payloads.into_iter().enumerate() {
+        points.insert(idx, payload.clone());
+        payload_storage
+            .assign(idx as PointOffsetType, &payload)
+            .unwrap();
+    }
+
+    let wrapped_payload_storage = Arc::new(AtomicRefCell::new(payload_storage.into()));
+    let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(point_num)));
+
+    let mut index =
+        StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path()).unwrap();
+
+    // set field to Integer type
+    index.set_indexed("field", Integer.into()).unwrap();
+    assert_eq!(
+        *index.indexed_fields().get("field").unwrap(),
+        FieldType(Integer)
+    );
+    let field_index = index.field_indexes.get("field").unwrap();
+    assert_eq!(field_index[0].count_indexed_points(), point_num);
+    assert_eq!(field_index[1].count_indexed_points(), point_num);
+
+    // update field to Keyword type
+    index.set_indexed("field", Keyword.into()).unwrap();
+    assert_eq!(
+        *index.indexed_fields().get("field").unwrap(),
+        FieldType(Keyword)
+    );
+    let field_index = index.field_indexes.get("field").unwrap();
+    assert_eq!(field_index[0].count_indexed_points(), 0); // only one field index for Keyword
+
+    // set field to Integer type (again)
+    index.set_indexed("field", Integer.into()).unwrap();
+    assert_eq!(
+        *index.indexed_fields().get("field").unwrap(),
+        FieldType(Integer)
+    );
+    let field_index = index.field_indexes.get("field").unwrap();
+    assert_eq!(field_index[0].count_indexed_points(), point_num);
+    assert_eq!(field_index[1].count_indexed_points(), point_num);
+}

commit 0d9542b7114c68094cb1c5f4eb25e795e44f1ef9
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Jul 3 13:25:54 2023 -0400

    Small refactor: remove duplicated `indexed_points()` function (#2103)
    
    * remove duplicated `indexed_points()` function
    
    * update for binary index

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 442c43a39..0785bb7eb 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -129,10 +129,10 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
     for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
         for index in indexes {
-            assert!(index.indexed_points() < num_points as usize);
+            assert!(index.count_indexed_points() < num_points as usize);
             if field != FLICKING_KEY {
                 assert!(
-                    index.indexed_points()
+                    index.count_indexed_points()
                         > (num_points as usize - points_to_delete - points_to_clear)
                 );
             }
@@ -246,9 +246,10 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
     for (_field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
         for index in indexes {
-            assert!(index.indexed_points() < num_points as usize);
+            assert!(index.count_indexed_points() < num_points as usize);
             assert!(
-                index.indexed_points() > (num_points as usize - points_to_delete - points_to_clear)
+                index.count_indexed_points()
+                    > (num_points as usize - points_to_delete - points_to_clear)
             );
         }
     }

commit bd40a58e65e58ba5cfea79be5603faf88dc62248
Author: Zein Wen <85084498+zzzz-vincent@users.noreply.github.com>
Date:   Mon Jul 17 03:36:50 2023 -0700

    Add geo_polygon filter to proto interface, complete conversion fn, and add an integration test (#2188)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 0785bb7eb..72c6c544a 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -24,24 +24,26 @@ use segment::segment_constructor::build_segment;
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
-    Condition, Distance, FieldCondition, Filter, GeoPoint, GeoRadius, Indexes, IsEmptyCondition,
-    Payload, PayloadField, PayloadSchemaType, PointOffsetType, Range, SegmentConfig,
-    VectorDataConfig, VectorStorageType, WithPayload,
+    Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoPoint, GeoPolygon, GeoRadius,
+    Indexes, IsEmptyCondition, Payload, PayloadField, PayloadSchemaType, PointOffsetType, Range,
+    SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
 };
 use serde_json::json;
 use tempfile::Builder;
 
 use crate::utils::scored_point_ties::ScoredPointTies;
 
+const DIM: usize = 5;
+const ATTEMPTS: usize = 100;
+
 fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
     let mut rnd = StdRng::seed_from_u64(42);
-    let dim = 5;
 
     let config = SegmentConfig {
         vector_data: HashMap::from([(
             DEFAULT_VECTOR_NAME.to_owned(),
             VectorDataConfig {
-                size: dim,
+                size: DIM,
                 distance: Distance::Dot,
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
@@ -66,7 +68,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     opnum += 1;
     for n in 0..num_points {
         let idx = n.into();
-        let vector = random_vector(&mut rnd, dim);
+        let vector = random_vector(&mut rnd, DIM);
         let payload: Payload = generate_diverse_payload(&mut rnd);
 
         plain_segment
@@ -144,13 +146,12 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
 fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
     let mut rnd = StdRng::seed_from_u64(42);
-    let dim = 5;
 
     let config = SegmentConfig {
         vector_data: HashMap::from([(
             DEFAULT_VECTOR_NAME.to_owned(),
             VectorDataConfig {
-                size: dim,
+                size: DIM,
                 distance: Distance::Dot,
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
@@ -203,7 +204,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
     opnum += 1;
     for n in 0..num_points {
         let idx = n.into();
-        let vector = random_vector(&mut rnd, dim);
+        let vector = random_vector(&mut rnd, DIM);
         let payload: Payload = generate_diverse_nested_payload(&mut rnd);
 
         plain_segment
@@ -257,6 +258,72 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
     (struct_segment, plain_segment)
 }
 
+fn validate_geo_filter(query_filter: Filter) {
+    let mut rnd = rand::thread_rng();
+    let query_vector = random_vector(&mut rnd, DIM);
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+
+    for _i in 0..ATTEMPTS {
+        let plain_result = plain_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = plain_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        let struct_result = struct_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+
+        let estimation = struct_segment
+            .payload_index
+            .borrow()
+            .estimate_cardinality(&query_filter);
+
+        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
+        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
+        assert!(
+            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            "{estimation:#?}",
+        );
+
+        plain_result
+            .iter()
+            .zip(struct_result.iter())
+            .for_each(|(r1, r2)| {
+                assert_eq!(r1.id, r2.id);
+                assert!((r1.score - r2.score) < 0.0001)
+            });
+    }
+}
+
 #[test]
 fn test_is_empty_conditions() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
@@ -462,15 +529,12 @@ fn test_struct_payload_index() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
     let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
 
-    let dim = 5;
-
     let mut rnd = rand::thread_rng();
 
     let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
 
-    let attempts = 100;
-    for _i in 0..attempts {
-        let query_vector = random_vector(&mut rnd, dim);
+    for _i in 0..ATTEMPTS {
+        let query_vector = random_vector(&mut rnd, DIM);
         let query_filter = random_filter(&mut rnd, 3);
 
         let plain_result = plain_segment
@@ -529,96 +593,75 @@ fn test_struct_payload_index() {
 }
 
 #[test]
-fn test_struct_payload_geo_index() {
-    // Compare search with plain and struct indexes
+fn test_struct_payload_geo_boundingbox_index() {
     let mut rnd = rand::thread_rng();
 
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+    let geo_bbox = GeoBoundingBox {
+        top_left: GeoPoint {
+            lon: rnd.gen_range(LON_RANGE),
+            lat: rnd.gen_range(LAT_RANGE),
+        },
+        bottom_right: GeoPoint {
+            lon: rnd.gen_range(LON_RANGE),
+            lat: rnd.gen_range(LAT_RANGE),
+        },
+    };
 
-    let dim = 5;
+    let condition = Condition::Field(FieldCondition::new_geo_bounding_box(
+        "geo_key".to_string(),
+        geo_bbox,
+    ));
 
-    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+    let query_filter = Filter::new_must(condition);
 
-    let attempts = 100;
-    for _i in 0..attempts {
-        let query_vector = random_vector(&mut rnd, dim);
-        let r_meters = rnd.gen_range(1.0..10000.0);
-        let geo_radius = GeoRadius {
-            center: GeoPoint {
-                lon: rnd.gen_range(LON_RANGE),
-                lat: rnd.gen_range(LAT_RANGE),
-            },
-            radius: r_meters,
-        };
+    validate_geo_filter(query_filter)
+}
 
-        let condition = Condition::Field(FieldCondition::new_geo_radius(
-            "geo_key".to_string(),
-            geo_radius,
-        ));
+#[test]
+fn test_struct_payload_geo_radius_index() {
+    let mut rnd = rand::thread_rng();
 
-        let query_filter = Filter {
-            should: None,
-            must: Some(vec![condition]),
-            must_not: None,
-        };
+    let r_meters = rnd.gen_range(1.0..10000.0);
+    let geo_radius = GeoRadius {
+        center: GeoPoint {
+            lon: rnd.gen_range(LON_RANGE),
+            lat: rnd.gen_range(LAT_RANGE),
+        },
+        radius: r_meters,
+    };
 
-        let plain_result = plain_segment
-            .search(
-                DEFAULT_VECTOR_NAME,
-                &query_vector,
-                &WithPayload::default(),
-                &false.into(),
-                Some(&query_filter),
-                5,
-                None,
-            )
-            .unwrap();
+    let condition = Condition::Field(FieldCondition::new_geo_radius(
+        "geo_key".to_string(),
+        geo_radius,
+    ));
 
-        let estimation = plain_segment
-            .payload_index
-            .borrow()
-            .estimate_cardinality(&query_filter);
+    let query_filter = Filter::new_must(condition);
 
-        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
-        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
-        assert!(
-            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
-            "{estimation:#?}",
-        );
+    validate_geo_filter(query_filter)
+}
 
-        let struct_result = struct_segment
-            .search(
-                DEFAULT_VECTOR_NAME,
-                &query_vector,
-                &WithPayload::default(),
-                &false.into(),
-                Some(&query_filter),
-                5,
-                None,
-            )
-            .unwrap();
+#[test]
+fn test_struct_payload_geo_polygon_index() {
+    let mut rnd = rand::thread_rng();
 
-        let estimation = struct_segment
-            .payload_index
-            .borrow()
-            .estimate_cardinality(&query_filter);
+    let polygon_edge = 5;
 
-        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
-        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
-        assert!(
-            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
-            "{estimation:#?}",
-        );
+    let points: Vec<GeoPoint> = (0..polygon_edge)
+        .map(|_| GeoPoint {
+            lon: rnd.gen_range(LON_RANGE),
+            lat: rnd.gen_range(LAT_RANGE),
+        })
+        .collect();
+    let geo_polygon = GeoPolygon { points };
 
-        plain_result
-            .iter()
-            .zip(struct_result.iter())
-            .for_each(|(r1, r2)| {
-                assert_eq!(r1.id, r2.id);
-                assert!((r1.score - r2.score) < 0.0001)
-            });
-    }
+    let condition = Condition::Field(FieldCondition::new_geo_polygon(
+        "geo_key".to_string(),
+        geo_polygon,
+    ));
+
+    let query_filter = Filter::new_must(condition);
+
+    validate_geo_filter(query_filter)
 }
 
 #[test]
@@ -627,8 +670,6 @@ fn test_struct_payload_index_nested_fields() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
     let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
 
-    let dim = 5;
-
     let mut rnd = rand::thread_rng();
 
     let (struct_segment, plain_segment) =
@@ -636,7 +677,7 @@ fn test_struct_payload_index_nested_fields() {
 
     let attempts = 100;
     for _i in 0..attempts {
-        let query_vector = random_vector(&mut rnd, dim);
+        let query_vector = random_vector(&mut rnd, DIM);
         let query_filter = random_nested_filter(&mut rnd);
         let plain_result = plain_segment
             .search(

commit 76f7d2fc68b124d3fe788900fd022b8daee0c60e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 24 12:45:33 2023 +0200

    Search timeout (#2293)
    
    * pass atomic bool from local shard to raw scorer
    
    * pass atomic bool from local shard to raw scorer
    
    * is_stopped in async scorer
    
    * fmt
    
    * is_stopped in quantized scorer
    
    * terminating scorer if stopped
    
    * enable timeout in local_shard
    
    * allow timeout configuration
    
    * use tokio spawn to ensure timeout handling if request is dropped
    
    * Revert "use tokio spawn to ensure timeout handling if request is dropped"
    
    This reverts commit 1068cf48d481b8856da41869b71b1f9a361f7e2d.
    
    * use stopping guard instead of task
    
    * report error if search request is stopped
    
    * fmt
    
    * refactor transient error handelling

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 72c6c544a..9a0393f9f 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -275,6 +275,7 @@ fn validate_geo_filter(query_filter: Filter) {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -299,6 +300,7 @@ fn validate_geo_filter(query_filter: Filter) {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -546,6 +548,7 @@ fn test_struct_payload_index() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
         let struct_result = struct_segment
@@ -557,6 +560,7 @@ fn test_struct_payload_index() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -691,6 +695,7 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
         let struct_result = struct_segment
@@ -705,6 +710,7 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 

commit 8ef51525235655112ab08adac644455d86a3d608
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Sep 4 15:24:52 2023 +0200

    immutable map index integration (#2524)
    
    * immutable map index integration
    
    * remove wipe
    
    * fix unit tests
    
    * get appendable flag from config
    
    * minor refactoring
    
    * fix chunked mmap appendable flag
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 9a0393f9f..b0500d4da 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -764,7 +764,7 @@ fn test_update_payload_index_type() {
     let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(point_num)));
 
     let mut index =
-        StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path()).unwrap();
+        StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path(), true).unwrap();
 
     // set field to Integer type
     index.set_indexed("field", Integer.into()).unwrap();

commit c8bdec7b0616c47e1c3057b3f8ef8435833dc74f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Sep 5 09:26:24 2023 -0300

    Refactor batch search to allow different scorers (#2529)
    
    * add enum for vector query on segment search
    
    * rename newly introduced types
    
    * fix: handle QueryVector on async scorer
    
    * handle QueryVector in QuantizedVectors impl
    
    * fix async scorer test after refactor
    
    * rebase + refactor on queue_proxy_shard.rs
    
    * constrain refactor propagation to segment_searcher
    
    * fmt
    
    * fix after rebase

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index b0500d4da..24d820d7d 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -260,7 +260,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
 fn validate_geo_filter(query_filter: Filter) {
     let mut rnd = rand::thread_rng();
-    let query_vector = random_vector(&mut rnd, DIM);
+    let query = random_vector(&mut rnd, DIM).into();
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
     let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
     let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
@@ -269,7 +269,7 @@ fn validate_geo_filter(query_filter: Filter) {
         let plain_result = plain_segment
             .search(
                 DEFAULT_VECTOR_NAME,
-                &query_vector,
+                &query,
                 &WithPayload::default(),
                 &false.into(),
                 Some(&query_filter),
@@ -294,7 +294,7 @@ fn validate_geo_filter(query_filter: Filter) {
         let struct_result = struct_segment
             .search(
                 DEFAULT_VECTOR_NAME,
-                &query_vector,
+                &query,
                 &WithPayload::default(),
                 &false.into(),
                 Some(&query_filter),
@@ -536,7 +536,7 @@ fn test_struct_payload_index() {
     let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
 
     for _i in 0..ATTEMPTS {
-        let query_vector = random_vector(&mut rnd, DIM);
+        let query_vector = random_vector(&mut rnd, DIM).into();
         let query_filter = random_filter(&mut rnd, 3);
 
         let plain_result = plain_segment
@@ -681,7 +681,7 @@ fn test_struct_payload_index_nested_fields() {
 
     let attempts = 100;
     for _i in 0..attempts {
-        let query_vector = random_vector(&mut rnd, DIM);
+        let query_vector = random_vector(&mut rnd, DIM).into();
         let query_filter = random_nested_filter(&mut rnd);
         let plain_result = plain_segment
             .search(

commit 1566d1cdc2eee6745d1f8944b46e9ddb8344807d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 21 19:42:03 2023 +0200

    Fix cardinality estimation for Any matcher (#2710)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 24d820d7d..11044c156 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -24,9 +24,9 @@ use segment::segment_constructor::build_segment;
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
-    Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoPoint, GeoPolygon, GeoRadius,
-    Indexes, IsEmptyCondition, Payload, PayloadField, PayloadSchemaType, PointOffsetType, Range,
-    SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
+    AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoPoint, GeoPolygon,
+    GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField, PayloadSchemaType,
+    PointOffsetType, Range, SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
 };
 use serde_json::json;
 use tempfile::Builder;
@@ -62,7 +62,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
     let mut opnum = 0;
     struct_segment
-        .create_field_index(opnum, INT_KEY_2, Some(&PayloadSchemaType::Integer.into()))
+        .create_field_index(opnum, INT_KEY_2, Some(&Integer.into()))
         .unwrap();
 
     opnum += 1;
@@ -88,7 +88,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     }
 
     struct_segment
-        .create_field_index(opnum, STR_KEY, Some(&PayloadSchemaType::Keyword.into()))
+        .create_field_index(opnum, STR_KEY, Some(&Keyword.into()))
         .unwrap();
     struct_segment
         .create_field_index(opnum, INT_KEY, None)
@@ -100,11 +100,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
         .create_field_index(opnum, TEXT_KEY, Some(&PayloadSchemaType::Text.into()))
         .unwrap();
     struct_segment
-        .create_field_index(
-            opnum,
-            FLICKING_KEY,
-            Some(&PayloadSchemaType::Integer.into()),
-        )
+        .create_field_index(opnum, FLICKING_KEY, Some(&Integer.into()))
         .unwrap();
 
     for _ in 0..points_to_clear {
@@ -176,27 +172,15 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
     let mut opnum = 0;
     struct_segment
-        .create_field_index(
-            opnum,
-            &nested_str_key,
-            Some(&PayloadSchemaType::Keyword.into()),
-        )
+        .create_field_index(opnum, &nested_str_key, Some(&Keyword.into()))
         .unwrap();
 
     struct_segment
-        .create_field_index(
-            opnum,
-            &nested_str_proj_key,
-            Some(&PayloadSchemaType::Keyword.into()),
-        )
+        .create_field_index(opnum, &nested_str_proj_key, Some(&Keyword.into()))
         .unwrap();
 
     struct_segment
-        .create_field_index(
-            opnum,
-            &deep_nested_str_proj_key,
-            Some(&PayloadSchemaType::Keyword.into()),
-        )
+        .create_field_index(opnum, &deep_nested_str_proj_key, Some(&Keyword.into()))
         .unwrap();
 
     eprintln!("{}", deep_nested_str_proj_key);
@@ -795,3 +779,58 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[0].count_indexed_points(), point_num);
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 }
+
+#[test]
+fn test_any_matcher_cardinality_estimation() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
+
+    let any_match = FieldCondition::new_match(
+        STR_KEY,
+        Match::new_any(AnyVariants::Keywords(vec![
+            "value1".to_string(),
+            "value2".to_string(),
+        ])),
+    );
+
+    let filter = Filter::new_must(Condition::Field(any_match.clone()));
+
+    let estimation = struct_segment
+        .payload_index
+        .borrow()
+        .estimate_cardinality(&filter);
+
+    // each `any` keyword generates a separate primary clause
+    assert_eq!(estimation.primary_clauses.len(), 2);
+    for (index, clause) in estimation.primary_clauses.iter().enumerate() {
+        let expected_primary_clause = FieldCondition::new_match(
+            STR_KEY.to_owned(),
+            format!("value{}", index + 1).to_string().into(),
+        );
+
+        match clause {
+            PrimaryCondition::Condition(field_condition) => {
+                assert_eq!(field_condition, &expected_primary_clause);
+            }
+            o => panic!("unexpected primary clause: {:?}", o),
+        }
+    }
+
+    let payload_index = struct_segment.payload_index.borrow();
+    let filter_context = payload_index.filter_context(&filter);
+    let exact = struct_segment
+        .id_tracker
+        .borrow()
+        .iter_ids()
+        .filter(|x| filter_context.check(*x))
+        .collect_vec()
+        .len();
+
+    eprintln!("exact = {exact:#?}");
+    eprintln!("estimation = {estimation:#?}");
+
+    assert!(exact <= estimation.max);
+    assert!(exact >= estimation.min);
+}

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 11044c156..d9056ca7c 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -3,6 +3,7 @@ use std::path::Path;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::types::PointOffsetType;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
@@ -25,8 +26,8 @@ use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoPoint, GeoPolygon,
-    GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField, PayloadSchemaType,
-    PointOffsetType, Range, SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
+    GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField, PayloadSchemaType, Range,
+    SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
 };
 use serde_json::json;
 use tempfile::Builder;

commit 3bc91780b0c75b1904b1d147e40666469954f66c
Author: Zein Wen <85084498+zzzz-vincent@users.noreply.github.com>
Date:   Wed Oct 4 02:57:51 2023 -0700

    Extend GeoPolygon to support interiors (#2315)
    
    * Extend GeoPolygon to support interiors (#2315)
    
    Per GeoJson, we should support polygon with exterior and interiors (holes on the surface) in Geo Filter by Polygon(#795). This commit extend current GeoPolygon filter to accept interiors. It includes:
    
    1. changes to proto and internal GeoPolygon struct, and validation fn
    2. add and refactor some tests
    3. add integration test
    
    * add gRPC geo_polygon validation
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index d9056ca7c..8eb287a54 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -25,9 +25,9 @@ use segment::segment_constructor::build_segment;
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
-    AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoPoint, GeoPolygon,
-    GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField, PayloadSchemaType, Range,
-    SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
+    AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoLineString,
+    GeoPoint, GeoPolygon, GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField,
+    PayloadSchemaType, Range, SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
 };
 use serde_json::json;
 use tempfile::Builder;
@@ -631,17 +631,32 @@ fn test_struct_payload_geo_radius_index() {
 
 #[test]
 fn test_struct_payload_geo_polygon_index() {
-    let mut rnd = rand::thread_rng();
-
     let polygon_edge = 5;
+    let interiors_num = 3;
+
+    fn generate_ring(polygon_edge: i32) -> GeoLineString {
+        let mut rnd = rand::thread_rng();
+        let mut line = GeoLineString {
+            points: (0..polygon_edge)
+                .map(|_| GeoPoint {
+                    lon: rnd.gen_range(LON_RANGE),
+                    lat: rnd.gen_range(LAT_RANGE),
+                })
+                .collect(),
+        };
+        line.points.push(line.points[0].clone()); // add last point that is identical to the first
+        line
+    }
 
-    let points: Vec<GeoPoint> = (0..polygon_edge)
-        .map(|_| GeoPoint {
-            lon: rnd.gen_range(LON_RANGE),
-            lat: rnd.gen_range(LAT_RANGE),
-        })
+    let exterior = generate_ring(polygon_edge);
+    let interiors = std::iter::repeat_with(|| generate_ring(polygon_edge))
+        .take(interiors_num)
         .collect();
-    let geo_polygon = GeoPolygon { points };
+
+    let geo_polygon = GeoPolygon {
+        exterior,
+        interiors,
+    };
 
     let condition = Condition::Field(FieldCondition::new_geo_polygon(
         "geo_key".to_string(),

commit 921f00062cc3ad18c426226b78ccf8e3cdbfbef6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Oct 5 18:34:39 2023 +0200

    Make GeoPolygon interiors optional (#2766)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 8eb287a54..64a83b113 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -649,9 +649,11 @@ fn test_struct_payload_geo_polygon_index() {
     }
 
     let exterior = generate_ring(polygon_edge);
-    let interiors = std::iter::repeat_with(|| generate_ring(polygon_edge))
-        .take(interiors_num)
-        .collect();
+    let interiors = Some(
+        std::iter::repeat_with(|| generate_ring(polygon_edge))
+            .take(interiors_num)
+            .collect(),
+    );
 
     let geo_polygon = GeoPolygon {
         exterior,

commit 0b581a5429c3835b0af3cfde2a2eb6c864be6c0c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Oct 12 15:45:32 2023 +0200

    optimize usage of the match-any filter in case it is empty (#2803)
    
    * optimize usage of the match-any filter in case it is empty
    
    * fix outdated tests

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 64a83b113..9b30463ae 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -820,13 +820,9 @@ fn test_any_matcher_cardinality_estimation() {
         .borrow()
         .estimate_cardinality(&filter);
 
-    // each `any` keyword generates a separate primary clause
-    assert_eq!(estimation.primary_clauses.len(), 2);
-    for (index, clause) in estimation.primary_clauses.iter().enumerate() {
-        let expected_primary_clause = FieldCondition::new_match(
-            STR_KEY.to_owned(),
-            format!("value{}", index + 1).to_string().into(),
-        );
+    assert_eq!(estimation.primary_clauses.len(), 1);
+    for (_, clause) in estimation.primary_clauses.iter().enumerate() {
+        let expected_primary_clause = any_match.clone();
 
         match clause {
             PrimaryCondition::Condition(field_condition) => {

commit 3fc1f9656418995d21d156bd83f6f3611a99ee96
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 1 13:10:58 2023 +0100

    Sparse index segment and collection config (#2802)
    
    * quantization storage as separate entity
    
    sparse index try to extend segment types
    
    fix build
    
    fix async scorer
    
    codespell
    
    update openapi
    
    update vector index
    
    remove code duplications
    
    more fixes
    
    more fixes
    
    fix build
    
    fix deserialization test
    
    remove transform_into
    
    are you happy clippy
    
    update openapi
    
    update openapi
    
    are you happy clippy
    
    fix build
    
    optional serialize
    
    more defaults
    
    update openapi
    
    fix comments
    
    generic transpose_map_into_named_vector
    
    rename fields in tests
    
    remove obsolete parts
    
    only named sparse config
    
    VectorStruct without unnamed sparse
    
    NamedVectorStruct without unnamed sparse
    
    remove obsolete test
    
    update openapi
    
    mmap index
    
    revert preprocess function
    
    are you happy fmt
    
    update openapi
    
    fix build
    
    fix tests
    
    are you happy fmt
    
    fix for client generation
    
    fix sparse segment creation
    
    fix basic sparse test
    
    fix conflicts
    
    remove obsolete convertion
    
    fix build
    
    config diffs
    
    update openapi
    
    review remarks
    
    update openapi
    
    fix batch upsert
    
    add failing test showing bad ids matching
    
    fix sparse vector insertion
    
    remove on_disk flag
    
    update openapi
    
    revert debug assert
    
    simplify conversions
    
    update openapi
    
    remove on disk storage flag
    
    update openapi
    
    default for vector config
    
    update openapi comment
    
    remove diffs
    
    update openapi
    
    * enable consensus test
    
    * add comment
    
    * update openapi

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 9b30463ae..96582be84 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -51,6 +51,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                 quantization_config: None,
             },
         )]),
+        sparse_vector_data: Default::default(),
         payload_storage_type: Default::default(),
     };
 
@@ -155,6 +156,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
                 quantization_config: None,
             },
         )]),
+        sparse_vector_data: Default::default(),
         payload_storage_type: Default::default(),
     };
 

commit 680574347f3b3dd6f604f452b80734a8c6f2f7c6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Dec 25 14:26:21 2023 +0100

    Fix clippy 1.75 (#3270)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 96582be84..6860664d9 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -823,7 +823,7 @@ fn test_any_matcher_cardinality_estimation() {
         .estimate_cardinality(&filter);
 
     assert_eq!(estimation.primary_clauses.len(), 1);
-    for (_, clause) in estimation.primary_clauses.iter().enumerate() {
+    for clause in estimation.primary_clauses.iter() {
         let expected_primary_clause = any_match.clone();
 
         match clause {

commit 820ade7494f707b872bf01fdaa9de6aca8ddeca4
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Jan 11 19:41:14 2024 +0100

    Parameterize integer index, allow lookup or range exclusively (#3380)
    
    * Merge serde attributes
    
    * Remove obsolete conversion
    
    * Add integer type with parameters
    
    * Make integer lookup and range parameters non-optional
    
    * Add parameterized integer index types test
    
    Co-authored-by: Di Zhao <diz@twitter.com>
    
    * Cleanup
    
    ---------
    
    Co-authored-by: Di Zhao <diz@twitter.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 6860664d9..2649472b2 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -7,27 +7,29 @@ use common::types::PointOffsetType;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
+use segment::data_types::integer_index::{IntegerIndexType, IntegerParams};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::fixtures::payload_fixtures::{
     generate_diverse_nested_payload, generate_diverse_payload, random_filter, random_nested_filter,
-    random_vector, FLICKING_KEY, GEO_KEY, INT_KEY, INT_KEY_2, LAT_RANGE, LON_RANGE, STR_KEY,
-    STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
+    random_vector, FLICKING_KEY, GEO_KEY, INT_KEY, INT_KEY_2, INT_KEY_3, LAT_RANGE, LON_RANGE,
+    STR_KEY, STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
 };
-use segment::index::field_index::PrimaryCondition;
+use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::PayloadIndex;
 use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
 use segment::segment_constructor::build_segment;
-use segment::types::PayloadFieldSchema::FieldType;
+use segment::types::PayloadFieldSchema::{FieldParams, FieldType};
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoLineString,
     GeoPoint, GeoPolygon, GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField,
-    PayloadSchemaType, Range, SegmentConfig, VectorDataConfig, VectorStorageType, WithPayload,
+    PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
+    VectorStorageType, WithPayload,
 };
 use serde_json::json;
 use tempfile::Builder;
@@ -95,6 +97,28 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     struct_segment
         .create_field_index(opnum, INT_KEY, None)
         .unwrap();
+    struct_segment
+        .create_field_index(
+            opnum,
+            INT_KEY_2,
+            Some(&FieldParams(PayloadSchemaParams::Integer(IntegerParams {
+                r#type: IntegerIndexType::Integer,
+                lookup: true,
+                range: false,
+            }))),
+        )
+        .unwrap();
+    struct_segment
+        .create_field_index(
+            opnum,
+            INT_KEY_3,
+            Some(&FieldParams(PayloadSchemaParams::Integer(IntegerParams {
+                r#type: IntegerIndexType::Integer,
+                lookup: false,
+                range: true,
+            }))),
+        )
+        .unwrap();
     struct_segment
         .create_field_index(opnum, GEO_KEY, Some(&PayloadSchemaType::Geo.into()))
         .unwrap();
@@ -360,6 +384,28 @@ fn test_is_empty_conditions() {
     );
 }
 
+#[test]
+fn test_integer_index_types() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
+
+    let indexes = struct_segment.payload_index.borrow();
+    assert!(matches!(
+        indexes.field_indexes.get(INT_KEY).unwrap().as_slice(),
+        [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)]
+    ));
+    assert!(matches!(
+        indexes.field_indexes.get(INT_KEY_2).unwrap().as_slice(),
+        [FieldIndex::IntMapIndex(_)]
+    ));
+    assert!(matches!(
+        indexes.field_indexes.get(INT_KEY_3).unwrap().as_slice(),
+        [FieldIndex::IntIndex(_)]
+    ));
+}
+
 #[test]
 fn test_cardinality_estimation() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();

commit 3281be7402216b45666a0f258493ed306070ab8c
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Jan 12 16:16:22 2024 +0100

    Rename IntegerParams to IntegerIndexParams to be consistent with text (#3385)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 2649472b2..8a25f6f6f 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -7,7 +7,7 @@ use common::types::PointOffsetType;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
-use segment::data_types::integer_index::{IntegerIndexType, IntegerParams};
+use segment::data_types::integer_index::{IntegerIndexParams, IntegerIndexType};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
@@ -101,22 +101,26 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
         .create_field_index(
             opnum,
             INT_KEY_2,
-            Some(&FieldParams(PayloadSchemaParams::Integer(IntegerParams {
-                r#type: IntegerIndexType::Integer,
-                lookup: true,
-                range: false,
-            }))),
+            Some(&FieldParams(PayloadSchemaParams::Integer(
+                IntegerIndexParams {
+                    r#type: IntegerIndexType::Integer,
+                    lookup: true,
+                    range: false,
+                },
+            ))),
         )
         .unwrap();
     struct_segment
         .create_field_index(
             opnum,
             INT_KEY_3,
-            Some(&FieldParams(PayloadSchemaParams::Integer(IntegerParams {
-                r#type: IntegerIndexType::Integer,
-                lookup: false,
-                range: true,
-            }))),
+            Some(&FieldParams(PayloadSchemaParams::Integer(
+                IntegerIndexParams {
+                    r#type: IntegerIndexType::Integer,
+                    lookup: false,
+                    range: true,
+                },
+            ))),
         )
         .unwrap();
     struct_segment

commit 3ee5aac011321766efab793c6b1e6a66088b0d36
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:50:58 2024 +0100

    Optimize MatchAny (#3525)
    
    * add benches for large MatchAny
    
    * use HashSet for MatchAny
    
    * use fnv hash
    
    * make fnv workspace level dependency; apply clippy
    
    * remove SmolStr from Keyword; Improve performance
    
    * add bench for small number of keywords
    
    * fix openapi
    
    * fix performance issue
    
    * apply integer optimization; create magic number constant

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 8a25f6f6f..f8dad7373 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -4,6 +4,8 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
+use fnv::FnvBuildHasher;
+use indexmap::IndexSet;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
@@ -623,13 +625,13 @@ fn test_struct_payload_index() {
         struct_result_sorted_ties.sort();
 
         plain_result_sorted_ties
-                .into_iter()
-                .zip(struct_result_sorted_ties.into_iter())
-                .map(|(r1, r2)| (r1.scored_point, r2.scored_point))
-                .for_each(|(r1, r2)| {
-                    assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
-                    assert!((r1.score - r2.score) < 0.0001)
-                });
+            .into_iter()
+            .zip(struct_result_sorted_ties.into_iter())
+            .map(|(r1, r2)| (r1.scored_point, r2.scored_point))
+            .for_each(|(r1, r2)| {
+                assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
+                assert!((r1.score - r2.score) < 0.0001)
+            });
     }
 }
 
@@ -782,12 +784,12 @@ fn test_struct_payload_index_nested_fields() {
 
         // warning: report flakiness at https://github.com/qdrant/qdrant/issues/534
         plain_result
-                .iter()
-                .zip(struct_result.iter())
-                .for_each(|(r1, r2)| {
-                    assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
-                    assert!((r1.score - r2.score) < 0.0001)
-                });
+            .iter()
+            .zip(struct_result.iter())
+            .for_each(|(r1, r2)| {
+                assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
+                assert!((r1.score - r2.score) < 0.0001)
+            });
     }
 }
 
@@ -857,13 +859,10 @@ fn test_any_matcher_cardinality_estimation() {
 
     let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
 
-    let any_match = FieldCondition::new_match(
-        STR_KEY,
-        Match::new_any(AnyVariants::Keywords(vec![
-            "value1".to_string(),
-            "value2".to_string(),
-        ])),
-    );
+    let keywords: IndexSet<String, FnvBuildHasher> =
+        ["value1", "value2"].iter().map(|i| i.to_string()).collect();
+    let any_match =
+        FieldCondition::new_match(STR_KEY, Match::new_any(AnyVariants::Keywords(keywords)));
 
     let filter = Filter::new_must(Condition::Field(any_match.clone()));
 

commit 3beb4e3b4ff4b3f9585337f4e5b0826a14e247b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Feb 23 14:38:40 2024 +0000

    Introduce JsonPathString (#3674)
    
    * Introduce JsonPathString
    
    * Fix fomatting

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index f8dad7373..5f961b1eb 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -36,6 +36,7 @@ use segment::types::{
 use serde_json::json;
 use tempfile::Builder;
 
+use crate::utils::path;
 use crate::utils::scored_point_ties::ScoredPointTies;
 
 const DIM: usize = 5;
@@ -68,7 +69,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
     let mut opnum = 0;
     struct_segment
-        .create_field_index(opnum, INT_KEY_2, Some(&Integer.into()))
+        .create_field_index(opnum, &path(INT_KEY_2), Some(&Integer.into()))
         .unwrap();
 
     opnum += 1;
@@ -94,15 +95,15 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     }
 
     struct_segment
-        .create_field_index(opnum, STR_KEY, Some(&Keyword.into()))
+        .create_field_index(opnum, &path(STR_KEY), Some(&Keyword.into()))
         .unwrap();
     struct_segment
-        .create_field_index(opnum, INT_KEY, None)
+        .create_field_index(opnum, &path(INT_KEY), None)
         .unwrap();
     struct_segment
         .create_field_index(
             opnum,
-            INT_KEY_2,
+            &path(INT_KEY_2),
             Some(&FieldParams(PayloadSchemaParams::Integer(
                 IntegerIndexParams {
                     r#type: IntegerIndexType::Integer,
@@ -115,7 +116,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     struct_segment
         .create_field_index(
             opnum,
-            INT_KEY_3,
+            &path(INT_KEY_3),
             Some(&FieldParams(PayloadSchemaParams::Integer(
                 IntegerIndexParams {
                     r#type: IntegerIndexType::Integer,
@@ -126,13 +127,17 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
         )
         .unwrap();
     struct_segment
-        .create_field_index(opnum, GEO_KEY, Some(&PayloadSchemaType::Geo.into()))
+        .create_field_index(opnum, &path(GEO_KEY), Some(&PayloadSchemaType::Geo.into()))
         .unwrap();
     struct_segment
-        .create_field_index(opnum, TEXT_KEY, Some(&PayloadSchemaType::Text.into()))
+        .create_field_index(
+            opnum,
+            &path(TEXT_KEY),
+            Some(&PayloadSchemaType::Text.into()),
+        )
         .unwrap();
     struct_segment
-        .create_field_index(opnum, FLICKING_KEY, Some(&Integer.into()))
+        .create_field_index(opnum, &path(FLICKING_KEY), Some(&Integer.into()))
         .unwrap();
 
     for _ in 0..points_to_clear {
@@ -160,7 +165,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
         for index in indexes {
             assert!(index.count_indexed_points() < num_points as usize);
-            if field != FLICKING_KEY {
+            if field.to_string() != FLICKING_KEY {
                 assert!(
                     index.count_indexed_points()
                         > (num_points as usize - points_to_delete - points_to_clear)
@@ -198,10 +203,12 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
     let points_to_clear = 500;
 
     // Nested payload keys
-    let nested_str_key = format!("{}.{}.{}", STR_KEY, "nested_1", "nested_2");
-    let nested_str_proj_key = format!("{}.{}[].{}", STR_PROJ_KEY, "nested_1", "nested_2");
-    let deep_nested_str_proj_key =
-        format!("{}[].{}[].{}", STR_ROOT_PROJ_KEY, "nested_1", "nested_2");
+    let nested_str_key = path(&format!("{}.{}.{}", STR_KEY, "nested_1", "nested_2"));
+    let nested_str_proj_key = path(&format!("{}.{}[].{}", STR_PROJ_KEY, "nested_1", "nested_2"));
+    let deep_nested_str_proj_key = path(&format!(
+        "{}[].{}[].{}",
+        STR_ROOT_PROJ_KEY, "nested_1", "nested_2"
+    ));
 
     let mut opnum = 0;
     struct_segment
@@ -352,7 +359,7 @@ fn test_is_empty_conditions() {
 
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
-            key: FLICKING_KEY.to_string(),
+            key: path(FLICKING_KEY),
         },
     }));
 
@@ -399,15 +406,27 @@ fn test_integer_index_types() {
 
     let indexes = struct_segment.payload_index.borrow();
     assert!(matches!(
-        indexes.field_indexes.get(INT_KEY).unwrap().as_slice(),
+        indexes
+            .field_indexes
+            .get(&path(INT_KEY))
+            .unwrap()
+            .as_slice(),
         [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)]
     ));
     assert!(matches!(
-        indexes.field_indexes.get(INT_KEY_2).unwrap().as_slice(),
+        indexes
+            .field_indexes
+            .get(&path(INT_KEY_2))
+            .unwrap()
+            .as_slice(),
         [FieldIndex::IntMapIndex(_)]
     ));
     assert!(matches!(
-        indexes.field_indexes.get(INT_KEY_3).unwrap().as_slice(),
+        indexes
+            .field_indexes
+            .get(&path(INT_KEY_3))
+            .unwrap()
+            .as_slice(),
         [FieldIndex::IntIndex(_)]
     ));
 }
@@ -420,7 +439,7 @@ fn test_cardinality_estimation() {
     let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
 
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
-        INT_KEY.to_owned(),
+        path(INT_KEY),
         Range {
             lt: None,
             gt: None,
@@ -460,10 +479,9 @@ fn test_root_nested_array_filter_cardinality_estimation() {
 
     // rely on test data from `build_test_segments_nested_payload`
     let nested_key = "nested_1[].nested_2";
-    let nested_match =
-        FieldCondition::new_match(nested_key.to_owned(), "some value".to_owned().into());
+    let nested_match = FieldCondition::new_match(path(nested_key), "some value".to_owned().into());
     let filter = Filter::new_must(Condition::new_nested(
-        STR_ROOT_PROJ_KEY.to_string(),
+        path(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::Field(nested_match)),
     ));
 
@@ -478,7 +496,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
     let primary_clause = estimation.primary_clauses.first().unwrap();
 
     let expected_primary_clause = FieldCondition::new_match(
-        format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key), // full key expected
+        path(&format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key)), // full key expected
         "some value".to_owned().into(),
     );
 
@@ -516,11 +534,11 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
     // rely on test data from `build_test_segments_nested_payload`
     let nested_match_key = "nested_2";
     let nested_match =
-        FieldCondition::new_match(nested_match_key.to_owned(), "some value".to_owned().into());
+        FieldCondition::new_match(path(nested_match_key), "some value".to_owned().into());
     let filter = Filter::new_must(Condition::new_nested(
-        STR_ROOT_PROJ_KEY.to_string(),
+        path(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::new_nested(
-            "nested_1".to_string(),
+            path("nested_1"),
             Filter::new_must(Condition::Field(nested_match)),
         )),
     ));
@@ -536,7 +554,11 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
     let primary_clause = estimation.primary_clauses.first().unwrap();
 
     let expected_primary_clause = FieldCondition::new_match(
-        format!("{}[].nested_1[].{}", STR_ROOT_PROJ_KEY, nested_match_key), // full key expected
+        // full key expected
+        path(&format!(
+            "{}[].nested_1[].{}",
+            STR_ROOT_PROJ_KEY, nested_match_key
+        )),
         "some value".to_owned().into(),
     );
 
@@ -651,7 +673,7 @@ fn test_struct_payload_geo_boundingbox_index() {
     };
 
     let condition = Condition::Field(FieldCondition::new_geo_bounding_box(
-        "geo_key".to_string(),
+        path("geo_key"),
         geo_bbox,
     ));
 
@@ -673,10 +695,7 @@ fn test_struct_payload_geo_radius_index() {
         radius: r_meters,
     };
 
-    let condition = Condition::Field(FieldCondition::new_geo_radius(
-        "geo_key".to_string(),
-        geo_radius,
-    ));
+    let condition = Condition::Field(FieldCondition::new_geo_radius(path("geo_key"), geo_radius));
 
     let query_filter = Filter::new_must(condition);
 
@@ -715,7 +734,7 @@ fn test_struct_payload_geo_polygon_index() {
     };
 
     let condition = Condition::Field(FieldCondition::new_geo_polygon(
-        "geo_key".to_string(),
+        path("geo_key"),
         geo_polygon,
     ));
 
@@ -822,32 +841,34 @@ fn test_update_payload_index_type() {
     let mut index =
         StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path(), true).unwrap();
 
+    let field = path("field");
+
     // set field to Integer type
-    index.set_indexed("field", Integer.into()).unwrap();
+    index.set_indexed(&field, Integer.into()).unwrap();
     assert_eq!(
-        *index.indexed_fields().get("field").unwrap(),
+        *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)
     );
-    let field_index = index.field_indexes.get("field").unwrap();
+    let field_index = index.field_indexes.get(&field).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), point_num);
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 
     // update field to Keyword type
-    index.set_indexed("field", Keyword.into()).unwrap();
+    index.set_indexed(&field, Keyword.into()).unwrap();
     assert_eq!(
-        *index.indexed_fields().get("field").unwrap(),
+        *index.indexed_fields().get(&field).unwrap(),
         FieldType(Keyword)
     );
-    let field_index = index.field_indexes.get("field").unwrap();
+    let field_index = index.field_indexes.get(&field).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), 0); // only one field index for Keyword
 
     // set field to Integer type (again)
-    index.set_indexed("field", Integer.into()).unwrap();
+    index.set_indexed(&field, Integer.into()).unwrap();
     assert_eq!(
-        *index.indexed_fields().get("field").unwrap(),
+        *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)
     );
-    let field_index = index.field_indexes.get("field").unwrap();
+    let field_index = index.field_indexes.get(&field).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), point_num);
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 }
@@ -861,8 +882,10 @@ fn test_any_matcher_cardinality_estimation() {
 
     let keywords: IndexSet<String, FnvBuildHasher> =
         ["value1", "value2"].iter().map(|i| i.to_string()).collect();
-    let any_match =
-        FieldCondition::new_match(STR_KEY, Match::new_any(AnyVariants::Keywords(keywords)));
+    let any_match = FieldCondition::new_match(
+        path(STR_KEY),
+        Match::new_any(AnyVariants::Keywords(keywords)),
+    );
 
     let filter = Filter::new_must(Condition::Field(any_match.clone()));
 

commit ffa363cbff245b81b225c8f09b2d4159d3a5f3a2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Apr 4 16:38:09 2024 +0200

    Multivec knob for SegmentConfig (#3963)
    
    * Multivec knob for SegmentConfig
    
    * regen openapi
    
    * add TODO for next step
    
    * introduce multivecconfig to support more similarity aggregation
    
    * update openapi

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 5f961b1eb..f7a12845f 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -54,6 +54,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
+                multi_vec_config: None,
             },
         )]),
         sparse_vector_data: Default::default(),
@@ -189,6 +190,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
+                multi_vec_config: None,
             },
         )]),
         sparse_vector_data: Default::default(),

commit 01f5c667bc6d0669b16759dacf5e2cf815497809
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 11 22:52:01 2024 +0200

    remove search method from serment trait to simplify usage in tests and prevent accidental usage in release (#3999)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index f7a12845f..e6e14415d 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -301,7 +301,6 @@ fn validate_geo_filter(query_filter: Filter) {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
 
@@ -326,7 +325,6 @@ fn validate_geo_filter(query_filter: Filter) {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
 
@@ -611,7 +609,6 @@ fn test_struct_payload_index() {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
         let struct_result = struct_segment
@@ -623,7 +620,6 @@ fn test_struct_payload_index() {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
 
@@ -772,7 +768,6 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
         let struct_result = struct_segment
@@ -787,7 +782,6 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
-                &false.into(),
             )
             .unwrap();
 

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index e6e14415d..6e7aa46f6 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -55,6 +55,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                 index: Indexes::Plain {},
                 quantization_config: None,
                 multi_vec_config: None,
+                datatype: None,
             },
         )]),
         sparse_vector_data: Default::default(),
@@ -191,6 +192,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
                 index: Indexes::Plain {},
                 quantization_config: None,
                 multi_vec_config: None,
+                datatype: None,
             },
         )]),
         sparse_vector_data: Default::default(),

commit 28a31bd5b00a237261bc0e306d972c60582f22b7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon May 6 14:19:42 2024 +0200

    Simplify MaxSim configuration (#4171)
    
    * Simplify MaxSim configuration
    
    * enable extension of multivectorconfig
    
    * rename multi_vec_config to multivec_config

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 6e7aa46f6..0644e7e93 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -54,7 +54,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
-                multi_vec_config: None,
+                multivec_config: None,
                 datatype: None,
             },
         )]),
@@ -191,7 +191,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
-                multi_vec_config: None,
+                multivec_config: None,
                 datatype: None,
             },
         )]),

commit 8fe5e43764a517b36e1ab013c2dc6505b132a51c
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue May 7 16:14:46 2024 +0000

    Introduce Cargo feature "testing" (#4192)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 0644e7e93..2154b1595 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -21,6 +21,7 @@ use segment::fixtures::payload_fixtures::{
 use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::PayloadIndex;
+use segment::json_path::path;
 use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
@@ -36,7 +37,6 @@ use segment::types::{
 use serde_json::json;
 use tempfile::Builder;
 
-use crate::utils::path;
 use crate::utils::scored_point_ties::ScoredPointTies;
 
 const DIM: usize = 5;

commit 02e89fe7ae9b6b163bd7c944718b934f685e5baf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri May 31 08:56:06 2024 -0400

    universal-query: Impl of `query_internal` in collection (#4331)
    
    * move ScoredPointTies to segment, make inner by reference
    
    * `query_internal` implementation
    
    * remove empty utils mod
    
    * use `then_with`
    
    * Improve readability, remove duplicated code
    
    * refactoring suggestions
    
    * don't collect eagerly
    
    * remove unused import
    
    * dont panic on empty transpose input
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 2154b1595..9c445bde0 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -34,11 +34,10 @@ use segment::types::{
     PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
     VectorStorageType, WithPayload,
 };
+use segment::utils::scored_point_ties::ScoredPointTies;
 use serde_json::json;
 use tempfile::Builder;
 
-use crate::utils::scored_point_ties::ScoredPointTies;
-
 const DIM: usize = 5;
 const ATTEMPTS: usize = 100;
 
@@ -639,17 +638,17 @@ fn test_struct_payload_index() {
 
         // Perform additional sort to break ties by score
         let mut plain_result_sorted_ties: Vec<ScoredPointTies> =
-            plain_result.iter().map(|x| x.clone().into()).collect_vec();
+            plain_result.iter().map(|x| x.into()).collect_vec();
         plain_result_sorted_ties.sort();
 
         let mut struct_result_sorted_ties: Vec<ScoredPointTies> =
-            struct_result.iter().map(|x| x.clone().into()).collect_vec();
+            struct_result.iter().map(|x| x.into()).collect_vec();
         struct_result_sorted_ties.sort();
 
         plain_result_sorted_ties
             .into_iter()
             .zip(struct_result_sorted_ties.into_iter())
-            .map(|(r1, r2)| (r1.scored_point, r2.scored_point))
+            .map(|(r1, r2)| (r1.0, r2.0))
             .for_each(|(r1, r2)| {
                 assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
                 assert!((r1.score - r2.score) < 0.0001)

commit eba2c6be61c000a6863e83d989e4e4eb9f1309e1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 23 23:56:42 2024 +0200

    Api consistency update (#4533)
    
    * rename search_params -> params
    
    * rename multivector_config + generate schema
    
    * upd tests

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 9c445bde0..28cfc6fec 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -53,7 +53,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
-                multivec_config: None,
+                multivector_config: None,
                 datatype: None,
             },
         )]),
@@ -190,7 +190,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
                 storage_type: VectorStorageType::Memory,
                 index: Indexes::Plain {},
                 quantization_config: None,
-                multivec_config: None,
+                multivector_config: None,
                 datatype: None,
             },
         )]),

commit a74bf30f8da3b03c9c78208006c9ddccd5823bc8
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jul 5 12:09:31 2024 +0000

    Extend PayloadSchemaParams to every PayloadSchemaType (#4613)
    
    * Move IntegerIndexType and TextIndexType into a common file
    
    * Formatting
    
    * Extend PayloadSchemaParams to every PayloadSchemaType

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 28cfc6fec..3d2beff45 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -9,7 +9,7 @@ use indexmap::IndexSet;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
-use segment::data_types::integer_index::{IntegerIndexParams, IntegerIndexType};
+use segment::data_types::index::{IntegerIndexParams, IntegerIndexType};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;

commit 4fdf7152f0977adc07bdf9258109ed8600c13f9f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jul 11 04:06:40 2024 +0000

    Drop JsonPathString (#4621)
    
    * drop some code
    
    * Drop JsonPathString
    
    * Fix test_remove_key
    
    Drop failing tests:
    - Deleting array indices is not idempotent, so we don't support it.
    - Empty JSONPath is not supported.
    
    * Make json_path::path() non-generic
    
    * Remove references to JsonPathV2
    
    * Drop JsonPathInterface
    
    * Move json_path::v2 code into json_path
    
    * Drop validate_not_empty
    
    * Drop JsonPath::head() as being unused
    
    * Replace path() with JsonPath::new()
    
    * Restore comments
    
    * Move tests to json_path
    
    * Use json() consistently in tests
    
    * Replace many into calls with Into trait
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 3d2beff45..ee9166898 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -21,7 +21,7 @@ use segment::fixtures::payload_fixtures::{
 use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::PayloadIndex;
-use segment::json_path::path;
+use segment::json_path::JsonPath;
 use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
@@ -70,7 +70,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
     let mut opnum = 0;
     struct_segment
-        .create_field_index(opnum, &path(INT_KEY_2), Some(&Integer.into()))
+        .create_field_index(opnum, &JsonPath::new(INT_KEY_2), Some(&Integer.into()))
         .unwrap();
 
     opnum += 1;
@@ -96,15 +96,15 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     }
 
     struct_segment
-        .create_field_index(opnum, &path(STR_KEY), Some(&Keyword.into()))
+        .create_field_index(opnum, &JsonPath::new(STR_KEY), Some(&Keyword.into()))
         .unwrap();
     struct_segment
-        .create_field_index(opnum, &path(INT_KEY), None)
+        .create_field_index(opnum, &JsonPath::new(INT_KEY), None)
         .unwrap();
     struct_segment
         .create_field_index(
             opnum,
-            &path(INT_KEY_2),
+            &JsonPath::new(INT_KEY_2),
             Some(&FieldParams(PayloadSchemaParams::Integer(
                 IntegerIndexParams {
                     r#type: IntegerIndexType::Integer,
@@ -117,7 +117,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
     struct_segment
         .create_field_index(
             opnum,
-            &path(INT_KEY_3),
+            &JsonPath::new(INT_KEY_3),
             Some(&FieldParams(PayloadSchemaParams::Integer(
                 IntegerIndexParams {
                     r#type: IntegerIndexType::Integer,
@@ -128,17 +128,21 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
         )
         .unwrap();
     struct_segment
-        .create_field_index(opnum, &path(GEO_KEY), Some(&PayloadSchemaType::Geo.into()))
+        .create_field_index(
+            opnum,
+            &JsonPath::new(GEO_KEY),
+            Some(&PayloadSchemaType::Geo.into()),
+        )
         .unwrap();
     struct_segment
         .create_field_index(
             opnum,
-            &path(TEXT_KEY),
+            &JsonPath::new(TEXT_KEY),
             Some(&PayloadSchemaType::Text.into()),
         )
         .unwrap();
     struct_segment
-        .create_field_index(opnum, &path(FLICKING_KEY), Some(&Integer.into()))
+        .create_field_index(opnum, &JsonPath::new(FLICKING_KEY), Some(&Integer.into()))
         .unwrap();
 
     for _ in 0..points_to_clear {
@@ -206,9 +210,10 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
     let points_to_clear = 500;
 
     // Nested payload keys
-    let nested_str_key = path(&format!("{}.{}.{}", STR_KEY, "nested_1", "nested_2"));
-    let nested_str_proj_key = path(&format!("{}.{}[].{}", STR_PROJ_KEY, "nested_1", "nested_2"));
-    let deep_nested_str_proj_key = path(&format!(
+    let nested_str_key = JsonPath::new(&format!("{}.{}.{}", STR_KEY, "nested_1", "nested_2"));
+    let nested_str_proj_key =
+        JsonPath::new(&format!("{}.{}[].{}", STR_PROJ_KEY, "nested_1", "nested_2"));
+    let deep_nested_str_proj_key = JsonPath::new(&format!(
         "{}[].{}[].{}",
         STR_ROOT_PROJ_KEY, "nested_1", "nested_2"
     ));
@@ -360,7 +365,7 @@ fn test_is_empty_conditions() {
 
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
-            key: path(FLICKING_KEY),
+            key: JsonPath::new(FLICKING_KEY),
         },
     }));
 
@@ -409,7 +414,7 @@ fn test_integer_index_types() {
     assert!(matches!(
         indexes
             .field_indexes
-            .get(&path(INT_KEY))
+            .get(&JsonPath::new(INT_KEY))
             .unwrap()
             .as_slice(),
         [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)]
@@ -417,7 +422,7 @@ fn test_integer_index_types() {
     assert!(matches!(
         indexes
             .field_indexes
-            .get(&path(INT_KEY_2))
+            .get(&JsonPath::new(INT_KEY_2))
             .unwrap()
             .as_slice(),
         [FieldIndex::IntMapIndex(_)]
@@ -425,7 +430,7 @@ fn test_integer_index_types() {
     assert!(matches!(
         indexes
             .field_indexes
-            .get(&path(INT_KEY_3))
+            .get(&JsonPath::new(INT_KEY_3))
             .unwrap()
             .as_slice(),
         [FieldIndex::IntIndex(_)]
@@ -440,7 +445,7 @@ fn test_cardinality_estimation() {
     let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
 
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
-        path(INT_KEY),
+        JsonPath::new(INT_KEY),
         Range {
             lt: None,
             gt: None,
@@ -480,9 +485,10 @@ fn test_root_nested_array_filter_cardinality_estimation() {
 
     // rely on test data from `build_test_segments_nested_payload`
     let nested_key = "nested_1[].nested_2";
-    let nested_match = FieldCondition::new_match(path(nested_key), "some value".to_owned().into());
+    let nested_match =
+        FieldCondition::new_match(JsonPath::new(nested_key), "some value".to_owned().into());
     let filter = Filter::new_must(Condition::new_nested(
-        path(STR_ROOT_PROJ_KEY),
+        JsonPath::new(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::Field(nested_match)),
     ));
 
@@ -497,7 +503,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
     let primary_clause = estimation.primary_clauses.first().unwrap();
 
     let expected_primary_clause = FieldCondition::new_match(
-        path(&format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key)), // full key expected
+        JsonPath::new(&format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key)), // full key expected
         "some value".to_owned().into(),
     );
 
@@ -534,12 +540,14 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 
     // rely on test data from `build_test_segments_nested_payload`
     let nested_match_key = "nested_2";
-    let nested_match =
-        FieldCondition::new_match(path(nested_match_key), "some value".to_owned().into());
+    let nested_match = FieldCondition::new_match(
+        JsonPath::new(nested_match_key),
+        "some value".to_owned().into(),
+    );
     let filter = Filter::new_must(Condition::new_nested(
-        path(STR_ROOT_PROJ_KEY),
+        JsonPath::new(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::new_nested(
-            path("nested_1"),
+            JsonPath::new("nested_1"),
             Filter::new_must(Condition::Field(nested_match)),
         )),
     ));
@@ -556,7 +564,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 
     let expected_primary_clause = FieldCondition::new_match(
         // full key expected
-        path(&format!(
+        JsonPath::new(&format!(
             "{}[].nested_1[].{}",
             STR_ROOT_PROJ_KEY, nested_match_key
         )),
@@ -672,7 +680,7 @@ fn test_struct_payload_geo_boundingbox_index() {
     };
 
     let condition = Condition::Field(FieldCondition::new_geo_bounding_box(
-        path("geo_key"),
+        JsonPath::new("geo_key"),
         geo_bbox,
     ));
 
@@ -694,7 +702,10 @@ fn test_struct_payload_geo_radius_index() {
         radius: r_meters,
     };
 
-    let condition = Condition::Field(FieldCondition::new_geo_radius(path("geo_key"), geo_radius));
+    let condition = Condition::Field(FieldCondition::new_geo_radius(
+        JsonPath::new("geo_key"),
+        geo_radius,
+    ));
 
     let query_filter = Filter::new_must(condition);
 
@@ -733,7 +744,7 @@ fn test_struct_payload_geo_polygon_index() {
     };
 
     let condition = Condition::Field(FieldCondition::new_geo_polygon(
-        path("geo_key"),
+        JsonPath::new("geo_key"),
         geo_polygon,
     ));
 
@@ -838,10 +849,10 @@ fn test_update_payload_index_type() {
     let mut index =
         StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path(), true).unwrap();
 
-    let field = path("field");
+    let field = JsonPath::new("field");
 
     // set field to Integer type
-    index.set_indexed(&field, Integer.into()).unwrap();
+    index.set_indexed(&field, Integer).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)
@@ -851,7 +862,7 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 
     // update field to Keyword type
-    index.set_indexed(&field, Keyword.into()).unwrap();
+    index.set_indexed(&field, Keyword).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Keyword)
@@ -860,7 +871,7 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[0].count_indexed_points(), 0); // only one field index for Keyword
 
     // set field to Integer type (again)
-    index.set_indexed(&field, Integer.into()).unwrap();
+    index.set_indexed(&field, Integer).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)
@@ -880,7 +891,7 @@ fn test_any_matcher_cardinality_estimation() {
     let keywords: IndexSet<String, FnvBuildHasher> =
         ["value1", "value2"].iter().map(|i| i.to_string()).collect();
     let any_match = FieldCondition::new_match(
-        path(STR_KEY),
+        JsonPath::new(STR_KEY),
         Match::new_any(AnyVariants::Keywords(keywords)),
     );
 

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index ee9166898..a7244d5d3 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -110,6 +110,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     r#type: IntegerIndexType::Integer,
                     lookup: true,
                     range: false,
+                    is_tenant: None,
                 },
             ))),
         )
@@ -123,6 +124,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     r#type: IntegerIndexType::Integer,
                     lookup: false,
                     range: true,
+                    is_tenant: None,
                 },
             ))),
         )

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index a7244d5d3..1f73a1409 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -233,7 +233,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         .create_field_index(opnum, &deep_nested_str_proj_key, Some(&Keyword.into()))
         .unwrap();
 
-    eprintln!("{}", deep_nested_str_proj_key);
+    eprintln!("{deep_nested_str_proj_key}");
 
     opnum += 1;
     for n in 0..num_points {
@@ -505,7 +505,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
     let primary_clause = estimation.primary_clauses.first().unwrap();
 
     let expected_primary_clause = FieldCondition::new_match(
-        JsonPath::new(&format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key)), // full key expected
+        JsonPath::new(&format!("{STR_ROOT_PROJ_KEY}[].{nested_key}")), // full key expected
         "some value".to_owned().into(),
     );
 
@@ -513,7 +513,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
         PrimaryCondition::Condition(field_condition) => {
             assert_eq!(field_condition, &expected_primary_clause);
         }
-        o => panic!("unexpected primary clause: {:?}", o),
+        o => panic!("unexpected primary clause: {o:?}"),
     }
 
     let payload_index = struct_segment.payload_index.borrow();
@@ -567,8 +567,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
     let expected_primary_clause = FieldCondition::new_match(
         // full key expected
         JsonPath::new(&format!(
-            "{}[].nested_1[].{}",
-            STR_ROOT_PROJ_KEY, nested_match_key
+            "{STR_ROOT_PROJ_KEY}[].nested_1[].{nested_match_key}"
         )),
         "some value".to_owned().into(),
     );
@@ -577,7 +576,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
         PrimaryCondition::Condition(field_condition) => {
             assert_eq!(field_condition, &expected_primary_clause);
         }
-        o => panic!("unexpected primary clause: {:?}", o),
+        o => panic!("unexpected primary clause: {o:?}"),
     }
 
     let payload_index = struct_segment.payload_index.borrow();
@@ -890,8 +889,10 @@ fn test_any_matcher_cardinality_estimation() {
 
     let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
 
-    let keywords: IndexSet<String, FnvBuildHasher> =
-        ["value1", "value2"].iter().map(|i| i.to_string()).collect();
+    let keywords: IndexSet<String, FnvBuildHasher> = ["value1", "value2"]
+        .iter()
+        .map(|&i| i.to_string())
+        .collect();
     let any_match = FieldCondition::new_match(
         JsonPath::new(STR_KEY),
         Match::new_any(AnyVariants::Keywords(keywords)),
@@ -912,7 +913,7 @@ fn test_any_matcher_cardinality_estimation() {
             PrimaryCondition::Condition(field_condition) => {
                 assert_eq!(field_condition, &expected_primary_clause);
             }
-            o => panic!("unexpected primary clause: {:?}", o),
+            o => panic!("unexpected primary clause: {o:?}"),
         }
     }
 

commit 983df217d95c5b5517cf6bc762647e9fb202902e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jul 26 10:12:35 2024 +0000

    Add {Integer,Float,Datetime}IndexParams::on_disk to the API (#4755)
    
    * Add {Keyword,Integer,Float,Datetime}IndexParams::on_disk to the API
    
    * Add PayloadFieldSchema::is_on_disk()

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 1f73a1409..0c42173ff 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -111,6 +111,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     lookup: true,
                     range: false,
                     is_tenant: None,
+                    on_disk: None,
                 },
             ))),
         )
@@ -125,6 +126,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     lookup: false,
                     range: true,
                     is_tenant: None,
+                    on_disk: None,
                 },
             ))),
         )

commit eb679ff097c79aba3f11b0f0b01d307d2e163d0c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jul 30 13:18:19 2024 -0400

    Facets in segment (#4753)
    
    * faceting in segment
    
    * Add segment integration test
    
    * nits
    
    * count from filtered stream, not value->points map directly
    
    * drop AtomicRef from fn signature
    
    * count only unique values per point
    
    * use entry in hashmap
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 0c42173ff..08f1dce1a 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1,3 +1,4 @@
+use std::cmp::Reverse;
 use std::collections::HashMap;
 use std::path::Path;
 use std::sync::Arc;
@@ -9,6 +10,7 @@ use indexmap::IndexSet;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
+use segment::data_types::facets::{FacetRequest, FacetValue, FacetValueHit};
 use segment::data_types::index::{IntegerIndexParams, IntegerIndexType};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
@@ -173,11 +175,11 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
 
     for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
         for index in indexes {
-            assert!(index.count_indexed_points() < num_points as usize);
+            assert!(index.count_indexed_points() <= num_points as usize);
             if field.to_string() != FLICKING_KEY {
                 assert!(
                     index.count_indexed_points()
-                        > (num_points as usize - points_to_delete - points_to_clear)
+                        >= (num_points as usize - points_to_delete - points_to_clear)
                 );
             }
         }
@@ -935,3 +937,69 @@ fn test_any_matcher_cardinality_estimation() {
     assert!(exact <= estimation.max);
     assert!(exact >= estimation.min);
 }
+
+/// Checks that it is ordered in descending order, and that the counts are the same as counting each value exactly.
+fn validate_facet_result(
+    segment: &Segment,
+    facet_hits: Vec<FacetValueHit>,
+    filter: Option<Filter>,
+) {
+    let mut expected = facet_hits.clone();
+    expected.sort_by_key(|hit| Reverse(hit.clone()));
+    assert_eq!(facet_hits, expected);
+
+    for hit in facet_hits {
+        // Compare against exact count
+        let FacetValue::Keyword(value) = hit.value;
+
+        let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
+            JsonPath::new(STR_KEY),
+            Match::from(value),
+        )));
+        let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
+
+        let exact = segment
+            .read_filtered(None, None, count_filter.as_ref())
+            .len();
+
+        assert_eq!(hit.count, exact);
+    }
+}
+
+#[test]
+fn test_keyword_facet() {
+    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
+    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
+
+    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+
+    let limit = 100;
+    let key: JsonPath = STR_KEY.try_into().unwrap();
+
+    // *** No filter ***
+    let request = FacetRequest {
+        key: key.clone(),
+        limit,
+        filter: None,
+    };
+
+    // Plain segment should fail, as it does not have a keyword index
+    assert!(plain_segment.facet(&request).is_err());
+
+    let facet_hits = struct_segment.facet(&request).unwrap();
+
+    validate_facet_result(&struct_segment, facet_hits, None);
+
+    // *** With filter ***
+    let mut rng = rand::thread_rng();
+    let filter = random_filter(&mut rng, 3);
+    let request = FacetRequest {
+        key,
+        limit,
+        filter: Some(filter.clone()),
+    };
+
+    let facet_hits = struct_segment.facet(&request).unwrap();
+
+    validate_facet_result(&struct_segment, facet_hits, Some(filter))
+}

commit 20b0199aff8ccc6b274ef80f688d1b0a1a322958
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Jul 31 17:09:52 2024 +0200

    Rename tenant to principal for float,int,datetime (#4789)
    
    * Rename tenant to principal for float,int,datetime
    
    * Apply review proposal

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 08f1dce1a..e5b328e50 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -112,7 +112,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     r#type: IntegerIndexType::Integer,
                     lookup: true,
                     range: false,
-                    is_tenant: None,
+                    is_principal: None,
                     on_disk: None,
                 },
             ))),
@@ -127,7 +127,7 @@ fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segme
                     r#type: IntegerIndexType::Integer,
                     lookup: false,
                     range: true,
-                    is_tenant: None,
+                    is_principal: None,
                     on_disk: None,
                 },
             ))),

commit 12c5d6b6b606cd5559a6452ef39d802039d02dd6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Aug 2 12:57:20 2024 -0400

    Support timeout in Facets (#4792)
    
    * nits in segments_searcher
    
    * implement timeout into segment faceting
    
    * Add timeout to internal service api
    
    * refactor iterator_ext, and add test

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index e5b328e50..b399cdce5 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -984,9 +984,9 @@ fn test_keyword_facet() {
     };
 
     // Plain segment should fail, as it does not have a keyword index
-    assert!(plain_segment.facet(&request).is_err());
+    assert!(plain_segment.facet(&request, &Default::default()).is_err());
 
-    let facet_hits = struct_segment.facet(&request).unwrap();
+    let facet_hits = struct_segment.facet(&request, &Default::default()).unwrap();
 
     validate_facet_result(&struct_segment, facet_hits, None);
 
@@ -999,7 +999,7 @@ fn test_keyword_facet() {
         filter: Some(filter.clone()),
     };
 
-    let facet_hits = struct_segment.facet(&request).unwrap();
+    let facet_hits = struct_segment.facet(&request, &Default::default()).unwrap();
 
     validate_facet_result(&struct_segment, facet_hits, Some(filter))
 }

commit 624b29daa431fe3683174e738aba0c0c5e625119
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 20:00:03 2024 +0000

    Integration tests for on-disk payload indices (#4819)
    
    * refactor: let SegmentBuilder::update take unlocked segments
    
    * style: split long lines
    
    * refactor: introduce TestSegments
    
    * test: add tests for mmap indices

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index b399cdce5..e91a3499e 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1,9 +1,12 @@
 use std::cmp::Reverse;
 use std::collections::HashMap;
+use std::fs::create_dir;
 use std::path::Path;
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use fnv::FnvBuildHasher;
 use indexmap::IndexSet;
@@ -11,14 +14,17 @@ use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
 use segment::data_types::facets::{FacetRequest, FacetValue, FacetValueHit};
-use segment::data_types::index::{IntegerIndexParams, IntegerIndexType};
+use segment::data_types::index::{
+    FloatIndexParams, FloatIndexType, IntegerIndexParams, IntegerIndexType, KeywordIndexParams,
+    KeywordIndexType,
+};
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::fixtures::payload_fixtures::{
     generate_diverse_nested_payload, generate_diverse_payload, random_filter, random_nested_filter,
-    random_vector, FLICKING_KEY, GEO_KEY, INT_KEY, INT_KEY_2, INT_KEY_3, LAT_RANGE, LON_RANGE,
-    STR_KEY, STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
+    random_vector, FLICKING_KEY, FLT_KEY, GEO_KEY, INT_KEY, INT_KEY_2, INT_KEY_3, LAT_RANGE,
+    LON_RANGE, STR_KEY, STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
 };
 use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
@@ -28,164 +34,297 @@ use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
 use segment::segment_constructor::build_segment;
+use segment::segment_constructor::segment_builder::SegmentBuilder;
 use segment::types::PayloadFieldSchema::{FieldParams, FieldType};
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoLineString,
-    GeoPoint, GeoPolygon, GeoRadius, Indexes, IsEmptyCondition, Match, Payload, PayloadField,
-    PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
+    GeoPoint, GeoPolygon, GeoRadius, HnswConfig, Indexes, IsEmptyCondition, Match, Payload,
+    PayloadField, PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
     VectorStorageType, WithPayload,
 };
 use segment::utils::scored_point_ties::ScoredPointTies;
 use serde_json::json;
-use tempfile::Builder;
+use tempfile::{Builder, TempDir};
 
 const DIM: usize = 5;
 const ATTEMPTS: usize = 100;
 
-fn build_test_segments(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
-    let mut rnd = StdRng::seed_from_u64(42);
+struct TestSegments {
+    _base_dir: TempDir,
+    struct_segment: Segment,
+    plain_segment: Segment,
+    mmap_segment: Option<Segment>,
+}
 
-    let config = SegmentConfig {
-        vector_data: HashMap::from([(
-            DEFAULT_VECTOR_NAME.to_owned(),
-            VectorDataConfig {
-                size: DIM,
-                distance: Distance::Dot,
-                storage_type: VectorStorageType::Memory,
-                index: Indexes::Plain {},
-                quantization_config: None,
-                multivector_config: None,
-                datatype: None,
-            },
-        )]),
-        sparse_vector_data: Default::default(),
-        payload_storage_type: Default::default(),
-    };
+impl TestSegments {
+    fn new(make_mmap: bool) -> Self {
+        let base_dir = Builder::new().prefix("test_segments").tempdir().unwrap();
 
-    let mut plain_segment = build_segment(path_plain, &config, true).unwrap();
-    let mut struct_segment = build_segment(path_struct, &config, true).unwrap();
+        let mut rnd = StdRng::seed_from_u64(42);
 
-    let num_points = 3000;
-    let points_to_delete = 500;
-    let points_to_clear = 500;
+        let config = Self::make_simple_config(true);
 
-    let mut opnum = 0;
-    struct_segment
-        .create_field_index(opnum, &JsonPath::new(INT_KEY_2), Some(&Integer.into()))
-        .unwrap();
+        let mut plain_segment =
+            build_segment(&base_dir.path().join("plain"), &config, true).unwrap();
+        let mut struct_segment =
+            build_segment(&base_dir.path().join("struct"), &config, true).unwrap();
 
-    opnum += 1;
-    for n in 0..num_points {
-        let idx = n.into();
-        let vector = random_vector(&mut rnd, DIM);
-        let payload: Payload = generate_diverse_payload(&mut rnd);
+        let num_points = 3000;
+        let points_to_delete = 500;
+        let points_to_clear = 500;
 
-        plain_segment
-            .upsert_point(opnum, idx, only_default_vector(&vector))
+        let mut opnum = 0;
+        struct_segment
+            .create_field_index(opnum, &JsonPath::new(INT_KEY_2), Some(&Integer.into()))
+            .unwrap();
+
+        opnum += 1;
+        for n in 0..num_points {
+            let idx = n.into();
+            let vector = random_vector(&mut rnd, DIM);
+            let payload: Payload = generate_diverse_payload(&mut rnd);
+
+            plain_segment
+                .upsert_point(opnum, idx, only_default_vector(&vector))
+                .unwrap();
+            struct_segment
+                .upsert_point(opnum, idx, only_default_vector(&vector))
+                .unwrap();
+            plain_segment
+                .set_full_payload(opnum, idx, &payload)
+                .unwrap();
+            struct_segment
+                .set_full_payload(opnum, idx, &payload)
+                .unwrap();
+
+            opnum += 1;
+        }
+
+        struct_segment
+            .create_field_index(opnum, &JsonPath::new(STR_KEY), Some(&Keyword.into()))
             .unwrap();
         struct_segment
-            .upsert_point(opnum, idx, only_default_vector(&vector))
+            .create_field_index(opnum, &JsonPath::new(INT_KEY), None)
             .unwrap();
-        plain_segment
-            .set_full_payload(opnum, idx, &payload)
+        struct_segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY_2),
+                Some(&FieldParams(PayloadSchemaParams::Integer(
+                    IntegerIndexParams {
+                        r#type: IntegerIndexType::Integer,
+                        lookup: true,
+                        range: false,
+                        is_principal: None,
+                        on_disk: None,
+                    },
+                ))),
+            )
             .unwrap();
         struct_segment
-            .set_full_payload(opnum, idx, &payload)
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY_3),
+                Some(&FieldParams(PayloadSchemaParams::Integer(
+                    IntegerIndexParams {
+                        r#type: IntegerIndexType::Integer,
+                        lookup: false,
+                        range: true,
+                        is_principal: None,
+                        on_disk: None,
+                    },
+                ))),
+            )
+            .unwrap();
+        struct_segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(GEO_KEY),
+                Some(&PayloadSchemaType::Geo.into()),
+            )
+            .unwrap();
+        struct_segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(TEXT_KEY),
+                Some(&PayloadSchemaType::Text.into()),
+            )
+            .unwrap();
+        struct_segment
+            .create_field_index(opnum, &JsonPath::new(FLICKING_KEY), Some(&Integer.into()))
             .unwrap();
 
-        opnum += 1;
+        // Make mmap segment after inserting the points, but after deleting some of them
+        let mut mmap_segment = make_mmap
+            .then(|| Self::make_mmap_segment(&base_dir.path().join("mmap"), &plain_segment));
+
+        for _ in 0..points_to_clear {
+            opnum += 1;
+            let idx_to_remove = rnd.gen_range(0..num_points);
+            plain_segment
+                .clear_payload(opnum, idx_to_remove.into())
+                .unwrap();
+            struct_segment
+                .clear_payload(opnum, idx_to_remove.into())
+                .unwrap();
+            mmap_segment.as_mut().map(|mmap_segment| {
+                mmap_segment
+                    .clear_payload(opnum, idx_to_remove.into())
+                    .unwrap()
+            });
+        }
+
+        for _ in 0..points_to_delete {
+            opnum += 1;
+            let idx_to_remove = rnd.gen_range(0..num_points);
+            plain_segment
+                .delete_point(opnum, idx_to_remove.into())
+                .unwrap();
+            struct_segment
+                .delete_point(opnum, idx_to_remove.into())
+                .unwrap();
+            mmap_segment.as_mut().map(|mmap_segment| {
+                mmap_segment
+                    .delete_point(opnum, idx_to_remove.into())
+                    .unwrap()
+            });
+        }
+
+        for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
+            for index in indexes {
+                assert!(index.count_indexed_points() <= num_points as usize);
+                if field.to_string() != FLICKING_KEY {
+                    assert!(
+                        index.count_indexed_points()
+                            >= (num_points as usize - points_to_delete - points_to_clear)
+                    );
+                }
+            }
+        }
+
+        Self {
+            _base_dir: base_dir,
+            struct_segment,
+            plain_segment,
+            mmap_segment,
+        }
     }
 
-    struct_segment
-        .create_field_index(opnum, &JsonPath::new(STR_KEY), Some(&Keyword.into()))
-        .unwrap();
-    struct_segment
-        .create_field_index(opnum, &JsonPath::new(INT_KEY), None)
-        .unwrap();
-    struct_segment
-        .create_field_index(
-            opnum,
-            &JsonPath::new(INT_KEY_2),
-            Some(&FieldParams(PayloadSchemaParams::Integer(
-                IntegerIndexParams {
-                    r#type: IntegerIndexType::Integer,
-                    lookup: true,
-                    range: false,
-                    is_principal: None,
-                    on_disk: None,
+    fn make_simple_config(appendable: bool) -> SegmentConfig {
+        let conf = SegmentConfig {
+            vector_data: HashMap::from([(
+                DEFAULT_VECTOR_NAME.to_owned(),
+                VectorDataConfig {
+                    size: DIM,
+                    distance: Distance::Dot,
+                    storage_type: VectorStorageType::Memory,
+                    index: if appendable {
+                        Indexes::Plain {}
+                    } else {
+                        Indexes::Hnsw(HnswConfig::default())
+                    },
+                    quantization_config: None,
+                    multivector_config: None,
+                    datatype: None,
                 },
-            ))),
-        )
-        .unwrap();
-    struct_segment
-        .create_field_index(
-            opnum,
-            &JsonPath::new(INT_KEY_3),
-            Some(&FieldParams(PayloadSchemaParams::Integer(
-                IntegerIndexParams {
-                    r#type: IntegerIndexType::Integer,
-                    lookup: false,
-                    range: true,
-                    is_principal: None,
-                    on_disk: None,
-                },
-            ))),
-        )
-        .unwrap();
-    struct_segment
-        .create_field_index(
-            opnum,
-            &JsonPath::new(GEO_KEY),
-            Some(&PayloadSchemaType::Geo.into()),
-        )
-        .unwrap();
-    struct_segment
-        .create_field_index(
-            opnum,
-            &JsonPath::new(TEXT_KEY),
-            Some(&PayloadSchemaType::Text.into()),
+            )]),
+            sparse_vector_data: Default::default(),
+            payload_storage_type: Default::default(),
+        };
+        assert_eq!(conf.is_appendable(), appendable);
+        conf
+    }
+
+    fn make_mmap_segment(path: &Path, plain_segment: &Segment) -> Segment {
+        let stopped = AtomicBool::new(false);
+        create_dir(path).unwrap();
+
+        let mut builder = SegmentBuilder::new(
+            path,
+            &path.with_extension("tmp"),
+            &Self::make_simple_config(false),
         )
         .unwrap();
-    struct_segment
-        .create_field_index(opnum, &JsonPath::new(FLICKING_KEY), Some(&Integer.into()))
-        .unwrap();
 
-    for _ in 0..points_to_clear {
-        opnum += 1;
-        let idx_to_remove = rnd.gen_range(0..num_points);
-        plain_segment
-            .clear_payload(opnum, idx_to_remove.into())
+        builder.update(&[plain_segment], &stopped).unwrap();
+        let permit = CpuPermit::dummy(1);
+
+        let mut segment = builder.build(permit, &stopped).unwrap();
+        let opnum = segment.version() + 1;
+
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(STR_KEY),
+                Some(&FieldParams(PayloadSchemaParams::Keyword(
+                    KeywordIndexParams {
+                        r#type: KeywordIndexType::Keyword,
+                        is_tenant: None,
+                        on_disk: Some(true),
+                    },
+                ))),
+            )
             .unwrap();
-        struct_segment
-            .clear_payload(opnum, idx_to_remove.into())
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY),
+                Some(&FieldParams(PayloadSchemaParams::Integer(
+                    IntegerIndexParams {
+                        r#type: IntegerIndexType::Integer,
+                        lookup: true,
+                        range: true,
+                        is_principal: None,
+                        on_disk: Some(true),
+                    },
+                ))),
+            )
             .unwrap();
-    }
-
-    for _ in 0..points_to_delete {
-        opnum += 1;
-        let idx_to_remove = rnd.gen_range(0..num_points);
-        plain_segment
-            .delete_point(opnum, idx_to_remove.into())
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY_2),
+                Some(&FieldParams(PayloadSchemaParams::Integer(
+                    IntegerIndexParams {
+                        r#type: IntegerIndexType::Integer,
+                        lookup: true,
+                        range: false,
+                        is_principal: None,
+                        on_disk: Some(true),
+                    },
+                ))),
+            )
             .unwrap();
-        struct_segment
-            .delete_point(opnum, idx_to_remove.into())
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY_3),
+                Some(&FieldParams(PayloadSchemaParams::Integer(
+                    IntegerIndexParams {
+                        r#type: IntegerIndexType::Integer,
+                        lookup: false,
+                        range: true,
+                        is_principal: None,
+                        on_disk: Some(true),
+                    },
+                ))),
+            )
+            .unwrap();
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(FLT_KEY),
+                Some(&FieldParams(PayloadSchemaParams::Float(FloatIndexParams {
+                    r#type: FloatIndexType::Float,
+                    is_principal: None,
+                    on_disk: Some(true),
+                }))),
+            )
             .unwrap();
-    }
 
-    for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
-        for index in indexes {
-            assert!(index.count_indexed_points() <= num_points as usize);
-            if field.to_string() != FLICKING_KEY {
-                assert!(
-                    index.count_indexed_points()
-                        >= (num_points as usize - points_to_delete - points_to_clear)
-                );
-            }
-        }
+        segment
     }
-
-    (struct_segment, plain_segment)
 }
 
 fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
@@ -299,12 +438,11 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 fn validate_geo_filter(query_filter: Filter) {
     let mut rnd = rand::thread_rng();
     let query = random_vector(&mut rnd, DIM).into();
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(false);
 
     for _i in 0..ATTEMPTS {
-        let plain_result = plain_segment
+        let plain_result = test_segments
+            .plain_segment
             .search(
                 DEFAULT_VECTOR_NAME,
                 &query,
@@ -316,7 +454,8 @@ fn validate_geo_filter(query_filter: Filter) {
             )
             .unwrap();
 
-        let estimation = plain_segment
+        let estimation = test_segments
+            .plain_segment
             .payload_index
             .borrow()
             .estimate_cardinality(&query_filter);
@@ -324,11 +463,17 @@ fn validate_geo_filter(query_filter: Filter) {
         assert!(estimation.min <= estimation.exp, "{estimation:#?}");
         assert!(estimation.exp <= estimation.max, "{estimation:#?}");
         assert!(
-            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            estimation.max
+                <= test_segments
+                    .struct_segment
+                    .id_tracker
+                    .borrow()
+                    .available_point_count(),
             "{estimation:#?}",
         );
 
-        let struct_result = struct_segment
+        let struct_result = test_segments
+            .struct_segment
             .search(
                 DEFAULT_VECTOR_NAME,
                 &query,
@@ -340,7 +485,8 @@ fn validate_geo_filter(query_filter: Filter) {
             )
             .unwrap();
 
-        let estimation = struct_segment
+        let estimation = test_segments
+            .struct_segment
             .payload_index
             .borrow()
             .estimate_cardinality(&query_filter);
@@ -348,7 +494,12 @@ fn validate_geo_filter(query_filter: Filter) {
         assert!(estimation.min <= estimation.exp, "{estimation:#?}");
         assert!(estimation.exp <= estimation.max, "{estimation:#?}");
         assert!(
-            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            estimation.max
+                <= test_segments
+                    .struct_segment
+                    .id_tracker
+                    .borrow()
+                    .available_point_count(),
             "{estimation:#?}",
         );
 
@@ -364,10 +515,7 @@ fn validate_geo_filter(query_filter: Filter) {
 
 #[test]
 fn test_is_empty_conditions() {
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
-    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(false);
 
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
@@ -375,21 +523,31 @@ fn test_is_empty_conditions() {
         },
     }));
 
-    let estimation_struct = struct_segment
+    let estimation_struct = test_segments
+        .struct_segment
         .payload_index
         .borrow()
         .estimate_cardinality(&filter);
 
-    let estimation_plain = plain_segment
+    let estimation_plain = test_segments
+        .plain_segment
         .payload_index
         .borrow()
         .estimate_cardinality(&filter);
 
-    let plain_result = plain_segment.payload_index.borrow().query_points(&filter);
+    let plain_result = test_segments
+        .plain_segment
+        .payload_index
+        .borrow()
+        .query_points(&filter);
 
     let real_number = plain_result.len();
 
-    let struct_result = struct_segment.payload_index.borrow().query_points(&filter);
+    let struct_result = test_segments
+        .struct_segment
+        .payload_index
+        .borrow()
+        .query_points(&filter);
 
     assert_eq!(plain_result, struct_result);
 
@@ -411,44 +569,54 @@ fn test_is_empty_conditions() {
 
 #[test]
 fn test_integer_index_types() {
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
-    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
-
-    let indexes = struct_segment.payload_index.borrow();
-    assert!(matches!(
-        indexes
-            .field_indexes
-            .get(&JsonPath::new(INT_KEY))
-            .unwrap()
-            .as_slice(),
-        [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)]
-    ));
-    assert!(matches!(
-        indexes
-            .field_indexes
-            .get(&JsonPath::new(INT_KEY_2))
-            .unwrap()
-            .as_slice(),
-        [FieldIndex::IntMapIndex(_)]
-    ));
-    assert!(matches!(
-        indexes
-            .field_indexes
-            .get(&JsonPath::new(INT_KEY_3))
-            .unwrap()
-            .as_slice(),
-        [FieldIndex::IntIndex(_)]
-    ));
+    let test_segments = TestSegments::new(true);
+
+    for (kind, indexes) in [
+        (
+            "struct",
+            &test_segments.struct_segment.payload_index.borrow(),
+        ),
+        (
+            "mmap",
+            &test_segments
+                .mmap_segment
+                .as_ref()
+                .unwrap()
+                .payload_index
+                .borrow(),
+        ),
+    ] {
+        eprintln!("Checking {kind}_segment");
+        assert!(matches!(
+            indexes
+                .field_indexes
+                .get(&JsonPath::new(INT_KEY))
+                .unwrap()
+                .as_slice(),
+            [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)],
+        ));
+        assert!(matches!(
+            indexes
+                .field_indexes
+                .get(&JsonPath::new(INT_KEY_2))
+                .unwrap()
+                .as_slice(),
+            [FieldIndex::IntMapIndex(_)],
+        ));
+        assert!(matches!(
+            indexes
+                .field_indexes
+                .get(&JsonPath::new(INT_KEY_3))
+                .unwrap()
+                .as_slice(),
+            [FieldIndex::IntIndex(_)],
+        ));
+    }
 }
 
 #[test]
 fn test_cardinality_estimation() {
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
-    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(false);
 
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
         JsonPath::new(INT_KEY),
@@ -460,14 +628,16 @@ fn test_cardinality_estimation() {
         },
     )));
 
-    let estimation = struct_segment
+    let estimation = test_segments
+        .struct_segment
         .payload_index
         .borrow()
         .estimate_cardinality(&filter);
 
-    let payload_index = struct_segment.payload_index.borrow();
+    let payload_index = test_segments.struct_segment.payload_index.borrow();
     let filter_context = payload_index.filter_context(&filter);
-    let exact = struct_segment
+    let exact = test_segments
+        .struct_segment
         .id_tracker
         .borrow()
         .iter_ids()
@@ -600,21 +770,19 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
     assert!(exact >= estimation.min);
 }
 
+/// Compare search with plain, struct, and mmap indices.
 #[test]
 fn test_struct_payload_index() {
-    // Compare search with plain and struct indexes
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
     let mut rnd = rand::thread_rng();
 
-    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(true);
 
     for _i in 0..ATTEMPTS {
         let query_vector = random_vector(&mut rnd, DIM).into();
         let query_filter = random_filter(&mut rnd, 3);
 
-        let plain_result = plain_segment
+        let plain_result = test_segments
+            .plain_segment
             .search(
                 DEFAULT_VECTOR_NAME,
                 &query_vector,
@@ -625,7 +793,22 @@ fn test_struct_payload_index() {
                 None,
             )
             .unwrap();
-        let struct_result = struct_segment
+        let struct_result = test_segments
+            .struct_segment
+            .search(
+                DEFAULT_VECTOR_NAME,
+                &query_vector,
+                &WithPayload::default(),
+                &false.into(),
+                Some(&query_filter),
+                5,
+                None,
+            )
+            .unwrap();
+        let mmap_result = test_segments
+            .mmap_segment
+            .as_ref()
+            .unwrap()
             .search(
                 DEFAULT_VECTOR_NAME,
                 &query_vector,
@@ -637,7 +820,8 @@ fn test_struct_payload_index() {
             )
             .unwrap();
 
-        let estimation = struct_segment
+        let estimation = test_segments
+            .struct_segment
             .payload_index
             .borrow()
             .estimate_cardinality(&query_filter);
@@ -645,7 +829,12 @@ fn test_struct_payload_index() {
         assert!(estimation.min <= estimation.exp, "{estimation:#?}");
         assert!(estimation.exp <= estimation.max, "{estimation:#?}");
         assert!(
-            estimation.max <= struct_segment.id_tracker.borrow().available_point_count(),
+            estimation.max
+                <= test_segments
+                    .struct_segment
+                    .id_tracker
+                    .borrow()
+                    .available_point_count(),
             "{estimation:#?}",
         );
 
@@ -658,14 +847,53 @@ fn test_struct_payload_index() {
             struct_result.iter().map(|x| x.into()).collect_vec();
         struct_result_sorted_ties.sort();
 
-        plain_result_sorted_ties
-            .into_iter()
-            .zip(struct_result_sorted_ties.into_iter())
-            .map(|(r1, r2)| (r1.0, r2.0))
-            .for_each(|(r1, r2)| {
-                assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
-                assert!((r1.score - r2.score) < 0.0001)
-            });
+        let mut mmap_result_sorted_ties: Vec<ScoredPointTies> =
+            mmap_result.iter().map(|x| x.into()).collect_vec();
+        mmap_result_sorted_ties.sort();
+
+        assert_eq!(
+            plain_result_sorted_ties.len(),
+            struct_result_sorted_ties.len(),
+            "query vector {query_vector:?}\n\
+            query filter {query_filter:?}\n\
+            plain result {plain_result:?}\n\
+            struct result{struct_result:?}",
+        );
+        assert_eq!(
+            plain_result_sorted_ties.len(),
+            mmap_result_sorted_ties.len(),
+            "query vector {query_vector:?}\n\
+            query filter {query_filter:?}\n\
+            plain result {plain_result:?}\n\
+            mmap result  {mmap_result:?}",
+        );
+
+        itertools::izip!(
+            plain_result_sorted_ties,
+            struct_result_sorted_ties,
+            mmap_result_sorted_ties,
+        )
+        .map(|(r1, r2, r3)| (r1.0, r2.0, r3.0))
+        .for_each(|(r1, r2, r3)| {
+            assert_eq!(
+                r1.id, r2.id,
+                "got different ScoredPoint {r1:?} and {r2:?} for\n\
+                query vector {query_vector:?}\n\
+                query filter {query_filter:?}\n\
+                plain result {plain_result:?}\n\
+                struct result{struct_result:?}",
+            );
+            assert!((r1.score - r2.score) < 0.0001);
+            assert_eq!(
+                r1.id, r3.id,
+                "got different ScoredPoint {r1:?} and {r3:?} for\n\
+                query vector {query_vector:?}\n\
+                query filter {query_filter:?}\n\
+                plain result {plain_result:?}\n\
+                mmap result  {mmap_result:?}",
+            );
+            assert!((r1.score - r3.score) < 0.0001);
+        });
     }
 }
 
@@ -819,7 +1047,14 @@ fn test_struct_payload_index_nested_fields() {
             .iter()
             .zip(struct_result.iter())
             .for_each(|(r1, r2)| {
-                assert_eq!(r1.id, r2.id, "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}");
+                assert_eq!(
+                    r1.id, r2.id,
+                    "got different ScoredPoint {r1:?} and {r2:?} for\n\
+                    query vector {query_vector:?}\n\
+                    query filter {query_filter:?}\n\
+                    plain result {plain_result:?}\n\
+                    struct result{struct_result:?}"
+                );
                 assert!((r1.score - r2.score) < 0.0001)
             });
     }
@@ -888,10 +1123,7 @@ fn test_update_payload_index_type() {
 
 #[test]
 fn test_any_matcher_cardinality_estimation() {
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
-    let (struct_segment, _) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(false);
 
     let keywords: IndexSet<String, FnvBuildHasher> = ["value1", "value2"]
         .iter()
@@ -904,7 +1136,8 @@ fn test_any_matcher_cardinality_estimation() {
 
     let filter = Filter::new_must(Condition::Field(any_match.clone()));
 
-    let estimation = struct_segment
+    let estimation = test_segments
+        .struct_segment
         .payload_index
         .borrow()
         .estimate_cardinality(&filter);
@@ -921,9 +1154,10 @@ fn test_any_matcher_cardinality_estimation() {
         }
     }
 
-    let payload_index = struct_segment.payload_index.borrow();
+    let payload_index = test_segments.struct_segment.payload_index.borrow();
     let filter_context = payload_index.filter_context(&filter);
-    let exact = struct_segment
+    let exact = test_segments
+        .struct_segment
         .id_tracker
         .borrow()
         .iter_ids()
@@ -938,7 +1172,8 @@ fn test_any_matcher_cardinality_estimation() {
     assert!(exact >= estimation.min);
 }
 
-/// Checks that it is ordered in descending order, and that the counts are the same as counting each value exactly.
+/// Checks that it is ordered in descending order, and that the counts are the same as counting
+/// each value exactly.
 fn validate_facet_result(
     segment: &Segment,
     facet_hits: Vec<FacetValueHit>,
@@ -968,10 +1203,7 @@ fn validate_facet_result(
 
 #[test]
 fn test_keyword_facet() {
-    let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
-    let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
-
-    let (struct_segment, plain_segment) = build_test_segments(dir1.path(), dir2.path());
+    let test_segments = TestSegments::new(false);
 
     let limit = 100;
     let key: JsonPath = STR_KEY.try_into().unwrap();
@@ -984,11 +1216,17 @@ fn test_keyword_facet() {
     };
 
     // Plain segment should fail, as it does not have a keyword index
-    assert!(plain_segment.facet(&request, &Default::default()).is_err());
-
-    let facet_hits = struct_segment.facet(&request, &Default::default()).unwrap();
+    assert!(test_segments
+        .plain_segment
+        .facet(&request, &Default::default())
+        .is_err());
+
+    let facet_hits = test_segments
+        .struct_segment
+        .facet(&request, &Default::default())
+        .unwrap();
 
-    validate_facet_result(&struct_segment, facet_hits, None);
+    validate_facet_result(&test_segments.struct_segment, facet_hits, None);
 
     // *** With filter ***
     let mut rng = rand::thread_rng();
@@ -999,7 +1237,10 @@ fn test_keyword_facet() {
         filter: Some(filter.clone()),
     };
 
-    let facet_hits = struct_segment.facet(&request, &Default::default()).unwrap();
+    let facet_hits = test_segments
+        .struct_segment
+        .facet(&request, &Default::default())
+        .unwrap();
 
-    validate_facet_result(&struct_segment, facet_hits, Some(filter))
+    validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter));
 }

commit 10b05c3ed84024f4aeaad5e97e24bd0b0ec421d2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Aug 5 19:05:45 2024 +0200

    Make scroll cancellable (#4827)
    
    * Make scroll cancellable
    
    * comments and fix
    
    * better comment

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index e91a3499e..5c87ea3db 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1179,6 +1179,7 @@ fn validate_facet_result(
     facet_hits: Vec<FacetValueHit>,
     filter: Option<Filter>,
 ) {
+    let is_stopped = AtomicBool::new(false);
     let mut expected = facet_hits.clone();
     expected.sort_by_key(|hit| Reverse(hit.clone()));
     assert_eq!(facet_hits, expected);
@@ -1194,7 +1195,7 @@ fn validate_facet_result(
         let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
 
         let exact = segment
-            .read_filtered(None, None, count_filter.as_ref())
+            .read_filtered(None, None, count_filter.as_ref(), &is_stopped)
             .len();
 
         assert_eq!(hit.count, exact);

commit e37a9ea2d5aa93fc328a7cc9764f9732f69243d2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Aug 19 10:52:27 2024 +0200

    make range and lookup params optional (#4905)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 5c87ea3db..3a75cde43 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -114,8 +114,8 @@ impl TestSegments {
                 Some(&FieldParams(PayloadSchemaParams::Integer(
                     IntegerIndexParams {
                         r#type: IntegerIndexType::Integer,
-                        lookup: true,
-                        range: false,
+                        lookup: Some(true),
+                        range: Some(false),
                         is_principal: None,
                         on_disk: None,
                     },
@@ -129,8 +129,8 @@ impl TestSegments {
                 Some(&FieldParams(PayloadSchemaParams::Integer(
                     IntegerIndexParams {
                         r#type: IntegerIndexType::Integer,
-                        lookup: false,
-                        range: true,
+                        lookup: Some(false),
+                        range: Some(true),
                         is_principal: None,
                         on_disk: None,
                     },
@@ -273,8 +273,8 @@ impl TestSegments {
                 Some(&FieldParams(PayloadSchemaParams::Integer(
                     IntegerIndexParams {
                         r#type: IntegerIndexType::Integer,
-                        lookup: true,
-                        range: true,
+                        lookup: Some(true),
+                        range: Some(true),
                         is_principal: None,
                         on_disk: Some(true),
                     },
@@ -288,8 +288,8 @@ impl TestSegments {
                 Some(&FieldParams(PayloadSchemaParams::Integer(
                     IntegerIndexParams {
                         r#type: IntegerIndexType::Integer,
-                        lookup: true,
-                        range: false,
+                        lookup: Some(true),
+                        range: Some(false),
                         is_principal: None,
                         on_disk: Some(true),
                     },
@@ -303,8 +303,8 @@ impl TestSegments {
                 Some(&FieldParams(PayloadSchemaParams::Integer(
                     IntegerIndexParams {
                         r#type: IntegerIndexType::Integer,
-                        lookup: false,
-                        range: true,
+                        lookup: Some(false),
+                        range: Some(true),
                         is_principal: None,
                         on_disk: Some(true),
                     },

commit ace8a90259561eb483a4ffefa1ab28d65ad1e1a5
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Aug 19 16:03:26 2024 -0400

    Facets in REST (#4848)
    
    * rename to FacetRequestInternal
    
    * add rest endpoint
    
    * fix correctness by fetching the whole list of values
    
    * fix mmap map index variant
    
    Also removes test for sorted output, for now
    
    * add ytt spec
    
    * fix clippy
    
    * use hashmap inside of local shard
    
    * rename operation to `facet`, add access test
    
    * whitelist endpoint
    
    * change api
    
    * make limit optional

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 3a75cde43..a9e12da73 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1,4 +1,3 @@
-use std::cmp::Reverse;
 use std::collections::HashMap;
 use std::fs::create_dir;
 use std::path::Path;
@@ -13,7 +12,7 @@ use indexmap::IndexSet;
 use itertools::Itertools;
 use rand::prelude::StdRng;
 use rand::{Rng, SeedableRng};
-use segment::data_types::facets::{FacetRequest, FacetValue, FacetValueHit};
+use segment::data_types::facets::{FacetParams, FacetValue};
 use segment::data_types::index::{
     FloatIndexParams, FloatIndexType, IntegerIndexParams, IntegerIndexType, KeywordIndexParams,
     KeywordIndexType,
@@ -1176,17 +1175,12 @@ fn test_any_matcher_cardinality_estimation() {
 /// each value exactly.
 fn validate_facet_result(
     segment: &Segment,
-    facet_hits: Vec<FacetValueHit>,
+    facet_hits: HashMap<FacetValue, usize>,
     filter: Option<Filter>,
 ) {
-    let is_stopped = AtomicBool::new(false);
-    let mut expected = facet_hits.clone();
-    expected.sort_by_key(|hit| Reverse(hit.clone()));
-    assert_eq!(facet_hits, expected);
-
-    for hit in facet_hits {
+    for (value, count) in facet_hits {
         // Compare against exact count
-        let FacetValue::Keyword(value) = hit.value;
+        let FacetValue::Keyword(value) = value;
 
         let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
             JsonPath::new(STR_KEY),
@@ -1195,22 +1189,22 @@ fn validate_facet_result(
         let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
 
         let exact = segment
-            .read_filtered(None, None, count_filter.as_ref(), &is_stopped)
+            .read_filtered(None, None, count_filter.as_ref(), &Default::default())
             .len();
 
-        assert_eq!(hit.count, exact);
+        assert_eq!(count, exact);
     }
 }
 
 #[test]
 fn test_keyword_facet() {
-    let test_segments = TestSegments::new(false);
+    let test_segments = TestSegments::new(true);
 
     let limit = 100;
     let key: JsonPath = STR_KEY.try_into().unwrap();
 
-    // *** No filter ***
-    let request = FacetRequest {
+    // *** Without filter ***
+    let request = FacetParams {
         key: key.clone(),
         limit,
         filter: None,
@@ -1222,6 +1216,7 @@ fn test_keyword_facet() {
         .facet(&request, &Default::default())
         .is_err());
 
+    // Struct segment
     let facet_hits = test_segments
         .struct_segment
         .facet(&request, &Default::default())
@@ -1229,19 +1224,52 @@ fn test_keyword_facet() {
 
     validate_facet_result(&test_segments.struct_segment, facet_hits, None);
 
+    // Mmap segment
+    let facet_hits = test_segments
+        .mmap_segment
+        .as_ref()
+        .unwrap()
+        .facet(&request, &Default::default())
+        .unwrap();
+
+    validate_facet_result(
+        test_segments.mmap_segment.as_ref().unwrap(),
+        facet_hits,
+        None,
+    );
+
     // *** With filter ***
     let mut rng = rand::thread_rng();
     let filter = random_filter(&mut rng, 3);
-    let request = FacetRequest {
+    let request = FacetParams {
         key,
         limit,
         filter: Some(filter.clone()),
     };
 
+    // Struct segment
     let facet_hits = test_segments
         .struct_segment
         .facet(&request, &Default::default())
         .unwrap();
 
-    validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter));
+    validate_facet_result(
+        &test_segments.struct_segment,
+        facet_hits,
+        Some(filter.clone()),
+    );
+
+    // Mmap segment
+    let facet_hits = test_segments
+        .mmap_segment
+        .as_ref()
+        .unwrap()
+        .facet(&request, &Default::default())
+        .unwrap();
+
+    validate_facet_result(
+        test_segments.mmap_segment.as_ref().unwrap(),
+        facet_hits,
+        Some(filter),
+    );
 }

commit 3185dd23c50f02e8f38c10839ff622fc2bd3a072
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Aug 19 23:21:17 2024 -0400

    Exact facet mode (#4878)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index a9e12da73..34612dfa5 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1171,8 +1171,7 @@ fn test_any_matcher_cardinality_estimation() {
     assert!(exact >= estimation.min);
 }
 
-/// Checks that it is ordered in descending order, and that the counts are the same as counting
-/// each value exactly.
+/// Checks that the counts are the same as counting each value exactly.
 fn validate_facet_result(
     segment: &Segment,
     facet_hits: HashMap<FacetValue, usize>,
@@ -1202,12 +1201,14 @@ fn test_keyword_facet() {
 
     let limit = 100;
     let key: JsonPath = STR_KEY.try_into().unwrap();
+    let exact = false; // This is only used at local shard level
 
     // *** Without filter ***
     let request = FacetParams {
         key: key.clone(),
         limit,
         filter: None,
+        exact,
     };
 
     // Plain segment should fail, as it does not have a keyword index
@@ -1245,6 +1246,7 @@ fn test_keyword_facet() {
         key,
         limit,
         filter: Some(filter.clone()),
+        exact,
     };
 
     // Struct segment

commit 90449b30d672bce523b4b01cf9ff30eabbaa702f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 20 10:12:20 2024 -0400

    perf: Limit bad performance of filtered faceting (#4903)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 34612dfa5..81d343578 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1177,9 +1177,9 @@ fn validate_facet_result(
     facet_hits: HashMap<FacetValue, usize>,
     filter: Option<Filter>,
 ) {
-    for (value, count) in facet_hits {
+    for (value, count) in facet_hits.iter() {
         // Compare against exact count
-        let FacetValue::Keyword(value) = value;
+        let FacetValue::Keyword(value) = value.to_owned();
 
         let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
             JsonPath::new(STR_KEY),
@@ -1191,7 +1191,7 @@ fn validate_facet_result(
             .read_filtered(None, None, count_filter.as_ref(), &Default::default())
             .len();
 
-        assert_eq!(count, exact);
+        assert_eq!(*count, exact);
     }
 }
 

commit 287f287bbd98f53c1dd29583149dec7234f29c2c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 27 00:53:30 2024 +0200

    Implement better handling of UUID index (#4961)
    
    * rename keyword -> string for internal data structures
    
    * implement MatchAny and expect for filter on UUID mmap index
    
    * implement MatchAny and expect for cardinality estimation on UUID mmap index
    
    * refactor PayloadFieldIndex filter for handling incorrect empty query parsing case

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 81d343578..9c029d183 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1130,7 +1130,7 @@ fn test_any_matcher_cardinality_estimation() {
         .collect();
     let any_match = FieldCondition::new_match(
         JsonPath::new(STR_KEY),
-        Match::new_any(AnyVariants::Keywords(keywords)),
+        Match::new_any(AnyVariants::Strings(keywords)),
     );
 
     let filter = Filter::new_must(Condition::Field(any_match.clone()));

commit 4b429214cc3feeede5d5ab2912fad76523219c4e
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 27 11:30:57 2024 -0400

    Integer and UUID facets (#4946)
    
    * move FacetIndex into facet_index.rs
    
    * add support for integer facets
    
    * add support for uuid facets
    
    * use separate internal structure
    
    * rename FacetValue::Keyword into FacetValue::String in REST
    
    * fix after rebase

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 9c029d183..5d6f08f72 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -39,8 +39,8 @@ use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoLineString,
     GeoPoint, GeoPolygon, GeoRadius, HnswConfig, Indexes, IsEmptyCondition, Match, Payload,
-    PayloadField, PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
-    VectorStorageType, WithPayload,
+    PayloadField, PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, ValueVariants,
+    VectorDataConfig, VectorStorageType, WithPayload,
 };
 use segment::utils::scored_point_ties::ScoredPointTies;
 use serde_json::json;
@@ -1179,7 +1179,7 @@ fn validate_facet_result(
 ) {
     for (value, count) in facet_hits.iter() {
         // Compare against exact count
-        let FacetValue::Keyword(value) = value.to_owned();
+        let value = ValueVariants::from(value.clone());
 
         let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
             JsonPath::new(STR_KEY),

commit 4f59f72c02e6b62f027c88888831c1bf60f24019
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 16 12:42:11 2024 +0200

    Rename payload storage operations for consistency (#5087)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 5d6f08f72..241bcfbc1 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1078,7 +1078,7 @@ fn test_update_payload_index_type() {
     for (idx, payload) in payloads.into_iter().enumerate() {
         points.insert(idx, payload.clone());
         payload_storage
-            .assign(idx as PointOffsetType, &payload)
+            .set(idx as PointOffsetType, &payload)
             .unwrap();
     }
 

commit cf8971503637f3d089670d74df81e31fb76f4fcf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Sep 16 16:27:30 2024 -0300

    Expose `on_disk` text index (#5074)
    
    * map index: fix reachable code marked as unreachable
    
    * plumber work to get mmap text index to interfaces
    
    * test: add fixture for mmap text index, always create mmap segment
    
    * various fixes
    
    - ensure dir is created for mmap
    - implement is_on_disk() for text index
    - invert deleted condition for filter in mmap inverted index
    
    * update grpc docs and openapi
    
    * implement return of files
    
    * review nit
    
    * fix after rebase
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 241bcfbc1..60f2988c0 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -15,7 +15,7 @@ use rand::{Rng, SeedableRng};
 use segment::data_types::facets::{FacetParams, FacetValue};
 use segment::data_types::index::{
     FloatIndexParams, FloatIndexType, IntegerIndexParams, IntegerIndexType, KeywordIndexParams,
-    KeywordIndexType,
+    KeywordIndexType, TextIndexParams, TextIndexType,
 };
 use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
 use segment::entry::entry_point::SegmentEntry;
@@ -53,11 +53,11 @@ struct TestSegments {
     _base_dir: TempDir,
     struct_segment: Segment,
     plain_segment: Segment,
-    mmap_segment: Option<Segment>,
+    mmap_segment: Segment,
 }
 
 impl TestSegments {
-    fn new(make_mmap: bool) -> Self {
+    fn new() -> Self {
         let base_dir = Builder::new().prefix("test_segments").tempdir().unwrap();
 
         let mut rnd = StdRng::seed_from_u64(42);
@@ -155,8 +155,8 @@ impl TestSegments {
             .unwrap();
 
         // Make mmap segment after inserting the points, but after deleting some of them
-        let mut mmap_segment = make_mmap
-            .then(|| Self::make_mmap_segment(&base_dir.path().join("mmap"), &plain_segment));
+        let mut mmap_segment =
+            Self::make_mmap_segment(&base_dir.path().join("mmap"), &plain_segment);
 
         for _ in 0..points_to_clear {
             opnum += 1;
@@ -167,11 +167,9 @@ impl TestSegments {
             struct_segment
                 .clear_payload(opnum, idx_to_remove.into())
                 .unwrap();
-            mmap_segment.as_mut().map(|mmap_segment| {
-                mmap_segment
-                    .clear_payload(opnum, idx_to_remove.into())
-                    .unwrap()
-            });
+            mmap_segment
+                .clear_payload(opnum, idx_to_remove.into())
+                .unwrap();
         }
 
         for _ in 0..points_to_delete {
@@ -183,11 +181,9 @@ impl TestSegments {
             struct_segment
                 .delete_point(opnum, idx_to_remove.into())
                 .unwrap();
-            mmap_segment.as_mut().map(|mmap_segment| {
-                mmap_segment
-                    .delete_point(opnum, idx_to_remove.into())
-                    .unwrap()
-            });
+            mmap_segment
+                .delete_point(opnum, idx_to_remove.into())
+                .unwrap();
         }
 
         for (field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
@@ -321,6 +317,17 @@ impl TestSegments {
                 }))),
             )
             .unwrap();
+        segment
+            .create_field_index(
+                opnum,
+                &JsonPath::new(TEXT_KEY),
+                Some(&FieldParams(PayloadSchemaParams::Text(TextIndexParams {
+                    r#type: TextIndexType::Text,
+                    on_disk: Some(true),
+                    ..Default::default()
+                }))),
+            )
+            .unwrap();
 
         segment
     }
@@ -437,7 +444,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 fn validate_geo_filter(query_filter: Filter) {
     let mut rnd = rand::thread_rng();
     let query = random_vector(&mut rnd, DIM).into();
-    let test_segments = TestSegments::new(false);
+    let test_segments = TestSegments::new();
 
     for _i in 0..ATTEMPTS {
         let plain_result = test_segments
@@ -514,7 +521,7 @@ fn validate_geo_filter(query_filter: Filter) {
 
 #[test]
 fn test_is_empty_conditions() {
-    let test_segments = TestSegments::new(false);
+    let test_segments = TestSegments::new();
 
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
@@ -568,22 +575,14 @@ fn test_is_empty_conditions() {
 
 #[test]
 fn test_integer_index_types() {
-    let test_segments = TestSegments::new(true);
+    let test_segments = TestSegments::new();
 
     for (kind, indexes) in [
         (
             "struct",
             &test_segments.struct_segment.payload_index.borrow(),
         ),
-        (
-            "mmap",
-            &test_segments
-                .mmap_segment
-                .as_ref()
-                .unwrap()
-                .payload_index
-                .borrow(),
-        ),
+        ("mmap", &test_segments.mmap_segment.payload_index.borrow()),
     ] {
         eprintln!("Checking {kind}_segment");
         assert!(matches!(
@@ -615,7 +614,7 @@ fn test_integer_index_types() {
 
 #[test]
 fn test_cardinality_estimation() {
-    let test_segments = TestSegments::new(false);
+    let test_segments = TestSegments::new();
 
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
         JsonPath::new(INT_KEY),
@@ -774,7 +773,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 fn test_struct_payload_index() {
     let mut rnd = rand::thread_rng();
 
-    let test_segments = TestSegments::new(true);
+    let test_segments = TestSegments::new();
 
     for _i in 0..ATTEMPTS {
         let query_vector = random_vector(&mut rnd, DIM).into();
@@ -806,8 +805,6 @@ fn test_struct_payload_index() {
             .unwrap();
         let mmap_result = test_segments
             .mmap_segment
-            .as_ref()
-            .unwrap()
             .search(
                 DEFAULT_VECTOR_NAME,
                 &query_vector,
@@ -1122,7 +1119,7 @@ fn test_update_payload_index_type() {
 
 #[test]
 fn test_any_matcher_cardinality_estimation() {
-    let test_segments = TestSegments::new(false);
+    let test_segments = TestSegments::new();
 
     let keywords: IndexSet<String, FnvBuildHasher> = ["value1", "value2"]
         .iter()
@@ -1197,7 +1194,7 @@ fn validate_facet_result(
 
 #[test]
 fn test_keyword_facet() {
-    let test_segments = TestSegments::new(true);
+    let test_segments = TestSegments::new();
 
     let limit = 100;
     let key: JsonPath = STR_KEY.try_into().unwrap();
@@ -1228,16 +1225,10 @@ fn test_keyword_facet() {
     // Mmap segment
     let facet_hits = test_segments
         .mmap_segment
-        .as_ref()
-        .unwrap()
         .facet(&request, &Default::default())
         .unwrap();
 
-    validate_facet_result(
-        test_segments.mmap_segment.as_ref().unwrap(),
-        facet_hits,
-        None,
-    );
+    validate_facet_result(&test_segments.mmap_segment, facet_hits, None);
 
     // *** With filter ***
     let mut rng = rand::thread_rng();
@@ -1264,14 +1255,8 @@ fn test_keyword_facet() {
     // Mmap segment
     let facet_hits = test_segments
         .mmap_segment
-        .as_ref()
-        .unwrap()
         .facet(&request, &Default::default())
         .unwrap();
 
-    validate_facet_result(
-        test_segments.mmap_segment.as_ref().unwrap(),
-        facet_hits,
-        Some(filter),
-    );
+    validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter));
 }

commit bcf05d9e231d55f0c4317081c36d3ebc0a2de8c8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Oct 25 18:47:03 2024 +0200

    HasVector filtering condition (#5303)
    
    * include vector storage into struct vector index
    
    * implement has_vector
    
    * generate schemas
    
    * refactor query filter optimizer so avoid too many function arguments
    
    * test + fix for sparse vectors
    
    * Update lib/segment/src/index/struct_payload_index.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * Update lib/segment/src/index/query_optimization/optimizer.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * fmt
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 60f2988c0..48fd17291 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1082,8 +1082,14 @@ fn test_update_payload_index_type() {
     let wrapped_payload_storage = Arc::new(AtomicRefCell::new(payload_storage.into()));
     let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(point_num)));
 
-    let mut index =
-        StructPayloadIndex::open(wrapped_payload_storage, id_tracker, dir.path(), true).unwrap();
+    let mut index = StructPayloadIndex::open(
+        wrapped_payload_storage,
+        id_tracker,
+        HashMap::new(),
+        dir.path(),
+        true,
+    )
+    .unwrap();
 
     let field = JsonPath::new("field");
 

commit c3068aaf272e63195c6bde395cf5d4021026d061
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 18 11:03:18 2024 +0100

    Fix clippy large variant for filter condition (#5455)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 48fd17291..efc9d8530 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -683,7 +683,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
 
     match primary_clause {
         PrimaryCondition::Condition(field_condition) => {
-            assert_eq!(field_condition, &expected_primary_clause);
+            assert_eq!(*field_condition, Box::new(expected_primary_clause));
         }
         o => panic!("unexpected primary clause: {o:?}"),
     }
@@ -746,7 +746,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 
     match primary_clause {
         PrimaryCondition::Condition(field_condition) => {
-            assert_eq!(field_condition, &expected_primary_clause);
+            assert_eq!(*field_condition, Box::new(expected_primary_clause));
         }
         o => panic!("unexpected primary clause: {o:?}"),
     }
@@ -1150,7 +1150,7 @@ fn test_any_matcher_cardinality_estimation() {
 
         match clause {
             PrimaryCondition::Condition(field_condition) => {
-                assert_eq!(field_condition, &expected_primary_clause);
+                assert_eq!(*field_condition, Box::new(expected_primary_clause));
             }
             o => panic!("unexpected primary clause: {o:?}"),
         }

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index efc9d8530..82d2d66ec 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -5,6 +5,7 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use fnv::FnvBuildHasher;
@@ -60,6 +61,8 @@ impl TestSegments {
     fn new() -> Self {
         let base_dir = Builder::new().prefix("test_segments").tempdir().unwrap();
 
+        let hw_counter = HardwareCounterCell::new();
+
         let mut rnd = StdRng::seed_from_u64(42);
 
         let config = Self::make_simple_config(true);
@@ -85,16 +88,16 @@ impl TestSegments {
             let payload: Payload = generate_diverse_payload(&mut rnd);
 
             plain_segment
-                .upsert_point(opnum, idx, only_default_vector(&vector))
+                .upsert_point(opnum, idx, only_default_vector(&vector), &hw_counter)
                 .unwrap();
             struct_segment
-                .upsert_point(opnum, idx, only_default_vector(&vector))
+                .upsert_point(opnum, idx, only_default_vector(&vector), &hw_counter)
                 .unwrap();
             plain_segment
-                .set_full_payload(opnum, idx, &payload)
+                .set_full_payload(opnum, idx, &payload, &hw_counter)
                 .unwrap();
             struct_segment
-                .set_full_payload(opnum, idx, &payload)
+                .set_full_payload(opnum, idx, &payload, &hw_counter)
                 .unwrap();
 
             opnum += 1;
@@ -162,13 +165,13 @@ impl TestSegments {
             opnum += 1;
             let idx_to_remove = rnd.gen_range(0..num_points);
             plain_segment
-                .clear_payload(opnum, idx_to_remove.into())
+                .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
             struct_segment
-                .clear_payload(opnum, idx_to_remove.into())
+                .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
             mmap_segment
-                .clear_payload(opnum, idx_to_remove.into())
+                .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
         }
 
@@ -176,13 +179,13 @@ impl TestSegments {
             opnum += 1;
             let idx_to_remove = rnd.gen_range(0..num_points);
             plain_segment
-                .delete_point(opnum, idx_to_remove.into())
+                .delete_point(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
             struct_segment
-                .delete_point(opnum, idx_to_remove.into())
+                .delete_point(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
             mmap_segment
-                .delete_point(opnum, idx_to_remove.into())
+                .delete_point(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
         }
 
@@ -384,6 +387,8 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
     eprintln!("{deep_nested_str_proj_key}");
 
+    let hw_counter = HardwareCounterCell::new();
+
     opnum += 1;
     for n in 0..num_points {
         let idx = n.into();
@@ -391,16 +396,16 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         let payload: Payload = generate_diverse_nested_payload(&mut rnd);
 
         plain_segment
-            .upsert_point(opnum, idx, only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector), &hw_counter)
             .unwrap();
         struct_segment
-            .upsert_point(opnum, idx, only_default_vector(&vector))
+            .upsert_point(opnum, idx, only_default_vector(&vector), &hw_counter)
             .unwrap();
         plain_segment
-            .set_full_payload(opnum, idx, &payload)
+            .set_full_payload(opnum, idx, &payload, &hw_counter)
             .unwrap();
         struct_segment
-            .set_full_payload(opnum, idx, &payload)
+            .set_full_payload(opnum, idx, &payload, &hw_counter)
             .unwrap();
 
         opnum += 1;
@@ -410,10 +415,10 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         opnum += 1;
         let idx_to_remove = rnd.gen_range(0..num_points);
         plain_segment
-            .clear_payload(opnum, idx_to_remove.into())
+            .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
         struct_segment
-            .clear_payload(opnum, idx_to_remove.into())
+            .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
     }
 
@@ -421,10 +426,10 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         opnum += 1;
         let idx_to_remove = rnd.gen_range(0..num_points);
         plain_segment
-            .delete_point(opnum, idx_to_remove.into())
+            .delete_point(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
         struct_segment
-            .delete_point(opnum, idx_to_remove.into())
+            .delete_point(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
     }
 

commit b0eb8d3431b19ed8beaeb1ceee7872d07d620314
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 10:58:25 2025 +0100

    Io measurement rename functions (#5816)
    
    * replace _measured functions with original name
    
    * Rename more functions

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 82d2d66ec..2b551b87f 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1077,10 +1077,12 @@ fn test_update_payload_index_type() {
         payloads.push(payload.into());
     }
 
+    let hw_counter = HardwareCounterCell::new();
+
     for (idx, payload) in payloads.into_iter().enumerate() {
         points.insert(idx, payload.clone());
         payload_storage
-            .set(idx as PointOffsetType, &payload)
+            .set(idx as PointOffsetType, &payload, &hw_counter)
             .unwrap();
     }
 

commit 97743b1b625d42f73955ecb32d54ca34ea3a5cb7
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jan 24 16:33:44 2025 +0100

    Propagate hardware counter for more functions (#5844)
    
    * Propagate hardware counter for more functions
    
    * Minor improvements
    
    * use vector_query_contexts hardware_counter

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 2b551b87f..17eb29aa7 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -534,6 +534,8 @@ fn test_is_empty_conditions() {
         },
     }));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let estimation_struct = test_segments
         .struct_segment
         .payload_index
@@ -550,7 +552,7 @@ fn test_is_empty_conditions() {
         .plain_segment
         .payload_index
         .borrow()
-        .query_points(&filter);
+        .query_points(&filter, &hw_counter);
 
     let real_number = plain_result.len();
 
@@ -558,7 +560,7 @@ fn test_is_empty_conditions() {
         .struct_segment
         .payload_index
         .borrow()
-        .query_points(&filter);
+        .query_points(&filter, &hw_counter);
 
     assert_eq!(plain_result, struct_result);
 
@@ -637,8 +639,10 @@ fn test_cardinality_estimation() {
         .borrow()
         .estimate_cardinality(&filter);
 
+    let hw_counter = HardwareCounterCell::new();
+
     let payload_index = test_segments.struct_segment.payload_index.borrow();
-    let filter_context = payload_index.filter_context(&filter);
+    let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = test_segments
         .struct_segment
         .id_tracker
@@ -693,8 +697,10 @@ fn test_root_nested_array_filter_cardinality_estimation() {
         o => panic!("unexpected primary clause: {o:?}"),
     }
 
+    let hw_counter = HardwareCounterCell::new();
+
     let payload_index = struct_segment.payload_index.borrow();
-    let filter_context = payload_index.filter_context(&filter);
+    let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = struct_segment
         .id_tracker
         .borrow()
@@ -756,8 +762,10 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
         o => panic!("unexpected primary clause: {o:?}"),
     }
 
+    let hw_counter = HardwareCounterCell::new();
+
     let payload_index = struct_segment.payload_index.borrow();
-    let filter_context = payload_index.filter_context(&filter);
+    let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = struct_segment
         .id_tracker
         .borrow()
@@ -1163,8 +1171,10 @@ fn test_any_matcher_cardinality_estimation() {
         }
     }
 
+    let hw_counter = HardwareCounterCell::new();
+
     let payload_index = test_segments.struct_segment.payload_index.borrow();
-    let filter_context = payload_index.filter_context(&filter);
+    let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = test_segments
         .struct_segment
         .id_tracker
@@ -1187,6 +1197,8 @@ fn validate_facet_result(
     facet_hits: HashMap<FacetValue, usize>,
     filter: Option<Filter>,
 ) {
+    let hw_counter = HardwareCounterCell::new();
+
     for (value, count) in facet_hits.iter() {
         // Compare against exact count
         let value = ValueVariants::from(value.clone());
@@ -1198,7 +1210,13 @@ fn validate_facet_result(
         let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
 
         let exact = segment
-            .read_filtered(None, None, count_filter.as_ref(), &Default::default())
+            .read_filtered(
+                None,
+                None,
+                count_filter.as_ref(),
+                &Default::default(),
+                &hw_counter,
+            )
             .len();
 
         assert_eq!(*count, exact);
@@ -1221,16 +1239,18 @@ fn test_keyword_facet() {
         exact,
     };
 
+    let hw_counter = HardwareCounterCell::new();
+
     // Plain segment should fail, as it does not have a keyword index
     assert!(test_segments
         .plain_segment
-        .facet(&request, &Default::default())
+        .facet(&request, &Default::default(), &hw_counter)
         .is_err());
 
     // Struct segment
     let facet_hits = test_segments
         .struct_segment
-        .facet(&request, &Default::default())
+        .facet(&request, &Default::default(), &hw_counter)
         .unwrap();
 
     validate_facet_result(&test_segments.struct_segment, facet_hits, None);
@@ -1238,7 +1258,7 @@ fn test_keyword_facet() {
     // Mmap segment
     let facet_hits = test_segments
         .mmap_segment
-        .facet(&request, &Default::default())
+        .facet(&request, &Default::default(), &hw_counter)
         .unwrap();
 
     validate_facet_result(&test_segments.mmap_segment, facet_hits, None);
@@ -1256,7 +1276,7 @@ fn test_keyword_facet() {
     // Struct segment
     let facet_hits = test_segments
         .struct_segment
-        .facet(&request, &Default::default())
+        .facet(&request, &Default::default(), &hw_counter)
         .unwrap();
 
     validate_facet_result(
@@ -1268,7 +1288,7 @@ fn test_keyword_facet() {
     // Mmap segment
     let facet_hits = test_segments
         .mmap_segment
-        .facet(&request, &Default::default())
+        .facet(&request, &Default::default(), &hw_counter)
         .unwrap();
 
     validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter));

commit 6e1316bfb5e916378e41a4776a0205b555e950cd
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jan 28 09:35:02 2025 +0000

    Add payload_json! macro (#5881)
    
    * Add payload_json! macro
    
    * Replace usage of `json!({...})` with `payload_json! {...}`
    
    * Drop `impl From<Value> for Payload`

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 17eb29aa7..62dd34a34 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -30,6 +30,7 @@ use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::PayloadIndex;
 use segment::json_path::JsonPath;
+use segment::payload_json;
 use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
@@ -44,7 +45,6 @@ use segment::types::{
     VectorDataConfig, VectorStorageType, WithPayload,
 };
 use segment::utils::scored_point_ties::ScoredPointTies;
-use serde_json::json;
 use tempfile::{Builder, TempDir};
 
 const DIM: usize = 5;
@@ -1079,10 +1079,7 @@ fn test_update_payload_index_type() {
 
     let mut payloads: Vec<Payload> = vec![];
     for i in 0..point_num {
-        let payload = json!({
-            "field": i,
-        });
-        payloads.push(payload.into());
+        payloads.push(payload_json! {"field": i});
     }
 
     let hw_counter = HardwareCounterCell::new();

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 62dd34a34..eb6082c52 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -163,7 +163,7 @@ impl TestSegments {
 
         for _ in 0..points_to_clear {
             opnum += 1;
-            let idx_to_remove = rnd.gen_range(0..num_points);
+            let idx_to_remove = rnd.random_range(0..num_points);
             plain_segment
                 .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
@@ -177,7 +177,7 @@ impl TestSegments {
 
         for _ in 0..points_to_delete {
             opnum += 1;
-            let idx_to_remove = rnd.gen_range(0..num_points);
+            let idx_to_remove = rnd.random_range(0..num_points);
             plain_segment
                 .delete_point(opnum, idx_to_remove.into(), &hw_counter)
                 .unwrap();
@@ -413,7 +413,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
     for _ in 0..points_to_clear {
         opnum += 1;
-        let idx_to_remove = rnd.gen_range(0..num_points);
+        let idx_to_remove = rnd.random_range(0..num_points);
         plain_segment
             .clear_payload(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
@@ -424,7 +424,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 
     for _ in 0..points_to_delete {
         opnum += 1;
-        let idx_to_remove = rnd.gen_range(0..num_points);
+        let idx_to_remove = rnd.random_range(0..num_points);
         plain_segment
             .delete_point(opnum, idx_to_remove.into(), &hw_counter)
             .unwrap();
@@ -447,7 +447,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 }
 
 fn validate_geo_filter(query_filter: Filter) {
-    let mut rnd = rand::thread_rng();
+    let mut rnd = rand::rng();
     let query = random_vector(&mut rnd, DIM).into();
     let test_segments = TestSegments::new();
 
@@ -784,7 +784,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 /// Compare search with plain, struct, and mmap indices.
 #[test]
 fn test_struct_payload_index() {
-    let mut rnd = rand::thread_rng();
+    let mut rnd = rand::rng();
 
     let test_segments = TestSegments::new();
 
@@ -908,16 +908,16 @@ fn test_struct_payload_index() {
 
 #[test]
 fn test_struct_payload_geo_boundingbox_index() {
-    let mut rnd = rand::thread_rng();
+    let mut rnd = rand::rng();
 
     let geo_bbox = GeoBoundingBox {
         top_left: GeoPoint {
-            lon: rnd.gen_range(LON_RANGE),
-            lat: rnd.gen_range(LAT_RANGE),
+            lon: rnd.random_range(LON_RANGE),
+            lat: rnd.random_range(LAT_RANGE),
         },
         bottom_right: GeoPoint {
-            lon: rnd.gen_range(LON_RANGE),
-            lat: rnd.gen_range(LAT_RANGE),
+            lon: rnd.random_range(LON_RANGE),
+            lat: rnd.random_range(LAT_RANGE),
         },
     };
 
@@ -933,13 +933,13 @@ fn test_struct_payload_geo_boundingbox_index() {
 
 #[test]
 fn test_struct_payload_geo_radius_index() {
-    let mut rnd = rand::thread_rng();
+    let mut rnd = rand::rng();
 
-    let r_meters = rnd.gen_range(1.0..10000.0);
+    let r_meters = rnd.random_range(1.0..10000.0);
     let geo_radius = GeoRadius {
         center: GeoPoint {
-            lon: rnd.gen_range(LON_RANGE),
-            lat: rnd.gen_range(LAT_RANGE),
+            lon: rnd.random_range(LON_RANGE),
+            lat: rnd.random_range(LAT_RANGE),
         },
         radius: r_meters,
     };
@@ -960,12 +960,12 @@ fn test_struct_payload_geo_polygon_index() {
     let interiors_num = 3;
 
     fn generate_ring(polygon_edge: i32) -> GeoLineString {
-        let mut rnd = rand::thread_rng();
+        let mut rnd = rand::rng();
         let mut line = GeoLineString {
             points: (0..polygon_edge)
                 .map(|_| GeoPoint {
-                    lon: rnd.gen_range(LON_RANGE),
-                    lat: rnd.gen_range(LAT_RANGE),
+                    lon: rnd.random_range(LON_RANGE),
+                    lat: rnd.random_range(LAT_RANGE),
                 })
                 .collect(),
         };
@@ -1001,7 +1001,7 @@ fn test_struct_payload_index_nested_fields() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
     let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
 
-    let mut rnd = rand::thread_rng();
+    let mut rnd = rand::rng();
 
     let (struct_segment, plain_segment) =
         build_test_segments_nested_payload(dir1.path(), dir2.path());
@@ -1261,7 +1261,7 @@ fn test_keyword_facet() {
     validate_facet_result(&test_segments.mmap_segment, facet_hits, None);
 
     // *** With filter ***
-    let mut rng = rand::thread_rng();
+    let mut rng = rand::rng();
     let filter = random_filter(&mut rng, 3);
     let request = FacetParams {
         key,

commit cf3240d923ed0d85b1101f49d10068d885c68f1c
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jan 30 20:15:33 2025 +0000

    Use `simple_segment_constructor` (#5919)
    
    * VECTOR1_NAME and VECTOR2_NAME
    
    * Use simple_segment_constructor

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index eb6082c52..0621ccc04 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -36,6 +36,7 @@ use segment::payload_storage::PayloadStorage;
 use segment::segment::Segment;
 use segment::segment_constructor::build_segment;
 use segment::segment_constructor::segment_builder::SegmentBuilder;
+use segment::segment_constructor::simple_segment_constructor::build_simple_segment;
 use segment::types::PayloadFieldSchema::{FieldParams, FieldType};
 use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
@@ -339,25 +340,8 @@ impl TestSegments {
 fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let config = SegmentConfig {
-        vector_data: HashMap::from([(
-            DEFAULT_VECTOR_NAME.to_owned(),
-            VectorDataConfig {
-                size: DIM,
-                distance: Distance::Dot,
-                storage_type: VectorStorageType::Memory,
-                index: Indexes::Plain {},
-                quantization_config: None,
-                multivector_config: None,
-                datatype: None,
-            },
-        )]),
-        sparse_vector_data: Default::default(),
-        payload_storage_type: Default::default(),
-    };
-
-    let mut plain_segment = build_segment(path_plain, &config, true).unwrap();
-    let mut struct_segment = build_segment(path_struct, &config, true).unwrap();
+    let mut plain_segment = build_simple_segment(path_plain, DIM, Distance::Dot).unwrap();
+    let mut struct_segment = build_simple_segment(path_struct, DIM, Distance::Dot).unwrap();
 
     let num_points = 3000;
     let points_to_delete = 500;

commit 217ad7336c8bcf80f86fed7ba7867e71b057d2f3
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Feb 17 13:44:37 2025 -0300

    [score boosting] evaluate formula (#5980)
    
    * evaluate expressions, given resolved variables
    
    * lazily resolve variables and conditions
    
    * optimize multiplication and division evaluation
    
    * review fix
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 0621ccc04..bdb4bf221 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -953,7 +953,7 @@ fn test_struct_payload_geo_polygon_index() {
                 })
                 .collect(),
         };
-        line.points.push(line.points[0].clone()); // add last point that is identical to the first
+        line.points.push(line.points[0]); // add last point that is identical to the first
         line
     }
 

commit caed5729e5b7ff3db9dcb4531a4af0929b186682
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 09:05:00 2025 +0100

    IO resource usage permit (#6015)
    
    * rename cpu_budget -> resource_budget
    
    * clippy
    
    * add io budget to resources
    
    * fmt
    
    * move budget structures into a separate file
    
    * add extend permit function
    
    * dont extend existing permit
    
    * switch from IO to CPU permit
    
    * do not release resource before aquiring an extension
    
    * fmt
    
    * Review remarks
    
    * Improve resource permit number assertion
    
    * Make resource permit replace_with only acquire extra needed permits
    
    * Remove obsolete drop implementation
    
    * allocate IO budget same as CPU
    
    * review fixes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index bdb4bf221..092eb0675 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -5,8 +5,8 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::budget::ResourcePermit;
 use common::counter::hardware_counter::HardwareCounterCell;
-use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use fnv::FnvBuildHasher;
 use indexmap::IndexSet;
@@ -247,7 +247,7 @@ impl TestSegments {
         .unwrap();
 
         builder.update(&[plain_segment], &stopped).unwrap();
-        let permit = CpuPermit::dummy(1);
+        let permit = ResourcePermit::dummy(1);
 
         let mut segment = builder.build(permit, &stopped).unwrap();
         let opnum = segment.version() + 1;

commit 0a15b0d655f41c44653211e131628c328941990d
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Feb 21 09:27:39 2025 -0300

    Fix flaky `test_keyword_facet` test (#6034)
    
    * improve facet tests
    
    * remove iter_filtered_counts_per_value
    
    * clarify comment
    
    * bugfix: add filter for deleted bitslice
    
    * clarify comment in compressed point mappings

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 092eb0675..597c5f7a5 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -2,7 +2,7 @@ use std::collections::HashMap;
 use std::fs::create_dir;
 use std::path::Path;
 use std::sync::atomic::AtomicBool;
-use std::sync::Arc;
+use std::sync::{Arc, OnceLock};
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
@@ -158,7 +158,7 @@ impl TestSegments {
             .create_field_index(opnum, &JsonPath::new(FLICKING_KEY), Some(&Integer.into()))
             .unwrap();
 
-        // Make mmap segment after inserting the points, but after deleting some of them
+        // Make mmap segment after inserting the points, but before deleting some of them
         let mut mmap_segment =
             Self::make_mmap_segment(&base_dir.path().join("mmap"), &plain_segment);
 
@@ -337,6 +337,13 @@ impl TestSegments {
     }
 }
 
+/// Fixture for read operations, so that multiple tests can reuse it without expensive segment creation.
+fn get_read_only_segments() -> &'static TestSegments {
+    static SEGMENTS: OnceLock<TestSegments> = OnceLock::new();
+
+    SEGMENTS.get_or_init(TestSegments::new)
+}
+
 fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
     let mut rnd = StdRng::seed_from_u64(42);
 
@@ -1172,6 +1179,21 @@ fn test_any_matcher_cardinality_estimation() {
     assert!(exact >= estimation.min);
 }
 
+/// FacetParams fixture without a filter
+fn keyword_facet_request() -> FacetParams {
+    let limit = 1000;
+    let key: JsonPath = STR_KEY.try_into().unwrap();
+    let exact = false; // This is only used at local shard level
+
+    // *** Without filter ***
+    FacetParams {
+        key: key.clone(),
+        limit,
+        filter: None,
+        exact,
+    }
+}
+
 /// Checks that the counts are the same as counting each value exactly.
 fn validate_facet_result(
     segment: &Segment,
@@ -1186,7 +1208,7 @@ fn validate_facet_result(
 
         let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
             JsonPath::new(STR_KEY),
-            Match::from(value),
+            Match::from(value.clone()),
         )));
         let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
 
@@ -1200,77 +1222,79 @@ fn validate_facet_result(
             )
             .len();
 
-        assert_eq!(*count, exact);
+        assert_eq!(*count, exact, "Facet value: {value:?}");
     }
 }
 
 #[test]
-fn test_keyword_facet() {
-    let test_segments = TestSegments::new();
-
-    let limit = 100;
-    let key: JsonPath = STR_KEY.try_into().unwrap();
-    let exact = false; // This is only used at local shard level
-
-    // *** Without filter ***
-    let request = FacetParams {
-        key: key.clone(),
-        limit,
-        filter: None,
-        exact,
-    };
+fn test_struct_keyword_facet() {
+    let test_segments = get_read_only_segments();
 
-    let hw_counter = HardwareCounterCell::new();
+    let request = keyword_facet_request();
 
     // Plain segment should fail, as it does not have a keyword index
     assert!(test_segments
         .plain_segment
-        .facet(&request, &Default::default(), &hw_counter)
+        .facet(&request, &Default::default(), &Default::default())
         .is_err());
 
     // Struct segment
     let facet_hits = test_segments
         .struct_segment
-        .facet(&request, &Default::default(), &hw_counter)
+        .facet(&request, &Default::default(), &Default::default())
         .unwrap();
 
     validate_facet_result(&test_segments.struct_segment, facet_hits, None);
+}
+
+#[test]
+fn test_mmap_keyword_facet() {
+    let test_segments = get_read_only_segments();
+
+    let request = keyword_facet_request();
 
-    // Mmap segment
     let facet_hits = test_segments
         .mmap_segment
-        .facet(&request, &Default::default(), &hw_counter)
+        .facet(&request, &Default::default(), &Default::default())
         .unwrap();
 
     validate_facet_result(&test_segments.mmap_segment, facet_hits, None);
+}
 
-    // *** With filter ***
-    let mut rng = rand::rng();
-    let filter = random_filter(&mut rng, 3);
-    let request = FacetParams {
-        key,
-        limit,
-        filter: Some(filter.clone()),
-        exact,
-    };
+#[test]
+fn test_struct_keyword_facet_filtered() {
+    let test_segments = get_read_only_segments();
 
-    // Struct segment
-    let facet_hits = test_segments
-        .struct_segment
-        .facet(&request, &Default::default(), &hw_counter)
-        .unwrap();
+    let mut request = keyword_facet_request();
 
-    validate_facet_result(
-        &test_segments.struct_segment,
-        facet_hits,
-        Some(filter.clone()),
-    );
+    for _ in 0..10 {
+        let filter = random_filter(&mut rand::rng(), 3);
+        request.filter = Some(filter.clone());
 
-    // Mmap segment
-    let facet_hits = test_segments
-        .mmap_segment
-        .facet(&request, &Default::default(), &hw_counter)
-        .unwrap();
+        let facet_hits = test_segments
+            .struct_segment
+            .facet(&request, &Default::default(), &Default::default())
+            .unwrap();
+
+        validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter));
+    }
+}
+
+#[test]
+fn test_mmap_keyword_facet_filtered() {
+    let test_segments = get_read_only_segments();
+
+    let mut request = keyword_facet_request();
 
-    validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter));
+    for _ in 0..10 {
+        let filter = random_filter(&mut rand::rng(), 3);
+        request.filter = Some(filter.clone());
+
+        let facet_hits = test_segments
+            .mmap_segment
+            .facet(&request, &Default::default(), &Default::default())
+            .unwrap();
+
+        validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter));
+    }
 }

commit a7c121b9201e454eb34ca1fd2ec4e4efd3267d9a
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Feb 24 13:55:17 2025 -0300

    Reuse fixture in payload index test (#6041)

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 597c5f7a5..c2331bd7a 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -2,8 +2,9 @@ use std::collections::HashMap;
 use std::fs::create_dir;
 use std::path::Path;
 use std::sync::atomic::AtomicBool;
-use std::sync::{Arc, OnceLock};
+use std::sync::Arc;
 
+use anyhow::{Context, Result};
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
 use common::counter::hardware_counter::HardwareCounterCell;
@@ -48,8 +49,23 @@ use segment::types::{
 use segment::utils::scored_point_ties::ScoredPointTies;
 use tempfile::{Builder, TempDir};
 
+macro_rules! here {
+    () => {
+        format!("at {}:{}", file!(), line!())
+    };
+}
+
+/// `anyhow::ensure!` but with location, as what `assert!` would do
+macro_rules! ensure {
+    ($($arg:tt)*) => {
+        (|| Ok(anyhow::ensure!($($arg)*)))().map_err(|e| {
+            e.context(here!())
+        })?
+    };
+}
+
 const DIM: usize = 5;
-const ATTEMPTS: usize = 100;
+const ATTEMPTS: usize = 20;
 
 struct TestSegments {
     _base_dir: TempDir,
@@ -337,13 +353,6 @@ impl TestSegments {
     }
 }
 
-/// Fixture for read operations, so that multiple tests can reuse it without expensive segment creation.
-fn get_read_only_segments() -> &'static TestSegments {
-    static SEGMENTS: OnceLock<TestSegments> = OnceLock::new();
-
-    SEGMENTS.get_or_init(TestSegments::new)
-}
-
 fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) -> (Segment, Segment) {
     let mut rnd = StdRng::seed_from_u64(42);
 
@@ -437,12 +446,11 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
     (struct_segment, plain_segment)
 }
 
-fn validate_geo_filter(query_filter: Filter) {
+fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Result<()> {
     let mut rnd = rand::rng();
-    let query = random_vector(&mut rnd, DIM).into();
-    let test_segments = TestSegments::new();
 
     for _i in 0..ATTEMPTS {
+        let query = random_vector(&mut rnd, DIM).into();
         let plain_result = test_segments
             .plain_segment
             .search(
@@ -462,9 +470,9 @@ fn validate_geo_filter(query_filter: Filter) {
             .borrow()
             .estimate_cardinality(&query_filter);
 
-        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
-        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
-        assert!(
+        ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
+        ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
+        ensure!(
             estimation.max
                 <= test_segments
                     .struct_segment
@@ -493,9 +501,9 @@ fn validate_geo_filter(query_filter: Filter) {
             .borrow()
             .estimate_cardinality(&query_filter);
 
-        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
-        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
-        assert!(
+        ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
+        ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
+        ensure!(
             estimation.max
                 <= test_segments
                     .struct_segment
@@ -505,20 +513,48 @@ fn validate_geo_filter(query_filter: Filter) {
             "{estimation:#?}",
         );
 
-        plain_result
-            .iter()
-            .zip(struct_result.iter())
-            .for_each(|(r1, r2)| {
-                assert_eq!(r1.id, r2.id);
-                assert!((r1.score - r2.score) < 0.0001)
-            });
+        for (r1, r2) in plain_result.iter().zip(struct_result.iter()) {
+            ensure!(r1.id == r2.id);
+            ensure!((r1.score - r2.score) < 0.0001)
+        }
     }
+
+    Ok(())
 }
 
+/// Test read operations on segments.
+/// The segments fixtures are created only once to improve test speed.
 #[test]
-fn test_is_empty_conditions() {
-    let test_segments = TestSegments::new();
+fn test_read_operations() -> Result<()> {
+    let test_segments = Arc::new(TestSegments::new());
+    let mut handles = vec![];
+
+    for test_fn in [
+        test_is_empty_conditions,
+        test_integer_index_types,
+        test_cardinality_estimation,
+        test_struct_payload_index,
+        test_struct_payload_geo_boundingbox_index,
+        test_struct_payload_geo_radius_index,
+        test_struct_payload_geo_polygon_index,
+        test_any_matcher_cardinality_estimation,
+        test_struct_keyword_facet,
+        test_mmap_keyword_facet,
+        test_struct_keyword_facet_filtered,
+        test_mmap_keyword_facet_filtered,
+    ] {
+        let segments = Arc::clone(&test_segments);
+        handles.push(std::thread::spawn(move || test_fn(&segments)));
+    }
+
+    for handle in handles {
+        handle.join().unwrap()?;
+    }
 
+    Ok(())
+}
+
+fn test_is_empty_conditions(test_segments: &TestSegments) -> Result<()> {
     let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
         is_empty: PayloadField {
             key: JsonPath::new(FLICKING_KEY),
@@ -553,28 +589,27 @@ fn test_is_empty_conditions() {
         .borrow()
         .query_points(&filter, &hw_counter);
 
-    assert_eq!(plain_result, struct_result);
+    ensure!(plain_result == struct_result);
 
     eprintln!("estimation_plain = {estimation_plain:#?}");
     eprintln!("estimation_struct = {estimation_struct:#?}");
     eprintln!("real_number = {real_number:#?}");
 
-    assert!(estimation_plain.max >= real_number);
-    assert!(estimation_plain.min <= real_number);
+    ensure!(estimation_plain.max >= real_number);
+    ensure!(estimation_plain.min <= real_number);
 
-    assert!(estimation_struct.max >= real_number);
-    assert!(estimation_struct.min <= real_number);
+    ensure!(estimation_struct.max >= real_number);
+    ensure!(estimation_struct.min <= real_number);
 
-    assert!(
+    ensure!(
         (estimation_struct.exp as f64 - real_number as f64).abs()
             <= (estimation_plain.exp as f64 - real_number as f64).abs()
     );
-}
 
-#[test]
-fn test_integer_index_types() {
-    let test_segments = TestSegments::new();
+    Ok(())
+}
 
+fn test_integer_index_types(test_segments: &TestSegments) -> Result<()> {
     for (kind, indexes) in [
         (
             "struct",
@@ -583,7 +618,7 @@ fn test_integer_index_types() {
         ("mmap", &test_segments.mmap_segment.payload_index.borrow()),
     ] {
         eprintln!("Checking {kind}_segment");
-        assert!(matches!(
+        ensure!(matches!(
             indexes
                 .field_indexes
                 .get(&JsonPath::new(INT_KEY))
@@ -591,7 +626,7 @@ fn test_integer_index_types() {
                 .as_slice(),
             [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)],
         ));
-        assert!(matches!(
+        ensure!(matches!(
             indexes
                 .field_indexes
                 .get(&JsonPath::new(INT_KEY_2))
@@ -599,7 +634,7 @@ fn test_integer_index_types() {
                 .as_slice(),
             [FieldIndex::IntMapIndex(_)],
         ));
-        assert!(matches!(
+        ensure!(matches!(
             indexes
                 .field_indexes
                 .get(&JsonPath::new(INT_KEY_3))
@@ -608,12 +643,10 @@ fn test_integer_index_types() {
             [FieldIndex::IntIndex(_)],
         ));
     }
+    Ok(())
 }
 
-#[test]
-fn test_cardinality_estimation() {
-    let test_segments = TestSegments::new();
-
+fn test_cardinality_estimation(test_segments: &TestSegments) -> Result<()> {
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_range(
         JsonPath::new(INT_KEY),
         Range {
@@ -646,8 +679,10 @@ fn test_cardinality_estimation() {
     eprintln!("exact = {exact:#?}");
     eprintln!("estimation = {estimation:#?}");
 
-    assert!(exact <= estimation.max);
-    assert!(exact >= estimation.min);
+    ensure!(exact <= estimation.max);
+    ensure!(exact >= estimation.min);
+
+    Ok(())
 }
 
 #[test]
@@ -773,12 +808,9 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 }
 
 /// Compare search with plain, struct, and mmap indices.
-#[test]
-fn test_struct_payload_index() {
+fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
     let mut rnd = rand::rng();
 
-    let test_segments = TestSegments::new();
-
     for _i in 0..ATTEMPTS {
         let query_vector = random_vector(&mut rnd, DIM).into();
         let query_filter = random_filter(&mut rnd, 3);
@@ -826,9 +858,9 @@ fn test_struct_payload_index() {
             .borrow()
             .estimate_cardinality(&query_filter);
 
-        assert!(estimation.min <= estimation.exp, "{estimation:#?}");
-        assert!(estimation.exp <= estimation.max, "{estimation:#?}");
-        assert!(
+        ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
+        ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
+        ensure!(
             estimation.max
                 <= test_segments
                     .struct_segment
@@ -851,54 +883,52 @@ fn test_struct_payload_index() {
             mmap_result.iter().map(|x| x.into()).collect_vec();
         mmap_result_sorted_ties.sort();
 
-        assert_eq!(
-            plain_result_sorted_ties.len(),
-            struct_result_sorted_ties.len(),
+        ensure!(
+            plain_result_sorted_ties.len() == struct_result_sorted_ties.len(),
             "query vector {query_vector:?}\n\
             query filter {query_filter:?}\n\
             plain result {plain_result:?}\n\
             struct result{struct_result:?}",
         );
-        assert_eq!(
-            plain_result_sorted_ties.len(),
-            mmap_result_sorted_ties.len(),
+        ensure!(
+            plain_result_sorted_ties.len() == mmap_result_sorted_ties.len(),
             "query vector {query_vector:?}\n\
             query filter {query_filter:?}\n\
             plain result {plain_result:?}\n\
             mmap result  {mmap_result:?}",
         );
 
-        itertools::izip!(
+        for (r1, r2, r3) in itertools::izip!(
             plain_result_sorted_ties,
             struct_result_sorted_ties,
             mmap_result_sorted_ties,
         )
         .map(|(r1, r2, r3)| (r1.0, r2.0, r3.0))
-        .for_each(|(r1, r2, r3)| {
-            assert_eq!(
-                r1.id, r2.id,
+        {
+            ensure!(
+                r1.id == r2.id,
                 "got different ScoredPoint {r1:?} and {r2:?} for\n\
                 query vector {query_vector:?}\n\
                 query filter {query_filter:?}\n\
                 plain result {plain_result:?}\n\
-                struct result{struct_result:?}",
+                struct result{struct_result:?}"
             );
-            assert!((r1.score - r2.score) < 0.0001);
-            assert_eq!(
-                r1.id, r3.id,
+            ensure!((r1.score - r2.score) < 0.0001);
+            ensure!(
+                r1.id == r3.id,
                 "got different ScoredPoint {r1:?} and {r3:?} for\n\
                 query vector {query_vector:?}\n\
                 query filter {query_filter:?}\n\
                 plain result {plain_result:?}\n\
                 mmap result  {mmap_result:?}",
             );
-            assert!((r1.score - r3.score) < 0.0001);
-        });
+            ensure!((r1.score - r3.score) < 0.0001);
+        }
     }
+    Ok(())
 }
 
-#[test]
-fn test_struct_payload_geo_boundingbox_index() {
+fn test_struct_payload_geo_boundingbox_index(test_segments: &TestSegments) -> Result<()> {
     let mut rnd = rand::rng();
 
     let geo_bbox = GeoBoundingBox {
@@ -919,11 +949,10 @@ fn test_struct_payload_geo_boundingbox_index() {
 
     let query_filter = Filter::new_must(condition);
 
-    validate_geo_filter(query_filter)
+    validate_geo_filter(test_segments, query_filter).context(here!())
 }
 
-#[test]
-fn test_struct_payload_geo_radius_index() {
+fn test_struct_payload_geo_radius_index(test_segments: &TestSegments) -> Result<()> {
     let mut rnd = rand::rng();
 
     let r_meters = rnd.random_range(1.0..10000.0);
@@ -942,11 +971,10 @@ fn test_struct_payload_geo_radius_index() {
 
     let query_filter = Filter::new_must(condition);
 
-    validate_geo_filter(query_filter)
+    validate_geo_filter(test_segments, query_filter).context(here!())
 }
 
-#[test]
-fn test_struct_payload_geo_polygon_index() {
+fn test_struct_payload_geo_polygon_index(test_segments: &TestSegments) -> Result<()> {
     let polygon_edge = 5;
     let interiors_num = 3;
 
@@ -983,7 +1011,7 @@ fn test_struct_payload_geo_polygon_index() {
 
     let query_filter = Filter::new_must(condition);
 
-    validate_geo_filter(query_filter)
+    validate_geo_filter(test_segments, query_filter).context(here!())
 }
 
 #[test]
@@ -1126,10 +1154,7 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 }
 
-#[test]
-fn test_any_matcher_cardinality_estimation() {
-    let test_segments = TestSegments::new();
-
+fn test_any_matcher_cardinality_estimation(test_segments: &TestSegments) -> Result<()> {
     let keywords: IndexSet<String, FnvBuildHasher> = ["value1", "value2"]
         .iter()
         .map(|&i| i.to_string())
@@ -1147,13 +1172,13 @@ fn test_any_matcher_cardinality_estimation() {
         .borrow()
         .estimate_cardinality(&filter);
 
-    assert_eq!(estimation.primary_clauses.len(), 1);
+    ensure!(estimation.primary_clauses.len() == 1);
     for clause in estimation.primary_clauses.iter() {
         let expected_primary_clause = any_match.clone();
 
         match clause {
             PrimaryCondition::Condition(field_condition) => {
-                assert_eq!(*field_condition, Box::new(expected_primary_clause));
+                ensure!(*field_condition == Box::new(expected_primary_clause));
             }
             o => panic!("unexpected primary clause: {o:?}"),
         }
@@ -1175,8 +1200,10 @@ fn test_any_matcher_cardinality_estimation() {
     eprintln!("exact = {exact:#?}");
     eprintln!("estimation = {estimation:#?}");
 
-    assert!(exact <= estimation.max);
-    assert!(exact >= estimation.min);
+    ensure!(exact <= estimation.max);
+    ensure!(exact >= estimation.min);
+
+    Ok(())
 }
 
 /// FacetParams fixture without a filter
@@ -1199,7 +1226,7 @@ fn validate_facet_result(
     segment: &Segment,
     facet_hits: HashMap<FacetValue, usize>,
     filter: Option<Filter>,
-) {
+) -> Result<()> {
     let hw_counter = HardwareCounterCell::new();
 
     for (value, count) in facet_hits.iter() {
@@ -1222,14 +1249,13 @@ fn validate_facet_result(
             )
             .len();
 
-        assert_eq!(*count, exact, "Facet value: {value:?}");
+        ensure!(*count == exact, "Facet value: {value:?}");
     }
-}
 
-#[test]
-fn test_struct_keyword_facet() {
-    let test_segments = get_read_only_segments();
+    Ok(())
+}
 
+fn test_struct_keyword_facet(test_segments: &TestSegments) -> Result<()> {
     let request = keyword_facet_request();
 
     // Plain segment should fail, as it does not have a keyword index
@@ -1244,13 +1270,10 @@ fn test_struct_keyword_facet() {
         .facet(&request, &Default::default(), &Default::default())
         .unwrap();
 
-    validate_facet_result(&test_segments.struct_segment, facet_hits, None);
+    validate_facet_result(&test_segments.struct_segment, facet_hits, None).context(here!())
 }
 
-#[test]
-fn test_mmap_keyword_facet() {
-    let test_segments = get_read_only_segments();
-
+fn test_mmap_keyword_facet(test_segments: &TestSegments) -> Result<()> {
     let request = keyword_facet_request();
 
     let facet_hits = test_segments
@@ -1258,16 +1281,13 @@ fn test_mmap_keyword_facet() {
         .facet(&request, &Default::default(), &Default::default())
         .unwrap();
 
-    validate_facet_result(&test_segments.mmap_segment, facet_hits, None);
+    validate_facet_result(&test_segments.mmap_segment, facet_hits, None).context(here!())
 }
 
-#[test]
-fn test_struct_keyword_facet_filtered() {
-    let test_segments = get_read_only_segments();
-
+fn test_struct_keyword_facet_filtered(test_segments: &TestSegments) -> Result<()> {
     let mut request = keyword_facet_request();
 
-    for _ in 0..10 {
+    for _ in 0..ATTEMPTS {
         let filter = random_filter(&mut rand::rng(), 3);
         request.filter = Some(filter.clone());
 
@@ -1276,17 +1296,16 @@ fn test_struct_keyword_facet_filtered() {
             .facet(&request, &Default::default(), &Default::default())
             .unwrap();
 
-        validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter));
+        validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter))
+            .context(here!())?
     }
+    Ok(())
 }
 
-#[test]
-fn test_mmap_keyword_facet_filtered() {
-    let test_segments = get_read_only_segments();
-
+fn test_mmap_keyword_facet_filtered(test_segments: &TestSegments) -> Result<()> {
     let mut request = keyword_facet_request();
 
-    for _ in 0..10 {
+    for _ in 0..ATTEMPTS {
         let filter = random_filter(&mut rand::rng(), 3);
         request.filter = Some(filter.clone());
 
@@ -1295,6 +1314,8 @@ fn test_mmap_keyword_facet_filtered() {
             .facet(&request, &Default::default(), &Default::default())
             .unwrap();
 
-        validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter));
+        validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter))
+            .context(here!())?
     }
+    Ok(())
 }

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index c2331bd7a..0b6f240fd 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -1,8 +1,8 @@
 use std::collections::HashMap;
 use std::fs::create_dir;
 use std::path::Path;
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 
 use anyhow::{Context, Result};
 use atomic_refcell::AtomicRefCell;
@@ -19,21 +19,21 @@ use segment::data_types::index::{
     FloatIndexParams, FloatIndexType, IntegerIndexParams, IntegerIndexType, KeywordIndexParams,
     KeywordIndexType, TextIndexParams, TextIndexType,
 };
-use segment::data_types::vectors::{only_default_vector, DEFAULT_VECTOR_NAME};
+use segment::data_types::vectors::{DEFAULT_VECTOR_NAME, only_default_vector};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::fixtures::payload_fixtures::{
-    generate_diverse_nested_payload, generate_diverse_payload, random_filter, random_nested_filter,
-    random_vector, FLICKING_KEY, FLT_KEY, GEO_KEY, INT_KEY, INT_KEY_2, INT_KEY_3, LAT_RANGE,
-    LON_RANGE, STR_KEY, STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY,
+    FLICKING_KEY, FLT_KEY, GEO_KEY, INT_KEY, INT_KEY_2, INT_KEY_3, LAT_RANGE, LON_RANGE, STR_KEY,
+    STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY, generate_diverse_nested_payload,
+    generate_diverse_payload, random_filter, random_nested_filter, random_vector,
 };
+use segment::index::PayloadIndex;
 use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
-use segment::index::PayloadIndex;
 use segment::json_path::JsonPath;
 use segment::payload_json;
-use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::payload_storage::PayloadStorage;
+use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::segment::Segment;
 use segment::segment_constructor::build_segment;
 use segment::segment_constructor::segment_builder::SegmentBuilder;
@@ -1259,10 +1259,12 @@ fn test_struct_keyword_facet(test_segments: &TestSegments) -> Result<()> {
     let request = keyword_facet_request();
 
     // Plain segment should fail, as it does not have a keyword index
-    assert!(test_segments
-        .plain_segment
-        .facet(&request, &Default::default(), &Default::default())
-        .is_err());
+    assert!(
+        test_segments
+            .plain_segment
+            .facet(&request, &Default::default(), &Default::default())
+            .is_err(),
+    );
 
     // Struct segment
     let facet_hits = test_segments

commit 706b1a31665ee4a2e44a0a20845bb8065b0dbc28
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 4 13:19:50 2025 +0100

    IsEmpty/IsNull index (#6088)
    
    * create initial strucutres
    
    * clippy
    
    * start field-query refactoring
    
    * start field-query refactoring (2/N)
    
    * start field-query refactoring (3/N): duplicate is_empty/null condiftions as field condition
    
    * start field-query refactoring (4/N): re-instate is_empty fallback in case new index is not built yet
    
    * filter for is_empty/is_null
    
    * implement add/remove point
    
    * upd schema
    
    * open and create of null-index
    
    * create null-index
    
    * fix test
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * unit test for null-index
    
    * more unit tests
    
    * add openapi tests
    
    * fmt
    
    * fix for integartion tests
    
    * rabbit review fix
    
    * make [null] non-empty
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 0b6f240fd..488c2ad34 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -618,30 +618,47 @@ fn test_integer_index_types(test_segments: &TestSegments) -> Result<()> {
         ("mmap", &test_segments.mmap_segment.payload_index.borrow()),
     ] {
         eprintln!("Checking {kind}_segment");
-        ensure!(matches!(
-            indexes
-                .field_indexes
-                .get(&JsonPath::new(INT_KEY))
-                .unwrap()
-                .as_slice(),
-            [FieldIndex::IntMapIndex(_), FieldIndex::IntIndex(_)],
-        ));
-        ensure!(matches!(
-            indexes
-                .field_indexes
-                .get(&JsonPath::new(INT_KEY_2))
-                .unwrap()
-                .as_slice(),
-            [FieldIndex::IntMapIndex(_)],
-        ));
-        ensure!(matches!(
-            indexes
-                .field_indexes
-                .get(&JsonPath::new(INT_KEY_3))
-                .unwrap()
-                .as_slice(),
-            [FieldIndex::IntIndex(_)],
-        ));
+        let field_indexes = indexes.field_indexes.get(&JsonPath::new(INT_KEY)).unwrap();
+
+        let has_map_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntMapIndex(_)));
+        let has_int_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntIndex(_)));
+
+        ensure!(has_map_index);
+        ensure!(has_int_index);
+
+        let field_indexes = indexes
+            .field_indexes
+            .get(&JsonPath::new(INT_KEY_2))
+            .unwrap();
+
+        let has_map_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntMapIndex(_)));
+        let has_int_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntIndex(_)));
+
+        ensure!(has_map_index);
+        ensure!(!has_int_index);
+
+        let field_indexes = indexes
+            .field_indexes
+            .get(&JsonPath::new(INT_KEY_3))
+            .unwrap();
+
+        let has_map_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntMapIndex(_)));
+        let has_int_index = field_indexes
+            .iter()
+            .any(|index| matches!(index, FieldIndex::IntIndex(_)));
+
+        ensure!(!has_map_index);
+        ensure!(has_int_index);
     }
     Ok(())
 }

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 488c2ad34..938f39ec0 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -464,11 +464,12 @@ fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Re
             )
             .unwrap();
 
+        let hw_counter = HardwareCounterCell::new();
         let estimation = test_segments
             .plain_segment
             .payload_index
             .borrow()
-            .estimate_cardinality(&query_filter);
+            .estimate_cardinality(&query_filter, &hw_counter);
 
         ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
         ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
@@ -499,7 +500,7 @@ fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Re
             .struct_segment
             .payload_index
             .borrow()
-            .estimate_cardinality(&query_filter);
+            .estimate_cardinality(&query_filter, &hw_counter);
 
         ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
         ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
@@ -567,13 +568,13 @@ fn test_is_empty_conditions(test_segments: &TestSegments) -> Result<()> {
         .struct_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     let estimation_plain = test_segments
         .plain_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     let plain_result = test_segments
         .plain_segment
@@ -674,11 +675,13 @@ fn test_cardinality_estimation(test_segments: &TestSegments) -> Result<()> {
         },
     )));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let estimation = test_segments
         .struct_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     let hw_counter = HardwareCounterCell::new();
 
@@ -718,10 +721,12 @@ fn test_root_nested_array_filter_cardinality_estimation() {
         Filter::new_must(Condition::Field(nested_match)),
     ));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let estimation = struct_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     // not empty primary clauses
     assert_eq!(estimation.primary_clauses.len(), 1);
@@ -780,10 +785,12 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
         )),
     ));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let estimation = struct_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     // not empty primary clauses
     assert_eq!(estimation.primary_clauses.len(), 1);
@@ -869,11 +876,13 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
             )
             .unwrap();
 
+        let hw_counter = HardwareCounterCell::new();
+
         let estimation = test_segments
             .struct_segment
             .payload_index
             .borrow()
-            .estimate_cardinality(&query_filter);
+            .estimate_cardinality(&query_filter, &hw_counter);
 
         ensure!(estimation.min <= estimation.exp, "{estimation:#?}");
         ensure!(estimation.exp <= estimation.max, "{estimation:#?}");
@@ -1075,10 +1084,12 @@ fn test_struct_payload_index_nested_fields() {
             )
             .unwrap();
 
+        let hw_counter = HardwareCounterCell::new();
+
         let estimation = struct_segment
             .payload_index
             .borrow()
-            .estimate_cardinality(&query_filter);
+            .estimate_cardinality(&query_filter, &hw_counter);
 
         assert!(estimation.min <= estimation.exp, "{estimation:#?}");
         assert!(estimation.exp <= estimation.max, "{estimation:#?}");
@@ -1183,11 +1194,13 @@ fn test_any_matcher_cardinality_estimation(test_segments: &TestSegments) -> Resu
 
     let filter = Filter::new_must(Condition::Field(any_match.clone()));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let estimation = test_segments
         .struct_segment
         .payload_index
         .borrow()
-        .estimate_cardinality(&filter);
+        .estimate_cardinality(&filter, &hw_counter);
 
     ensure!(estimation.primary_clauses.len() == 1);
     for clause in estimation.primary_clauses.iter() {

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/payload_index_test.rs b/lib/segment/tests/integration/payload_index_test.rs
index 938f39ec0..1499e5c22 100644
--- a/lib/segment/tests/integration/payload_index_test.rs
+++ b/lib/segment/tests/integration/payload_index_test.rs
@@ -95,7 +95,12 @@ impl TestSegments {
 
         let mut opnum = 0;
         struct_segment
-            .create_field_index(opnum, &JsonPath::new(INT_KEY_2), Some(&Integer.into()))
+            .create_field_index(
+                opnum,
+                &JsonPath::new(INT_KEY_2),
+                Some(&Integer.into()),
+                &hw_counter,
+            )
             .unwrap();
 
         opnum += 1;
@@ -121,10 +126,15 @@ impl TestSegments {
         }
 
         struct_segment
-            .create_field_index(opnum, &JsonPath::new(STR_KEY), Some(&Keyword.into()))
+            .create_field_index(
+                opnum,
+                &JsonPath::new(STR_KEY),
+                Some(&Keyword.into()),
+                &hw_counter,
+            )
             .unwrap();
         struct_segment
-            .create_field_index(opnum, &JsonPath::new(INT_KEY), None)
+            .create_field_index(opnum, &JsonPath::new(INT_KEY), None, &hw_counter)
             .unwrap();
         struct_segment
             .create_field_index(
@@ -139,6 +149,7 @@ impl TestSegments {
                         on_disk: None,
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         struct_segment
@@ -154,6 +165,7 @@ impl TestSegments {
                         on_disk: None,
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         struct_segment
@@ -161,6 +173,7 @@ impl TestSegments {
                 opnum,
                 &JsonPath::new(GEO_KEY),
                 Some(&PayloadSchemaType::Geo.into()),
+                &hw_counter,
             )
             .unwrap();
         struct_segment
@@ -168,10 +181,16 @@ impl TestSegments {
                 opnum,
                 &JsonPath::new(TEXT_KEY),
                 Some(&PayloadSchemaType::Text.into()),
+                &hw_counter,
             )
             .unwrap();
         struct_segment
-            .create_field_index(opnum, &JsonPath::new(FLICKING_KEY), Some(&Integer.into()))
+            .create_field_index(
+                opnum,
+                &JsonPath::new(FLICKING_KEY),
+                Some(&Integer.into()),
+                &hw_counter,
+            )
             .unwrap();
 
         // Make mmap segment after inserting the points, but before deleting some of them
@@ -264,8 +283,9 @@ impl TestSegments {
 
         builder.update(&[plain_segment], &stopped).unwrap();
         let permit = ResourcePermit::dummy(1);
+        let hw_counter = HardwareCounterCell::new();
 
-        let mut segment = builder.build(permit, &stopped).unwrap();
+        let mut segment = builder.build(permit, &stopped, &hw_counter).unwrap();
         let opnum = segment.version() + 1;
 
         segment
@@ -279,6 +299,7 @@ impl TestSegments {
                         on_disk: Some(true),
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         segment
@@ -294,6 +315,7 @@ impl TestSegments {
                         on_disk: Some(true),
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         segment
@@ -309,6 +331,7 @@ impl TestSegments {
                         on_disk: Some(true),
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         segment
@@ -324,6 +347,7 @@ impl TestSegments {
                         on_disk: Some(true),
                     },
                 ))),
+                &hw_counter,
             )
             .unwrap();
         segment
@@ -335,6 +359,7 @@ impl TestSegments {
                     is_principal: None,
                     on_disk: Some(true),
                 }))),
+                &hw_counter,
             )
             .unwrap();
         segment
@@ -346,6 +371,7 @@ impl TestSegments {
                     on_disk: Some(true),
                     ..Default::default()
                 }))),
+                &hw_counter,
             )
             .unwrap();
 
@@ -372,23 +398,33 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         STR_ROOT_PROJ_KEY, "nested_1", "nested_2"
     ));
 
+    let hw_counter = HardwareCounterCell::new();
+
     let mut opnum = 0;
     struct_segment
-        .create_field_index(opnum, &nested_str_key, Some(&Keyword.into()))
+        .create_field_index(opnum, &nested_str_key, Some(&Keyword.into()), &hw_counter)
         .unwrap();
 
     struct_segment
-        .create_field_index(opnum, &nested_str_proj_key, Some(&Keyword.into()))
+        .create_field_index(
+            opnum,
+            &nested_str_proj_key,
+            Some(&Keyword.into()),
+            &hw_counter,
+        )
         .unwrap();
 
     struct_segment
-        .create_field_index(opnum, &deep_nested_str_proj_key, Some(&Keyword.into()))
+        .create_field_index(
+            opnum,
+            &deep_nested_str_proj_key,
+            Some(&Keyword.into()),
+            &hw_counter,
+        )
         .unwrap();
 
     eprintln!("{deep_nested_str_proj_key}");
 
-    let hw_counter = HardwareCounterCell::new();
-
     opnum += 1;
     for n in 0..num_points {
         let idx = n.into();
@@ -1153,7 +1189,7 @@ fn test_update_payload_index_type() {
     let field = JsonPath::new("field");
 
     // set field to Integer type
-    index.set_indexed(&field, Integer).unwrap();
+    index.set_indexed(&field, Integer, &hw_counter).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)
@@ -1163,7 +1199,7 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[1].count_indexed_points(), point_num);
 
     // update field to Keyword type
-    index.set_indexed(&field, Keyword).unwrap();
+    index.set_indexed(&field, Keyword, &hw_counter).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Keyword)
@@ -1172,7 +1208,7 @@ fn test_update_payload_index_type() {
     assert_eq!(field_index[0].count_indexed_points(), 0); // only one field index for Keyword
 
     // set field to Integer type (again)
-    index.set_indexed(&field, Integer).unwrap();
+    index.set_indexed(&field, Integer, &hw_counter).unwrap();
     assert_eq!(
         *index.indexed_fields().get(&field).unwrap(),
         FieldType(Integer)

