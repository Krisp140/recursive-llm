# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/actix/api/snapshot_api.rs

commit fac87018c45b1bc7bc957dbe254ba26349464426
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jul 1 13:21:57 2022 +0200

    Snapshoting API (#764)
    
    * wip: rest api for snapshots
    
    * fmt
    
    * fix tests
    
    * fmt
    
    * wip: collection snapshoting and recovery
    
    * fmt
    
    * remote shard snapshots
    
    * remote shard test
    
    * fmt
    
    * extend proxy snapshot test + fix double read lock
    
    * fmt + clippy
    
    * openapi schema
    
    * Update openapi/openapi-snapshots.ytt.yaml
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update openapi/openapi-snapshots.ytt.yaml
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update src/main.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update src/main.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * reduce writes on snapshots location
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
new file mode 100644
index 000000000..acda4e332
--- /dev/null
+++ b/src/actix/api/snapshot_api.rs
@@ -0,0 +1,70 @@
+use actix_files::NamedFile;
+use std::sync::Arc;
+
+use actix_web::rt::time::Instant;
+use actix_web::{get, post, web, Responder, Result};
+
+use storage::content_manager::toc::TableOfContent;
+
+use crate::actix::helpers::{
+    collection_into_actix_error, process_response, storage_into_actix_error,
+};
+use crate::common::collections::*;
+
+pub async fn do_get_snapshot(
+    toc: &TableOfContent,
+    collection_name: &str,
+    snapshot_name: &str,
+) -> Result<NamedFile> {
+    let collection = toc
+        .get_collection(collection_name)
+        .await
+        .map_err(storage_into_actix_error)?;
+
+    let file_name = collection
+        .get_snapshot_path(snapshot_name)
+        .await
+        .map_err(collection_into_actix_error)?;
+
+    Ok(NamedFile::open(file_name)?)
+}
+
+#[get("/collections/{name}/snapshots")]
+async fn list_snapshots(
+    toc: web::Data<Arc<TableOfContent>>,
+    path: web::Path<String>,
+) -> impl Responder {
+    let collection_name = path.into_inner();
+
+    let timing = Instant::now();
+    let response = do_list_snapshots(&toc.into_inner(), &collection_name).await;
+    process_response(response, timing)
+}
+
+#[post("/collections/{name}/snapshots")]
+async fn create_snapshot(
+    toc: web::Data<Arc<TableOfContent>>,
+    path: web::Path<String>,
+) -> impl Responder {
+    let collection_name = path.into_inner();
+
+    let timing = Instant::now();
+    let response = do_create_snapshot(&toc.into_inner(), &collection_name).await;
+    process_response(response, timing)
+}
+
+#[get("/collections/{name}/snapshots/{snapshot_name}")]
+async fn get_snapshot(
+    toc: web::Data<Arc<TableOfContent>>,
+    path: web::Path<(String, String)>,
+) -> impl Responder {
+    let (collection_name, snapshot_name) = path.into_inner();
+    do_get_snapshot(&toc.into_inner(), &collection_name, &snapshot_name).await
+}
+
+// Configure services
+pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
+    cfg.service(list_snapshots)
+        .service(create_snapshot)
+        .service(get_snapshot);
+}

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index acda4e332..f99065e6e 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,9 +1,8 @@
-use actix_files::NamedFile;
 use std::sync::Arc;
 
+use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
 use actix_web::{get, post, web, Responder, Result};
-
 use storage::content_manager::toc::TableOfContent;
 
 use crate::actix::helpers::{

commit 123332c8678fc06bcc872d0390ec28dfb57a26cc
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 18 17:11:23 2022 +0200

    Full snapshot (#824)
    
    * full snapshot rest api
    
    * openapi for snapshots
    
    * openapi snapshot api
    
    * fmt + clippy
    
    * fix recovery + implement grpc methods
    
    * fmt
    
    * same aliases to full storage snapshot
    
    * fmt

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index f99065e6e..18e4b1bab 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -3,6 +3,9 @@ use std::sync::Arc;
 use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
 use actix_web::{get, post, web, Responder, Result};
+use storage::content_manager::snapshots::{
+    do_create_full_snapshot, do_list_full_snapshots, get_full_snapshot_path,
+};
 use storage::content_manager::toc::TableOfContent;
 
 use crate::actix::helpers::{
@@ -10,6 +13,14 @@ use crate::actix::helpers::{
 };
 use crate::common::collections::*;
 
+pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) -> Result<NamedFile> {
+    let file_name = get_full_snapshot_path(toc, snapshot_name)
+        .await
+        .map_err(storage_into_actix_error)?;
+
+    Ok(NamedFile::open(file_name)?)
+}
+
 pub async fn do_get_snapshot(
     toc: &TableOfContent,
     collection_name: &str,
@@ -61,9 +72,35 @@ async fn get_snapshot(
     do_get_snapshot(&toc.into_inner(), &collection_name, &snapshot_name).await
 }
 
+#[get("/snapshots")]
+async fn list_full_snapshots(toc: web::Data<Arc<TableOfContent>>) -> impl Responder {
+    let timing = Instant::now();
+    let response = do_list_full_snapshots(&toc.into_inner()).await;
+    process_response(response, timing)
+}
+
+#[post("/snapshots")]
+async fn create_full_snapshot(toc: web::Data<Arc<TableOfContent>>) -> impl Responder {
+    let timing = Instant::now();
+    let response = do_create_full_snapshot(&toc.into_inner()).await;
+    process_response(response, timing)
+}
+
+#[get("/snapshots/{snapshot_name}")]
+async fn get_full_snapshot(
+    toc: web::Data<Arc<TableOfContent>>,
+    path: web::Path<String>,
+) -> impl Responder {
+    let snapshot_name = path.into_inner();
+    do_get_full_snapshot(&toc.into_inner(), &snapshot_name).await
+}
+
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
         .service(create_snapshot)
-        .service(get_snapshot);
+        .service(get_snapshot)
+        .service(list_full_snapshots)
+        .service(create_full_snapshot)
+        .service(get_full_snapshot);
 }

commit 1e4a895bf330d6621eed3cfa78b8df7bd5565988
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jul 28 12:28:57 2022 +0200

    Remove unecessary Arc for web::Data (#870)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 18e4b1bab..eb1b694aa 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,5 +1,3 @@
-use std::sync::Arc;
-
 use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
 use actix_web::{get, post, web, Responder, Result};
@@ -40,59 +38,56 @@ pub async fn do_get_snapshot(
 }
 
 #[get("/collections/{name}/snapshots")]
-async fn list_snapshots(
-    toc: web::Data<Arc<TableOfContent>>,
-    path: web::Path<String>,
-) -> impl Responder {
+async fn list_snapshots(toc: web::Data<TableOfContent>, path: web::Path<String>) -> impl Responder {
     let collection_name = path.into_inner();
 
     let timing = Instant::now();
-    let response = do_list_snapshots(&toc.into_inner(), &collection_name).await;
+    let response = do_list_snapshots(toc.get_ref(), &collection_name).await;
     process_response(response, timing)
 }
 
 #[post("/collections/{name}/snapshots")]
 async fn create_snapshot(
-    toc: web::Data<Arc<TableOfContent>>,
+    toc: web::Data<TableOfContent>,
     path: web::Path<String>,
 ) -> impl Responder {
     let collection_name = path.into_inner();
 
     let timing = Instant::now();
-    let response = do_create_snapshot(&toc.into_inner(), &collection_name).await;
+    let response = do_create_snapshot(toc.get_ref(), &collection_name).await;
     process_response(response, timing)
 }
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
-    toc: web::Data<Arc<TableOfContent>>,
+    toc: web::Data<TableOfContent>,
     path: web::Path<(String, String)>,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
-    do_get_snapshot(&toc.into_inner(), &collection_name, &snapshot_name).await
+    do_get_snapshot(toc.get_ref(), &collection_name, &snapshot_name).await
 }
 
 #[get("/snapshots")]
-async fn list_full_snapshots(toc: web::Data<Arc<TableOfContent>>) -> impl Responder {
+async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
     let timing = Instant::now();
-    let response = do_list_full_snapshots(&toc.into_inner()).await;
+    let response = do_list_full_snapshots(toc.get_ref()).await;
     process_response(response, timing)
 }
 
 #[post("/snapshots")]
-async fn create_full_snapshot(toc: web::Data<Arc<TableOfContent>>) -> impl Responder {
+async fn create_full_snapshot(toc: web::Data<TableOfContent>) -> impl Responder {
     let timing = Instant::now();
-    let response = do_create_full_snapshot(&toc.into_inner()).await;
+    let response = do_create_full_snapshot(toc.get_ref()).await;
     process_response(response, timing)
 }
 
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
-    toc: web::Data<Arc<TableOfContent>>,
+    toc: web::Data<TableOfContent>,
     path: web::Path<String>,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(&toc.into_inner(), &snapshot_name).await
+    do_get_full_snapshot(toc.get_ref(), &snapshot_name).await
 }
 
 // Configure services

commit ec25e973fb69dcad520a07a02256692c7e732daa
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 15 13:33:22 2022 +0100

    Recover distributed collection (#1214)
    
    * WIP: shards recovering API: download snapshot
    
    * fmt
    
    * snapshot recovery API
    
    * fmt
    
    * snapshot recovery integration test + fixes
    
    * review fixes
    
    * review fixes 2
    
    * Update lib/storage/src/content_manager/snapshots/recover.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index eb1b694aa..33e9acfa5 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,6 +1,8 @@
 use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
-use actix_web::{get, post, web, Responder, Result};
+use actix_web::{get, post, put, web, Responder, Result};
+use collection::operations::snapshot_ops::SnapshotRecover;
+use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
     do_create_full_snapshot, do_list_full_snapshots, get_full_snapshot_path,
 };
@@ -58,6 +60,21 @@ async fn create_snapshot(
     process_response(response, timing)
 }
 
+#[put("/collections/{name}/snapshots/recover")]
+async fn recover_from_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<String>,
+    request: web::Json<SnapshotRecover>,
+) -> impl Responder {
+    let collection_name = path.into_inner();
+    let snapshot_recover = request.into_inner();
+
+    let timing = Instant::now();
+    let response =
+        do_recover_from_snapshot(toc.get_ref(), &collection_name, snapshot_recover).await;
+    process_response(response, timing)
+}
+
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
     toc: web::Data<TableOfContent>,
@@ -94,6 +111,7 @@ async fn get_full_snapshot(
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
         .service(create_snapshot)
+        .service(recover_from_snapshot)
         .service(get_snapshot)
         .service(list_full_snapshots)
         .service(create_full_snapshot)

commit fe06844c48d834a1e2c3b0f7f2d161b86f788deb
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Jan 20 19:28:56 2023 +0100

    Delete snapshots API (#1377)
    
    * Delete snapshots API
    
    * remove unecessary plurals

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 33e9acfa5..fe47bb8b2 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,10 +1,11 @@
 use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
-use actix_web::{get, post, put, web, Responder, Result};
+use actix_web::{delete, get, post, put, web, Responder, Result};
 use collection::operations::snapshot_ops::SnapshotRecover;
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
-    do_create_full_snapshot, do_list_full_snapshots, get_full_snapshot_path,
+    do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
+    do_list_full_snapshots, get_full_snapshot_path,
 };
 use storage::content_manager::toc::TableOfContent;
 
@@ -13,6 +14,7 @@ use crate::actix::helpers::{
 };
 use crate::common::collections::*;
 
+// Actix specific code
 pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) -> Result<NamedFile> {
     let file_name = get_full_snapshot_path(toc, snapshot_name)
         .await
@@ -21,6 +23,7 @@ pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) ->
     Ok(NamedFile::open(file_name)?)
 }
 
+// Actix specific code
 pub async fn do_get_snapshot(
     toc: &TableOfContent,
     collection_name: &str,
@@ -107,6 +110,29 @@ async fn get_full_snapshot(
     do_get_full_snapshot(toc.get_ref(), &snapshot_name).await
 }
 
+#[delete("/snapshots/{snapshot_name}")]
+async fn delete_full_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<String>,
+) -> impl Responder {
+    let snapshot_name = path.into_inner();
+    let timing = Instant::now();
+    let response = do_delete_full_snapshot(toc.get_ref(), &snapshot_name).await;
+    process_response(response, timing)
+}
+
+#[delete("/collections/{name}/snapshots/{snapshot_name}")]
+async fn delete_collection_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, String)>,
+) -> impl Responder {
+    let (collection_name, snapshot_name) = path.into_inner();
+    let timing = Instant::now();
+    let response =
+        do_delete_collection_snapshot(toc.get_ref(), &collection_name, &snapshot_name).await;
+    process_response(response, timing)
+}
+
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
@@ -115,5 +141,7 @@ pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
         .service(get_snapshot)
         .service(list_full_snapshots)
         .service(create_full_snapshot)
-        .service(get_full_snapshot);
+        .service(get_full_snapshot)
+        .service(delete_full_snapshot)
+        .service(delete_collection_snapshot);
 }

commit d7379f07067b928eed7c5b6c878c2d075517abb1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 7 17:03:01 2023 +0100

    Fix recover snapshot peer (#1534)
    
    * allow to recover distributed snapshot on local intance + allow recover non-existing collections
    
    * async snapshot recovery
    
    * fix tests
    
    * be polite earlier

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index fe47bb8b2..a8cfbd2cc 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,19 +1,28 @@
 use actix_files::NamedFile;
 use actix_web::rt::time::Instant;
+use actix_web::web::Query;
 use actix_web::{delete, get, post, put, web, Responder, Result};
 use collection::operations::snapshot_ops::SnapshotRecover;
+use schemars::JsonSchema;
+use serde::{Deserialize, Serialize};
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
     do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
     do_list_full_snapshots, get_full_snapshot_path,
 };
 use storage::content_manager::toc::TableOfContent;
+use storage::dispatcher::Dispatcher;
 
 use crate::actix::helpers::{
     collection_into_actix_error, process_response, storage_into_actix_error,
 };
 use crate::common::collections::*;
 
+#[derive(Deserialize, Serialize, JsonSchema)]
+pub struct SnapshottingParam {
+    pub wait: Option<bool>,
+}
+
 // Actix specific code
 pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) -> Result<NamedFile> {
     let file_name = get_full_snapshot_path(toc, snapshot_name)
@@ -65,16 +74,23 @@ async fn create_snapshot(
 
 #[put("/collections/{name}/snapshots/recover")]
 async fn recover_from_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     request: web::Json<SnapshotRecover>,
+    params: Query<SnapshottingParam>,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     let snapshot_recover = request.into_inner();
+    let wait = params.wait.unwrap_or(true);
 
     let timing = Instant::now();
-    let response =
-        do_recover_from_snapshot(toc.get_ref(), &collection_name, snapshot_recover).await;
+    let response = do_recover_from_snapshot(
+        dispatcher.get_ref(),
+        &collection_name,
+        snapshot_recover,
+        wait,
+    )
+    .await;
     process_response(response, timing)
 }
 

commit 21641346aab1c9a04622279f65c56614fd1d1126
Author: Ibrahim M. Akrab <ibrahim.m.akrab@gmail.com>
Date:   Tue Mar 21 18:17:25 2023 +0200

     add upload snapshot functionality using multipart request  (#1578)
    
    * add upload snapshot functionality using multipart request
    
    * remove unnecessary printing
    
    * Add proper error handling
    
    * add snapshot upload integration tests
    
    * Fix maximum uploaded snapshot size limit
    
    * review changes
    
    * update OpenAPI with upload endpoint
    
    * add missed query param in openapi
    
    * remove unused function
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index a8cfbd2cc..e1f07d825 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,10 +1,16 @@
+use std::path::Path;
+
 use actix_files::NamedFile;
+use actix_multipart::form::tempfile::TempFile;
+use actix_multipart::form::MultipartForm;
 use actix_web::rt::time::Instant;
 use actix_web::web::Query;
 use actix_web::{delete, get, post, put, web, Responder, Result};
-use collection::operations::snapshot_ops::SnapshotRecover;
+use collection::operations::snapshot_ops::{SnapshotPriority, SnapshotRecover};
+use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
+use storage::content_manager::errors::StorageError;
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
     do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
@@ -12,17 +18,29 @@ use storage::content_manager::snapshots::{
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
+use uuid::Uuid;
 
 use crate::actix::helpers::{
     collection_into_actix_error, process_response, storage_into_actix_error,
 };
 use crate::common::collections::*;
 
+#[derive(Deserialize, Serialize, JsonSchema)]
+pub struct SnapshotUploadingParam {
+    pub wait: Option<bool>,
+    pub priority: Option<SnapshotPriority>,
+}
+
 #[derive(Deserialize, Serialize, JsonSchema)]
 pub struct SnapshottingParam {
     pub wait: Option<bool>,
 }
 
+#[derive(MultipartForm)]
+pub struct SnapshottingForm {
+    snapshot: TempFile,
+}
+
 // Actix specific code
 pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) -> Result<NamedFile> {
     let file_name = get_full_snapshot_path(toc, snapshot_name)
@@ -32,6 +50,30 @@ pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) ->
     Ok(NamedFile::open(file_name)?)
 }
 
+pub fn do_save_uploaded_snapshot(
+    toc: &TableOfContent,
+    collection_name: &str,
+    snapshot: TempFile,
+) -> std::result::Result<Url, StorageError> {
+    let filename = snapshot.file_name.unwrap_or(Uuid::new_v4().to_string());
+    let path = Path::new(toc.snapshots_path())
+        .join(collection_name)
+        .join(filename);
+
+    snapshot.file.persist(&path)?;
+
+    let absolute_path = path.canonicalize()?;
+
+    let snapshot_location = Url::from_file_path(&absolute_path).map_err(|_| {
+        StorageError::service_error(format!(
+            "Failed to convert path to URL: {}",
+            absolute_path.display()
+        ))
+    })?;
+
+    Ok(snapshot_location)
+}
+
 // Actix specific code
 pub async fn do_get_snapshot(
     toc: &TableOfContent,
@@ -72,6 +114,39 @@ async fn create_snapshot(
     process_response(response, timing)
 }
 
+#[post("/collections/{name}/snapshots/upload")]
+async fn upload_snapshot(
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<String>,
+    MultipartForm(form): MultipartForm<SnapshottingForm>,
+    params: Query<SnapshotUploadingParam>,
+) -> impl Responder {
+    let collection_name = path.into_inner();
+    let snapshot = form.snapshot;
+    let wait = params.wait.unwrap_or(true);
+    let timing = Instant::now();
+
+    let snapshot_location =
+        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection_name, snapshot) {
+            Ok(location) => location,
+            Err(err) => return process_response(Err(err), timing),
+        };
+
+    let snapshot_recover = SnapshotRecover {
+        location: snapshot_location,
+        priority: params.priority,
+    };
+
+    let response = do_recover_from_snapshot(
+        dispatcher.get_ref(),
+        &collection_name,
+        snapshot_recover,
+        wait,
+    )
+    .await;
+    process_response(response, timing)
+}
+
 #[put("/collections/{name}/snapshots/recover")]
 async fn recover_from_snapshot(
     dispatcher: web::Data<Dispatcher>,
@@ -153,6 +228,7 @@ async fn delete_collection_snapshot(
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
         .service(create_snapshot)
+        .service(upload_snapshot)
         .service(recover_from_snapshot)
         .service(get_snapshot)
         .service(list_full_snapshots)

commit f0f92292e022e3ddfde82f96d393efc8b6addcf9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Apr 3 11:43:55 2023 +0400

    Add Actix and config validation (#1463)
    
    * actix validation
    
    * add check for memmap/indexing_threshold
    
    * fix actix json settings
    
    * Validate settings configuration on start, print pretty warnings on fail
    
    * Add more validation rules for settings and nested types
    
    * Move shared validation logic into collection/operations
    
    * Show validation warning in log when loading some internal configs
    
    * Show prettier actix JSON validation errors
    
    * Stubs for pretty handling of query errors, reformat validation errors
    
    * Use crate flatten function, the hard work was already done for us
    
    We don't have to flatten validation errors into their qualified field
    names ourselves because there is a utility function for this.
    
    * Configure actix path validator
    
    * Actix endpoints don't require public
    
    * Extend validation to more actix types
    
    * Validate all remaining actix path and query properties
    
    * Rephrase range validation messages to clearly describe they're inclusive
    
    * Validate all query params to respond with pretty deserialize errors
    
    * Nicely format JSON payload deserialize error responses
    
    * Improve error reporting for upsert point batches
    
    * Add basic validation test that checks a path, query and payload value
    
    * Add some validation constraints
    
    * Add simple validation error render test
    
    * Update Cargo.lock
    
    ---------
    
    Co-authored-by: timvisee <tim+github@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index e1f07d825..5c02c0bbe 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,11 +1,11 @@
-use std::path::Path;
+use std::path::Path as StdPath;
 
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
 use actix_web::rt::time::Instant;
-use actix_web::web::Query;
 use actix_web::{delete, get, post, put, web, Responder, Result};
+use actix_web_validator::{Json, Path, Query};
 use collection::operations::snapshot_ops::{SnapshotPriority, SnapshotRecover};
 use reqwest::Url;
 use schemars::JsonSchema;
@@ -19,19 +19,28 @@ use storage::content_manager::snapshots::{
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 use uuid::Uuid;
+use validator::Validate;
 
+use super::CollectionPath;
 use crate::actix::helpers::{
     collection_into_actix_error, process_response, storage_into_actix_error,
 };
 use crate::common::collections::*;
 
-#[derive(Deserialize, Serialize, JsonSchema)]
+#[derive(Deserialize, Validate)]
+struct SnapshotPath {
+    #[serde(rename = "snapshot_name")]
+    #[validate(length(min = 1))]
+    name: String,
+}
+
+#[derive(Deserialize, Serialize, JsonSchema, Validate)]
 pub struct SnapshotUploadingParam {
     pub wait: Option<bool>,
     pub priority: Option<SnapshotPriority>,
 }
 
-#[derive(Deserialize, Serialize, JsonSchema)]
+#[derive(Deserialize, Serialize, JsonSchema, Validate)]
 pub struct SnapshottingParam {
     pub wait: Option<bool>,
 }
@@ -56,7 +65,7 @@ pub fn do_save_uploaded_snapshot(
     snapshot: TempFile,
 ) -> std::result::Result<Url, StorageError> {
     let filename = snapshot.file_name.unwrap_or(Uuid::new_v4().to_string());
-    let path = Path::new(toc.snapshots_path())
+    let path = StdPath::new(toc.snapshots_path())
         .join(collection_name)
         .join(filename);
 
@@ -94,40 +103,38 @@ pub async fn do_get_snapshot(
 }
 
 #[get("/collections/{name}/snapshots")]
-async fn list_snapshots(toc: web::Data<TableOfContent>, path: web::Path<String>) -> impl Responder {
-    let collection_name = path.into_inner();
-
+async fn list_snapshots(
+    toc: web::Data<TableOfContent>,
+    collection: Path<CollectionPath>,
+) -> impl Responder {
     let timing = Instant::now();
-    let response = do_list_snapshots(toc.get_ref(), &collection_name).await;
+    let response = do_list_snapshots(toc.get_ref(), &collection.name).await;
     process_response(response, timing)
 }
 
 #[post("/collections/{name}/snapshots")]
 async fn create_snapshot(
     toc: web::Data<TableOfContent>,
-    path: web::Path<String>,
+    collection: Path<CollectionPath>,
 ) -> impl Responder {
-    let collection_name = path.into_inner();
-
     let timing = Instant::now();
-    let response = do_create_snapshot(toc.get_ref(), &collection_name).await;
+    let response = do_create_snapshot(toc.get_ref(), &collection.name).await;
     process_response(response, timing)
 }
 
 #[post("/collections/{name}/snapshots/upload")]
 async fn upload_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    path: web::Path<String>,
+    collection: Path<CollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     params: Query<SnapshotUploadingParam>,
 ) -> impl Responder {
-    let collection_name = path.into_inner();
+    let timing = Instant::now();
     let snapshot = form.snapshot;
     let wait = params.wait.unwrap_or(true);
-    let timing = Instant::now();
 
     let snapshot_location =
-        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection_name, snapshot) {
+        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot) {
             Ok(location) => location,
             Err(err) => return process_response(Err(err), timing),
         };
@@ -139,7 +146,7 @@ async fn upload_snapshot(
 
     let response = do_recover_from_snapshot(
         dispatcher.get_ref(),
-        &collection_name,
+        &collection.name,
         snapshot_recover,
         wait,
     )
@@ -150,18 +157,17 @@ async fn upload_snapshot(
 #[put("/collections/{name}/snapshots/recover")]
 async fn recover_from_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    path: web::Path<String>,
-    request: web::Json<SnapshotRecover>,
+    collection: Path<CollectionPath>,
+    request: Json<SnapshotRecover>,
     params: Query<SnapshottingParam>,
 ) -> impl Responder {
-    let collection_name = path.into_inner();
+    let timing = Instant::now();
     let snapshot_recover = request.into_inner();
     let wait = params.wait.unwrap_or(true);
 
-    let timing = Instant::now();
     let response = do_recover_from_snapshot(
         dispatcher.get_ref(),
-        &collection_name,
+        &collection.name,
         snapshot_recover,
         wait,
     )
@@ -172,10 +178,10 @@ async fn recover_from_snapshot(
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
     toc: web::Data<TableOfContent>,
-    path: web::Path<(String, String)>,
+    collection: Path<CollectionPath>,
+    snapshot: Path<SnapshotPath>,
 ) -> impl Responder {
-    let (collection_name, snapshot_name) = path.into_inner();
-    do_get_snapshot(toc.get_ref(), &collection_name, &snapshot_name).await
+    do_get_snapshot(toc.get_ref(), &collection.name, &snapshot.name).await
 }
 
 #[get("/snapshots")]
@@ -195,32 +201,30 @@ async fn create_full_snapshot(toc: web::Data<TableOfContent>) -> impl Responder
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
     toc: web::Data<TableOfContent>,
-    path: web::Path<String>,
+    snapshot: Path<SnapshotPath>,
 ) -> impl Responder {
-    let snapshot_name = path.into_inner();
-    do_get_full_snapshot(toc.get_ref(), &snapshot_name).await
+    do_get_full_snapshot(toc.get_ref(), &snapshot.name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
 async fn delete_full_snapshot(
     toc: web::Data<TableOfContent>,
-    path: web::Path<String>,
+    snapshot: Path<SnapshotPath>,
 ) -> impl Responder {
-    let snapshot_name = path.into_inner();
     let timing = Instant::now();
-    let response = do_delete_full_snapshot(toc.get_ref(), &snapshot_name).await;
+    let response = do_delete_full_snapshot(toc.get_ref(), &snapshot.name).await;
     process_response(response, timing)
 }
 
 #[delete("/collections/{name}/snapshots/{snapshot_name}")]
 async fn delete_collection_snapshot(
     toc: web::Data<TableOfContent>,
-    path: web::Path<(String, String)>,
+    collection: Path<CollectionPath>,
+    snapshot: Path<SnapshotPath>,
 ) -> impl Responder {
-    let (collection_name, snapshot_name) = path.into_inner();
     let timing = Instant::now();
     let response =
-        do_delete_collection_snapshot(toc.get_ref(), &collection_name, &snapshot_name).await;
+        do_delete_collection_snapshot(toc.get_ref(), &collection.name, &snapshot.name).await;
     process_response(response, timing)
 }
 

commit de93c75bf3abb81c076d90a380d46ee3627f7704
Author: Alex Huang <huangweijun1001@gmail.com>
Date:   Tue Apr 4 12:08:13 2023 +0200

    feat: add wait param for all snapshot API (#1571)
    
    * feat: add wait parm for all snapshot API
    
    * update openAPI
    
    * avoid unwrap
    
    * remove all unwarp
    
    * return HTTP 202 when no waiting on snapshot creation
    
    * return 202 when non wait
    
    * update open API
    
    * update param on python test
    
    * update and test api
    
    * optimize the test
    
    * return 202 when non-wait delete
    
    * recover fixes
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 5c02c0bbe..892352600 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -23,7 +23,7 @@ use validator::Validate;
 
 use super::CollectionPath;
 use crate::actix::helpers::{
-    collection_into_actix_error, process_response, storage_into_actix_error,
+    accepted_response, collection_into_actix_error, process_response, storage_into_actix_error,
 };
 use crate::common::collections::*;
 
@@ -103,23 +103,30 @@ pub async fn do_get_snapshot(
 }
 
 #[get("/collections/{name}/snapshots")]
-async fn list_snapshots(
-    toc: web::Data<TableOfContent>,
-    collection: Path<CollectionPath>,
-) -> impl Responder {
+async fn list_snapshots(toc: web::Data<TableOfContent>, path: web::Path<String>) -> impl Responder {
+    let collection_name = path.into_inner();
     let timing = Instant::now();
-    let response = do_list_snapshots(toc.get_ref(), &collection.name).await;
+
+    let response = do_list_snapshots(&toc, &collection_name).await;
     process_response(response, timing)
 }
 
 #[post("/collections/{name}/snapshots")]
 async fn create_snapshot(
-    toc: web::Data<TableOfContent>,
-    collection: Path<CollectionPath>,
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<String>,
+    params: Query<SnapshottingParam>,
 ) -> impl Responder {
+    let collection_name = path.into_inner();
+    let wait = params.wait.unwrap_or(true);
+
     let timing = Instant::now();
-    let response = do_create_snapshot(toc.get_ref(), &collection.name).await;
-    process_response(response, timing)
+    let response = do_create_snapshot(dispatcher.get_ref(), &collection_name, wait).await;
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 #[post("/collections/{name}/snapshots/upload")]
@@ -136,7 +143,7 @@ async fn upload_snapshot(
     let snapshot_location =
         match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot) {
             Ok(location) => location,
-            Err(err) => return process_response(Err(err), timing),
+            Err(err) => return process_response::<()>(Err(err), timing),
         };
 
     let snapshot_recover = SnapshotRecover {
@@ -151,7 +158,11 @@ async fn upload_snapshot(
         wait,
     )
     .await;
-    process_response(response, timing)
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 #[put("/collections/{name}/snapshots/recover")]
@@ -172,18 +183,21 @@ async fn recover_from_snapshot(
         wait,
     )
     .await;
-    process_response(response, timing)
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
     toc: web::Data<TableOfContent>,
-    collection: Path<CollectionPath>,
-    snapshot: Path<SnapshotPath>,
+    path: web::Path<(String, String)>,
 ) -> impl Responder {
-    do_get_snapshot(toc.get_ref(), &collection.name, &snapshot.name).await
+    let (collection_name, snapshot_name) = path.into_inner();
+    do_get_snapshot(&toc, &collection_name, &snapshot_name).await
 }
-
 #[get("/snapshots")]
 async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
     let timing = Instant::now();
@@ -192,40 +206,63 @@ async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
 }
 
 #[post("/snapshots")]
-async fn create_full_snapshot(toc: web::Data<TableOfContent>) -> impl Responder {
+async fn create_full_snapshot(
+    dispatcher: web::Data<Dispatcher>,
+    params: Query<SnapshottingParam>,
+) -> impl Responder {
     let timing = Instant::now();
-    let response = do_create_full_snapshot(toc.get_ref()).await;
-    process_response(response, timing)
+    let wait = params.wait.unwrap_or(true);
+    let response = do_create_full_snapshot(dispatcher.get_ref(), wait).await;
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
     toc: web::Data<TableOfContent>,
-    snapshot: Path<SnapshotPath>,
+    path: web::Path<String>,
 ) -> impl Responder {
-    do_get_full_snapshot(toc.get_ref(), &snapshot.name).await
+    let snapshot_name = path.into_inner();
+    do_get_full_snapshot(&toc, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
 async fn delete_full_snapshot(
-    toc: web::Data<TableOfContent>,
-    snapshot: Path<SnapshotPath>,
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<String>,
+    params: Query<SnapshottingParam>,
 ) -> impl Responder {
+    let snapshot_name = path.into_inner();
     let timing = Instant::now();
-    let response = do_delete_full_snapshot(toc.get_ref(), &snapshot.name).await;
-    process_response(response, timing)
+    let wait = params.wait.unwrap_or(true);
+    let response = do_delete_full_snapshot(dispatcher.get_ref(), &snapshot_name, wait).await;
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 #[delete("/collections/{name}/snapshots/{snapshot_name}")]
 async fn delete_collection_snapshot(
-    toc: web::Data<TableOfContent>,
-    collection: Path<CollectionPath>,
-    snapshot: Path<SnapshotPath>,
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<(String, String)>,
+    params: Query<SnapshottingParam>,
 ) -> impl Responder {
+    let (collection_name, snapshot_name) = path.into_inner();
     let timing = Instant::now();
+    let wait = params.wait.unwrap_or(true);
     let response =
-        do_delete_collection_snapshot(toc.get_ref(), &collection.name, &snapshot.name).await;
-    process_response(response, timing)
+        do_delete_collection_snapshot(dispatcher.get_ref(), &collection_name, &snapshot_name, wait)
+            .await;
+    match response {
+        Err(_) => process_response(response, timing),
+        Ok(_) if wait => process_response(response, timing),
+        Ok(_) => accepted_response(timing),
+    }
 }
 
 // Configure services

commit 5eb031638965d416be4783d857f46608858a02e1
Author: paulotten <paulotten@users.noreply.github.com>
Date:   Mon Apr 17 05:42:34 2023 -0400

    chore: fix clippy warnings (#1740)
    
    * chore: fix clippy warnings
    
    - Prefer `unwrap_or_else` over `unwrap_or` as the later is always executed.
    - Use `clamp`.
    
    * chore: convert `default_quantization_ignore_value` and `default_quantization_rescore_value` to `const fn`
    
    * chore: revert `clamp` change

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 892352600..5d7656a69 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -64,7 +64,9 @@ pub fn do_save_uploaded_snapshot(
     collection_name: &str,
     snapshot: TempFile,
 ) -> std::result::Result<Url, StorageError> {
-    let filename = snapshot.file_name.unwrap_or(Uuid::new_v4().to_string());
+    let filename = snapshot
+        .file_name
+        .unwrap_or_else(|| Uuid::new_v4().to_string());
     let path = StdPath::new(toc.snapshots_path())
         .join(collection_name)
         .join(filename);

commit 2935a45578c9657de47242ac98bac0e4071b669b
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jun 12 19:29:05 2023 +0200

    Create snapshot dir. during upload if it does not exist (#2063)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 5d7656a69..0f8e58031 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,5 +1,3 @@
-use std::path::Path as StdPath;
-
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
@@ -59,7 +57,7 @@ pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) ->
     Ok(NamedFile::open(file_name)?)
 }
 
-pub fn do_save_uploaded_snapshot(
+pub async fn do_save_uploaded_snapshot(
     toc: &TableOfContent,
     collection_name: &str,
     snapshot: TempFile,
@@ -67,9 +65,16 @@ pub fn do_save_uploaded_snapshot(
     let filename = snapshot
         .file_name
         .unwrap_or_else(|| Uuid::new_v4().to_string());
-    let path = StdPath::new(toc.snapshots_path())
-        .join(collection_name)
-        .join(filename);
+    let collection_snapshot_path = toc.snapshots_path_for_collection(collection_name);
+    if !collection_snapshot_path.exists() {
+        log::debug!(
+            "Creating missing collection snapshots directory for {}",
+            collection_name
+        );
+        toc.create_snapshots_path(collection_name).await?;
+    }
+
+    let path = collection_snapshot_path.join(filename);
 
     snapshot.file.persist(&path)?;
 
@@ -143,7 +148,7 @@ async fn upload_snapshot(
     let wait = params.wait.unwrap_or(true);
 
     let snapshot_location =
-        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot) {
+        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot).await {
             Ok(location) => location,
             Err(err) => return process_response::<()>(Err(err), timing),
         };

commit 097e72971392bf181700cf97cd9173f977a47bf9
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Aug 30 12:41:29 2023 +0200

    Shard snapshot API (#2410)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 0f8e58031..c07d53a1d 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,25 +1,34 @@
+use std::path::{Path, PathBuf};
+use std::{fmt, io};
+
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
 use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, Responder, Result};
-use actix_web_validator::{Json, Path, Query};
+use actix_web_validator as valid;
+use collection::collection::Collection;
 use collection::operations::snapshot_ops::{SnapshotPriority, SnapshotRecover};
+use collection::shards::replica_set::ReplicaState;
+use collection::shards::shard::ShardId;
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::errors::StorageError;
-use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
+use storage::content_manager::snapshots::download::downloaded_snapshots_dir;
+use storage::content_manager::snapshots::recover::{activate_shard, do_recover_from_snapshot};
 use storage::content_manager::snapshots::{
-    do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
+    self, do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
     do_list_full_snapshots, get_full_snapshot_path,
 };
-use storage::content_manager::toc::TableOfContent;
+use storage::content_manager::toc::{TableOfContent, SNAPSHOTS_TEMP_DIR};
 use storage::dispatcher::Dispatcher;
+use tokio::sync::RwLockReadGuard;
 use uuid::Uuid;
 use validator::Validate;
 
 use super::CollectionPath;
+use crate::actix::helpers;
 use crate::actix::helpers::{
     accepted_response, collection_into_actix_error, process_response, storage_into_actix_error,
 };
@@ -122,7 +131,7 @@ async fn list_snapshots(toc: web::Data<TableOfContent>, path: web::Path<String>)
 async fn create_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
-    params: Query<SnapshottingParam>,
+    params: valid::Query<SnapshottingParam>,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     let wait = params.wait.unwrap_or(true);
@@ -139,9 +148,9 @@ async fn create_snapshot(
 #[post("/collections/{name}/snapshots/upload")]
 async fn upload_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    collection: Path<CollectionPath>,
+    collection: valid::Path<CollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
-    params: Query<SnapshotUploadingParam>,
+    params: valid::Query<SnapshotUploadingParam>,
 ) -> impl Responder {
     let timing = Instant::now();
     let snapshot = form.snapshot;
@@ -175,9 +184,9 @@ async fn upload_snapshot(
 #[put("/collections/{name}/snapshots/recover")]
 async fn recover_from_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    collection: Path<CollectionPath>,
-    request: Json<SnapshotRecover>,
-    params: Query<SnapshottingParam>,
+    collection: valid::Path<CollectionPath>,
+    request: valid::Json<SnapshotRecover>,
+    params: valid::Query<SnapshottingParam>,
 ) -> impl Responder {
     let timing = Instant::now();
     let snapshot_recover = request.into_inner();
@@ -215,7 +224,7 @@ async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
 #[post("/snapshots")]
 async fn create_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    params: Query<SnapshottingParam>,
+    params: valid::Query<SnapshottingParam>,
 ) -> impl Responder {
     let timing = Instant::now();
     let wait = params.wait.unwrap_or(true);
@@ -240,7 +249,7 @@ async fn get_full_snapshot(
 async fn delete_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
-    params: Query<SnapshottingParam>,
+    params: valid::Query<SnapshottingParam>,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
     let timing = Instant::now();
@@ -257,7 +266,7 @@ async fn delete_full_snapshot(
 async fn delete_collection_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
-    params: Query<SnapshottingParam>,
+    params: valid::Query<SnapshottingParam>,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
     let timing = Instant::now();
@@ -272,6 +281,291 @@ async fn delete_collection_snapshot(
     }
 }
 
+#[get("/collections/{collection}/shards/{shard}/snapshots")]
+async fn list_shard_snapshots(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId)>,
+) -> impl Responder {
+    let future = async move {
+        let (collection, shard) = path.into_inner();
+        let collection = toc.get_collection(&collection).await?;
+        let snapshots = collection.list_shard_snapshots(shard).await?;
+        Ok(snapshots)
+    };
+
+    helpers::time(future).await
+}
+
+#[post("/collections/{collection}/shards/{shard}/snapshots")]
+async fn create_shard_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId)>,
+    query: web::Query<SnapshottingParam>,
+) -> impl Responder {
+    let future = async move {
+        let (collection, shard) = path.into_inner();
+        let collection = toc.get_collection(&collection).await?;
+        let snapshot = collection
+            .create_shard_snapshot(shard, &toc.temp_snapshots_path().join(SNAPSHOTS_TEMP_DIR))
+            .await?;
+
+        Ok(snapshot)
+    };
+
+    helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
+}
+
+// TODO: `PUT` (same as `recover_from_snapshot`) or `POST`!?
+#[put("/collections/{collection}/shards/{shard}/snapshots/recover")]
+async fn recover_shard_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId)>,
+    query: web::Query<SnapshottingParam>,
+    web::Json(request): web::Json<ShardSnapshotRecover>,
+) -> impl Responder {
+    let future = async move {
+        let (collection, shard) = path.into_inner();
+        let collection = toc.get_collection(&collection).await?;
+        collection.assert_shard_exists(shard).await?;
+
+        // TODO: Handle cleanup on download failure (e.g., using `tempfile`)!?
+
+        let snapshot_path = match request.location {
+            ShardSnapshotLocation::Url(url) => {
+                if !matches!(url.scheme(), "http" | "https") {
+                    let description = format!(
+                        "Invalid snapshot URL {url}: URLs with {} scheme are not supported",
+                        url.scheme(),
+                    );
+
+                    return Err(StorageError::bad_input(description).into());
+                }
+
+                let downloaded_snapshots_dir = downloaded_snapshots_dir(toc.snapshots_path());
+                tokio::fs::create_dir_all(&downloaded_snapshots_dir).await?;
+
+                snapshots::download::download_snapshot(url, &downloaded_snapshots_dir).await?
+            }
+
+            ShardSnapshotLocation::Path(path) => {
+                let snapshot_path = collection.get_shard_snapshot_path(shard, path).await?;
+                check_shard_snapshot_file_exists(&snapshot_path)?;
+                snapshot_path
+            }
+        };
+
+        recover_shard_snapshot_impl(
+            &toc,
+            &collection,
+            shard,
+            &snapshot_path,
+            request.priority.unwrap_or_default(),
+        )
+        .await?;
+
+        Ok(())
+    };
+
+    helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
+}
+
+// TODO: `POST` (same as `upload_snapshot`) or `PUT`!?
+#[post("/collections/{collection}/shards/{shard}/snapshots/upload")]
+async fn upload_shard_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId)>,
+    query: web::Query<SnapshotUploadingParam>,
+    MultipartForm(form): MultipartForm<SnapshottingForm>,
+) -> impl Responder {
+    let SnapshotUploadingParam { wait, priority } = query.into_inner();
+
+    let future = async move {
+        let (collection, shard) = path.into_inner();
+        let collection = toc.get_collection(&collection).await?;
+        collection.assert_shard_exists(shard).await?;
+
+        let snapshot_file_name = form
+            .snapshot
+            .file_name
+            .unwrap_or_else(|| format!("{}.snapshot", Uuid::new_v4()));
+
+        let (uploaded_snapshot_file, snapshot_path) =
+            if collection.is_shard_local(&shard).await.unwrap_or(false) {
+                let snapshot_path = collection
+                    .get_shard_snapshot_path(shard, &snapshot_file_name)
+                    .await?;
+
+                form.snapshot
+                    .file
+                    .persist(&snapshot_path)
+                    .map_err(io::Error::from)?;
+
+                (None, snapshot_path)
+            } else {
+                let uploaded_snapshot_path = form.snapshot.file.path().to_path_buf();
+                (Some(form.snapshot.file), uploaded_snapshot_path)
+            };
+
+        recover_shard_snapshot_impl(
+            &toc,
+            &collection,
+            shard,
+            &snapshot_path,
+            priority.unwrap_or_default(),
+        )
+        .await?;
+
+        if let Some(uploaded_snapshot_file) = uploaded_snapshot_file {
+            let snapshot_path = collection
+                .get_shard_snapshot_path(shard, &snapshot_file_name)
+                .await?;
+
+            uploaded_snapshot_file
+                .persist(snapshot_path)
+                .map_err(io::Error::from)?;
+        }
+
+        Ok(())
+    };
+
+    helpers::time_or_accept(future, wait.unwrap_or(true)).await
+}
+
+#[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
+async fn download_shard_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId, String)>,
+) -> Result<impl Responder, helpers::HttpError> {
+    let (collection, shard, snapshot) = path.into_inner();
+    let collection = toc.get_collection(&collection).await?;
+    let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
+
+    Ok(NamedFile::open(snapshot_path))
+}
+
+#[delete("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
+async fn delete_shard_snapshot(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<(String, ShardId, String)>,
+    query: web::Query<SnapshottingParam>,
+) -> impl Responder {
+    let future = async move {
+        let (collection, shard, snapshot) = path.into_inner();
+        let collection = toc.get_collection(&collection).await?;
+        let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
+
+        check_shard_snapshot_file_exists(&snapshot_path)?;
+        std::fs::remove_file(&snapshot_path)?;
+
+        Ok(())
+    };
+
+    helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
+}
+
+fn check_shard_snapshot_file_exists(snapshot_path: &Path) -> Result<(), StorageError> {
+    let snapshot_path_display = snapshot_path.display();
+    let snapshot_file_name = snapshot_path.file_name().and_then(|str| str.to_str());
+
+    let snapshot: &dyn fmt::Display = snapshot_file_name
+        .as_ref()
+        .map_or(&snapshot_path_display, |str| str);
+
+    if !snapshot_path.exists() {
+        let description = format!("Snapshot {snapshot} not found");
+        Err(StorageError::NotFound { description })
+    } else if !snapshot_path.is_file() {
+        let description = format!("{snapshot} is not a file");
+        Err(StorageError::service_error(description))
+    } else {
+        Ok(())
+    }
+}
+
+async fn recover_shard_snapshot_impl(
+    toc: &TableOfContent,
+    collection: &RwLockReadGuard<'_, Collection>,
+    shard: ShardId,
+    snapshot_path: &std::path::Path,
+    priority: SnapshotPriority,
+) -> Result<(), StorageError> {
+    // TODO: Check snapshot compatibility?
+    // TODO: Switch replica into `Partial` state?
+
+    collection
+        .restore_shard_snapshot(
+            shard,
+            snapshot_path,
+            toc.this_peer_id,
+            toc.is_distributed(),
+            &toc.temp_snapshots_path().join(SNAPSHOTS_TEMP_DIR),
+        )
+        .await?;
+
+    let state = collection.state().await;
+    let shard_info = state.shards.get(&shard).unwrap(); // TODO: Handle `unwrap`?..
+
+    // TODO: Unify (and de-duplicate) "recovered shard state notification" logic in `_do_recover_from_snapshot` with this one!
+
+    let other_active_replicas: Vec<_> = shard_info
+        .replicas
+        .iter()
+        .map(|(&peer, &state)| (peer, state))
+        .filter(|&(peer, state)| peer != toc.this_peer_id && state == ReplicaState::Active)
+        .collect();
+
+    if other_active_replicas.is_empty() {
+        activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
+    } else {
+        match priority {
+            SnapshotPriority::LocalOnly => {
+                activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
+            }
+
+            SnapshotPriority::Snapshot => {
+                activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
+
+                for &(peer, _) in other_active_replicas.iter() {
+                    toc.send_set_replica_state_proposal(
+                        collection.name(),
+                        peer,
+                        shard,
+                        ReplicaState::Dead,
+                        None,
+                    )?;
+                }
+            }
+
+            SnapshotPriority::Replica => {
+                toc.send_set_replica_state_proposal(
+                    collection.name(),
+                    toc.this_peer_id,
+                    shard,
+                    ReplicaState::Dead,
+                    None,
+                )?;
+            }
+        }
+    }
+
+    Ok(())
+}
+
+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
+struct ShardSnapshotRecover {
+    location: ShardSnapshotLocation,
+
+    #[serde(default)]
+    priority: Option<SnapshotPriority>,
+}
+
+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
+#[serde(untagged)]
+enum ShardSnapshotLocation {
+    Url(Url),
+    Path(PathBuf),
+}
+
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
@@ -283,5 +577,11 @@ pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
         .service(create_full_snapshot)
         .service(get_full_snapshot)
         .service(delete_full_snapshot)
-        .service(delete_collection_snapshot);
+        .service(delete_collection_snapshot)
+        .service(list_shard_snapshots)
+        .service(create_shard_snapshot)
+        .service(recover_shard_snapshot)
+        .service(upload_shard_snapshot)
+        .service(download_shard_snapshot)
+        .service(delete_shard_snapshot);
 }

commit 55f4acdca831f1bb7f7aef8b70ea1eecda0b453a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Aug 31 11:32:29 2023 +0200

    directories cleanup + refactoring (#2536)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index c07d53a1d..1e377cebb 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -15,13 +15,12 @@ use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::errors::StorageError;
-use storage::content_manager::snapshots::download::downloaded_snapshots_dir;
 use storage::content_manager::snapshots::recover::{activate_shard, do_recover_from_snapshot};
 use storage::content_manager::snapshots::{
     self, do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
     do_list_full_snapshots, get_full_snapshot_path,
 };
-use storage::content_manager::toc::{TableOfContent, SNAPSHOTS_TEMP_DIR};
+use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 use tokio::sync::RwLockReadGuard;
 use uuid::Uuid;
@@ -306,7 +305,7 @@ async fn create_shard_snapshot(
         let (collection, shard) = path.into_inner();
         let collection = toc.get_collection(&collection).await?;
         let snapshot = collection
-            .create_shard_snapshot(shard, &toc.temp_snapshots_path().join(SNAPSHOTS_TEMP_DIR))
+            .create_shard_snapshot(shard, &toc.optional_temp_or_snapshot_temp_path()?)
             .await?;
 
         Ok(snapshot)
@@ -328,7 +327,7 @@ async fn recover_shard_snapshot(
         let collection = toc.get_collection(&collection).await?;
         collection.assert_shard_exists(shard).await?;
 
-        // TODO: Handle cleanup on download failure (e.g., using `tempfile`)!?
+        let download_dir = toc.snapshots_download_tempdir()?;
 
         let snapshot_path = match request.location {
             ShardSnapshotLocation::Url(url) => {
@@ -340,11 +339,7 @@ async fn recover_shard_snapshot(
 
                     return Err(StorageError::bad_input(description).into());
                 }
-
-                let downloaded_snapshots_dir = downloaded_snapshots_dir(toc.snapshots_path());
-                tokio::fs::create_dir_all(&downloaded_snapshots_dir).await?;
-
-                snapshots::download::download_snapshot(url, &downloaded_snapshots_dir).await?
+                snapshots::download::download_snapshot(url, download_dir.path()).await?
             }
 
             ShardSnapshotLocation::Path(path) => {
@@ -498,7 +493,7 @@ async fn recover_shard_snapshot_impl(
             snapshot_path,
             toc.this_peer_id,
             toc.is_distributed(),
-            &toc.temp_snapshots_path().join(SNAPSHOTS_TEMP_DIR),
+            &toc.optional_temp_or_snapshot_temp_path()?,
         )
         .await?;
 

commit 68abd8992326d51b561f274b3400d4a05c0277b2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Sep 4 14:54:08 2023 +0200

    openapi definitions for shard shashots API (#2571)
    
    * openapi definitions for shard shashots API
    
    * review fixes

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 1e377cebb..9f88b91e9 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,4 +1,4 @@
-use std::path::{Path, PathBuf};
+use std::path::Path;
 use std::{fmt, io};
 
 use actix_files::NamedFile;
@@ -8,7 +8,9 @@ use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, Responder, Result};
 use actix_web_validator as valid;
 use collection::collection::Collection;
-use collection::operations::snapshot_ops::{SnapshotPriority, SnapshotRecover};
+use collection::operations::snapshot_ops::{
+    ShardSnapshotLocation, ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
+};
 use collection::shards::replica_set::ReplicaState;
 use collection::shards::shard::ShardId;
 use reqwest::Url;
@@ -452,7 +454,7 @@ async fn delete_shard_snapshot(
         check_shard_snapshot_file_exists(&snapshot_path)?;
         std::fs::remove_file(&snapshot_path)?;
 
-        Ok(())
+        Ok(true)
     };
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
@@ -546,21 +548,6 @@ async fn recover_shard_snapshot_impl(
     Ok(())
 }
 
-#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
-struct ShardSnapshotRecover {
-    location: ShardSnapshotLocation,
-
-    #[serde(default)]
-    priority: Option<SnapshotPriority>,
-}
-
-#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
-#[serde(untagged)]
-enum ShardSnapshotLocation {
-    Url(Url),
-    Path(PathBuf),
-}
-
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)

commit 17dfe92e4d605105605a59f653cff02430930c0e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Sep 4 16:07:50 2023 +0200

    test for snapshot operations with different volumes (#2554)
    
    * test for snapshot operations with different volumes
    
    * fix collection snapshot upload + test for shards snapshots
    
    * replace persistance -> move_file
    
    * simplify shard snapsot upload method
    
    * fmt
    
    * chmod + x
    
    * replace network host
    
    * fmt
    
    * bash linter [skip ci]
    
    * fix review

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 9f88b91e9..3e36154a7 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,5 +1,5 @@
+use std::fmt;
 use std::path::Path;
-use std::{fmt, io};
 
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
@@ -8,6 +8,7 @@ use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, Responder, Result};
 use actix_web_validator as valid;
 use collection::collection::Collection;
+use collection::common::file_utils::move_file;
 use collection::operations::snapshot_ops::{
     ShardSnapshotLocation, ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
@@ -86,7 +87,7 @@ pub async fn do_save_uploaded_snapshot(
 
     let path = collection_snapshot_path.join(filename);
 
-    snapshot.file.persist(&path)?;
+    move_file(snapshot.file.path(), &path).await?;
 
     let absolute_path = path.canonicalize()?;
 
@@ -381,47 +382,15 @@ async fn upload_shard_snapshot(
         let collection = toc.get_collection(&collection).await?;
         collection.assert_shard_exists(shard).await?;
 
-        let snapshot_file_name = form
-            .snapshot
-            .file_name
-            .unwrap_or_else(|| format!("{}.snapshot", Uuid::new_v4()));
-
-        let (uploaded_snapshot_file, snapshot_path) =
-            if collection.is_shard_local(&shard).await.unwrap_or(false) {
-                let snapshot_path = collection
-                    .get_shard_snapshot_path(shard, &snapshot_file_name)
-                    .await?;
-
-                form.snapshot
-                    .file
-                    .persist(&snapshot_path)
-                    .map_err(io::Error::from)?;
-
-                (None, snapshot_path)
-            } else {
-                let uploaded_snapshot_path = form.snapshot.file.path().to_path_buf();
-                (Some(form.snapshot.file), uploaded_snapshot_path)
-            };
-
         recover_shard_snapshot_impl(
             &toc,
             &collection,
             shard,
-            &snapshot_path,
+            form.snapshot.file.path(),
             priority.unwrap_or_default(),
         )
         .await?;
 
-        if let Some(uploaded_snapshot_file) = uploaded_snapshot_file {
-            let snapshot_path = collection
-                .get_shard_snapshot_path(shard, &snapshot_file_name)
-                .await?;
-
-            uploaded_snapshot_file
-                .persist(snapshot_path)
-                .map_err(io::Error::from)?;
-        }
-
         Ok(())
     };
 

commit 323632bf437a52aa3196e34be0bdc98867c93eb7
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Sep 5 13:13:31 2023 +0200

    rename LocalOnly -> NoSync (#2594)
    
    * rename LocalOnly -> NoSync
    
    * Improve readability in OpenAPI description
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 3e36154a7..b8b40c6b6 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -484,7 +484,7 @@ async fn recover_shard_snapshot_impl(
         activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
     } else {
         match priority {
-            SnapshotPriority::LocalOnly => {
+            SnapshotPriority::NoSync => {
                 activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
             }
 

commit a3cc037afb250f14d044151489c7814d49e7893c
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Oct 18 14:34:58 2023 +0200

    Add shard snapshot gRPC API (#2825)
    
    * Fix paste-bugs in `snapshot_service.proto`
    
    * Add shard snapshot gRCP API definition
    
    * Add validation to shard snapshot gRPC API definition
    
    * Implement conversions between gRPC and `collection` types
    
    * Extract shard snapshot API implementation into common sub-module
    
    * Implement shard snapshot gRPC API
    
    * Generate gRPC docs
    
    * Refactor `ShardSnapshots` gRPC service to be internal API only
    
    * fixup! Refactor `ShardSnapshots` gRPC service to be internal API only
    
    Move `ShardSnapshotRecoverResponse` to `shard_snapshots_service.proto`
    
    * fixup! fixup! Refactor `ShardSnapshots` gRPC service to be internal API only
    
    Update `api/src/grpc/qdrant.rs`
    
    * fixup! fixup! Refactor `ShardSnapshots` gRPC service to be internal API only
    
    Update gRPC docs
    
    * Switch `ShardSnapshots` gRPC service to use `validate_and_log` instead of `validate`

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index b8b40c6b6..bed6b6708 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,31 +1,26 @@
-use std::fmt;
-use std::path::Path;
-
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
 use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, Responder, Result};
 use actix_web_validator as valid;
-use collection::collection::Collection;
 use collection::common::file_utils::move_file;
 use collection::operations::snapshot_ops::{
-    ShardSnapshotLocation, ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
+    ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
-use collection::shards::replica_set::ReplicaState;
 use collection::shards::shard::ShardId;
+use futures::TryFutureExt as _;
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::errors::StorageError;
-use storage::content_manager::snapshots::recover::{activate_shard, do_recover_from_snapshot};
+use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
-    self, do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
+    do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
     do_list_full_snapshots, get_full_snapshot_path,
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
-use tokio::sync::RwLockReadGuard;
 use uuid::Uuid;
 use validator::Validate;
 
@@ -34,6 +29,7 @@ use crate::actix::helpers;
 use crate::actix::helpers::{
     accepted_response, collection_into_actix_error, process_response, storage_into_actix_error,
 };
+use crate::common;
 use crate::common::collections::*;
 
 #[derive(Deserialize, Validate)]
@@ -288,12 +284,9 @@ async fn list_shard_snapshots(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId)>,
 ) -> impl Responder {
-    let future = async move {
-        let (collection, shard) = path.into_inner();
-        let collection = toc.get_collection(&collection).await?;
-        let snapshots = collection.list_shard_snapshots(shard).await?;
-        Ok(snapshots)
-    };
+    let (collection, shard) = path.into_inner();
+    let future = common::snapshots::list_shard_snapshots(toc.into_inner(), collection, shard)
+        .map_err(Into::into);
 
     helpers::time(future).await
 }
@@ -304,15 +297,9 @@ async fn create_shard_snapshot(
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
 ) -> impl Responder {
-    let future = async move {
-        let (collection, shard) = path.into_inner();
-        let collection = toc.get_collection(&collection).await?;
-        let snapshot = collection
-            .create_shard_snapshot(shard, &toc.optional_temp_or_snapshot_temp_path()?)
-            .await?;
-
-        Ok(snapshot)
-    };
+    let (collection, shard) = path.into_inner();
+    let future = common::snapshots::create_shard_snapshot(toc.into_inner(), collection, shard)
+        .map_err(Into::into);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -325,44 +312,15 @@ async fn recover_shard_snapshot(
     query: web::Query<SnapshottingParam>,
     web::Json(request): web::Json<ShardSnapshotRecover>,
 ) -> impl Responder {
-    let future = async move {
-        let (collection, shard) = path.into_inner();
-        let collection = toc.get_collection(&collection).await?;
-        collection.assert_shard_exists(shard).await?;
-
-        let download_dir = toc.snapshots_download_tempdir()?;
-
-        let snapshot_path = match request.location {
-            ShardSnapshotLocation::Url(url) => {
-                if !matches!(url.scheme(), "http" | "https") {
-                    let description = format!(
-                        "Invalid snapshot URL {url}: URLs with {} scheme are not supported",
-                        url.scheme(),
-                    );
-
-                    return Err(StorageError::bad_input(description).into());
-                }
-                snapshots::download::download_snapshot(url, download_dir.path()).await?
-            }
-
-            ShardSnapshotLocation::Path(path) => {
-                let snapshot_path = collection.get_shard_snapshot_path(shard, path).await?;
-                check_shard_snapshot_file_exists(&snapshot_path)?;
-                snapshot_path
-            }
-        };
-
-        recover_shard_snapshot_impl(
-            &toc,
-            &collection,
-            shard,
-            &snapshot_path,
-            request.priority.unwrap_or_default(),
-        )
-        .await?;
-
-        Ok(())
-    };
+    let (collection, shard) = path.into_inner();
+    let future = common::snapshots::recover_shard_snapshot(
+        toc.into_inner(),
+        collection,
+        shard,
+        request.location,
+        request.priority.unwrap_or_default(),
+    )
+    .map_err(Into::into);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -382,7 +340,7 @@ async fn upload_shard_snapshot(
         let collection = toc.get_collection(&collection).await?;
         collection.assert_shard_exists(shard).await?;
 
-        recover_shard_snapshot_impl(
+        common::snapshots::recover_shard_snapshot_impl(
             &toc,
             &collection,
             shard,
@@ -415,108 +373,15 @@ async fn delete_shard_snapshot(
     path: web::Path<(String, ShardId, String)>,
     query: web::Query<SnapshottingParam>,
 ) -> impl Responder {
-    let future = async move {
-        let (collection, shard, snapshot) = path.into_inner();
-        let collection = toc.get_collection(&collection).await?;
-        let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
-
-        check_shard_snapshot_file_exists(&snapshot_path)?;
-        std::fs::remove_file(&snapshot_path)?;
-
-        Ok(true)
-    };
+    let (collection, shard, snapshot) = path.into_inner();
+    let future =
+        common::snapshots::delete_shard_snapshot(toc.into_inner(), collection, shard, snapshot)
+            .map_ok(|_| true)
+            .map_err(Into::into);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
 
-fn check_shard_snapshot_file_exists(snapshot_path: &Path) -> Result<(), StorageError> {
-    let snapshot_path_display = snapshot_path.display();
-    let snapshot_file_name = snapshot_path.file_name().and_then(|str| str.to_str());
-
-    let snapshot: &dyn fmt::Display = snapshot_file_name
-        .as_ref()
-        .map_or(&snapshot_path_display, |str| str);
-
-    if !snapshot_path.exists() {
-        let description = format!("Snapshot {snapshot} not found");
-        Err(StorageError::NotFound { description })
-    } else if !snapshot_path.is_file() {
-        let description = format!("{snapshot} is not a file");
-        Err(StorageError::service_error(description))
-    } else {
-        Ok(())
-    }
-}
-
-async fn recover_shard_snapshot_impl(
-    toc: &TableOfContent,
-    collection: &RwLockReadGuard<'_, Collection>,
-    shard: ShardId,
-    snapshot_path: &std::path::Path,
-    priority: SnapshotPriority,
-) -> Result<(), StorageError> {
-    // TODO: Check snapshot compatibility?
-    // TODO: Switch replica into `Partial` state?
-
-    collection
-        .restore_shard_snapshot(
-            shard,
-            snapshot_path,
-            toc.this_peer_id,
-            toc.is_distributed(),
-            &toc.optional_temp_or_snapshot_temp_path()?,
-        )
-        .await?;
-
-    let state = collection.state().await;
-    let shard_info = state.shards.get(&shard).unwrap(); // TODO: Handle `unwrap`?..
-
-    // TODO: Unify (and de-duplicate) "recovered shard state notification" logic in `_do_recover_from_snapshot` with this one!
-
-    let other_active_replicas: Vec<_> = shard_info
-        .replicas
-        .iter()
-        .map(|(&peer, &state)| (peer, state))
-        .filter(|&(peer, state)| peer != toc.this_peer_id && state == ReplicaState::Active)
-        .collect();
-
-    if other_active_replicas.is_empty() {
-        activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
-    } else {
-        match priority {
-            SnapshotPriority::NoSync => {
-                activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
-            }
-
-            SnapshotPriority::Snapshot => {
-                activate_shard(toc, collection, toc.this_peer_id, &shard).await?;
-
-                for &(peer, _) in other_active_replicas.iter() {
-                    toc.send_set_replica_state_proposal(
-                        collection.name(),
-                        peer,
-                        shard,
-                        ReplicaState::Dead,
-                        None,
-                    )?;
-                }
-            }
-
-            SnapshotPriority::Replica => {
-                toc.send_set_replica_state_proposal(
-                    collection.name(),
-                    toc.this_peer_id,
-                    shard,
-                    ReplicaState::Dead,
-                    None,
-                )?;
-            }
-        }
-    }
-
-    Ok(())
-}
-
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)

commit c2f42cecf16135c233659b1426476d3cf9356523
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Nov 2 12:25:08 2023 +0100

    Make shard snapshot methods and API cancel-safe (#2870)
    
    * WIP: Make shard snapshot methods and API to be safely cancellable
    
    * WIP: Annotate all shard snapshot API methods if they are safe to cancel...
    
    ...and what should be done to make them so
    
    * WIP: Fix/clarify annotations for methods that can't be made safe to cancel
    
    * WIP: Further clarify cancel-safe annotations
    
    * Make shard snapshot methods cancel-safe...
    
    ...or annotate and propagate cancellation tokens to them
    
    * Fix spelling
    
    * Explicitly cancel snapshot archive task in `ShardHolder::create_shard_snapshot`
    
    * WIP: Make `recover_shard_snapshot`/`upload_shard_snapshot` API cancel-safe
    
    * Make `recover_shard_snapshot`/`upload_shard_snapshot` API cancel-safe
    
    * Add `common/cancel-safe` sub-crate
    
    * Cleanup
    
    * Rename `cancel-safe` sub-crate to `cancel`...
    
    ...and rename methods to have more meaningful names
    
    * fixup! Rename `cancel-safe` sub-crate to `cancel`...
    
    * Remove explicit `tokio-util` dependency from the `qdrant` crate
    
    `common/cancel` re-exports important parts anyway
    
    * Documentation fixes
    
    * Do not cancel request processing if request is dropped
    
    * Rename `common/cancel` APIs
    
    * Fix (or drop) some TODOs
    
    * Fix `clippy` and `cargo fmt`
    
    * fixup! Rename `common/cancel` APIs
    
    Fix typo
    
    * Improve documentation and comments
    
    * Fix failing shard snapshot API test
    
    * Use conventional cancel safety notes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index bed6b6708..a2ac0f851 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -9,7 +9,7 @@ use collection::operations::snapshot_ops::{
     ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
 use collection::shards::shard::ShardId;
-use futures::TryFutureExt as _;
+use futures::{FutureExt as _, TryFutureExt as _};
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
@@ -333,24 +333,37 @@ async fn upload_shard_snapshot(
     query: web::Query<SnapshotUploadingParam>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
 ) -> impl Responder {
+    let (collection, shard) = path.into_inner();
     let SnapshotUploadingParam { wait, priority } = query.into_inner();
 
-    let future = async move {
-        let (collection, shard) = path.into_inner();
-        let collection = toc.get_collection(&collection).await?;
-        collection.assert_shard_exists(shard).await?;
+    // - `recover_shard_snapshot_impl` is *not* cancel safe
+    //   - but the task is *spawned* on the runtime and won't be cancelled, if request is cancelled
+
+    let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
+        let future = async {
+            let collection = toc.get_collection(&collection).await?;
+            collection.assert_shard_exists(shard).await?;
+
+            Result::<_, helpers::HttpError>::Ok(collection)
+        };
+
+        let collection = cancel::future::cancel_on_token(cancel.clone(), future).await??;
 
+        // `recover_shard_snapshot_impl` is *not* cancel safe
         common::snapshots::recover_shard_snapshot_impl(
             &toc,
             &collection,
             shard,
             form.snapshot.file.path(),
             priority.unwrap_or_default(),
+            cancel,
         )
         .await?;
 
-        Ok(())
-    };
+        Result::<_, helpers::HttpError>::Ok(())
+    })
+    .map_err(Into::into)
+    .map(|res| res.and_then(|res| res));
 
     helpers::time_or_accept(future, wait.unwrap_or(true)).await
 }

commit eb9466fd67393f71aef8cc93c63b07faf51210e1
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Nov 10 09:56:49 2023 +0100

    Add custom TLS certificate support for remote snapshot downloads to snapshot recover APIs (#2895)
    
    * WIP: Add proper HTTPS support for remote snapshot downloads to snapshot recover APIs
    
    * Implement HTTPS client configuration
    
    * fixup! Implement HTTPS client configuration
    
    Move HTTPS client configuration from `actix/certificate_helpers.rs` to
    `common/http_client.rs`
    
    * Initialize and propagate HTTPS client to shard snapshot API
    
    * Use reqwest client reference where possible
    
    * Add integration test
    
    * Simplify HTTP(S) client initialization
    
    * fixup! Simplify HTTP(S) client initialization
    
    * Fix lifetime conflicts after rebase on dev
    
    * Add comment to elaborate on PEM concatenation
    
    * fixup! Add integration test
    
    Add `test_tls_snapshot_shard_transfer.sh` run to the existing TLS test job
    instead of creating a new one
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index a2ac0f851..9fc931591 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -31,6 +31,7 @@ use crate::actix::helpers::{
 };
 use crate::common;
 use crate::common::collections::*;
+use crate::common::http_client::HttpClient;
 
 #[derive(Deserialize, Validate)]
 struct SnapshotPath {
@@ -146,6 +147,7 @@ async fn create_snapshot(
 #[post("/collections/{name}/snapshots/upload")]
 async fn upload_snapshot(
     dispatcher: web::Data<Dispatcher>,
+    http_client: web::Data<HttpClient>,
     collection: valid::Path<CollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     params: valid::Query<SnapshotUploadingParam>,
@@ -160,6 +162,11 @@ async fn upload_snapshot(
             Err(err) => return process_response::<()>(Err(err), timing),
         };
 
+    let http_client = match http_client.client() {
+        Ok(http_client) => http_client,
+        Err(err) => return process_response::<()>(Err(err.into()), timing),
+    };
+
     let snapshot_recover = SnapshotRecover {
         location: snapshot_location,
         priority: params.priority,
@@ -170,8 +177,10 @@ async fn upload_snapshot(
         &collection.name,
         snapshot_recover,
         wait,
+        http_client,
     )
     .await;
+
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -182,6 +191,7 @@ async fn upload_snapshot(
 #[put("/collections/{name}/snapshots/recover")]
 async fn recover_from_snapshot(
     dispatcher: web::Data<Dispatcher>,
+    http_client: web::Data<HttpClient>,
     collection: valid::Path<CollectionPath>,
     request: valid::Json<SnapshotRecover>,
     params: valid::Query<SnapshottingParam>,
@@ -190,13 +200,20 @@ async fn recover_from_snapshot(
     let snapshot_recover = request.into_inner();
     let wait = params.wait.unwrap_or(true);
 
+    let http_client = match http_client.client() {
+        Ok(http_client) => http_client,
+        Err(err) => return process_response::<()>(Err(err.into()), timing),
+    };
+
     let response = do_recover_from_snapshot(
         dispatcher.get_ref(),
         &collection.name,
         snapshot_recover,
         wait,
+        http_client,
     )
     .await;
+
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -308,19 +325,26 @@ async fn create_shard_snapshot(
 #[put("/collections/{collection}/shards/{shard}/snapshots/recover")]
 async fn recover_shard_snapshot(
     toc: web::Data<TableOfContent>,
+    http_client: web::Data<HttpClient>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
     web::Json(request): web::Json<ShardSnapshotRecover>,
 ) -> impl Responder {
-    let (collection, shard) = path.into_inner();
-    let future = common::snapshots::recover_shard_snapshot(
-        toc.into_inner(),
-        collection,
-        shard,
-        request.location,
-        request.priority.unwrap_or_default(),
-    )
-    .map_err(Into::into);
+    let future = async move {
+        let (collection, shard) = path.into_inner();
+
+        common::snapshots::recover_shard_snapshot(
+            toc.into_inner(),
+            collection,
+            shard,
+            request.location,
+            request.priority.unwrap_or_default(),
+            http_client.as_ref().clone(),
+        )
+        .await?;
+
+        Ok(())
+    };
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }

commit a11c6f6a5befa6bce014a3759f04a0ffac510e89
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jan 25 15:00:07 2024 +0000

    add optional checksum to snapshot recovery request (#3381)
    
    * add optional checksum to snapshot recovery request
    
    * Update openapi yaml files
    
    * Add pytests for snapshots restoration

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 9fc931591..f5c98be3c 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -5,6 +5,7 @@ use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, Responder, Result};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
+use collection::common::sha_256::{hash_file, hashes_equal};
 use collection::operations::snapshot_ops::{
     ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
@@ -44,6 +45,11 @@ struct SnapshotPath {
 pub struct SnapshotUploadingParam {
     pub wait: Option<bool>,
     pub priority: Option<SnapshotPriority>,
+
+    /// Optional SHA256 checksum to verify snapshot integrity before recovery.
+    #[serde(default)]
+    #[validate(custom = "::common::validation::validate_sha256_hash")]
+    pub checksum: Option<String>,
 }
 
 #[derive(Deserialize, Serialize, JsonSchema, Validate)]
@@ -156,6 +162,19 @@ async fn upload_snapshot(
     let snapshot = form.snapshot;
     let wait = params.wait.unwrap_or(true);
 
+    if let Some(checksum) = &params.checksum {
+        let snapshot_checksum = match hash_file(snapshot.file.path()).await {
+            Ok(checksum) => checksum,
+            Err(err) => return process_response::<()>(Err(err.into()), timing),
+        };
+        if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
+            return process_response::<()>(
+                Err(StorageError::checksum_mismatch(snapshot_checksum, checksum)),
+                timing,
+            );
+        }
+    }
+
     let snapshot_location =
         match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot).await {
             Ok(location) => location,
@@ -170,6 +189,7 @@ async fn upload_snapshot(
     let snapshot_recover = SnapshotRecover {
         location: snapshot_location,
         priority: params.priority,
+        checksum: None,
     };
 
     let response = do_recover_from_snapshot(
@@ -339,11 +359,12 @@ async fn recover_shard_snapshot(
             shard,
             request.location,
             request.priority.unwrap_or_default(),
+            request.checksum,
             http_client.as_ref().clone(),
         )
         .await?;
 
-        Ok(())
+        Ok(true)
     };
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
@@ -358,12 +379,24 @@ async fn upload_shard_snapshot(
     MultipartForm(form): MultipartForm<SnapshottingForm>,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let SnapshotUploadingParam { wait, priority } = query.into_inner();
+    let SnapshotUploadingParam {
+        wait,
+        priority,
+        checksum,
+    } = query.into_inner();
 
     // - `recover_shard_snapshot_impl` is *not* cancel safe
     //   - but the task is *spawned* on the runtime and won't be cancelled, if request is cancelled
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
+        if let Some(checksum) = checksum {
+            let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
+            if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
+                let err = StorageError::checksum_mismatch(snapshot_checksum, checksum);
+                return Result::<_, helpers::HttpError>::Err(err.into());
+            }
+        }
+
         let future = async {
             let collection = toc.get_collection(&collection).await?;
             collection.assert_shard_exists(shard).await?;

commit 3ab8ec7d14178bb2ac39a4bcc972f2258254196e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 15 10:11:03 2024 +0100

    Security patch for snapshot upload filename (#3623)
    
    * do not trust file_name from the multipart upload
    
    * Add comment describing sanitation
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index f5c98be3c..7175a0891 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,3 +1,5 @@
+use std::path::Path;
+
 use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
@@ -78,6 +80,15 @@ pub async fn do_save_uploaded_snapshot(
 ) -> std::result::Result<Url, StorageError> {
     let filename = snapshot
         .file_name
+        // Sanitize the file name:
+        // - only take the top level path (no directories such as ../)
+        // - require the file name to be valid UTF-8
+        .and_then(|x| {
+            Path::new(&x)
+                .file_name()
+                .map(|filename| filename.to_owned())
+        })
+        .and_then(|x| x.to_str().map(|x| x.to_owned()))
         .unwrap_or_else(|| Uuid::new_v4().to_string());
     let collection_snapshot_path = toc.snapshots_path_for_collection(collection_name);
     if !collection_snapshot_path.exists() {

commit 17982377b012a4252e3a7cc0f73ff221b15bfdbc
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Mar 4 22:18:42 2024 +0300

    remove checksum path parameter for snapshot recovery in openapi (#3758)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 7175a0891..e4b6579d5 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -260,6 +260,7 @@ async fn get_snapshot(
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(&toc, &collection_name, &snapshot_name).await
 }
+
 #[get("/snapshots")]
 async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
     let timing = Instant::now();

commit a514bd1a85c3ac8c83cac1a0baf036a23e440f34
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Mar 21 13:21:34 2024 +0000

    RBAC support for snapshots API (#3887)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index e4b6579d5..a6f1e1034 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -13,9 +13,11 @@ use collection::operations::snapshot_ops::{
 };
 use collection::shards::shard::ShardId;
 use futures::{FutureExt as _, TryFutureExt as _};
+use rbac::jwt::Claims;
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
+use storage::content_manager::claims::{check_full_access_to_collection, check_manage_rights};
 use storage::content_manager::errors::StorageError;
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
@@ -28,6 +30,7 @@ use uuid::Uuid;
 use validator::Validate;
 
 use super::CollectionPath;
+use crate::actix::auth::Extension;
 use crate::actix::helpers;
 use crate::actix::helpers::{
     accepted_response, collection_into_actix_error, process_response, storage_into_actix_error,
@@ -65,7 +68,13 @@ pub struct SnapshottingForm {
 }
 
 // Actix specific code
-pub async fn do_get_full_snapshot(toc: &TableOfContent, snapshot_name: &str) -> Result<NamedFile> {
+pub async fn do_get_full_snapshot(
+    toc: &TableOfContent,
+    claims: Option<Claims>,
+    snapshot_name: &str,
+) -> Result<NamedFile> {
+    check_manage_rights(claims.as_ref()).map_err(storage_into_actix_error)?;
+
     let file_name = get_full_snapshot_path(toc, snapshot_name)
         .await
         .map_err(storage_into_actix_error)?;
@@ -118,9 +127,13 @@ pub async fn do_save_uploaded_snapshot(
 // Actix specific code
 pub async fn do_get_snapshot(
     toc: &TableOfContent,
+    claims: Option<Claims>,
     collection_name: &str,
     snapshot_name: &str,
 ) -> Result<NamedFile> {
+    check_full_access_to_collection(claims.as_ref(), collection_name)
+        .map_err(storage_into_actix_error)?;
+
     let collection = toc
         .get_collection(collection_name)
         .await
@@ -135,11 +148,15 @@ pub async fn do_get_snapshot(
 }
 
 #[get("/collections/{name}/snapshots")]
-async fn list_snapshots(toc: web::Data<TableOfContent>, path: web::Path<String>) -> impl Responder {
+async fn list_snapshots(
+    toc: web::Data<TableOfContent>,
+    path: web::Path<String>,
+    claims: Extension<Claims>,
+) -> impl Responder {
     let collection_name = path.into_inner();
     let timing = Instant::now();
 
-    let response = do_list_snapshots(&toc, &collection_name).await;
+    let response = do_list_snapshots(&toc, claims.into_inner(), &collection_name).await;
     process_response(response, timing)
 }
 
@@ -148,12 +165,19 @@ async fn create_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     params: valid::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     let wait = params.wait.unwrap_or(true);
 
     let timing = Instant::now();
-    let response = do_create_snapshot(dispatcher.get_ref(), &collection_name, wait).await;
+    let response = do_create_snapshot(
+        dispatcher.get_ref(),
+        claims.into_inner(),
+        &collection_name,
+        wait,
+    )
+    .await;
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -168,11 +192,17 @@ async fn upload_snapshot(
     collection: valid::Path<CollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     params: valid::Query<SnapshotUploadingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let timing = Instant::now();
     let snapshot = form.snapshot;
     let wait = params.wait.unwrap_or(true);
 
+    match check_manage_rights(claims.into_inner().as_ref()) {
+        Ok(_) => (),
+        Err(err) => return process_response::<()>(Err(err), timing),
+    }
+
     if let Some(checksum) = &params.checksum {
         let snapshot_checksum = match hash_file(snapshot.file.path()).await {
             Ok(checksum) => checksum,
@@ -208,6 +238,7 @@ async fn upload_snapshot(
         &collection.name,
         snapshot_recover,
         wait,
+        None,
         http_client,
     )
     .await;
@@ -226,6 +257,7 @@ async fn recover_from_snapshot(
     collection: valid::Path<CollectionPath>,
     request: valid::Json<SnapshotRecover>,
     params: valid::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let timing = Instant::now();
     let snapshot_recover = request.into_inner();
@@ -241,6 +273,7 @@ async fn recover_from_snapshot(
         &collection.name,
         snapshot_recover,
         wait,
+        claims.into_inner(),
         http_client,
     )
     .await;
@@ -256,15 +289,19 @@ async fn recover_from_snapshot(
 async fn get_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, String)>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
-    do_get_snapshot(&toc, &collection_name, &snapshot_name).await
+    do_get_snapshot(&toc, claims.into_inner(), &collection_name, &snapshot_name).await
 }
 
 #[get("/snapshots")]
-async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
+async fn list_full_snapshots(
+    toc: web::Data<TableOfContent>,
+    claims: Extension<Claims>,
+) -> impl Responder {
     let timing = Instant::now();
-    let response = do_list_full_snapshots(toc.get_ref()).await;
+    let response = do_list_full_snapshots(toc.get_ref(), claims.into_inner()).await;
     process_response(response, timing)
 }
 
@@ -272,10 +309,11 @@ async fn list_full_snapshots(toc: web::Data<TableOfContent>) -> impl Responder {
 async fn create_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
     params: valid::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let timing = Instant::now();
     let wait = params.wait.unwrap_or(true);
-    let response = do_create_full_snapshot(dispatcher.get_ref(), wait).await;
+    let response = do_create_full_snapshot(dispatcher.get_ref(), claims.into_inner(), wait).await;
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -287,9 +325,10 @@ async fn create_full_snapshot(
 async fn get_full_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<String>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(&toc, &snapshot_name).await
+    do_get_full_snapshot(&toc, claims.into_inner(), &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -297,11 +336,18 @@ async fn delete_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     params: valid::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
     let timing = Instant::now();
     let wait = params.wait.unwrap_or(true);
-    let response = do_delete_full_snapshot(dispatcher.get_ref(), &snapshot_name, wait).await;
+    let response = do_delete_full_snapshot(
+        dispatcher.get_ref(),
+        claims.into_inner(),
+        &snapshot_name,
+        wait,
+    )
+    .await;
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -314,13 +360,19 @@ async fn delete_collection_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
     params: valid::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
     let timing = Instant::now();
     let wait = params.wait.unwrap_or(true);
-    let response =
-        do_delete_collection_snapshot(dispatcher.get_ref(), &collection_name, &snapshot_name, wait)
-            .await;
+    let response = do_delete_collection_snapshot(
+        dispatcher.get_ref(),
+        claims.into_inner(),
+        &collection_name,
+        &snapshot_name,
+        wait,
+    )
+    .await;
     match response {
         Err(_) => process_response(response, timing),
         Ok(_) if wait => process_response(response, timing),
@@ -332,10 +384,16 @@ async fn delete_collection_snapshot(
 async fn list_shard_snapshots(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId)>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future = common::snapshots::list_shard_snapshots(toc.into_inner(), collection, shard)
-        .map_err(Into::into);
+    let future = common::snapshots::list_shard_snapshots(
+        toc.into_inner(),
+        claims.into_inner(),
+        collection,
+        shard,
+    )
+    .map_err(Into::into);
 
     helpers::time(future).await
 }
@@ -345,10 +403,16 @@ async fn create_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future = common::snapshots::create_shard_snapshot(toc.into_inner(), collection, shard)
-        .map_err(Into::into);
+    let future = common::snapshots::create_shard_snapshot(
+        toc.into_inner(),
+        claims.into_inner(),
+        collection,
+        shard,
+    )
+    .map_err(Into::into);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -361,12 +425,14 @@ async fn recover_shard_snapshot(
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
     web::Json(request): web::Json<ShardSnapshotRecover>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let future = async move {
         let (collection, shard) = path.into_inner();
 
         common::snapshots::recover_shard_snapshot(
             toc.into_inner(),
+            claims.into_inner(),
             collection,
             shard,
             request.location,
@@ -389,6 +455,7 @@ async fn upload_shard_snapshot(
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshotUploadingParam>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
     let SnapshotUploadingParam {
@@ -401,6 +468,10 @@ async fn upload_shard_snapshot(
     //   - but the task is *spawned* on the runtime and won't be cancelled, if request is cancelled
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
+        // TODO: Run this check before the multipart blob is uploaded
+        check_manage_rights(claims.into_inner().as_ref())
+            .map_err(Into::<helpers::HttpError>::into)?;
+
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
             if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
@@ -441,8 +512,10 @@ async fn upload_shard_snapshot(
 async fn download_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId, String)>,
+    claims: Extension<Claims>,
 ) -> Result<impl Responder, helpers::HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
+    check_full_access_to_collection(claims.into_inner().as_ref(), &collection)?;
     let collection = toc.get_collection(&collection).await?;
     let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
 
@@ -454,12 +527,18 @@ async fn delete_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId, String)>,
     query: web::Query<SnapshottingParam>,
+    claims: Extension<Claims>,
 ) -> impl Responder {
     let (collection, shard, snapshot) = path.into_inner();
-    let future =
-        common::snapshots::delete_shard_snapshot(toc.into_inner(), collection, shard, snapshot)
-            .map_ok(|_| true)
-            .map_err(Into::into);
+    let future = common::snapshots::delete_shard_snapshot(
+        toc.into_inner(),
+        claims.into_inner(),
+        collection,
+        shard,
+        snapshot,
+    )
+    .map_ok(|_| true)
+    .map_err(Into::into);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }

commit f6eba9382ba1bab63567b3f47a68443fdf3eafbd
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Mar 25 17:09:07 2024 +0000

    Refactor actix response handlers (#3907)
    
    * Refactor actix response handlers
    
    * Drop HttpError

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index a6f1e1034..16ae03c46 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -31,10 +31,7 @@ use validator::Validate;
 
 use super::CollectionPath;
 use crate::actix::auth::Extension;
-use crate::actix::helpers;
-use crate::actix::helpers::{
-    accepted_response, collection_into_actix_error, process_response, storage_into_actix_error,
-};
+use crate::actix::helpers::{self, process_response, HttpError};
 use crate::common;
 use crate::common::collections::*;
 use crate::common::http_client::HttpClient;
@@ -72,13 +69,9 @@ pub async fn do_get_full_snapshot(
     toc: &TableOfContent,
     claims: Option<Claims>,
     snapshot_name: &str,
-) -> Result<NamedFile> {
-    check_manage_rights(claims.as_ref()).map_err(storage_into_actix_error)?;
-
-    let file_name = get_full_snapshot_path(toc, snapshot_name)
-        .await
-        .map_err(storage_into_actix_error)?;
-
+) -> Result<NamedFile, HttpError> {
+    check_manage_rights(claims.as_ref())?;
+    let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
 
@@ -130,20 +123,10 @@ pub async fn do_get_snapshot(
     claims: Option<Claims>,
     collection_name: &str,
     snapshot_name: &str,
-) -> Result<NamedFile> {
-    check_full_access_to_collection(claims.as_ref(), collection_name)
-        .map_err(storage_into_actix_error)?;
-
-    let collection = toc
-        .get_collection(collection_name)
-        .await
-        .map_err(storage_into_actix_error)?;
-
-    let file_name = collection
-        .get_snapshot_path(snapshot_name)
-        .await
-        .map_err(collection_into_actix_error)?;
-
+) -> Result<NamedFile, HttpError> {
+    check_full_access_to_collection(claims.as_ref(), collection_name)?;
+    let collection = toc.get_collection(collection_name).await?;
+    let file_name = collection.get_snapshot_path(snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
 
@@ -168,21 +151,10 @@ async fn create_snapshot(
     claims: Extension<Claims>,
 ) -> impl Responder {
     let collection_name = path.into_inner();
-    let wait = params.wait.unwrap_or(true);
-
-    let timing = Instant::now();
-    let response = do_create_snapshot(
-        dispatcher.get_ref(),
-        claims.into_inner(),
-        &collection_name,
-        wait,
-    )
-    .await;
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        do_create_snapshot(dispatcher.get_ref(), claims.into_inner(), &collection_name)
+    })
+    .await
 }
 
 #[post("/collections/{name}/snapshots/upload")]
@@ -194,60 +166,38 @@ async fn upload_snapshot(
     params: valid::Query<SnapshotUploadingParam>,
     claims: Extension<Claims>,
 ) -> impl Responder {
-    let timing = Instant::now();
-    let snapshot = form.snapshot;
-    let wait = params.wait.unwrap_or(true);
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        let snapshot = form.snapshot;
 
-    match check_manage_rights(claims.into_inner().as_ref()) {
-        Ok(_) => (),
-        Err(err) => return process_response::<()>(Err(err), timing),
-    }
+        check_manage_rights(claims.into_inner().as_ref())?;
 
-    if let Some(checksum) = &params.checksum {
-        let snapshot_checksum = match hash_file(snapshot.file.path()).await {
-            Ok(checksum) => checksum,
-            Err(err) => return process_response::<()>(Err(err.into()), timing),
-        };
-        if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
-            return process_response::<()>(
-                Err(StorageError::checksum_mismatch(snapshot_checksum, checksum)),
-                timing,
-            );
+        if let Some(checksum) = &params.checksum {
+            let snapshot_checksum = hash_file(snapshot.file.path()).await?;
+            if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
+                return Err(StorageError::checksum_mismatch(snapshot_checksum, checksum));
+            }
         }
-    }
-
-    let snapshot_location =
-        match do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot).await {
-            Ok(location) => location,
-            Err(err) => return process_response::<()>(Err(err), timing),
-        };
 
-    let http_client = match http_client.client() {
-        Ok(http_client) => http_client,
-        Err(err) => return process_response::<()>(Err(err.into()), timing),
-    };
+        let snapshot_location =
+            do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot).await?;
 
-    let snapshot_recover = SnapshotRecover {
-        location: snapshot_location,
-        priority: params.priority,
-        checksum: None,
-    };
+        let http_client = http_client.client()?;
 
-    let response = do_recover_from_snapshot(
-        dispatcher.get_ref(),
-        &collection.name,
-        snapshot_recover,
-        wait,
-        None,
-        http_client,
-    )
-    .await;
+        let snapshot_recover = SnapshotRecover {
+            location: snapshot_location,
+            priority: params.priority,
+            checksum: None,
+        };
 
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+        do_recover_from_snapshot(
+            dispatcher.get_ref(),
+            &collection.name,
+            snapshot_recover,
+            None,
+            http_client,
+        )
+    })
+    .await
 }
 
 #[put("/collections/{name}/snapshots/recover")]
@@ -259,30 +209,18 @@ async fn recover_from_snapshot(
     params: valid::Query<SnapshottingParam>,
     claims: Extension<Claims>,
 ) -> impl Responder {
-    let timing = Instant::now();
-    let snapshot_recover = request.into_inner();
-    let wait = params.wait.unwrap_or(true);
-
-    let http_client = match http_client.client() {
-        Ok(http_client) => http_client,
-        Err(err) => return process_response::<()>(Err(err.into()), timing),
-    };
-
-    let response = do_recover_from_snapshot(
-        dispatcher.get_ref(),
-        &collection.name,
-        snapshot_recover,
-        wait,
-        claims.into_inner(),
-        http_client,
-    )
-    .await;
-
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        let snapshot_recover = request.into_inner();
+        let http_client = http_client.client()?;
+        do_recover_from_snapshot(
+            dispatcher.get_ref(),
+            &collection.name,
+            snapshot_recover,
+            claims.into_inner(),
+            http_client,
+        )
+    })
+    .await
 }
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
@@ -311,14 +249,10 @@ async fn create_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     claims: Extension<Claims>,
 ) -> impl Responder {
-    let timing = Instant::now();
-    let wait = params.wait.unwrap_or(true);
-    let response = do_create_full_snapshot(dispatcher.get_ref(), claims.into_inner(), wait).await;
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        do_create_full_snapshot(dispatcher.get_ref(), claims.into_inner())
+    })
+    .await
 }
 
 #[get("/snapshots/{snapshot_name}")]
@@ -338,21 +272,11 @@ async fn delete_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     claims: Extension<Claims>,
 ) -> impl Responder {
-    let snapshot_name = path.into_inner();
-    let timing = Instant::now();
-    let wait = params.wait.unwrap_or(true);
-    let response = do_delete_full_snapshot(
-        dispatcher.get_ref(),
-        claims.into_inner(),
-        &snapshot_name,
-        wait,
-    )
-    .await;
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        let snapshot_name = path.into_inner();
+        do_delete_full_snapshot(dispatcher.get_ref(), claims.into_inner(), &snapshot_name).await
+    })
+    .await
 }
 
 #[delete("/collections/{name}/snapshots/{snapshot_name}")]
@@ -362,22 +286,17 @@ async fn delete_collection_snapshot(
     params: valid::Query<SnapshottingParam>,
     claims: Extension<Claims>,
 ) -> impl Responder {
-    let (collection_name, snapshot_name) = path.into_inner();
-    let timing = Instant::now();
-    let wait = params.wait.unwrap_or(true);
-    let response = do_delete_collection_snapshot(
-        dispatcher.get_ref(),
-        claims.into_inner(),
-        &collection_name,
-        &snapshot_name,
-        wait,
-    )
-    .await;
-    match response {
-        Err(_) => process_response(response, timing),
-        Ok(_) if wait => process_response(response, timing),
-        Ok(_) => accepted_response(timing),
-    }
+    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+        let (collection_name, snapshot_name) = path.into_inner();
+        do_delete_collection_snapshot(
+            dispatcher.get_ref(),
+            claims.into_inner(),
+            &collection_name,
+            &snapshot_name,
+        )
+        .await
+    })
+    .await
 }
 
 #[get("/collections/{collection}/shards/{shard}/snapshots")]
@@ -411,8 +330,7 @@ async fn create_shard_snapshot(
         claims.into_inner(),
         collection,
         shard,
-    )
-    .map_err(Into::into);
+    );
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -469,14 +387,12 @@ async fn upload_shard_snapshot(
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
-        check_manage_rights(claims.into_inner().as_ref())
-            .map_err(Into::<helpers::HttpError>::into)?;
+        check_manage_rights(claims.into_inner().as_ref())?;
 
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
             if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
-                let err = StorageError::checksum_mismatch(snapshot_checksum, checksum);
-                return Result::<_, helpers::HttpError>::Err(err.into());
+                return Err(StorageError::checksum_mismatch(snapshot_checksum, checksum));
             }
         }
 
@@ -484,7 +400,7 @@ async fn upload_shard_snapshot(
             let collection = toc.get_collection(&collection).await?;
             collection.assert_shard_exists(shard).await?;
 
-            Result::<_, helpers::HttpError>::Ok(collection)
+            Result::<_, StorageError>::Ok(collection)
         };
 
         let collection = cancel::future::cancel_on_token(cancel.clone(), future).await??;
@@ -500,10 +416,9 @@ async fn upload_shard_snapshot(
         )
         .await?;
 
-        Result::<_, helpers::HttpError>::Ok(())
+        Ok(())
     })
-    .map_err(Into::into)
-    .map(|res| res.and_then(|res| res));
+    .map(|x| x.map_err(Into::into).and_then(|x| x));
 
     helpers::time_or_accept(future, wait.unwrap_or(true)).await
 }
@@ -513,7 +428,7 @@ async fn download_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId, String)>,
     claims: Extension<Claims>,
-) -> Result<impl Responder, helpers::HttpError> {
+) -> Result<impl Responder, HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
     check_full_access_to_collection(claims.into_inner().as_ref(), &collection)?;
     let collection = toc.get_collection(&collection).await?;

commit 802641f9d6725eaf01eb5c9d3fb71151e7b00045
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Mar 27 15:44:26 2024 +0000

    RBAC: Introduce Access object and use it (#3925)
    
    * Introduce Access object and use it
    
    * Make Access non-optional
    
    * Allow creating sharding key if collection claim is not present
    
    * Tear up rbac crate into the main crate and storage crate

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 16ae03c46..bbdd4b33b 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -13,7 +13,6 @@ use collection::operations::snapshot_ops::{
 };
 use collection::shards::shard::ShardId;
 use futures::{FutureExt as _, TryFutureExt as _};
-use rbac::jwt::Claims;
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
@@ -26,11 +25,12 @@ use storage::content_manager::snapshots::{
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
+use storage::rbac::access::Access;
 use uuid::Uuid;
 use validator::Validate;
 
 use super::CollectionPath;
-use crate::actix::auth::Extension;
+use crate::actix::auth::ActixAccess;
 use crate::actix::helpers::{self, process_response, HttpError};
 use crate::common;
 use crate::common::collections::*;
@@ -67,10 +67,10 @@ pub struct SnapshottingForm {
 // Actix specific code
 pub async fn do_get_full_snapshot(
     toc: &TableOfContent,
-    claims: Option<Claims>,
+    access: Access,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    check_manage_rights(claims.as_ref())?;
+    check_manage_rights(&access)?;
     let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
@@ -120,11 +120,11 @@ pub async fn do_save_uploaded_snapshot(
 // Actix specific code
 pub async fn do_get_snapshot(
     toc: &TableOfContent,
-    claims: Option<Claims>,
+    access: Access,
     collection_name: &str,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    check_full_access_to_collection(claims.as_ref(), collection_name)?;
+    check_full_access_to_collection(&access, collection_name)?;
     let collection = toc.get_collection(collection_name).await?;
     let file_name = collection.get_snapshot_path(snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
@@ -134,12 +134,12 @@ pub async fn do_get_snapshot(
 async fn list_snapshots(
     toc: web::Data<TableOfContent>,
     path: web::Path<String>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     let timing = Instant::now();
 
-    let response = do_list_snapshots(&toc, claims.into_inner(), &collection_name).await;
+    let response = do_list_snapshots(&toc, access, &collection_name).await;
     process_response(response, timing)
 }
 
@@ -148,11 +148,11 @@ async fn create_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     params: valid::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_snapshot(dispatcher.get_ref(), claims.into_inner(), &collection_name)
+        do_create_snapshot(dispatcher.get_ref(), access, &collection_name)
     })
     .await
 }
@@ -164,12 +164,12 @@ async fn upload_snapshot(
     collection: valid::Path<CollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     params: valid::Query<SnapshotUploadingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot = form.snapshot;
 
-        check_manage_rights(claims.into_inner().as_ref())?;
+        check_manage_rights(&access)?;
 
         if let Some(checksum) = &params.checksum {
             let snapshot_checksum = hash_file(snapshot.file.path()).await?;
@@ -193,7 +193,7 @@ async fn upload_snapshot(
             dispatcher.get_ref(),
             &collection.name,
             snapshot_recover,
-            None,
+            Access::full(),
             http_client,
         )
     })
@@ -207,7 +207,7 @@ async fn recover_from_snapshot(
     collection: valid::Path<CollectionPath>,
     request: valid::Json<SnapshotRecover>,
     params: valid::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot_recover = request.into_inner();
@@ -216,7 +216,7 @@ async fn recover_from_snapshot(
             dispatcher.get_ref(),
             &collection.name,
             snapshot_recover,
-            claims.into_inner(),
+            access,
             http_client,
         )
     })
@@ -227,19 +227,19 @@ async fn recover_from_snapshot(
 async fn get_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, String)>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
-    do_get_snapshot(&toc, claims.into_inner(), &collection_name, &snapshot_name).await
+    do_get_snapshot(&toc, access, &collection_name, &snapshot_name).await
 }
 
 #[get("/snapshots")]
 async fn list_full_snapshots(
     toc: web::Data<TableOfContent>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let timing = Instant::now();
-    let response = do_list_full_snapshots(toc.get_ref(), claims.into_inner()).await;
+    let response = do_list_full_snapshots(toc.get_ref(), access).await;
     process_response(response, timing)
 }
 
@@ -247,10 +247,10 @@ async fn list_full_snapshots(
 async fn create_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
     params: valid::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_full_snapshot(dispatcher.get_ref(), claims.into_inner())
+        do_create_full_snapshot(dispatcher.get_ref(), access)
     })
     .await
 }
@@ -259,10 +259,10 @@ async fn create_full_snapshot(
 async fn get_full_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<String>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(&toc, claims.into_inner(), &snapshot_name).await
+    do_get_full_snapshot(&toc, access, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -270,11 +270,11 @@ async fn delete_full_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     params: valid::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot_name = path.into_inner();
-        do_delete_full_snapshot(dispatcher.get_ref(), claims.into_inner(), &snapshot_name).await
+        do_delete_full_snapshot(dispatcher.get_ref(), access, &snapshot_name).await
     })
     .await
 }
@@ -284,13 +284,13 @@ async fn delete_collection_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
     params: valid::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let (collection_name, snapshot_name) = path.into_inner();
         do_delete_collection_snapshot(
             dispatcher.get_ref(),
-            claims.into_inner(),
+            access,
             &collection_name,
             &snapshot_name,
         )
@@ -303,16 +303,12 @@ async fn delete_collection_snapshot(
 async fn list_shard_snapshots(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId)>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future = common::snapshots::list_shard_snapshots(
-        toc.into_inner(),
-        claims.into_inner(),
-        collection,
-        shard,
-    )
-    .map_err(Into::into);
+    let future =
+        common::snapshots::list_shard_snapshots(toc.into_inner(), access, collection, shard)
+            .map_err(Into::into);
 
     helpers::time(future).await
 }
@@ -322,15 +318,11 @@ async fn create_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future = common::snapshots::create_shard_snapshot(
-        toc.into_inner(),
-        claims.into_inner(),
-        collection,
-        shard,
-    );
+    let future =
+        common::snapshots::create_shard_snapshot(toc.into_inner(), access, collection, shard);
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -343,14 +335,14 @@ async fn recover_shard_snapshot(
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
     web::Json(request): web::Json<ShardSnapshotRecover>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let future = async move {
         let (collection, shard) = path.into_inner();
 
         common::snapshots::recover_shard_snapshot(
             toc.into_inner(),
-            claims.into_inner(),
+            access,
             collection,
             shard,
             request.location,
@@ -373,7 +365,7 @@ async fn upload_shard_snapshot(
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshotUploadingParam>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
     let SnapshotUploadingParam {
@@ -387,7 +379,7 @@ async fn upload_shard_snapshot(
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
-        check_manage_rights(claims.into_inner().as_ref())?;
+        check_manage_rights(&access)?;
 
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
@@ -427,10 +419,10 @@ async fn upload_shard_snapshot(
 async fn download_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId, String)>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
-    check_full_access_to_collection(claims.into_inner().as_ref(), &collection)?;
+    check_full_access_to_collection(&access, &collection)?;
     let collection = toc.get_collection(&collection).await?;
     let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
 
@@ -442,12 +434,12 @@ async fn delete_shard_snapshot(
     toc: web::Data<TableOfContent>,
     path: web::Path<(String, ShardId, String)>,
     query: web::Query<SnapshottingParam>,
-    claims: Extension<Claims>,
+    ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard, snapshot) = path.into_inner();
     let future = common::snapshots::delete_shard_snapshot(
         toc.into_inner(),
-        claims.into_inner(),
+        access,
         collection,
         shard,
         snapshot,

commit 45f702629579f234e74fcc5e0ac48cf6110457f9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Mar 28 12:46:12 2024 +0000

    RBAC: introduce CollectionPass (#3932)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index bbdd4b33b..683514275 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -16,7 +16,6 @@ use futures::{FutureExt as _, TryFutureExt as _};
 use reqwest::Url;
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
-use storage::content_manager::claims::{check_full_access_to_collection, check_manage_rights};
 use storage::content_manager::errors::StorageError;
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
@@ -70,7 +69,7 @@ pub async fn do_get_full_snapshot(
     access: Access,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    check_manage_rights(&access)?;
+    access.check_manage_rights()?;
     let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
@@ -124,8 +123,8 @@ pub async fn do_get_snapshot(
     collection_name: &str,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    check_full_access_to_collection(&access, collection_name)?;
-    let collection = toc.get_collection(collection_name).await?;
+    let collection_pass = access.check_whole_collection_rights(collection_name)?;
+    let collection = toc.get_collection_by_pass(&collection_pass).await?;
     let file_name = collection.get_snapshot_path(snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
@@ -169,7 +168,7 @@ async fn upload_snapshot(
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot = form.snapshot;
 
-        check_manage_rights(&access)?;
+        access.check_manage_rights()?;
 
         if let Some(checksum) = &params.checksum {
             let snapshot_checksum = hash_file(snapshot.file.path()).await?;
@@ -379,7 +378,7 @@ async fn upload_shard_snapshot(
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
-        check_manage_rights(&access)?;
+        let multipass = access.check_manage_rights()?;
 
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
@@ -389,7 +388,9 @@ async fn upload_shard_snapshot(
         }
 
         let future = async {
-            let collection = toc.get_collection(&collection).await?;
+            let collection = toc
+                .get_collection_by_pass(&multipass.issue_pass(&collection))
+                .await?;
             collection.assert_shard_exists(shard).await?;
 
             Result::<_, StorageError>::Ok(collection)
@@ -422,8 +423,8 @@ async fn download_shard_snapshot(
     ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
-    check_full_access_to_collection(&access, &collection)?;
-    let collection = toc.get_collection(&collection).await?;
+    let collection_pass = access.check_whole_collection_rights(&collection)?;
+    let collection = toc.get_collection_by_pass(&collection_pass).await?;
     let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
 
     Ok(NamedFile::open(snapshot_path))

commit e4286f98b5334f60bdb7ec03753623f1effa9f1b
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 3 13:10:46 2024 +0000

    RBAC: new JWT schema (#3941)
    
    * RBAC: new JWT schema
    
    * Address review comments
    
    Renames, validation, default values, drop Ord
    
    * require access to whole collection to read its stats
    
    * fmt
    
    * remove unrelated
    
    * Introduce AccessRequrements
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 683514275..7abc99953 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -24,7 +24,7 @@ use storage::content_manager::snapshots::{
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
-use storage::rbac::access::Access;
+use storage::rbac::{Access, AccessRequrements};
 use uuid::Uuid;
 use validator::Validate;
 
@@ -69,7 +69,7 @@ pub async fn do_get_full_snapshot(
     access: Access,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    access.check_manage_rights()?;
+    access.check_global_access(AccessRequrements::new())?;
     let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
@@ -123,7 +123,8 @@ pub async fn do_get_snapshot(
     collection_name: &str,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    let collection_pass = access.check_whole_collection_rights(collection_name)?;
+    let collection_pass =
+        access.check_collection_access(collection_name, AccessRequrements::new().whole())?;
     let collection = toc.get_collection_by_pass(&collection_pass).await?;
     let file_name = collection.get_snapshot_path(snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
@@ -151,7 +152,7 @@ async fn create_snapshot(
 ) -> impl Responder {
     let collection_name = path.into_inner();
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_snapshot(dispatcher.get_ref(), access, &collection_name)
+        do_create_snapshot(dispatcher.toc().clone(), access, &collection_name)
     })
     .await
 }
@@ -168,7 +169,7 @@ async fn upload_snapshot(
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot = form.snapshot;
 
-        access.check_manage_rights()?;
+        access.check_global_access(AccessRequrements::new().manage())?;
 
         if let Some(checksum) = &params.checksum {
             let snapshot_checksum = hash_file(snapshot.file.path()).await?;
@@ -178,7 +179,7 @@ async fn upload_snapshot(
         }
 
         let snapshot_location =
-            do_save_uploaded_snapshot(dispatcher.get_ref(), &collection.name, snapshot).await?;
+            do_save_uploaded_snapshot(dispatcher.toc(), &collection.name, snapshot).await?;
 
         let http_client = http_client.client()?;
 
@@ -192,7 +193,7 @@ async fn upload_snapshot(
             dispatcher.get_ref(),
             &collection.name,
             snapshot_recover,
-            Access::full(),
+            Access::full("Already checked"),
             http_client,
         )
     })
@@ -378,7 +379,9 @@ async fn upload_shard_snapshot(
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
-        let multipass = access.check_manage_rights()?;
+        let collection_pass = access
+            .check_global_access(AccessRequrements::new().manage())?
+            .issue_pass(&collection);
 
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
@@ -388,9 +391,7 @@ async fn upload_shard_snapshot(
         }
 
         let future = async {
-            let collection = toc
-                .get_collection_by_pass(&multipass.issue_pass(&collection))
-                .await?;
+            let collection = toc.get_collection_by_pass(&collection_pass).await?;
             collection.assert_shard_exists(shard).await?;
 
             Result::<_, StorageError>::Ok(collection)
@@ -423,7 +424,8 @@ async fn download_shard_snapshot(
     ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
-    let collection_pass = access.check_whole_collection_rights(&collection)?;
+    let collection_pass =
+        access.check_collection_access(&collection, AccessRequrements::new().whole())?;
     let collection = toc.get_collection_by_pass(&collection_pass).await?;
     let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
 

commit ae08d856b764cbe762047dbfdc318f2adfe85627
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Apr 8 22:19:43 2024 +0000

    RBAC: require access token in ToC functions (#3972)
    
    * claims -> access
    
    * Require access for Dispatcher::toc()
    
    * Require Access for various collection functions
    
    * review fixes
    
    * comment nit
    
    * Add periods to docsting
    
    * Disallow creating and deleting sharding keys for non-manage access
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 7abc99953..c88d01f89 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -24,7 +24,7 @@ use storage::content_manager::snapshots::{
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
-use storage::rbac::{Access, AccessRequrements};
+use storage::rbac::{Access, AccessRequirements};
 use uuid::Uuid;
 use validator::Validate;
 
@@ -69,7 +69,7 @@ pub async fn do_get_full_snapshot(
     access: Access,
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
-    access.check_global_access(AccessRequrements::new())?;
+    access.check_global_access(AccessRequirements::new())?;
     let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
@@ -124,22 +124,22 @@ pub async fn do_get_snapshot(
     snapshot_name: &str,
 ) -> Result<NamedFile, HttpError> {
     let collection_pass =
-        access.check_collection_access(collection_name, AccessRequrements::new().whole())?;
-    let collection = toc.get_collection_by_pass(&collection_pass).await?;
+        access.check_collection_access(collection_name, AccessRequirements::new().whole())?;
+    let collection = toc.get_collection(&collection_pass).await?;
     let file_name = collection.get_snapshot_path(snapshot_name).await?;
     Ok(NamedFile::open(file_name)?)
 }
 
 #[get("/collections/{name}/snapshots")]
 async fn list_snapshots(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let collection_name = path.into_inner();
     let timing = Instant::now();
 
-    let response = do_list_snapshots(&toc, access, &collection_name).await;
+    let response = do_list_snapshots(dispatcher.toc(&access), access, &collection_name).await;
     process_response(response, timing)
 }
 
@@ -152,7 +152,7 @@ async fn create_snapshot(
 ) -> impl Responder {
     let collection_name = path.into_inner();
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_snapshot(dispatcher.toc().clone(), access, &collection_name)
+        do_create_snapshot(dispatcher.toc(&access).clone(), access, &collection_name)
     })
     .await
 }
@@ -169,7 +169,7 @@ async fn upload_snapshot(
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot = form.snapshot;
 
-        access.check_global_access(AccessRequrements::new().manage())?;
+        access.check_global_access(AccessRequirements::new().manage())?;
 
         if let Some(checksum) = &params.checksum {
             let snapshot_checksum = hash_file(snapshot.file.path()).await?;
@@ -179,7 +179,7 @@ async fn upload_snapshot(
         }
 
         let snapshot_location =
-            do_save_uploaded_snapshot(dispatcher.toc(), &collection.name, snapshot).await?;
+            do_save_uploaded_snapshot(dispatcher.toc(&access), &collection.name, snapshot).await?;
 
         let http_client = http_client.client()?;
 
@@ -193,7 +193,7 @@ async fn upload_snapshot(
             dispatcher.get_ref(),
             &collection.name,
             snapshot_recover,
-            Access::full("Already checked"),
+            access,
             http_client,
         )
     })
@@ -225,21 +225,27 @@ async fn recover_from_snapshot(
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
-    do_get_snapshot(&toc, access, &collection_name, &snapshot_name).await
+    do_get_snapshot(
+        dispatcher.toc(&access),
+        access,
+        &collection_name,
+        &snapshot_name,
+    )
+    .await
 }
 
 #[get("/snapshots")]
 async fn list_full_snapshots(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let timing = Instant::now();
-    let response = do_list_full_snapshots(toc.get_ref(), access).await;
+    let response = do_list_full_snapshots(dispatcher.toc(&access), access).await;
     process_response(response, timing)
 }
 
@@ -257,12 +263,12 @@ async fn create_full_snapshot(
 
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(&toc, access, &snapshot_name).await
+    do_get_full_snapshot(dispatcher.toc(&access), access, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -301,28 +307,36 @@ async fn delete_collection_snapshot(
 
 #[get("/collections/{collection}/shards/{shard}/snapshots")]
 async fn list_shard_snapshots(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future =
-        common::snapshots::list_shard_snapshots(toc.into_inner(), access, collection, shard)
-            .map_err(Into::into);
+    let future = common::snapshots::list_shard_snapshots(
+        dispatcher.toc(&access).clone(),
+        access,
+        collection,
+        shard,
+    )
+    .map_err(Into::into);
 
     helpers::time(future).await
 }
 
 #[post("/collections/{collection}/shards/{shard}/snapshots")]
 async fn create_shard_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard) = path.into_inner();
-    let future =
-        common::snapshots::create_shard_snapshot(toc.into_inner(), access, collection, shard);
+    let future = common::snapshots::create_shard_snapshot(
+        dispatcher.toc(&access).clone(),
+        access,
+        collection,
+        shard,
+    );
 
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
@@ -330,7 +344,7 @@ async fn create_shard_snapshot(
 // TODO: `PUT` (same as `recover_from_snapshot`) or `POST`!?
 #[put("/collections/{collection}/shards/{shard}/snapshots/recover")]
 async fn recover_shard_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     http_client: web::Data<HttpClient>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
@@ -341,7 +355,7 @@ async fn recover_shard_snapshot(
         let (collection, shard) = path.into_inner();
 
         common::snapshots::recover_shard_snapshot(
-            toc.into_inner(),
+            dispatcher.toc(&access).clone(),
             access,
             collection,
             shard,
@@ -361,7 +375,7 @@ async fn recover_shard_snapshot(
 // TODO: `POST` (same as `upload_snapshot`) or `PUT`!?
 #[post("/collections/{collection}/shards/{shard}/snapshots/upload")]
 async fn upload_shard_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshotUploadingParam>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
@@ -380,7 +394,7 @@ async fn upload_shard_snapshot(
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
         let collection_pass = access
-            .check_global_access(AccessRequrements::new().manage())?
+            .check_global_access(AccessRequirements::new().manage())?
             .issue_pass(&collection);
 
         if let Some(checksum) = checksum {
@@ -391,7 +405,10 @@ async fn upload_shard_snapshot(
         }
 
         let future = async {
-            let collection = toc.get_collection_by_pass(&collection_pass).await?;
+            let collection = dispatcher
+                .toc(&access)
+                .get_collection(&collection_pass)
+                .await?;
             collection.assert_shard_exists(shard).await?;
 
             Result::<_, StorageError>::Ok(collection)
@@ -401,7 +418,7 @@ async fn upload_shard_snapshot(
 
         // `recover_shard_snapshot_impl` is *not* cancel safe
         common::snapshots::recover_shard_snapshot_impl(
-            &toc,
+            dispatcher.toc(&access),
             &collection,
             shard,
             form.snapshot.file.path(),
@@ -419,14 +436,17 @@ async fn upload_shard_snapshot(
 
 #[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
 async fn download_shard_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId, String)>,
     ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
     let (collection, shard, snapshot) = path.into_inner();
     let collection_pass =
-        access.check_collection_access(&collection, AccessRequrements::new().whole())?;
-    let collection = toc.get_collection_by_pass(&collection_pass).await?;
+        access.check_collection_access(&collection, AccessRequirements::new().whole())?;
+    let collection = dispatcher
+        .toc(&access)
+        .get_collection(&collection_pass)
+        .await?;
     let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
 
     Ok(NamedFile::open(snapshot_path))
@@ -434,14 +454,14 @@ async fn download_shard_snapshot(
 
 #[delete("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
 async fn delete_shard_snapshot(
-    toc: web::Data<TableOfContent>,
+    dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId, String)>,
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection, shard, snapshot) = path.into_inner();
     let future = common::snapshots::delete_shard_snapshot(
-        toc.into_inner(),
+        dispatcher.toc(&access).clone(),
         access,
         collection,
         shard,

commit 0134f047c3a1f5663d5a9451bc883a91d8e5ad6f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 9 09:43:26 2024 +0200

    use StrictCollectionPath for uploading collection snapshot (#3991)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index c88d01f89..f3eed408b 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -28,7 +28,7 @@ use storage::rbac::{Access, AccessRequirements};
 use uuid::Uuid;
 use validator::Validate;
 
-use super::CollectionPath;
+use super::{CollectionPath, StrictCollectionPath};
 use crate::actix::auth::ActixAccess;
 use crate::actix::helpers::{self, process_response, HttpError};
 use crate::common;
@@ -161,7 +161,7 @@ async fn create_snapshot(
 async fn upload_snapshot(
     dispatcher: web::Data<Dispatcher>,
     http_client: web::Data<HttpClient>,
-    collection: valid::Path<CollectionPath>,
+    collection: valid::Path<StrictCollectionPath>,
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     params: valid::Query<SnapshotUploadingParam>,
     ActixAccess(access): ActixAccess,

commit fe1458dc2ee84a4ee56851ecd5eec6b03908ef3f
Author: Tim Vise <tim+github@visee.me>
Date:   Thu May 2 17:10:34 2024 +0200

    Add API key field to snapshot restore, fix snapshot recovery with API key (#4155)
    
    * Add API key to HTTP client
    
    * Add API key field to snapshot recovery requests
    
    * Add API key to channel service
    
    * Provide API key when doing snapshot transfer
    
    * Configure API key header name constant in a central place
    
    * Reformat
    
    * Update OpenAPI spec
    
    * Remove suffixed spaces from configuration file
    
    * Allow to specify HTTP headers in some consensus test utility functions
    
    * Add snapshot transfer test with configured API key
    
    * Use random API key in test
    
    * Fix compilation errors and clippy warnings

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index f3eed408b..987c15bb5 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -181,12 +181,14 @@ async fn upload_snapshot(
         let snapshot_location =
             do_save_uploaded_snapshot(dispatcher.toc(&access), &collection.name, snapshot).await?;
 
-        let http_client = http_client.client()?;
+        // Snapshot is a local file, we do not need an API key for that
+        let http_client = http_client.client(None)?;
 
         let snapshot_recover = SnapshotRecover {
             location: snapshot_location,
             priority: params.priority,
             checksum: None,
+            api_key: None,
         };
 
         do_recover_from_snapshot(
@@ -211,7 +213,7 @@ async fn recover_from_snapshot(
 ) -> impl Responder {
     helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
         let snapshot_recover = request.into_inner();
-        let http_client = http_client.client()?;
+        let http_client = http_client.client(snapshot_recover.api_key.as_deref())?;
         do_recover_from_snapshot(
             dispatcher.get_ref(),
             &collection.name,
@@ -363,6 +365,7 @@ async fn recover_shard_snapshot(
             request.priority.unwrap_or_default(),
             request.checksum,
             http_client.as_ref().clone(),
+            request.api_key,
         )
         .await?;
 

commit 22c3ee286e9390cff9d060f9158c9751f0b64bd4
Author: Kenshin Tanaka <70839560+kemkemG0@users.noreply.github.com>
Date:   Fri May 10 23:54:23 2024 +0900

    Implement S3 snapshot manager (#4150)
    
    * Add SnapshotsStorageConfig enum(Local or S3) and deserialize implementation
    
    * [refactor]  use snapshots_config instead of s3_config
    
    * update config
    
    * add AWS official`aws-sdk-s3`
    
    * implement store_file() WITHOUT error handling
    
    * implement list_snapshots
    
    * implement delete_snapshot
    
    * run `cargo +nightly fmt`
    
    * delete println
    
    * implement get_stored_file
    
    * Add error handlings
    
    * Refactor AWS S3 configuration and error handling
    
    * fix bugs
    
    * create an empty test file
    
    * fix `alias_test.rs` for StorageConfig type
    
    * tempolary delete some test and try s3 test
    
    * Update integration-tests.yml to use snap instead of apt-get for installing yq
    
    * Update integration-tests.yml to use sudo when installing yq
    
    * add sudo
    
    * make (full/non-full) snapshots downloadable
    
    * debug
    
    * small fix
    
    * Add S3 endpoint URL configuration option
    
    * fix
    
    * fix
    
    * debug
    
    * fix endpoint
    
    * update to http://127.0.0.1:9000/
    
    * update
    
    * fix
    
    * fix `#[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]` for s3
    
    * put original tests back
    
    * refactor
    
    * small fix (delete println & echo)
    
    * use object_store and refactor
    
    * create snapshot_storage_ops and implement
    
    * Refactor get_appropriate_chunk_size function to adjust chunk size based on service limits and file size
    
    * cargo +nightly fmt --all
    
    * make it more abstract
    
    * Refactor SnapshotsStorageConfig deserialization in SnapShotsConfig
    
    * small update
    
    * small fix
    
    * Update dependencies in Cargo.lock
    
    * Update minio image to satantime/minio-server
    
    * Refactor snapshot storage paths in snapshots_manager.rs and snapshot_storage_ops.rs
    
    * Fix issue with downloaded file size not matching expected size in download_snapshot function
    
    * add flush
    
    * Use Streaming instead of donloading once
    
    * apply `cargo +nightly fmt --all`
    
    * Fix issue with opening file in SnapshotStream::LocalFS variant
    
    * Fix error handling in SnapshotStream::LocalFS variant
    
    * Add integration test for Shard Snapshot API with S3 storage (#7)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 987c15bb5..68d998e89 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,13 +1,13 @@
 use std::path::Path;
 
-use actix_files::NamedFile;
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
 use actix_web::rt::time::Instant;
-use actix_web::{delete, get, post, put, web, Responder, Result};
+use actix_web::{delete, get, post, put, web, HttpRequest, Responder, Result};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
 use collection::common::sha_256::{hash_file, hashes_equal};
+use collection::common::snapshot_stream::SnapshotStream;
 use collection::operations::snapshot_ops::{
     ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
@@ -20,7 +20,7 @@ use storage::content_manager::errors::StorageError;
 use storage::content_manager::snapshots::recover::do_recover_from_snapshot;
 use storage::content_manager::snapshots::{
     do_create_full_snapshot, do_delete_collection_snapshot, do_delete_full_snapshot,
-    do_list_full_snapshots, get_full_snapshot_path,
+    do_list_full_snapshots,
 };
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
@@ -65,13 +65,20 @@ pub struct SnapshottingForm {
 
 // Actix specific code
 pub async fn do_get_full_snapshot(
+    req: HttpRequest,
     toc: &TableOfContent,
     access: Access,
     snapshot_name: &str,
-) -> Result<NamedFile, HttpError> {
+) -> Result<SnapshotStream, HttpError> {
     access.check_global_access(AccessRequirements::new())?;
-    let file_name = get_full_snapshot_path(toc, snapshot_name).await?;
-    Ok(NamedFile::open(file_name)?)
+    let snapshots_storage_manager = toc.get_snapshots_storage_manager()?;
+    let snapshot_path = snapshots_storage_manager
+        .get_full_snapshot_path(toc.snapshots_path(), snapshot_name)
+        .await?;
+    let snapshot_stream = snapshots_storage_manager
+        .get_snapshot_stream(req, &snapshot_path)
+        .await?;
+    Ok(snapshot_stream)
 }
 
 pub async fn do_save_uploaded_snapshot(
@@ -118,16 +125,24 @@ pub async fn do_save_uploaded_snapshot(
 
 // Actix specific code
 pub async fn do_get_snapshot(
+    req: HttpRequest,
     toc: &TableOfContent,
     access: Access,
     collection_name: &str,
     snapshot_name: &str,
-) -> Result<NamedFile, HttpError> {
+) -> Result<SnapshotStream, HttpError> {
     let collection_pass =
         access.check_collection_access(collection_name, AccessRequirements::new().whole())?;
-    let collection = toc.get_collection(&collection_pass).await?;
-    let file_name = collection.get_snapshot_path(snapshot_name).await?;
-    Ok(NamedFile::open(file_name)?)
+    let collection: tokio::sync::RwLockReadGuard<collection::collection::Collection> =
+        toc.get_collection(&collection_pass).await?;
+    let snapshot_storage_manager = collection.get_snapshots_storage_manager()?;
+    let snapshot_path = snapshot_storage_manager
+        .get_snapshot_path(collection.snapshots_path(), snapshot_name)
+        .await?;
+    let snapshot_stream = snapshot_storage_manager
+        .get_snapshot_stream(req, &snapshot_path)
+        .await?;
+    Ok(snapshot_stream)
 }
 
 #[get("/collections/{name}/snapshots")]
@@ -227,12 +242,14 @@ async fn recover_from_snapshot(
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
+    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(
+        req,
         dispatcher.toc(&access),
         access,
         &collection_name,
@@ -265,12 +282,13 @@ async fn create_full_snapshot(
 
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
+    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(dispatcher.toc(&access), access, &snapshot_name).await
+    do_get_full_snapshot(req, dispatcher.toc(&access), access, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -439,6 +457,7 @@ async fn upload_shard_snapshot(
 
 #[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
 async fn download_shard_snapshot(
+    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId, String)>,
     ActixAccess(access): ActixAccess,
@@ -450,9 +469,19 @@ async fn download_shard_snapshot(
         .toc(&access)
         .get_collection(&collection_pass)
         .await?;
-    let snapshot_path = collection.get_shard_snapshot_path(shard, &snapshot).await?;
-
-    Ok(NamedFile::open(snapshot_path))
+    let snapshots_storage_manager = collection.get_snapshots_storage_manager()?;
+    let snapshot_path = snapshots_storage_manager
+        .get_shard_snapshot_path(
+            collection.shards_holder(),
+            shard,
+            collection.snapshots_path(),
+            &snapshot,
+        )
+        .await?;
+    let snapshot_stream = snapshots_storage_manager
+        .get_snapshot_stream(req, &snapshot_path)
+        .await?;
+    Ok(snapshot_stream)
 }
 
 #[delete("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]

commit a06d20fb58a70f369c3a3b40178b726a291e6423
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 8 07:51:59 2024 +0000

    Remove dead code (#4623)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 68d998e89..8a3462b05 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -35,13 +35,6 @@ use crate::common;
 use crate::common::collections::*;
 use crate::common::http_client::HttpClient;
 
-#[derive(Deserialize, Validate)]
-struct SnapshotPath {
-    #[serde(rename = "snapshot_name")]
-    #[validate(length(min = 1))]
-    name: String,
-}
-
 #[derive(Deserialize, Serialize, JsonSchema, Validate)]
 pub struct SnapshotUploadingParam {
     pub wait: Option<bool>,

commit 29126883bc8865a0a936496ac61bc5019789c387
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Aug 15 15:22:51 2024 +0200

    Update Validator 0.18 (#4894)
    
    * Update Validator 0.18
    
    * fix new test error message
    
    * clearer geo error message
    
    * fix error message
    
    * fix unit tests
    
    * Put spaces back
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 8a3462b05..52eb74903 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -42,7 +42,7 @@ pub struct SnapshotUploadingParam {
 
     /// Optional SHA256 checksum to verify snapshot integrity before recovery.
     #[serde(default)]
-    #[validate(custom = "::common::validation::validate_sha256_hash")]
+    #[validate(custom(function = "::common::validation::validate_sha256_hash"))]
     pub checksum: Option<String>,
 }
 

commit 217b87e76c59fb47616f2b6fe8ab23bd6fa1a048
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Aug 20 09:05:21 2024 +0200

    Wrap handler body in helpers::time (#4901)
    
    * wrap handler body in helpers::time
    
    * remove unnecessary async closures
    
    * fix clippy
    
    * remove more async closures
    
    * avoid another async {}
    
    * remove more async {}
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 52eb74903..26b367d57 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -2,7 +2,6 @@ use std::path::Path;
 
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
-use actix_web::rt::time::Instant;
 use actix_web::{delete, get, post, put, web, HttpRequest, Responder, Result};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
@@ -30,7 +29,7 @@ use validator::Validate;
 
 use super::{CollectionPath, StrictCollectionPath};
 use crate::actix::auth::ActixAccess;
-use crate::actix::helpers::{self, process_response, HttpError};
+use crate::actix::helpers::{self, HttpError};
 use crate::common;
 use crate::common::collections::*;
 use crate::common::http_client::HttpClient;
@@ -144,11 +143,7 @@ async fn list_snapshots(
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    let collection_name = path.into_inner();
-    let timing = Instant::now();
-
-    let response = do_list_snapshots(dispatcher.toc(&access), access, &collection_name).await;
-    process_response(response, timing)
+    helpers::time(do_list_snapshots(dispatcher.toc(&access), access, &path)).await
 }
 
 #[post("/collections/{name}/snapshots")]
@@ -256,9 +251,7 @@ async fn list_full_snapshots(
     dispatcher: web::Data<Dispatcher>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    let timing = Instant::now();
-    let response = do_list_full_snapshots(dispatcher.toc(&access), access).await;
-    process_response(response, timing)
+    helpers::time(do_list_full_snapshots(dispatcher.toc(&access), access)).await
 }
 
 #[post("/snapshots")]

commit 8374ec09cf0cf92638ad1fed786afdc8d50221a7
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Aug 27 10:19:28 2024 +0200

    Cleanup `actix::helpers` module (#4951)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 26b367d57..40ea0284d 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -77,7 +77,7 @@ pub async fn do_save_uploaded_snapshot(
     toc: &TableOfContent,
     collection_name: &str,
     snapshot: TempFile,
-) -> std::result::Result<Url, StorageError> {
+) -> Result<Url, StorageError> {
     let filename = snapshot
         .file_name
         // Sanitize the file name:
@@ -154,10 +154,12 @@ async fn create_snapshot(
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let collection_name = path.into_inner();
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_snapshot(dispatcher.toc(&access).clone(), access, &collection_name)
-    })
-    .await
+
+    let future = async move {
+        do_create_snapshot(dispatcher.toc(&access).clone(), access, &collection_name).await
+    };
+
+    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
 #[post("/collections/{name}/snapshots/upload")]
@@ -169,7 +171,9 @@ async fn upload_snapshot(
     params: valid::Query<SnapshotUploadingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+    let wait = params.wait;
+
+    let future = async move {
         let snapshot = form.snapshot;
 
         access.check_global_access(AccessRequirements::new().manage())?;
@@ -201,8 +205,10 @@ async fn upload_snapshot(
             access,
             http_client,
         )
-    })
-    .await
+        .await
+    };
+
+    helpers::time_or_accept(future, wait.unwrap_or(true)).await
 }
 
 #[put("/collections/{name}/snapshots/recover")]
@@ -214,9 +220,10 @@ async fn recover_from_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+    let future = async move {
         let snapshot_recover = request.into_inner();
         let http_client = http_client.client(snapshot_recover.api_key.as_deref())?;
+
         do_recover_from_snapshot(
             dispatcher.get_ref(),
             &collection.name,
@@ -224,8 +231,10 @@ async fn recover_from_snapshot(
             access,
             http_client,
         )
-    })
-    .await
+        .await
+    };
+
+    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
@@ -260,10 +269,8 @@ async fn create_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
-        do_create_full_snapshot(dispatcher.get_ref(), access)
-    })
-    .await
+    let future = async move { do_create_full_snapshot(dispatcher.get_ref(), access).await };
+    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
 #[get("/snapshots/{snapshot_name}")]
@@ -284,11 +291,12 @@ async fn delete_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+    let future = async move {
         let snapshot_name = path.into_inner();
         do_delete_full_snapshot(dispatcher.get_ref(), access, &snapshot_name).await
-    })
-    .await
+    };
+
+    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
 #[delete("/collections/{name}/snapshots/{snapshot_name}")]
@@ -298,8 +306,9 @@ async fn delete_collection_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time_or_accept_with_handle(params.wait.unwrap_or(true), async move {
+    let future = async move {
         let (collection_name, snapshot_name) = path.into_inner();
+
         do_delete_collection_snapshot(
             dispatcher.get_ref(),
             access,
@@ -307,8 +316,9 @@ async fn delete_collection_snapshot(
             &snapshot_name,
         )
         .await
-    })
-    .await
+    };
+
+    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
 #[get("/collections/{collection}/shards/{shard}/snapshots")]

commit 50c06177f4efd03829835fcf288a6b528dec40d8
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Sep 25 12:42:30 2024 +0200

    [Strict mode] Finish REST requests (#4990)
    
    * add strict mode to more requests
    
    * add timeout check from request query
    
    * unify timeout checking
    
    * adjust functions not requiring strict mode
    
    * add missing checks
    
    * add Prefetch check for query api
    
    * review remarks

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 40ea0284d..515ee86a7 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -10,6 +10,7 @@ use collection::common::snapshot_stream::SnapshotStream;
 use collection::operations::snapshot_ops::{
     ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
+use collection::operations::verification::new_unchecked_verification_pass;
 use collection::shards::shard::ShardId;
 use futures::{FutureExt as _, TryFutureExt as _};
 use reqwest::Url;
@@ -143,7 +144,15 @@ async fn list_snapshots(
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time(do_list_snapshots(dispatcher.toc(&access), access, &path)).await
+    // Nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
+    helpers::time(do_list_snapshots(
+        dispatcher.toc_new(&access, &pass),
+        access,
+        &path,
+    ))
+    .await
 }
 
 #[post("/collections/{name}/snapshots")]
@@ -153,10 +162,18 @@ async fn create_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // Nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let collection_name = path.into_inner();
 
     let future = async move {
-        do_create_snapshot(dispatcher.toc(&access).clone(), access, &collection_name).await
+        do_create_snapshot(
+            dispatcher.toc_new(&access, &pass).clone(),
+            access,
+            &collection_name,
+        )
+        .await
     };
 
     helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
@@ -173,6 +190,9 @@ async fn upload_snapshot(
 ) -> impl Responder {
     let wait = params.wait;
 
+    // Nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let future = async move {
         let snapshot = form.snapshot;
 
@@ -185,8 +205,12 @@ async fn upload_snapshot(
             }
         }
 
-        let snapshot_location =
-            do_save_uploaded_snapshot(dispatcher.toc(&access), &collection.name, snapshot).await?;
+        let snapshot_location = do_save_uploaded_snapshot(
+            dispatcher.toc_new(&access, &pass),
+            &collection.name,
+            snapshot,
+        )
+        .await?;
 
         // Snapshot is a local file, we do not need an API key for that
         let http_client = http_client.client(None)?;
@@ -244,10 +268,13 @@ async fn get_snapshot(
     path: web::Path<(String, String)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // Nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(
         req,
-        dispatcher.toc(&access),
+        dispatcher.toc_new(&access, &pass),
         access,
         &collection_name,
         &snapshot_name,
@@ -260,7 +287,14 @@ async fn list_full_snapshots(
     dispatcher: web::Data<Dispatcher>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    helpers::time(do_list_full_snapshots(dispatcher.toc(&access), access)).await
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
+    helpers::time(do_list_full_snapshots(
+        dispatcher.toc_new(&access, &pass),
+        access,
+    ))
+    .await
 }
 
 #[post("/snapshots")]
@@ -280,8 +314,17 @@ async fn get_full_snapshot(
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(req, dispatcher.toc(&access), access, &snapshot_name).await
+    do_get_full_snapshot(
+        req,
+        dispatcher.toc_new(&access, &pass),
+        access,
+        &snapshot_name,
+    )
+    .await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -327,9 +370,13 @@ async fn list_shard_snapshots(
     path: web::Path<(String, ShardId)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection, shard) = path.into_inner();
+
     let future = common::snapshots::list_shard_snapshots(
-        dispatcher.toc(&access).clone(),
+        dispatcher.toc_new(&access, &pass).clone(),
         access,
         collection,
         shard,
@@ -346,9 +393,12 @@ async fn create_shard_snapshot(
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection, shard) = path.into_inner();
     let future = common::snapshots::create_shard_snapshot(
-        dispatcher.toc(&access).clone(),
+        dispatcher.toc_new(&access, &pass).clone(),
         access,
         collection,
         shard,
@@ -367,11 +417,14 @@ async fn recover_shard_snapshot(
     web::Json(request): web::Json<ShardSnapshotRecover>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let future = async move {
         let (collection, shard) = path.into_inner();
 
         common::snapshots::recover_shard_snapshot(
-            dispatcher.toc(&access).clone(),
+            dispatcher.toc_new(&access, &pass).clone(),
             access,
             collection,
             shard,
@@ -398,6 +451,9 @@ async fn upload_shard_snapshot(
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection, shard) = path.into_inner();
     let SnapshotUploadingParam {
         wait,
@@ -423,7 +479,7 @@ async fn upload_shard_snapshot(
 
         let future = async {
             let collection = dispatcher
-                .toc(&access)
+                .toc_new(&access, &pass)
                 .get_collection(&collection_pass)
                 .await?;
             collection.assert_shard_exists(shard).await?;
@@ -435,7 +491,7 @@ async fn upload_shard_snapshot(
 
         // `recover_shard_snapshot_impl` is *not* cancel safe
         common::snapshots::recover_shard_snapshot_impl(
-            dispatcher.toc(&access),
+            dispatcher.toc_new(&access, &pass),
             &collection,
             shard,
             form.snapshot.file.path(),
@@ -458,11 +514,14 @@ async fn download_shard_snapshot(
     path: web::Path<(String, ShardId, String)>,
     ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection, shard, snapshot) = path.into_inner();
     let collection_pass =
         access.check_collection_access(&collection, AccessRequirements::new().whole())?;
     let collection = dispatcher
-        .toc(&access)
+        .toc_new(&access, &pass)
         .get_collection(&collection_pass)
         .await?;
     let snapshots_storage_manager = collection.get_snapshots_storage_manager()?;
@@ -487,9 +546,12 @@ async fn delete_shard_snapshot(
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
     let (collection, shard, snapshot) = path.into_inner();
     let future = common::snapshots::delete_shard_snapshot(
-        dispatcher.toc(&access).clone(),
+        dispatcher.toc_new(&access, &pass).clone(),
         access,
         collection,
         shard,

commit 9e1ccf62377bf3a8ff5885b807acb5e74f09ec31
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Sep 25 15:15:58 2024 +0200

    [Strict mode] migrate toc_new -> toc (#5120)
    
    * Replace all remaining calls of toc() with toc_new
    
    * mirgate toc_new -> toc

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 515ee86a7..27f9725da 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -148,7 +148,7 @@ async fn list_snapshots(
     let pass = new_unchecked_verification_pass();
 
     helpers::time(do_list_snapshots(
-        dispatcher.toc_new(&access, &pass),
+        dispatcher.toc(&access, &pass),
         access,
         &path,
     ))
@@ -169,7 +169,7 @@ async fn create_snapshot(
 
     let future = async move {
         do_create_snapshot(
-            dispatcher.toc_new(&access, &pass).clone(),
+            dispatcher.toc(&access, &pass).clone(),
             access,
             &collection_name,
         )
@@ -205,12 +205,9 @@ async fn upload_snapshot(
             }
         }
 
-        let snapshot_location = do_save_uploaded_snapshot(
-            dispatcher.toc_new(&access, &pass),
-            &collection.name,
-            snapshot,
-        )
-        .await?;
+        let snapshot_location =
+            do_save_uploaded_snapshot(dispatcher.toc(&access, &pass), &collection.name, snapshot)
+                .await?;
 
         // Snapshot is a local file, we do not need an API key for that
         let http_client = http_client.client(None)?;
@@ -274,7 +271,7 @@ async fn get_snapshot(
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(
         req,
-        dispatcher.toc_new(&access, &pass),
+        dispatcher.toc(&access, &pass),
         access,
         &collection_name,
         &snapshot_name,
@@ -291,7 +288,7 @@ async fn list_full_snapshots(
     let pass = new_unchecked_verification_pass();
 
     helpers::time(do_list_full_snapshots(
-        dispatcher.toc_new(&access, &pass),
+        dispatcher.toc(&access, &pass),
         access,
     ))
     .await
@@ -318,13 +315,7 @@ async fn get_full_snapshot(
     let pass = new_unchecked_verification_pass();
 
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(
-        req,
-        dispatcher.toc_new(&access, &pass),
-        access,
-        &snapshot_name,
-    )
-    .await
+    do_get_full_snapshot(req, dispatcher.toc(&access, &pass), access, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -376,7 +367,7 @@ async fn list_shard_snapshots(
     let (collection, shard) = path.into_inner();
 
     let future = common::snapshots::list_shard_snapshots(
-        dispatcher.toc_new(&access, &pass).clone(),
+        dispatcher.toc(&access, &pass).clone(),
         access,
         collection,
         shard,
@@ -398,7 +389,7 @@ async fn create_shard_snapshot(
 
     let (collection, shard) = path.into_inner();
     let future = common::snapshots::create_shard_snapshot(
-        dispatcher.toc_new(&access, &pass).clone(),
+        dispatcher.toc(&access, &pass).clone(),
         access,
         collection,
         shard,
@@ -424,7 +415,7 @@ async fn recover_shard_snapshot(
         let (collection, shard) = path.into_inner();
 
         common::snapshots::recover_shard_snapshot(
-            dispatcher.toc_new(&access, &pass).clone(),
+            dispatcher.toc(&access, &pass).clone(),
             access,
             collection,
             shard,
@@ -479,7 +470,7 @@ async fn upload_shard_snapshot(
 
         let future = async {
             let collection = dispatcher
-                .toc_new(&access, &pass)
+                .toc(&access, &pass)
                 .get_collection(&collection_pass)
                 .await?;
             collection.assert_shard_exists(shard).await?;
@@ -491,7 +482,7 @@ async fn upload_shard_snapshot(
 
         // `recover_shard_snapshot_impl` is *not* cancel safe
         common::snapshots::recover_shard_snapshot_impl(
-            dispatcher.toc_new(&access, &pass),
+            dispatcher.toc(&access, &pass),
             &collection,
             shard,
             form.snapshot.file.path(),
@@ -521,7 +512,7 @@ async fn download_shard_snapshot(
     let collection_pass =
         access.check_collection_access(&collection, AccessRequirements::new().whole())?;
     let collection = dispatcher
-        .toc_new(&access, &pass)
+        .toc(&access, &pass)
         .get_collection(&collection_pass)
         .await?;
     let snapshots_storage_manager = collection.get_snapshots_storage_manager()?;
@@ -551,7 +542,7 @@ async fn delete_shard_snapshot(
 
     let (collection, shard, snapshot) = path.into_inner();
     let future = common::snapshots::delete_shard_snapshot(
-        dispatcher.toc_new(&access, &pass).clone(),
+        dispatcher.toc(&access, &pass).clone(),
         access,
         collection,
         shard,

commit 89cce79dace19c8c28e0545bfd6ca46e1f6a436d
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Oct 4 16:36:19 2024 +0000

    Support SnapshotFormat::Streamable, add REST endpoint (#5178)

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 27f9725da..d82738844 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -2,7 +2,7 @@ use std::path::Path;
 
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
-use actix_web::{delete, get, post, put, web, HttpRequest, Responder, Result};
+use actix_web::{delete, get, post, put, web, HttpRequest, HttpResponse, Responder, Result};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
 use collection::common::sha_256::{hash_file, hashes_equal};
@@ -398,6 +398,27 @@ async fn create_shard_snapshot(
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
 
+#[get("/collections/{collection}/shards/{shard}/snapshot")]
+async fn stream_shard_snapshot(
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<(String, ShardId)>,
+    ActixAccess(access): ActixAccess,
+) -> Result<impl Responder, HttpError> {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
+    let (collection, shard) = path.into_inner();
+    let stream = common::snapshots::stream_shard_snapshot(
+        dispatcher.toc(&access, &pass).clone(),
+        access,
+        collection,
+        shard,
+    )
+    .await?;
+
+    Ok(HttpResponse::Ok().streaming(stream))
+}
+
 // TODO: `PUT` (same as `recover_from_snapshot`) or `POST`!?
 #[put("/collections/{collection}/shards/{shard}/snapshots/recover")]
 async fn recover_shard_snapshot(
@@ -568,6 +589,7 @@ pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
         .service(delete_collection_snapshot)
         .service(list_shard_snapshots)
         .service(create_shard_snapshot)
+        .service(stream_shard_snapshot)
         .service(recover_shard_snapshot)
         .service(upload_shard_snapshot)
         .service(download_shard_snapshot)

commit ba938316834e792331b49953482dea63799cadd1
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Oct 14 22:35:01 2024 +0000

    Fix shard snapshot operations for s3 (#5227)
    
    * Fix shard snapshot operations for s3
    
    * tests/shard-snapshot-api.sh: Improve error reporting
    
    * Drop SnapshotStorageManager::get_shard_snapshot_path
    
    * Fix s3 test on CI

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index d82738844..4f280b3b1 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -537,13 +537,11 @@ async fn download_shard_snapshot(
         .get_collection(&collection_pass)
         .await?;
     let snapshots_storage_manager = collection.get_snapshots_storage_manager()?;
-    let snapshot_path = snapshots_storage_manager
-        .get_shard_snapshot_path(
-            collection.shards_holder(),
-            shard,
-            collection.snapshots_path(),
-            &snapshot,
-        )
+    let snapshot_path = collection
+        .shards_holder()
+        .read()
+        .await
+        .get_shard_snapshot_path(collection.snapshots_path(), shard, &snapshot)
         .await?;
     let snapshot_stream = snapshots_storage_manager
         .get_snapshot_stream(req, &snapshot_path)

commit 02050108a057c18ad3a6f9df90bbf51370bf05e6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Oct 16 10:12:56 2024 +0000

    Use SnapshotStream both for S3 and streaming snapshots (#5238)
    
    * Use SnapshotStream both for S3 and streaming snapshots
    
    * Set Content-Disposition header for streaming shard snapshots

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 4f280b3b1..ef92d7920 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -2,7 +2,7 @@ use std::path::Path;
 
 use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
-use actix_web::{delete, get, post, put, web, HttpRequest, HttpResponse, Responder, Result};
+use actix_web::{delete, get, post, put, web, Responder, Result};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
 use collection::common::sha_256::{hash_file, hashes_equal};
@@ -58,7 +58,6 @@ pub struct SnapshottingForm {
 
 // Actix specific code
 pub async fn do_get_full_snapshot(
-    req: HttpRequest,
     toc: &TableOfContent,
     access: Access,
     snapshot_name: &str,
@@ -69,7 +68,7 @@ pub async fn do_get_full_snapshot(
         .get_full_snapshot_path(toc.snapshots_path(), snapshot_name)
         .await?;
     let snapshot_stream = snapshots_storage_manager
-        .get_snapshot_stream(req, &snapshot_path)
+        .get_snapshot_stream(&snapshot_path)
         .await?;
     Ok(snapshot_stream)
 }
@@ -118,7 +117,6 @@ pub async fn do_save_uploaded_snapshot(
 
 // Actix specific code
 pub async fn do_get_snapshot(
-    req: HttpRequest,
     toc: &TableOfContent,
     access: Access,
     collection_name: &str,
@@ -133,7 +131,7 @@ pub async fn do_get_snapshot(
         .get_snapshot_path(collection.snapshots_path(), snapshot_name)
         .await?;
     let snapshot_stream = snapshot_storage_manager
-        .get_snapshot_stream(req, &snapshot_path)
+        .get_snapshot_stream(&snapshot_path)
         .await?;
     Ok(snapshot_stream)
 }
@@ -260,7 +258,6 @@ async fn recover_from_snapshot(
 
 #[get("/collections/{name}/snapshots/{snapshot_name}")]
 async fn get_snapshot(
-    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, String)>,
     ActixAccess(access): ActixAccess,
@@ -270,7 +267,6 @@ async fn get_snapshot(
 
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(
-        req,
         dispatcher.toc(&access, &pass),
         access,
         &collection_name,
@@ -306,7 +302,6 @@ async fn create_full_snapshot(
 
 #[get("/snapshots/{snapshot_name}")]
 async fn get_full_snapshot(
-    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
@@ -315,7 +310,7 @@ async fn get_full_snapshot(
     let pass = new_unchecked_verification_pass();
 
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(req, dispatcher.toc(&access, &pass), access, &snapshot_name).await
+    do_get_full_snapshot(dispatcher.toc(&access, &pass), access, &snapshot_name).await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -403,20 +398,18 @@ async fn stream_shard_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId)>,
     ActixAccess(access): ActixAccess,
-) -> Result<impl Responder, HttpError> {
+) -> Result<SnapshotStream, HttpError> {
     // nothing to verify.
     let pass = new_unchecked_verification_pass();
 
     let (collection, shard) = path.into_inner();
-    let stream = common::snapshots::stream_shard_snapshot(
+    Ok(common::snapshots::stream_shard_snapshot(
         dispatcher.toc(&access, &pass).clone(),
         access,
         collection,
         shard,
     )
-    .await?;
-
-    Ok(HttpResponse::Ok().streaming(stream))
+    .await?)
 }
 
 // TODO: `PUT` (same as `recover_from_snapshot`) or `POST`!?
@@ -521,7 +514,6 @@ async fn upload_shard_snapshot(
 
 #[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
 async fn download_shard_snapshot(
-    req: HttpRequest,
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId, String)>,
     ActixAccess(access): ActixAccess,
@@ -544,7 +536,7 @@ async fn download_shard_snapshot(
         .get_shard_snapshot_path(collection.snapshots_path(), shard, &snapshot)
         .await?;
     let snapshot_stream = snapshots_storage_manager
-        .get_snapshot_stream(req, &snapshot_path)
+        .get_snapshot_stream(&snapshot_path)
         .await?;
     Ok(snapshot_stream)
 }

commit 4240e71859b86195c03d84ac363f9699b7bc0317
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 8 10:10:44 2024 +0100

    No useless async (#5401)
    
    * Remove unecessary async/await
    
    * clippy aftermath

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index ef92d7920..3048c78e1 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -64,9 +64,8 @@ pub async fn do_get_full_snapshot(
 ) -> Result<SnapshotStream, HttpError> {
     access.check_global_access(AccessRequirements::new())?;
     let snapshots_storage_manager = toc.get_snapshots_storage_manager()?;
-    let snapshot_path = snapshots_storage_manager
-        .get_full_snapshot_path(toc.snapshots_path(), snapshot_name)
-        .await?;
+    let snapshot_path =
+        snapshots_storage_manager.get_full_snapshot_path(toc.snapshots_path(), snapshot_name)?;
     let snapshot_stream = snapshots_storage_manager
         .get_snapshot_stream(&snapshot_path)
         .await?;
@@ -127,9 +126,8 @@ pub async fn do_get_snapshot(
     let collection: tokio::sync::RwLockReadGuard<collection::collection::Collection> =
         toc.get_collection(&collection_pass).await?;
     let snapshot_storage_manager = collection.get_snapshots_storage_manager()?;
-    let snapshot_path = snapshot_storage_manager
-        .get_snapshot_path(collection.snapshots_path(), snapshot_name)
-        .await?;
+    let snapshot_path =
+        snapshot_storage_manager.get_snapshot_path(collection.snapshots_path(), snapshot_name)?;
     let snapshot_stream = snapshot_storage_manager
         .get_snapshot_stream(&snapshot_path)
         .await?;

commit ee6ae82ed5c9d6d2708183a15e13c26403d81804
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jan 7 15:19:17 2025 +0000

    Impletement a special type of access to collection suitable for serverless (#5745)
    
    * Impletement a special type of access to collection suitable for serverless
    
    * fix test
    
    * fix test

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 3048c78e1..97af6be8f 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -121,8 +121,8 @@ pub async fn do_get_snapshot(
     collection_name: &str,
     snapshot_name: &str,
 ) -> Result<SnapshotStream, HttpError> {
-    let collection_pass =
-        access.check_collection_access(collection_name, AccessRequirements::new().whole())?;
+    let collection_pass = access
+        .check_collection_access(collection_name, AccessRequirements::new().whole().extras())?;
     let collection: tokio::sync::RwLockReadGuard<collection::collection::Collection> =
         toc.get_collection(&collection_pass).await?;
     let snapshot_storage_manager = collection.get_snapshots_storage_manager()?;
@@ -521,7 +521,7 @@ async fn download_shard_snapshot(
 
     let (collection, shard, snapshot) = path.into_inner();
     let collection_pass =
-        access.check_collection_access(&collection, AccessRequirements::new().whole())?;
+        access.check_collection_access(&collection, AccessRequirements::new().whole().extras())?;
     let collection = dispatcher
         .toc(&access, &pass)
         .get_collection(&collection_pass)

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 97af6be8f..1e786b8a1 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -1,8 +1,8 @@
 use std::path::Path;
 
-use actix_multipart::form::tempfile::TempFile;
 use actix_multipart::form::MultipartForm;
-use actix_web::{delete, get, post, put, web, Responder, Result};
+use actix_multipart::form::tempfile::TempFile;
+use actix_web::{Responder, Result, delete, get, post, put, web};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
 use collection::common::sha_256::{hash_file, hashes_equal};

commit f230629fa0e62e069e683cce60e24319ab3cc84b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 25 10:08:21 2025 +0100

    build(deps): bump log from 0.4.26 to 0.4.27 (#6247)
    
    * build(deps): bump log from 0.4.26 to 0.4.27
    
    Bumps [log](https://github.com/rust-lang/log) from 0.4.26 to 0.4.27.
    - [Release notes](https://github.com/rust-lang/log/releases)
    - [Changelog](https://github.com/rust-lang/log/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/rust-lang/log/compare/0.4.26...0.4.27)
    
    ---
    updated-dependencies:
    - dependency-name: log
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * put variables inside the strings for log macros
    
    * also for pyroscope
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/src/actix/api/snapshot_api.rs b/src/actix/api/snapshot_api.rs
index 1e786b8a1..269be6012 100644
--- a/src/actix/api/snapshot_api.rs
+++ b/src/actix/api/snapshot_api.rs
@@ -91,10 +91,7 @@ pub async fn do_save_uploaded_snapshot(
         .unwrap_or_else(|| Uuid::new_v4().to_string());
     let collection_snapshot_path = toc.snapshots_path_for_collection(collection_name);
     if !collection_snapshot_path.exists() {
-        log::debug!(
-            "Creating missing collection snapshots directory for {}",
-            collection_name
-        );
+        log::debug!("Creating missing collection snapshots directory for {collection_name}");
         toc.create_snapshots_path(collection_name).await?;
     }
 

