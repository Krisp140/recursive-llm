# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/shaper/harfbuzz.zig

commit e3c18f3f512f51f0311775c02ff28d3eede05dd1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 6 11:20:37 2022 -0800

    font: move shaper into comptime interface

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
new file mode 100644
index 00000000..d51e4da4
--- /dev/null
+++ b/src/font/shaper/harfbuzz.zig
@@ -0,0 +1,669 @@
+const std = @import("std");
+const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
+const harfbuzz = @import("harfbuzz");
+const trace = @import("tracy").trace;
+const font = @import("../main.zig");
+const Face = font.Face;
+const DeferredFace = font.DeferredFace;
+const Group = font.Group;
+const GroupCache = font.GroupCache;
+const Library = font.Library;
+const Style = font.Style;
+const Presentation = font.Presentation;
+const terminal = @import("../../terminal/main.zig");
+
+const log = std.log.scoped(.font_shaper);
+
+/// Shaper that uses Harfbuzz.
+pub const Shaper = struct {
+    /// The buffer used for text shaping. We reuse it across multiple shaping
+    /// calls to prevent allocations.
+    hb_buf: harfbuzz.Buffer,
+
+    /// The shared memory used for shaping results.
+    cell_buf: []Cell,
+
+    /// The cell_buf argument is the buffer to use for storing shaped results.
+    /// This should be at least the number of columns in the terminal.
+    pub fn init(cell_buf: []Cell) !Shaper {
+        return Shaper{
+            .hb_buf = try harfbuzz.Buffer.create(),
+            .cell_buf = cell_buf,
+        };
+    }
+
+    pub fn deinit(self: *Shaper) void {
+        self.hb_buf.destroy();
+    }
+
+    /// Returns an iterator that returns one text run at a time for the
+    /// given terminal row. Note that text runs are are only valid one at a time
+    /// for a Shaper struct since they share state.
+    pub fn runIterator(self: *Shaper, group: *GroupCache, row: terminal.Screen.Row) RunIterator {
+        return .{ .shaper = self, .group = group, .row = row };
+    }
+
+    /// Shape the given text run. The text run must be the immediately previous
+    /// text run that was iterated since the text run does share state with the
+    /// Shaper struct.
+    ///
+    /// The return value is only valid until the next shape call is called.
+    ///
+    /// If there is not enough space in the cell buffer, an error is returned.
+    pub fn shape(self: *Shaper, run: TextRun) ![]Cell {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        // We only do shaping if the font is not a special-case. For special-case
+        // fonts, the codepoint == glyph_index so we don't need to run any shaping.
+        if (run.font_index.special() == null) {
+            // TODO: we do not want to hardcode these
+            const hb_feats = &[_]harfbuzz.Feature{
+                harfbuzz.Feature.fromString("dlig").?,
+                harfbuzz.Feature.fromString("liga").?,
+            };
+
+            const face = try run.group.group.faceFromIndex(run.font_index);
+            harfbuzz.shape(face.hb_font, self.hb_buf, hb_feats);
+        }
+
+        // If our buffer is empty, we short-circuit the rest of the work
+        // return nothing.
+        if (self.hb_buf.getLength() == 0) return self.cell_buf[0..0];
+        const info = self.hb_buf.getGlyphInfos();
+        const pos = self.hb_buf.getGlyphPositions() orelse return error.HarfbuzzFailed;
+
+        // This is perhaps not true somewhere, but we currently assume it is true.
+        // If it isn't true, I'd like to catch it and learn more.
+        assert(info.len == pos.len);
+
+        // Convert all our info/pos to cells and set it.
+        if (info.len > self.cell_buf.len) return error.OutOfMemory;
+        //log.warn("info={} pos={} run={}", .{ info.len, pos.len, run });
+
+        for (info) |v, i| {
+            self.cell_buf[i] = .{
+                .x = @intCast(u16, v.cluster),
+                .glyph_index = v.codepoint,
+            };
+
+            //log.warn("i={} info={} pos={} cell={}", .{ i, v, pos[i], self.cell_buf[i] });
+        }
+
+        return self.cell_buf[0..info.len];
+    }
+
+    pub const Cell = struct {
+        /// The column that this cell occupies. Since a set of shaper cells is
+        /// always on the same line, only the X is stored. It is expected the
+        /// caller has access to the original screen cell.
+        x: u16,
+
+        /// The glyph index for this cell. The font index to use alongside
+        /// this cell is available in the text run.
+        glyph_index: u32,
+    };
+
+    /// A single text run. A text run is only valid for one Shaper and
+    /// until the next run is created.
+    pub const TextRun = struct {
+        /// The offset in the row where this run started
+        offset: u16,
+
+        /// The total number of cells produced by this run.
+        cells: u16,
+
+        /// The font group that built this run.
+        group: *GroupCache,
+
+        /// The font index to use for the glyphs of this run.
+        font_index: Group.FontIndex,
+    };
+
+    pub const RunIterator = struct {
+        shaper: *Shaper,
+        group: *GroupCache,
+        row: terminal.Screen.Row,
+        i: usize = 0,
+
+        pub fn next(self: *RunIterator, alloc: Allocator) !?TextRun {
+            const tracy = trace(@src());
+            defer tracy.end();
+
+            // Trim the right side of a row that might be empty
+            const max: usize = max: {
+                var j: usize = self.row.lenCells();
+                while (j > 0) : (j -= 1) if (!self.row.getCell(j - 1).empty()) break;
+                break :max j;
+            };
+
+            // We're over at the max
+            if (self.i >= max) return null;
+
+            // Track the font for our curent run
+            var current_font: Group.FontIndex = .{};
+
+            // Reset the buffer for our current run
+            self.shaper.hb_buf.reset();
+            self.shaper.hb_buf.setContentType(.unicode);
+
+            // Go through cell by cell and accumulate while we build our run.
+            var j: usize = self.i;
+            while (j < max) : (j += 1) {
+                const cluster = j;
+                const cell = self.row.getCell(j);
+
+                // If we're a spacer, then we ignore it
+                if (cell.attrs.wide_spacer_tail) continue;
+
+                const style: Style = if (cell.attrs.bold)
+                    .bold
+                else
+                    .regular;
+
+                // Determine the presentation format for this glyph.
+                const presentation: ?Presentation = if (cell.attrs.grapheme) p: {
+                    // We only check the FIRST codepoint because I believe the
+                    // presentation format must be directly adjacent to the codepoint.
+                    var it = self.row.codepointIterator(j);
+                    if (it.next()) |cp| {
+                        if (cp == 0xFE0E) break :p Presentation.text;
+                        if (cp == 0xFE0F) break :p Presentation.emoji;
+                    }
+
+                    break :p null;
+                } else null;
+
+                // Determine the font for this cell. We'll use fallbacks
+                // manually here to try replacement chars and then a space
+                // for unknown glyphs.
+                const font_idx_opt = (try self.group.indexForCodepoint(
+                    alloc,
+                    if (cell.empty() or cell.char == 0) ' ' else cell.char,
+                    style,
+                    presentation,
+                )) orelse (try self.group.indexForCodepoint(
+                    alloc,
+                    0xFFFD,
+                    style,
+                    .text,
+                )) orelse
+                    try self.group.indexForCodepoint(alloc, ' ', style, .text);
+                const font_idx = font_idx_opt.?;
+                //log.warn("char={x} idx={}", .{ cell.char, font_idx });
+                if (j == self.i) current_font = font_idx;
+
+                // If our fonts are not equal, then we're done with our run.
+                if (font_idx.int() != current_font.int()) break;
+
+                // Continue with our run
+                self.shaper.hb_buf.add(cell.char, @intCast(u32, cluster));
+
+                // If this cell is part of a grapheme cluster, add all the grapheme
+                // data points.
+                if (cell.attrs.grapheme) {
+                    var it = self.row.codepointIterator(j);
+                    while (it.next()) |cp| {
+                        if (cp == 0xFE0E or cp == 0xFE0F) continue;
+                        self.shaper.hb_buf.add(cp, @intCast(u32, cluster));
+                    }
+                }
+            }
+
+            // Finalize our buffer
+            self.shaper.hb_buf.guessSegmentProperties();
+
+            // Move our cursor. Must defer since we use self.i below.
+            defer self.i = j;
+
+            return TextRun{
+                .offset = @intCast(u16, self.i),
+                .cells = @intCast(u16, j - self.i),
+                .group = self.group,
+                .font_index = current_font,
+            };
+        }
+    };
+};
+
+test "run iterator" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    {
+        // Make a screen with some data
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("ABCD");
+
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |_| count += 1;
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Spaces should be part of a run
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.testWriteString("ABCD   EFG");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |_| count += 1;
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    {
+        // Make a screen with some data
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("AüòÉD");
+
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |_| {
+            count += 1;
+
+            // All runs should be exactly length 1
+            try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+}
+
+test "run iterator: empty cells with background set" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    {
+        // Make a screen with some data
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("A");
+
+        // Get our first row
+        const row = screen.getRow(.{ .active = 0 });
+        row.getCellPtr(1).bg = try terminal.color.Name.cyan.default();
+        row.getCellPtr(1).attrs.has_bg = true;
+        row.getCellPtr(2).fg = try terminal.color.Name.yellow.default();
+        row.getCellPtr(2).attrs.has_fg = true;
+
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+
+            // The run should have length 3 because of the two background
+            // cells.
+            try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 3), cells.len);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+test "shape" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+    buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
+        _ = try shaper.shape(run);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape inconsolata ligs" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString(">=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 1), cells.len);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("===");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 1), cells.len);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+
+test "shape emoji width" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("üëç");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 1), cells.len);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+
+test "shape emoji width long" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x1F9D4, buf[buf_idx..]); // man: beard
+    buf_idx += try std.unicode.utf8Encode(0x1F3FB, buf[buf_idx..]); // light skin tone (Fitz 1-2)
+    buf_idx += try std.unicode.utf8Encode(0x200D, buf[buf_idx..]); // ZWJ
+    buf_idx += try std.unicode.utf8Encode(0x2642, buf[buf_idx..]); // male sign
+    buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // emoji representation
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 4), shaper.hb_buf.getLength());
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 1), cells.len);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape variation selector VS15" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x270C, buf[buf_idx..]); // Victory sign (default text)
+    buf_idx += try std.unicode.utf8Encode(0xFE0E, buf[buf_idx..]); // ZWJ to force text
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 1), cells.len);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape variation selector VS16" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x270C, buf[buf_idx..]); // Victory sign (default text)
+    buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // ZWJ to force color
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 1), cells.len);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape with empty cells in between" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    defer screen.deinit();
+    try screen.testWriteString("A");
+    screen.cursor.x += 5;
+    try screen.testWriteString("B");
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 7), cells.len);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape Chinese characters" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode('n', buf[buf_idx..]); // Combining
+    buf_idx += try std.unicode.utf8Encode(0x0308, buf[buf_idx..]); // Combining
+    buf_idx += try std.unicode.utf8Encode(0x0308, buf[buf_idx..]);
+    buf_idx += try std.unicode.utf8Encode('a', buf[buf_idx..]);
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 4), cells.len);
+        try testing.expectEqual(@as(u16, 0), cells[0].x);
+        try testing.expectEqual(@as(u16, 0), cells[1].x);
+        try testing.expectEqual(@as(u16, 0), cells[2].x);
+        try testing.expectEqual(@as(u16, 1), cells[3].x);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+test "shape box glyphs" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Setup the box font
+    testdata.cache.group.sprite = font.sprite.Face{
+        .width = 18,
+        .height = 36,
+        .thickness = 2,
+    };
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x2500, buf[buf_idx..]); // horiz line
+    buf_idx += try std.unicode.utf8Encode(0x2501, buf[buf_idx..]); //
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = testdata.shaper;
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 2), cells.len);
+        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index);
+        try testing.expectEqual(@as(u16, 0), cells[0].x);
+        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index);
+        try testing.expectEqual(@as(u16, 1), cells[1].x);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
+const TestShaper = struct {
+    alloc: Allocator,
+    shaper: Shaper,
+    cache: *GroupCache,
+    lib: Library,
+    cell_buf: []Shaper.Cell,
+
+    pub fn deinit(self: *TestShaper) void {
+        self.shaper.deinit();
+        self.cache.deinit(self.alloc);
+        self.alloc.destroy(self.cache);
+        self.alloc.free(self.cell_buf);
+        self.lib.deinit();
+    }
+};
+
+/// Helper to return a fully initialized shaper.
+fn testShaper(alloc: Allocator) !TestShaper {
+    const testFont = @import("../test.zig").fontRegular;
+    const testEmoji = @import("../test.zig").fontEmoji;
+    const testEmojiText = @import("../test.zig").fontEmojiText;
+
+    var lib = try Library.init();
+    errdefer lib.deinit();
+
+    var cache_ptr = try alloc.create(GroupCache);
+    errdefer alloc.destroy(cache_ptr);
+    cache_ptr.* = try GroupCache.init(alloc, try Group.init(
+        alloc,
+        lib,
+        .{ .points = 12 },
+    ));
+    errdefer cache_ptr.*.deinit(alloc);
+
+    // Setup group
+    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
+    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
+    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
+
+    var cell_buf = try alloc.alloc(Shaper.Cell, 80);
+    errdefer alloc.free(cell_buf);
+
+    var shaper = try Shaper.init(cell_buf);
+    errdefer shaper.deinit();
+
+    return TestShaper{
+        .alloc = alloc,
+        .shaper = shaper,
+        .cache = cache_ptr,
+        .lib = lib,
+        .cell_buf = cell_buf,
+    };
+}

commit f0b7fbecee2a12b5c72df3c010340e59a06d1305
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 6 13:23:53 2022 -0800

    font: extract common shaper elements out

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index d51e4da4..9953a12b 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -22,11 +22,11 @@ pub const Shaper = struct {
     hb_buf: harfbuzz.Buffer,
 
     /// The shared memory used for shaping results.
-    cell_buf: []Cell,
+    cell_buf: []font.shape.Cell,
 
     /// The cell_buf argument is the buffer to use for storing shaped results.
     /// This should be at least the number of columns in the terminal.
-    pub fn init(cell_buf: []Cell) !Shaper {
+    pub fn init(cell_buf: []font.shape.Cell) !Shaper {
         return Shaper{
             .hb_buf = try harfbuzz.Buffer.create(),
             .cell_buf = cell_buf,
@@ -40,8 +40,12 @@ pub const Shaper = struct {
     /// Returns an iterator that returns one text run at a time for the
     /// given terminal row. Note that text runs are are only valid one at a time
     /// for a Shaper struct since they share state.
-    pub fn runIterator(self: *Shaper, group: *GroupCache, row: terminal.Screen.Row) RunIterator {
-        return .{ .shaper = self, .group = group, .row = row };
+    pub fn runIterator(
+        self: *Shaper,
+        group: *GroupCache,
+        row: terminal.Screen.Row,
+    ) font.shape.RunIterator {
+        return .{ .hooks = .{ .shaper = self }, .group = group, .row = row };
     }
 
     /// Shape the given text run. The text run must be the immediately previous
@@ -51,7 +55,7 @@ pub const Shaper = struct {
     /// The return value is only valid until the next shape call is called.
     ///
     /// If there is not enough space in the cell buffer, an error is returned.
-    pub fn shape(self: *Shaper, run: TextRun) ![]Cell {
+    pub fn shape(self: *Shaper, run: font.shape.TextRun) ![]font.shape.Cell {
         const tracy = trace(@src());
         defer tracy.end();
 
@@ -94,135 +98,22 @@ pub const Shaper = struct {
         return self.cell_buf[0..info.len];
     }
 
-    pub const Cell = struct {
-        /// The column that this cell occupies. Since a set of shaper cells is
-        /// always on the same line, only the X is stored. It is expected the
-        /// caller has access to the original screen cell.
-        x: u16,
-
-        /// The glyph index for this cell. The font index to use alongside
-        /// this cell is available in the text run.
-        glyph_index: u32,
-    };
-
-    /// A single text run. A text run is only valid for one Shaper and
-    /// until the next run is created.
-    pub const TextRun = struct {
-        /// The offset in the row where this run started
-        offset: u16,
-
-        /// The total number of cells produced by this run.
-        cells: u16,
-
-        /// The font group that built this run.
-        group: *GroupCache,
-
-        /// The font index to use for the glyphs of this run.
-        font_index: Group.FontIndex,
-    };
-
-    pub const RunIterator = struct {
+    /// The hooks for RunIterator.
+    pub const RunIteratorHook = struct {
         shaper: *Shaper,
-        group: *GroupCache,
-        row: terminal.Screen.Row,
-        i: usize = 0,
-
-        pub fn next(self: *RunIterator, alloc: Allocator) !?TextRun {
-            const tracy = trace(@src());
-            defer tracy.end();
-
-            // Trim the right side of a row that might be empty
-            const max: usize = max: {
-                var j: usize = self.row.lenCells();
-                while (j > 0) : (j -= 1) if (!self.row.getCell(j - 1).empty()) break;
-                break :max j;
-            };
-
-            // We're over at the max
-            if (self.i >= max) return null;
-
-            // Track the font for our curent run
-            var current_font: Group.FontIndex = .{};
 
+        pub fn prepare(self: RunIteratorHook) !void {
             // Reset the buffer for our current run
             self.shaper.hb_buf.reset();
             self.shaper.hb_buf.setContentType(.unicode);
+        }
 
-            // Go through cell by cell and accumulate while we build our run.
-            var j: usize = self.i;
-            while (j < max) : (j += 1) {
-                const cluster = j;
-                const cell = self.row.getCell(j);
-
-                // If we're a spacer, then we ignore it
-                if (cell.attrs.wide_spacer_tail) continue;
-
-                const style: Style = if (cell.attrs.bold)
-                    .bold
-                else
-                    .regular;
-
-                // Determine the presentation format for this glyph.
-                const presentation: ?Presentation = if (cell.attrs.grapheme) p: {
-                    // We only check the FIRST codepoint because I believe the
-                    // presentation format must be directly adjacent to the codepoint.
-                    var it = self.row.codepointIterator(j);
-                    if (it.next()) |cp| {
-                        if (cp == 0xFE0E) break :p Presentation.text;
-                        if (cp == 0xFE0F) break :p Presentation.emoji;
-                    }
-
-                    break :p null;
-                } else null;
-
-                // Determine the font for this cell. We'll use fallbacks
-                // manually here to try replacement chars and then a space
-                // for unknown glyphs.
-                const font_idx_opt = (try self.group.indexForCodepoint(
-                    alloc,
-                    if (cell.empty() or cell.char == 0) ' ' else cell.char,
-                    style,
-                    presentation,
-                )) orelse (try self.group.indexForCodepoint(
-                    alloc,
-                    0xFFFD,
-                    style,
-                    .text,
-                )) orelse
-                    try self.group.indexForCodepoint(alloc, ' ', style, .text);
-                const font_idx = font_idx_opt.?;
-                //log.warn("char={x} idx={}", .{ cell.char, font_idx });
-                if (j == self.i) current_font = font_idx;
-
-                // If our fonts are not equal, then we're done with our run.
-                if (font_idx.int() != current_font.int()) break;
-
-                // Continue with our run
-                self.shaper.hb_buf.add(cell.char, @intCast(u32, cluster));
-
-                // If this cell is part of a grapheme cluster, add all the grapheme
-                // data points.
-                if (cell.attrs.grapheme) {
-                    var it = self.row.codepointIterator(j);
-                    while (it.next()) |cp| {
-                        if (cp == 0xFE0E or cp == 0xFE0F) continue;
-                        self.shaper.hb_buf.add(cp, @intCast(u32, cluster));
-                    }
-                }
-            }
-
-            // Finalize our buffer
-            self.shaper.hb_buf.guessSegmentProperties();
-
-            // Move our cursor. Must defer since we use self.i below.
-            defer self.i = j;
+        pub fn addCodepoint(self: RunIteratorHook, cp: u32, cluster: u32) !void {
+            self.shaper.hb_buf.add(cp, cluster);
+        }
 
-            return TextRun{
-                .offset = @intCast(u16, self.i),
-                .cells = @intCast(u16, j - self.i),
-                .group = self.group,
-                .font_index = current_font,
-            };
+        pub fn finalize(self: RunIteratorHook) !void {
+            self.shaper.hb_buf.guessSegmentProperties();
         }
     };
 };
@@ -619,7 +510,7 @@ const TestShaper = struct {
     shaper: Shaper,
     cache: *GroupCache,
     lib: Library,
-    cell_buf: []Shaper.Cell,
+    cell_buf: []font.shape.Cell,
 
     pub fn deinit(self: *TestShaper) void {
         self.shaper.deinit();
@@ -653,7 +544,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
     try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
     try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
 
-    var cell_buf = try alloc.alloc(Shaper.Cell, 80);
+    var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);
 
     var shaper = try Shaper.init(cell_buf);

commit dd71456f355f5b59c7d4b025654dd5eb77ba9e7d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 6 13:39:18 2022 -0800

    font: shapers init with allocator since web canvas needs to init buffer

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 9953a12b..6ec6d189 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -26,7 +26,10 @@ pub const Shaper = struct {
 
     /// The cell_buf argument is the buffer to use for storing shaped results.
     /// This should be at least the number of columns in the terminal.
-    pub fn init(cell_buf: []font.shape.Cell) !Shaper {
+    pub fn init(alloc: Allocator, cell_buf: []font.shape.Cell) !Shaper {
+        // Allocator is not used because harfbuzz uses libc
+        _ = alloc;
+
         return Shaper{
             .hb_buf = try harfbuzz.Buffer.create(),
             .cell_buf = cell_buf,
@@ -547,7 +550,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);
 
-    var shaper = try Shaper.init(cell_buf);
+    var shaper = try Shaper.init(alloc, cell_buf);
     errdefer shaper.deinit();
 
     return TestShaper{

commit ce86c64b4299b2524a59eb75c575b85270da70fa
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Feb 27 21:46:42 2023 -0800

    update zig, src for loops

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 6ec6d189..44b56b5b 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -89,7 +89,7 @@ pub const Shaper = struct {
         if (info.len > self.cell_buf.len) return error.OutOfMemory;
         //log.warn("info={} pos={} run={}", .{ info.len, pos.len, run });
 
-        for (info) |v, i| {
+        for (info, 0..) |v, i| {
             self.cell_buf[i] = .{
                 .x = @intCast(u16, v.cluster),
                 .glyph_index = v.codepoint,

commit 2be4eb0da72f78658169fad944fac2ac482e4ea5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 23 10:24:22 2023 -0700

    font/shaper: split runs at selection boundaries

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 44b56b5b..5a090b5d 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -43,12 +43,22 @@ pub const Shaper = struct {
     /// Returns an iterator that returns one text run at a time for the
     /// given terminal row. Note that text runs are are only valid one at a time
     /// for a Shaper struct since they share state.
+    ///
+    /// The selection must be a row-only selection (height = 1). See
+    /// Selection.containedRow. The run iterator will ONLY look at X values
+    /// and assume the y value matches.
     pub fn runIterator(
         self: *Shaper,
         group: *GroupCache,
         row: terminal.Screen.Row,
+        selection: ?terminal.Selection,
     ) font.shape.RunIterator {
-        return .{ .hooks = .{ .shaper = self }, .group = group, .row = row };
+        return .{
+            .hooks = .{ .shaper = self },
+            .group = group,
+            .row = row,
+            .selection = selection,
+        };
     }
 
     /// Shape the given text run. The text run must be the immediately previous
@@ -136,7 +146,7 @@ test "run iterator" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -149,7 +159,7 @@ test "run iterator" {
         try screen.testWriteString("ABCD   EFG");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -163,7 +173,7 @@ test "run iterator" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| {
             count += 1;
@@ -197,7 +207,7 @@ test "run iterator: empty cells with background set" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -211,6 +221,7 @@ test "run iterator: empty cells with background set" {
         try testing.expectEqual(@as(usize, 1), count);
     }
 }
+
 test "shape" {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -231,7 +242,7 @@ test "shape" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -254,7 +265,7 @@ test "shape inconsolata ligs" {
         try screen.testWriteString(">=");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -271,7 +282,7 @@ test "shape inconsolata ligs" {
         try screen.testWriteString("===");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -296,7 +307,7 @@ test "shape emoji width" {
         try screen.testWriteString("üëç");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -330,7 +341,7 @@ test "shape emoji width long" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -361,7 +372,7 @@ test "shape variation selector VS15" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -392,7 +403,7 @@ test "shape variation selector VS16" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -420,7 +431,7 @@ test "shape with empty cells in between" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -452,7 +463,7 @@ test "shape Chinese characters" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -493,7 +504,7 @@ test "shape box glyphs" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }));
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -508,6 +519,99 @@ test "shape box glyphs" {
     try testing.expectEqual(@as(usize, 1), count);
 }
 
+test "shape selection boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString("a1b2c3d4e5");
+
+    // Full line selection
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+            .start = .{ .x = 0, .y = 0 },
+            .end = .{ .x = screen.cols - 1, .y = 0 },
+        });
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Offset x, goes to end of line selection
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+            .start = .{ .x = 2, .y = 0 },
+            .end = .{ .x = screen.cols - 1, .y = 0 },
+        });
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Offset x, starts at beginning of line
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+            .start = .{ .x = 0, .y = 0 },
+            .end = .{ .x = 3, .y = 0 },
+        });
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Selection only subset of line
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+            .start = .{ .x = 1, .y = 0 },
+            .end = .{ .x = 3, .y = 0 },
+        });
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+
+    // Selection only one character
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+            .start = .{ .x = 1, .y = 0 },
+            .end = .{ .x = 1, .y = 0 },
+        });
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+}
+
 const TestShaper = struct {
     alloc: Allocator,
     shaper: Shaper,

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 5a090b5d..335ef6ad 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -101,7 +101,7 @@ pub const Shaper = struct {
 
         for (info, 0..) |v, i| {
             self.cell_buf[i] = .{
-                .x = @intCast(u16, v.cluster),
+                .x = @intCast(v.cluster),
                 .glyph_index = v.codepoint,
             };
 

commit 1d1b86895826953768d047438cfb68344ddf4289
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 13:51:31 2023 -0700

    font: do not use Noto on macOS for tests, it doesn't work

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 335ef6ad..8c16344d 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -648,8 +648,11 @@ fn testShaper(alloc: Allocator) !TestShaper {
 
     // Setup group
     try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
-    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
     try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
+    if (font.options.backend != .coretext) {
+        // Coretext doesn't support Noto's format
+        try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
+    }
 
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);

commit 9968128da9e50e5cd6a27e4bc306f90b09280f31
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 15:15:53 2023 -0700

    fix failing test on non-Mac

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 8c16344d..1f4cbc81 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -648,11 +648,11 @@ fn testShaper(alloc: Allocator) !TestShaper {
 
     // Setup group
     try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
-    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
         try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
     }
+    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
 
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);

commit 45ac9b5d4c59b4af1659cbb8de482ebadd6e50fe
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Jul 5 13:05:51 2023 -0700

    font-feature config to enable/disable OpenType Font Features

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 1f4cbc81..e10b86ed 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -24,20 +24,49 @@ pub const Shaper = struct {
     /// The shared memory used for shaping results.
     cell_buf: []font.shape.Cell,
 
+    /// The features to use for shaping.
+    hb_feats: FeatureList,
+
+    const FeatureList = std.ArrayList(harfbuzz.Feature);
+
     /// The cell_buf argument is the buffer to use for storing shaped results.
     /// This should be at least the number of columns in the terminal.
-    pub fn init(alloc: Allocator, cell_buf: []font.shape.Cell) !Shaper {
-        // Allocator is not used because harfbuzz uses libc
-        _ = alloc;
+    pub fn init(alloc: Allocator, opts: font.shape.Options) !Shaper {
+        // Parse all the features we want to use. We use
+        var hb_feats = hb_feats: {
+            // These features are hardcoded to always be on by default. Users
+            // can turn them off by setting the features to "-liga" for example.
+            const hardcoded_features = [_][]const u8{ "dlig", "liga" };
+
+            var list = try FeatureList.initCapacity(alloc, opts.features.len + hardcoded_features.len);
+            errdefer list.deinit();
+
+            for (hardcoded_features) |name| {
+                if (harfbuzz.Feature.fromString(name)) |feat| {
+                    try list.append(feat);
+                } else log.warn("failed to parse font feature: {s}", .{name});
+            }
+
+            for (opts.features) |name| {
+                if (harfbuzz.Feature.fromString(name)) |feat| {
+                    try list.append(feat);
+                } else log.warn("failed to parse font feature: {s}", .{name});
+            }
+
+            break :hb_feats list;
+        };
+        errdefer hb_feats.deinit();
 
         return Shaper{
             .hb_buf = try harfbuzz.Buffer.create(),
-            .cell_buf = cell_buf,
+            .cell_buf = opts.cell_buf,
+            .hb_feats = hb_feats,
         };
     }
 
     pub fn deinit(self: *Shaper) void {
         self.hb_buf.destroy();
+        self.hb_feats.deinit();
     }
 
     /// Returns an iterator that returns one text run at a time for the
@@ -75,14 +104,8 @@ pub const Shaper = struct {
         // We only do shaping if the font is not a special-case. For special-case
         // fonts, the codepoint == glyph_index so we don't need to run any shaping.
         if (run.font_index.special() == null) {
-            // TODO: we do not want to hardcode these
-            const hb_feats = &[_]harfbuzz.Feature{
-                harfbuzz.Feature.fromString("dlig").?,
-                harfbuzz.Feature.fromString("liga").?,
-            };
-
             const face = try run.group.group.faceFromIndex(run.font_index);
-            harfbuzz.shape(face.hb_font, self.hb_buf, hb_feats);
+            harfbuzz.shape(face.hb_font, self.hb_buf, self.hb_feats.items);
         }
 
         // If our buffer is empty, we short-circuit the rest of the work
@@ -657,7 +680,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);
 
-    var shaper = try Shaper.init(alloc, cell_buf);
+    var shaper = try Shaper.init(alloc, .{ .cell_buf = cell_buf });
     errdefer shaper.deinit();
 
     return TestShaper{

commit 4b062dc45c57c75fd7082b64487308b333283df2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jul 18 16:17:46 2023 -0700

    font/shaper: text runs should split around block cursors
    
    Fixes #206

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index e10b86ed..ad9b0839 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -81,12 +81,14 @@ pub const Shaper = struct {
         group: *GroupCache,
         row: terminal.Screen.Row,
         selection: ?terminal.Selection,
+        cursor_x: ?usize,
     ) font.shape.RunIterator {
         return .{
             .hooks = .{ .shaper = self },
             .group = group,
             .row = row,
             .selection = selection,
+            .cursor_x = cursor_x,
         };
     }
 
@@ -169,7 +171,7 @@ test "run iterator" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -182,7 +184,7 @@ test "run iterator" {
         try screen.testWriteString("ABCD   EFG");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -196,7 +198,7 @@ test "run iterator" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| {
             count += 1;
@@ -230,7 +232,7 @@ test "run iterator: empty cells with background set" {
 
         // Get our run iterator
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -265,7 +267,7 @@ test "shape" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -288,7 +290,7 @@ test "shape inconsolata ligs" {
         try screen.testWriteString(">=");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -305,7 +307,7 @@ test "shape inconsolata ligs" {
         try screen.testWriteString("===");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -330,7 +332,7 @@ test "shape emoji width" {
         try screen.testWriteString("üëç");
 
         var shaper = testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -364,7 +366,7 @@ test "shape emoji width long" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -395,7 +397,7 @@ test "shape variation selector VS15" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -426,7 +428,7 @@ test "shape variation selector VS16" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -454,7 +456,7 @@ test "shape with empty cells in between" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -486,7 +488,7 @@ test "shape Chinese characters" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -527,7 +529,7 @@ test "shape box glyphs" {
 
     // Get our run iterator
     var shaper = testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null);
+    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -561,7 +563,7 @@ test "shape selection boundary" {
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 0, .y = 0 },
             .end = .{ .x = screen.cols - 1, .y = 0 },
-        });
+        }, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -577,7 +579,7 @@ test "shape selection boundary" {
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 2, .y = 0 },
             .end = .{ .x = screen.cols - 1, .y = 0 },
-        });
+        }, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -593,7 +595,7 @@ test "shape selection boundary" {
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 0, .y = 0 },
             .end = .{ .x = 3, .y = 0 },
-        });
+        }, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -609,7 +611,7 @@ test "shape selection boundary" {
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 1, .y = 0 },
             .end = .{ .x = 3, .y = 0 },
-        });
+        }, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -625,7 +627,7 @@ test "shape selection boundary" {
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 1, .y = 0 },
             .end = .{ .x = 1, .y = 0 },
-        });
+        }, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -635,6 +637,71 @@ test "shape selection boundary" {
     }
 }
 
+test "shape cursor boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString("a1b2c3d4e5");
+
+    // No cursor is full line
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Cursor at index 0 is two runs
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Cursor at index 1 is three runs
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+
+    // Cursor at last col is two runs
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 9);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+}
+
 const TestShaper = struct {
     alloc: Allocator,
     shaper: Shaper,

commit 4137c6cf69ef62ccddbd2467f36c9bc77c474e47
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jul 18 16:38:02 2023 -0700

    font/shaper: do not break on merged emoji if cursor is directly on it

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index ad9b0839..e6c6127c 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -702,6 +702,56 @@ test "shape cursor boundary" {
     }
 }
 
+test "shape cursor boundary and colored emoji" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString("üëçüèº");
+
+    // No cursor is full line
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Cursor on emoji does not split it
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+    {
+        // Get our run iterator
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+
 const TestShaper = struct {
     alloc: Allocator,
     shaper: Shaper,

commit ea3b957bc7166909fb270f1c9c663f304e36bdbf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 09:29:15 2023 -0700

    quirks: Menlo/Monaco should disable ligatures by default (#331)
    
    * font: disable default font features for Menlo and Monaco
    
    Both of these fonts have a default ligature on "fi" which makes terminal
    rendering super ugly. The easiest thing to do is special-case these
    fonts and disable ligatures. It appears other terminals do the same
    thing.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index e6c6127c..2e3d20ca 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -12,6 +12,7 @@ const Library = font.Library;
 const Style = font.Style;
 const Presentation = font.Presentation;
 const terminal = @import("../../terminal/main.zig");
+const quirks = @import("../../quirks.zig");
 
 const log = std.log.scoped(.font_shaper);
 
@@ -29,15 +30,15 @@ pub const Shaper = struct {
 
     const FeatureList = std.ArrayList(harfbuzz.Feature);
 
+    // These features are hardcoded to always be on by default. Users
+    // can turn them off by setting the features to "-liga" for example.
+    const hardcoded_features = [_][]const u8{ "dlig", "liga" };
+
     /// The cell_buf argument is the buffer to use for storing shaped results.
     /// This should be at least the number of columns in the terminal.
     pub fn init(alloc: Allocator, opts: font.shape.Options) !Shaper {
         // Parse all the features we want to use. We use
         var hb_feats = hb_feats: {
-            // These features are hardcoded to always be on by default. Users
-            // can turn them off by setting the features to "-liga" for example.
-            const hardcoded_features = [_][]const u8{ "dlig", "liga" };
-
             var list = try FeatureList.initCapacity(alloc, opts.features.len + hardcoded_features.len);
             errdefer list.deinit();
 
@@ -107,7 +108,14 @@ pub const Shaper = struct {
         // fonts, the codepoint == glyph_index so we don't need to run any shaping.
         if (run.font_index.special() == null) {
             const face = try run.group.group.faceFromIndex(run.font_index);
-            harfbuzz.shape(face.hb_font, self.hb_buf, self.hb_feats.items);
+            const i = if (!quirks.disableDefaultFontFeatures(face)) 0 else i: {
+                // If we are disabling default font features we just offset
+                // our features by the hardcoded items because always
+                // add those at the beginning.
+                break :i hardcoded_features.len;
+            };
+
+            harfbuzz.shape(face.hb_font, self.hb_buf, self.hb_feats.items[i..]);
         }
 
         // If our buffer is empty, we short-circuit the rest of the work

commit ad6c2b6cc8eaefad06fb5edfce741de8bf110fe0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 13:16:42 2023 -0700

    font: move auto-italicization to Group

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 2e3d20ca..590cbbe0 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -795,12 +795,12 @@ fn testShaper(alloc: Allocator) !TestShaper {
     errdefer cache_ptr.*.deinit(alloc);
 
     // Setup group
-    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
+    try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
-        try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
+        try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
     }
-    try cache_ptr.group.addFace(alloc, .regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
+    try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
 
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);

commit 167bf6f0980c312fdff0d4eedb6ad3ecdfa39d26
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 13:28:46 2023 -0700

    font: DeferredFace can no longer represent a loaded face

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 590cbbe0..fe41ae51 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -795,12 +795,13 @@ fn testShaper(alloc: Allocator) !TestShaper {
     errdefer cache_ptr.*.deinit(alloc);
 
     // Setup group
-    try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testFont, .{ .points = 12 })));
+    try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testFont, .{ .points = 12 }) });
+
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
-        try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testEmoji, .{ .points = 12 })));
+        try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmoji, .{ .points = 12 }) });
     }
-    try cache_ptr.group.addFace(.regular, DeferredFace.initLoaded(try Face.init(lib, testEmojiText, .{ .points = 12 })));
+    try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
 
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);

commit f4738210e14e2f0c758376b06a4b3107f5594ba1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 14:44:16 2023 -0700

    font: determine quirks modes on font face load

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index fe41ae51..688aed67 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -12,7 +12,6 @@ const Library = font.Library;
 const Style = font.Style;
 const Presentation = font.Presentation;
 const terminal = @import("../../terminal/main.zig");
-const quirks = @import("../../quirks.zig");
 
 const log = std.log.scoped(.font_shaper);
 
@@ -108,7 +107,7 @@ pub const Shaper = struct {
         // fonts, the codepoint == glyph_index so we don't need to run any shaping.
         if (run.font_index.special() == null) {
             const face = try run.group.group.faceFromIndex(run.font_index);
-            const i = if (!quirks.disableDefaultFontFeatures(face)) 0 else i: {
+            const i = if (!face.quirks_disable_default_font_features) 0 else i: {
                 // If we are disabling default font features we just offset
                 // our features by the hardcoded items because always
                 // add those at the beginning.

commit e6edf3105e43ccf41f345eee263f49f7faca18f3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 26 09:20:26 2023 -0700

    font: grapheme clusters need to find a single font for all codepoints
    
    When font shaping grapheme clusters, we erroneously used the font index
    of a font that only matches the first codepoint in the cell. This led to the
    combining characters being [usually] unknown and rendering as boxes.
    
    For a grapheme, we must find a font face that has a glyph for _all codepoints_
    in the grapheme.
    
    This also fixes an issue where we now properly render the unicode replacement
    character if we can't find a font satisfying a codepoint.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 688aed67..e7afb3d0 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -137,7 +137,7 @@ pub const Shaper = struct {
                 .glyph_index = v.codepoint,
             };
 
-            //log.warn("i={} info={} pos={} cell={}", .{ i, v, pos[i], self.cell_buf[i] });
+            // log.warn("i={} info={} pos={} cell={}", .{ i, v, pos[i], self.cell_buf[i] });
         }
 
         return self.cell_buf[0..info.len];
@@ -154,6 +154,7 @@ pub const Shaper = struct {
         }
 
         pub fn addCodepoint(self: RunIteratorHook, cp: u32, cluster: u32) !void {
+            // log.warn("cluster={} cp={x}", .{ cluster, cp });
             self.shaper.hb_buf.add(cp, cluster);
         }
 

commit f733e58dc4be66b44fd2037f88299c488e965bd5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 26 17:14:22 2023 -0700

    font/shaper: on macos load apple color emoji for tests

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index e7afb3d0..ce15851c 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -800,6 +800,18 @@ fn testShaper(alloc: Allocator) !TestShaper {
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
         try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmoji, .{ .points = 12 }) });
+    } else {
+        // On CoreText we want to load Apple Emoji, we should have it.
+        var disco = font.Discover.init();
+        defer disco.deinit();
+        var disco_it = try disco.discover(.{
+            .family = "Apple Color Emoji",
+            .size = 12,
+        });
+        defer disco_it.deinit();
+        var face = (try disco_it.next()).?;
+        errdefer face.deinit();
+        try cache_ptr.group.addFace(.regular, .{ .deferred = face });
     }
     try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
 

commit ed5c0016901d80706d0f41052f750dc3bbfb4638
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 29 14:09:21 2023 -0700

    font/shaper: split ligature around cell style change

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index ce15851c..4069a526 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -229,14 +229,14 @@ test "run iterator: empty cells with background set" {
         // Make a screen with some data
         var screen = try terminal.Screen.init(alloc, 3, 5, 0);
         defer screen.deinit();
+        screen.cursor.pen.bg = try terminal.color.Name.cyan.default();
+        screen.cursor.pen.attrs.has_bg = true;
         try screen.testWriteString("A");
 
         // Get our first row
         const row = screen.getRow(.{ .active = 0 });
-        row.getCellPtr(1).bg = try terminal.color.Name.cyan.default();
-        row.getCellPtr(1).attrs.has_bg = true;
-        row.getCellPtr(2).fg = try terminal.color.Name.yellow.default();
-        row.getCellPtr(2).attrs.has_fg = true;
+        row.getCellPtr(1).* = screen.cursor.pen;
+        row.getCellPtr(2).* = screen.cursor.pen;
 
         // Get our run iterator
         var shaper = testdata.shaper;
@@ -760,6 +760,107 @@ test "shape cursor boundary and colored emoji" {
     }
 }
 
+test "shape cell attribute change" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Plain >= should shape into 1 run
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.testWriteString(">=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Bold vs regular should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.testWriteString(">");
+        screen.cursor.pen.attrs.bold = true;
+        try screen.testWriteString("=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Changing fg color should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        screen.cursor.pen.attrs.has_fg = true;
+        screen.cursor.pen.fg = .{ .r = 1, .g = 2, .b = 3 };
+        try screen.testWriteString(">");
+        screen.cursor.pen.fg = .{ .r = 3, .g = 2, .b = 1 };
+        try screen.testWriteString("=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Changing bg color should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        screen.cursor.pen.attrs.has_bg = true;
+        screen.cursor.pen.bg = .{ .r = 1, .g = 2, .b = 3 };
+        try screen.testWriteString(">");
+        screen.cursor.pen.bg = .{ .r = 3, .g = 2, .b = 1 };
+        try screen.testWriteString("=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Same bg color should not split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        screen.cursor.pen.attrs.has_bg = true;
+        screen.cursor.pen.bg = .{ .r = 1, .g = 2, .b = 3 };
+        try screen.testWriteString(">");
+        try screen.testWriteString("=");
+
+        var shaper = testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+
 const TestShaper = struct {
     alloc: Allocator,
     shaper: Shaper,

commit a2236d1ceb6c3f6d4fbe8d0247b955321449300f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 13 14:23:07 2023 -0700

    font: fallback search must verify presentation

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 4069a526..547829a3 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -896,11 +896,11 @@ fn testShaper(alloc: Allocator) !TestShaper {
     errdefer cache_ptr.*.deinit(alloc);
 
     // Setup group
-    try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testFont, .{ .points = 12 }) });
+    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testFont, .{ .points = 12 }) });
 
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
-        try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmoji, .{ .points = 12 }) });
+        _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmoji, .{ .points = 12 }) });
     } else {
         // On CoreText we want to load Apple Emoji, we should have it.
         var disco = font.Discover.init();
@@ -912,9 +912,9 @@ fn testShaper(alloc: Allocator) !TestShaper {
         defer disco_it.deinit();
         var face = (try disco_it.next()).?;
         errdefer face.deinit();
-        try cache_ptr.group.addFace(.regular, .{ .deferred = face });
+        _ = try cache_ptr.group.addFace(.regular, .{ .deferred = face });
     }
-    try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
+    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
 
     var cell_buf = try alloc.alloc(font.shape.Cell, 80);
     errdefer alloc.free(cell_buf);

commit 49dbd8d1511a4382350382f7696ae12c8f61df7b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 24 11:10:04 2023 -0700

    font/shaper: fix failing test on macos

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 547829a3..cceb7d8a 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -908,6 +908,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
         var disco_it = try disco.discover(.{
             .family = "Apple Color Emoji",
             .size = 12,
+            .monospace = false,
         });
         defer disco_it.deinit();
         var face = (try disco_it.next()).?;

commit 5c1fbd09cd771be68945a2a6fd2686e2963945d4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Sep 26 17:57:50 2023 -0700

    font: shaper dynamically allocates cell buffer
    
    Pathlogical grapheme clusters can use a LOT of memory, so we need to be
    able to grow.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index cceb7d8a..0b5293d7 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -17,17 +17,21 @@ const log = std.log.scoped(.font_shaper);
 
 /// Shaper that uses Harfbuzz.
 pub const Shaper = struct {
+    /// The allocated used for the feature list and cell buf.
+    alloc: Allocator,
+
     /// The buffer used for text shaping. We reuse it across multiple shaping
     /// calls to prevent allocations.
     hb_buf: harfbuzz.Buffer,
 
     /// The shared memory used for shaping results.
-    cell_buf: []font.shape.Cell,
+    cell_buf: CellBuf,
 
     /// The features to use for shaping.
     hb_feats: FeatureList,
 
-    const FeatureList = std.ArrayList(harfbuzz.Feature);
+    const CellBuf = std.ArrayListUnmanaged(font.shape.Cell);
+    const FeatureList = std.ArrayListUnmanaged(harfbuzz.Feature);
 
     // These features are hardcoded to always be on by default. Users
     // can turn them off by setting the features to "-liga" for example.
@@ -39,34 +43,36 @@ pub const Shaper = struct {
         // Parse all the features we want to use. We use
         var hb_feats = hb_feats: {
             var list = try FeatureList.initCapacity(alloc, opts.features.len + hardcoded_features.len);
-            errdefer list.deinit();
+            errdefer list.deinit(alloc);
 
             for (hardcoded_features) |name| {
                 if (harfbuzz.Feature.fromString(name)) |feat| {
-                    try list.append(feat);
+                    try list.append(alloc, feat);
                 } else log.warn("failed to parse font feature: {s}", .{name});
             }
 
             for (opts.features) |name| {
                 if (harfbuzz.Feature.fromString(name)) |feat| {
-                    try list.append(feat);
+                    try list.append(alloc, feat);
                 } else log.warn("failed to parse font feature: {s}", .{name});
             }
 
             break :hb_feats list;
         };
-        errdefer hb_feats.deinit();
+        errdefer hb_feats.deinit(alloc);
 
         return Shaper{
+            .alloc = alloc,
             .hb_buf = try harfbuzz.Buffer.create(),
-            .cell_buf = opts.cell_buf,
+            .cell_buf = .{},
             .hb_feats = hb_feats,
         };
     }
 
     pub fn deinit(self: *Shaper) void {
         self.hb_buf.destroy();
-        self.hb_feats.deinit();
+        self.cell_buf.deinit(self.alloc);
+        self.hb_feats.deinit(self.alloc);
     }
 
     /// Returns an iterator that returns one text run at a time for the
@@ -99,7 +105,7 @@ pub const Shaper = struct {
     /// The return value is only valid until the next shape call is called.
     ///
     /// If there is not enough space in the cell buffer, an error is returned.
-    pub fn shape(self: *Shaper, run: font.shape.TextRun) ![]font.shape.Cell {
+    pub fn shape(self: *Shaper, run: font.shape.TextRun) ![]const font.shape.Cell {
         const tracy = trace(@src());
         defer tracy.end();
 
@@ -119,7 +125,7 @@ pub const Shaper = struct {
 
         // If our buffer is empty, we short-circuit the rest of the work
         // return nothing.
-        if (self.hb_buf.getLength() == 0) return self.cell_buf[0..0];
+        if (self.hb_buf.getLength() == 0) return self.cell_buf.items[0..0];
         const info = self.hb_buf.getGlyphInfos();
         const pos = self.hb_buf.getGlyphPositions() orelse return error.HarfbuzzFailed;
 
@@ -128,19 +134,18 @@ pub const Shaper = struct {
         assert(info.len == pos.len);
 
         // Convert all our info/pos to cells and set it.
-        if (info.len > self.cell_buf.len) return error.OutOfMemory;
-        //log.warn("info={} pos={} run={}", .{ info.len, pos.len, run });
-
-        for (info, 0..) |v, i| {
-            self.cell_buf[i] = .{
+        self.cell_buf.clearRetainingCapacity();
+        try self.cell_buf.ensureTotalCapacity(self.alloc, info.len);
+        for (info) |v| {
+            self.cell_buf.appendAssumeCapacity(.{
                 .x = @intCast(v.cluster),
                 .glyph_index = v.codepoint,
-            };
+            });
 
             // log.warn("i={} info={} pos={} cell={}", .{ i, v, pos[i], self.cell_buf[i] });
         }
 
-        return self.cell_buf[0..info.len];
+        return self.cell_buf.items;
     }
 
     /// The hooks for RunIterator.
@@ -178,7 +183,7 @@ test "run iterator" {
         try screen.testWriteString("ABCD");
 
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
@@ -191,7 +196,7 @@ test "run iterator" {
         defer screen.deinit();
         try screen.testWriteString("ABCD   EFG");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
@@ -205,7 +210,7 @@ test "run iterator" {
         try screen.testWriteString("AüòÉD");
 
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |_| {
@@ -239,7 +244,7 @@ test "run iterator: empty cells with background set" {
         row.getCellPtr(2).* = screen.cursor.pen;
 
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -274,7 +279,7 @@ test "shape" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -297,7 +302,7 @@ test "shape inconsolata ligs" {
         defer screen.deinit();
         try screen.testWriteString(">=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -314,7 +319,7 @@ test "shape inconsolata ligs" {
         defer screen.deinit();
         try screen.testWriteString("===");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -339,7 +344,7 @@ test "shape emoji width" {
         defer screen.deinit();
         try screen.testWriteString("üëç");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -373,7 +378,7 @@ test "shape emoji width long" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -404,7 +409,7 @@ test "shape variation selector VS15" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -435,7 +440,7 @@ test "shape variation selector VS16" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -463,7 +468,7 @@ test "shape with empty cells in between" {
     try screen.testWriteString("B");
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -495,7 +500,7 @@ test "shape Chinese characters" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -536,7 +541,7 @@ test "shape box glyphs" {
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
-    var shaper = testdata.shaper;
+    var shaper = &testdata.shaper;
     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
@@ -567,7 +572,7 @@ test "shape selection boundary" {
     // Full line selection
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 0, .y = 0 },
             .end = .{ .x = screen.cols - 1, .y = 0 },
@@ -583,7 +588,7 @@ test "shape selection boundary" {
     // Offset x, goes to end of line selection
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 2, .y = 0 },
             .end = .{ .x = screen.cols - 1, .y = 0 },
@@ -599,7 +604,7 @@ test "shape selection boundary" {
     // Offset x, starts at beginning of line
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 0, .y = 0 },
             .end = .{ .x = 3, .y = 0 },
@@ -615,7 +620,7 @@ test "shape selection boundary" {
     // Selection only subset of line
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 1, .y = 0 },
             .end = .{ .x = 3, .y = 0 },
@@ -631,7 +636,7 @@ test "shape selection boundary" {
     // Selection only one character
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
             .start = .{ .x = 1, .y = 0 },
             .end = .{ .x = 1, .y = 0 },
@@ -660,7 +665,7 @@ test "shape cursor boundary" {
     // No cursor is full line
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -673,7 +678,7 @@ test "shape cursor boundary" {
     // Cursor at index 0 is two runs
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -686,7 +691,7 @@ test "shape cursor boundary" {
     // Cursor at index 1 is three runs
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -699,7 +704,7 @@ test "shape cursor boundary" {
     // Cursor at last col is two runs
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 9);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -725,7 +730,7 @@ test "shape cursor boundary and colored emoji" {
     // No cursor is full line
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -738,7 +743,7 @@ test "shape cursor boundary and colored emoji" {
     // Cursor on emoji does not split it
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -749,7 +754,7 @@ test "shape cursor boundary and colored emoji" {
     }
     {
         // Get our run iterator
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -773,7 +778,7 @@ test "shape cell attribute change" {
         defer screen.deinit();
         try screen.testWriteString(">=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -791,7 +796,7 @@ test "shape cell attribute change" {
         screen.cursor.pen.attrs.bold = true;
         try screen.testWriteString("=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -811,7 +816,7 @@ test "shape cell attribute change" {
         screen.cursor.pen.fg = .{ .r = 3, .g = 2, .b = 1 };
         try screen.testWriteString("=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -831,7 +836,7 @@ test "shape cell attribute change" {
         screen.cursor.pen.bg = .{ .r = 3, .g = 2, .b = 1 };
         try screen.testWriteString("=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -850,7 +855,7 @@ test "shape cell attribute change" {
         try screen.testWriteString(">");
         try screen.testWriteString("=");
 
-        var shaper = testdata.shaper;
+        var shaper = &testdata.shaper;
         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
@@ -866,13 +871,11 @@ const TestShaper = struct {
     shaper: Shaper,
     cache: *GroupCache,
     lib: Library,
-    cell_buf: []font.shape.Cell,
 
     pub fn deinit(self: *TestShaper) void {
         self.shaper.deinit();
         self.cache.deinit(self.alloc);
         self.alloc.destroy(self.cache);
-        self.alloc.free(self.cell_buf);
         self.lib.deinit();
     }
 };
@@ -917,10 +920,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
     }
     _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
 
-    var cell_buf = try alloc.alloc(font.shape.Cell, 80);
-    errdefer alloc.free(cell_buf);
-
-    var shaper = try Shaper.init(alloc, .{ .cell_buf = cell_buf });
+    var shaper = try Shaper.init(alloc, .{});
     errdefer shaper.deinit();
 
     return TestShaper{
@@ -928,6 +928,5 @@ fn testShaper(alloc: Allocator) !TestShaper {
         .shaper = shaper,
         .cache = cache_ptr,
         .lib = lib,
-        .cell_buf = cell_buf,
     };
 }

commit 1127330b3a10dfa3da82dff9358501b7d8ed8c11
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 3 09:17:41 2023 -0700

    font/coretext: score discovered fonts

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 0b5293d7..6c7c9132 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -908,7 +908,7 @@ fn testShaper(alloc: Allocator) !TestShaper {
         // On CoreText we want to load Apple Emoji, we should have it.
         var disco = font.Discover.init();
         defer disco.deinit();
-        var disco_it = try disco.discover(.{
+        var disco_it = try disco.discover(alloc, .{
             .family = "Apple Color Emoji",
             .size = 12,
             .monospace = false,

commit 54b9b45a7fa61a47c6ae1480a95adb7d4755efc8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 17:23:57 2023 -0700

    font: rework font init to use a struct with modifiersets everywhere

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 6c7c9132..781d5a70 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -899,11 +899,19 @@ fn testShaper(alloc: Allocator) !TestShaper {
     errdefer cache_ptr.*.deinit(alloc);
 
     // Setup group
-    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testFont, .{ .points = 12 }) });
+    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12 } },
+    ) });
 
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
-        _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmoji, .{ .points = 12 }) });
+        _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+            lib,
+            testEmoji,
+            .{ .size = .{ .points = 12 } },
+        ) });
     } else {
         // On CoreText we want to load Apple Emoji, we should have it.
         var disco = font.Discover.init();
@@ -918,7 +926,11 @@ fn testShaper(alloc: Allocator) !TestShaper {
         errdefer face.deinit();
         _ = try cache_ptr.group.addFace(.regular, .{ .deferred = face });
     }
-    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(lib, testEmojiText, .{ .points = 12 }) });
+    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+        lib,
+        testEmojiText,
+        .{ .size = .{ .points = 12 } },
+    ) });
 
     var shaper = try Shaper.init(alloc, .{});
     errdefer shaper.deinit();

commit 489ed57e2f924e6993158427ad9317f21eede9eb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 11 21:41:13 2023 -0800

    font/harfbuzz: track x/y offsets

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 781d5a70..4a361327 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -133,17 +133,43 @@ pub const Shaper = struct {
         // If it isn't true, I'd like to catch it and learn more.
         assert(info.len == pos.len);
 
+        // This keeps track of the current offsets within a single cell.
+        var cell_offset: struct {
+            cluster: u32 = 0,
+            x: i32 = 0,
+            y: i32 = 0,
+        } = .{};
+
         // Convert all our info/pos to cells and set it.
         self.cell_buf.clearRetainingCapacity();
         try self.cell_buf.ensureTotalCapacity(self.alloc, info.len);
-        for (info) |v| {
+        for (info, pos) |info_v, pos_v| {
+            if (info_v.cluster != cell_offset.cluster) cell_offset = .{
+                .cluster = info_v.cluster,
+            };
+
             self.cell_buf.appendAssumeCapacity(.{
-                .x = @intCast(v.cluster),
-                .glyph_index = v.codepoint,
+                .x = @intCast(info_v.cluster),
+                .x_offset = @intCast(cell_offset.x),
+                .y_offset = @intCast(cell_offset.y),
+                .glyph_index = info_v.codepoint,
             });
 
-            // log.warn("i={} info={} pos={} cell={}", .{ i, v, pos[i], self.cell_buf[i] });
+            if (font.options.backend.hasFreetype()) {
+                // Freetype returns 26.6 fixed point values, so we need to
+                // divide by 64 to get the actual value. I can't find any
+                // HB API to stop this.
+                cell_offset.x += pos_v.x_advance >> 6;
+                cell_offset.y += pos_v.y_advance >> 6;
+            } else {
+                cell_offset.x += pos_v.x_advance;
+                cell_offset.y += pos_v.y_advance;
+            }
+
+            // const i = self.cell_buf.items.len - 1;
+            // log.warn("i={} info={} pos={} cell={}", .{ i, info_v, pos_v, self.cell_buf.items[i] });
         }
+        //log.warn("----------------", .{});
 
         return self.cell_buf.items;
     }

commit 060bdff117224ea467f2ade55f90dbc96a1b942f
Author: Gregory Anders <greg@gpanders.com>
Date:   Tue Jan 2 17:01:00 2024 -0600

    terminal: track palette color in cell state
    
    Rather than immediately converting a color palette index into an RGB
    value for a cell color, when a palette color is used track the palette
    color directly in the cell state and convert to an RGB value in the
    renderer.
    
    This causes palette color changes to take effect immediately instead of
    only for newly drawn cells.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 4a361327..cc36bcec 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -260,8 +260,7 @@ test "run iterator: empty cells with background set" {
         // Make a screen with some data
         var screen = try terminal.Screen.init(alloc, 3, 5, 0);
         defer screen.deinit();
-        screen.cursor.pen.bg = try terminal.color.Name.cyan.default();
-        screen.cursor.pen.attrs.has_bg = true;
+        screen.cursor.pen.bg = .{ .rgb = try terminal.color.Name.cyan.default() };
         try screen.testWriteString("A");
 
         // Get our first row
@@ -836,10 +835,9 @@ test "shape cell attribute change" {
     {
         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
         defer screen.deinit();
-        screen.cursor.pen.attrs.has_fg = true;
-        screen.cursor.pen.fg = .{ .r = 1, .g = 2, .b = 3 };
+        screen.cursor.pen.fg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
         try screen.testWriteString(">");
-        screen.cursor.pen.fg = .{ .r = 3, .g = 2, .b = 1 };
+        screen.cursor.pen.fg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
         try screen.testWriteString("=");
 
         var shaper = &testdata.shaper;
@@ -856,10 +854,9 @@ test "shape cell attribute change" {
     {
         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
         defer screen.deinit();
-        screen.cursor.pen.attrs.has_bg = true;
-        screen.cursor.pen.bg = .{ .r = 1, .g = 2, .b = 3 };
+        screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
         try screen.testWriteString(">");
-        screen.cursor.pen.bg = .{ .r = 3, .g = 2, .b = 1 };
+        screen.cursor.pen.bg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
         try screen.testWriteString("=");
 
         var shaper = &testdata.shaper;
@@ -876,8 +873,7 @@ test "shape cell attribute change" {
     {
         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
         defer screen.deinit();
-        screen.cursor.pen.attrs.has_bg = true;
-        screen.cursor.pen.bg = .{ .r = 1, .g = 2, .b = 3 };
+        screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
         try screen.testWriteString(">");
         try screen.testWriteString("=");
 

commit f447e6f9df87fd7942630261151935b8dedcad65
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 6 18:57:42 2024 -0800

    font: insert blank cells for multi-cell ligatures for styling
    
    Up to this point, every font I've experienced with ligatures has
    replaced the codepoints that were replaced for combining with a space.
    For example, if a font has a ligature for "!=" to turn it into a glyph,
    it'd shape to `[not equal glyph, space]`, so it'd still take up two
    cells, allowing us to style both.
    
    Monaspace, however, does not do this. It turns "!=" into `[not equal
    glyph]` so styles like backgrounds, underlines, etc. were not extending.
    
    This commit detects multi-cell glyphs and inserts synthetic blank cells
    so that styling returns. I decided to do this via synthetic blank cells
    instead of introducing a `cell_width` to the shaper result because this
    simplifies the renderers to assume each shaper cell is one cell. We can
    change this later if we need to.
    
    Annoyingly, this does make the shaper slightly slower for EVERYONE to
    accomodate one known font that behaves this way. I haven't benchmarked
    it but my belief is that the performance impact will be negligible
    because to figure out cell width we're only accessing subsequent cells
    so they're likely to be in the CPU cache and also 99% of cells are going
    to be width 1.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index cc36bcec..1e682024 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -142,13 +142,13 @@ pub const Shaper = struct {
 
         // Convert all our info/pos to cells and set it.
         self.cell_buf.clearRetainingCapacity();
-        try self.cell_buf.ensureTotalCapacity(self.alloc, info.len);
-        for (info, pos) |info_v, pos_v| {
+        for (info, pos, 0..) |info_v, pos_v, i| {
+            // If our cluster changed then we've moved to a new cell.
             if (info_v.cluster != cell_offset.cluster) cell_offset = .{
                 .cluster = info_v.cluster,
             };
 
-            self.cell_buf.appendAssumeCapacity(.{
+            try self.cell_buf.append(self.alloc, .{
                 .x = @intCast(info_v.cluster),
                 .x_offset = @intCast(cell_offset.x),
                 .y_offset = @intCast(cell_offset.y),
@@ -166,6 +166,43 @@ pub const Shaper = struct {
                 cell_offset.y += pos_v.y_advance;
             }
 
+            // Determine the width of the cell. To do this, we have to
+            // find the next cluster that has been shaped. This tells us how
+            // many cells this glyph replaced (i.e. for ligatures). For example
+            // in some fonts "!=" turns into a single glyph from the component
+            // parts "!" and "=" so this cell width would be "2" despite
+            // only having a single glyph.
+            //
+            // Many fonts replace ligature cells with space so that this always
+            // is one (e.g. Fira Code, JetBrains Mono, etc). Some do not
+            // (e.g. Monaspace).
+            const cell_width = width: {
+                if (i + 1 < info.len) {
+                    // We may have to go through multiple glyphs because
+                    // multiple can be replaced. e.g. "==="
+                    for (info[i + 1 ..]) |next_info_v| {
+                        if (next_info_v.cluster != info_v.cluster) {
+                            break :width next_info_v.cluster - info_v.cluster;
+                        }
+                    }
+                }
+
+                // If we reached the end then our width is our max cluster
+                // minus this one.
+                const max = run.offset + run.cells;
+                break :width max - info_v.cluster;
+            };
+            if (cell_width > 1) {
+                // To make the renderer implementations simpler, we convert
+                // the extra spaces for width to blank cells.
+                for (1..cell_width) |j| {
+                    try self.cell_buf.append(self.alloc, .{
+                        .x = @intCast(info_v.cluster + j),
+                        .glyph_index = null,
+                    });
+                }
+            }
+
             // const i = self.cell_buf.items.len - 1;
             // log.warn("i={} info={} pos={} cell={}", .{ i, info_v, pos_v, self.cell_buf.items[i] });
         }
@@ -334,10 +371,40 @@ test "shape inconsolata ligs" {
             count += 1;
 
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
+            try testing.expectEqual(@as(usize, 2), cells.len);
+            try testing.expect(cells[0].glyph_index != null);
+            try testing.expect(cells[1].glyph_index == null);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        defer screen.deinit();
+        try screen.testWriteString("===");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 3), cells.len);
+            try testing.expect(cells[0].glyph_index != null);
+            try testing.expect(cells[1].glyph_index == null);
+            try testing.expect(cells[2].glyph_index == null);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
+}
+
+test "shape monaspace ligs" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaperWithFont(alloc, .monaspace_neon);
+    defer testdata.deinit();
 
     {
         var screen = try terminal.Screen.init(alloc, 3, 5, 0);
@@ -351,7 +418,10 @@ test "shape inconsolata ligs" {
             count += 1;
 
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
+            try testing.expectEqual(@as(usize, 3), cells.len);
+            try testing.expect(cells[0].glyph_index != null);
+            try testing.expect(cells[1].glyph_index == null);
+            try testing.expect(cells[2].glyph_index == null);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -376,7 +446,7 @@ test "shape emoji width" {
             count += 1;
 
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
+            try testing.expectEqual(@as(usize, 2), cells.len);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -411,7 +481,9 @@ test "shape emoji width long" {
         try testing.expectEqual(@as(u32, 4), shaper.hb_buf.getLength());
 
         const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 1), cells.len);
+
+        // screen.testWriteString isn't grapheme aware, otherwise this is two
+        try testing.expectEqual(@as(usize, 5), cells.len);
     }
     try testing.expectEqual(@as(usize, 1), count);
 }
@@ -574,9 +646,9 @@ test "shape box glyphs" {
         try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
         const cells = try shaper.shape(run);
         try testing.expectEqual(@as(usize, 2), cells.len);
-        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index);
+        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index.?);
         try testing.expectEqual(@as(u16, 0), cells[0].x);
-        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index);
+        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index.?);
         try testing.expectEqual(@as(u16, 1), cells[1].x);
     }
     try testing.expectEqual(@as(usize, 1), count);
@@ -902,11 +974,23 @@ const TestShaper = struct {
     }
 };
 
+const TestFont = enum {
+    inconsolata,
+    monaspace_neon,
+};
+
 /// Helper to return a fully initialized shaper.
 fn testShaper(alloc: Allocator) !TestShaper {
-    const testFont = @import("../test.zig").fontRegular;
+    return try testShaperWithFont(alloc, .inconsolata);
+}
+
+fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
     const testEmoji = @import("../test.zig").fontEmoji;
     const testEmojiText = @import("../test.zig").fontEmojiText;
+    const testFont = switch (font_req) {
+        .inconsolata => @import("../test.zig").fontRegular,
+        .monaspace_neon => @import("../test.zig").fontMonaspaceNeon,
+    };
 
     var lib = try Library.init();
     errdefer lib.deinit();

commit 2082751a65eb1c1bb2ef2846ca3ada1ad68cb818
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jan 7 22:16:11 2024 -0800

    font/shaper: prevent underflow in multi-cell lig detection
    
    Fixes #1251
    
    See the comment for details.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 1e682024..da94afbf 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -182,7 +182,12 @@ pub const Shaper = struct {
                     // multiple can be replaced. e.g. "==="
                     for (info[i + 1 ..]) |next_info_v| {
                         if (next_info_v.cluster != info_v.cluster) {
-                            break :width next_info_v.cluster - info_v.cluster;
+                            // We do a saturating sub here because for RTL
+                            // text, the next cluster can be less than the
+                            // current cluster. We don't really support RTL
+                            // currently so we do this to prevent an underflow
+                            // but it isn't correct generally.
+                            break :width next_info_v.cluster -| info_v.cluster;
                         }
                     }
                 }

commit adb7958f6177dfe5df69bc2202da98c566f389b9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 13 15:06:08 2024 -0800

    remove tracy usage from all files

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index da94afbf..601b642f 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -2,7 +2,6 @@ const std = @import("std");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const harfbuzz = @import("harfbuzz");
-const trace = @import("tracy").trace;
 const font = @import("../main.zig");
 const Face = font.Face;
 const DeferredFace = font.DeferredFace;
@@ -106,9 +105,6 @@ pub const Shaper = struct {
     ///
     /// If there is not enough space in the cell buffer, an error is returned.
     pub fn shape(self: *Shaper, run: font.shape.TextRun) ![]const font.shape.Cell {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         // We only do shaping if the font is not a special-case. For special-case
         // fonts, the codepoint == glyph_index so we don't need to run any shaping.
         if (run.font_index.special() == null) {

commit e3230cf1e6c6519c0d6a6588d3f2844fb02ca05f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 09:28:22 2024 -0800

    font/shaper: start converting run to new terminal

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 601b642f..cf1d9c89 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -10,7 +10,7 @@ const GroupCache = font.GroupCache;
 const Library = font.Library;
 const Style = font.Style;
 const Presentation = font.Presentation;
-const terminal = @import("../../terminal/main.zig");
+const terminal = @import("../../terminal/main.zig").new;
 
 const log = std.log.scoped(.font_shaper);
 
@@ -84,7 +84,7 @@ pub const Shaper = struct {
     pub fn runIterator(
         self: *Shaper,
         group: *GroupCache,
-        row: terminal.Screen.Row,
+        row: terminal.Pin,
         selection: ?terminal.Selection,
         cursor_x: ?usize,
     ) font.shape.RunIterator {
@@ -242,13 +242,18 @@ test "run iterator" {
 
     {
         // Make a screen with some data
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("ABCD");
 
         // Get our run iterator
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -256,12 +261,17 @@ test "run iterator" {
 
     // Spaces should be part of a run
     {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        var screen = try terminal.Screen.init(alloc, 10, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("ABCD   EFG");
 
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |_| count += 1;
         try testing.expectEqual(@as(usize, 1), count);
@@ -269,13 +279,18 @@ test "run iterator" {
 
     {
         // Make a screen with some data
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("AüòÉD");
 
         // Get our run iterator
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |_| {
             count += 1;
@@ -287,71 +302,71 @@ test "run iterator" {
     }
 }
 
-test "run iterator: empty cells with background set" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    {
-        // Make a screen with some data
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
-        defer screen.deinit();
-        screen.cursor.pen.bg = .{ .rgb = try terminal.color.Name.cyan.default() };
-        try screen.testWriteString("A");
-
-        // Get our first row
-        const row = screen.getRow(.{ .active = 0 });
-        row.getCellPtr(1).* = screen.cursor.pen;
-        row.getCellPtr(2).* = screen.cursor.pen;
-
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-
-            // The run should have length 3 because of the two background
-            // cells.
-            try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 3), cells.len);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-test "shape" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-    buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-        _ = try shaper.shape(run);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
+// test "run iterator: empty cells with background set" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     {
+//         // Make a screen with some data
+//         var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+//         defer screen.deinit();
+//         screen.cursor.pen.bg = .{ .rgb = try terminal.color.Name.cyan.default() };
+//         try screen.testWriteString("A");
+//
+//         // Get our first row
+//         const row = screen.getRow(.{ .active = 0 });
+//         row.getCellPtr(1).* = screen.cursor.pen;
+//         row.getCellPtr(2).* = screen.cursor.pen;
+//
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//
+//             // The run should have length 3 because of the two background
+//             // cells.
+//             try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
+//             const cells = try shaper.shape(run);
+//             try testing.expectEqual(@as(usize, 3), cells.len);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+// }
+//
+// test "shape" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     var buf: [32]u8 = undefined;
+//     var buf_idx: usize = 0;
+//     buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+//     buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+//     buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
+//
+//     // Make a screen with some data
+//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//     defer screen.deinit();
+//     try screen.testWriteString(buf[0..buf_idx]);
+//
+//     // Get our run iterator
+//     var shaper = &testdata.shaper;
+//     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//     var count: usize = 0;
+//     while (try it.next(alloc)) |run| {
+//         count += 1;
+//         try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
+//         _ = try shaper.shape(run);
+//     }
+//     try testing.expectEqual(@as(usize, 1), count);
+// }
 
 test "shape inconsolata ligs" {
     const testing = std.testing;
@@ -361,12 +376,17 @@ test "shape inconsolata ligs" {
     defer testdata.deinit();
 
     {
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString(">=");
 
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -380,12 +400,17 @@ test "shape inconsolata ligs" {
     }
 
     {
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("===");
 
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -408,12 +433,17 @@ test "shape monaspace ligs" {
     defer testdata.deinit();
 
     {
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("===");
 
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -436,12 +466,17 @@ test "shape emoji width" {
     defer testdata.deinit();
 
     {
-        var screen = try terminal.Screen.init(alloc, 3, 5, 0);
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
         defer screen.deinit();
         try screen.testWriteString("üëç");
 
         var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+        var it = shaper.runIterator(
+            testdata.cache,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
         var count: usize = 0;
         while (try it.next(alloc)) |run| {
             count += 1;
@@ -469,13 +504,18 @@ test "shape emoji width long" {
     buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // emoji representation
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
     defer screen.deinit();
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -502,13 +542,18 @@ test "shape variation selector VS15" {
     buf_idx += try std.unicode.utf8Encode(0xFE0E, buf[buf_idx..]); // ZWJ to force text
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
     defer screen.deinit();
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -533,13 +578,18 @@ test "shape variation selector VS16" {
     buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // ZWJ to force color
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
     defer screen.deinit();
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -559,23 +609,28 @@ test "shape with empty cells in between" {
     defer testdata.deinit();
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
     defer screen.deinit();
     try screen.testWriteString("A");
-    screen.cursor.x += 5;
+    screen.cursorRight(5);
     try screen.testWriteString("B");
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
 
         const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 1), count);
         try testing.expectEqual(@as(usize, 7), cells.len);
     }
-    try testing.expectEqual(@as(usize, 1), count);
 }
 
 test "shape Chinese characters" {
@@ -593,13 +648,18 @@ test "shape Chinese characters" {
     buf_idx += try std.unicode.utf8Encode('a', buf[buf_idx..]);
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 30, 0);
+    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
     defer screen.deinit();
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -634,13 +694,18 @@ test "shape box glyphs" {
     buf_idx += try std.unicode.utf8Encode(0x2501, buf[buf_idx..]); //
 
     // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
     defer screen.deinit();
     try screen.testWriteString(buf[0..buf_idx]);
 
     // Get our run iterator
     var shaper = &testdata.shaper;
-    var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+    var it = shaper.runIterator(
+        testdata.cache,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
     var count: usize = 0;
     while (try it.next(alloc)) |run| {
         count += 1;
@@ -655,311 +720,311 @@ test "shape box glyphs" {
     try testing.expectEqual(@as(usize, 1), count);
 }
 
-test "shape selection boundary" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-    defer screen.deinit();
-    try screen.testWriteString("a1b2c3d4e5");
-
-    // Full line selection
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-            .start = .{ .x = 0, .y = 0 },
-            .end = .{ .x = screen.cols - 1, .y = 0 },
-        }, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Offset x, goes to end of line selection
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-            .start = .{ .x = 2, .y = 0 },
-            .end = .{ .x = screen.cols - 1, .y = 0 },
-        }, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Offset x, starts at beginning of line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-            .start = .{ .x = 0, .y = 0 },
-            .end = .{ .x = 3, .y = 0 },
-        }, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Selection only subset of line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-            .start = .{ .x = 1, .y = 0 },
-            .end = .{ .x = 3, .y = 0 },
-        }, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-
-    // Selection only one character
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-            .start = .{ .x = 1, .y = 0 },
-            .end = .{ .x = 1, .y = 0 },
-        }, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-}
-
-test "shape cursor boundary" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-    defer screen.deinit();
-    try screen.testWriteString("a1b2c3d4e5");
-
-    // No cursor is full line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Cursor at index 0 is two runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Cursor at index 1 is three runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-
-    // Cursor at last col is two runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 9);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-}
-
-test "shape cursor boundary and colored emoji" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-    defer screen.deinit();
-    try screen.testWriteString("üëçüèº");
-
-    // No cursor is full line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Cursor on emoji does not split it
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-test "shape cell attribute change" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Plain >= should shape into 1 run
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.testWriteString(">=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Bold vs regular should split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.testWriteString(">");
-        screen.cursor.pen.attrs.bold = true;
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Changing fg color should split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        screen.cursor.pen.fg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-        try screen.testWriteString(">");
-        screen.cursor.pen.fg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Changing bg color should split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-        try screen.testWriteString(">");
-        screen.cursor.pen.bg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Same bg color should not split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-        try screen.testWriteString(">");
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
+// test "shape selection boundary" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     // Make a screen with some data
+//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//     defer screen.deinit();
+//     try screen.testWriteString("a1b2c3d4e5");
+//
+//     // Full line selection
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+//             .start = .{ .x = 0, .y = 0 },
+//             .end = .{ .x = screen.cols - 1, .y = 0 },
+//         }, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+//
+//     // Offset x, goes to end of line selection
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+//             .start = .{ .x = 2, .y = 0 },
+//             .end = .{ .x = screen.cols - 1, .y = 0 },
+//         }, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Offset x, starts at beginning of line
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+//             .start = .{ .x = 0, .y = 0 },
+//             .end = .{ .x = 3, .y = 0 },
+//         }, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Selection only subset of line
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+//             .start = .{ .x = 1, .y = 0 },
+//             .end = .{ .x = 3, .y = 0 },
+//         }, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 3), count);
+//     }
+//
+//     // Selection only one character
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
+//             .start = .{ .x = 1, .y = 0 },
+//             .end = .{ .x = 1, .y = 0 },
+//         }, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 3), count);
+//     }
+// }
+//
+// test "shape cursor boundary" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     // Make a screen with some data
+//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//     defer screen.deinit();
+//     try screen.testWriteString("a1b2c3d4e5");
+//
+//     // No cursor is full line
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+//
+//     // Cursor at index 0 is two runs
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Cursor at index 1 is three runs
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 3), count);
+//     }
+//
+//     // Cursor at last col is two runs
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 9);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+// }
+//
+// test "shape cursor boundary and colored emoji" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     // Make a screen with some data
+//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//     defer screen.deinit();
+//     try screen.testWriteString("üëçüèº");
+//
+//     // No cursor is full line
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+//
+//     // Cursor on emoji does not split it
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+//     {
+//         // Get our run iterator
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+// }
+//
+// test "shape cell attribute change" {
+//     const testing = std.testing;
+//     const alloc = testing.allocator;
+//
+//     var testdata = try testShaper(alloc);
+//     defer testdata.deinit();
+//
+//     // Plain >= should shape into 1 run
+//     {
+//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//         defer screen.deinit();
+//         try screen.testWriteString(">=");
+//
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+//
+//     // Bold vs regular should split
+//     {
+//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//         defer screen.deinit();
+//         try screen.testWriteString(">");
+//         screen.cursor.pen.attrs.bold = true;
+//         try screen.testWriteString("=");
+//
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Changing fg color should split
+//     {
+//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//         defer screen.deinit();
+//         screen.cursor.pen.fg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
+//         try screen.testWriteString(">");
+//         screen.cursor.pen.fg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
+//         try screen.testWriteString("=");
+//
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Changing bg color should split
+//     {
+//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//         defer screen.deinit();
+//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
+//         try screen.testWriteString(">");
+//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
+//         try screen.testWriteString("=");
+//
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 2), count);
+//     }
+//
+//     // Same bg color should not split
+//     {
+//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+//         defer screen.deinit();
+//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
+//         try screen.testWriteString(">");
+//         try screen.testWriteString("=");
+//
+//         var shaper = &testdata.shaper;
+//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
+//         var count: usize = 0;
+//         while (try it.next(alloc)) |run| {
+//             count += 1;
+//             _ = try shaper.shape(run);
+//         }
+//         try testing.expectEqual(@as(usize, 1), count);
+//     }
+// }
 
 const TestShaper = struct {
     alloc: Allocator,

commit 34200a3e833cad188abf0378e5e028daa37a4ee3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 09:40:18 2024 -0800

    font/shaper: more tests passing

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index cf1d9c89..f2532800 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -84,6 +84,7 @@ pub const Shaper = struct {
     pub fn runIterator(
         self: *Shaper,
         group: *GroupCache,
+        screen: *const terminal.Screen,
         row: terminal.Pin,
         selection: ?terminal.Selection,
         cursor_x: ?usize,
@@ -91,6 +92,7 @@ pub const Shaper = struct {
         return .{
             .hooks = .{ .shaper = self },
             .group = group,
+            .screen = screen,
             .row = row,
             .selection = selection,
             .cursor_x = cursor_x,
@@ -250,6 +252,7 @@ test "run iterator" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -268,6 +271,7 @@ test "run iterator" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -287,6 +291,7 @@ test "run iterator" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -337,36 +342,42 @@ test "run iterator" {
 //         try testing.expectEqual(@as(usize, 1), count);
 //     }
 // }
-//
-// test "shape" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     var buf: [32]u8 = undefined;
-//     var buf_idx: usize = 0;
-//     buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-//     buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-//     buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
-//
-//     // Make a screen with some data
-//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//     defer screen.deinit();
-//     try screen.testWriteString(buf[0..buf_idx]);
-//
-//     // Get our run iterator
-//     var shaper = &testdata.shaper;
-//     var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//     var count: usize = 0;
-//     while (try it.next(alloc)) |run| {
-//         count += 1;
-//         try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-//         _ = try shaper.shape(run);
-//     }
-//     try testing.expectEqual(@as(usize, 1), count);
-// }
+
+test "shape" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    var buf: [32]u8 = undefined;
+    var buf_idx: usize = 0;
+    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
+    buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
+    defer screen.deinit();
+    try screen.testWriteString(buf[0..buf_idx]);
+
+    // Get our run iterator
+    var shaper = &testdata.shaper;
+    var it = shaper.runIterator(
+        testdata.cache,
+        &screen,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
+        _ = try shaper.shape(run);
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
 
 test "shape inconsolata ligs" {
     const testing = std.testing;
@@ -383,6 +394,7 @@ test "shape inconsolata ligs" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -407,6 +419,7 @@ test "shape inconsolata ligs" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -440,6 +453,7 @@ test "shape monaspace ligs" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -473,6 +487,7 @@ test "shape emoji width" {
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
             testdata.cache,
+            &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
             null,
@@ -512,6 +527,7 @@ test "shape emoji width long" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -550,6 +566,7 @@ test "shape variation selector VS15" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -586,6 +603,7 @@ test "shape variation selector VS16" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -619,6 +637,7 @@ test "shape with empty cells in between" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -656,6 +675,7 @@ test "shape Chinese characters" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -702,6 +722,7 @@ test "shape box glyphs" {
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.cache,
+        &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
         null,
@@ -720,214 +741,291 @@ test "shape box glyphs" {
     try testing.expectEqual(@as(usize, 1), count);
 }
 
-// test "shape selection boundary" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     // Make a screen with some data
-//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//     defer screen.deinit();
-//     try screen.testWriteString("a1b2c3d4e5");
-//
-//     // Full line selection
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-//             .start = .{ .x = 0, .y = 0 },
-//             .end = .{ .x = screen.cols - 1, .y = 0 },
-//         }, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-//
-//     // Offset x, goes to end of line selection
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-//             .start = .{ .x = 2, .y = 0 },
-//             .end = .{ .x = screen.cols - 1, .y = 0 },
-//         }, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Offset x, starts at beginning of line
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-//             .start = .{ .x = 0, .y = 0 },
-//             .end = .{ .x = 3, .y = 0 },
-//         }, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Selection only subset of line
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-//             .start = .{ .x = 1, .y = 0 },
-//             .end = .{ .x = 3, .y = 0 },
-//         }, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 3), count);
-//     }
-//
-//     // Selection only one character
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), .{
-//             .start = .{ .x = 1, .y = 0 },
-//             .end = .{ .x = 1, .y = 0 },
-//         }, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 3), count);
-//     }
-// }
-//
-// test "shape cursor boundary" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     // Make a screen with some data
-//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//     defer screen.deinit();
-//     try screen.testWriteString("a1b2c3d4e5");
-//
-//     // No cursor is full line
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-//
-//     // Cursor at index 0 is two runs
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Cursor at index 1 is three runs
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 3), count);
-//     }
-//
-//     // Cursor at last col is two runs
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 9);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-// }
-//
-// test "shape cursor boundary and colored emoji" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     // Make a screen with some data
-//     var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//     defer screen.deinit();
-//     try screen.testWriteString("üëçüèº");
-//
-//     // No cursor is full line
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-//
-//     // Cursor on emoji does not split it
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 0);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-//     {
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, 1);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-// }
-//
+test "shape selection boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
+    defer screen.deinit();
+    try screen.testWriteString("a1b2c3d4e5");
+
+    // Full line selection
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            terminal.Selection.init(
+                screen.pages.pin(.{ .active = .{ .x = 0, .y = 0 } }).?,
+                screen.pages.pin(.{ .active = .{ .x = screen.pages.cols - 1, .y = 0 } }).?,
+                false,
+            ),
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Offset x, goes to end of line selection
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            terminal.Selection.init(
+                screen.pages.pin(.{ .active = .{ .x = 2, .y = 0 } }).?,
+                screen.pages.pin(.{ .active = .{ .x = screen.pages.cols - 1, .y = 0 } }).?,
+                false,
+            ),
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Offset x, starts at beginning of line
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            terminal.Selection.init(
+                screen.pages.pin(.{ .active = .{ .x = 0, .y = 0 } }).?,
+                screen.pages.pin(.{ .active = .{ .x = 3, .y = 0 } }).?,
+                false,
+            ),
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Selection only subset of line
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            terminal.Selection.init(
+                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
+                screen.pages.pin(.{ .active = .{ .x = 3, .y = 0 } }).?,
+                false,
+            ),
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+
+    // Selection only one character
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            terminal.Selection.init(
+                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
+                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
+                false,
+            ),
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+}
+
+test "shape cursor boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
+    defer screen.deinit();
+    try screen.testWriteString("a1b2c3d4e5");
+
+    // No cursor is full line
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Cursor at index 0 is two runs
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            0,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Cursor at index 1 is three runs
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            1,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 3), count);
+    }
+
+    // Cursor at last col is two runs
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            9,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+}
+
+test "shape cursor boundary and colored emoji" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Make a screen with some data
+    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+    defer screen.deinit();
+    try screen.testWriteString("üëçüèº");
+
+    // No cursor is full line
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Cursor on emoji does not split it
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            0,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+    {
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            1,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
+
 // test "shape cell attribute change" {
 //     const testing = std.testing;
 //     const alloc = testing.allocator;

commit efe037bb9f2bc5f0140d57b32534935883e0329a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 09:48:44 2024 -0800

    font/shaper: test with bg only cells

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index f2532800..17a09c3a 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -307,41 +307,62 @@ test "run iterator" {
     }
 }
 
-// test "run iterator: empty cells with background set" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     {
-//         // Make a screen with some data
-//         var screen = try terminal.Screen.init(alloc, 3, 5, 0);
-//         defer screen.deinit();
-//         screen.cursor.pen.bg = .{ .rgb = try terminal.color.Name.cyan.default() };
-//         try screen.testWriteString("A");
-//
-//         // Get our first row
-//         const row = screen.getRow(.{ .active = 0 });
-//         row.getCellPtr(1).* = screen.cursor.pen;
-//         row.getCellPtr(2).* = screen.cursor.pen;
-//
-//         // Get our run iterator
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//
-//             // The run should have length 3 because of the two background
-//             // cells.
-//             try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-//             const cells = try shaper.shape(run);
-//             try testing.expectEqual(@as(usize, 3), cells.len);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-// }
+test "run iterator: empty cells with background set" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    {
+        // Make a screen with some data
+        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
+        defer screen.deinit();
+        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 0xFF, .g = 0, .b = 0 } });
+        try screen.testWriteString("A");
+
+        // Get our first row
+        {
+            const list_cell = screen.pages.getCell(.{ .active = .{ .x = 1 } }).?;
+            const cell = list_cell.cell;
+            cell.* = .{
+                .content_tag = .bg_color_rgb,
+                .content = .{ .color_rgb = .{ .r = 0xFF, .g = 0, .b = 0 } },
+            };
+        }
+        {
+            const list_cell = screen.pages.getCell(.{ .active = .{ .x = 2 } }).?;
+            const cell = list_cell.cell;
+            cell.* = .{
+                .content_tag = .bg_color_rgb,
+                .content = .{ .color_rgb = .{ .r = 0xFF, .g = 0, .b = 0 } },
+            };
+        }
+
+        // Get our run iterator
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        {
+            const run = (try it.next(alloc)).?;
+            try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 1), cells.len);
+        }
+        {
+            const run = (try it.next(alloc)).?;
+            try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
+            const cells = try shaper.shape(run);
+            try testing.expectEqual(@as(usize, 2), cells.len);
+        }
+        try testing.expect(try it.next(alloc) == null);
+    }
+}
 
 test "shape" {
     const testing = std.testing;

commit 05470bb36a11f5cbaefb141fbaa5f67a37dcb1bd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 09:58:19 2024 -0800

    font/shaper: new API

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 17a09c3a..29a7e315 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -1047,103 +1047,133 @@ test "shape cursor boundary and colored emoji" {
     }
 }
 
-// test "shape cell attribute change" {
-//     const testing = std.testing;
-//     const alloc = testing.allocator;
-//
-//     var testdata = try testShaper(alloc);
-//     defer testdata.deinit();
-//
-//     // Plain >= should shape into 1 run
-//     {
-//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//         defer screen.deinit();
-//         try screen.testWriteString(">=");
-//
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-//
-//     // Bold vs regular should split
-//     {
-//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//         defer screen.deinit();
-//         try screen.testWriteString(">");
-//         screen.cursor.pen.attrs.bold = true;
-//         try screen.testWriteString("=");
-//
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Changing fg color should split
-//     {
-//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//         defer screen.deinit();
-//         screen.cursor.pen.fg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-//         try screen.testWriteString(">");
-//         screen.cursor.pen.fg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
-//         try screen.testWriteString("=");
-//
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Changing bg color should split
-//     {
-//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//         defer screen.deinit();
-//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-//         try screen.testWriteString(">");
-//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 3, .g = 2, .b = 1 } };
-//         try screen.testWriteString("=");
-//
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 2), count);
-//     }
-//
-//     // Same bg color should not split
-//     {
-//         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-//         defer screen.deinit();
-//         screen.cursor.pen.bg = .{ .rgb = .{ .r = 1, .g = 2, .b = 3 } };
-//         try screen.testWriteString(">");
-//         try screen.testWriteString("=");
-//
-//         var shaper = &testdata.shaper;
-//         var it = shaper.runIterator(testdata.cache, screen.getRow(.{ .screen = 0 }), null, null);
-//         var count: usize = 0;
-//         while (try it.next(alloc)) |run| {
-//             count += 1;
-//             _ = try shaper.shape(run);
-//         }
-//         try testing.expectEqual(@as(usize, 1), count);
-//     }
-// }
+test "shape cell attribute change" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaper(alloc);
+    defer testdata.deinit();
+
+    // Plain >= should shape into 1 run
+    {
+        var screen = try terminal.Screen.init(alloc, 10, 3, 0);
+        defer screen.deinit();
+        try screen.testWriteString(">=");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+
+    // Bold vs regular should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.testWriteString(">");
+        try screen.setAttribute(.{ .bold = {} });
+        try screen.testWriteString("=");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Changing fg color should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.setAttribute(.{ .direct_color_fg = .{ .r = 1, .g = 2, .b = 3 } });
+        try screen.testWriteString(">");
+        try screen.setAttribute(.{ .direct_color_fg = .{ .r = 3, .g = 2, .b = 1 } });
+        try screen.testWriteString("=");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Changing bg color should split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 1, .g = 2, .b = 3 } });
+        try screen.testWriteString(">");
+        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 3, .g = 2, .b = 1 } });
+        try screen.testWriteString("=");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 2), count);
+    }
+
+    // Same bg color should not split
+    {
+        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
+        defer screen.deinit();
+        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 1, .g = 2, .b = 3 } });
+        try screen.testWriteString(">");
+        try screen.testWriteString("=");
+
+        var shaper = &testdata.shaper;
+        var it = shaper.runIterator(
+            testdata.cache,
+            &screen,
+            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+            null,
+            null,
+        );
+        var count: usize = 0;
+        while (try it.next(alloc)) |run| {
+            count += 1;
+            _ = try shaper.shape(run);
+        }
+        try testing.expectEqual(@as(usize, 1), count);
+    }
+}
 
 const TestShaper = struct {
     alloc: Allocator,

commit 9b4ab0e209b84890cf53182078a6c42d85553263
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 10:17:41 2024 -0800

    zig build test with renamed terminal package

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 29a7e315..04143c09 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -10,7 +10,7 @@ const GroupCache = font.GroupCache;
 const Library = font.Library;
 const Style = font.Style;
 const Presentation = font.Presentation;
-const terminal = @import("../../terminal/main.zig").new;
+const terminal = @import("../../terminal/main.zig");
 
 const log = std.log.scoped(.font_shaper);
 

commit b77513de1a6bcfd9d23fc35bcfb5cb86e8cabaaf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 5 21:48:53 2024 -0700

    font/harfbuzz: work with new font structures

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 04143c09..13988ecf 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -4,10 +4,10 @@ const Allocator = std.mem.Allocator;
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
 const Face = font.Face;
+const Collection = font.Collection;
 const DeferredFace = font.DeferredFace;
-const Group = font.Group;
-const GroupCache = font.GroupCache;
 const Library = font.Library;
+const SharedGrid = font.SharedGrid;
 const Style = font.Style;
 const Presentation = font.Presentation;
 const terminal = @import("../../terminal/main.zig");
@@ -83,7 +83,7 @@ pub const Shaper = struct {
     /// and assume the y value matches.
     pub fn runIterator(
         self: *Shaper,
-        group: *GroupCache,
+        grid: *SharedGrid,
         screen: *const terminal.Screen,
         row: terminal.Pin,
         selection: ?terminal.Selection,
@@ -91,7 +91,7 @@ pub const Shaper = struct {
     ) font.shape.RunIterator {
         return .{
             .hooks = .{ .shaper = self },
-            .group = group,
+            .grid = grid,
             .screen = screen,
             .row = row,
             .selection = selection,
@@ -110,7 +110,13 @@ pub const Shaper = struct {
         // We only do shaping if the font is not a special-case. For special-case
         // fonts, the codepoint == glyph_index so we don't need to run any shaping.
         if (run.font_index.special() == null) {
-            const face = try run.group.group.faceFromIndex(run.font_index);
+            // We have to lock the grid to get the face and unfortunately
+            // freetype faces (typically used with harfbuzz) are not thread
+            // safe so this has to be an exclusive lock.
+            run.grid.lock.lock();
+            defer run.grid.lock.unlock();
+
+            const face = try run.grid.resolver.collection.getFace(run.font_index);
             const i = if (!face.quirks_disable_default_font_features) 0 else i: {
                 // If we are disabling default font features we just offset
                 // our features by the hardcoded items because always
@@ -251,7 +257,7 @@ test "run iterator" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -270,7 +276,7 @@ test "run iterator" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -290,7 +296,7 @@ test "run iterator" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -342,7 +348,7 @@ test "run iterator: empty cells with background set" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -385,7 +391,7 @@ test "shape" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -414,7 +420,7 @@ test "shape inconsolata ligs" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -439,7 +445,7 @@ test "shape inconsolata ligs" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -473,7 +479,7 @@ test "shape monaspace ligs" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -507,7 +513,7 @@ test "shape emoji width" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -547,7 +553,7 @@ test "shape emoji width long" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -586,7 +592,7 @@ test "shape variation selector VS15" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -623,7 +629,7 @@ test "shape variation selector VS16" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -657,7 +663,7 @@ test "shape with empty cells in between" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -695,7 +701,7 @@ test "shape Chinese characters" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -722,13 +728,6 @@ test "shape box glyphs" {
     var testdata = try testShaper(alloc);
     defer testdata.deinit();
 
-    // Setup the box font
-    testdata.cache.group.sprite = font.sprite.Face{
-        .width = 18,
-        .height = 36,
-        .thickness = 2,
-    };
-
     var buf: [32]u8 = undefined;
     var buf_idx: usize = 0;
     buf_idx += try std.unicode.utf8Encode(0x2500, buf[buf_idx..]); // horiz line
@@ -742,7 +741,7 @@ test "shape box glyphs" {
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
-        testdata.cache,
+        testdata.grid,
         &screen,
         screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
         null,
@@ -779,7 +778,7 @@ test "shape selection boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             terminal.Selection.init(
@@ -802,7 +801,7 @@ test "shape selection boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             terminal.Selection.init(
@@ -825,7 +824,7 @@ test "shape selection boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             terminal.Selection.init(
@@ -848,7 +847,7 @@ test "shape selection boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             terminal.Selection.init(
@@ -871,7 +870,7 @@ test "shape selection boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             terminal.Selection.init(
@@ -907,7 +906,7 @@ test "shape cursor boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -926,7 +925,7 @@ test "shape cursor boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -945,7 +944,7 @@ test "shape cursor boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -964,7 +963,7 @@ test "shape cursor boundary" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -996,7 +995,7 @@ test "shape cursor boundary and colored emoji" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1015,7 +1014,7 @@ test "shape cursor boundary and colored emoji" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1032,7 +1031,7 @@ test "shape cursor boundary and colored emoji" {
         // Get our run iterator
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1062,7 +1061,7 @@ test "shape cell attribute change" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1086,7 +1085,7 @@ test "shape cell attribute change" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1111,7 +1110,7 @@ test "shape cell attribute change" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1136,7 +1135,7 @@ test "shape cell attribute change" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1160,7 +1159,7 @@ test "shape cell attribute change" {
 
         var shaper = &testdata.shaper;
         var it = shaper.runIterator(
-            testdata.cache,
+            testdata.grid,
             &screen,
             screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
             null,
@@ -1178,13 +1177,13 @@ test "shape cell attribute change" {
 const TestShaper = struct {
     alloc: Allocator,
     shaper: Shaper,
-    cache: *GroupCache,
+    grid: *SharedGrid,
     lib: Library,
 
     pub fn deinit(self: *TestShaper) void {
         self.shaper.deinit();
-        self.cache.deinit(self.alloc);
-        self.alloc.destroy(self.cache);
+        self.grid.deinit(self.alloc);
+        self.alloc.destroy(self.grid);
         self.lib.deinit();
     }
 };
@@ -1210,17 +1209,11 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
     var lib = try Library.init();
     errdefer lib.deinit();
 
-    var cache_ptr = try alloc.create(GroupCache);
-    errdefer alloc.destroy(cache_ptr);
-    cache_ptr.* = try GroupCache.init(alloc, try Group.init(
-        alloc,
-        lib,
-        .{ .points = 12 },
-    ));
-    errdefer cache_ptr.*.deinit(alloc);
+    var c = try Collection.init(alloc);
+    c.load_options = .{ .library = lib };
 
     // Setup group
-    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
         lib,
         testFont,
         .{ .size = .{ .points = 12 } },
@@ -1228,7 +1221,7 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
 
     if (font.options.backend != .coretext) {
         // Coretext doesn't support Noto's format
-        _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+        _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
             lib,
             testEmoji,
             .{ .size = .{ .points = 12 } },
@@ -1245,21 +1238,26 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
         defer disco_it.deinit();
         var face = (try disco_it.next()).?;
         errdefer face.deinit();
-        _ = try cache_ptr.group.addFace(.regular, .{ .deferred = face });
+        _ = try c.add(alloc, .regular, .{ .deferred = face });
     }
-    _ = try cache_ptr.group.addFace(.regular, .{ .loaded = try Face.init(
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
         lib,
         testEmojiText,
         .{ .size = .{ .points = 12 } },
     ) });
 
+    const grid_ptr = try alloc.create(SharedGrid);
+    errdefer alloc.destroy(grid_ptr);
+    grid_ptr.* = try SharedGrid.init(alloc, .{ .collection = c }, false);
+    errdefer grid_ptr.*.deinit(alloc);
+
     var shaper = try Shaper.init(alloc, .{});
     errdefer shaper.deinit();
 
     return TestShaper{
         .alloc = alloc,
         .shaper = shaper,
-        .cache = cache_ptr,
+        .grid = grid_ptr,
         .lib = lib,
     };
 }

commit 313c7f4cf1e7ef55807abbee7e9a85d3bafa4ff5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 30 11:08:13 2024 -0700

    font: runs do not split on bg color change
    
    We previously split text runs for shaping on bg color changes. As
    pointed out in Discord, this is not necessary, since we can always color
    cells according to their desired background even if the text in the cell
    shapes to something else.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 13988ecf..38ac7c10 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -356,15 +356,9 @@ test "run iterator: empty cells with background set" {
         );
         {
             const run = (try it.next(alloc)).?;
-            try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
-        }
-        {
-            const run = (try it.next(alloc)).?;
-            try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
+            try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 2), cells.len);
+            try testing.expectEqual(@as(usize, 3), cells.len);
         }
         try testing.expect(try it.next(alloc) == null);
     }
@@ -1124,7 +1118,7 @@ test "shape cell attribute change" {
         try testing.expectEqual(@as(usize, 2), count);
     }
 
-    // Changing bg color should split
+    // Changing bg color should not split
     {
         var screen = try terminal.Screen.init(alloc, 3, 10, 0);
         defer screen.deinit();
@@ -1146,7 +1140,7 @@ test "shape cell attribute change" {
             count += 1;
             _ = try shaper.shape(run);
         }
-        try testing.expectEqual(@as(usize, 2), count);
+        try testing.expectEqual(@as(usize, 1), count);
     }
 
     // Same bg color should not split

commit 346eba3152aaa233e8399a7f518fa2ed0d27b454
Author: Jack N <nystromjp@gmail.com>
Date:   Mon Apr 22 20:35:23 2024 -0700

    sprites: dont thicken via font-thicken, + add cursor thickness adjustment

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 13988ecf..6ff70672 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -1248,7 +1248,7 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
 
     const grid_ptr = try alloc.create(SharedGrid);
     errdefer alloc.destroy(grid_ptr);
-    grid_ptr.* = try SharedGrid.init(alloc, .{ .collection = c }, false);
+    grid_ptr.* = try SharedGrid.init(alloc, .{ .collection = c });
     errdefer grid_ptr.*.deinit(alloc);
 
     var shaper = try Shaper.init(alloc, .{});

commit f99823ec38dbe315a58fb6b2afb3f827f654b81f
Merge: 10723547 8c8f1b6f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 30 14:09:04 2024 -0700

    Merge pull request #1713 from BvngeeCord/main
    
    sprites: dont thicken via font-thicken, add cursor thickness adjustment


commit 6dcf567554eaf99eae0166838ff3e5d1f2b9a513
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 8 18:33:14 2024 -0700

    font: fix coretext test issues with harfbuzz shaper

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index c34a5762..11adecb7 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -1213,7 +1213,7 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
         .{ .size = .{ .points = 12 } },
     ) });
 
-    if (font.options.backend != .coretext) {
+    if (comptime !font.options.backend.hasCoretext()) {
         // Coretext doesn't support Noto's format
         _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
             lib,

commit 260744623514ab0bcac914c7c5de7f126a21b9ee
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jun 22 20:49:10 2024 -0700

    font: add noop endFrame calls to all other shapers

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 11adecb7..7599a624 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -74,6 +74,10 @@ pub const Shaper = struct {
         self.hb_feats.deinit(self.alloc);
     }
 
+    pub fn endFrame(self: *const Shaper) void {
+        _ = self;
+    }
+
     /// Returns an iterator that returns one text run at a time for the
     /// given terminal row. Note that text runs are are only valid one at a time
     /// for a Shaper struct since they share state.

commit 5befe75a1f6bfe6bae95414695d8db7d4e85c0f3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 15:30:47 2024 -0700

    font/harfbuzz: work with new collection API

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 7599a624..8c04b759 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -1207,7 +1207,7 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
     var lib = try Library.init();
     errdefer lib.deinit();
 
-    var c = try Collection.init(alloc);
+    var c = Collection.init();
     c.load_options = .{ .library = lib };
 
     // Setup group

commit be3ae56bc8cdd8c6b15c3bcd885d572300b28953
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 2 14:45:34 2024 -0700

    font: add stylistic variants for built-in font, fix naming convention
    
    Fixes #2364
    
    This adds the bold, italic, and bold italic variants of JB Mono so it is
    built-in. This also fixes up the naming convention for the embedded font
    files across tests and removes redundant embedded font files.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 8c04b759..6dd520ad 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -1197,11 +1197,11 @@ fn testShaper(alloc: Allocator) !TestShaper {
 }
 
 fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
-    const testEmoji = @import("../test.zig").fontEmoji;
-    const testEmojiText = @import("../test.zig").fontEmojiText;
+    const testEmoji = font.embedded.emoji;
+    const testEmojiText = font.embedded.emoji_text;
     const testFont = switch (font_req) {
-        .inconsolata => @import("../test.zig").fontRegular,
-        .monaspace_neon => @import("../test.zig").fontMonaspaceNeon,
+        .inconsolata => font.embedded.inconsolata,
+        .monaspace_neon => font.embedded.monaspace_neon,
     };
 
     var lib = try Library.init();

commit 7686cacde61a6b094eabcfbdd73baee4a225b25a
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Tue Oct 8 23:10:43 2024 -0400

    renderer, shaper: don't use null cells, handle bg and decorations separately
    
    Significant rework that also removes a lot of unnecessarily duplicated
    work while rebuilding cells in both renderers. Fixes multiple issues
    with decorations and bg colors on wide chars and ligatures, while
    reducing the amount of special case handling required.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 6dd520ad..53efeec5 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -150,7 +150,7 @@ pub const Shaper = struct {
 
         // Convert all our info/pos to cells and set it.
         self.cell_buf.clearRetainingCapacity();
-        for (info, pos, 0..) |info_v, pos_v, i| {
+        for (info, pos) |info_v, pos_v| {
             // If our cluster changed then we've moved to a new cell.
             if (info_v.cluster != cell_offset.cluster) cell_offset = .{
                 .cluster = info_v.cluster,
@@ -174,48 +174,6 @@ pub const Shaper = struct {
                 cell_offset.y += pos_v.y_advance;
             }
 
-            // Determine the width of the cell. To do this, we have to
-            // find the next cluster that has been shaped. This tells us how
-            // many cells this glyph replaced (i.e. for ligatures). For example
-            // in some fonts "!=" turns into a single glyph from the component
-            // parts "!" and "=" so this cell width would be "2" despite
-            // only having a single glyph.
-            //
-            // Many fonts replace ligature cells with space so that this always
-            // is one (e.g. Fira Code, JetBrains Mono, etc). Some do not
-            // (e.g. Monaspace).
-            const cell_width = width: {
-                if (i + 1 < info.len) {
-                    // We may have to go through multiple glyphs because
-                    // multiple can be replaced. e.g. "==="
-                    for (info[i + 1 ..]) |next_info_v| {
-                        if (next_info_v.cluster != info_v.cluster) {
-                            // We do a saturating sub here because for RTL
-                            // text, the next cluster can be less than the
-                            // current cluster. We don't really support RTL
-                            // currently so we do this to prevent an underflow
-                            // but it isn't correct generally.
-                            break :width next_info_v.cluster -| info_v.cluster;
-                        }
-                    }
-                }
-
-                // If we reached the end then our width is our max cluster
-                // minus this one.
-                const max = run.offset + run.cells;
-                break :width max - info_v.cluster;
-            };
-            if (cell_width > 1) {
-                // To make the renderer implementations simpler, we convert
-                // the extra spaces for width to blank cells.
-                for (1..cell_width) |j| {
-                    try self.cell_buf.append(self.alloc, .{
-                        .x = @intCast(info_v.cluster + j),
-                        .glyph_index = null,
-                    });
-                }
-            }
-
             // const i = self.cell_buf.items.len - 1;
             // log.warn("i={} info={} pos={} cell={}", .{ i, info_v, pos_v, self.cell_buf.items[i] });
         }

commit ca59367164d330575b8c4a83346c7ec98f1aa340
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Oct 9 16:05:09 2024 -0400

    harfbuzz: fix tests to account for removal of null cells

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 53efeec5..b3c8400b 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -386,10 +386,10 @@ test "shape inconsolata ligs" {
         while (try it.next(alloc)) |run| {
             count += 1;
 
+            try testing.expectEqual(@as(usize, 2), run.cells);
+
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 2), cells.len);
-            try testing.expect(cells[0].glyph_index != null);
-            try testing.expect(cells[1].glyph_index == null);
+            try testing.expectEqual(@as(usize, 1), cells.len);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -411,11 +411,10 @@ test "shape inconsolata ligs" {
         while (try it.next(alloc)) |run| {
             count += 1;
 
+            try testing.expectEqual(@as(usize, 3), run.cells);
+
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 3), cells.len);
-            try testing.expect(cells[0].glyph_index != null);
-            try testing.expect(cells[1].glyph_index == null);
-            try testing.expect(cells[2].glyph_index == null);
+            try testing.expectEqual(@as(usize, 1), cells.len);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -445,11 +444,10 @@ test "shape monaspace ligs" {
         while (try it.next(alloc)) |run| {
             count += 1;
 
+            try testing.expectEqual(@as(usize, 3), run.cells);
+
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 3), cells.len);
-            try testing.expect(cells[0].glyph_index != null);
-            try testing.expect(cells[1].glyph_index == null);
-            try testing.expect(cells[2].glyph_index == null);
+            try testing.expectEqual(@as(usize, 1), cells.len);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -479,8 +477,10 @@ test "shape emoji width" {
         while (try it.next(alloc)) |run| {
             count += 1;
 
+            try testing.expectEqual(@as(usize, 2), run.cells);
+
             const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 2), cells.len);
+            try testing.expectEqual(@as(usize, 1), cells.len);
         }
         try testing.expectEqual(@as(usize, 1), count);
     }
@@ -522,8 +522,7 @@ test "shape emoji width long" {
 
         const cells = try shaper.shape(run);
 
-        // screen.testWriteString isn't grapheme aware, otherwise this is two
-        try testing.expectEqual(@as(usize, 5), cells.len);
+        try testing.expectEqual(@as(usize, 1), cells.len);
     }
     try testing.expectEqual(@as(usize, 1), count);
 }
@@ -709,9 +708,9 @@ test "shape box glyphs" {
         try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
         const cells = try shaper.shape(run);
         try testing.expectEqual(@as(usize, 2), cells.len);
-        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index.?);
+        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index);
         try testing.expectEqual(@as(u16, 0), cells[0].x);
-        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index.?);
+        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index);
         try testing.expectEqual(@as(u16, 1), cells[1].x);
     }
     try testing.expectEqual(@as(usize, 1), count);

commit f04b6c8768cd49c7ce2c9a9d94a696bf71a466a7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 3 09:51:13 2024 -0800

    font/harfbuzz: force LTR font shaping
    
    Fixes #2570
    Related to #1740
    
    See #1740 for details.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index b3c8400b..ccb422f2 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -190,6 +190,11 @@ pub const Shaper = struct {
             // Reset the buffer for our current run
             self.shaper.hb_buf.reset();
             self.shaper.hb_buf.setContentType(.unicode);
+
+            // We don't support RTL text because RTL in terminals is messy.
+            // Its something we want to improve. For now, we force LTR because
+            // our renderers assume a strictly increasing X value.
+            self.shaper.hb_buf.setDirection(.ltr);
         }
 
         pub fn addCodepoint(self: RunIteratorHook, cp: u32, cluster: u32) !void {
@@ -453,6 +458,46 @@ test "shape monaspace ligs" {
     }
 }
 
+// Ghostty doesn't currently support RTL and our renderers assume
+// that cells are in strict LTR order. This means that we need to
+// force RTL text to be LTR for rendering. This test ensures that
+// we are correctly forcing RTL text to be LTR.
+test "shape arabic forced LTR" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var testdata = try testShaperWithFont(alloc, .arabic);
+    defer testdata.deinit();
+
+    var screen = try terminal.Screen.init(alloc, 120, 30, 0);
+    defer screen.deinit();
+    try screen.testWriteString(@embedFile("testdata/arabic.txt"));
+
+    var shaper = &testdata.shaper;
+    var it = shaper.runIterator(
+        testdata.grid,
+        &screen,
+        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        null,
+        null,
+    );
+    var count: usize = 0;
+    while (try it.next(alloc)) |run| {
+        count += 1;
+        try testing.expectEqual(@as(usize, 25), run.cells);
+
+        const cells = try shaper.shape(run);
+        try testing.expectEqual(@as(usize, 25), cells.len);
+
+        var x: u16 = cells[0].x;
+        for (cells[1..]) |cell| {
+            try testing.expectEqual(x + 1, cell.x);
+            x = cell.x;
+        }
+    }
+    try testing.expectEqual(@as(usize, 1), count);
+}
+
 test "shape emoji width" {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -1146,6 +1191,7 @@ const TestShaper = struct {
 const TestFont = enum {
     inconsolata,
     monaspace_neon,
+    arabic,
 };
 
 /// Helper to return a fully initialized shaper.
@@ -1159,6 +1205,7 @@ fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
     const testFont = switch (font_req) {
         .inconsolata => font.embedded.inconsolata,
         .monaspace_neon => font.embedded.monaspace_neon,
+        .arabic => font.embedded.arabic,
     };
 
     var lib = try Library.init();

commit 2d174f9bff96cc65c55f6c0a6b27f14e655b7a08
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Dec 30 20:49:45 2024 -0500

    font: allow non-boolean font feature settings
    
    + much more flexible syntax and lenient parser
    + allows comma-separated list as a single config value
    
    This allows, e.g. `cv01 = 2` to select the second variant of `cv01`.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index ccb422f2..97292b9b 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -3,6 +3,10 @@ const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
+const terminal = @import("../../terminal/main.zig");
+const Feature = font.shape.Feature;
+const FeatureList = font.shape.FeatureList;
+const default_features = font.shape.default_features;
 const Face = font.Face;
 const Collection = font.Collection;
 const DeferredFace = font.DeferredFace;
@@ -10,7 +14,6 @@ const Library = font.Library;
 const SharedGrid = font.SharedGrid;
 const Style = font.Style;
 const Presentation = font.Presentation;
-const terminal = @import("../../terminal/main.zig");
 
 const log = std.log.scoped(.font_shaper);
 
@@ -27,38 +30,37 @@ pub const Shaper = struct {
     cell_buf: CellBuf,
 
     /// The features to use for shaping.
-    hb_feats: FeatureList,
+    hb_feats: []harfbuzz.Feature,
 
     const CellBuf = std.ArrayListUnmanaged(font.shape.Cell);
-    const FeatureList = std.ArrayListUnmanaged(harfbuzz.Feature);
-
-    // These features are hardcoded to always be on by default. Users
-    // can turn them off by setting the features to "-liga" for example.
-    const hardcoded_features = [_][]const u8{ "dlig", "liga" };
 
     /// The cell_buf argument is the buffer to use for storing shaped results.
     /// This should be at least the number of columns in the terminal.
     pub fn init(alloc: Allocator, opts: font.shape.Options) !Shaper {
-        // Parse all the features we want to use. We use
-        var hb_feats = hb_feats: {
-            var list = try FeatureList.initCapacity(alloc, opts.features.len + hardcoded_features.len);
-            errdefer list.deinit(alloc);
-
-            for (hardcoded_features) |name| {
-                if (harfbuzz.Feature.fromString(name)) |feat| {
-                    try list.append(alloc, feat);
-                } else log.warn("failed to parse font feature: {s}", .{name});
+        // Parse all the features we want to use.
+        const hb_feats = hb_feats: {
+            var feature_list: FeatureList = .{};
+            defer feature_list.deinit(alloc);
+            try feature_list.features.appendSlice(alloc, &default_features);
+            for (opts.features) |feature_str| {
+                try feature_list.appendFromString(alloc, feature_str);
             }
 
-            for (opts.features) |name| {
-                if (harfbuzz.Feature.fromString(name)) |feat| {
-                    try list.append(alloc, feat);
-                } else log.warn("failed to parse font feature: {s}", .{name});
+            var list = try alloc.alloc(harfbuzz.Feature, feature_list.features.items.len);
+            errdefer alloc.free(list);
+
+            for (feature_list.features.items, 0..) |feature, i| {
+                list[i] = .{
+                    .tag = std.mem.nativeToBig(u32, @bitCast(feature.tag)),
+                    .value = feature.value,
+                    .start = harfbuzz.c.HB_FEATURE_GLOBAL_START,
+                    .end = harfbuzz.c.HB_FEATURE_GLOBAL_END,
+                };
             }
 
             break :hb_feats list;
         };
-        errdefer hb_feats.deinit(alloc);
+        errdefer alloc.free(hb_feats);
 
         return Shaper{
             .alloc = alloc,
@@ -71,7 +73,7 @@ pub const Shaper = struct {
     pub fn deinit(self: *Shaper) void {
         self.hb_buf.destroy();
         self.cell_buf.deinit(self.alloc);
-        self.hb_feats.deinit(self.alloc);
+        self.alloc.free(self.hb_feats);
     }
 
     pub fn endFrame(self: *const Shaper) void {
@@ -125,10 +127,10 @@ pub const Shaper = struct {
                 // If we are disabling default font features we just offset
                 // our features by the hardcoded items because always
                 // add those at the beginning.
-                break :i hardcoded_features.len;
+                break :i default_features.len;
             };
 
-            harfbuzz.shape(face.hb_font, self.hb_buf, self.hb_feats.items[i..]);
+            harfbuzz.shape(face.hb_font, self.hb_buf, self.hb_feats[i..]);
         }
 
         // If our buffer is empty, we short-circuit the rest of the work

commit f0080529c42ccccbeb0340a7e36534695c621807
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Mar 19 14:50:42 2025 -0600

    fix(font/shape): don't require emoji presentation for grapheme parts
    
    Also update shaper test that fails because the run iterator can't apply
    that logic since `testWriteString` doesn't do proper grpaheme clustering
    so the parts are actually split across multiple cells.
    
    Several other tests are technically incorrect for the same reason but
    still pass, so I've decided not to fix them here.

diff --git a/src/font/shaper/harfbuzz.zig b/src/font/shaper/harfbuzz.zig
index 97292b9b..b284dc14 100644
--- a/src/font/shaper/harfbuzz.zig
+++ b/src/font/shaper/harfbuzz.zig
@@ -540,25 +540,35 @@ test "shape emoji width long" {
     var testdata = try testShaper(alloc);
     defer testdata.deinit();
 
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x1F9D4, buf[buf_idx..]); // man: beard
-    buf_idx += try std.unicode.utf8Encode(0x1F3FB, buf[buf_idx..]); // light skin tone (Fitz 1-2)
-    buf_idx += try std.unicode.utf8Encode(0x200D, buf[buf_idx..]); // ZWJ
-    buf_idx += try std.unicode.utf8Encode(0x2642, buf[buf_idx..]); // male sign
-    buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // emoji representation
-
-    // Make a screen with some data
+    // Make a screen and add a long emoji sequence to it.
     var screen = try terminal.Screen.init(alloc, 30, 3, 0);
     defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
+
+    var page = screen.pages.pages.first.?.data;
+    var row = page.getRow(1);
+    const cell = &row.cells.ptr(page.memory)[0];
+    cell.* = .{
+        .content_tag = .codepoint,
+        .content = .{ .codepoint = 0x1F9D4 }, // Person with beard
+    };
+    var graphemes = [_]u21{
+        0x1F3FB, // Light skin tone (Fitz 1-2)
+        0x200D, // ZWJ
+        0x2642, // Male sign
+        0xFE0F, // Emoji presentation selector
+    };
+    try page.setGraphemes(
+        row,
+        cell,
+        graphemes[0..],
+    );
 
     // Get our run iterator
     var shaper = &testdata.shaper;
     var it = shaper.runIterator(
         testdata.grid,
         &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
+        screen.pages.pin(.{ .screen = .{ .y = 1 } }).?,
         null,
         null,
     );

