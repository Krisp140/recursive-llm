# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/client/ReactDOMRoot.js

commit b8f8258775211d2d3b1b144cc6c75148ecd4b8d8
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sun Nov 10 13:43:29 2019 +0000

    Split ReactDOM entry point (#17331)
    
    * Split ReactDOM entry point
    
    * BatchedRoot -> BlockingRoot

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
new file mode 100644
index 0000000000..0edc6a3672
--- /dev/null
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -0,0 +1,188 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {DOMContainer} from './ReactDOM';
+import type {RootTag} from 'shared/ReactRootTags';
+import type {ReactNodeList} from 'shared/ReactTypes';
+// TODO: This type is shared between the reconciler and ReactDOM, but will
+// eventually be lifted out to the renderer.
+import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
+
+export type RootType = {
+  render(children: ReactNodeList, callback: ?() => mixed): void,
+  unmount(callback: ?() => mixed): void,
+
+  _internalRoot: FiberRoot,
+};
+
+export type RootOptions = {
+  hydrate?: boolean,
+  hydrationOptions?: {
+    onHydrated?: (suspenseNode: Comment) => void,
+    onDeleted?: (suspenseNode: Comment) => void,
+  },
+};
+
+import {
+  isContainerMarkedAsRoot,
+  markContainerAsRoot,
+  unmarkContainerAsRoot,
+} from './ReactDOMComponentTree';
+import {eagerlyTrapReplayableEvents} from '../events/ReactDOMEventReplaying';
+import {
+  ELEMENT_NODE,
+  COMMENT_NODE,
+  DOCUMENT_NODE,
+  DOCUMENT_FRAGMENT_NODE,
+} from '../shared/HTMLNodeType';
+
+import {createContainer, updateContainer} from 'react-reconciler/inline.dom';
+import invariant from 'shared/invariant';
+import warningWithoutStack from 'shared/warningWithoutStack';
+import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
+
+function ReactDOMRoot(container: DOMContainer, options: void | RootOptions) {
+  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
+}
+
+function ReactDOMBlockingRoot(
+  container: DOMContainer,
+  tag: RootTag,
+  options: void | RootOptions,
+) {
+  this._internalRoot = createRootImpl(container, tag, options);
+}
+
+ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
+  children: ReactNodeList,
+  callback: ?() => mixed,
+): void {
+  const root = this._internalRoot;
+  const cb = callback === undefined ? null : callback;
+  if (__DEV__) {
+    warnOnInvalidCallback(cb, 'render');
+  }
+  updateContainer(children, root, null, cb);
+};
+
+ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(
+  callback: ?() => mixed,
+): void {
+  const root = this._internalRoot;
+  const cb = callback === undefined ? null : callback;
+  if (__DEV__) {
+    warnOnInvalidCallback(cb, 'render');
+  }
+  const container = root.containerInfo;
+  updateContainer(null, root, null, () => {
+    unmarkContainerAsRoot(container);
+    if (cb !== null) {
+      cb();
+    }
+  });
+};
+
+function createRootImpl(
+  container: DOMContainer,
+  tag: RootTag,
+  options: void | RootOptions,
+) {
+  // Tag is either LegacyRoot or Concurrent Root
+  const hydrate = options != null && options.hydrate === true;
+  const hydrationCallbacks =
+    (options != null && options.hydrationOptions) || null;
+  const root = createContainer(container, tag, hydrate, hydrationCallbacks);
+  markContainerAsRoot(root.current, container);
+  if (hydrate && tag !== LegacyRoot) {
+    const doc =
+      container.nodeType === DOCUMENT_NODE
+        ? container
+        : container.ownerDocument;
+    eagerlyTrapReplayableEvents(doc);
+  }
+  return root;
+}
+
+export function createRoot(
+  container: DOMContainer,
+  options?: RootOptions,
+): RootType {
+  invariant(
+    isValidContainer(container),
+    'createRoot(...): Target container is not a DOM element.',
+  );
+  warnIfReactDOMContainerInDEV(container);
+  return new ReactDOMRoot(container, options);
+}
+
+export function createBlockingRoot(
+  container: DOMContainer,
+  options?: RootOptions,
+): RootType {
+  invariant(
+    isValidContainer(container),
+    'createRoot(...): Target container is not a DOM element.',
+  );
+  warnIfReactDOMContainerInDEV(container);
+  return new ReactDOMBlockingRoot(container, BlockingRoot, options);
+}
+
+export function createLegacyRoot(
+  container: DOMContainer,
+  options?: RootOptions,
+): RootType {
+  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
+}
+
+export function isValidContainer(node: mixed): boolean {
+  return !!(
+    node &&
+    (node.nodeType === ELEMENT_NODE ||
+      node.nodeType === DOCUMENT_NODE ||
+      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
+      (node.nodeType === COMMENT_NODE &&
+        (node: any).nodeValue === ' react-mount-point-unstable '))
+  );
+}
+
+export function warnOnInvalidCallback(
+  callback: mixed,
+  callerName: string,
+): void {
+  if (__DEV__) {
+    warningWithoutStack(
+      callback === null || typeof callback === 'function',
+      '%s(...): Expected the last optional `callback` argument to be a ' +
+        'function. Instead received: %s.',
+      callerName,
+      callback,
+    );
+  }
+}
+
+function warnIfReactDOMContainerInDEV(container) {
+  if (__DEV__) {
+    if (isContainerMarkedAsRoot(container)) {
+      if (container._reactRootContainer) {
+        warningWithoutStack(
+          false,
+          'You are calling ReactDOM.createRoot() on a container that was previously ' +
+            'passed to ReactDOM.render(). This is not supported.',
+        );
+      } else {
+        warningWithoutStack(
+          false,
+          'You are calling ReactDOM.createRoot() on a container that ' +
+            'has already been passed to createRoot() before. Instead, call ' +
+            'root.render() on the existing root instead if you want to update it.',
+        );
+      }
+    }
+  }
+}

commit 9ac42dd074c42b66ecc0334b75200b1d2989f892
Author: Laura buns <walaura@fb.com>
Date:   Wed Dec 11 03:28:14 2019 +0000

    Remove the condition argument from warning() (#17568)
    
    * prep for codemod
    
    * prep warnings
    
    * rename lint rules
    
    * codemod for ifs
    
    * shim www functions
    
    * Handle more cases in the transform
    
    * Thanks De Morgan
    
    * Run the codemod
    
    * Delete the transform
    
    * Fix up confusing conditions manually
    
    * Fix up www shims to match expected API
    
    * Also check for low-pri warning in the lint rule

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 0edc6a3672..77e6183935 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -156,13 +156,14 @@ export function warnOnInvalidCallback(
   callerName: string,
 ): void {
   if (__DEV__) {
-    warningWithoutStack(
-      callback === null || typeof callback === 'function',
-      '%s(...): Expected the last optional `callback` argument to be a ' +
-        'function. Instead received: %s.',
-      callerName,
-      callback,
-    );
+    if (callback !== null && typeof callback !== 'function') {
+      warningWithoutStack(
+        '%s(...): Expected the last optional `callback` argument to be a ' +
+          'function. Instead received: %s.',
+        callerName,
+        callback,
+      );
+    }
   }
 }
 
@@ -171,13 +172,11 @@ function warnIfReactDOMContainerInDEV(container) {
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
         warningWithoutStack(
-          false,
           'You are calling ReactDOM.createRoot() on a container that was previously ' +
             'passed to ReactDOM.render(). This is not supported.',
         );
       } else {
         warningWithoutStack(
-          false,
           'You are calling ReactDOM.createRoot() on a container that ' +
             'has already been passed to createRoot() before. Instead, call ' +
             'root.render() on the existing root instead if you want to update it.',

commit b15bf36750ca4c4a5a09f2de76c5315ded1258d0
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 12 23:47:55 2019 +0000

    Add component stacks to (almost) all warnings (#17586)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 77e6183935..c9fbde50c7 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -44,7 +44,7 @@ import {
 
 import {createContainer, updateContainer} from 'react-reconciler/inline.dom';
 import invariant from 'shared/invariant';
-import warningWithoutStack from 'shared/warningWithoutStack';
+import warning from 'shared/warning';
 import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
 
 function ReactDOMRoot(container: DOMContainer, options: void | RootOptions) {
@@ -157,7 +157,7 @@ export function warnOnInvalidCallback(
 ): void {
   if (__DEV__) {
     if (callback !== null && typeof callback !== 'function') {
-      warningWithoutStack(
+      warning(
         '%s(...): Expected the last optional `callback` argument to be a ' +
           'function. Instead received: %s.',
         callerName,
@@ -171,12 +171,12 @@ function warnIfReactDOMContainerInDEV(container) {
   if (__DEV__) {
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
-        warningWithoutStack(
+        warning(
           'You are calling ReactDOM.createRoot() on a container that was previously ' +
             'passed to ReactDOM.render(). This is not supported.',
         );
       } else {
-        warningWithoutStack(
+        warning(
           'You are calling ReactDOM.createRoot() on a container that ' +
             'has already been passed to createRoot() before. Instead, call ' +
             'root.render() on the existing root instead if you want to update it.',

commit 0cf22a56a18790ef34c71bef14f64695c0498619
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat Dec 14 18:09:25 2019 +0000

    Use console directly instead of warning() modules (#17599)
    
    * Replace all warning/lowPriWarning with console calls
    
    * Replace console.warn/error with a custom wrapper at build time
    
    * Fail the build for console.error/warn() where we can't read the stack

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index c9fbde50c7..4719b1fe2d 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -44,7 +44,6 @@ import {
 
 import {createContainer, updateContainer} from 'react-reconciler/inline.dom';
 import invariant from 'shared/invariant';
-import warning from 'shared/warning';
 import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
 
 function ReactDOMRoot(container: DOMContainer, options: void | RootOptions) {
@@ -157,7 +156,7 @@ export function warnOnInvalidCallback(
 ): void {
   if (__DEV__) {
     if (callback !== null && typeof callback !== 'function') {
-      warning(
+      console.error(
         '%s(...): Expected the last optional `callback` argument to be a ' +
           'function. Instead received: %s.',
         callerName,
@@ -171,12 +170,12 @@ function warnIfReactDOMContainerInDEV(container) {
   if (__DEV__) {
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
-        warning(
+        console.error(
           'You are calling ReactDOM.createRoot() on a container that was previously ' +
             'passed to ReactDOM.render(). This is not supported.',
         );
       } else {
-        warning(
+        console.error(
           'You are calling ReactDOM.createRoot() on a container that ' +
             'has already been passed to createRoot() before. Instead, call ' +
             'root.render() on the existing root instead if you want to update it.',

commit e706721490e50d0bd6af2cd933dbf857fd8b61ed
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 14:50:44 2020 +0000

    Update Flow to 0.84 (#17805)
    
    * Update Flow to 0.84
    
    * Fix violations
    
    * Use inexact object syntax in files from fbsource
    
    * Fix warning extraction to use a modern parser
    
    * Codemod inexact objects to new syntax
    
    * Tighten types that can be exact
    
    * Revert unintentional formatting changes from codemod

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 4719b1fe2d..b11430b8b3 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -17,8 +17,8 @@ import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
 export type RootType = {
   render(children: ReactNodeList, callback: ?() => mixed): void,
   unmount(callback: ?() => mixed): void,
-
   _internalRoot: FiberRoot,
+  ...
 };
 
 export type RootOptions = {
@@ -26,7 +26,9 @@ export type RootOptions = {
   hydrationOptions?: {
     onHydrated?: (suspenseNode: Comment) => void,
     onDeleted?: (suspenseNode: Comment) => void,
+    ...
   },
+  ...
 };
 
 import {

commit e26682a9f3889439765942f1510f280466c3433a
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Jan 27 12:35:08 2020 -0800

    Removed Root API callback params and added warnings (#17916)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index b11430b8b3..62834dbde2 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -15,8 +15,8 @@ import type {ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
 
 export type RootType = {
-  render(children: ReactNodeList, callback: ?() => mixed): void,
-  unmount(callback: ?() => mixed): void,
+  render(children: ReactNodeList): void,
+  unmount(): void,
   _internalRoot: FiberRoot,
   ...
 };
@@ -62,30 +62,32 @@ function ReactDOMBlockingRoot(
 
 ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
   children: ReactNodeList,
-  callback: ?() => mixed,
 ): void {
-  const root = this._internalRoot;
-  const cb = callback === undefined ? null : callback;
   if (__DEV__) {
-    warnOnInvalidCallback(cb, 'render');
+    if (typeof arguments[1] === 'function') {
+      console.error(
+        'render(...): does not support the second callback argument. ' +
+          'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      );
+    }
   }
-  updateContainer(children, root, null, cb);
+  const root = this._internalRoot;
+  updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(
-  callback: ?() => mixed,
-): void {
-  const root = this._internalRoot;
-  const cb = callback === undefined ? null : callback;
+ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(): void {
   if (__DEV__) {
-    warnOnInvalidCallback(cb, 'render');
+    if (typeof arguments[0] === 'function') {
+      console.error(
+        'unmount(...): does not support a callback argument. ' +
+          'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      );
+    }
   }
+  const root = this._internalRoot;
   const container = root.containerInfo;
   updateContainer(null, root, null, () => {
     unmarkContainerAsRoot(container);
-    if (cb !== null) {
-      cb();
-    }
   });
 };
 
@@ -152,22 +154,6 @@ export function isValidContainer(node: mixed): boolean {
   );
 }
 
-export function warnOnInvalidCallback(
-  callback: mixed,
-  callerName: string,
-): void {
-  if (__DEV__) {
-    if (callback !== null && typeof callback !== 'function') {
-      console.error(
-        '%s(...): Expected the last optional `callback` argument to be a ' +
-          'function. Instead received: %s.',
-        callerName,
-        callback,
-      );
-    }
-  }
-}
-
 function warnIfReactDOMContainerInDEV(container) {
   if (__DEV__) {
     if (isContainerMarkedAsRoot(container)) {

commit 1662035852519983955c8c3bdab72a0c60b1264b
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Jan 30 17:17:42 2020 +0000

    Ensure createRoot warning parity with ReactDOM.render (#17937)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 62834dbde2..f9282e919c 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,6 +13,7 @@ import type {ReactNodeList} from 'shared/ReactTypes';
 // TODO: This type is shared between the reconciler and ReactDOM, but will
 // eventually be lifted out to the renderer.
 import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
+import {findHostInstanceWithNoPortals} from 'react-reconciler/inline.dom';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -63,6 +64,7 @@ function ReactDOMBlockingRoot(
 ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
+  const root = this._internalRoot;
   if (__DEV__) {
     if (typeof arguments[1] === 'function') {
       console.error(
@@ -70,8 +72,22 @@ ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function
           'To execute a side effect after rendering, declare it in a component body with useEffect().',
       );
     }
+    const container = root.containerInfo;
+
+    if (container.nodeType !== COMMENT_NODE) {
+      const hostInstance = findHostInstanceWithNoPortals(root.current);
+      if (hostInstance) {
+        if (hostInstance.parentNode !== container) {
+          console.error(
+            'render(...): It looks like the React-rendered content of the ' +
+              'root container was removed without using React. This is not ' +
+              'supported and will cause errors. Instead, call ' +
+              "root.unmount() to empty a root's container.",
+          );
+        }
+      }
+    }
   }
-  const root = this._internalRoot;
   updateContainer(children, root, null, null);
 };
 
@@ -156,6 +172,19 @@ export function isValidContainer(node: mixed): boolean {
 
 function warnIfReactDOMContainerInDEV(container) {
   if (__DEV__) {
+    if (
+      container.nodeType === ELEMENT_NODE &&
+      ((container: any): Element).tagName &&
+      ((container: any): Element).tagName.toUpperCase() === 'BODY'
+    ) {
+      console.error(
+        'createRoot(): Creating roots directly with document.body is ' +
+          'discouraged, since its children are often manipulated by third-party ' +
+          'scripts and browser extensions. This may lead to subtle ' +
+          'reconciliation issues. Try using a container element created ' +
+          'for your app.',
+      );
+    }
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
         console.error(

commit 3f85d53ca6f2af8a711daae6322e6bdda862f660
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Feb 20 00:46:03 2020 +0000

    Further pre-requisite changes to plugin event system (#18083)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index f9282e919c..da256457e0 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -123,7 +123,7 @@ function createRootImpl(
       container.nodeType === DOCUMENT_NODE
         ? container
         : container.ownerDocument;
-    eagerlyTrapReplayableEvents(doc);
+    eagerlyTrapReplayableEvents(container, doc);
   }
   return root;
 }

commit ccab49473897aacae43bb4d55c1061065892403c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Feb 24 08:57:49 2020 -0800

    Move type DOMContainer to HostConfig (#18112)
    
    Exports from ReactDOM represents React's public API. This include types
    exported by React. At some point we'll start building Flow types from
    these files.
    
    The duplicate name between DOMContainer and Container seems confusing too
    since it was used in the same files even though they're the same.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index da256457e0..7cbbbbd939 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -7,7 +7,7 @@
  * @flow
  */
 
-import type {DOMContainer} from './ReactDOM';
+import type {Container} from './ReactDOMHostConfig';
 import type {RootTag} from 'shared/ReactRootTags';
 import type {ReactNodeList} from 'shared/ReactTypes';
 // TODO: This type is shared between the reconciler and ReactDOM, but will
@@ -49,12 +49,12 @@ import {createContainer, updateContainer} from 'react-reconciler/inline.dom';
 import invariant from 'shared/invariant';
 import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
 
-function ReactDOMRoot(container: DOMContainer, options: void | RootOptions) {
+function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
 
 function ReactDOMBlockingRoot(
-  container: DOMContainer,
+  container: Container,
   tag: RootTag,
   options: void | RootOptions,
 ) {
@@ -108,7 +108,7 @@ ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = functi
 };
 
 function createRootImpl(
-  container: DOMContainer,
+  container: Container,
   tag: RootTag,
   options: void | RootOptions,
 ) {
@@ -129,7 +129,7 @@ function createRootImpl(
 }
 
 export function createRoot(
-  container: DOMContainer,
+  container: Container,
   options?: RootOptions,
 ): RootType {
   invariant(
@@ -141,7 +141,7 @@ export function createRoot(
 }
 
 export function createBlockingRoot(
-  container: DOMContainer,
+  container: Container,
   options?: RootOptions,
 ): RootType {
   invariant(
@@ -153,7 +153,7 @@ export function createBlockingRoot(
 }
 
 export function createLegacyRoot(
-  container: DOMContainer,
+  container: Container,
   options?: RootOptions,
 ): RootType {
   return new ReactDOMBlockingRoot(container, LegacyRoot, options);

commit 7a1691cdff209249b49a4472ba87b542980a5f71
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Mar 6 16:20:42 2020 -0800

    Refactor Host Config Infra (getting rid of .inline*.js) (#18240)
    
    * Require deep for reconcilers
    
    * Delete inline* files
    
    * Delete react-reconciler/persistent
    
    This no longer makes any sense because it react-reconciler takes
    supportsMutation or supportsPersistence as options. It's no longer based
    on feature flags.
    
    * Fix jest mocking
    
    * Fix Flow strategy
    
    We now explicitly list which paths we want to be checked by a renderer.
    For every other renderer config we ignore those paths.
    
    Nothing is "any" typed. So if some transitive dependency isn't reachable
    it won't be accidentally "any" that leaks.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 7cbbbbd939..62cd9fcef0 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,7 +13,7 @@ import type {ReactNodeList} from 'shared/ReactTypes';
 // TODO: This type is shared between the reconciler and ReactDOM, but will
 // eventually be lifted out to the renderer.
 import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
-import {findHostInstanceWithNoPortals} from 'react-reconciler/inline.dom';
+import {findHostInstanceWithNoPortals} from 'react-reconciler/src/ReactFiberReconciler';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -45,7 +45,10 @@ import {
   DOCUMENT_FRAGMENT_NODE,
 } from '../shared/HTMLNodeType';
 
-import {createContainer, updateContainer} from 'react-reconciler/inline.dom';
+import {
+  createContainer,
+  updateContainer,
+} from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
 

commit c5d2fc7127654e43de59fff865b74765a103c4a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 21 15:22:01 2020 -0700

    Move some files out of /shared and rename to upper case (#18363)
    
    * Rename lower case isomorphic default exports modules to upper case named exports
    
    We're somewhat inconsistent here between e.g. ReactLazy and memo.
    
    Let's pick one.
    
    This also moves the responder, fundamental, scope creators from shared
    since they're isomorphic and same as the other creators.
    
    * Move some files that are specific to the react-reconciler from shared
    
    Individual renderers are allowed to deep require into the reconciler.
    
    * Move files specific to react-dom from shared
    
    react-interactions is right now dom specific (it wasn't before) so we can
    type check it together with other dom stuff. Avoids the need for
    a shared ReactDOMTypes to be checked by RN for example.
    
    * Move ReactWorkTags to the reconciler
    
    * Move createPortal to export from reconciler
    
    Otherwise Noop can't access it since it's not allowed deep requires.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 62cd9fcef0..a73f51daee 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -8,7 +8,7 @@
  */
 
 import type {Container} from './ReactDOMHostConfig';
-import type {RootTag} from 'shared/ReactRootTags';
+import type {RootTag} from 'react-reconciler/src/ReactRootTags';
 import type {ReactNodeList} from 'shared/ReactTypes';
 // TODO: This type is shared between the reconciler and ReactDOM, but will
 // eventually be lifted out to the renderer.
@@ -50,7 +50,11 @@ import {
   updateContainer,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {BlockingRoot, ConcurrentRoot, LegacyRoot} from 'shared/ReactRootTags';
+import {
+  BlockingRoot,
+  ConcurrentRoot,
+  LegacyRoot,
+} from 'react-reconciler/src/ReactRootTags';
 
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);

commit d686f3f16a796025ce32cfb431b70eef6de1934e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 19:44:52 2020 -0700

    Add `.old` prefix to reconciler modules

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index a73f51daee..41f487b57a 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -12,7 +12,7 @@ import type {RootTag} from 'react-reconciler/src/ReactRootTags';
 import type {ReactNodeList} from 'shared/ReactTypes';
 // TODO: This type is shared between the reconciler and ReactDOM, but will
 // eventually be lifted out to the renderer.
-import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';
+import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot.old';
 import {findHostInstanceWithNoPortals} from 'react-reconciler/src/ReactFiberReconciler';
 
 export type RootType = {

commit 376d5c1b5aa17724c5fea9412f8fcde14a7b23f1
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 23:48:24 2020 -0700

    Split cross-package types from implementation
    
    Some of our internal reconciler types have leaked into other packages.
    Usually, these types are treated as opaque; we don't read and write
    to its fields. This is good.
    
    However, the type is often passed back to a reconciler method. For
    example, React DOM creates a FiberRoot with `createContainer`, then
    passes that root to `updateContainer`. It doesn't do anything with the
    root except pass it through, but because `updateContainer` expects a
    full FiberRoot, React DOM is still coupled to all its fields.
    
    I don't know if there's an idiomatic way to handle this in Flow. Opaque
    types are simlar, but those only work within a single file. AFAIK,
    there's no way to use a package as the boundary for opaqueness.
    
    The immediate problem this presents is that the reconciler refactor will
    involve changes to our internal data structures. I don't want to have to
    fork every single package that happens to pass through a Fiber or
    FiberRoot, or access any one of its fields. So my current plan is to
    share the same Flow type across both forks. The shared type will be a
    superset of each implementation's type, e.g. Fiber will have both an
    `expirationTime` field and a `lanes` field. The implementations will
    diverge, but not the types.
    
    To do this, I lifted the type definitions into a separate module.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 41f487b57a..12a73a83eb 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -10,9 +10,7 @@
 import type {Container} from './ReactDOMHostConfig';
 import type {RootTag} from 'react-reconciler/src/ReactRootTags';
 import type {ReactNodeList} from 'shared/ReactTypes';
-// TODO: This type is shared between the reconciler and ReactDOM, but will
-// eventually be lifted out to the renderer.
-import type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot.old';
+import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 import {findHostInstanceWithNoPortals} from 'react-reconciler/src/ReactFiberReconciler';
 
 export type RootType = {

commit 823dc581fea8814a904579e85a62da6d18258830
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue May 5 22:10:07 2020 +0100

    Modern Event System: fix EnterLeave plugin logic (#18830)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 12a73a83eb..3c29c2e86a 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -42,6 +42,7 @@ import {
   DOCUMENT_NODE,
   DOCUMENT_FRAGMENT_NODE,
 } from '../shared/HTMLNodeType';
+import {ensureListeningTo} from './ReactDOMComponent';
 
 import {
   createContainer,
@@ -54,6 +55,8 @@ import {
   LegacyRoot,
 } from 'react-reconciler/src/ReactRootTags';
 
+import {enableModernEventSystem} from 'shared/ReactFeatureFlags';
+
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
@@ -123,12 +126,22 @@ function createRootImpl(
     (options != null && options.hydrationOptions) || null;
   const root = createContainer(container, tag, hydrate, hydrationCallbacks);
   markContainerAsRoot(root.current, container);
+  const containerNodeType = container.nodeType;
+
   if (hydrate && tag !== LegacyRoot) {
     const doc =
-      container.nodeType === DOCUMENT_NODE
-        ? container
-        : container.ownerDocument;
-    eagerlyTrapReplayableEvents(container, doc);
+      containerNodeType === DOCUMENT_NODE ? container : container.ownerDocument;
+    // We need to cast this because Flow doesn't work
+    // with the hoisted containerNodeType. If we inline
+    // it, then Flow doesn't complain. We intentionally
+    // hoist it to reduce code-size.
+    eagerlyTrapReplayableEvents(container, ((doc: any): Document));
+  } else if (
+    enableModernEventSystem &&
+    containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
+    containerNodeType !== DOCUMENT_NODE
+  ) {
+    ensureListeningTo(container, 'onMouseEnter');
   }
   return root;
 }

commit 142d4f1c00c66f3d728177082dbc027fd6335115
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu May 21 16:00:46 2020 -0700

    useMutableSource hydration support (#18771)
    
    * useMutableSource hydration support
    
    * Remove unnecessary ReactMutableSource fork
    
    * Replaced root.registerMutableSourceForHydration() with mutableSources option
    
    * Response to PR feedback:
    
    1. Moved mutableSources root option to hydrationOptions object
    2. Only initialize root mutableSourceEagerHydrationData if supportsHydration config is true
    3. Lazily initialize mutableSourceEagerHydrationData on root object

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 3c29c2e86a..549f7c3e60 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -9,9 +9,8 @@
 
 import type {Container} from './ReactDOMHostConfig';
 import type {RootTag} from 'react-reconciler/src/ReactRootTags';
-import type {ReactNodeList} from 'shared/ReactTypes';
+import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
-import {findHostInstanceWithNoPortals} from 'react-reconciler/src/ReactFiberReconciler';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -25,6 +24,7 @@ export type RootOptions = {
   hydrationOptions?: {
     onHydrated?: (suspenseNode: Comment) => void,
     onDeleted?: (suspenseNode: Comment) => void,
+    mutableSources?: Array<MutableSource<any>>,
     ...
   },
   ...
@@ -47,6 +47,8 @@ import {ensureListeningTo} from './ReactDOMComponent';
 import {
   createContainer,
   updateContainer,
+  findHostInstanceWithNoPortals,
+  registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {
@@ -124,6 +126,11 @@ function createRootImpl(
   const hydrate = options != null && options.hydrate === true;
   const hydrationCallbacks =
     (options != null && options.hydrationOptions) || null;
+  const mutableSources =
+    (options != null &&
+      options.hydrationOptions != null &&
+      options.hydrationOptions.mutableSources) ||
+    null;
   const root = createContainer(container, tag, hydrate, hydrationCallbacks);
   markContainerAsRoot(root.current, container);
   const containerNodeType = container.nodeType;
@@ -143,6 +150,14 @@ function createRootImpl(
   ) {
     ensureListeningTo(container, 'onMouseEnter');
   }
+
+  if (mutableSources) {
+    for (let i = 0; i < mutableSources.length; i++) {
+      const mutableSource = mutableSources[i];
+      registerMutableSourceForHydration(root, mutableSource);
+    }
+  }
+
   return root;
 }
 

commit 9fba65efa50fe5f38e5664729d4aa6f85cf7be92
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Jul 1 17:43:34 2020 +0100

    Enable modern event system and delete dead code (#19230)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 549f7c3e60..31a869ba2d 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -57,8 +57,6 @@ import {
   LegacyRoot,
 } from 'react-reconciler/src/ReactRootTags';
 
-import {enableModernEventSystem} from 'shared/ReactFeatureFlags';
-
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
@@ -144,7 +142,6 @@ function createRootImpl(
     // hoist it to reduce code-size.
     eagerlyTrapReplayableEvents(container, ((doc: any): Document));
   } else if (
-    enableModernEventSystem &&
     containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
     containerNodeType !== DOCUMENT_NODE
   ) {

commit 356c17108f4e132371450338fa86e195f5e0acf4
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Jul 21 22:40:50 2020 +0100

    Remove capturePhaseEvents and separate events by bubbling (#19278)
    
    * Remove capturePhaseEvents and separate events by bubbling
    
    WIP
    
    Refine all logic
    
    Revise types
    
    Fix
    
    Fix conflicts
    
    Fix flags
    
    Fix
    
    Fix
    
    Fix test
    
    Revise
    
    Cleanup
    
    Refine
    
    Deal with replaying
    
    Fix
    
    * Add non delegated listeners unconditionally
    
    * Add media events
    
    * Fix a previously ignored test
    
    * Address feedback
    
    Co-authored-by: Dan Abramov <dan.abramov@me.com>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 31a869ba2d..d9e446749c 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -145,7 +145,7 @@ function createRootImpl(
     containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
     containerNodeType !== DOCUMENT_NODE
   ) {
-    ensureListeningTo(container, 'onMouseEnter');
+    ensureListeningTo(container, 'onMouseEnter', null);
   }
 
   if (mutableSources) {

commit 848bb2426e44606e0a55dfe44c7b3ece33772485
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Aug 24 16:50:20 2020 +0100

    Attach Listeners Eagerly to Roots and Portal Containers (#19659)
    
    * Failing test for #19608
    
    * Attach Listeners Eagerly to Roots and Portal Containers
    
    * Forbid createEventHandle with custom events
    
    We can't support this without adding more complexity. It's not clear that this is even desirable, as none of our existing use cases need custom events. This API primarily exists as a deprecation strategy for Flare, so I don't think it is important to expand its support beyond what Flare replacement code currently needs. We can later revisit it with a better understanding of the eager/lazy tradeoff but for now let's remove the inconsistency.
    
    * Reduce risk by changing condition only under the flag
    
    Co-authored-by: koba04 <koba0004@gmail.com>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index d9e446749c..11ec850a4a 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -35,6 +35,7 @@ import {
   markContainerAsRoot,
   unmarkContainerAsRoot,
 } from './ReactDOMComponentTree';
+import {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';
 import {eagerlyTrapReplayableEvents} from '../events/ReactDOMEventReplaying';
 import {
   ELEMENT_NODE,
@@ -51,6 +52,7 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
+import {enableEagerRootListeners} from 'shared/ReactFeatureFlags';
 import {
   BlockingRoot,
   ConcurrentRoot,
@@ -133,19 +135,27 @@ function createRootImpl(
   markContainerAsRoot(root.current, container);
   const containerNodeType = container.nodeType;
 
-  if (hydrate && tag !== LegacyRoot) {
-    const doc =
-      containerNodeType === DOCUMENT_NODE ? container : container.ownerDocument;
-    // We need to cast this because Flow doesn't work
-    // with the hoisted containerNodeType. If we inline
-    // it, then Flow doesn't complain. We intentionally
-    // hoist it to reduce code-size.
-    eagerlyTrapReplayableEvents(container, ((doc: any): Document));
-  } else if (
-    containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
-    containerNodeType !== DOCUMENT_NODE
-  ) {
-    ensureListeningTo(container, 'onMouseEnter', null);
+  if (enableEagerRootListeners) {
+    const rootContainerElement =
+      container.nodeType === COMMENT_NODE ? container.parentNode : container;
+    listenToAllSupportedEvents(rootContainerElement);
+  } else {
+    if (hydrate && tag !== LegacyRoot) {
+      const doc =
+        containerNodeType === DOCUMENT_NODE
+          ? container
+          : container.ownerDocument;
+      // We need to cast this because Flow doesn't work
+      // with the hoisted containerNodeType. If we inline
+      // it, then Flow doesn't complain. We intentionally
+      // hoist it to reduce code-size.
+      eagerlyTrapReplayableEvents(container, ((doc: any): Document));
+    } else if (
+      containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
+      containerNodeType !== DOCUMENT_NODE
+    ) {
+      ensureListeningTo(container, 'onMouseEnter', null);
+    }
   }
 
   if (mutableSources) {

commit 993ca533b42756811731f6b7791ae06a35ee6b4d
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 8 19:32:28 2020 +0100

    Enable eager listeners statically (#19983)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 11ec850a4a..66a3132854 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -36,14 +36,12 @@ import {
   unmarkContainerAsRoot,
 } from './ReactDOMComponentTree';
 import {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';
-import {eagerlyTrapReplayableEvents} from '../events/ReactDOMEventReplaying';
 import {
   ELEMENT_NODE,
   COMMENT_NODE,
   DOCUMENT_NODE,
   DOCUMENT_FRAGMENT_NODE,
 } from '../shared/HTMLNodeType';
-import {ensureListeningTo} from './ReactDOMComponent';
 
 import {
   createContainer,
@@ -52,7 +50,6 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {enableEagerRootListeners} from 'shared/ReactFeatureFlags';
 import {
   BlockingRoot,
   ConcurrentRoot,
@@ -133,30 +130,10 @@ function createRootImpl(
     null;
   const root = createContainer(container, tag, hydrate, hydrationCallbacks);
   markContainerAsRoot(root.current, container);
-  const containerNodeType = container.nodeType;
-
-  if (enableEagerRootListeners) {
-    const rootContainerElement =
-      container.nodeType === COMMENT_NODE ? container.parentNode : container;
-    listenToAllSupportedEvents(rootContainerElement);
-  } else {
-    if (hydrate && tag !== LegacyRoot) {
-      const doc =
-        containerNodeType === DOCUMENT_NODE
-          ? container
-          : container.ownerDocument;
-      // We need to cast this because Flow doesn't work
-      // with the hoisted containerNodeType. If we inline
-      // it, then Flow doesn't complain. We intentionally
-      // hoist it to reduce code-size.
-      eagerlyTrapReplayableEvents(container, ((doc: any): Document));
-    } else if (
-      containerNodeType !== DOCUMENT_FRAGMENT_NODE &&
-      containerNodeType !== DOCUMENT_NODE
-    ) {
-      ensureListeningTo(container, 'onMouseEnter', null);
-    }
-  }
+
+  const rootContainerElement =
+    container.nodeType === COMMENT_NODE ? container.parentNode : container;
+  listenToAllSupportedEvents(rootContainerElement);
 
   if (mutableSources) {
     for (let i = 0; i < mutableSources.length; i++) {

commit 9209c30ff98528cfbbe9df0774fda0b117975a25
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed Feb 24 16:14:14 2021 -0500

    Add StrictMode level prop and createRoot unstable_strictModeLevel option (#20849)
    
    * The exported '<React.StrictMode>' tag remains the same and opts legacy subtrees into strict mode level one ('mode == StrictModeL1'). This mode enables DEV-only double rendering, double component lifecycles, string ref warnings, legacy context warnings, etc. The primary purpose of this mode is to help detected render phase side effects. No new behavior. Roots created with experimental 'createRoot' and 'createBlockingRoot' APIs will also (for now) continue to default to strict mode level 1.
    
    In a subsequent commit I will add support for a 'level' attribute on the '<React.StrictMode>' tag (as well as a new option supported by ). This will be the way to opt into strict mode level 2 ('mode == StrictModeL2'). This mode will enable DEV-only double invoking of effects on initial mount. This will simulate future Offscreen API semantics for trees being mounted, then hidden, and then shown again. The primary purpose of this mode is to enable applications to prepare for compatibility with the new Offscreen API (more information to follow shortly).
    
    For now, this commit changes no public facing behavior. The only mechanism for opting into strict mode level 2 is the pre-existing 'enableDoubleInvokingEffects' feature flag (only enabled within Facebook for now).
    
    * Renamed strict mode constants
    
    StrictModeL1 -> StrictLegacyMode and StrictModeL2 -> StrictEffectsMode
    
    * Renamed tests
    
    * Split strict effects mode into two flags
    
    One flag ('enableStrictEffects') enables strict mode level 2. It is similar to 'debugRenderPhaseSideEffectsForStrictMode' which enables srtict mode level 1.
    
    The second flag ('createRootStrictEffectsByDefault') controls the default strict mode level for 'createRoot' trees. For now, all 'createRoot' trees remain level 1 by default. We will experiment with level 2 within Facebook.
    
    This is a prerequisite for adding a configurable option to 'createRoot' that enables choosing a different StrictMode level than the default.
    
    * Add StrictMode 'unstable_level' prop and createRoot 'unstable_strictModeLevel' option
    
    New StrictMode 'unstable_level' prop allows specifying which level of strict mode to use. If no level attribute is specified, StrictLegacyMode will be used to maintain backwards compatibility. Otherwise the following is true:
    * Level 0 does nothing
    * Level 1 selects StrictLegacyMode
    * Level 2 selects StrictEffectsMode (which includes StrictLegacyMode)
    
    Levels can be increased with nesting (0 -> 1 -> 2) but not decreased.
    
    This commit also adds a new 'unstable_strictModeLevel' option to the createRoot and createBatchedRoot APIs. This option can be used to override default behavior to increase or decrease the StrictMode level of the root.
    
    A subsequent commit will add additional DEV warnings:
    * If a nested StrictMode tag attempts to explicitly decrease the level
    * If a level attribute changes in an update

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 66a3132854..62a72dc229 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -27,6 +27,7 @@ export type RootOptions = {
     mutableSources?: Array<MutableSource<any>>,
     ...
   },
+  unstable_strictModeLevel?: number,
   ...
 };
 
@@ -128,7 +129,18 @@ function createRootImpl(
       options.hydrationOptions != null &&
       options.hydrationOptions.mutableSources) ||
     null;
-  const root = createContainer(container, tag, hydrate, hydrationCallbacks);
+  const strictModeLevelOverride =
+    options != null && options.unstable_strictModeLevel != null
+      ? options.unstable_strictModeLevel
+      : null;
+
+  const root = createContainer(
+    container,
+    tag,
+    hydrate,
+    hydrationCallbacks,
+    strictModeLevelOverride,
+  );
   markContainerAsRoot(root.current, container);
 
   const rootContainerElement =

commit 553440bd1578ef71982c4a10e2cc8c462f33d9be
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Feb 28 01:14:54 2021 -0500

    Remove blocking mode and blocking root (#20888)
    
    * Remove blocking mode and blocking root
    
    * Add back SuspenseList test
    
    * Clean up ReactDOMLegacyRoot
    
    * Remove dupe ConcurrentRoot
    
    * Update comment

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 62a72dc229..56532d5d67 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -51,25 +51,17 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {
-  BlockingRoot,
-  ConcurrentRoot,
-  LegacyRoot,
-} from 'react-reconciler/src/ReactRootTags';
+import {ConcurrentRoot, LegacyRoot} from 'react-reconciler/src/ReactRootTags';
 
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
 
-function ReactDOMBlockingRoot(
-  container: Container,
-  tag: RootTag,
-  options: void | RootOptions,
-) {
-  this._internalRoot = createRootImpl(container, tag, options);
+function ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {
+  this._internalRoot = createRootImpl(container, LegacyRoot, options);
 }
 
-ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
+ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
   const root = this._internalRoot;
@@ -99,7 +91,7 @@ ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function
   updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(): void {
+ReactDOMRoot.prototype.unmount = ReactDOMLegacyRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
       console.error(
@@ -169,23 +161,11 @@ export function createRoot(
   return new ReactDOMRoot(container, options);
 }
 
-export function createBlockingRoot(
-  container: Container,
-  options?: RootOptions,
-): RootType {
-  invariant(
-    isValidContainer(container),
-    'createRoot(...): Target container is not a DOM element.',
-  );
-  warnIfReactDOMContainerInDEV(container);
-  return new ReactDOMBlockingRoot(container, BlockingRoot, options);
-}
-
 export function createLegacyRoot(
   container: Container,
   options?: RootOptions,
 ): RootType {
-  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
+  return new ReactDOMLegacyRoot(container, options);
 }
 
 export function isValidContainer(node: mixed): boolean {

commit ee432635724d5a50301448016caa137ac3c0a7a2
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 2 14:51:18 2021 -0600

    Revert "Remove blocking mode and blocking root (#20888)" (#20916)
    
    This reverts commit 553440bd1578ef71982c4a10e2cc8c462f33d9be.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 56532d5d67..62a72dc229 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -51,17 +51,25 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {ConcurrentRoot, LegacyRoot} from 'react-reconciler/src/ReactRootTags';
+import {
+  BlockingRoot,
+  ConcurrentRoot,
+  LegacyRoot,
+} from 'react-reconciler/src/ReactRootTags';
 
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
 
-function ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {
-  this._internalRoot = createRootImpl(container, LegacyRoot, options);
+function ReactDOMBlockingRoot(
+  container: Container,
+  tag: RootTag,
+  options: void | RootOptions,
+) {
+  this._internalRoot = createRootImpl(container, tag, options);
 }
 
-ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
+ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
   const root = this._internalRoot;
@@ -91,7 +99,7 @@ ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
   updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = ReactDOMLegacyRoot.prototype.unmount = function(): void {
+ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
       console.error(
@@ -161,11 +169,23 @@ export function createRoot(
   return new ReactDOMRoot(container, options);
 }
 
+export function createBlockingRoot(
+  container: Container,
+  options?: RootOptions,
+): RootType {
+  invariant(
+    isValidContainer(container),
+    'createRoot(...): Target container is not a DOM element.',
+  );
+  warnIfReactDOMContainerInDEV(container);
+  return new ReactDOMBlockingRoot(container, BlockingRoot, options);
+}
+
 export function createLegacyRoot(
   container: Container,
   options?: RootOptions,
 ): RootType {
-  return new ReactDOMLegacyRoot(container, options);
+  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
 }
 
 export function isValidContainer(node: mixed): boolean {

commit 860f673a7a6bf826010d41de2f66de62171ab676
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Mar 10 18:34:35 2021 -0500

    Remove Blocking Mode (again) (#20974)
    
    * Remove Blocking Mode (again)
    
    * Rename batchingmode file and comment

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 62a72dc229..56532d5d67 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -51,25 +51,17 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {
-  BlockingRoot,
-  ConcurrentRoot,
-  LegacyRoot,
-} from 'react-reconciler/src/ReactRootTags';
+import {ConcurrentRoot, LegacyRoot} from 'react-reconciler/src/ReactRootTags';
 
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
 }
 
-function ReactDOMBlockingRoot(
-  container: Container,
-  tag: RootTag,
-  options: void | RootOptions,
-) {
-  this._internalRoot = createRootImpl(container, tag, options);
+function ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {
+  this._internalRoot = createRootImpl(container, LegacyRoot, options);
 }
 
-ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(
+ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
   const root = this._internalRoot;
@@ -99,7 +91,7 @@ ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function
   updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function(): void {
+ReactDOMRoot.prototype.unmount = ReactDOMLegacyRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
       console.error(
@@ -169,23 +161,11 @@ export function createRoot(
   return new ReactDOMRoot(container, options);
 }
 
-export function createBlockingRoot(
-  container: Container,
-  options?: RootOptions,
-): RootType {
-  invariant(
-    isValidContainer(container),
-    'createRoot(...): Target container is not a DOM element.',
-  );
-  warnIfReactDOMContainerInDEV(container);
-  return new ReactDOMBlockingRoot(container, BlockingRoot, options);
-}
-
 export function createLegacyRoot(
   container: Container,
   options?: RootOptions,
 ): RootType {
-  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
+  return new ReactDOMLegacyRoot(container, options);
 }
 
 export function isValidContainer(node: mixed): boolean {

commit 9e9dac650535406b25979758a630a78b7c68a22c
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 28 16:09:30 2021 -0400

    Add unstable_concurrentUpdatesByDefault (#21227)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 56532d5d67..0a78f61ad0 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -28,6 +28,7 @@ export type RootOptions = {
     ...
   },
   unstable_strictModeLevel?: number,
+  unstable_concurrentUpdatesByDefault?: boolean,
   ...
 };
 
@@ -52,6 +53,7 @@ import {
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {ConcurrentRoot, LegacyRoot} from 'react-reconciler/src/ReactRootTags';
+import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
 
 function ReactDOMRoot(container: Container, options: void | RootOptions) {
   this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
@@ -126,12 +128,21 @@ function createRootImpl(
       ? options.unstable_strictModeLevel
       : null;
 
+  let concurrentUpdatesByDefaultOverride = null;
+  if (allowConcurrentByDefault) {
+    concurrentUpdatesByDefaultOverride =
+      options != null && options.unstable_concurrentUpdatesByDefault != null
+        ? options.unstable_concurrentUpdatesByDefault
+        : null;
+  }
+
   const root = createContainer(
     container,
     tag,
     hydrate,
     hydrationCallbacks,
     strictModeLevelOverride,
+    concurrentUpdatesByDefaultOverride,
   );
   markContainerAsRoot(root.current, container);
 

commit 15fb8c3045064e13e81706a36bf0e4e419803c97
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon May 3 16:57:03 2021 -0400

    createRoot API is no longer strict by default (#21417)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 0a78f61ad0..73e96eb086 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -27,7 +27,6 @@ export type RootOptions = {
     mutableSources?: Array<MutableSource<any>>,
     ...
   },
-  unstable_strictModeLevel?: number,
   unstable_concurrentUpdatesByDefault?: boolean,
   ...
 };
@@ -123,10 +122,6 @@ function createRootImpl(
       options.hydrationOptions != null &&
       options.hydrationOptions.mutableSources) ||
     null;
-  const strictModeLevelOverride =
-    options != null && options.unstable_strictModeLevel != null
-      ? options.unstable_strictModeLevel
-      : null;
 
   let concurrentUpdatesByDefaultOverride = null;
   if (allowConcurrentByDefault) {
@@ -141,7 +136,6 @@ function createRootImpl(
     tag,
     hydrate,
     hydrationCallbacks,
-    strictModeLevelOverride,
     concurrentUpdatesByDefaultOverride,
   );
   markContainerAsRoot(root.current, container);

commit e9a4a44aae675e1b164cf2ae509e438c324d424a
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue May 4 15:42:48 2021 -0400

    Add back root override for strict mode (#21428)
    
    * Add back root override for strict mode
    
    * Switch flag to boolean
    
    * Fix flow

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 73e96eb086..dc4c95a41e 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -27,6 +27,7 @@ export type RootOptions = {
     mutableSources?: Array<MutableSource<any>>,
     ...
   },
+  unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   ...
 };
@@ -122,6 +123,7 @@ function createRootImpl(
       options.hydrationOptions != null &&
       options.hydrationOptions.mutableSources) ||
     null;
+  const isStrictMode = options != null && options.unstable_strictMode === true;
 
   let concurrentUpdatesByDefaultOverride = null;
   if (allowConcurrentByDefault) {
@@ -136,6 +138,7 @@ function createRootImpl(
     tag,
     hydrate,
     hydrationCallbacks,
+    isStrictMode,
     concurrentUpdatesByDefaultOverride,
   );
   markContainerAsRoot(root.current, container);

commit 7ec4c55971aad644616ca0b040f42410659fe802
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Jun 15 16:37:53 2021 -0400

    createRoot(..., {hydrate:true}) -> hydrateRoot(...) (#21687)
    
    This adds a new top level API for hydrating a root. It takes the initial
    children as part of its constructor. These are unlike other render calls
    in that they have to represent what the server sent and they can't be
    batched with other updates.
    
    I also changed the options to move the hydrationOptions to the top level
    since now these options are all hydration options.
    
    I kept the createRoot one just temporarily to make it easier to codemod
    internally but I'm doing a follow up to delete.
    
    As part of this I un-dried a couple of paths. ReactDOMLegacy was intended
    to be built on top of the new API but it didn't actually use those root
    APIs because there are special paths. It also doesn't actually use most of
    the commmon paths since all the options are ignored. It also made it hard
    to add only warnings for legacy only or new only code paths.
    
    I also forked the create/hydrate paths because they're subtly different
    since now the options are different. The containers are also different
    because I now error for comment nodes during hydration which just doesn't
    work at all but eventually we'll error for all createRoot calls.
    
    After some iteration it might make sense to break out some common paths but
    for now it's easier to iterate on the duplicates.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index dc4c95a41e..ba062fc3f7 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -8,7 +8,6 @@
  */
 
 import type {Container} from './ReactDOMHostConfig';
-import type {RootTag} from 'react-reconciler/src/ReactRootTags';
 import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 
@@ -19,7 +18,8 @@ export type RootType = {
   ...
 };
 
-export type RootOptions = {
+export type CreateRootOptions = {
+  // TODO: Remove these options.
   hydrate?: boolean,
   hydrationOptions?: {
     onHydrated?: (suspenseNode: Comment) => void,
@@ -27,6 +27,18 @@ export type RootOptions = {
     mutableSources?: Array<MutableSource<any>>,
     ...
   },
+  // END OF TODO
+  unstable_strictMode?: boolean,
+  unstable_concurrentUpdatesByDefault?: boolean,
+  ...
+};
+
+export type HydrateRootOptions = {
+  // Hydration options
+  hydratedSources?: Array<MutableSource<any>>,
+  onHydrated?: (suspenseNode: Comment) => void,
+  onDeleted?: (suspenseNode: Comment) => void,
+  // Options for all roots
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   ...
@@ -52,20 +64,14 @@ import {
   registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
-import {ConcurrentRoot, LegacyRoot} from 'react-reconciler/src/ReactRootTags';
+import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
 
-function ReactDOMRoot(container: Container, options: void | RootOptions) {
-  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
-}
-
-function ReactDOMLegacyRoot(container: Container, options: void | RootOptions) {
-  this._internalRoot = createRootImpl(container, LegacyRoot, options);
+function ReactDOMRoot(internalRoot) {
+  this._internalRoot = internalRoot;
 }
 
-ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
-  children: ReactNodeList,
-): void {
+ReactDOMRoot.prototype.render = function(children: ReactNodeList): void {
   const root = this._internalRoot;
   if (__DEV__) {
     if (typeof arguments[1] === 'function') {
@@ -93,7 +99,7 @@ ReactDOMRoot.prototype.render = ReactDOMLegacyRoot.prototype.render = function(
   updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = ReactDOMLegacyRoot.prototype.unmount = function(): void {
+ReactDOMRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
       console.error(
@@ -109,12 +115,17 @@ ReactDOMRoot.prototype.unmount = ReactDOMLegacyRoot.prototype.unmount = function
   });
 };
 
-function createRootImpl(
+export function createRoot(
   container: Container,
-  tag: RootTag,
-  options: void | RootOptions,
-) {
-  // Tag is either LegacyRoot or Concurrent Root
+  options?: CreateRootOptions,
+): RootType {
+  invariant(
+    isValidContainerLegacy(container),
+    'createRoot(...): Target container is not a DOM element.',
+  );
+  warnIfReactDOMContainerInDEV(container);
+
+  // TODO: Delete these options
   const hydrate = options != null && options.hydrate === true;
   const hydrationCallbacks =
     (options != null && options.hydrationOptions) || null;
@@ -123,8 +134,9 @@ function createRootImpl(
       options.hydrationOptions != null &&
       options.hydrationOptions.mutableSources) ||
     null;
-  const isStrictMode = options != null && options.unstable_strictMode === true;
+  // END TODO
 
+  const isStrictMode = options != null && options.unstable_strictMode === true;
   let concurrentUpdatesByDefaultOverride = null;
   if (allowConcurrentByDefault) {
     concurrentUpdatesByDefaultOverride =
@@ -135,7 +147,7 @@ function createRootImpl(
 
   const root = createContainer(
     container,
-    tag,
+    ConcurrentRoot,
     hydrate,
     hydrationCallbacks,
     isStrictMode,
@@ -147,36 +159,80 @@ function createRootImpl(
     container.nodeType === COMMENT_NODE ? container.parentNode : container;
   listenToAllSupportedEvents(rootContainerElement);
 
+  // TODO: Delete this path
   if (mutableSources) {
     for (let i = 0; i < mutableSources.length; i++) {
       const mutableSource = mutableSources[i];
       registerMutableSourceForHydration(root, mutableSource);
     }
   }
+  // END TODO
 
-  return root;
+  return new ReactDOMRoot(root);
 }
 
-export function createRoot(
+export function hydrateRoot(
   container: Container,
-  options?: RootOptions,
+  initialChildren: ReactNodeList,
+  options?: HydrateRootOptions,
 ): RootType {
   invariant(
     isValidContainer(container),
-    'createRoot(...): Target container is not a DOM element.',
+    'hydrateRoot(...): Target container is not a DOM element.',
   );
   warnIfReactDOMContainerInDEV(container);
-  return new ReactDOMRoot(container, options);
+
+  // For now we reuse the whole bag of options since they contain
+  // the hydration callbacks.
+  const hydrationCallbacks = options != null ? options : null;
+  const mutableSources = (options != null && options.hydratedSources) || null;
+  const isStrictMode = options != null && options.unstable_strictMode === true;
+
+  let concurrentUpdatesByDefaultOverride = null;
+  if (allowConcurrentByDefault) {
+    concurrentUpdatesByDefaultOverride =
+      options != null && options.unstable_concurrentUpdatesByDefault != null
+        ? options.unstable_concurrentUpdatesByDefault
+        : null;
+  }
+
+  const root = createContainer(
+    container,
+    ConcurrentRoot,
+    true, // hydrate
+    hydrationCallbacks,
+    isStrictMode,
+    concurrentUpdatesByDefaultOverride,
+  );
+  markContainerAsRoot(root.current, container);
+  // This can't be a comment node since hydration doesn't work on comment nodes anyway.
+  listenToAllSupportedEvents(container);
+
+  if (mutableSources) {
+    for (let i = 0; i < mutableSources.length; i++) {
+      const mutableSource = mutableSources[i];
+      registerMutableSourceForHydration(root, mutableSource);
+    }
+  }
+
+  // Render the initial children
+  updateContainer(initialChildren, root, null, null);
+
+  return new ReactDOMRoot(root);
 }
 
-export function createLegacyRoot(
-  container: Container,
-  options?: RootOptions,
-): RootType {
-  return new ReactDOMLegacyRoot(container, options);
+export function isValidContainer(node: any): boolean {
+  return !!(
+    node &&
+    (node.nodeType === ELEMENT_NODE ||
+      node.nodeType === DOCUMENT_NODE ||
+      node.nodeType === DOCUMENT_FRAGMENT_NODE)
+  );
 }
 
-export function isValidContainer(node: mixed): boolean {
+// TODO: Remove this function which also includes comment nodes.
+// We only use it in places that are currently more relaxed.
+export function isValidContainerLegacy(node: any): boolean {
   return !!(
     node &&
     (node.nodeType === ELEMENT_NODE ||

commit 8209de269531767b33d8db26eda41db38bfb6a27
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 20 00:11:50 2021 -0400

    Delete useMutableSource implementation (#22292)
    
    This API was replaced by useSyncExternalStore

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ba062fc3f7..3bde63dc67 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -8,7 +8,7 @@
  */
 
 import type {Container} from './ReactDOMHostConfig';
-import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
+import type {ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 
 export type RootType = {
@@ -24,7 +24,6 @@ export type CreateRootOptions = {
   hydrationOptions?: {
     onHydrated?: (suspenseNode: Comment) => void,
     onDeleted?: (suspenseNode: Comment) => void,
-    mutableSources?: Array<MutableSource<any>>,
     ...
   },
   // END OF TODO
@@ -35,7 +34,6 @@ export type CreateRootOptions = {
 
 export type HydrateRootOptions = {
   // Hydration options
-  hydratedSources?: Array<MutableSource<any>>,
   onHydrated?: (suspenseNode: Comment) => void,
   onDeleted?: (suspenseNode: Comment) => void,
   // Options for all roots
@@ -61,7 +59,6 @@ import {
   createContainer,
   updateContainer,
   findHostInstanceWithNoPortals,
-  registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
@@ -129,11 +126,6 @@ export function createRoot(
   const hydrate = options != null && options.hydrate === true;
   const hydrationCallbacks =
     (options != null && options.hydrationOptions) || null;
-  const mutableSources =
-    (options != null &&
-      options.hydrationOptions != null &&
-      options.hydrationOptions.mutableSources) ||
-    null;
   // END TODO
 
   const isStrictMode = options != null && options.unstable_strictMode === true;
@@ -159,15 +151,6 @@ export function createRoot(
     container.nodeType === COMMENT_NODE ? container.parentNode : container;
   listenToAllSupportedEvents(rootContainerElement);
 
-  // TODO: Delete this path
-  if (mutableSources) {
-    for (let i = 0; i < mutableSources.length; i++) {
-      const mutableSource = mutableSources[i];
-      registerMutableSourceForHydration(root, mutableSource);
-    }
-  }
-  // END TODO
-
   return new ReactDOMRoot(root);
 }
 
@@ -185,7 +168,6 @@ export function hydrateRoot(
   // For now we reuse the whole bag of options since they contain
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;
-  const mutableSources = (options != null && options.hydratedSources) || null;
   const isStrictMode = options != null && options.unstable_strictMode === true;
 
   let concurrentUpdatesByDefaultOverride = null;
@@ -208,13 +190,6 @@ export function hydrateRoot(
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 
-  if (mutableSources) {
-    for (let i = 0; i < mutableSources.length; i++) {
-      const mutableSource = mutableSources[i];
-      registerMutableSourceForHydration(root, mutableSource);
-    }
-  }
-
   // Render the initial children
   updateContainer(initialChildren, root, null, null);
 

commit 82c8fa90be86fc0afcbff2dc39486579cff1ac9a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 21 23:38:24 2021 -0400

    Add back useMutableSource temporarily (#22396)
    
    Recoil uses useMutableSource behind a flag. I thought this was fine
    because Recoil isn't used in any concurrent roots, so the behavior
    would be the same, but it turns out that it is used by concurrent
    roots in a few places.
    
    I'm not expecting it to be hard to migrate to useSyncExternalStore, but
    to de-risk the change I'm going to roll it out gradually with a flag. In
    the meantime, I've added back the useMutableSource API.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 3bde63dc67..ba062fc3f7 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -8,7 +8,7 @@
  */
 
 import type {Container} from './ReactDOMHostConfig';
-import type {ReactNodeList} from 'shared/ReactTypes';
+import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 
 export type RootType = {
@@ -24,6 +24,7 @@ export type CreateRootOptions = {
   hydrationOptions?: {
     onHydrated?: (suspenseNode: Comment) => void,
     onDeleted?: (suspenseNode: Comment) => void,
+    mutableSources?: Array<MutableSource<any>>,
     ...
   },
   // END OF TODO
@@ -34,6 +35,7 @@ export type CreateRootOptions = {
 
 export type HydrateRootOptions = {
   // Hydration options
+  hydratedSources?: Array<MutableSource<any>>,
   onHydrated?: (suspenseNode: Comment) => void,
   onDeleted?: (suspenseNode: Comment) => void,
   // Options for all roots
@@ -59,6 +61,7 @@ import {
   createContainer,
   updateContainer,
   findHostInstanceWithNoPortals,
+  registerMutableSourceForHydration,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
@@ -126,6 +129,11 @@ export function createRoot(
   const hydrate = options != null && options.hydrate === true;
   const hydrationCallbacks =
     (options != null && options.hydrationOptions) || null;
+  const mutableSources =
+    (options != null &&
+      options.hydrationOptions != null &&
+      options.hydrationOptions.mutableSources) ||
+    null;
   // END TODO
 
   const isStrictMode = options != null && options.unstable_strictMode === true;
@@ -151,6 +159,15 @@ export function createRoot(
     container.nodeType === COMMENT_NODE ? container.parentNode : container;
   listenToAllSupportedEvents(rootContainerElement);
 
+  // TODO: Delete this path
+  if (mutableSources) {
+    for (let i = 0; i < mutableSources.length; i++) {
+      const mutableSource = mutableSources[i];
+      registerMutableSourceForHydration(root, mutableSource);
+    }
+  }
+  // END TODO
+
   return new ReactDOMRoot(root);
 }
 
@@ -168,6 +185,7 @@ export function hydrateRoot(
   // For now we reuse the whole bag of options since they contain
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;
+  const mutableSources = (options != null && options.hydratedSources) || null;
   const isStrictMode = options != null && options.unstable_strictMode === true;
 
   let concurrentUpdatesByDefaultOverride = null;
@@ -190,6 +208,13 @@ export function hydrateRoot(
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 
+  if (mutableSources) {
+    for (let i = 0; i < mutableSources.length; i++) {
+      const mutableSource = mutableSources[i];
+      registerMutableSourceForHydration(root, mutableSource);
+    }
+  }
+
   // Render the initial children
   updateContainer(initialChildren, root, null, null);
 

commit d3e0869324267dc62b50ee02f747f5f0a5f5c656
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 27 17:04:39 2021 -0400

    Make root.unmount() synchronous  (#22444)
    
    * Move flushSync warning to React DOM
    
    When you call in `flushSync` from an effect, React fires a warning. I've
    moved the implementation of this warning out of the reconciler and into
    React DOM.
    
    `flushSync` is a renderer API, not an isomorphic API, because it has
    behavior that was designed specifically for the constraints of React
    DOM. The equivalent API in a different renderer may not be the same.
    For example, React Native has a different threading model than the
    browser, so it might not make sense to expose a `flushSync` API to the
    JavaScript thread.
    
    * Make root.unmount() synchronous
    
    When you unmount a root, the internal state that React stores on the
    DOM node is immediately cleared. So, we should also synchronously
    delete the React tree. You should be able to create a new root using
    the same container.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ba062fc3f7..1a027d9a1e 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -14,7 +14,7 @@ import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 export type RootType = {
   render(children: ReactNodeList): void,
   unmount(): void,
-  _internalRoot: FiberRoot,
+  _internalRoot: FiberRoot | null,
   ...
 };
 
@@ -62,17 +62,23 @@ import {
   updateContainer,
   findHostInstanceWithNoPortals,
   registerMutableSourceForHydration,
+  flushSync,
+  isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import invariant from 'shared/invariant';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
 
-function ReactDOMRoot(internalRoot) {
+function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }
 
 ReactDOMRoot.prototype.render = function(children: ReactNodeList): void {
   const root = this._internalRoot;
+  if (root === null) {
+    invariant(false, 'Cannot update an unmounted root.');
+  }
+
   if (__DEV__) {
     if (typeof arguments[1] === 'function') {
       console.error(
@@ -109,10 +115,23 @@ ReactDOMRoot.prototype.unmount = function(): void {
     }
   }
   const root = this._internalRoot;
-  const container = root.containerInfo;
-  updateContainer(null, root, null, () => {
+  if (root !== null) {
+    this._internalRoot = null;
+    const container = root.containerInfo;
+    if (__DEV__) {
+      if (isAlreadyRendering()) {
+        console.error(
+          'Attempted to synchronously unmount a root while React was already ' +
+            'rendering. React cannot finish unmounting the root until the ' +
+            'current render has completed, which may lead to a race condition.',
+        );
+      }
+    }
+    flushSync(() => {
+      updateContainer(null, root, null, null);
+    });
     unmarkContainerAsRoot(container);
-  });
+  }
 };
 
 export function createRoot(

commit a724a3b578dce77d427bef313102a4d0e978d9b4
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Sep 30 15:01:28 2021 -0400

    [RFC] Codemod invariant -> throw new Error (#22435)
    
    * Hoist error codes import to module scope
    
    When this code was written, the error codes map (`codes.json`) was
    created on-the-fly, so we had to lazily require from inside the visitor.
    
    Because `codes.json` is now checked into source, we can import it a
    single time in module scope.
    
    * Minify error constructors in production
    
    We use a script to minify our error messages in production. Each message
    is assigned an error code, defined in `scripts/error-codes/codes.json`.
    Then our build script replaces the messages with a link to our
    error decoder page, e.g. https://reactjs.org/docs/error-decoder.html/?invariant=92
    
    This enables us to write helpful error messages without increasing the
    bundle size.
    
    Right now, the script only works for `invariant` calls. It does not work
    if you throw an Error object. This is an old Facebookism that we don't
    really need, other than the fact that our error minification script
    relies on it.
    
    So, I've updated the script to minify error constructors, too:
    
    Input:
      Error(`A ${adj} message that contains ${noun}`);
    Output:
      Error(formatProdErrorMessage(ERR_CODE, adj, noun));
    
    It only works for constructors that are literally named Error, though we
    could add support for other names, too.
    
    As a next step, I will add a lint rule to enforce that errors written
    this way must have a corresponding error code.
    
    * Minify "no fallback UI specified" error in prod
    
    This error message wasn't being minified because it doesn't use
    invariant. The reason it didn't use invariant is because this particular
    error is created without begin thrown — it doesn't need to be thrown
    because it's located inside the error handling part of the runtime.
    
    Now that the error minification script supports Error constructors, we
    can minify it by assigning it a production error code in
    `scripts/error-codes/codes.json`.
    
    To support the use of Error constructors more generally, I will add a
    lint rule that enforces each message has a corresponding error code.
    
    * Lint rule to detect unminified errors
    
    Adds a lint rule that detects when an Error constructor is used without
    a corresponding production error code.
    
    We already have this for `invariant`, but not for regular errors, i.e.
    `throw new Error(msg)`. There's also nothing that enforces the use of
    `invariant` besides convention.
    
    There are some packages where we don't care to minify errors. These are
    packages that run in environments where bundle size is not a concern,
    like react-pg. I added an override in the ESLint config to ignore these.
    
    * Temporarily add invariant codemod script
    
    I'm adding this codemod to the repo temporarily, but I'll revert it
    in the same PR. That way we don't have to check it in but it's still
    accessible (via the PR) if we need it later.
    
    * [Automated] Codemod invariant -> Error
    
    This commit contains only automated changes:
    
    npx jscodeshift -t scripts/codemod-invariant.js packages --ignore-pattern="node_modules/**/*"
    yarn linc --fix
    yarn prettier
    
    I will do any manual touch ups in separate commits so they're easier
    to review.
    
    * Remove temporary codemod script
    
    This reverts the codemod script and ESLint config I added temporarily
    in order to perform the invariant codemod.
    
    * Manual touch ups
    
    A few manual changes I made after the codemod ran.
    
    * Enable error code transform per package
    
    Currently we're not consistent about which packages should have their
    errors minified in production and which ones should.
    
    This adds a field to the bundle configuration to control whether to
    apply the transform. We should decide what the criteria is going
    forward. I think it's probably a good idea to minify any package that
    gets sent over the network. So yes to modules that run in the browser,
    and no to modules that run on the server and during development only.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 1a027d9a1e..38f2100cb5 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -65,7 +65,6 @@ import {
   flushSync,
   isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
-import invariant from 'shared/invariant';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
 
@@ -76,7 +75,7 @@ function ReactDOMRoot(internalRoot: FiberRoot) {
 ReactDOMRoot.prototype.render = function(children: ReactNodeList): void {
   const root = this._internalRoot;
   if (root === null) {
-    invariant(false, 'Cannot update an unmounted root.');
+    throw new Error('Cannot update an unmounted root.');
   }
 
   if (__DEV__) {
@@ -138,10 +137,10 @@ export function createRoot(
   container: Container,
   options?: CreateRootOptions,
 ): RootType {
-  invariant(
-    isValidContainerLegacy(container),
-    'createRoot(...): Target container is not a DOM element.',
-  );
+  if (!isValidContainerLegacy(container)) {
+    throw new Error('createRoot(...): Target container is not a DOM element.');
+  }
+
   warnIfReactDOMContainerInDEV(container);
 
   // TODO: Delete these options
@@ -195,10 +194,10 @@ export function hydrateRoot(
   initialChildren: ReactNodeList,
   options?: HydrateRootOptions,
 ): RootType {
-  invariant(
-    isValidContainer(container),
-    'hydrateRoot(...): Target container is not a DOM element.',
-  );
+  if (!isValidContainer(container)) {
+    throw new Error('hydrateRoot(...): Target container is not a DOM element.');
+  }
+
   warnIfReactDOMContainerInDEV(container);
 
   // For now we reuse the whole bag of options since they contain

commit 4ff5f5719b348d9d8db14aaa49a48532defb4ab7
Author: salazarm <salazarm@users.noreply.github.com>
Date:   Mon Nov 15 17:15:01 2021 -0500

    Move unstable_scheduleHydration to ReactDOMHydrationRoot (#22455)
    
    * move unstable_scheduleHydration to ReactDOMHydrationRoot
    
    * move definition of schedule hydration
    
    * fix test?
    
    * prototype
    
    * fix test
    
    * remove gating because unstable_scheduleHydration is no longer gated through index.stable.js because its exposed through ReactDOMHydrationRoot instead of the ReactDOM package
    
    * remove another gating

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 38f2100cb5..d8794eec5b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -11,6 +11,8 @@ import type {Container} from './ReactDOMHostConfig';
 import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
 import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
 
+import {queueExplicitHydrationTarget} from '../events/ReactDOMEventReplaying';
+
 export type RootType = {
   render(children: ReactNodeList): void,
   unmount(): void,
@@ -72,7 +74,9 @@ function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }
 
-ReactDOMRoot.prototype.render = function(children: ReactNodeList): void {
+ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(
+  children: ReactNodeList,
+): void {
   const root = this._internalRoot;
   if (root === null) {
     throw new Error('Cannot update an unmounted root.');
@@ -104,7 +108,7 @@ ReactDOMRoot.prototype.render = function(children: ReactNodeList): void {
   updateContainer(children, root, null, null);
 };
 
-ReactDOMRoot.prototype.unmount = function(): void {
+ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
       console.error(
@@ -189,6 +193,16 @@ export function createRoot(
   return new ReactDOMRoot(root);
 }
 
+function ReactDOMHydrationRoot(internalRoot: FiberRoot) {
+  this._internalRoot = internalRoot;
+}
+function scheduleHydration(target: Node) {
+  if (target) {
+    queueExplicitHydrationTarget(target);
+  }
+}
+ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
+
 export function hydrateRoot(
   container: Container,
   initialChildren: ReactNodeList,
@@ -236,7 +250,7 @@ export function hydrateRoot(
   // Render the initial children
   updateContainer(initialChildren, root, null, null);
 
-  return new ReactDOMRoot(root);
+  return new ReactDOMHydrationRoot(root);
 }
 
 export function isValidContainer(node: any): boolean {

commit 4729ff6d1f191902897927ff4ecd3d1f390177fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Dec 2 20:49:43 2021 -0500

    Implement identifierPrefix option for useId (#22855)
    
    When an `identifierPrefix` option is given, React will add it to the
    beginning of ids generated by `useId`.
    
    The main use case is to avoid conflicts when there are multiple React
    roots on a single page.
    
    The server API already supported an `identifierPrefix` option. It's not
    only used by `useId`, but also for React-generated ids that are used to
    stitch together chunks of HTML, among other things. I added a
    corresponding option to the client.
    
    You must pass the same prefix option to both the server and client.
    Eventually we may make this automatic by sending the prefix from the
    server as part of the HTML stream.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index d8794eec5b..3c49a15fc1 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -32,6 +32,7 @@ export type CreateRootOptions = {
   // END OF TODO
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
+  identifierPrefix?: string,
   ...
 };
 
@@ -43,6 +44,7 @@ export type HydrateRootOptions = {
   // Options for all roots
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
+  identifierPrefix?: string,
   ...
 };
 
@@ -158,13 +160,22 @@ export function createRoot(
     null;
   // END TODO
 
-  const isStrictMode = options != null && options.unstable_strictMode === true;
-  let concurrentUpdatesByDefaultOverride = null;
-  if (allowConcurrentByDefault) {
-    concurrentUpdatesByDefaultOverride =
-      options != null && options.unstable_concurrentUpdatesByDefault != null
-        ? options.unstable_concurrentUpdatesByDefault
-        : null;
+  let isStrictMode = false;
+  let concurrentUpdatesByDefaultOverride = false;
+  let identifierPrefix = '';
+  if (options !== null && options !== undefined) {
+    if (options.unstable_strictMode === true) {
+      isStrictMode = true;
+    }
+    if (
+      allowConcurrentByDefault &&
+      options.unstable_concurrentUpdatesByDefault === true
+    ) {
+      concurrentUpdatesByDefaultOverride = true;
+    }
+    if (options.identifierPrefix !== undefined) {
+      identifierPrefix = options.identifierPrefix;
+    }
   }
 
   const root = createContainer(
@@ -174,6 +185,7 @@ export function createRoot(
     hydrationCallbacks,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
+    identifierPrefix,
   );
   markContainerAsRoot(root.current, container);
 
@@ -217,15 +229,25 @@ export function hydrateRoot(
   // For now we reuse the whole bag of options since they contain
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;
+  // TODO: Delete this option
   const mutableSources = (options != null && options.hydratedSources) || null;
-  const isStrictMode = options != null && options.unstable_strictMode === true;
-
-  let concurrentUpdatesByDefaultOverride = null;
-  if (allowConcurrentByDefault) {
-    concurrentUpdatesByDefaultOverride =
-      options != null && options.unstable_concurrentUpdatesByDefault != null
-        ? options.unstable_concurrentUpdatesByDefault
-        : null;
+
+  let isStrictMode = false;
+  let concurrentUpdatesByDefaultOverride = false;
+  let identifierPrefix = '';
+  if (options !== null && options !== undefined) {
+    if (options.unstable_strictMode === true) {
+      isStrictMode = true;
+    }
+    if (
+      allowConcurrentByDefault &&
+      options.unstable_concurrentUpdatesByDefault === true
+    ) {
+      concurrentUpdatesByDefaultOverride = true;
+    }
+    if (options.identifierPrefix !== undefined) {
+      identifierPrefix = options.identifierPrefix;
+    }
   }
 
   const root = createContainer(
@@ -235,6 +257,7 @@ export function hydrateRoot(
     hydrationCallbacks,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
+    identifierPrefix,
   );
   markContainerAsRoot(root.current, container);
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.

commit 5041c37d27ee8f80bf152951d20bf861f817c7c6
Author: salazarm <salazarm@users.noreply.github.com>
Date:   Tue Dec 7 16:10:00 2021 -0500

    Remove hydrate option from createRoot (#22878)
    
    * remove hydrate: true option
    
    * remove missed comment
    
    * lint
    
    * warning
    
    * circumvent flow

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 3c49a15fc1..800eeba0d0 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -21,15 +21,6 @@ export type RootType = {
 };
 
 export type CreateRootOptions = {
-  // TODO: Remove these options.
-  hydrate?: boolean,
-  hydrationOptions?: {
-    onHydrated?: (suspenseNode: Comment) => void,
-    onDeleted?: (suspenseNode: Comment) => void,
-    mutableSources?: Array<MutableSource<any>>,
-    ...
-  },
-  // END OF TODO
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   identifierPrefix?: string,
@@ -149,21 +140,17 @@ export function createRoot(
 
   warnIfReactDOMContainerInDEV(container);
 
-  // TODO: Delete these options
-  const hydrate = options != null && options.hydrate === true;
-  const hydrationCallbacks =
-    (options != null && options.hydrationOptions) || null;
-  const mutableSources =
-    (options != null &&
-      options.hydrationOptions != null &&
-      options.hydrationOptions.mutableSources) ||
-    null;
-  // END TODO
-
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
   if (options !== null && options !== undefined) {
+    if (__DEV__) {
+      if ((options: any).hydrate) {
+        console.warn(
+          'hydrate through createRoot is deprecated. Use ReactDOM.hydrateRoot(container, <App />) instead.',
+        );
+      }
+    }
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
     }
@@ -181,8 +168,8 @@ export function createRoot(
   const root = createContainer(
     container,
     ConcurrentRoot,
-    hydrate,
-    hydrationCallbacks,
+    false,
+    null,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
@@ -193,15 +180,6 @@ export function createRoot(
     container.nodeType === COMMENT_NODE ? container.parentNode : container;
   listenToAllSupportedEvents(rootContainerElement);
 
-  // TODO: Delete this path
-  if (mutableSources) {
-    for (let i = 0; i < mutableSources.length; i++) {
-      const mutableSource = mutableSources[i];
-      registerMutableSourceForHydration(root, mutableSource);
-    }
-  }
-  // END TODO
-
   return new ReactDOMRoot(root);
 }
 

commit 848e802d203e531daf2b9b0edb281a1eb6c5415d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Feb 4 07:57:33 2022 -0800

    Add onRecoverableError option to hydrateRoot, createRoot (#23207)
    
    * [RFC] Add onHydrationError option to hydrateRoot
    
    This is not the final API but I'm pushing it for discussion purposes.
    
    When an error is thrown during hydration, we fallback to client
    rendering, without triggering an error boundary. This is good because,
    in many cases, the UI will recover and the user won't even notice that
    something has gone wrong behind the scenes.
    
    However, we shouldn't recover from these errors silently, because the
    underlying cause might be pretty serious. Server-client mismatches are
    not supposed to happen, even if UI doesn't break from the users
    perspective. Ignoring them could lead to worse problems later. De-opting
    from server to client rendering could also be a significant performance
    regression, depending on the scope of the UI it affects.
    
    So we need a way to log when hydration errors occur.
    
    This adds a new option for `hydrateRoot` called `onHydrationError`. It's
    symmetrical to the server renderer's `onError` option, and serves the
    same purpose.
    
    When no option is provided, the default behavior is to schedule a
    browser task and rethrow the error. This will trigger the normal browser
    behavior for errors, including dispatching an error event. If the app
    already has error monitoring, this likely will just work as expected
    without additional configuration.
    
    However, we can also expose additional metadata about these errors, like
    which Suspense boundaries were affected by the de-opt to client
    rendering. (I have not exposed any metadata in this commit; API needs
    more design work.)
    
    There are other situations besides hydration where we recover from an
    error without surfacing it to the user, or notifying an error boundary.
    For example, if an error occurs during a concurrent render, it could be
    due to a data race, so we try again synchronously in case that fixes it.
    We should probably expose a way to log these types of errors, too. (Also
    not implemented in this commit.)
    
    * Log all recoverable errors
    
    This expands the scope of onHydrationError to include all errors that
    are not surfaced to the UI (an error boundary). In addition to errors
    that occur during hydration, this also includes errors that recoverable
    by de-opting to synchronous rendering. Typically (or really, by
    definition) these errors are the result of a concurrent data race;
    blocking the main thread fixes them by prevents subsequent races.
    
    The logic for de-opting to synchronous rendering already existed. The
    only thing that has changed is that we now log the errors instead of
    silently proceeding.
    
    The logging API has been renamed from onHydrationError
    to onRecoverableError.
    
    * Don't log recoverable errors until commit phase
    
    If the render is interrupted and restarts, we don't want to log the
    errors multiple times.
    
    This change only affects errors that are recovered by de-opting to
    synchronous rendering; we'll have to do something else for errors
    during hydration, since they use a different recovery path.
    
    * Only log hydration error if client render succeeds
    
    Similar to previous step.
    
    When an error occurs during hydration, we only want to log it if falling
    back to client rendering _succeeds_. If client rendering fails,
    the error will get reported to the nearest error boundary, so there's
    no need for a duplicate log.
    
    To implement this, I added a list of errors to the hydration context.
    If the Suspense boundary successfully completes, they are added to
    the main recoverable errors queue (the one I added in the
    previous step.)
    
    * Log error with queueMicrotask instead of Scheduler
    
    If onRecoverableError is not provided, we default to rethrowing the
    error in a separate task. Originally, I scheduled the task with
    idle priority, but @sebmarkbage made the good point that if there are
    multiple errors logs, we want to preserve the original order. So I've
    switched it to a microtask. The priority can be lowered in userspace
    by scheduling an additional task inside onRecoverableError.
    
    * Only use host config method for default behavior
    
    Redefines the contract of the host config's logRecoverableError method
    to be a default implementation for onRecoverableError if a user-provided
    one is not provided when the root is created.
    
    * Log with reportError instead of rethrowing
    
    In modern browsers, reportError will dispatch an error event, emulating
    an uncaught JavaScript error. We can do this instead of rethrowing
    recoverable errors in a microtask, which is nice because it avoids any
    subtle ordering issues.
    
    In older browsers and test environments, we'll fall back
    to console.error.
    
    * Naming nits
    
    queueRecoverableHydrationErrors -> upgradeHydrationErrorsToRecoverable

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 800eeba0d0..fe6b6ee31f 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -24,6 +24,7 @@ export type CreateRootOptions = {
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   identifierPrefix?: string,
+  onRecoverableError?: (error: mixed) => void,
   ...
 };
 
@@ -36,6 +37,7 @@ export type HydrateRootOptions = {
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   identifierPrefix?: string,
+  onRecoverableError?: (error: mixed) => void,
   ...
 };
 
@@ -143,6 +145,7 @@ export function createRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
+  let onRecoverableError = null;
   if (options !== null && options !== undefined) {
     if (__DEV__) {
       if ((options: any).hydrate) {
@@ -163,6 +166,9 @@ export function createRoot(
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }
+    if (options.onRecoverableError !== undefined) {
+      onRecoverableError = options.onRecoverableError;
+    }
   }
 
   const root = createContainer(
@@ -173,6 +179,7 @@ export function createRoot(
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
+    onRecoverableError,
   );
   markContainerAsRoot(root.current, container);
 
@@ -213,6 +220,7 @@ export function hydrateRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
+  let onRecoverableError = null;
   if (options !== null && options !== undefined) {
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
@@ -226,6 +234,9 @@ export function hydrateRoot(
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }
+    if (options.onRecoverableError !== undefined) {
+      onRecoverableError = options.onRecoverableError;
+    }
   }
 
   const root = createContainer(
@@ -236,6 +247,7 @@ export function hydrateRoot(
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
+    onRecoverableError,
   );
   markContainerAsRoot(root.current, container);
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.

commit efd8f6442d1aa7c4566fe812cba03e7e83aaccc3
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 10 07:59:10 2022 -0800

    Resolve default onRecoverableError at root init (#23264)
    
    Minor follow up to initial onRecoverableError PR.
    
    When onRecoverableError is not provided to `createRoot`, the
    renderer falls back to a default implementation. Originally I
    implemented this with a host config method, but what we can do instead
    is pass the default implementation the root constructor as if it were
    a user provided one.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index fe6b6ee31f..9867a1b45e 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -65,6 +65,18 @@ import {
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
 
+/* global reportError */
+const defaultOnRecoverableError =
+  typeof reportError === 'function'
+    ? // In modern browsers, reportError will dispatch an error event,
+      // emulating an uncaught JavaScript error.
+      reportError
+    : (error: mixed) => {
+        // In older browsers and test environments, fallback to console.error.
+        // eslint-disable-next-line react-internal/no-production-logging, react-internal/warning-args
+        console.error(error);
+      };
+
 function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }
@@ -145,7 +157,7 @@ export function createRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
-  let onRecoverableError = null;
+  let onRecoverableError = defaultOnRecoverableError;
   if (options !== null && options !== undefined) {
     if (__DEV__) {
       if ((options: any).hydrate) {
@@ -220,7 +232,7 @@ export function hydrateRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
-  let onRecoverableError = null;
+  let onRecoverableError = defaultOnRecoverableError;
   if (options !== null && options !== undefined) {
     if (options.unstable_strictMode === true) {
       isStrictMode = true;

commit 1fb0d06878416d321182ddb4601231982e7433c9
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Fri Feb 11 13:15:10 2022 -0500

    [Devtools][Transition Tracing] Add Transition callbacks to createRoot (#23276)
    
    - Add the type of transition tracing callbacks
    - Add transition tracing callbacks as an option to `createRoot`
    - Add transition tracing callbacks on the root
    - Add option to pass transition tracing callbacks to createReactNoop

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9867a1b45e..1fe4557cb8 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -9,7 +9,10 @@
 
 import type {Container} from './ReactDOMHostConfig';
 import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
-import type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';
+import type {
+  FiberRoot,
+  TransitionTracingCallbacks,
+} from 'react-reconciler/src/ReactInternalTypes';
 
 import {queueExplicitHydrationTarget} from '../events/ReactDOMEventReplaying';
 
@@ -25,6 +28,7 @@ export type CreateRootOptions = {
   unstable_concurrentUpdatesByDefault?: boolean,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
+  transitionCallbacks?: TransitionTracingCallbacks,
   ...
 };
 
@@ -158,6 +162,8 @@ export function createRoot(
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
   let onRecoverableError = defaultOnRecoverableError;
+  let transitionCallbacks = null;
+
   if (options !== null && options !== undefined) {
     if (__DEV__) {
       if ((options: any).hydrate) {
@@ -181,6 +187,9 @@ export function createRoot(
     if (options.onRecoverableError !== undefined) {
       onRecoverableError = options.onRecoverableError;
     }
+    if (options.transitionCallbacks !== undefined) {
+      transitionCallbacks = options.transitionCallbacks;
+    }
   }
 
   const root = createContainer(
@@ -192,6 +201,7 @@ export function createRoot(
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
     onRecoverableError,
+    transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
 
@@ -260,6 +270,8 @@ export function hydrateRoot(
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
     onRecoverableError,
+    // TODO(luna) Support hydration later
+    null,
   );
   markContainerAsRoot(root.current, container);
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.

commit 80059bb7307e30234ebcc9e6b491c0606e66e6c7
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Feb 16 12:15:25 2022 -0600

    Switch to client rendering if root receives update (#23309)
    
    If a hydration root receives an update before the outermost shell has
    finished hydrating, we should give up hydrating and switch to
    client rendering.
    
    Since the shell is expected to commit quickly, this doesn't happen that
    often. The most common sequence is something in the shell suspends, and
    then the user quickly navigates to a different screen, triggering a
    top-level update.
    
    Instead of immediately switching to client rendering, we could first
    attempt to hydration at higher priority, like we do for updates that
    occur inside nested dehydrated trees.
    
    But since this case is expected to be rare, and mainly only happens when
    the shell is suspended, an attempt at higher priority would likely end
    up suspending again anyway, so it would be wasted effort. Implementing
    it this way would also require us to add a new lane especially for root
    hydration. For simplicity's sake, we'll immediately switch to client
    rendering. In the future, if we find another use case for a root
    hydration lane, we'll reconsider.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 1fe4557cb8..e10f9e5448 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -60,6 +60,7 @@ import {
 
 import {
   createContainer,
+  createHydrationContainer,
   updateContainer,
   findHostInstanceWithNoPortals,
   registerMutableSourceForHydration,
@@ -261,10 +262,10 @@ export function hydrateRoot(
     }
   }
 
-  const root = createContainer(
+  const root = createHydrationContainer(
+    initialChildren,
     container,
     ConcurrentRoot,
-    true, // hydrate
     hydrationCallbacks,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
@@ -284,9 +285,6 @@ export function hydrateRoot(
     }
   }
 
-  // Render the initial children
-  updateContainer(initialChildren, root, null, null);
-
   return new ReactDOMHydrationRoot(root);
 }
 

commit 54f785bc51800556dead12aaedf9594b2f15e836
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 17 16:44:22 2022 -0500

    Disallow comments as DOM containers for createRoot (#23321)
    
    This is an old feature that we no longer support. `hydrateRoot` already
    throws if you pass a comment node; this change makes `createRoot`
    throw, too.
    
    Still enabled in the Facebook build until we migrate the callers.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index e10f9e5448..9665cf07f9 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -68,7 +68,10 @@ import {
   isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
-import {allowConcurrentByDefault} from 'shared/ReactFeatureFlags';
+import {
+  allowConcurrentByDefault,
+  disableCommentsAsDOMContainers,
+} from 'shared/ReactFeatureFlags';
 
 /* global reportError */
 const defaultOnRecoverableError =
@@ -153,7 +156,7 @@ export function createRoot(
   container: Container,
   options?: CreateRootOptions,
 ): RootType {
-  if (!isValidContainerLegacy(container)) {
+  if (!isValidContainer(container)) {
     throw new Error('createRoot(...): Target container is not a DOM element.');
   }
 
@@ -293,7 +296,10 @@ export function isValidContainer(node: any): boolean {
     node &&
     (node.nodeType === ELEMENT_NODE ||
       node.nodeType === DOCUMENT_NODE ||
-      node.nodeType === DOCUMENT_FRAGMENT_NODE)
+      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
+      (!disableCommentsAsDOMContainers &&
+        node.nodeType === COMMENT_NODE &&
+        (node: any).nodeValue === ' react-mount-point-unstable '))
   );
 }
 

commit 8c4cd65cfaa4614bac7fd7783b4ec502a337eba3
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 24 10:57:37 2022 -0500

    Add warnings for common root API mistakes (#23356)
    
    For createRoot, a common mistake is to pass JSX as the second argument,
    instead of calling root.render.
    
    For hydrateRoot, a common mistake is to forget to pass children as
    the second argument.
    
    The type system will enforce correct usage, but since not everyone uses
    types we'll log a helpful warning, too.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9665cf07f9..46786fcdea 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -15,6 +15,7 @@ import type {
 } from 'react-reconciler/src/ReactInternalTypes';
 
 import {queueExplicitHydrationTarget} from '../events/ReactDOMEventReplaying';
+import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -174,6 +175,20 @@ export function createRoot(
         console.warn(
           'hydrate through createRoot is deprecated. Use ReactDOM.hydrateRoot(container, <App />) instead.',
         );
+      } else {
+        if (
+          typeof options === 'object' &&
+          options !== null &&
+          (options: any).$$typeof === REACT_ELEMENT_TYPE
+        ) {
+          console.error(
+            'You passed a JSX element to createRoot. You probably meant to ' +
+              'call root.render instead. ' +
+              'Example usage:\n\n' +
+              '  let root = createRoot(domContainer);\n' +
+              '  root.render(<App />);',
+          );
+        }
       }
     }
     if (options.unstable_strictMode === true) {
@@ -237,6 +252,15 @@ export function hydrateRoot(
 
   warnIfReactDOMContainerInDEV(container);
 
+  if (__DEV__) {
+    if (initialChildren === undefined) {
+      console.error(
+        'Must provide initial children as second argument to hydrateRoot. ' +
+          'Example usage: hydrateRoot(domContainer, <App />)',
+      );
+    }
+  }
+
   // For now we reuse the whole bag of options since they contain
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;

commit 68cb55f262b75f5d5b723104b830daab37b1ea14
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 24 16:31:48 2022 -0500

    Add more warnings for second argument to root.render. (#23358)
    
    We already had one for callbacks but containers is also an easy mistake.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 46786fcdea..57bbe7ab96 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -104,7 +104,18 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = functio
         'render(...): does not support the second callback argument. ' +
           'To execute a side effect after rendering, declare it in a component body with useEffect().',
       );
+    } else if (isValidContainer(arguments[1])) {
+      console.error(
+        'You passed a container to the second argument of root.render(...). ' +
+          "You don't need to pass it again since you already passed it to create the root.",
+      );
+    } else if (typeof arguments[1] !== 'undefined') {
+      console.error(
+        'You passed a second argument to root.render(...) but it only accepts ' +
+          'one argument.',
+      );
     }
+
     const container = root.containerInfo;
 
     if (container.nodeType !== COMMENT_NODE) {

commit 17806594cc28284fe195f918e8d77de3516848ec
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 1 00:13:28 2022 -0500

    Move createRoot/hydrateRoot to react-dom/client (#23385)
    
    * Move createRoot/hydrateRoot to /client
    
    We want these APIs ideally to be imported separately from things you
    might use in arbitrary components (like flushSync). Those other methods
    are "isomorphic" to how the ReactDOM tree is rendered. Similar to hooks.
    
    E.g. importing flushSync into a component that only uses it on the client
    should ideally not also pull in the entry client implementation on the
    server.
    
    This also creates a nicer parity with /server where the roots are in a
    separate entry point.
    
    Unfortunately, I can't quite do this yet because we have some legacy APIs
    that we plan on removing (like findDOMNode) and we also haven't implemented
    flushSync using a flag like startTransition does yet.
    
    Another problem is that we currently encourage these APIs to be aliased by
    /profiling (or unstable_testing). In the future you don't have to alias
    them because you can just change your roots to just import those APIs and
    they'll still work with the isomorphic forms. Although we might also just
    use export conditions for them.
    
    For that all to work, I went with a different strategy for now where the
    real API is in / but it comes with a warning if you use it. If you instead
    import /client it disables the warning in a wrapper. That means that if you
    alias / then import /client that will inturn import the alias and it'll
    just work.
    
    In a future breaking changes (likely when we switch to ESM) we can just
    remove createRoot/hydrateRoot from / and move away from the aliasing
    strategy.
    
    * Update tests to import from react-dom/client
    
    * Fix fixtures
    
    * Update warnings
    
    * Add test for the warning
    
    * Update devtools
    
    * Change order of react-dom, react-dom/client alias
    
    I think the order matters here. The first one takes precedence.
    
    * Require react-dom through client so it can be aliased
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 57bbe7ab96..d71de3bb0c 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -184,7 +184,7 @@ export function createRoot(
     if (__DEV__) {
       if ((options: any).hydrate) {
         console.warn(
-          'hydrate through createRoot is deprecated. Use ReactDOM.hydrateRoot(container, <App />) instead.',
+          'hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.',
         );
       } else {
         if (
@@ -369,12 +369,12 @@ function warnIfReactDOMContainerInDEV(container) {
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
         console.error(
-          'You are calling ReactDOM.createRoot() on a container that was previously ' +
+          'You are calling ReactDOMClient.createRoot() on a container that was previously ' +
             'passed to ReactDOM.render(). This is not supported.',
         );
       } else {
         console.error(
-          'You are calling ReactDOM.createRoot() on a container that ' +
+          'You are calling ReactDOMClient.createRoot() on a container that ' +
             'has already been passed to createRoot() before. Instead, call ' +
             'root.render() on the existing root instead if you want to update it.',
         );

commit c8e4789e21f6cb031b92b3bd8a905244bfd808b2
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 4 16:50:29 2022 -0500

    Pass children to hydration root constructor
    
    I already made this change for the concurrent root API in #23309. This
    does the same thing for the legacy API.
    
    Doesn't change any behavior, but I will use this in the next steps.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index d71de3bb0c..6e7192ae10 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -225,7 +225,6 @@ export function createRoot(
   const root = createContainer(
     container,
     ConcurrentRoot,
-    false,
     null,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
@@ -302,6 +301,7 @@ export function hydrateRoot(
 
   const root = createHydrationContainer(
     initialChildren,
+    null,
     container,
     ConcurrentRoot,
     hydrationCallbacks,

commit 832e2987e01aa357c3b2e551acae0682ca36fb14
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 11 21:31:23 2022 -0500

    Revert accdientally merged PR (#24081)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 6e7192ae10..d71de3bb0c 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -225,6 +225,7 @@ export function createRoot(
   const root = createContainer(
     container,
     ConcurrentRoot,
+    false,
     null,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
@@ -301,7 +302,6 @@ export function hydrateRoot(
 
   const root = createHydrationContainer(
     initialChildren,
-    null,
     container,
     ConcurrentRoot,
     hydrationCallbacks,

commit 1c44437355e21f2992344fdef9ab1c1c5a7f8c2b
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Mar 16 20:06:00 2022 -0400

    Fix createRoot container signature (#24110)
    
    The internal Container type represents the types of containers that React
    can support in its internals that deal with containers.
    
    This didn't include DocumentFragment which we support specifically for
    rendering into shadow roots.
    
    However, not all types makes sense to pass into the createRoot API.
    
    One of those is comment nodes that is deprecated and we don't really fully
    support. It really only exists for FB legacy.
    
    For createRoot it doesn't make sense to pass a Document since that will try
    to empty the document which removes the HTML tag which doesn't work.
    Documents can only be passed to hydrateRoot.
    
    Conversely I'm not sure we actually support hydrating a shadow root properly
    so I excluded DocumentFragment from hydrateRoot.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index d71de3bb0c..33074054f1 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -7,7 +7,6 @@
  * @flow
  */
 
-import type {Container} from './ReactDOMHostConfig';
 import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
 import type {
   FiberRoot,
@@ -165,7 +164,7 @@ ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = funct
 };
 
 export function createRoot(
-  container: Container,
+  container: Element | DocumentFragment,
   options?: CreateRootOptions,
 ): RootType {
   if (!isValidContainer(container)) {
@@ -235,8 +234,10 @@ export function createRoot(
   );
   markContainerAsRoot(root.current, container);
 
-  const rootContainerElement =
-    container.nodeType === COMMENT_NODE ? container.parentNode : container;
+  const rootContainerElement: Document | Element | DocumentFragment =
+    container.nodeType === COMMENT_NODE
+      ? (container.parentNode: any)
+      : container;
   listenToAllSupportedEvents(rootContainerElement);
 
   return new ReactDOMRoot(root);
@@ -253,7 +254,7 @@ function scheduleHydration(target: Node) {
 ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
 
 export function hydrateRoot(
-  container: Container,
+  container: Document | Element,
   initialChildren: ReactNodeList,
   options?: HydrateRootOptions,
 ): RootType {
@@ -351,7 +352,7 @@ export function isValidContainerLegacy(node: any): boolean {
   );
 }
 
-function warnIfReactDOMContainerInDEV(container) {
+function warnIfReactDOMContainerInDEV(container: any) {
   if (__DEV__) {
     if (
       container.nodeType === ELEMENT_NODE &&

commit 2e0d86d22192ff0b13b71b4ad68fea46bf523ef6
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Mar 20 16:18:51 2022 -0400

    Allow updating dehydrated root at lower priority without forcing client render (#24082)
    
    * Pass children to hydration root constructor
    
    I already made this change for the concurrent root API in #23309. This
    does the same thing for the legacy API.
    
    Doesn't change any behavior, but I will use this in the next steps.
    
    * Add isRootDehydrated function
    
    Currently this does nothing except read a boolean field, but I'm about
    to change this logic.
    
    Since this is accessed by React DOM, too, I put the function in a
    separate module that can be deep imported. Previously, it was accessing
    the FiberRoot directly. The reason it's a separate module is to break a
    circular dependency between React DOM and the reconciler.
    
    * Allow updates at lower pri without forcing client render
    
    Currently, if a root is updated before the shell has finished hydrating
    (for example, due to a top-level navigation), we immediately revert to
    client rendering. This is rare because the root is expected is finish
    quickly, but not exceedingly rare because the root may be suspended.
    
    This adds support for updating the root without forcing a client render
    as long as the update has lower priority than the initial hydration,
    i.e. if the update is wrapped in startTransition.
    
    To implement this, I had to do some refactoring. The main idea here is
    to make it closer to how we implement hydration in Suspense boundaries:
    
    - I moved isDehydrated from the shared FiberRoot object to the
    HostRoot's state object.
    - In the begin phase, I check if the root has received an by comparing
    the new children to the initial children. If they are different, we
    revert to client rendering, and set isDehydrated to false using a
    derived state update (a la getDerivedStateFromProps).
    - There are a few places where we used to set root.isDehydrated to false
    as a way to force a client render. Instead, I set the ForceClientRender
    flag on the root work-in-progress fiber.
    - Whenever we fall back to client rendering, I log a recoverable error.
    
    The overall code structure is almost identical to the corresponding
    logic for Suspense components.
    
    The reason this works is because if the update has lower priority than
    the initial hydration, it won't be processed during the hydration
    render, so the children will be the same.
    
    We can go even further and allow updates at _higher_ priority (though
    not sync) by implementing selective hydration at the root, like we do
    for Suspense boundaries: interrupt the current render, attempt hydration
    at slightly higher priority than the update, then continue rendering the
    update. I haven't implemented this yet, but I've structured the code in
    anticipation of adding this later.
    
    * Wrap useMutableSource logic in feature flag

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 33074054f1..c7820a703a 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -224,7 +224,6 @@ export function createRoot(
   const root = createContainer(
     container,
     ConcurrentRoot,
-    false,
     null,
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
@@ -303,6 +302,7 @@ export function hydrateRoot(
 
   const root = createHydrationContainer(
     initialChildren,
+    null,
     container,
     ConcurrentRoot,
     hydrationCallbacks,

commit fe6e0741286345edb2aa23784c21f8ea611ebdea
Author: Yash Srivastav <yash111998@gmail.com>
Date:   Tue Mar 29 10:45:14 2022 +0100

    Fix usage of console.error to prevent transform (#24188)
    
    We were suppressing the `react-internals/warning-args` lint rule
    for the call to `console.error` in `defaultOnRecoverableError`.
    
    As far as I could tell, the lint rule exists because on dev builds,
    we replace all calls to `console.error` with [this error
    function](https://github.com/facebook/react/blob/main/packages/shared/consoleWithStackDev.js#L31-L37)
    which expects a format string + args and nothing else. We were trying
    to pass in an `Error` object directly. After this commit's change,
    we will still be passing an `Error` but the transform won't occur.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index c7820a703a..55c340be7d 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -81,8 +81,8 @@ const defaultOnRecoverableError =
       reportError
     : (error: mixed) => {
         // In older browsers and test environments, fallback to console.error.
-        // eslint-disable-next-line react-internal/no-production-logging, react-internal/warning-args
-        console.error(error);
+        // eslint-disable-next-line react-internal/no-production-logging
+        console['error'](error);
       };
 
 function ReactDOMRoot(internalRoot: FiberRoot) {

commit 8197c73ec334e4430d892cead14aa371f13467a9
Author: Josh Story <story@hey.com>
Date:   Tue May 10 10:17:36 2022 -0700

    Support document rendering (#24523)
    
    * Support Document as a container for hydration and rendering
    
    Previously Document was not handled effectively as a container. in particual when hydrating if there was a fallback to client rendering React would attempt to append a new <html> element into the document before clearing out the existing one which errored leaving the application in brokent state.
    
    The initial approach I took was to recycle the documentElement and never remove or append it, always just moving it to the right fiber and appending the right children (heady/body) as needed. However in testing a simple approach in modern browsers it seems like treating the documentElement like any other element works fine. This change modifies the clearContainer method to remove the documentElement if the container is a DOCUMENT_NODE. Once the container is cleared React can append a new documentElement via normal means.
    
    * Allow Document as container for createRoot
    
    previously rendering into Document was broken and only hydration worked because React did not properly deal with the documentElement and would error in a broken state if used that way. With the previous commit addressing this limitation this change re-adds Document as a valid container for createRoot.
    
    It should be noted that if you use document with createRoot it will drop anything a 3rd party scripts adds the page before rendering for the first time.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 55c340be7d..49084d0f9b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -164,7 +164,7 @@ ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = funct
 };
 
 export function createRoot(
-  container: Element | DocumentFragment,
+  container: Element | Document | DocumentFragment,
   options?: CreateRootOptions,
 ): RootType {
   if (!isValidContainer(container)) {

commit f629495199791ce2811661ab50c37aac7898f862
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Wed Jul 13 15:27:12 2022 -0400

    [Transition Tracing] Rename transitionCallbacks to unstable_transitionCallbacks  (#24920)
    
    Renaming transitionCallbacks to unstable_transitionCallbacks as per convention

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 49084d0f9b..ed3faa9381 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -26,9 +26,9 @@ export type RootType = {
 export type CreateRootOptions = {
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
+  unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
-  transitionCallbacks?: TransitionTracingCallbacks,
   ...
 };
 
@@ -216,8 +216,8 @@ export function createRoot(
     if (options.onRecoverableError !== undefined) {
       onRecoverableError = options.onRecoverableError;
     }
-    if (options.transitionCallbacks !== undefined) {
-      transitionCallbacks = options.transitionCallbacks;
+    if (options.unstable_transitionCallbacks !== undefined) {
+      transitionCallbacks = options.unstable_transitionCallbacks;
     }
   }
 

commit 6daf600609e7699106673b37b507097bc2ea5139
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Mon Jul 18 13:22:47 2022 -0400

    add transistion callbacks to hydrateRoot (#24937)
    
    This PR adds transition callbacks to hydrateRoot.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ed3faa9381..c522d91f21 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -40,6 +40,7 @@ export type HydrateRootOptions = {
   // Options for all roots
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
+  unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
   ...
@@ -282,6 +283,7 @@ export function hydrateRoot(
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
   let onRecoverableError = defaultOnRecoverableError;
+  let transitionCallbacks = null;
   if (options !== null && options !== undefined) {
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
@@ -298,6 +300,9 @@ export function hydrateRoot(
     if (options.onRecoverableError !== undefined) {
       onRecoverableError = options.onRecoverableError;
     }
+    if (options.unstable_transitionCallbacks !== undefined) {
+      transitionCallbacks = options.unstable_transitionCallbacks;
+    }
   }
 
   const root = createHydrationContainer(
@@ -310,8 +315,7 @@ export function hydrateRoot(
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
     onRecoverableError,
-    // TODO(luna) Support hydration later
-    null,
+    transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.

commit 796d31809b3683083d3b62ccbab4f00dec8ffb1f
Author: Josh Story <story@hey.com>
Date:   Fri Aug 12 13:27:53 2022 -0700

    Implement basic stylesheet Resources for react-dom (#25060)
    
    Implement basic support for "Resources". In the context of this commit, the only thing that is currently a Resource are
    
    <link rel="stylesheet" precedence="some-value" ...>
    
    Resources can be rendered anywhere in the react tree, even outside of normal parenting rules, for instance you can render a resource before you have rendered the <html><head> tags for your application. In the stream we reorder this so the browser always receives valid HTML and resources are emitted either in place (normal circumstances) or at the top of the <head> (when you render them above or before the <head> in your react tree)
    
    On the client, resources opt into an entirely different hydration path. Instead of matching the location within the Document these resources are queried for in the entire document. It is an error to have more than one resource with the same href attribute.
    
    The use of precedence here as an opt-in signal for resourcifying the link is in preparation for a more complete Resource implementation which will dedupe resource references (multiple will be valid), hoist to the appropriate container (body, head, or elsewhere), order (according to precedence) and Suspend boundaries that depend on them. More details will come in the coming weeks on this plan.
    
    This feature is gated by an experimental flag and will only be made available in experimental builds until some future time.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index c522d91f21..9fbed21bd1 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -15,6 +15,7 @@ import type {
 
 import {queueExplicitHydrationTarget} from '../events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
+import {enableFloat} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -118,7 +119,7 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = functio
 
     const container = root.containerInfo;
 
-    if (container.nodeType !== COMMENT_NODE) {
+    if (!enableFloat && container.nodeType !== COMMENT_NODE) {
       const hostInstance = findHostInstanceWithNoPortals(root.current);
       if (hostInstance) {
         if (hostInstance.parentNode !== container) {

commit 97d75c9c8bcddb0daed1ed062101c7f5e9b825f4
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Sep 28 19:05:50 2022 -0400

    Move react-dom implementation files to react-dom-bindings (#25345)
    
    This lets us share it with react-server-dom-webpack while still having a
    dependency on react-dom. It also makes somewhat sense from a bundling
    perspective since react-dom is an external to itself.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9fbed21bd1..cea9be01a3 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,7 +13,7 @@ import type {
   TransitionTracingCallbacks,
 } from 'react-reconciler/src/ReactInternalTypes';
 
-import {queueExplicitHydrationTarget} from '../events/ReactDOMEventReplaying';
+import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {enableFloat} from 'shared/ReactFeatureFlags';
 
@@ -51,14 +51,14 @@ import {
   isContainerMarkedAsRoot,
   markContainerAsRoot,
   unmarkContainerAsRoot,
-} from './ReactDOMComponentTree';
-import {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';
+} from 'react-dom-bindings/src/client/ReactDOMComponentTree';
+import {listenToAllSupportedEvents} from 'react-dom-bindings/src/events/DOMPluginEventSystem';
 import {
   ELEMENT_NODE,
   COMMENT_NODE,
   DOCUMENT_NODE,
   DOCUMENT_FRAGMENT_NODE,
-} from '../shared/HTMLNodeType';
+} from 'react-dom-bindings/src/shared/HTMLNodeType';
 
 import {
   createContainer,

commit 7b25b961df878109a2b3810f33815249cae37ecc
Author: Josh Story <story@hey.com>
Date:   Fri Sep 30 16:14:04 2022 -0700

    [Fizz/Float] Float for stylesheet resources (#25243)
    
    * [Fizz/Float] Float for stylesheet resources
    
    This commit implements Float in Fizz and on the Client. The initial set of supported APIs is roughly
    
    1. Convert certain stylesheets into style Resources when opting in with precedence prop
    2. Emit preloads for stylesheets and explicit preload tags
    3. Dedupe all Resources by href
    4. Implement ReactDOM.preload() to allow for imperative preloading
    5. Implement ReactDOM.preinit() to allow for imperative preinitialization
    
    Currently supports
    1. style Resources (link rel "stylesheet")
    2. font Resources (preload as "font")
    
    later updates will include support for scripts and modules

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index cea9be01a3..9926346128 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,6 +13,9 @@ import type {
   TransitionTracingCallbacks,
 } from 'react-reconciler/src/ReactInternalTypes';
 
+import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
+const {Dispatcher} = ReactDOMSharedInternals;
+import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMFloatClient';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {enableFloat} from 'shared/ReactFeatureFlags';
@@ -235,6 +238,10 @@ export function createRoot(
   );
   markContainerAsRoot(root.current, container);
 
+  if (enableFloat) {
+    // Set the default dispatcher to the client dispatcher
+    Dispatcher.current = ReactDOMClientDispatcher;
+  }
   const rootContainerElement: Document | Element | DocumentFragment =
     container.nodeType === COMMENT_NODE
       ? (container.parentNode: any)
@@ -319,6 +326,10 @@ export function hydrateRoot(
     transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
+  if (enableFloat) {
+    // Set the default dispatcher to the client dispatcher
+    Dispatcher.current = ReactDOMClientDispatcher;
+  }
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 

commit 72593f008ec2011104d78b460dd287e7dfcac838
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Oct 4 13:25:17 2022 -0400

    Flow upgrade to 0.176
    
    This upgrade deprecated calling `new` on functions which introduced
    the majority of breakages and I suppressed those.
    
    ghstack-source-id: 545363f3c5b9f0327ac53fdea56a582d6cc29d72
    Pull Request resolved: https://github.com/facebook/react/pull/25418

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9926346128..13498ae1fa 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -248,6 +248,7 @@ export function createRoot(
       : container;
   listenToAllSupportedEvents(rootContainerElement);
 
+  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions
   return new ReactDOMRoot(root);
 }
 
@@ -340,6 +341,7 @@ export function hydrateRoot(
     }
   }
 
+  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions
   return new ReactDOMHydrationRoot(root);
 }
 

commit 9813edef2964d5d01308540e4eb7804dfc95425f
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Oct 4 15:39:26 2022 -0400

    Flow upgrade to 0.188
    
    ghstack-source-id: 5c359b97cc0a2587cf55ff879c863415a2c13127
    Pull Request resolved: https://github.com/facebook/react/pull/25423

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 13498ae1fa..ddd52b7686 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -94,6 +94,7 @@ function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }
 
+// $FlowFixMe[prop-missing] found when upgrading Flow
 ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
@@ -139,6 +140,7 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = functio
   updateContainer(children, root, null, null);
 };
 
+// $FlowFixMe[prop-missing] found when upgrading Flow
 ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
@@ -260,6 +262,7 @@ function scheduleHydration(target: Node) {
     queueExplicitHydrationTarget(target);
   }
 }
+// $FlowFixMe[prop-missing] found when upgrading Flow
 ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
 
 export function hydrateRoot(

commit 2cf4352e1c81a5b8c3528519a128c20e8e65531d
Author: Josh Story <story@hey.com>
Date:   Tue Oct 11 08:42:42 2022 -0700

    Implement HostSingleton Fiber type (#25426)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ddd52b7686..1fc2e71eb8 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -18,7 +18,7 @@ const {Dispatcher} = ReactDOMSharedInternals;
 import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMFloatClient';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
-import {enableFloat} from 'shared/ReactFeatureFlags';
+import {enableFloat, enableHostSingletons} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -123,7 +123,11 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = functio
 
     const container = root.containerInfo;
 
-    if (!enableFloat && container.nodeType !== COMMENT_NODE) {
+    if (
+      !enableFloat &&
+      !enableHostSingletons &&
+      container.nodeType !== COMMENT_NODE
+    ) {
       const hostInstance = findHostInstanceWithNoPortals(root.current);
       if (hostInstance) {
         if (hostInstance.parentNode !== container) {

commit 9fb581c7cc9b08a776d440254048734c3ffec78c
Author: c0dedance <38075730+c0dedance@users.noreply.github.com>
Date:   Mon Oct 17 09:58:58 2022 +0800

    Refactor: merge duplicate imports (#25489)
    
    Co-authored-by: Jan Kassens <jan@kassens.net>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 1fc2e71eb8..4040a1ef3b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -18,7 +18,12 @@ const {Dispatcher} = ReactDOMSharedInternals;
 import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMFloatClient';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
-import {enableFloat, enableHostSingletons} from 'shared/ReactFeatureFlags';
+import {
+  enableFloat,
+  enableHostSingletons,
+  allowConcurrentByDefault,
+  disableCommentsAsDOMContainers,
+} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -73,10 +78,6 @@ import {
   isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
-import {
-  allowConcurrentByDefault,
-  disableCommentsAsDOMContainers,
-} from 'shared/ReactFeatureFlags';
 
 /* global reportError */
 const defaultOnRecoverableError =

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 4040a1ef3b..a4b901d156 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 420f0b7fa1fcc609fc7b438c4599d0f76fab4bc0
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:06:25 2022 -0500

    Remove Reconciler fork (1/2) (#25774)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **This PR**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **#25775**
    - rename `*.old` files

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index a4b901d156..a2b4994952 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -76,7 +76,7 @@ import {
   registerMutableSourceForHydration,
   flushSync,
   isAlreadyRendering,
-} from 'react-reconciler/src/ReactFiberReconciler';
+} from 'react-reconciler/src/ReactFiberReconciler.old';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 
 /* global reportError */

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index a2b4994952..a4b901d156 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -76,7 +76,7 @@ import {
   registerMutableSourceForHydration,
   flushSync,
   isAlreadyRendering,
-} from 'react-reconciler/src/ReactFiberReconciler.old';
+} from 'react-reconciler/src/ReactFiberReconciler';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 
 /* global reportError */

commit 0b4f443020af386f2b48c47c074cb504ed672dc8
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jan 9 15:46:48 2023 -0500

    [flow] enable enforce_local_inference_annotations (#25921)
    
    This setting is an incremental path to the next Flow version enforcing
    type annotations on most functions (except some inline callbacks).
    
    Used
    ```
    node_modules/.bin/flow codemod annotate-functions-and-classes --write .
    ```
    to add a majority of the types with some hand cleanup when for large
    inferred objects that should just be `Fiber` or weird constructs
    including `any`.
    
    Suppressed the remaining issues.
    
    Builds on #25918

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index a4b901d156..12f62e2f1c 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -91,11 +91,13 @@ const defaultOnRecoverableError =
         console['error'](error);
       };
 
+// $FlowFixMe[missing-this-annot]
 function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }
 
 // $FlowFixMe[prop-missing] found when upgrading Flow
+// $FlowFixMe[missing-this-annot]
 ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(
   children: ReactNodeList,
 ): void {
@@ -146,6 +148,7 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = functio
 };
 
 // $FlowFixMe[prop-missing] found when upgrading Flow
+// $FlowFixMe[missing-this-annot]
 ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(): void {
   if (__DEV__) {
     if (typeof arguments[0] === 'function') {
@@ -259,6 +262,7 @@ export function createRoot(
   return new ReactDOMRoot(root);
 }
 
+// $FlowFixMe[missing-this-annot]
 function ReactDOMHydrationRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
 }

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 12f62e2f1c..08b849f21f 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -97,86 +97,86 @@ function ReactDOMRoot(internalRoot: FiberRoot) {
 }
 
 // $FlowFixMe[prop-missing] found when upgrading Flow
-// $FlowFixMe[missing-this-annot]
-ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(
-  children: ReactNodeList,
-): void {
-  const root = this._internalRoot;
-  if (root === null) {
-    throw new Error('Cannot update an unmounted root.');
-  }
-
-  if (__DEV__) {
-    if (typeof arguments[1] === 'function') {
-      console.error(
-        'render(...): does not support the second callback argument. ' +
-          'To execute a side effect after rendering, declare it in a component body with useEffect().',
-      );
-    } else if (isValidContainer(arguments[1])) {
-      console.error(
-        'You passed a container to the second argument of root.render(...). ' +
-          "You don't need to pass it again since you already passed it to create the root.",
-      );
-    } else if (typeof arguments[1] !== 'undefined') {
-      console.error(
-        'You passed a second argument to root.render(...) but it only accepts ' +
-          'one argument.',
-      );
+ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
+  // $FlowFixMe[missing-this-annot]
+  function (children: ReactNodeList): void {
+    const root = this._internalRoot;
+    if (root === null) {
+      throw new Error('Cannot update an unmounted root.');
     }
 
-    const container = root.containerInfo;
+    if (__DEV__) {
+      if (typeof arguments[1] === 'function') {
+        console.error(
+          'render(...): does not support the second callback argument. ' +
+            'To execute a side effect after rendering, declare it in a component body with useEffect().',
+        );
+      } else if (isValidContainer(arguments[1])) {
+        console.error(
+          'You passed a container to the second argument of root.render(...). ' +
+            "You don't need to pass it again since you already passed it to create the root.",
+        );
+      } else if (typeof arguments[1] !== 'undefined') {
+        console.error(
+          'You passed a second argument to root.render(...) but it only accepts ' +
+            'one argument.',
+        );
+      }
 
-    if (
-      !enableFloat &&
-      !enableHostSingletons &&
-      container.nodeType !== COMMENT_NODE
-    ) {
-      const hostInstance = findHostInstanceWithNoPortals(root.current);
-      if (hostInstance) {
-        if (hostInstance.parentNode !== container) {
-          console.error(
-            'render(...): It looks like the React-rendered content of the ' +
-              'root container was removed without using React. This is not ' +
-              'supported and will cause errors. Instead, call ' +
-              "root.unmount() to empty a root's container.",
-          );
+      const container = root.containerInfo;
+
+      if (
+        !enableFloat &&
+        !enableHostSingletons &&
+        container.nodeType !== COMMENT_NODE
+      ) {
+        const hostInstance = findHostInstanceWithNoPortals(root.current);
+        if (hostInstance) {
+          if (hostInstance.parentNode !== container) {
+            console.error(
+              'render(...): It looks like the React-rendered content of the ' +
+                'root container was removed without using React. This is not ' +
+                'supported and will cause errors. Instead, call ' +
+                "root.unmount() to empty a root's container.",
+            );
+          }
         }
       }
     }
-  }
-  updateContainer(children, root, null, null);
-};
+    updateContainer(children, root, null, null);
+  };
 
 // $FlowFixMe[prop-missing] found when upgrading Flow
-// $FlowFixMe[missing-this-annot]
-ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(): void {
-  if (__DEV__) {
-    if (typeof arguments[0] === 'function') {
-      console.error(
-        'unmount(...): does not support a callback argument. ' +
-          'To execute a side effect after rendering, declare it in a component body with useEffect().',
-      );
-    }
-  }
-  const root = this._internalRoot;
-  if (root !== null) {
-    this._internalRoot = null;
-    const container = root.containerInfo;
+ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
+  // $FlowFixMe[missing-this-annot]
+  function (): void {
     if (__DEV__) {
-      if (isAlreadyRendering()) {
+      if (typeof arguments[0] === 'function') {
         console.error(
-          'Attempted to synchronously unmount a root while React was already ' +
-            'rendering. React cannot finish unmounting the root until the ' +
-            'current render has completed, which may lead to a race condition.',
+          'unmount(...): does not support a callback argument. ' +
+            'To execute a side effect after rendering, declare it in a component body with useEffect().',
         );
       }
     }
-    flushSync(() => {
-      updateContainer(null, root, null, null);
-    });
-    unmarkContainerAsRoot(container);
-  }
-};
+    const root = this._internalRoot;
+    if (root !== null) {
+      this._internalRoot = null;
+      const container = root.containerInfo;
+      if (__DEV__) {
+        if (isAlreadyRendering()) {
+          console.error(
+            'Attempted to synchronously unmount a root while React was already ' +
+              'rendering. React cannot finish unmounting the root until the ' +
+              'current render has completed, which may lead to a race condition.',
+          );
+        }
+      }
+      flushSync(() => {
+        updateContainer(null, root, null, null);
+      });
+      unmarkContainerAsRoot(container);
+    }
+  };
 
 export function createRoot(
   container: Element | Document | DocumentFragment,

commit 6396b664118442f3c2eae7bf13732fcb27bda98f
Author: Josh Story <story@hey.com>
Date:   Thu Feb 9 22:59:29 2023 -0800

    Model Float on Hoistables semantics (#26106)
    
    ## Hoistables
    
    In the original implementation of Float, all hoisted elements were
    treated like Resources. They had deduplication semantics and hydrated
    based on a key. This made certain kinds of hoists very challenging such
    as sequences of meta tags for `og:image:...` metadata. The reason is
    each tag along is not dedupable based on only it's intrinsic properties.
    two identical tags may need to be included and hoisted together with
    preceding meta tags that describe a semantic object with a linear set of
    html nodes.
    
    It was clear that the concept of Browser Resources (stylesheets /
    scripts / preloads) did not extend universally to all hositable tags
    (title, meta, other links, etc...)
    
    Additionally while Resources benefit from deduping they suffer an
    inability to update because while we may have multiple rendered elements
    that refer to a single Resource it isn't unambiguous which element owns
    the props on the underlying resource. We could try merging props, but
    that is still really hard to reason about for authors. Instead we
    restrict Resource semantics to freezing the props at the time the
    Resource is first constructed and warn if you attempt to render the same
    Resource with different props via another rendered element or by
    updating an existing element for that Resource.
    
    This lack of updating restriction is however way more extreme than
    necessary for instances that get hoisted but otherwise do not dedupe;
    where there is a well defined DOM instance for each rendered element. We
    should be able to update props on these instances.
    
    Hoistable is a generalization of what Float tries to model for hoisting.
    Instead of assuming every hoistable element is a Resource we now have
    two distinct categories, hoistable elements and hoistable resources. As
    one might guess the former has semantics that match regular Host
    Components except the placement of the node is usually in the <head>.
    The latter continues to behave how the original implementation of
    HostResource behaved with the first iteration of Float
    
    ### Hoistable Element
    On the server hoistable elements render just like regular tags except
    the output is stored in special queues that can be emitted in the stream
    earlier than they otherwise would be if rendered in place. This also
    allow for instance the ability to render a hoistable before even
    rendering the <html> tag because the queues for hoistable elements won't
    flush until after we have flushed the preamble (`<DOCTYPE
    html><html><head>`).
    
    On the client, hoistable elements largely operate like HostComponents.
    The most notable difference is in the hydration strategy. If we are
    hydrating and encounter a hoistable element we will look for all tags in
    the document that could potentially be a match and we check whether the
    attributes match the props for this particular instance. We also do this
    in the commit phase rather than the render phase. The reason hydration
    can be done for HostComponents in render is the instance will be removed
    from the document if hydration fails so mutating it in render is safe.
    For hoistables the nodes are not in a hydration boundary (Root or
    SuspenseBoundary at time of writing) and thus if hydration fails and we
    may have an instance marked as bound to some Fiber when that Fiber never
    commits. Moving the hydration matching to commit ensures we will always
    succeed in pairing the hoisted DOM instance with a Fiber that has
    committed.
    
    ### Hoistable Resource
    On the server and client the semantics of Resources are largely the same
    they just don't apply to title, meta, and most link tags anymore.
    Resources hoist and dedupe via an `href` key and are ref counted. In a
    future update we will add a garbage collector so we can clean up
    Resources that no longer have any references
    
    ## `<style>` support
    In earlier implementations there was no support for <style> tags. This
    PR adds support for treating `<style href="..."
    precedence="...">...</style>` as a Resource analagous to `<link
    rel="stylesheet" href="..." precedence="..." />`
    
    It may seem odd at first to require an href to get Resource semantics
    for a style tag. The rationale is that these are for inlining of actual
    external stylesheets as an optimization and for URI like scoping of
    inline styles for css-in-js libraries. The href indicates that the key
    space for `<style>` and `<link rel="stylesheet" />` Resources is shared.
    and the precedence is there to allow for interleaving of both kinds of
    Style resources. This is an advanced feature that we do not expect most
    app developers to use directly but will be quite handy for various
    styling libraries and for folks who want to inline as much as possible
    once Fizz supports this feature.
    
    ## refactor notes
    * HostResource Fiber type is renamed HostHoistable to reflect the
    generalization of the concept
    * The Resource object representation is modified to reduce hidden class
    checks and to use less memory overall
    * The thing that distinguishes a resource from an element is whether the
    Fiber has a memoizedState. If it does, it will use resource semantics,
    otherwise element semantics
    * The time complexity of matching hositable elements for hydration
    should be improved

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 08b849f21f..2737a14cce 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -385,6 +385,7 @@ export function isValidContainerLegacy(node: any): boolean {
 function warnIfReactDOMContainerInDEV(container: any) {
   if (__DEV__) {
     if (
+      !enableHostSingletons &&
       container.nodeType === ELEMENT_NODE &&
       ((container: any): Element).tagName &&
       ((container: any): Element).tagName.toUpperCase() === 'BODY'

commit 21aee59e454a875f872ca666d6eb2694425e52af
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 14 19:52:57 2023 -0400

    Delete unused DOM files (#26387)
    
    These used to be used by partial render.
    
    ReactDOMDispatcher ended up not being used in this way.
    
    Move shared DOM files to client. These are only used by client
    abstractions now. They're inlined in the Fizz code so they're no longer
    shared.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 2737a14cce..eebae0b50b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -66,7 +66,7 @@ import {
   COMMENT_NODE,
   DOCUMENT_NODE,
   DOCUMENT_FRAGMENT_NODE,
-} from 'react-dom-bindings/src/shared/HTMLNodeType';
+} from 'react-dom-bindings/src/client/HTMLNodeType';
 
 import {
   createContainer,

commit 73b6435ca4e0c3ae3aac8126509a82420a84f0d7
Author: Josh Story <story@hey.com>
Date:   Fri Mar 24 19:17:38 2023 -0700

    [Float][Fiber] Implement waitForCommitToBeReady for stylesheet resources (#26450)
    
    Before a commit is finished if any new stylesheet resources are going to
    mount and we are capable of delaying the commit we will do the following
    
    1. Wait for all preloads for newly created stylesheet resources to load
    2. Once all preloads are finished we insert the stylesheet instances for
    these resources and wait for them all to load
    3. Once all stylesheets have loaded we complete the commit
    
    In this PR I also removed the synchronous loadingstate tracking in the
    fizz runtime. It was not necessary to support the implementation on not
    used by the fizz runtime itself. It makes the inline script slightly
    smaller
    
    In this PR I also integrated ReactDOMFloatClient with
    ReactDOMHostConfig. It leads to better code factoring, something I
    already did on the server a while back. To make the diff a little easier
    to follow i make these changes in a single commit so you can look at the
    change after that commit if helpful
    
    There is a 500ms timeout which will finish the commit even if all
    suspended host instances have not finished loading yet
    
    At the moment error and load events are treated the same and we're
    really tracking whether the host instance is finished attempting to
    load.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index eebae0b50b..96d32f8622 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -15,7 +15,7 @@ import type {
 
 import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
 const {Dispatcher} = ReactDOMSharedInternals;
-import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMFloatClient';
+import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMHostConfig';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {

commit b55d31955982851284bb437a5187a6c56e366539
Author: Josh Story <story@hey.com>
Date:   Mon Apr 10 14:58:44 2023 -0700

    Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)
    
    part of https://github.com/facebook/react/pull/26571
    
    merging separately to improve tracking of files renames in git
    
    Rename HostConfig files to FiberConfig to clarify they are configs for
    Fiber and not Fizz/Flight. This better conforms to the naming used in
    Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 96d32f8622..b0f53ccdf0 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -15,7 +15,7 @@ import type {
 
 import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
 const {Dispatcher} = ReactDOMSharedInternals;
-import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactDOMHostConfig';
+import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactFiberConfigDOM';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {

commit fdad813ac765e901e2957b8d36fba87e5504e5f4
Author: Josh Story <story@hey.com>
Date:   Thu Apr 20 14:40:25 2023 -0700

    [Float][Fiber] Enable Float methods to be called outside of render (#26557)
    
    Stacked on #26570
    
    Previously we restricted Float methods to only being callable while
    rendering. This allowed us to make associations between calls and their
    position in the DOM tree, for instance hoisting preinitialized styles
    into a ShadowRoot or an iframe Document.
    
    When considering how we are going to support Flight support in Float
    however it became clear that this restriction would lead to compromises
    on the implementation because the Flight client does not execute within
    the context of a client render. We want to be able to disaptch Float
    directives coming from Flight as soon as possible and this requires
    being able to call them outside of render.
    
    this patch modifies Float so that its methods are callable anywhere. The
    main consequence of this change is Float will always use the Document
    the renderer script is running within as the HoistableRoot. This means
    if you preinit as style inside a component render targeting a ShadowRoot
    the style will load in the ownerDocument not the ShadowRoot. Practially
    speaking it means that preinit is not useful inside ShadowRoots and
    iframes.
    
    This tradeoff was deemed acceptable because these methods are
    optimistic, not critical. Additionally, the other methods, preconntect,
    prefetchDNS, and preload, are not impacted because they already operated
    at the level of the ownerDocument and really only interface with the
    Network cache layer.
    
    I added a couple additional fixes that were necessary for getting tests
    to pass that are worth considering separately.
    
    The first commit improves the diff for `waitForThrow` so it compares
    strings if possible.
    
    The second commit makes invokeGuardedCallback not use metaprogramming
    pattern and swallows any novel errors produced from trying to run the
    guarded callback. Swallowing may not be the best we can do but it at
    least protects React against rapid failure when something causes the
    dispatchEvent to throw.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index b0f53ccdf0..e79fa16452 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -247,11 +247,8 @@ export function createRoot(
     transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
+  Dispatcher.current = ReactDOMClientDispatcher;
 
-  if (enableFloat) {
-    // Set the default dispatcher to the client dispatcher
-    Dispatcher.current = ReactDOMClientDispatcher;
-  }
   const rootContainerElement: Document | Element | DocumentFragment =
     container.nodeType === COMMENT_NODE
       ? (container.parentNode: any)
@@ -339,10 +336,7 @@ export function hydrateRoot(
     transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
-  if (enableFloat) {
-    // Set the default dispatcher to the client dispatcher
-    Dispatcher.current = ReactDOMClientDispatcher;
-  }
+  Dispatcher.current = ReactDOMClientDispatcher;
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 

commit 36e4cbe2e918ec9c8a7abbfda28898c835361fb2
Author: Josh Story <story@hey.com>
Date:   Fri Apr 21 20:45:51 2023 -0700

    [Float][Flight] Flight support for Float (#26502)
    
    Stacked on #26557
    
    Supporting Float methods such as ReactDOM.preload() are challenging for
    flight because it does not have an easy means to convey direct
    executions in other environments. Because the flight wire format is a
    JSON-like serialization that is expected to be rendered it currently
    only describes renderable elements. We need a way to convey a function
    invocation that gets run in the context of the client environment
    whether that is Fizz or Fiber.
    
    Fiber is somewhat straightforward because the HostDispatcher is always
    active and we can just have the FlightClient dispatch the serialized
    directive.
    
    Fizz is much more challenging becaue the dispatcher is always scoped but
    the specific request the dispatch belongs to is not readily available.
    Environments that support AsyncLocalStorage (or in the future
    AsyncContext) we will use this to be able to resolve directives in Fizz
    to the appropriate Request. For other environments directives will be
    elided. Right now this is pragmatic and non-breaking because all
    directives are opportunistic and non-critical. If this changes in the
    future we will need to reconsider how widespread support for async
    context tracking is.
    
    For Flight, if AsyncLocalStorage is available Float methods can be
    called before and after await points and be expected to work. If
    AsyncLocalStorage is not available float methods called in the sync
    phase of a component render will be captured but anything after an await
    point will be a noop. If a float call is dropped in this manner a DEV
    warning should help you realize your code may need to be modified.
    
    This PR also introduces a way for resources (Fizz) and hints (Flight) to
    flush even if there is not active task being worked on. This will help
    when Float methods are called in between async points within a function
    execution but the task is blocked on the entire function finishing.
    
    This PR also introduces deduping of Hints in Flight using the same
    resource keys used in Fizz. This will help shrink payload sizes when the
    same hint is attempted to emit over and over again

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index e79fa16452..2167175a90 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,8 +13,6 @@ import type {
   TransitionTracingCallbacks,
 } from 'react-reconciler/src/ReactInternalTypes';
 
-import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
-const {Dispatcher} = ReactDOMSharedInternals;
 import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactFiberConfigDOM';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
@@ -25,13 +23,19 @@ import {
   disableCommentsAsDOMContainers,
 } from 'shared/ReactFeatureFlags';
 
+import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
+const {Dispatcher} = ReactDOMSharedInternals;
+if (enableFloat && typeof document !== 'undefined') {
+  // Set the default dispatcher to the client dispatcher
+  Dispatcher.current = ReactDOMClientDispatcher;
+}
+
 export type RootType = {
   render(children: ReactNodeList): void,
   unmount(): void,
   _internalRoot: FiberRoot | null,
   ...
 };
-
 export type CreateRootOptions = {
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,

commit 80d9a40114bb43c07d021e8254790852f450bd2b
Author: Noah Lemen <noah.lemen@gmail.com>
Date:   Tue Jun 27 12:45:46 2023 -0400

    Remove useMutableSource (#27011)
    
    ## Summary
    
    This PR cleans up `useMutableSource`. This has been blocked by a
    remaining dependency internally at Meta, but that has now been deleted.
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    ## How did you test this change?
    
    ```
    yarn flow
    yarn lint
    yarn test --prod
    ```
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 2167175a90..b55b09eb21 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -7,7 +7,7 @@
  * @flow
  */
 
-import type {MutableSource, ReactNodeList} from 'shared/ReactTypes';
+import type {ReactNodeList} from 'shared/ReactTypes';
 import type {
   FiberRoot,
   TransitionTracingCallbacks,
@@ -47,7 +47,6 @@ export type CreateRootOptions = {
 
 export type HydrateRootOptions = {
   // Hydration options
-  hydratedSources?: Array<MutableSource<any>>,
   onHydrated?: (suspenseNode: Comment) => void,
   onDeleted?: (suspenseNode: Comment) => void,
   // Options for all roots
@@ -77,7 +76,6 @@ import {
   createHydrationContainer,
   updateContainer,
   findHostInstanceWithNoPortals,
-  registerMutableSourceForHydration,
   flushSync,
   isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
@@ -298,8 +296,6 @@ export function hydrateRoot(
   // For now we reuse the whole bag of options since they contain
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;
-  // TODO: Delete this option
-  const mutableSources = (options != null && options.hydratedSources) || null;
 
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
@@ -344,13 +340,6 @@ export function hydrateRoot(
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 
-  if (mutableSources) {
-    for (let i = 0; i < mutableSources.length; i++) {
-      const mutableSource = mutableSources[i];
-      registerMutableSourceForHydration(root, mutableSource);
-    }
-  }
-
   // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions
   return new ReactDOMHydrationRoot(root);
 }

commit 612b2b6601abb844248c384d1e288bb824b180b7
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 13 18:30:40 2023 -0400

    useFormState: Reuse state from previous form submission (#27321)
    
    If a Server Action is passed to useFormState, the action may be
    submitted before it has hydrated. This will trigger a full page
    (MPA-style) navigation. We can transfer the form state to the next page
    by comparing the key path of the hook instance.
    
    `ReactServerDOMServer.decodeFormState` is used by the server to extract
    the form state from the submitted action. This value can then be passed
    as an option when rendering the new page. It must be passed during both
    SSR and hydration.
    
    ```js
    const boundAction = await decodeAction(formData, serverManifest);
    const result = await boundAction();
    const formState = decodeFormState(result, formData, serverManifest);
    
    // SSR
    const response = createFromReadableStream(<App />);
    const ssrStream = await renderToReadableStream(response, { formState })
    
    // Hydration
    hydrateRoot(container, <App />, { formState });
    ```
    
    If the `formState` option is omitted, then the state won't be
    transferred to the next page. However, it must be passed in both places,
    or in neither; misconfiguring will result in a hydration mismatch.
    
    (The `formState` option is currently prefixed with `experimental_`)

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index b55b09eb21..55bbc66279 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -7,7 +7,7 @@
  * @flow
  */
 
-import type {ReactNodeList} from 'shared/ReactTypes';
+import type {ReactNodeList, ReactFormState} from 'shared/ReactTypes';
 import type {
   FiberRoot,
   TransitionTracingCallbacks,
@@ -21,6 +21,8 @@ import {
   enableHostSingletons,
   allowConcurrentByDefault,
   disableCommentsAsDOMContainers,
+  enableAsyncActions,
+  enableFormActions,
 } from 'shared/ReactFeatureFlags';
 
 import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
@@ -55,6 +57,7 @@ export type HydrateRootOptions = {
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
+  experimental_formState?: ReactFormState<any> | null,
   ...
 };
 
@@ -302,6 +305,7 @@ export function hydrateRoot(
   let identifierPrefix = '';
   let onRecoverableError = defaultOnRecoverableError;
   let transitionCallbacks = null;
+  let formState = null;
   if (options !== null && options !== undefined) {
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
@@ -321,6 +325,11 @@ export function hydrateRoot(
     if (options.unstable_transitionCallbacks !== undefined) {
       transitionCallbacks = options.unstable_transitionCallbacks;
     }
+    if (enableAsyncActions && enableFormActions) {
+      if (options.experimental_formState !== undefined) {
+        formState = options.experimental_formState;
+      }
+    }
   }
 
   const root = createHydrationContainer(
@@ -334,6 +343,7 @@ export function hydrateRoot(
     identifierPrefix,
     onRecoverableError,
     transitionCallbacks,
+    formState,
   );
   markContainerAsRoot(root.current, container);
   Dispatcher.current = ReactDOMClientDispatcher;

commit 95c9554bc72813b0ee2b028774bb7cf0482887ba
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 13 20:46:22 2023 -0400

    useFormState: Compare action signatures when reusing form state (#27370)
    
    During an MPA form submission, useFormState should only reuse the form
    state if same action is passed both times. (We also compare the key
    paths.)
    
    We compare the identity of the inner closure function, disregarding the
    value of the bound arguments. That way you can pass an inline Server
    Action closure:
    
    ```js
    function FormContainer({maxLength}) {
      function submitAction(prevState, formData) {
        'use server'
        if (formData.get('field').length > maxLength) {
          return { errorMsg: 'Too many characters' };
        }
        // ...
      }
      return <Form submitAction={submitAction} />
    }
    ```

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 55bbc66279..3ce35d4a20 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -57,7 +57,7 @@ export type HydrateRootOptions = {
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
-  experimental_formState?: ReactFormState<any> | null,
+  experimental_formState?: ReactFormState<any, any> | null,
   ...
 };
 

commit 44d40a077ae91bbf5e18a95b90d8a15c2ec978ca
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Oct 4 15:17:37 2023 -0400

    Remove prefix from `formState` option (#27460)
    
    `useFormState` is now in canary.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 3ce35d4a20..ea36929cac 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -57,7 +57,7 @@ export type HydrateRootOptions = {
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
-  experimental_formState?: ReactFormState<any, any> | null,
+  formState?: ReactFormState<any, any> | null,
   ...
 };
 
@@ -326,8 +326,8 @@ export function hydrateRoot(
       transitionCallbacks = options.unstable_transitionCallbacks;
     }
     if (enableAsyncActions && enableFormActions) {
-      if (options.experimental_formState !== undefined) {
-        formState = options.experimental_formState;
+      if (options.formState !== undefined) {
+        formState = options.formState;
       }
     }
   }

commit 1a65d036ef057b07a6b15f5604e399f91bc5ed73
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Nov 16 17:42:03 2023 -0500

    [cleanup] remove enableHostSingletons feature flag (#27583)
    
    The flag is enabled everywhere, I think we can remove it now.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ea36929cac..0e3579eb37 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -18,7 +18,6 @@ import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactD
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {
   enableFloat,
-  enableHostSingletons,
   allowConcurrentByDefault,
   disableCommentsAsDOMContainers,
   enableAsyncActions,
@@ -78,7 +77,6 @@ import {
   createContainer,
   createHydrationContainer,
   updateContainer,
-  findHostInstanceWithNoPortals,
   flushSync,
   isAlreadyRendering,
 } from 'react-reconciler/src/ReactFiberReconciler';
@@ -127,26 +125,6 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
             'one argument.',
         );
       }
-
-      const container = root.containerInfo;
-
-      if (
-        !enableFloat &&
-        !enableHostSingletons &&
-        container.nodeType !== COMMENT_NODE
-      ) {
-        const hostInstance = findHostInstanceWithNoPortals(root.current);
-        if (hostInstance) {
-          if (hostInstance.parentNode !== container) {
-            console.error(
-              'render(...): It looks like the React-rendered content of the ' +
-                'root container was removed without using React. This is not ' +
-                'supported and will cause errors. Instead, call ' +
-                "root.unmount() to empty a root's container.",
-            );
-          }
-        }
-      }
     }
     updateContainer(children, root, null, null);
   };
@@ -381,20 +359,6 @@ export function isValidContainerLegacy(node: any): boolean {
 
 function warnIfReactDOMContainerInDEV(container: any) {
   if (__DEV__) {
-    if (
-      !enableHostSingletons &&
-      container.nodeType === ELEMENT_NODE &&
-      ((container: any): Element).tagName &&
-      ((container: any): Element).tagName.toUpperCase() === 'BODY'
-    ) {
-      console.error(
-        'createRoot(): Creating roots directly with document.body is ' +
-          'discouraged, since its children are often manipulated by third-party ' +
-          'scripts and browser extensions. This may lead to subtle ' +
-          'reconciliation issues. Try using a container element created ' +
-          'for your app.',
-      );
-    }
     if (isContainerMarkedAsRoot(container)) {
       if (container._reactRootContainer) {
         console.error(

commit f498aa299292d4d1e999f66d1c769440ad10d57c
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Dec 4 16:10:36 2023 -0500

    Flow: make more objects exact (#27790)
    
    This makes a couple objects more exact. Nothing critical, just noticed
    this old branch I had created when doing some Flow upgrades in the past.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 0e3579eb37..9b93ab6354 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -35,15 +35,14 @@ export type RootType = {
   render(children: ReactNodeList): void,
   unmount(): void,
   _internalRoot: FiberRoot | null,
-  ...
 };
+
 export type CreateRootOptions = {
   unstable_strictMode?: boolean,
   unstable_concurrentUpdatesByDefault?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
-  ...
 };
 
 export type HydrateRootOptions = {
@@ -57,7 +56,6 @@ export type HydrateRootOptions = {
   identifierPrefix?: string,
   onRecoverableError?: (error: mixed) => void,
   formState?: ReactFormState<any, any> | null,
-  ...
 };
 
 import {

commit d579e7748218920331252b0528850943d5e2dd31
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Feb 23 15:16:54 2024 -0500

    Remove method name prefix from warnings and errors (#28432)
    
    This pattern is a petpeeve of mine. I don't consider this best practice
    and so most don't have these prefixes. Very inconsistent.
    
    At best this is useless and noisey that you have to parse because the
    information is also in the stack trace.
    
    At worse these are misleading because they're highlighting something
    internal (like validateDOMNesting) which even suggests an internal bug.
    Even the ones public to React aren't necessarily what you called because
    you might be calling a wrapper around it.
    
    That would be properly reflected in a stack trace - which can also
    properly ignore list so that the first stack you see is your callsite,
    
    Which might be like `render()` in react-testing-library rather than
    `createRoot()` for example.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9b93ab6354..bbbde79e05 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -109,7 +109,7 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
     if (__DEV__) {
       if (typeof arguments[1] === 'function') {
         console.error(
-          'render(...): does not support the second callback argument. ' +
+          'does not support the second callback argument. ' +
             'To execute a side effect after rendering, declare it in a component body with useEffect().',
         );
       } else if (isValidContainer(arguments[1])) {
@@ -134,7 +134,7 @@ ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
     if (__DEV__) {
       if (typeof arguments[0] === 'function') {
         console.error(
-          'unmount(...): does not support a callback argument. ' +
+          'does not support a callback argument. ' +
             'To execute a side effect after rendering, declare it in a component body with useEffect().',
         );
       }
@@ -164,7 +164,7 @@ export function createRoot(
   options?: CreateRootOptions,
 ): RootType {
   if (!isValidContainer(container)) {
-    throw new Error('createRoot(...): Target container is not a DOM element.');
+    throw new Error('Target container is not a DOM element.');
   }
 
   warnIfReactDOMContainerInDEV(container);
@@ -258,7 +258,7 @@ export function hydrateRoot(
   options?: HydrateRootOptions,
 ): RootType {
   if (!isValidContainer(container)) {
-    throw new Error('hydrateRoot(...): Target container is not a DOM element.');
+    throw new Error('Target container is not a DOM element.');
   }
 
   warnIfReactDOMContainerInDEV(container);

commit 113ab9af08c46e8a548a397154f5c9dfeb96ab6a
Author: Josh Story <story@hey.com>
Date:   Mon Mar 4 12:27:15 2024 -0800

    [Flight][Fizz][Fiber] Chain HostDispatcher implementations (#28488)
    
    The idea here is that host dispatchers are not bound to renders so we
    need to be able to dispatch to them at any time. This updates the
    implementation to chain these dispatchers so that each renderer can
    respond to the dispatch. Semantically we don't always want every
    renderer to do this for instance if Fizz handles a float method we don't
    want Fiber to as well so each dispatcher implementation can decide if it
    makes sense to forward the call or not. For float methods server
    disaptchers will handle the call if they can resolve a Request otherwise
    they will forward. For client dispatchers they will handle the call and
    always forward. The choice needs to be made for each dispatcher method
    and may have implications on correct renderer import order. For now we
    just live with the restriction that if you want to use server and client
    together (such as renderToString in the browser) you need to import the
    server renderer after the client renderer.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index bbbde79e05..563fd6be1f 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,24 +13,15 @@ import type {
   TransitionTracingCallbacks,
 } from 'react-reconciler/src/ReactInternalTypes';
 
-import {ReactDOMClientDispatcher} from 'react-dom-bindings/src/client/ReactFiberConfigDOM';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {
-  enableFloat,
   allowConcurrentByDefault,
   disableCommentsAsDOMContainers,
   enableAsyncActions,
   enableFormActions,
 } from 'shared/ReactFeatureFlags';
 
-import ReactDOMSharedInternals from '../ReactDOMSharedInternals';
-const {Dispatcher} = ReactDOMSharedInternals;
-if (enableFloat && typeof document !== 'undefined') {
-  // Set the default dispatcher to the client dispatcher
-  Dispatcher.current = ReactDOMClientDispatcher;
-}
-
 export type RootType = {
   render(children: ReactNodeList): void,
   unmount(): void,
@@ -228,7 +219,6 @@ export function createRoot(
     transitionCallbacks,
   );
   markContainerAsRoot(root.current, container);
-  Dispatcher.current = ReactDOMClientDispatcher;
 
   const rootContainerElement: Document | Element | DocumentFragment =
     container.nodeType === COMMENT_NODE
@@ -322,7 +312,6 @@ export function hydrateRoot(
     formState,
   );
   markContainerAsRoot(root.current, container);
-  Dispatcher.current = ReactDOMClientDispatcher;
   // This can't be a comment node since hydration doesn't work on comment nodes anyway.
   listenToAllSupportedEvents(container);
 

commit 527ed72bfd9f5c0045da468ad01db968a9961ad7
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Mar 25 13:25:14 2024 -0400

    Cleanup enableFormActions flag (#28614)
    
    Cleanup enableFormActions flag

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 563fd6be1f..f963030c91 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -19,7 +19,6 @@ import {
   allowConcurrentByDefault,
   disableCommentsAsDOMContainers,
   enableAsyncActions,
-  enableFormActions,
 } from 'shared/ReactFeatureFlags';
 
 export type RootType = {
@@ -291,7 +290,7 @@ export function hydrateRoot(
     if (options.unstable_transitionCallbacks !== undefined) {
       transitionCallbacks = options.unstable_transitionCallbacks;
     }
-    if (enableAsyncActions && enableFormActions) {
+    if (enableAsyncActions) {
       if (options.formState !== undefined) {
         formState = options.formState;
       }

commit 6786563f3cbbc9b16d5a8187207b5bd904386e53
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 20:44:07 2024 -0700

    [Fiber] Don't Rethrow Errors at the Root (#28627)
    
    Stacked on top of #28498 for test fixes.
    
    ### Don't Rethrow
    
    When we started React it was 1:1 setState calls a series of renders and
    if they error, it errors where the setState was called. Simple. However,
    then batching came and the error actually got thrown somewhere else.
    With concurrent mode, it's not even possible to get setState itself to
    throw anymore.
    
    In fact, all APIs that can rethrow out of React are executed either at
    the root of the scheduler or inside a DOM event handler.
    If you throw inside a React.startTransition callback that's sync, then
    that will bubble out of the startTransition but if you throw inside an
    async callback or a useTransition we now need to handle it at the hook
    site. So in 19 we need to make all React.startTransition swallow the
    error (and report them to reportError).
    
    The only one remaining that can throw is flushSync but it doesn't really
    make sense for it to throw at the callsite neither because batching.
    Just because something rendered in this flush doesn't mean it was
    rendered due to what was just scheduled and doesn't mean that it should
    abort any of the remaining code afterwards. setState is fire and forget.
    It's send an instruction elsewhere, it's not part of the current
    imperative code.
    
    Error boundaries never rethrow. Since you should really always have
    error boundaries, most of the time, it wouldn't rethrow anyway.
    
    Rethrowing also actually currently drops errors on the floor since we
    can only rethrow the first error, so to avoid that we'd need to call
    reportError anyway. This happens in RN events.
    
    The other issue with rethrowing is that it logs an extra console.error.
    Since we're not sure that user code will actually log it anywhere we
    still log it too just like we do with errors inside error boundaries
    which leads all of these to log twice.
    The goal of this PR is to never rethrow out of React instead, errors
    outside of error boundaries get logged to reportError. Event system
    errors too.
    
    ### Breaking Changes
    
    The main thing this affects is testing where you want to inspect the
    errors thrown. To make it easier to port, if you're inside `act` we
    track the error into act in an aggregate error and then rethrow it at
    the root of `act`. Unlike before though, if you flush synchronously
    inside of act it'll still continue until the end of act before
    rethrowing.
    
    I expect most user code breakages would be to migrate from `flushSync`
    to `act` if you assert on throwing.
    
    However, in the React repo we also have `internalAct` and the
    `waitForThrow` helpers. Since these have to use public production
    implementations we track these using the global onerror or process
    uncaughtException. Unlike regular act, includes both event handler
    errors and onRecoverableError by default too. Not just render/commit
    errors. So I had to account for that in our tests.
    
    We restore logging an extra log for uncaught errors after the main log
    with the component stack in it. We use `console.warn`. This is not yet
    ignorable if you preventDefault to the main error event. To avoid
    confusion if you don't end up logging the error to console I just added
    `An error occurred`.
    
    ### Polyfill
    
    All browsers we support really supports `reportError` but not all test
    and server environments do, so I implemented a polyfill for browser and
    node in `shared/reportGlobalError`. I don't love that this is included
    in all builds and gets duplicated into isomorphic even though it's not
    actually needed in production. Maybe in the future we can require a
    polyfill for this.
    
    ### Follow Ups
    
    In a follow up, I'll make caught vs uncaught error handling be
    configurable too.
    
    ---------
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index f963030c91..119152e875 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -70,17 +70,11 @@ import {
 } from 'react-reconciler/src/ReactFiberReconciler';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 
-/* global reportError */
-const defaultOnRecoverableError =
-  typeof reportError === 'function'
-    ? // In modern browsers, reportError will dispatch an error event,
-      // emulating an uncaught JavaScript error.
-      reportError
-    : (error: mixed) => {
-        // In older browsers and test environments, fallback to console.error.
-        // eslint-disable-next-line react-internal/no-production-logging
-        console['error'](error);
-      };
+import reportGlobalError from 'shared/reportGlobalError';
+
+function defaultOnRecoverableError(error: mixed, errorInfo: any) {
+  reportGlobalError(error);
+}
 
 // $FlowFixMe[missing-this-annot]
 function ReactDOMRoot(internalRoot: FiberRoot) {

commit a0537160771bafae90c6fd3154eeead2f2c903e7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 21:51:37 2024 -0700

    Make onUncaughtError and onCaughtError Configurable (#28641)
    
    Stacked on #28627.
    
    This makes error logging configurable using these
    `createRoot`/`hydrateRoot` options:
    
    ```
    onUncaughtError(error: mixed, errorInfo: {componentStack?: ?string}) => void
    onCaughtError(error: mixed, errorInfo: {componentStack?: ?string, errorBoundary?: ?React.Component<any, any>}) => void
    onRecoverableError(error: mixed, errorInfo: {digest?: ?string, componentStack?: ?string}) => void
    ```
    
    We already have the `onRecoverableError` option since before.
    
    Overriding these can be used to implement custom error dialogs (with
    access to the `componentStack`).
    
    It can also be used to silence caught errors when testing an error
    boundary or if you prefer not getting logs for caught errors that you've
    already handled in an error boundary.
    
    I currently expose the error boundary instance but I think we should
    probably remove that since it doesn't make sense for non-class error
    boundaries and isn't very useful anyway. It's also unclear what it
    should do when an error is rethrown from one boundary to another.
    
    Since these are public APIs now we can implement the
    ReactFiberErrorDialog forks using these options at the roots of the
    builds. So I unforked those files and instead passed a custom option for
    the native and www builds.
    
    To do this I had to fork the ReactDOMLegacy file into ReactDOMRootFB
    which is a duplication but that will go away as soon as the FB fork is
    the only legacy root.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 119152e875..21b08b784e 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -32,7 +32,21 @@ export type CreateRootOptions = {
   unstable_concurrentUpdatesByDefault?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
-  onRecoverableError?: (error: mixed) => void,
+  onUncaughtError?: (
+    error: mixed,
+    errorInfo: {+componentStack?: ?string},
+  ) => void,
+  onCaughtError?: (
+    error: mixed,
+    errorInfo: {
+      +componentStack?: ?string,
+      +errorBoundary?: ?React$Component<any, any>,
+    },
+  ) => void,
+  onRecoverableError?: (
+    error: mixed,
+    errorInfo: {+digest?: ?string, +componentStack?: ?string},
+  ) => void,
 };
 
 export type HydrateRootOptions = {
@@ -44,7 +58,21 @@ export type HydrateRootOptions = {
   unstable_concurrentUpdatesByDefault?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
-  onRecoverableError?: (error: mixed) => void,
+  onUncaughtError?: (
+    error: mixed,
+    errorInfo: {+componentStack?: ?string},
+  ) => void,
+  onCaughtError?: (
+    error: mixed,
+    errorInfo: {
+      +componentStack?: ?string,
+      +errorBoundary?: ?React$Component<any, any>,
+    },
+  ) => void,
+  onRecoverableError?: (
+    error: mixed,
+    errorInfo: {+digest?: ?string, +componentStack?: ?string},
+  ) => void,
   formState?: ReactFormState<any, any> | null,
 };
 
@@ -67,15 +95,12 @@ import {
   updateContainer,
   flushSync,
   isAlreadyRendering,
+  defaultOnUncaughtError,
+  defaultOnCaughtError,
+  defaultOnRecoverableError,
 } from 'react-reconciler/src/ReactFiberReconciler';
 import {ConcurrentRoot} from 'react-reconciler/src/ReactRootTags';
 
-import reportGlobalError from 'shared/reportGlobalError';
-
-function defaultOnRecoverableError(error: mixed, errorInfo: any) {
-  reportGlobalError(error);
-}
-
 // $FlowFixMe[missing-this-annot]
 function ReactDOMRoot(internalRoot: FiberRoot) {
   this._internalRoot = internalRoot;
@@ -156,6 +181,8 @@ export function createRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
+  let onUncaughtError = defaultOnUncaughtError;
+  let onCaughtError = defaultOnCaughtError;
   let onRecoverableError = defaultOnRecoverableError;
   let transitionCallbacks = null;
 
@@ -193,6 +220,12 @@ export function createRoot(
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }
+    if (options.onUncaughtError !== undefined) {
+      onUncaughtError = options.onUncaughtError;
+    }
+    if (options.onCaughtError !== undefined) {
+      onCaughtError = options.onCaughtError;
+    }
     if (options.onRecoverableError !== undefined) {
       onRecoverableError = options.onRecoverableError;
     }
@@ -208,6 +241,8 @@ export function createRoot(
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
+    onUncaughtError,
+    onCaughtError,
     onRecoverableError,
     transitionCallbacks,
   );
@@ -262,6 +297,8 @@ export function hydrateRoot(
   let isStrictMode = false;
   let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
+  let onUncaughtError = defaultOnUncaughtError;
+  let onCaughtError = defaultOnCaughtError;
   let onRecoverableError = defaultOnRecoverableError;
   let transitionCallbacks = null;
   let formState = null;
@@ -278,6 +315,12 @@ export function hydrateRoot(
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }
+    if (options.onUncaughtError !== undefined) {
+      onUncaughtError = options.onUncaughtError;
+    }
+    if (options.onCaughtError !== undefined) {
+      onCaughtError = options.onCaughtError;
+    }
     if (options.onRecoverableError !== undefined) {
       onRecoverableError = options.onRecoverableError;
     }
@@ -300,6 +343,8 @@ export function hydrateRoot(
     isStrictMode,
     concurrentUpdatesByDefaultOverride,
     identifierPrefix,
+    onUncaughtError,
+    onCaughtError,
     onRecoverableError,
     transitionCallbacks,
     formState,

commit df95577db0d1d7ca383f281bc1d9e6ba5579bef2
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 30 18:32:20 2024 -0400

    Finish cleaning up digest from onRecoverableError (#28686)
    
    Don't need to track it separately on the captured value anymore.
    
    Shouldn't be in the types.
    
    I used a getter for the warning instead because Proxies are kind of
    heavy weight options for this kind of warning. We typically use getters.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 21b08b784e..9d24b0ba9e 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -45,7 +45,7 @@ export type CreateRootOptions = {
   ) => void,
   onRecoverableError?: (
     error: mixed,
-    errorInfo: {+digest?: ?string, +componentStack?: ?string},
+    errorInfo: {+componentStack?: ?string},
   ) => void,
 };
 
@@ -71,7 +71,7 @@ export type HydrateRootOptions = {
   ) => void,
   onRecoverableError?: (
     error: mixed,
-    errorInfo: {+digest?: ?string, +componentStack?: ?string},
+    errorInfo: {+componentStack?: ?string},
   ) => void,
   formState?: ReactFormState<any, any> | null,
 };

commit 4c12339ce3fa398050d1026c616ea43d43dcaf4a
Author: Josh Story <story@hey.com>
Date:   Mon Apr 8 09:03:20 2024 -0700

    [DOM] move `flushSync` out of the reconciler (#28500)
    
    This PR moves `flushSync` out of the reconciler. there is still an
    internal implementation that is used when these semantics are needed for
    React methods such as `unmount` on roots.
    
    This new isomorphic `flushSync` is only used in builds that no longer
    support legacy mode.
    
    Additionally all the internal uses of flushSync in the reconciler have
    been replaced with more direct methods. There is a new
    `updateContainerSync` method which updates a container but forces it to
    the Sync lane and flushes passive effects if necessary. This combined
    with flushSyncWork can be used to replace flushSync for all instances of
    internal usage.
    
    We still maintain the original flushSync implementation as
    `flushSyncFromReconciler` because it will be used as the flushSync
    implementation for FB builds. This is because it has special legacy mode
    handling that the new isomorphic implementation does not need to
    consider. It will be removed from production OSS builds by closure
    though

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 9d24b0ba9e..ef573f5f79 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -93,7 +93,8 @@ import {
   createContainer,
   createHydrationContainer,
   updateContainer,
-  flushSync,
+  updateContainerSync,
+  flushSyncWork,
   isAlreadyRendering,
   defaultOnUncaughtError,
   defaultOnCaughtError,
@@ -161,9 +162,8 @@ ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
           );
         }
       }
-      flushSync(() => {
-        updateContainer(null, root, null, null);
-      });
+      updateContainerSync(null, root, null, null);
+      flushSyncWork();
       unmarkContainerAsRoot(container);
     }
   };

commit cb151849e13f46ec64570519cb93d5939fb60cab
Author: Josh Story <story@hey.com>
Date:   Wed Apr 24 08:50:32 2024 -0700

    [react-dom] move all client code to `react-dom/client` (#28271)
    
    This PR reorganizes the `react-dom` entrypoint to only pull in code that
    is environment agnostic. Previously if you required anything from this
    entrypoint in any environment the entire client reconciler was loaded.
    In a prior release we added a server rendering stub which you could
    alias in server environments to omit this unecessary code. After landing
    this change this entrypoint should not load any environment specific
    code.
    
    While a few APIs are truly client (browser) only such as createRoot and
    hydrateRoot many of the APIs you import from this package are only
    useful in the browser but could concievably be imported in shared code
    (components running in Fizz or shared components as part of an RSC app).
    To avoid making these require opting into the client bundle we are
    keeping them in the `react-dom` entrypoint and changing their
    implementation so that in environments where they are not particularly
    useful they do something benign and expected.
    
    #### Removed APIs
    The following APIs are being removed in the next major. Largely they
    have all been deprecated already and are part of legacy rendering modes
    where concurrent features of React are not available
    * `render`
    * `hydrate`
    * `findDOMNode`
    * `unmountComponentAtNode`
    * `unstable_createEventHandle`
    * `unstable_renderSubtreeIntoContainer`
    * `unstable_runWithPrioirty`
    
    #### moved Client APIs
    These APIs were available on both `react-dom` (with a warning) and
    `react-dom/client`. After this change they are only available on
    `react-dom/client`
    * `createRoot`
    * `hydrateRoot`
    
    #### retained APIs
    These APIs still exist on the `react-dom` entrypoint but have normalized
    behavior depending on which renderers are currently in scope
    * `flushSync`: will execute the function (if provided) inside the
    flushSync implemention of FlightServer, Fizz, and Fiber DOM renderers.
    * `unstable_batchedUpdates`: This is a noop in concurrent mode because
    it is now the only supported behavior because there is no legacy
    rendering mode
    * `createPortal`: This just produces an object. It can be called from
    anywhere but since you will probably not have a handle on a DOM node to
    pass to it it will likely warn in environments other than the browser
    * preloading APIS such as `preload`: These methods will execute the
    preload across all renderers currently in scope. Since we resolve the
    Request object on the server using AsyncLocalStorage or the current
    function stack in practice only one renderer should act upon the
    preload.
    
    In addition to these changes the server rendering stub now just rexports
    everything from `react-dom`. In a future minor we will add a warning
    when using the stub and in the next major we will remove the stub
    altogether

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index ef573f5f79..aef8775de5 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -13,11 +13,11 @@ import type {
   TransitionTracingCallbacks,
 } from 'react-reconciler/src/ReactInternalTypes';
 
+import {isValidContainer} from 'react-dom-bindings/src/client/ReactDOMContainer';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 import {
   allowConcurrentByDefault,
-  disableCommentsAsDOMContainers,
   enableAsyncActions,
 } from 'shared/ReactFeatureFlags';
 
@@ -82,12 +82,7 @@ import {
   unmarkContainerAsRoot,
 } from 'react-dom-bindings/src/client/ReactDOMComponentTree';
 import {listenToAllSupportedEvents} from 'react-dom-bindings/src/events/DOMPluginEventSystem';
-import {
-  ELEMENT_NODE,
-  COMMENT_NODE,
-  DOCUMENT_NODE,
-  DOCUMENT_FRAGMENT_NODE,
-} from 'react-dom-bindings/src/client/HTMLNodeType';
+import {COMMENT_NODE} from 'react-dom-bindings/src/client/HTMLNodeType';
 
 import {
   createContainer,
@@ -357,31 +352,6 @@ export function hydrateRoot(
   return new ReactDOMHydrationRoot(root);
 }
 
-export function isValidContainer(node: any): boolean {
-  return !!(
-    node &&
-    (node.nodeType === ELEMENT_NODE ||
-      node.nodeType === DOCUMENT_NODE ||
-      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
-      (!disableCommentsAsDOMContainers &&
-        node.nodeType === COMMENT_NODE &&
-        (node: any).nodeValue === ' react-mount-point-unstable '))
-  );
-}
-
-// TODO: Remove this function which also includes comment nodes.
-// We only use it in places that are currently more relaxed.
-export function isValidContainerLegacy(node: any): boolean {
-  return !!(
-    node &&
-    (node.nodeType === ELEMENT_NODE ||
-      node.nodeType === DOCUMENT_NODE ||
-      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
-      (node.nodeType === COMMENT_NODE &&
-        (node: any).nodeValue === ' react-mount-point-unstable '))
-  );
-}
-
 function warnIfReactDOMContainerInDEV(container: any) {
   if (__DEV__) {
     if (isContainerMarkedAsRoot(container)) {

commit 14a4699ff173936a30ec453f7b94d47105bbb252
Author: Jack Pope <jackpope1@gmail.com>
Date:   Thu Jul 25 11:59:50 2024 -0400

    Remove allowConcurrentByDefault flag (#30445)
    
    Following https://github.com/facebook/react/pull/30436
    
    Concurrent by default strategy has been unshipped. Here we clean up the
    `allowConcurrentByDefault` path and related logic/tests.
    
    For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
    `createContainer` and `createHydrationContainer` and ignores the value
    to prevent more breaking changes to `react-reconciler` in the RC stage.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index aef8775de5..98ec6f9236 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -16,10 +16,7 @@ import type {
 import {isValidContainer} from 'react-dom-bindings/src/client/ReactDOMContainer';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
-import {
-  allowConcurrentByDefault,
-  enableAsyncActions,
-} from 'shared/ReactFeatureFlags';
+import {enableAsyncActions} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -29,7 +26,6 @@ export type RootType = {
 
 export type CreateRootOptions = {
   unstable_strictMode?: boolean,
-  unstable_concurrentUpdatesByDefault?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onUncaughtError?: (
@@ -55,7 +51,6 @@ export type HydrateRootOptions = {
   onDeleted?: (suspenseNode: Comment) => void,
   // Options for all roots
   unstable_strictMode?: boolean,
-  unstable_concurrentUpdatesByDefault?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,
   identifierPrefix?: string,
   onUncaughtError?: (
@@ -173,8 +168,8 @@ export function createRoot(
 
   warnIfReactDOMContainerInDEV(container);
 
+  const concurrentUpdatesByDefaultOverride = false;
   let isStrictMode = false;
-  let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
   let onUncaughtError = defaultOnUncaughtError;
   let onCaughtError = defaultOnCaughtError;
@@ -206,12 +201,6 @@ export function createRoot(
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
     }
-    if (
-      allowConcurrentByDefault &&
-      options.unstable_concurrentUpdatesByDefault === true
-    ) {
-      concurrentUpdatesByDefaultOverride = true;
-    }
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }
@@ -289,8 +278,8 @@ export function hydrateRoot(
   // the hydration callbacks.
   const hydrationCallbacks = options != null ? options : null;
 
+  const concurrentUpdatesByDefaultOverride = false;
   let isStrictMode = false;
-  let concurrentUpdatesByDefaultOverride = false;
   let identifierPrefix = '';
   let onUncaughtError = defaultOnUncaughtError;
   let onCaughtError = defaultOnCaughtError;
@@ -301,12 +290,6 @@ export function hydrateRoot(
     if (options.unstable_strictMode === true) {
       isStrictMode = true;
     }
-    if (
-      allowConcurrentByDefault &&
-      options.unstable_concurrentUpdatesByDefault === true
-    ) {
-      concurrentUpdatesByDefaultOverride = true;
-    }
     if (options.identifierPrefix !== undefined) {
       identifierPrefix = options.identifierPrefix;
     }

commit ef63718a27407b6d6b262d6be92e6bf0a87ff1a3
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Dec 13 13:58:18 2024 -0500

    Remove enableAsyncActions (#31757)
    
    Based on https://github.com/facebook/react/pull/31756
    
    This is landed everywhere

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 98ec6f9236..1c673bf254 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -16,7 +16,6 @@ import type {
 import {isValidContainer} from 'react-dom-bindings/src/client/ReactDOMContainer';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
-import {enableAsyncActions} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -305,10 +304,8 @@ export function hydrateRoot(
     if (options.unstable_transitionCallbacks !== undefined) {
       transitionCallbacks = options.unstable_transitionCallbacks;
     }
-    if (enableAsyncActions) {
-      if (options.formState !== undefined) {
-        formState = options.formState;
-      }
+    if (options.formState !== undefined) {
+      formState = options.formState;
     }
   }
 

commit 2bd1c756c6fffefb00cdb2986218fa2701ece82e
Author: David Sancho <dsnxmoreno@gmail.com>
Date:   Wed Dec 18 14:08:56 2024 +0100

    Ensure function arity is preserved after build (#31808)
    
    Co-authored-by: eps1lon <sebastian.silbermann@vercel.com>

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 1c673bf254..5cef2d2843 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -106,17 +106,19 @@ ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
     }
 
     if (__DEV__) {
-      if (typeof arguments[1] === 'function') {
+      // using a reference to `arguments` bails out of GCC optimizations which affect function arity
+      const args = arguments;
+      if (typeof args[1] === 'function') {
         console.error(
           'does not support the second callback argument. ' +
             'To execute a side effect after rendering, declare it in a component body with useEffect().',
         );
-      } else if (isValidContainer(arguments[1])) {
+      } else if (isValidContainer(args[1])) {
         console.error(
           'You passed a container to the second argument of root.render(...). ' +
             "You don't need to pass it again since you already passed it to create the root.",
         );
-      } else if (typeof arguments[1] !== 'undefined') {
+      } else if (typeof args[1] !== 'undefined') {
         console.error(
           'You passed a second argument to root.render(...) but it only accepts ' +
             'one argument.',
@@ -131,7 +133,9 @@ ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
   // $FlowFixMe[missing-this-annot]
   function (): void {
     if (__DEV__) {
-      if (typeof arguments[0] === 'function') {
+      // using a reference to `arguments` bails out of GCC optimizations which affect function arity
+      const args = arguments;
+      if (typeof args[0] === 'function') {
         console.error(
           'does not support a callback argument. ' +
             'To execute a side effect after rendering, declare it in a component body with useEffect().',

commit 0605cd9f38f8b9d0ca6f8bd9dd3409db8d6c5c81
Author: Josh Story <story@hey.com>
Date:   Tue Feb 4 12:39:52 2025 -0800

    [Fiber] Disable comments as containers in OSS (#32250)
    
    3 years ago we partially disabled comment nodes as valid containers.
    Some unflagged support was left in due to legacy APIs like
    `unmountComponentAtNode` and `unstable_renderSubtreeIntoContainer` but
    these were since removed in React 19. This update flags the remaining
    uses of comments as containers.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 5cef2d2843..37e994cc7b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -16,6 +16,7 @@ import type {
 import {isValidContainer} from 'react-dom-bindings/src/client/ReactDOMContainer';
 import {queueExplicitHydrationTarget} from 'react-dom-bindings/src/events/ReactDOMEventReplaying';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
+import {disableCommentsAsDOMContainers} from 'shared/ReactFeatureFlags';
 
 export type RootType = {
   render(children: ReactNodeList): void,
@@ -236,7 +237,7 @@ export function createRoot(
   markContainerAsRoot(root.current, container);
 
   const rootContainerElement: Document | Element | DocumentFragment =
-    container.nodeType === COMMENT_NODE
+    !disableCommentsAsDOMContainers && container.nodeType === COMMENT_NODE
       ? (container.parentNode: any)
       : container;
   listenToAllSupportedEvents(rootContainerElement);

commit 17f88c80ed20b4e5f21255d9e1268542a2fbc1bd
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 22 19:44:14 2025 -0400

    Implement ActivityInstance in FiberConfigDOM (#32842)
    
    Stacked on #32851 and #32900.
    
    This implements the equivalent Configs for ActivityInstance as we have
    for SuspenseInstance. These can be implemented as comments but they
    don't have to be and can be implemented differently in the renderer.
    
    This seems like a lot duplication but it's actually ends mostly just
    calling the same methods underneath and the wrappers compiles out.
    
    This doesn't leave the Activity dehydrated yet. It just hydrates into it
    immediately.

diff --git a/packages/react-dom/src/client/ReactDOMRoot.js b/packages/react-dom/src/client/ReactDOMRoot.js
index 37e994cc7b..940f0d4f3b 100644
--- a/packages/react-dom/src/client/ReactDOMRoot.js
+++ b/packages/react-dom/src/client/ReactDOMRoot.js
@@ -47,8 +47,8 @@ export type CreateRootOptions = {
 
 export type HydrateRootOptions = {
   // Hydration options
-  onHydrated?: (suspenseNode: Comment) => void,
-  onDeleted?: (suspenseNode: Comment) => void,
+  onHydrated?: (hydrationBoundary: Comment) => void,
+  onDeleted?: (hydrationBoundary: Comment) => void,
   // Options for all roots
   unstable_strictMode?: boolean,
   unstable_transitionCallbacks?: TransitionTracingCallbacks,

