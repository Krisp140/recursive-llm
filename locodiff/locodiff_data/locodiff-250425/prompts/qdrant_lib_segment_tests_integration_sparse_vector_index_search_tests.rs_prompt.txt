# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/tests/integration/sparse_vector_index_search_tests.rs

commit d5f98d8205f61dcfa53d0ecbd6c363c7d7aa501e
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 3 16:23:05 2023 +0100

    SparseVectorIndex implements VectorIndex (#2900)
    
    * SparseVector implements VectorIndex
    
    * dedicated telemetry
    
    * conflict
    
    * easy code reviews
    
    * simplify tracking indexed points count
    
    * move telemetry conversion to sparse file
    
    * move max_result_count out of inverted index trait
    
    * unify sparse vector fixtures
    
    * simpler conversion
    
    * add todo regarding OOM potential
    
    * reuse check deleted from raw scorer with TODO
    
    * change new to open to handle mmap index

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
new file mode 100644
index 000000000..297a1bd04
--- /dev/null
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -0,0 +1,340 @@
+use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
+
+use atomic_refcell::AtomicRefCell;
+use common::types::PointOffsetType;
+use rand::rngs::StdRng;
+use rand::{Rng, SeedableRng};
+use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+use segment::data_types::vectors::QueryVector;
+use segment::fixtures::payload_context_fixture::FixtureIdTracker;
+use segment::fixtures::payload_fixtures::STR_KEY;
+use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
+use segment::index::struct_payload_index::StructPayloadIndex;
+use segment::index::{PayloadIndex, VectorIndex};
+use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
+use segment::types::PayloadFieldSchema::FieldType;
+use segment::types::PayloadSchemaType::Keyword;
+use segment::types::{Condition, Distance, FieldCondition, Filter, Payload};
+use segment::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
+use segment::vector_storage::VectorStorage;
+use serde_json::json;
+use sparse::common::sparse_vector::SparseVector;
+use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
+use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
+use sparse::index::inverted_index::InvertedIndex;
+use tempfile::Builder;
+
+/// Max dimension of sparse vectors used in tests
+const MAX_SPARSE_DIM: usize = 1024;
+
+/// Prepares a sparse vector index with random sparse vectors
+fn fixture_sparse_index<I: InvertedIndex, R: Rng + ?Sized>(
+    rnd: &mut R,
+    max_dim: usize,
+    stopped: &AtomicBool,
+) -> SparseVectorIndex<I> {
+    // test params
+    let num_vectors = 1000;
+
+    // temp dirs
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+    // setup
+    let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num_vectors)));
+    let payload_storage = InMemoryPayloadStorage::default();
+    let wrapped_payload_storage = Arc::new(AtomicRefCell::new(payload_storage.into()));
+    let payload_index = StructPayloadIndex::open(
+        wrapped_payload_storage,
+        id_tracker.clone(),
+        payload_dir.path(),
+        true,
+    )
+    .unwrap();
+    let wrapped_payload_index = Arc::new(AtomicRefCell::new(payload_index));
+
+    let db = open_db(storage_dir.path(), &[DB_VECTOR_CF]).unwrap();
+    let vector_storage =
+        open_simple_sparse_vector_storage(db, DB_VECTOR_CF, Distance::Dot).unwrap();
+
+    let mut sparse_vector_index: SparseVectorIndex<I> = SparseVectorIndex::open(
+        id_tracker,
+        vector_storage.clone(),
+        wrapped_payload_index,
+        index_dir.path(),
+    )
+    .unwrap();
+
+    // add points to storage
+    for idx in 0..num_vectors {
+        let vec = &random_sparse_vector(rnd, max_dim);
+        vector_storage
+            .borrow_mut()
+            .insert_vector(idx as PointOffsetType, vec.into())
+            .unwrap();
+    }
+    assert_eq!(
+        vector_storage.borrow().available_vector_count(),
+        num_vectors
+    );
+
+    // build index
+    sparse_vector_index.build_index(stopped).unwrap();
+    assert_eq!(sparse_vector_index.indexed_vector_count(), num_vectors);
+    sparse_vector_index
+}
+
+#[test]
+fn sparse_vector_index_ram_no_filter_search() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
+        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+
+    // random query vectors
+    let attempts = 100;
+    let query_vectors = (0..attempts)
+        .map(|_| random_sparse_vector(&mut rnd, MAX_SPARSE_DIM))
+        .collect::<Vec<_>>();
+
+    // filter matches everything
+    let filter = Filter::new_must_not(Condition::Field(FieldCondition::new_match(
+        STR_KEY,
+        STR_KEY.to_owned().into(),
+    )));
+
+    // compares results with and without filters
+    // expects the filter to have no effect on the results because the filter matches everything
+    for query in query_vectors.into_iter() {
+        // top to get all results
+        let top = sparse_vector_index.max_result_count(&query);
+        assert!(top > 0);
+        let query_vector: QueryVector = query.into();
+        // with filter
+        let index_results_filter = sparse_vector_index
+            .search(&[&query_vector], Some(&filter), top, None, &stopped)
+            .unwrap();
+
+        // without filter
+        let index_results_no_filter = sparse_vector_index
+            .search(&[&query_vector], None, top, None, &stopped)
+            .unwrap();
+
+        assert_eq!(index_results_filter.len(), index_results_no_filter.len());
+
+        for (filter_result, no_filter_result) in index_results_filter
+            .iter()
+            .zip(index_results_no_filter.iter())
+        {
+            assert_eq!(filter_result.len(), top);
+            assert_eq!(filter_result.len(), no_filter_result.len());
+            for (filter_result, no_filter_result) in
+                filter_result.iter().zip(no_filter_result.iter())
+            {
+                assert_eq!(filter_result, no_filter_result);
+            }
+        }
+    }
+}
+
+#[test]
+fn sparse_vector_index_ram_consistent_with_storage() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
+        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let borrowed_vector_storage = sparse_vector_index.vector_storage.borrow();
+    let point_count = borrowed_vector_storage.available_vector_count();
+    for id in 0..point_count as PointOffsetType {
+        // assuming no deleted points
+        let vector: &SparseVector = borrowed_vector_storage.get_vector(id).try_into().unwrap();
+        // check posting lists are consistent with storage
+        for (dim_id, dim_value) in vector.indices.iter().zip(vector.values.iter()) {
+            let posting_list = sparse_vector_index.inverted_index.get(dim_id).unwrap();
+            // assert posting list sorted  by record id
+            assert!(posting_list
+                .elements
+                .windows(2)
+                .all(|w| w[0].record_id < w[1].record_id));
+            // assert posted list contains record id
+            assert!(posting_list
+                .elements
+                .iter()
+                .any(|e| e.record_id == id && e.weight == *dim_value));
+        }
+        // check the vector can be found via search using large top
+        let top = sparse_vector_index.max_result_count(vector);
+        let query_vector: QueryVector = vector.to_owned().into();
+        let results = sparse_vector_index
+            .search(&[&query_vector], None, top, None, &stopped)
+            .unwrap();
+        assert!(results[0].iter().any(|s| s.idx == id));
+    }
+}
+
+#[test]
+fn sparse_vector_index_ram_deleted_points_search() {
+    let stopped = AtomicBool::new(false);
+    let top = 10;
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
+        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+
+    // sanity check (all indexed, no deleted points)
+    assert_eq!(
+        sparse_vector_index
+            .id_tracker
+            .borrow()
+            .available_point_count(),
+        sparse_vector_index.indexed_vector_count()
+    );
+    assert_eq!(
+        sparse_vector_index
+            .id_tracker
+            .borrow()
+            .deleted_point_count(),
+        0
+    );
+
+    // query index
+    let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
+    let before_deletion_results: Vec<_> = sparse_vector_index
+        .search(&[&query_vector], None, top, None, &stopped)
+        .unwrap();
+
+    // pick a point to delete
+    let deleted_idx = before_deletion_results[0][0].idx;
+
+    // delete a point
+    let deleted_external = sparse_vector_index
+        .id_tracker
+        .borrow_mut()
+        .external_id(deleted_idx)
+        .unwrap();
+    sparse_vector_index
+        .id_tracker
+        .borrow_mut()
+        .drop(deleted_external)
+        .unwrap();
+
+    assert!(sparse_vector_index
+        .id_tracker
+        .borrow()
+        .is_deleted_point(deleted_idx));
+    assert_eq!(
+        sparse_vector_index
+            .id_tracker
+            .borrow()
+            .deleted_point_count(),
+        1
+    );
+    // still need to update index
+    assert_eq!(
+        sparse_vector_index
+            .id_tracker
+            .borrow()
+            .available_point_count(),
+        sparse_vector_index.indexed_vector_count() - 1
+    );
+
+    // refresh index to remove point
+    sparse_vector_index.build_index(&stopped).unwrap();
+    assert_eq!(
+        sparse_vector_index
+            .id_tracker
+            .borrow()
+            .available_point_count(),
+        sparse_vector_index.indexed_vector_count()
+    );
+
+    // assert that the deleted point is no longer in the index
+    let after_deletion_results: Vec<_> = sparse_vector_index
+        .search(&[&query_vector], None, top, None, &stopped)
+        .unwrap();
+    assert_ne!(before_deletion_results, after_deletion_results);
+    assert!(after_deletion_results
+        .iter()
+        .all(|x| x.iter().all(|y| y.idx != deleted_idx)));
+}
+
+#[test]
+fn sparse_vector_index_ram_filtered_search() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+    let field_name = "field";
+    let field_value = "important value";
+
+    // setup index
+    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
+        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+
+    // query index by payload
+    let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
+        field_name,
+        field_value.to_owned().into(),
+    )));
+
+    // query all sparse dimension to get all points
+    let query_vector: QueryVector = random_full_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
+    let before_result = sparse_vector_index
+        .search(&[&query_vector], Some(&filter), 10, None, &stopped)
+        .unwrap();
+    assert_eq!(before_result.len(), 1);
+    assert_eq!(before_result[0].len(), 0);
+
+    // create payload field index
+    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    payload_index
+        .set_indexed(field_name, Keyword.into())
+        .unwrap();
+    drop(payload_index);
+
+    // assert payload field index created and empty
+    let payload_index = sparse_vector_index.payload_index.borrow();
+    let indexed_fields = payload_index.indexed_fields();
+    assert_eq!(*indexed_fields.get(field_name).unwrap(), FieldType(Keyword));
+
+    let field_indexes = &payload_index.field_indexes;
+    let field_index = field_indexes.get(field_name).unwrap();
+    assert_eq!(field_index[0].count_indexed_points(), 0);
+    drop(payload_index);
+
+    // add payload on the first half of the points
+    let half_indexed_count = sparse_vector_index.indexed_vector_count() / 2;
+    let payload: Payload = json!({
+        field_name: field_value,
+    })
+    .into();
+    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    for idx in 0..half_indexed_count {
+        payload_index
+            .assign(idx as PointOffsetType, &payload)
+            .unwrap();
+    }
+    drop(payload_index);
+
+    // assert payload index updated
+    let payload_index = sparse_vector_index.payload_index.borrow();
+    let field_indexes = &payload_index.field_indexes;
+    let field_index = field_indexes.get(field_name).unwrap();
+    assert_eq!(field_index[0].count_indexed_points(), half_indexed_count);
+    drop(payload_index);
+
+    // request all points with payload
+    let after_result = sparse_vector_index
+        .search(
+            &[&query_vector],
+            Some(&filter),
+            half_indexed_count * 2, // original top
+            None,
+            &stopped,
+        )
+        .unwrap();
+    assert_eq!(after_result.len(), 1);
+    assert_eq!(after_result[0].len(), half_indexed_count); // expect half of the points
+}

commit 3058057df6fd810c2d84f19e4044ddfd53a5d277
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 7 15:03:37 2023 +0100

    Extra tests for Sparse Vector Index (#2925)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 297a1bd04..f1cd6f690 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,3 +1,4 @@
+use std::path::Path;
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
@@ -5,6 +6,7 @@ use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
 use rand::rngs::StdRng;
 use rand::{Rng, SeedableRng};
+use segment::common::operation_error::OperationResult;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::QueryVector;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
@@ -21,25 +23,21 @@ use segment::vector_storage::VectorStorage;
 use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
+use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
 use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
 /// Max dimension of sparse vectors used in tests
-const MAX_SPARSE_DIM: usize = 1024;
-
-/// Prepares a sparse vector index with random sparse vectors
-fn fixture_sparse_index<I: InvertedIndex, R: Rng + ?Sized>(
-    rnd: &mut R,
-    max_dim: usize,
-    stopped: &AtomicBool,
-) -> SparseVectorIndex<I> {
-    // test params
-    let num_vectors = 1000;
+const MAX_SPARSE_DIM: usize = 512;
 
+/// Helper to open a test sparse vector index
+fn fixture_open_sparse_index<I: InvertedIndex>(
+    index_dir: &Path,
+    num_vectors: usize, // used to size the id tracker
+) -> OperationResult<SparseVectorIndex<I>> {
     // temp dirs
     let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
     let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
 
     // setup
@@ -51,36 +49,54 @@ fn fixture_sparse_index<I: InvertedIndex, R: Rng + ?Sized>(
         id_tracker.clone(),
         payload_dir.path(),
         true,
-    )
-    .unwrap();
+    )?;
     let wrapped_payload_index = Arc::new(AtomicRefCell::new(payload_index));
 
     let db = open_db(storage_dir.path(), &[DB_VECTOR_CF]).unwrap();
-    let vector_storage =
-        open_simple_sparse_vector_storage(db, DB_VECTOR_CF, Distance::Dot).unwrap();
+    let vector_storage = open_simple_sparse_vector_storage(db, DB_VECTOR_CF, Distance::Dot)?;
 
-    let mut sparse_vector_index: SparseVectorIndex<I> = SparseVectorIndex::open(
+    let sparse_vector_index: SparseVectorIndex<I> = SparseVectorIndex::open(
         id_tracker,
         vector_storage.clone(),
         wrapped_payload_index,
-        index_dir.path(),
-    )
-    .unwrap();
+        index_dir,
+    )?;
+
+    Ok(sparse_vector_index)
+}
+
+/// Prepares a sparse vector index with random sparse vectors
+fn fixture_sparse_index_ram<R: Rng + ?Sized>(
+    rnd: &mut R,
+    max_dim: usize,
+    stopped: &AtomicBool,
+) -> SparseVectorIndex<InvertedIndexRam> {
+    // test params
+    let num_vectors = 1000;
+
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let mut sparse_vector_index = fixture_open_sparse_index(index_dir.path(), num_vectors).unwrap();
+    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
 
     // add points to storage
     for idx in 0..num_vectors {
         let vec = &random_sparse_vector(rnd, max_dim);
-        vector_storage
-            .borrow_mut()
+        borrowed_storage
             .insert_vector(idx as PointOffsetType, vec.into())
             .unwrap();
     }
+    drop(borrowed_storage);
+
+    // assert all points are in storage
     assert_eq!(
-        vector_storage.borrow().available_vector_count(),
+        sparse_vector_index
+            .vector_storage
+            .borrow()
+            .available_vector_count(),
         num_vectors
     );
 
-    // build index
+    // build index to refresh RAM index
     sparse_vector_index.build_index(stopped).unwrap();
     assert_eq!(sparse_vector_index.indexed_vector_count(), num_vectors);
     sparse_vector_index
@@ -91,8 +107,7 @@ fn sparse_vector_index_ram_no_filter_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
-        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
 
     // random query vectors
     let attempts = 100;
@@ -140,13 +155,8 @@ fn sparse_vector_index_ram_no_filter_search() {
     }
 }
 
-#[test]
-fn sparse_vector_index_ram_consistent_with_storage() {
-    let stopped = AtomicBool::new(false);
-    let mut rnd = StdRng::seed_from_u64(42);
-
-    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
-        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+/// Checks that the sparse vector index is consistent with the underlying storage
+fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {
     let borrowed_vector_storage = sparse_vector_index.vector_storage.borrow();
     let point_count = borrowed_vector_storage.available_vector_count();
     for id in 0..point_count as PointOffsetType {
@@ -170,20 +180,59 @@ fn sparse_vector_index_ram_consistent_with_storage() {
         let top = sparse_vector_index.max_result_count(vector);
         let query_vector: QueryVector = vector.to_owned().into();
         let results = sparse_vector_index
-            .search(&[&query_vector], None, top, None, &stopped)
+            .search(&[&query_vector], None, top, None, &false.into())
             .unwrap();
         assert!(results[0].iter().any(|s| s.idx == id));
     }
 }
 
+#[test]
+fn sparse_vector_index_consistent_with_storage() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let sparse_vector_ram_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
+
+    // check consistency with underlying RAM inverted index
+    check_index_storage_consistency(&sparse_vector_ram_index);
+
+    let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
+    // copy index mmap and save to disk
+    let _mmap_inverted_index = InvertedIndexMmap::convert_and_save(
+        &sparse_vector_ram_index.inverted_index,
+        &mmap_index_dir,
+    )
+    .unwrap();
+
+    // load index from memmap file
+    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
+        sparse_vector_ram_index.id_tracker.clone(),
+        sparse_vector_ram_index.vector_storage.clone(),
+        sparse_vector_ram_index.payload_index.clone(),
+        mmap_index_dir.path(),
+    )
+    .unwrap();
+
+    // check consistency with underlying mmap inverted index
+    check_index_storage_consistency(&sparse_vector_mmap_index);
+}
+
+#[test]
+fn sparse_vector_index_load_missing_mmap() {
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
+        fixture_open_sparse_index(index_dir.path(), 0);
+    // fails to open index if mmap file is missing
+    assert!(sparse_vector_index.is_err())
+}
+
 #[test]
 fn sparse_vector_index_ram_deleted_points_search() {
     let stopped = AtomicBool::new(false);
     let top = 10;
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
-        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let mut sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
 
     // sanity check (all indexed, no deleted points)
     assert_eq!(
@@ -270,8 +319,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let field_value = "important value";
 
     // setup index
-    let sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
-        fixture_sparse_index(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
 
     // query index by payload
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(

commit 6cdbdd4c5af19cb23b3563fdd776d1a811b0eb7a
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 8 13:07:33 2023 +0100

    Sparse vector search benchmarks (#2944)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index f1cd6f690..045c7d2a2 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,113 +1,38 @@
-use std::path::Path;
 use std::sync::atomic::AtomicBool;
-use std::sync::Arc;
 
-use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
 use rand::rngs::StdRng;
-use rand::{Rng, SeedableRng};
+use rand::SeedableRng;
 use segment::common::operation_error::OperationResult;
-use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::QueryVector;
-use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::fixtures::payload_fixtures::STR_KEY;
+use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
-use segment::index::struct_payload_index::StructPayloadIndex;
 use segment::index::{PayloadIndex, VectorIndex};
-use segment::payload_storage::in_memory_payload_storage::InMemoryPayloadStorage;
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
-use segment::types::{Condition, Distance, FieldCondition, Filter, Payload};
-use segment::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
+use segment::types::{Condition, FieldCondition, Filter, Payload};
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
-use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
 /// Max dimension of sparse vectors used in tests
 const MAX_SPARSE_DIM: usize = 512;
 
-/// Helper to open a test sparse vector index
-fn fixture_open_sparse_index<I: InvertedIndex>(
-    index_dir: &Path,
-    num_vectors: usize, // used to size the id tracker
-) -> OperationResult<SparseVectorIndex<I>> {
-    // temp dirs
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-
-    // setup
-    let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num_vectors)));
-    let payload_storage = InMemoryPayloadStorage::default();
-    let wrapped_payload_storage = Arc::new(AtomicRefCell::new(payload_storage.into()));
-    let payload_index = StructPayloadIndex::open(
-        wrapped_payload_storage,
-        id_tracker.clone(),
-        payload_dir.path(),
-        true,
-    )?;
-    let wrapped_payload_index = Arc::new(AtomicRefCell::new(payload_index));
-
-    let db = open_db(storage_dir.path(), &[DB_VECTOR_CF]).unwrap();
-    let vector_storage = open_simple_sparse_vector_storage(db, DB_VECTOR_CF, Distance::Dot)?;
-
-    let sparse_vector_index: SparseVectorIndex<I> = SparseVectorIndex::open(
-        id_tracker,
-        vector_storage.clone(),
-        wrapped_payload_index,
-        index_dir,
-    )?;
-
-    Ok(sparse_vector_index)
-}
-
-/// Prepares a sparse vector index with random sparse vectors
-fn fixture_sparse_index_ram<R: Rng + ?Sized>(
-    rnd: &mut R,
-    max_dim: usize,
-    stopped: &AtomicBool,
-) -> SparseVectorIndex<InvertedIndexRam> {
-    // test params
-    let num_vectors = 1000;
-
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
-    let mut sparse_vector_index = fixture_open_sparse_index(index_dir.path(), num_vectors).unwrap();
-    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
-
-    // add points to storage
-    for idx in 0..num_vectors {
-        let vec = &random_sparse_vector(rnd, max_dim);
-        borrowed_storage
-            .insert_vector(idx as PointOffsetType, vec.into())
-            .unwrap();
-    }
-    drop(borrowed_storage);
-
-    // assert all points are in storage
-    assert_eq!(
-        sparse_vector_index
-            .vector_storage
-            .borrow()
-            .available_vector_count(),
-        num_vectors
-    );
-
-    // build index to refresh RAM index
-    sparse_vector_index.build_index(stopped).unwrap();
-    assert_eq!(sparse_vector_index.indexed_vector_count(), num_vectors);
-    sparse_vector_index
-}
+/// Number of vectors to index in tests
+const NUM_VECTORS: usize = 1000;
 
 #[test]
 fn sparse_vector_index_ram_no_filter_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_index =
+        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
 
     // random query vectors
     let attempts = 100;
@@ -191,18 +116,20 @@ fn sparse_vector_index_consistent_with_storage() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let sparse_vector_ram_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_ram_index =
+        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
 
     // check consistency with underlying RAM inverted index
     check_index_storage_consistency(&sparse_vector_ram_index);
 
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
     // copy index mmap and save to disk
-    let _mmap_inverted_index = InvertedIndexMmap::convert_and_save(
+    let mmap_inverted_index = InvertedIndexMmap::convert_and_save(
         &sparse_vector_ram_index.inverted_index,
         &mmap_index_dir,
     )
     .unwrap();
+    drop(mmap_inverted_index);
 
     // load index from memmap file
     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
@@ -232,7 +159,8 @@ fn sparse_vector_index_ram_deleted_points_search() {
     let top = 10;
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let mut sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let mut sparse_vector_index =
+        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
 
     // sanity check (all indexed, no deleted points)
     assert_eq!(
@@ -319,7 +247,8 @@ fn sparse_vector_index_ram_filtered_search() {
     let field_value = "important value";
 
     // setup index
-    let sparse_vector_index = fixture_sparse_index_ram(&mut rnd, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_index =
+        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
 
     // query index by payload
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(

commit ee5fe6301942eaf3316372289049f3a983dbad16
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Nov 9 09:57:43 2023 +0100

    Benchmark sparse filter plain search (#2947)
    
    * Sparse filter plain search
    
    * code review

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 045c7d2a2..8e0bd0ed1 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -21,7 +21,7 @@ use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
 /// Max dimension of sparse vectors used in tests
-const MAX_SPARSE_DIM: usize = 512;
+const MAX_SPARSE_DIM: usize = 2048;
 
 /// Number of vectors to index in tests
 const NUM_VECTORS: usize = 1000;
@@ -31,8 +31,19 @@ fn sparse_vector_index_ram_no_filter_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let sparse_vector_index =
-        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+
+    let sparse_vector_index = fixture_sparse_index_ram(
+        &mut rnd,
+        NUM_VECTORS,
+        MAX_SPARSE_DIM,
+        payload_dir.path(),
+        storage_dir.path(),
+        index_dir.path(),
+        &stopped,
+    );
 
     // random query vectors
     let attempts = 100;
@@ -116,8 +127,19 @@ fn sparse_vector_index_consistent_with_storage() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let sparse_vector_ram_index =
-        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+
+    let sparse_vector_ram_index = fixture_sparse_index_ram(
+        &mut rnd,
+        NUM_VECTORS,
+        MAX_SPARSE_DIM,
+        payload_dir.path(),
+        storage_dir.path(),
+        index_dir.path(),
+        &stopped,
+    );
 
     // check consistency with underlying RAM inverted index
     check_index_storage_consistency(&sparse_vector_ram_index);
@@ -147,8 +169,10 @@ fn sparse_vector_index_consistent_with_storage() {
 #[test]
 fn sparse_vector_index_load_missing_mmap() {
     let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
-        fixture_open_sparse_index(index_dir.path(), 0);
+        fixture_open_sparse_index(index_dir.path(), payload_dir.path(), storage_dir.path(), 0);
     // fails to open index if mmap file is missing
     assert!(sparse_vector_index.is_err())
 }
@@ -159,8 +183,19 @@ fn sparse_vector_index_ram_deleted_points_search() {
     let top = 10;
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let mut sparse_vector_index =
-        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+
+    let mut sparse_vector_index = fixture_sparse_index_ram(
+        &mut rnd,
+        NUM_VECTORS,
+        MAX_SPARSE_DIM,
+        payload_dir.path(),
+        storage_dir.path(),
+        index_dir.path(),
+        &stopped,
+    );
 
     // sanity check (all indexed, no deleted points)
     assert_eq!(
@@ -243,14 +278,25 @@ fn sparse_vector_index_ram_deleted_points_search() {
 fn sparse_vector_index_ram_filtered_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
-    let field_name = "field";
-    let field_value = "important value";
+
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
 
     // setup index
-    let sparse_vector_index =
-        fixture_sparse_index_ram(&mut rnd, NUM_VECTORS, MAX_SPARSE_DIM, &stopped);
+    let sparse_vector_index = fixture_sparse_index_ram(
+        &mut rnd,
+        NUM_VECTORS,
+        MAX_SPARSE_DIM,
+        payload_dir.path(),
+        storage_dir.path(),
+        index_dir.path(),
+        &stopped,
+    );
 
     // query index by payload
+    let field_name = "field";
+    let field_value = "important value";
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
         field_name,
         field_value.to_owned().into(),
@@ -315,3 +361,65 @@ fn sparse_vector_index_ram_filtered_search() {
     assert_eq!(after_result.len(), 1);
     assert_eq!(after_result[0].len(), half_indexed_count); // expect half of the points
 }
+
+#[test]
+fn sparse_vector_index_plain_search() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
+    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+
+    // setup index
+    let sparse_vector_index = fixture_sparse_index_ram(
+        &mut rnd,
+        NUM_VECTORS,
+        MAX_SPARSE_DIM,
+        payload_dir.path(),
+        storage_dir.path(),
+        index_dir.path(),
+        &stopped,
+    );
+
+    // query index by payload
+    let field_name = "field";
+    let field_value = "important value";
+    let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
+        field_name,
+        field_value.to_owned().into(),
+    )));
+
+    // query all sparse dimension to get all points
+    let query_vector: QueryVector = random_full_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
+
+    // empty when searching payload index directly
+    let before_plain_results = sparse_vector_index
+        .search_plain(&[&query_vector], &filter, 10, &stopped)
+        .unwrap();
+
+    assert_eq!(before_plain_results.len(), 1);
+    assert_eq!(before_plain_results[0].len(), 0);
+
+    let payload: Payload = json!({
+        field_name: field_value,
+    })
+    .into();
+
+    // add payload to all points
+    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    for idx in 0..NUM_VECTORS {
+        payload_index
+            .assign(idx as PointOffsetType, &payload)
+            .unwrap();
+    }
+    drop(payload_index);
+
+    // same results when searching payload index directly
+    let after_plain_results = sparse_vector_index
+        .search_plain(&[&query_vector], &filter, NUM_VECTORS, &stopped)
+        .unwrap();
+
+    assert_eq!(after_plain_results.len(), 1);
+    assert_eq!(after_plain_results[0].len(), NUM_VECTORS);
+}

commit 8f844b66359db9a24ac0785cd936de909ff711f6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 14 17:31:18 2023 +0100

    Fix vector count in sparse index (#2992)
    
    * Fix vector count in sparse index
    
    * simplify naming
    
    * rely on max id for count

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 8e0bd0ed1..5c8cc298b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -162,6 +162,11 @@ fn sparse_vector_index_consistent_with_storage() {
     )
     .unwrap();
 
+    assert_eq!(
+        sparse_vector_mmap_index.indexed_vector_count(),
+        sparse_vector_ram_index.indexed_vector_count()
+    );
+
     // check consistency with underlying mmap inverted index
     check_index_storage_consistency(&sparse_vector_mmap_index);
 }

commit 28fa2eedf892c9763108ba0a947d4976615270ae
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 14 19:58:52 2023 +0100

    Add fallback to plain search for sparse vectors (#2963)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 5c8cc298b..67c5d757f 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -26,22 +26,23 @@ const MAX_SPARSE_DIM: usize = 2048;
 /// Number of vectors to index in tests
 const NUM_VECTORS: usize = 1000;
 
-#[test]
-fn sparse_vector_index_ram_no_filter_search() {
+/// Default full scan threshold in tests
+/// very low value to force usage of index
+const LOW_FULL_SCAN_THRESHOLD: usize = 1;
+
+/// Expects the filter to match ALL points in order to compare the results with/without filter
+fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
     let sparse_vector_index = fixture_sparse_index_ram(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        payload_dir.path(),
-        storage_dir.path(),
-        index_dir.path(),
+        full_scan_threshold,
+        data_dir.path(),
         &stopped,
     );
 
@@ -91,6 +92,18 @@ fn sparse_vector_index_ram_no_filter_search() {
     }
 }
 
+#[test]
+fn sparse_vector_index_ram_filter_search() {
+    // very low full scan threshold to force usage of inverted index
+    compare_sparse_vectors_search_with_without_filter(LOW_FULL_SCAN_THRESHOLD);
+}
+
+#[test]
+fn sparse_vector_index_fallback_plain_search() {
+    // very high full scan threshold to force fallback to plain search
+    compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);
+}
+
 /// Checks that the sparse vector index is consistent with the underlying storage
 fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {
     let borrowed_vector_storage = sparse_vector_index.vector_storage.borrow();
@@ -127,17 +140,13 @@ fn sparse_vector_index_consistent_with_storage() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
-
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_ram_index = fixture_sparse_index_ram(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        payload_dir.path(),
-        storage_dir.path(),
-        index_dir.path(),
+        LOW_FULL_SCAN_THRESHOLD,
+        data_dir.path(),
         &stopped,
     );
 
@@ -154,7 +163,9 @@ fn sparse_vector_index_consistent_with_storage() {
     drop(mmap_inverted_index);
 
     // load index from memmap file
+    let sparse_index_config = sparse_vector_ram_index.config;
     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
+        sparse_index_config,
         sparse_vector_ram_index.id_tracker.clone(),
         sparse_vector_ram_index.vector_storage.clone(),
         sparse_vector_ram_index.payload_index.clone(),
@@ -173,11 +184,9 @@ fn sparse_vector_index_consistent_with_storage() {
 
 #[test]
 fn sparse_vector_index_load_missing_mmap() {
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
-        fixture_open_sparse_index(index_dir.path(), payload_dir.path(), storage_dir.path(), 0);
+        fixture_open_sparse_index(data_dir.path(), 0, 10_000);
     // fails to open index if mmap file is missing
     assert!(sparse_vector_index.is_err())
 }
@@ -188,17 +197,14 @@ fn sparse_vector_index_ram_deleted_points_search() {
     let top = 10;
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
     let mut sparse_vector_index = fixture_sparse_index_ram(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        payload_dir.path(),
-        storage_dir.path(),
-        index_dir.path(),
+        LOW_FULL_SCAN_THRESHOLD,
+        data_dir.path(),
         &stopped,
     );
 
@@ -284,18 +290,15 @@ fn sparse_vector_index_ram_filtered_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
     // setup index
     let sparse_vector_index = fixture_sparse_index_ram(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        payload_dir.path(),
-        storage_dir.path(),
-        index_dir.path(),
+        LOW_FULL_SCAN_THRESHOLD,
+        data_dir.path(),
         &stopped,
     );
 
@@ -372,18 +375,14 @@ fn sparse_vector_index_plain_search() {
     let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
-    let payload_dir = Builder::new().prefix("payload_dir").tempdir().unwrap();
-    let storage_dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let index_dir = Builder::new().prefix("index_dir").tempdir().unwrap();
-
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     // setup index
     let sparse_vector_index = fixture_sparse_index_ram(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        payload_dir.path(),
-        storage_dir.path(),
-        index_dir.path(),
+        LOW_FULL_SCAN_THRESHOLD,
+        data_dir.path(),
         &stopped,
     );
 

commit 6d0a48b2dc772e978dd560d9c265530859ea2a6d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Nov 16 10:51:02 2023 +0100

    Deactivate sparse index pruning for negative query vectors (#3024)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 67c5d757f..eca17edf0 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,3 +1,4 @@
+use std::cmp::max;
 use std::sync::atomic::AtomicBool;
 
 use common::types::PointOffsetType;
@@ -61,9 +62,9 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
     // compares results with and without filters
     // expects the filter to have no effect on the results because the filter matches everything
     for query in query_vectors.into_iter() {
-        // top to get all results
-        let top = sparse_vector_index.max_result_count(&query);
-        assert!(top > 0);
+        let maximum_number_of_results = sparse_vector_index.max_result_count(&query);
+        // get all results minus 10 to force a bit of pruning
+        let top = max(1, maximum_number_of_results.saturating_sub(10));
         let query_vector: QueryVector = query.into();
         // with filter
         let index_results_filter = sparse_vector_index

commit de390f51bfa39200fe443e981fab3e8d197f69fd
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 20 15:58:10 2023 +0100

    Better heuristic for sparse vector pruning (#3048)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index eca17edf0..770b8a9fb 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -22,10 +22,10 @@ use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
 /// Max dimension of sparse vectors used in tests
-const MAX_SPARSE_DIM: usize = 2048;
+const MAX_SPARSE_DIM: usize = 4096;
 
 /// Number of vectors to index in tests
-const NUM_VECTORS: usize = 1000;
+const NUM_VECTORS: usize = 2000;
 
 /// Default full scan threshold in tests
 /// very low value to force usage of index
@@ -48,7 +48,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
     );
 
     // random query vectors
-    let attempts = 100;
+    let attempts = 1000;
     let query_vectors = (0..attempts)
         .map(|_| random_sparse_vector(&mut rnd, MAX_SPARSE_DIM))
         .collect::<Vec<_>>();
@@ -65,7 +65,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
         let maximum_number_of_results = sparse_vector_index.max_result_count(&query);
         // get all results minus 10 to force a bit of pruning
         let top = max(1, maximum_number_of_results.saturating_sub(10));
-        let query_vector: QueryVector = query.into();
+        let query_vector: QueryVector = query.clone().into();
         // with filter
         let index_results_filter = sparse_vector_index
             .search(&[&query_vector], Some(&filter), top, None, &stopped)
@@ -82,8 +82,14 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
             .iter()
             .zip(index_results_no_filter.iter())
         {
-            assert_eq!(filter_result.len(), top);
-            assert_eq!(filter_result.len(), no_filter_result.len());
+            assert_eq!(
+                filter_result.len(),
+                no_filter_result.len(),
+                "query = {:#?}, filter_result = {:#?} no_filter_result = {:#?}",
+                query,
+                filter_result,
+                no_filter_result,
+            );
             for (filter_result, no_filter_result) in
                 filter_result.iter().zip(no_filter_result.iter())
             {

commit a09a6303673a396f3847d55415befeea8089aae2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 21 11:27:12 2023 +0100

    Accept empty sparse vectors (#3057)
    
    * Accept empty sparse vectors
    
    * sparse vector index is responsbile for filtering empty vectors

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 770b8a9fb..b9653a23b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -12,12 +12,13 @@ use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
-use segment::types::{Condition, FieldCondition, Filter, Payload};
+use segment::types::{Condition, FieldCondition, Filter, Payload, DEFAULT_FULL_SCAN_THRESHOLD};
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
+use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
@@ -434,3 +435,46 @@ fn sparse_vector_index_plain_search() {
     assert_eq!(after_plain_results.len(), 1);
     assert_eq!(after_plain_results[0].len(), NUM_VECTORS);
 }
+
+#[test]
+fn handling_empty_sparse_vectors() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
+    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
+        fixture_open_sparse_index(data_dir.path(), NUM_VECTORS, DEFAULT_FULL_SCAN_THRESHOLD)
+            .unwrap();
+    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
+
+    // add empty points to storage
+    for idx in 0..NUM_VECTORS {
+        let vec = &SparseVector::new(vec![], vec![]).unwrap();
+        borrowed_storage
+            .insert_vector(idx as PointOffsetType, vec.into())
+            .unwrap();
+    }
+    drop(borrowed_storage);
+
+    // assert all empty points are in storage
+    assert_eq!(
+        sparse_vector_index
+            .vector_storage
+            .borrow()
+            .available_vector_count(),
+        NUM_VECTORS
+    );
+
+    // empty vectors are not indexed
+    sparse_vector_index.build_index(&stopped).unwrap();
+    assert_eq!(sparse_vector_index.indexed_vector_count(), 0);
+
+    let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
+
+    // empty vectors are not searchable (recommend using scroll API to retrieve those)
+    let results = sparse_vector_index
+        .search(&[&query_vector], None, 10, None, &stopped)
+        .unwrap();
+    assert_eq!(results.len(), 1);
+    assert_eq!(results[0].len(), 0);
+}

commit 684c58fbdc62a1abe7ed54e70277592457867507
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Nov 30 17:48:19 2023 +0100

    Sparse vector storage rocksdb only (#3112)
    
    * sparse vector storage rocksdb only
    
    * fix build
    
    * spelling fix
    
    * simplify get_cf
    
    * restore deleted flags loading

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index b9653a23b..b0cf11683 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -118,7 +118,8 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
     let point_count = borrowed_vector_storage.available_vector_count();
     for id in 0..point_count as PointOffsetType {
         // assuming no deleted points
-        let vector: &SparseVector = borrowed_vector_storage.get_vector(id).try_into().unwrap();
+        let vector = borrowed_vector_storage.get_vector(id);
+        let vector: &SparseVector = vector.as_vec_ref().try_into().unwrap();
         // check posting lists are consistent with storage
         for (dim_id, dim_value) in vector.indices.iter().zip(vector.values.iter()) {
             let posting_list = sparse_vector_index.inverted_index.get(dim_id).unwrap();

commit 3fc1f9656418995d21d156bd83f6f3611a99ee96
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 1 13:10:58 2023 +0100

    Sparse index segment and collection config (#2802)
    
    * quantization storage as separate entity
    
    sparse index try to extend segment types
    
    fix build
    
    fix async scorer
    
    codespell
    
    update openapi
    
    update vector index
    
    remove code duplications
    
    more fixes
    
    more fixes
    
    fix build
    
    fix deserialization test
    
    remove transform_into
    
    are you happy clippy
    
    update openapi
    
    update openapi
    
    are you happy clippy
    
    fix build
    
    optional serialize
    
    more defaults
    
    update openapi
    
    fix comments
    
    generic transpose_map_into_named_vector
    
    rename fields in tests
    
    remove obsolete parts
    
    only named sparse config
    
    VectorStruct without unnamed sparse
    
    NamedVectorStruct without unnamed sparse
    
    remove obsolete test
    
    update openapi
    
    mmap index
    
    revert preprocess function
    
    are you happy fmt
    
    update openapi
    
    fix build
    
    fix tests
    
    are you happy fmt
    
    fix for client generation
    
    fix sparse segment creation
    
    fix basic sparse test
    
    fix conflicts
    
    remove obsolete convertion
    
    fix build
    
    config diffs
    
    update openapi
    
    review remarks
    
    update openapi
    
    fix batch upsert
    
    add failing test showing bad ids matching
    
    fix sparse vector insertion
    
    remove on_disk flag
    
    update openapi
    
    revert debug assert
    
    simplify conversions
    
    update openapi
    
    remove on disk storage flag
    
    update openapi
    
    default for vector config
    
    update openapi comment
    
    remove diffs
    
    update openapi
    
    * enable consensus test
    
    * add comment
    
    * update openapi

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index b0cf11683..f68f130fd 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -12,7 +12,9 @@ use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
-use segment::types::{Condition, FieldCondition, Filter, Payload, DEFAULT_FULL_SCAN_THRESHOLD};
+use segment::types::{
+    Condition, FieldCondition, Filter, Payload, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+};
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
@@ -443,9 +445,12 @@ fn handling_empty_sparse_vectors() {
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> =
-        fixture_open_sparse_index(data_dir.path(), NUM_VECTORS, DEFAULT_FULL_SCAN_THRESHOLD)
-            .unwrap();
+    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> = fixture_open_sparse_index(
+        data_dir.path(),
+        NUM_VECTORS,
+        DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+    )
+    .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
 
     // add empty points to storage

commit 286caac3a473aaa2a883ac9ac5857b3e54096ab6
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Dec 4 12:02:53 2023 +0100

    Sparse index persistence (#3131)
    
    * sparse index persistence
    
    * fix tests
    
    * remove defaults

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index f68f130fd..6c79c28fb 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,19 +1,24 @@
 use std::cmp::max;
+use std::collections::HashMap;
 use std::sync::atomic::AtomicBool;
 
 use common::types::PointOffsetType;
 use rand::rngs::StdRng;
 use rand::SeedableRng;
 use segment::common::operation_error::OperationResult;
-use segment::data_types::vectors::QueryVector;
+use segment::data_types::named_vectors::NamedVectors;
+use segment::data_types::vectors::{QueryVector, Vector};
+use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex};
+use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
-    Condition, FieldCondition, Filter, Payload, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+    Condition, FieldCondition, Filter, Payload, SegmentConfig, SeqNumberType,
+    SparseVectorDataConfig, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
@@ -34,6 +39,8 @@ const NUM_VECTORS: usize = 2000;
 /// very low value to force usage of index
 const LOW_FULL_SCAN_THRESHOLD: usize = 1;
 
+const SPARSE_VECTOR_NAME: &str = "sparse_vector";
+
 /// Expects the filter to match ALL points in order to compare the results with/without filter
 fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {
     let stopped = AtomicBool::new(false);
@@ -451,25 +458,6 @@ fn handling_empty_sparse_vectors() {
         DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
     )
     .unwrap();
-    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
-
-    // add empty points to storage
-    for idx in 0..NUM_VECTORS {
-        let vec = &SparseVector::new(vec![], vec![]).unwrap();
-        borrowed_storage
-            .insert_vector(idx as PointOffsetType, vec.into())
-            .unwrap();
-    }
-    drop(borrowed_storage);
-
-    // assert all empty points are in storage
-    assert_eq!(
-        sparse_vector_index
-            .vector_storage
-            .borrow()
-            .available_vector_count(),
-        NUM_VECTORS
-    );
 
     // empty vectors are not indexed
     sparse_vector_index.build_index(&stopped).unwrap();
@@ -484,3 +472,74 @@ fn handling_empty_sparse_vectors() {
     assert_eq!(results.len(), 1);
     assert_eq!(results[0].len(), 0);
 }
+
+#[test]
+fn sparse_vector_persistence_test() {
+    let stopped = AtomicBool::new(false);
+
+    let dim = 8;
+    let num_vectors: u64 = 5_000;
+    let top = 3;
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
+
+    let config = SegmentConfig {
+        vector_data: Default::default(),
+        sparse_vector_data: HashMap::from([(
+            SPARSE_VECTOR_NAME.to_owned(),
+            SparseVectorDataConfig { index: None },
+        )]),
+        payload_storage_type: Default::default(),
+    };
+    let mut segment = build_segment(dir.path(), &config, true).unwrap();
+
+    for n in 0..num_vectors {
+        let vector: Vector = random_sparse_vector(&mut rnd, dim).into();
+        let mut named_vector = NamedVectors::default();
+        named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
+        let idx = n.into();
+        segment
+            .upsert_point(n as SeqNumberType, idx, named_vector)
+            .unwrap();
+    }
+    segment.flush(true).unwrap();
+
+    let search_vector = random_sparse_vector(&mut rnd, dim);
+    let query_vector: QueryVector = search_vector.into();
+
+    let search_result = segment
+        .search(
+            SPARSE_VECTOR_NAME,
+            &query_vector,
+            &Default::default(),
+            &Default::default(),
+            None,
+            top,
+            None,
+            &stopped,
+        )
+        .unwrap();
+
+    assert_eq!(search_result.len(), top);
+
+    let path = segment.current_path.clone();
+    drop(segment);
+
+    let segment = load_segment(&path).unwrap().unwrap();
+    let search_after_reload_result = segment
+        .search(
+            SPARSE_VECTOR_NAME,
+            &query_vector,
+            &Default::default(),
+            &Default::default(),
+            None,
+            top,
+            None,
+            &stopped,
+        )
+        .unwrap();
+
+    assert_eq!(search_after_reload_result.len(), top);
+    assert_eq!(search_result, search_after_reload_result);
+}

commit 9f260907c58090abf6e2debff1c7ef6728c83282
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Dec 5 00:24:30 2023 +0100

    Fix optimizer change sparse index on disk (#3143)
    
    * Estimate sparse vector dimension for optimizer (#3142)
    
    * Estimate sparse vector dimension for optimizer
    
    * add hack explanation + todo
    
    Fix optimizer change sparse index on disk
    
    fix index to disk
    
    is appendable fix
    
    add index files if necessary
    
    fix test
    
    * fix tests
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 6c79c28fb..8c822f90b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -172,13 +172,32 @@ fn sparse_vector_index_consistent_with_storage() {
     check_index_storage_consistency(&sparse_vector_ram_index);
 
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
-    // copy index mmap and save to disk
-    let mmap_inverted_index = InvertedIndexMmap::convert_and_save(
-        &sparse_vector_ram_index.inverted_index,
-        &mmap_index_dir,
-    )
-    .unwrap();
-    drop(mmap_inverted_index);
+
+    // create mmap sparse vector index
+    let sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+        SparseVectorIndex::open(
+            sparse_index_config,
+            sparse_vector_ram_index.id_tracker.clone(),
+            sparse_vector_ram_index.vector_storage.clone(),
+            sparse_vector_ram_index.payload_index.clone(),
+            mmap_index_dir.path(),
+        )
+        .unwrap();
+
+    // build index
+    sparse_vector_mmap_index.build_index(&stopped).unwrap();
+
+    assert_eq!(
+        sparse_vector_mmap_index.indexed_vector_count(),
+        sparse_vector_ram_index.indexed_vector_count()
+    );
+
+    // check consistency with underlying mmap inverted index
+    check_index_storage_consistency(&sparse_vector_mmap_index);
+
+    // drop and reload index
+    drop(sparse_vector_mmap_index);
 
     // load index from memmap file
     let sparse_index_config = sparse_vector_ram_index.config;
@@ -205,8 +224,9 @@ fn sparse_vector_index_load_missing_mmap() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
         fixture_open_sparse_index(data_dir.path(), 0, 10_000);
-    // fails to open index if mmap file is missing
-    assert!(sparse_vector_index.is_err())
+    // absent configuration file for mmap are ignored
+    // a new index is created
+    assert!(sparse_vector_index.is_ok())
 }
 
 #[test]

commit d5a705e0faaf667641b82e53708fb2119a44d272
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Dec 5 20:32:23 2023 +0100

    Sparse vectors advanced search api support (#3128)
    
    * sparse vectors query scorer
    
    plain search test without internals
    
    fix sparse_vector_index_plain_search
    
    fix async scorer build
    
    fix unit tests
    
    are you happy fmt
    
    sparse index with full query support
    
    fix benches, use exact flag to force plain search
    
    add alias and comment to exact flag
    
    fix tests
    
    recommendations TODOs fix
    
    add simple test
    
    add todo
    
    refactor index
    
    test vs comparison dense and sparse discovery
    
    are you happy fmt
    
    propogate error from avg negatives
    
    reuse filtered points list
    
    rollback api changes
    
    better discovery test
    
    are you happy fmt
    
    rollback openapi
    
    fix build
    
    fix tests
    
    review remark recommendations
    
    review remarks
    
    review remarks
    
    codespell
    
    integrate plain search
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    fix comment of plain search
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    fix tests
    
    * simplify search query function

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 8c822f90b..eca947ee1 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -39,6 +39,9 @@ const NUM_VECTORS: usize = 2000;
 /// very low value to force usage of index
 const LOW_FULL_SCAN_THRESHOLD: usize = 1;
 
+/// Full scan threshold to force plain search
+const LARGE_FULL_SCAN_THRESHOLD: usize = 10 * NUM_VECTORS;
+
 const SPARSE_VECTOR_NAME: &str = "sparse_vector";
 
 /// Expects the filter to match ALL points in order to compare the results with/without filter
@@ -100,8 +103,11 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
                 filter_result,
                 no_filter_result,
             );
-            for (filter_result, no_filter_result) in
-                filter_result.iter().zip(no_filter_result.iter())
+            // skip zero scores because index skips non-overlapping points, but plain search does not
+            for (filter_result, no_filter_result) in filter_result
+                .iter()
+                .filter(|s| s.score != 0.0)
+                .zip(no_filter_result.iter().filter(|s| s.score != 0.0))
             {
                 assert_eq!(filter_result, no_filter_result);
             }
@@ -419,7 +425,7 @@ fn sparse_vector_index_plain_search() {
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
-        LOW_FULL_SCAN_THRESHOLD,
+        LARGE_FULL_SCAN_THRESHOLD,
         data_dir.path(),
         &stopped,
     );
@@ -437,7 +443,7 @@ fn sparse_vector_index_plain_search() {
 
     // empty when searching payload index directly
     let before_plain_results = sparse_vector_index
-        .search_plain(&[&query_vector], &filter, 10, &stopped)
+        .search(&[&query_vector], Some(&filter), 10, None, &stopped)
         .unwrap();
 
     assert_eq!(before_plain_results.len(), 1);
@@ -459,11 +465,20 @@ fn sparse_vector_index_plain_search() {
 
     // same results when searching payload index directly
     let after_plain_results = sparse_vector_index
-        .search_plain(&[&query_vector], &filter, NUM_VECTORS, &stopped)
+        .search(&[&query_vector], Some(&filter), NUM_VECTORS, None, &stopped)
         .unwrap();
 
     assert_eq!(after_plain_results.len(), 1);
     assert_eq!(after_plain_results[0].len(), NUM_VECTORS);
+
+    // check that plain searchers were used
+    assert_eq!(
+        sparse_vector_index
+            .get_telemetry_data()
+            .filtered_small_cardinality
+            .count,
+        2
+    );
 }
 
 #[test]

commit 9810823cb0656166e962681cd497dfe3b8e66072
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 6 10:58:11 2023 +0100

    Fix sparse mmap snapshot (#3166)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index eca947ee1..f1fb2a9f7 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -578,3 +578,44 @@ fn sparse_vector_persistence_test() {
     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
 }
+
+#[test]
+fn sparse_vector_index_files() {
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(42);
+
+    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
+    let sparse_vector_ram_index = fixture_sparse_index_ram(
+        &mut rnd,
+        1,
+        MAX_SPARSE_DIM,
+        LOW_FULL_SCAN_THRESHOLD,
+        data_dir.path(),
+        &stopped,
+    );
+
+    let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
+
+    // create mmap sparse vector index
+    let sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+        SparseVectorIndex::open(
+            sparse_index_config,
+            sparse_vector_ram_index.id_tracker.clone(),
+            sparse_vector_ram_index.vector_storage.clone(),
+            sparse_vector_ram_index.payload_index.clone(),
+            mmap_index_dir.path(),
+        )
+        .unwrap();
+
+    // build index
+    sparse_vector_mmap_index.build_index(&stopped).unwrap();
+
+    // files for RAM index
+    let ram_files = sparse_vector_ram_index.files();
+    assert_eq!(ram_files.len(), 1); // only the sparse index config file
+
+    // files for mmap index
+    let mmap_files = sparse_vector_mmap_index.files();
+    assert_eq!(mmap_files.len(), 3); // sparse index config + inverted index config + inverted index data
+}

commit 17827a33a1f1948df306701d8ab7560028eb2203
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 6 13:28:17 2023 +0100

    Internal sparse configs for segment (#3168)
    
    * internal sparse vector segment configs
    
    update openapi
    
    fix build
    
    provide correct index type to fixtures
    
    rename grpc stuff
    
    optional search threshold
    
    update api consistency
    
    * review fix
    
    * rollback rename
    
    * reger docs
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index f1fb2a9f7..c2c54d530 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -11,6 +11,7 @@ use segment::data_types::vectors::{QueryVector, Vector};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
+use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex};
 use segment::segment_constructor::{build_segment, load_segment};
@@ -180,7 +181,8 @@ fn sparse_vector_index_consistent_with_storage() {
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
-    let sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config;
+    sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
         SparseVectorIndex::open(
             sparse_index_config,
@@ -206,7 +208,8 @@ fn sparse_vector_index_consistent_with_storage() {
     drop(sparse_vector_mmap_index);
 
     // load index from memmap file
-    let sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config;
+    sparse_index_config.index_type = SparseIndexType::Mmap;
     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
         sparse_index_config,
         sparse_vector_ram_index.id_tracker.clone(),
@@ -229,7 +232,7 @@ fn sparse_vector_index_consistent_with_storage() {
 fn sparse_vector_index_load_missing_mmap() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
-        fixture_open_sparse_index(data_dir.path(), 0, 10_000);
+        fixture_open_sparse_index(data_dir.path(), 0, 10_000, SparseIndexType::Mmap);
     // absent configuration file for mmap are ignored
     // a new index is created
     assert!(sparse_vector_index.is_ok())
@@ -491,6 +494,7 @@ fn handling_empty_sparse_vectors() {
         data_dir.path(),
         NUM_VECTORS,
         DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+        SparseIndexType::ImmutableRam,
     )
     .unwrap();
 
@@ -523,7 +527,12 @@ fn sparse_vector_persistence_test() {
         vector_data: Default::default(),
         sparse_vector_data: HashMap::from([(
             SPARSE_VECTOR_NAME.to_owned(),
-            SparseVectorDataConfig { index: None },
+            SparseVectorDataConfig {
+                index: SparseIndexConfig {
+                    full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+                    index_type: SparseIndexType::MutableRam,
+                },
+            },
         )]),
         payload_storage_type: Default::default(),
     };

commit 8558399b4e0642054f6b7780a33784e3093cd9ba
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 6 17:36:08 2023 +0100

    Load non-appendable ram sparse vector index from file (#3154)
    
    * internal sparse vector segment configs
    
    update openapi
    
    fix build
    
    provide correct index type to fixtures
    
    internal sparse vector segment configs
    
    update openapi
    
    fix build
    
    load ram sparse index from file
    
    fix spelling
    
    add test
    
    spelling error
    
    use appendable flag to decide load or not
    
    fix conflict
    
    dont flush mmap when file is empty
    
    * fix build
    
    * set list of files for snapshot
    
    * fix snapshots test
    
    * fix codespell
    
    * simple save-load unit test
    
    * refactor InvertedIndex::files
    
    * fix unit tests
    
    * add debug_assert
    
    * test all persistence loading cases

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index c2c54d530..6ee56c5c7 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -513,7 +513,7 @@ fn handling_empty_sparse_vectors() {
 }
 
 #[test]
-fn sparse_vector_persistence_test() {
+fn sparse_vector_index_persistence_test() {
     let stopped = AtomicBool::new(false);
 
     let dim = 8;
@@ -570,6 +570,8 @@ fn sparse_vector_persistence_test() {
     let path = segment.current_path.clone();
     drop(segment);
 
+    // persistence using rebuild of inverted index
+    // for appendable segment vector index has to be rebuilt
     let segment = load_segment(&path).unwrap().unwrap();
     let search_after_reload_result = segment
         .search(
@@ -586,6 +588,117 @@ fn sparse_vector_persistence_test() {
 
     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
+
+    // persistence using loading RAM index from file
+    // because `segment` is appendable, create sparse index manually
+    let inverted_index_dir = Builder::new()
+        .prefix("inverted_index_ram")
+        .tempdir()
+        .unwrap();
+    let mut sparse_vector_index_ram: SparseVectorIndex<InvertedIndexRam> = SparseVectorIndex::open(
+        SparseIndexConfig {
+            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+            index_type: SparseIndexType::ImmutableRam,
+        },
+        segment.id_tracker.clone(),
+        segment.vector_data[SPARSE_VECTOR_NAME]
+            .vector_storage
+            .clone(),
+        segment.payload_index.clone(),
+        inverted_index_dir.path(),
+    )
+    .unwrap();
+    // call build index to create inverted index files
+    sparse_vector_index_ram.build_index(&stopped).unwrap();
+
+    // reload sparse index from file
+    drop(sparse_vector_index_ram);
+    let sparse_vector_index_ram: SparseVectorIndex<InvertedIndexRam> = SparseVectorIndex::open(
+        SparseIndexConfig {
+            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+            index_type: SparseIndexType::ImmutableRam,
+        },
+        segment.id_tracker.clone(),
+        segment.vector_data[SPARSE_VECTOR_NAME]
+            .vector_storage
+            .clone(),
+        segment.payload_index.clone(),
+        inverted_index_dir.path(),
+    )
+    .unwrap();
+
+    // check that the loaded index performs the same search
+    let search_after_reload_result = sparse_vector_index_ram
+        .search(&[&query_vector], None, top, None, &stopped)
+        .unwrap();
+    assert_eq!(search_after_reload_result[0].len(), top);
+    for (search_1, search_2) in search_result
+        .iter()
+        .zip(search_after_reload_result[0].iter())
+    {
+        let id_1 = segment
+            .id_tracker
+            .borrow_mut()
+            .internal_id(search_1.id)
+            .unwrap();
+        assert_eq!(id_1, search_2.idx);
+    }
+
+    // MMAP persistence
+    // because `segment` is appendable, create sparse index manually
+    let inverted_index_dir = Builder::new()
+        .prefix("inverted_index_ram")
+        .tempdir()
+        .unwrap();
+    let mut sparse_vector_index_mmap: SparseVectorIndex<InvertedIndexMmap> =
+        SparseVectorIndex::open(
+            SparseIndexConfig {
+                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+                index_type: SparseIndexType::Mmap,
+            },
+            segment.id_tracker.clone(),
+            segment.vector_data[SPARSE_VECTOR_NAME]
+                .vector_storage
+                .clone(),
+            segment.payload_index.clone(),
+            inverted_index_dir.path(),
+        )
+        .unwrap();
+    // call build index to create inverted index files
+    sparse_vector_index_mmap.build_index(&stopped).unwrap();
+
+    // reload sparse index from file
+    drop(sparse_vector_index_mmap);
+    let sparse_vector_index_mmap: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
+        SparseIndexConfig {
+            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+            index_type: SparseIndexType::Mmap,
+        },
+        segment.id_tracker.clone(),
+        segment.vector_data[SPARSE_VECTOR_NAME]
+            .vector_storage
+            .clone(),
+        segment.payload_index.clone(),
+        inverted_index_dir.path(),
+    )
+    .unwrap();
+
+    // check that the loaded index performs the same search
+    let search_after_reload_result = sparse_vector_index_mmap
+        .search(&[&query_vector], None, top, None, &stopped)
+        .unwrap();
+    assert_eq!(search_after_reload_result[0].len(), top);
+    for (search_1, search_2) in search_result
+        .iter()
+        .zip(search_after_reload_result[0].iter())
+    {
+        let id_1 = segment
+            .id_tracker
+            .borrow_mut()
+            .internal_id(search_1.id)
+            .unwrap();
+        assert_eq!(id_1, search_2.idx);
+    }
 }
 
 #[test]
@@ -606,7 +719,8 @@ fn sparse_vector_index_files() {
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
-    let sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config;
+    sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
         SparseVectorIndex::open(
             sparse_index_config,
@@ -620,11 +734,35 @@ fn sparse_vector_index_files() {
     // build index
     sparse_vector_mmap_index.build_index(&stopped).unwrap();
 
-    // files for RAM index
+    // files for immutable RAM index
     let ram_files = sparse_vector_ram_index.files();
-    assert_eq!(ram_files.len(), 1); // only the sparse index config file
+    assert_eq!(ram_files.len(), 3); // only the sparse index config file
 
     // files for mmap index
     let mmap_files = sparse_vector_mmap_index.files();
     assert_eq!(mmap_files.len(), 3); // sparse index config + inverted index config + inverted index data
+
+    // create mutable RAM sparse vector index
+    let mutable_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
+    let mut sparse_index_config = sparse_vector_ram_index.config;
+    sparse_index_config.index_type = SparseIndexType::MutableRam;
+    let mut sparse_vector_mutable_index: SparseVectorIndex<InvertedIndexRam> =
+        SparseVectorIndex::open(
+            sparse_index_config,
+            sparse_vector_ram_index.id_tracker.clone(),
+            sparse_vector_ram_index.vector_storage.clone(),
+            sparse_vector_ram_index.payload_index.clone(),
+            mutable_index_dir.path(),
+        )
+        .unwrap();
+
+    sparse_vector_mutable_index.build_index(&stopped).unwrap();
+    assert_eq!(
+        sparse_vector_mutable_index.indexed_vector_count(),
+        sparse_vector_mmap_index.indexed_vector_count(),
+    );
+
+    // files for mutable index
+    let mutable_index_files = sparse_vector_mutable_index.files();
+    assert_eq!(mutable_index_files.len(), 1);
 }

commit 772a8a75d9186e1de19776d737b2adc8c88f1ad0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Dec 16 00:02:01 2023 +0000

    sparse vectors with large indices support (#3230)
    
    * sparse vectors with large indices support
    
    * fix unit tests
    
    * add tracker file to snapshot
    
    * fix unit tests
    
    * are you happy clippy
    
    * fix config loading
    
    * test with max value
    
    * fix python tests
    
    * fix consensus tests
    
    * review remarks; acc test for inverted index

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 6ee56c5c7..1f76f0ffb 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -13,7 +13,7 @@ use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
-use segment::index::{PayloadIndex, VectorIndex};
+use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
@@ -25,6 +25,7 @@ use segment::vector_storage::VectorStorage;
 use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
+use sparse::common::types::DimId;
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
 use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
@@ -136,10 +137,17 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
         // assuming no deleted points
         let vector = borrowed_vector_storage.get_vector(id);
         let vector: &SparseVector = vector.as_vec_ref().try_into().unwrap();
+        let remapped_vector = sparse_vector_index
+            .indices_tracker
+            .remap_vector(vector.to_owned());
         // check posting lists are consistent with storage
-        for (dim_id, dim_value) in vector.indices.iter().zip(vector.values.iter()) {
+        for (dim_id, dim_value) in remapped_vector
+            .indices
+            .iter()
+            .zip(remapped_vector.values.iter())
+        {
             let posting_list = sparse_vector_index.inverted_index.get(dim_id).unwrap();
-            // assert posting list sorted  by record id
+            // assert posting list sorted by record id
             assert!(posting_list
                 .elements
                 .windows(2)
@@ -736,11 +744,13 @@ fn sparse_vector_index_files() {
 
     // files for immutable RAM index
     let ram_files = sparse_vector_ram_index.files();
-    assert_eq!(ram_files.len(), 3); // only the sparse index config file
+    // sparse index config + inverted index config + inverted index data + tracker
+    assert_eq!(ram_files.len(), 4);
 
     // files for mmap index
     let mmap_files = sparse_vector_mmap_index.files();
-    assert_eq!(mmap_files.len(), 3); // sparse index config + inverted index config + inverted index data
+    // sparse index config + inverted index config + inverted index data + tracker
+    assert_eq!(mmap_files.len(), 4);
 
     // create mutable RAM sparse vector index
     let mutable_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
@@ -764,5 +774,50 @@ fn sparse_vector_index_files() {
 
     // files for mutable index
     let mutable_index_files = sparse_vector_mutable_index.files();
-    assert_eq!(mutable_index_files.len(), 1);
+    assert_eq!(mutable_index_files.len(), 1); // only the sparse index config file
+}
+
+#[test]
+fn sparse_vector_test_large_index() {
+    let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
+    let config = SegmentConfig {
+        vector_data: Default::default(),
+        sparse_vector_data: HashMap::from([(
+            SPARSE_VECTOR_NAME.to_owned(),
+            SparseVectorDataConfig {
+                index: SparseIndexConfig {
+                    full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+                    index_type: SparseIndexType::MutableRam,
+                },
+            },
+        )]),
+        payload_storage_type: Default::default(),
+    };
+    let mut segment = build_segment(dir.path(), &config, true).unwrap();
+
+    let vector: Vector = SparseVector {
+        indices: vec![DimId::MAX],
+        values: vec![0.0],
+    }
+    .into();
+    let mut named_vector = NamedVectors::default();
+    named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
+    let idx = 0.into();
+    segment
+        .upsert_point(0 as SeqNumberType, idx, named_vector)
+        .unwrap();
+
+    let borrowed_vector_index = segment.vector_data[SPARSE_VECTOR_NAME]
+        .vector_index
+        .borrow();
+    match &*borrowed_vector_index {
+        VectorIndexEnum::SparseRam(sparse_vector_index) => {
+            assert!(sparse_vector_index
+                .indices_tracker
+                .remap_index(DimId::MAX)
+                .is_some());
+            assert_eq!(sparse_vector_index.inverted_index.max_index().unwrap(), 0);
+        }
+        _ => panic!("unexpected vector index type"),
+    }
 }

commit 19514265330ac9a1049b9439517deb104a5a19ed
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Jan 31 11:56:34 2024 +0100

    Dynamic CPU saturation internals (#3364)
    
    * Move CPU count function to common, fix wrong CPU count in visited list
    
    * Change default number of rayon threads to 8
    
    * Use CPU budget and CPU permits for optimizer tasks to limit utilization
    
    * Respect configured thread limits, use new sane defaults in config
    
    * Fix spelling issues
    
    * Fix test compilation error
    
    * Improve breaking if there is no CPU budget
    
    * Block optimizations until CPU budget, fix potentially getting stuck
    
    Our optimization worker now blocks until CPU budget is available to
    perform the task.
    
    Fix potential issue where optimization worker could get stuck. This
    would happen if no optimization task is started because there's no
    available CPU budget. This ensures the worker is woken up again to
    retry.
    
    * Utilize n-1 CPUs with optimization tasks
    
    * Better handle situations where CPU budget is drained
    
    * Dynamically scale rayon CPU count based on CPU size
    
    * Fix incorrect default for max_indexing_threads conversion
    
    * Respect max_indexing_threads for collection
    
    * Make max_indexing_threads optional, use none to set no limit
    
    * Update property documentation and comments
    
    * Property max_optimization_threads is per shard, not per collection
    
    * If we reached shard optimization limit, skip further checks
    
    * Add remaining TODOs
    
    * Fix spelling mistake
    
    * Align gRPC comment blocks
    
    * Fix compilation errors since last rebase
    
    * Make tests aware of CPU budget
    
    * Use new CPU budget calculation function everywhere
    
    * Make CPU budget configurable in settings, move static budget to common
    
    * Do not use static CPU budget, instance it and pass it through
    
    * Update CPU budget description
    
    * Move heuristic into defaults
    
    * Fix spelling issues
    
    * Move cpu_budget property to a better place
    
    * Move some things around
    
    * Minor review improvements
    
    * Use range match statement for CPU count heuristics
    
    * Systems with 1 or 2 CPUs do not keep cores unallocated by default
    
    * Fix compilation errors since last rebase
    
    * Update lib/segment/src/types.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Update lib/storage/src/content_manager/toc/transfer.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Rename cpu_budget to optimizer_cpu_budget
    
    * Update OpenAPI specification
    
    * Require at least half of the desired CPUs for optimizers
    
    This prevents running optimizations with just one CPU, which could be
    very slow.
    
    * Don't use wildcard in CPU heuristic match statements
    
    * Rename cpu_budget setting to optimizer_cpu_budget
    
    * Update CPU budget comments
    
    * Spell acquire correctly
    
    * Change if-else into match
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Rename max_rayon_threads to num_rayon_threads, add explanation
    
    * Explain limit in update handler
    
    * Remove numbers for automatic selection of indexing threads
    
    * Inline max_workers variable
    
    * Remove CPU budget from ShardTransferConsensus trait, it is in collection
    
    * small allow(dead_code) => cfg(test)
    
    * Remove now obsolete lazy_static
    
    * Fix incorrect CPU calculation in CPU saturation test
    
    * Make waiting for CPU budget async, don't block current thread
    
    * Prevent deadlock on optimizer signal channel
    
    Do not block the optimization worker task anymore to wait for CPU budget
    to be available. That prevents our optimizer signal channel from being
    drained, blocking incoming updates because the cannot send another
    optimizer signal. Now, prevent blocking this task all together and
    retrigger the optimizers separately when CPU budget is available again.
    
    * Fix incorrect CPU calculation in optimization cancel test
    
    * Rename CPU budget wait function to notify
    
    * Detach API changes from CPU saturation internals
    
    This allows us to merge into a patch version of Qdrant. We can
    reintroduce the API changes in the upcoming minor release to make all of
    it fully functional.
    
    ---------
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 1f76f0ffb..03aeffe2f 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,7 +1,9 @@
 use std::cmp::max;
 use std::collections::HashMap;
 use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
 
+use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use rand::rngs::StdRng;
 use rand::SeedableRng;
@@ -11,6 +13,7 @@ use segment::data_types::vectors::{QueryVector, Vector};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
+use segment::index::hnsw_index::num_rayon_threads;
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
@@ -183,6 +186,9 @@ fn sparse_vector_index_consistent_with_storage() {
         &stopped,
     );
 
+    let permit_cpu_count = num_rayon_threads(0);
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+
     // check consistency with underlying RAM inverted index
     check_index_storage_consistency(&sparse_vector_ram_index);
 
@@ -202,7 +208,9 @@ fn sparse_vector_index_consistent_with_storage() {
         .unwrap();
 
     // build index
-    sparse_vector_mmap_index.build_index(&stopped).unwrap();
+    sparse_vector_mmap_index
+        .build_index(permit, &stopped)
+        .unwrap();
 
     assert_eq!(
         sparse_vector_mmap_index.indexed_vector_count(),
@@ -320,8 +328,11 @@ fn sparse_vector_index_ram_deleted_points_search() {
         sparse_vector_index.indexed_vector_count() - 1
     );
 
+    let permit_cpu_count = num_rayon_threads(0);
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+
     // refresh index to remove point
-    sparse_vector_index.build_index(&stopped).unwrap();
+    sparse_vector_index.build_index(permit, &stopped).unwrap();
     assert_eq!(
         sparse_vector_index
             .id_tracker
@@ -505,9 +516,31 @@ fn handling_empty_sparse_vectors() {
         SparseIndexType::ImmutableRam,
     )
     .unwrap();
+    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
+
+    // add empty points to storage
+    for idx in 0..NUM_VECTORS {
+        let vec = &SparseVector::new(vec![], vec![]).unwrap();
+        borrowed_storage
+            .insert_vector(idx as PointOffsetType, vec.into())
+            .unwrap();
+    }
+    drop(borrowed_storage);
+
+    // assert all empty points are in storage
+    assert_eq!(
+        sparse_vector_index
+            .vector_storage
+            .borrow()
+            .available_vector_count(),
+        NUM_VECTORS,
+    );
+
+    let permit_cpu_count = num_rayon_threads(0);
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
 
     // empty vectors are not indexed
-    sparse_vector_index.build_index(&stopped).unwrap();
+    sparse_vector_index.build_index(permit, &stopped).unwrap();
     assert_eq!(sparse_vector_index.indexed_vector_count(), 0);
 
     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
@@ -546,6 +579,9 @@ fn sparse_vector_index_persistence_test() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
+    let permit_cpu_count = num_rayon_threads(0);
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+
     for n in 0..num_vectors {
         let vector: Vector = random_sparse_vector(&mut rnd, dim).into();
         let mut named_vector = NamedVectors::default();
@@ -617,7 +653,9 @@ fn sparse_vector_index_persistence_test() {
     )
     .unwrap();
     // call build index to create inverted index files
-    sparse_vector_index_ram.build_index(&stopped).unwrap();
+    sparse_vector_index_ram
+        .build_index(permit, &stopped)
+        .unwrap();
 
     // reload sparse index from file
     drop(sparse_vector_index_ram);
@@ -673,7 +711,10 @@ fn sparse_vector_index_persistence_test() {
         )
         .unwrap();
     // call build index to create inverted index files
-    sparse_vector_index_mmap.build_index(&stopped).unwrap();
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+    sparse_vector_index_mmap
+        .build_index(permit, &stopped)
+        .unwrap();
 
     // reload sparse index from file
     drop(sparse_vector_index_mmap);
@@ -724,6 +765,9 @@ fn sparse_vector_index_files() {
         &stopped,
     );
 
+    let permit_cpu_count = num_rayon_threads(0);
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
@@ -740,7 +784,9 @@ fn sparse_vector_index_files() {
         .unwrap();
 
     // build index
-    sparse_vector_mmap_index.build_index(&stopped).unwrap();
+    sparse_vector_mmap_index
+        .build_index(permit, &stopped)
+        .unwrap();
 
     // files for immutable RAM index
     let ram_files = sparse_vector_ram_index.files();
@@ -766,7 +812,10 @@ fn sparse_vector_index_files() {
         )
         .unwrap();
 
-    sparse_vector_mutable_index.build_index(&stopped).unwrap();
+    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
+    sparse_vector_mutable_index
+        .build_index(permit, &stopped)
+        .unwrap();
     assert_eq!(
         sparse_vector_mutable_index.indexed_vector_count(),
         sparse_vector_mmap_index.indexed_vector_count(),

commit 8ae92d47161cbb90b6c211400cc307069858ffc6
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:52:03 2024 +0100

    allow stopping segment loading (#3498)
    
    * allow stopping segment loading
    
    * fix benches

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 03aeffe2f..e15399e34 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -204,6 +204,7 @@ fn sparse_vector_index_consistent_with_storage() {
             sparse_vector_ram_index.vector_storage.clone(),
             sparse_vector_ram_index.payload_index.clone(),
             mmap_index_dir.path(),
+            &stopped,
         )
         .unwrap();
 
@@ -232,6 +233,7 @@ fn sparse_vector_index_consistent_with_storage() {
         sparse_vector_ram_index.vector_storage.clone(),
         sparse_vector_ram_index.payload_index.clone(),
         mmap_index_dir.path(),
+        &stopped,
     )
     .unwrap();
 
@@ -248,7 +250,13 @@ fn sparse_vector_index_consistent_with_storage() {
 fn sparse_vector_index_load_missing_mmap() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
-        fixture_open_sparse_index(data_dir.path(), 0, 10_000, SparseIndexType::Mmap);
+        fixture_open_sparse_index(
+            data_dir.path(),
+            0,
+            10_000,
+            SparseIndexType::Mmap,
+            &AtomicBool::new(false),
+        );
     // absent configuration file for mmap are ignored
     // a new index is created
     assert!(sparse_vector_index.is_ok())
@@ -514,6 +522,7 @@ fn handling_empty_sparse_vectors() {
         NUM_VECTORS,
         DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
         SparseIndexType::ImmutableRam,
+        &stopped,
     )
     .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
@@ -616,7 +625,7 @@ fn sparse_vector_index_persistence_test() {
 
     // persistence using rebuild of inverted index
     // for appendable segment vector index has to be rebuilt
-    let segment = load_segment(&path).unwrap().unwrap();
+    let segment = load_segment(&path, &stopped).unwrap().unwrap();
     let search_after_reload_result = segment
         .search(
             SPARSE_VECTOR_NAME,
@@ -650,6 +659,7 @@ fn sparse_vector_index_persistence_test() {
             .clone(),
         segment.payload_index.clone(),
         inverted_index_dir.path(),
+        &stopped,
     )
     .unwrap();
     // call build index to create inverted index files
@@ -670,6 +680,7 @@ fn sparse_vector_index_persistence_test() {
             .clone(),
         segment.payload_index.clone(),
         inverted_index_dir.path(),
+        &stopped,
     )
     .unwrap();
 
@@ -708,6 +719,7 @@ fn sparse_vector_index_persistence_test() {
                 .clone(),
             segment.payload_index.clone(),
             inverted_index_dir.path(),
+            &stopped,
         )
         .unwrap();
     // call build index to create inverted index files
@@ -729,6 +741,7 @@ fn sparse_vector_index_persistence_test() {
             .clone(),
         segment.payload_index.clone(),
         inverted_index_dir.path(),
+        &stopped,
     )
     .unwrap();
 
@@ -780,6 +793,7 @@ fn sparse_vector_index_files() {
             sparse_vector_ram_index.vector_storage.clone(),
             sparse_vector_ram_index.payload_index.clone(),
             mmap_index_dir.path(),
+            &stopped,
         )
         .unwrap();
 
@@ -809,6 +823,7 @@ fn sparse_vector_index_files() {
             sparse_vector_ram_index.vector_storage.clone(),
             sparse_vector_ram_index.payload_index.clone(),
             mutable_index_dir.path(),
+            &stopped,
         )
         .unwrap();
 

commit 87b541bb41560adf4609190cc0a7c1ed1da6e2f3
Author: shylock <tcath2s@gmail.com>
Date:   Thu Feb 15 22:15:05 2024 +0800

    Feat/set payload by key (#3548)
    
    * Support set by key in low level.
    
    * Rename key field.
    
    * Format.
    
    * Pass key.
    
    * Format.
    
    * Test.
    
    * Clippy.
    
    * Fix ci lint.
    
    * Check grpc consistency.
    
    * Update openapi.
    
    * Fix empty key test case.
    
    * Support array index.
    
    * Format.
    
    * Add test for non exists key.
    
    * Clippy fix.
    
    * Add idempotence test.
    
    * Update index by updated payload.
    
    * Add ut for utils.
    
    * Add ut for 1 level key.
    
    * Fix ut.
    
    * Support no exits key.
    
    * Fix test result.
    
    * Fix after rebase
    
    * handle wildcart insertion into non-existing array
    
    * avoid double read of payload during update
    
    * fix missing removing data from index in case if set_payload removes indexed field
    
    ---------
    
    Co-authored-by: Shylock Hg <shylock@DESKTOP-40I855A>
    Co-authored-by: Albert Safin <xzfcpw@gmail.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index e15399e34..d2c9cb3f8 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -418,7 +418,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
     for idx in 0..half_indexed_count {
         payload_index
-            .assign(idx as PointOffsetType, &payload)
+            .assign(idx as PointOffsetType, &payload, &None)
             .unwrap();
     }
     drop(payload_index);
@@ -488,7 +488,7 @@ fn sparse_vector_index_plain_search() {
     let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
     for idx in 0..NUM_VECTORS {
         payload_index
-            .assign(idx as PointOffsetType, &payload)
+            .assign(idx as PointOffsetType, &payload, &None)
             .unwrap();
     }
     drop(payload_index);

commit d39a483017d14971051e30be5023dd4e969163b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Feb 20 14:55:57 2024 +0000

    Refactor: introduce details level enum (#3612)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index d2c9cb3f8..1632b8a20 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -4,7 +4,7 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::cpu::CpuPermit;
-use common::types::PointOffsetType;
+use common::types::{PointOffsetType, TelemetryDetail};
 use rand::rngs::StdRng;
 use rand::SeedableRng;
 use segment::common::operation_error::OperationResult;
@@ -504,7 +504,7 @@ fn sparse_vector_index_plain_search() {
     // check that plain searchers were used
     assert_eq!(
         sparse_vector_index
-            .get_telemetry_data()
+            .get_telemetry_data(TelemetryDetail::default())
             .filtered_small_cardinality
             .count,
         2

commit 3beb4e3b4ff4b3f9585337f4e5b0826a14e247b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Feb 23 14:38:40 2024 +0000

    Introduce JsonPathString (#3674)
    
    * Introduce JsonPathString
    
    * Fix fomatting

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 1632b8a20..818ba32d7 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -34,6 +34,8 @@ use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
+use crate::utils::path;
+
 /// Max dimension of sparse vectors used in tests
 const MAX_SPARSE_DIM: usize = 4096;
 
@@ -73,7 +75,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
 
     // filter matches everything
     let filter = Filter::new_must_not(Condition::Field(FieldCondition::new_match(
-        STR_KEY,
+        path(STR_KEY),
         STR_KEY.to_owned().into(),
     )));
 
@@ -380,7 +382,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let field_name = "field";
     let field_value = "important value";
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
-        field_name,
+        path(field_name),
         field_value.to_owned().into(),
     )));
 
@@ -395,17 +397,20 @@ fn sparse_vector_index_ram_filtered_search() {
     // create payload field index
     let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
     payload_index
-        .set_indexed(field_name, Keyword.into())
+        .set_indexed(&path(field_name), Keyword.into())
         .unwrap();
     drop(payload_index);
 
     // assert payload field index created and empty
     let payload_index = sparse_vector_index.payload_index.borrow();
     let indexed_fields = payload_index.indexed_fields();
-    assert_eq!(*indexed_fields.get(field_name).unwrap(), FieldType(Keyword));
+    assert_eq!(
+        *indexed_fields.get(&path(field_name)).unwrap(),
+        FieldType(Keyword)
+    );
 
     let field_indexes = &payload_index.field_indexes;
-    let field_index = field_indexes.get(field_name).unwrap();
+    let field_index = field_indexes.get(&path(field_name)).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), 0);
     drop(payload_index);
 
@@ -426,7 +431,7 @@ fn sparse_vector_index_ram_filtered_search() {
     // assert payload index updated
     let payload_index = sparse_vector_index.payload_index.borrow();
     let field_indexes = &payload_index.field_indexes;
-    let field_index = field_indexes.get(field_name).unwrap();
+    let field_index = field_indexes.get(&path(field_name)).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), half_indexed_count);
     drop(payload_index);
 
@@ -464,7 +469,7 @@ fn sparse_vector_index_plain_search() {
     let field_name = "field";
     let field_value = "important value";
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
-        field_name,
+        path(field_name),
         field_value.to_owned().into(),
     )));
 

commit e54ab8a636ecbfa3fe70f85fce1058ce655099fb
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 11 13:16:56 2024 +0200

    Fix indexed-only behavior for proxy shard (#3998)
    
    * move check for unindexed segment size inside the segment to allow proxy shard decide where to search better
    
    * fmt
    
    * move indexed_only check inside the plain index

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 818ba32d7..c30b4e72e 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -88,12 +88,19 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
         let query_vector: QueryVector = query.clone().into();
         // with filter
         let index_results_filter = sparse_vector_index
-            .search(&[&query_vector], Some(&filter), top, None, &stopped)
+            .search(
+                &[&query_vector],
+                Some(&filter),
+                top,
+                None,
+                &stopped,
+                usize::MAX,
+            )
             .unwrap();
 
         // without filter
         let index_results_no_filter = sparse_vector_index
-            .search(&[&query_vector], None, top, None, &stopped)
+            .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
             .unwrap();
 
         assert_eq!(index_results_filter.len(), index_results_no_filter.len());
@@ -167,7 +174,7 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
         let top = sparse_vector_index.max_result_count(vector);
         let query_vector: QueryVector = vector.to_owned().into();
         let results = sparse_vector_index
-            .search(&[&query_vector], None, top, None, &false.into())
+            .search(&[&query_vector], None, top, None, &false.into(), usize::MAX)
             .unwrap();
         assert!(results[0].iter().any(|s| s.idx == id));
     }
@@ -300,7 +307,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
     // query index
     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
     let before_deletion_results: Vec<_> = sparse_vector_index
-        .search(&[&query_vector], None, top, None, &stopped)
+        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
         .unwrap();
 
     // pick a point to delete
@@ -353,7 +360,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
     // assert that the deleted point is no longer in the index
     let after_deletion_results: Vec<_> = sparse_vector_index
-        .search(&[&query_vector], None, top, None, &stopped)
+        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
         .unwrap();
     assert_ne!(before_deletion_results, after_deletion_results);
     assert!(after_deletion_results
@@ -389,7 +396,14 @@ fn sparse_vector_index_ram_filtered_search() {
     // query all sparse dimension to get all points
     let query_vector: QueryVector = random_full_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
     let before_result = sparse_vector_index
-        .search(&[&query_vector], Some(&filter), 10, None, &stopped)
+        .search(
+            &[&query_vector],
+            Some(&filter),
+            10,
+            None,
+            &stopped,
+            usize::MAX,
+        )
         .unwrap();
     assert_eq!(before_result.len(), 1);
     assert_eq!(before_result[0].len(), 0);
@@ -443,6 +457,7 @@ fn sparse_vector_index_ram_filtered_search() {
             half_indexed_count * 2, // original top
             None,
             &stopped,
+            usize::MAX,
         )
         .unwrap();
     assert_eq!(after_result.len(), 1);
@@ -478,7 +493,14 @@ fn sparse_vector_index_plain_search() {
 
     // empty when searching payload index directly
     let before_plain_results = sparse_vector_index
-        .search(&[&query_vector], Some(&filter), 10, None, &stopped)
+        .search(
+            &[&query_vector],
+            Some(&filter),
+            10,
+            None,
+            &stopped,
+            usize::MAX,
+        )
         .unwrap();
 
     assert_eq!(before_plain_results.len(), 1);
@@ -500,7 +522,14 @@ fn sparse_vector_index_plain_search() {
 
     // same results when searching payload index directly
     let after_plain_results = sparse_vector_index
-        .search(&[&query_vector], Some(&filter), NUM_VECTORS, None, &stopped)
+        .search(
+            &[&query_vector],
+            Some(&filter),
+            NUM_VECTORS,
+            None,
+            &stopped,
+            usize::MAX,
+        )
         .unwrap();
 
     assert_eq!(after_plain_results.len(), 1);
@@ -561,7 +590,7 @@ fn handling_empty_sparse_vectors() {
 
     // empty vectors are not searchable (recommend using scroll API to retrieve those)
     let results = sparse_vector_index
-        .search(&[&query_vector], None, 10, None, &stopped)
+        .search(&[&query_vector], None, 10, None, &stopped, usize::MAX)
         .unwrap();
     assert_eq!(results.len(), 1);
     assert_eq!(results[0].len(), 0);
@@ -691,7 +720,7 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_ram
-        .search(&[&query_vector], None, top, None, &stopped)
+        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result
@@ -752,7 +781,7 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_mmap
-        .search(&[&query_vector], None, top, None, &stopped)
+        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result

commit 01f5c667bc6d0669b16759dacf5e2cf815497809
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 11 22:52:01 2024 +0200

    remove search method from serment trait to simplify usage in tests and prevent accidental usage in release (#3999)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index c30b4e72e..8f57ad283 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -648,7 +648,6 @@ fn sparse_vector_index_persistence_test() {
             None,
             top,
             None,
-            &stopped,
         )
         .unwrap();
 
@@ -669,7 +668,6 @@ fn sparse_vector_index_persistence_test() {
             None,
             top,
             None,
-            &stopped,
         )
         .unwrap();
 

commit 0cfb3b0e1d579e5ce633432f640a7f25b6437740
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Apr 19 13:27:21 2024 +0200

    Median based TopK for sparse vectors scoring (#4037)
    
    * Median based TopK for sparse vectors scoring
    
    * add test with identical scores

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 8f57ad283..4060daff2 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -123,7 +123,12 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
                 .filter(|s| s.score != 0.0)
                 .zip(no_filter_result.iter().filter(|s| s.score != 0.0))
             {
-                assert_eq!(filter_result, no_filter_result);
+                if filter_result.idx != no_filter_result.idx {
+                    // we do not break ties when identical scores
+                    assert_eq!(filter_result.score, no_filter_result.score);
+                } else {
+                    assert_eq!(filter_result, no_filter_result);
+                }
             }
         }
     }

commit 896cfe109d9a6dd5a9a4ab39422899d6d238a5c6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 29 14:54:14 2024 +0200

    Sparse idf dot (#4126)
    
    * introduce QueryContext, which accumulates runtime info needed for executing search
    
    * fmt
    
    * propagate query context into segment internals
    
    * [WIP] prepare idf stats for search query context
    
    * Split SparseVector and RemmapedSparseVector to guarantee we will not mix them up on the type level
    
    * implement filling of the query context with IDF statistics
    
    * implement re-weighting of the sparse query with idf
    
    * fmt
    
    * update idf param only if explicitly specified (more consistent with diff param update
    
    * replace idf bool with modifier enum, improve further extensibility
    
    * test and fixes
    
    * Update lib/collection/src/operations/types.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * review fixes
    
    * fmt
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 4060daff2..d6a8ff546 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -94,13 +94,20 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
                 top,
                 None,
                 &stopped,
-                usize::MAX,
+                &Default::default(),
             )
             .unwrap();
 
         // without filter
         let index_results_no_filter = sparse_vector_index
-            .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
+            .search(
+                &[&query_vector],
+                None,
+                top,
+                None,
+                &stopped,
+                &Default::default(),
+            )
             .unwrap();
 
         assert_eq!(index_results_filter.len(), index_results_no_filter.len());
@@ -179,7 +186,14 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
         let top = sparse_vector_index.max_result_count(vector);
         let query_vector: QueryVector = vector.to_owned().into();
         let results = sparse_vector_index
-            .search(&[&query_vector], None, top, None, &false.into(), usize::MAX)
+            .search(
+                &[&query_vector],
+                None,
+                top,
+                None,
+                &false.into(),
+                &Default::default(),
+            )
             .unwrap();
         assert!(results[0].iter().any(|s| s.idx == id));
     }
@@ -312,7 +326,14 @@ fn sparse_vector_index_ram_deleted_points_search() {
     // query index
     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
     let before_deletion_results: Vec<_> = sparse_vector_index
-        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
+        .search(
+            &[&query_vector],
+            None,
+            top,
+            None,
+            &stopped,
+            &Default::default(),
+        )
         .unwrap();
 
     // pick a point to delete
@@ -365,7 +386,14 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
     // assert that the deleted point is no longer in the index
     let after_deletion_results: Vec<_> = sparse_vector_index
-        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
+        .search(
+            &[&query_vector],
+            None,
+            top,
+            None,
+            &stopped,
+            &Default::default(),
+        )
         .unwrap();
     assert_ne!(before_deletion_results, after_deletion_results);
     assert!(after_deletion_results
@@ -407,7 +435,7 @@ fn sparse_vector_index_ram_filtered_search() {
             10,
             None,
             &stopped,
-            usize::MAX,
+            &Default::default(),
         )
         .unwrap();
     assert_eq!(before_result.len(), 1);
@@ -462,7 +490,7 @@ fn sparse_vector_index_ram_filtered_search() {
             half_indexed_count * 2, // original top
             None,
             &stopped,
-            usize::MAX,
+            &Default::default(),
         )
         .unwrap();
     assert_eq!(after_result.len(), 1);
@@ -504,7 +532,7 @@ fn sparse_vector_index_plain_search() {
             10,
             None,
             &stopped,
-            usize::MAX,
+            &Default::default(),
         )
         .unwrap();
 
@@ -533,7 +561,7 @@ fn sparse_vector_index_plain_search() {
             NUM_VECTORS,
             None,
             &stopped,
-            usize::MAX,
+            &Default::default(),
         )
         .unwrap();
 
@@ -595,7 +623,14 @@ fn handling_empty_sparse_vectors() {
 
     // empty vectors are not searchable (recommend using scroll API to retrieve those)
     let results = sparse_vector_index
-        .search(&[&query_vector], None, 10, None, &stopped, usize::MAX)
+        .search(
+            &[&query_vector],
+            None,
+            10,
+            None,
+            &stopped,
+            &Default::default(),
+        )
         .unwrap();
     assert_eq!(results.len(), 1);
     assert_eq!(results[0].len(), 0);
@@ -723,7 +758,14 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_ram
-        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
+        .search(
+            &[&query_vector],
+            None,
+            top,
+            None,
+            &stopped,
+            &Default::default(),
+        )
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result
@@ -784,7 +826,14 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_mmap
-        .search(&[&query_vector], None, top, None, &stopped, usize::MAX)
+        .search(
+            &[&query_vector],
+            None,
+            top,
+            None,
+            &stopped,
+            &Default::default(),
+        )
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result

commit e663f8aa8710ad6e5f9c22c151617be7ac0ac6be
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 6 11:51:50 2024 +0200

    Faster deleted filter in proxy segments (#4148)
    
    * [WIP] introduce internal has-id check
    
    * fmt
    
    * update value of the deleted_mask in proxy
    
    * use deleted_points from the context, if present
    
    * fmt
    
    * move stopped flag into query context
    
    * fmt
    
    * segment-specific query context
    
    * enable custom deleted mask in proxy
    
    * remove unused HasIdConditionInternal
    
    * fix tests
    
    * remove debug

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index d6a8ff546..73dbcf389 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -93,21 +93,13 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
                 Some(&filter),
                 top,
                 None,
-                &stopped,
                 &Default::default(),
             )
             .unwrap();
 
         // without filter
         let index_results_no_filter = sparse_vector_index
-            .search(
-                &[&query_vector],
-                None,
-                top,
-                None,
-                &stopped,
-                &Default::default(),
-            )
+            .search(&[&query_vector], None, top, None, &Default::default())
             .unwrap();
 
         assert_eq!(index_results_filter.len(), index_results_no_filter.len());
@@ -186,14 +178,7 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
         let top = sparse_vector_index.max_result_count(vector);
         let query_vector: QueryVector = vector.to_owned().into();
         let results = sparse_vector_index
-            .search(
-                &[&query_vector],
-                None,
-                top,
-                None,
-                &false.into(),
-                &Default::default(),
-            )
+            .search(&[&query_vector], None, top, None, &Default::default())
             .unwrap();
         assert!(results[0].iter().any(|s| s.idx == id));
     }
@@ -326,14 +311,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
     // query index
     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
     let before_deletion_results: Vec<_> = sparse_vector_index
-        .search(
-            &[&query_vector],
-            None,
-            top,
-            None,
-            &stopped,
-            &Default::default(),
-        )
+        .search(&[&query_vector], None, top, None, &Default::default())
         .unwrap();
 
     // pick a point to delete
@@ -386,14 +364,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
     // assert that the deleted point is no longer in the index
     let after_deletion_results: Vec<_> = sparse_vector_index
-        .search(
-            &[&query_vector],
-            None,
-            top,
-            None,
-            &stopped,
-            &Default::default(),
-        )
+        .search(&[&query_vector], None, top, None, &Default::default())
         .unwrap();
     assert_ne!(before_deletion_results, after_deletion_results);
     assert!(after_deletion_results
@@ -434,7 +405,6 @@ fn sparse_vector_index_ram_filtered_search() {
             Some(&filter),
             10,
             None,
-            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -489,7 +459,6 @@ fn sparse_vector_index_ram_filtered_search() {
             Some(&filter),
             half_indexed_count * 2, // original top
             None,
-            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -531,7 +500,6 @@ fn sparse_vector_index_plain_search() {
             Some(&filter),
             10,
             None,
-            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -560,7 +528,6 @@ fn sparse_vector_index_plain_search() {
             Some(&filter),
             NUM_VECTORS,
             None,
-            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -623,14 +590,7 @@ fn handling_empty_sparse_vectors() {
 
     // empty vectors are not searchable (recommend using scroll API to retrieve those)
     let results = sparse_vector_index
-        .search(
-            &[&query_vector],
-            None,
-            10,
-            None,
-            &stopped,
-            &Default::default(),
-        )
+        .search(&[&query_vector], None, 10, None, &Default::default())
         .unwrap();
     assert_eq!(results.len(), 1);
     assert_eq!(results[0].len(), 0);
@@ -758,14 +718,7 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_ram
-        .search(
-            &[&query_vector],
-            None,
-            top,
-            None,
-            &stopped,
-            &Default::default(),
-        )
+        .search(&[&query_vector], None, top, None, &Default::default())
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result
@@ -826,14 +779,7 @@ fn sparse_vector_index_persistence_test() {
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_mmap
-        .search(
-            &[&query_vector],
-            None,
-            top,
-            None,
-            &stopped,
-            &Default::default(),
-        )
+        .search(&[&query_vector], None, top, None, &Default::default())
         .unwrap();
     assert_eq!(search_after_reload_result[0].len(), top);
     for (search_1, search_2) in search_result

commit 8fe5e43764a517b36e1ab013c2dc6505b132a51c
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue May 7 16:14:46 2024 +0000

    Introduce Cargo feature "testing" (#4192)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 73dbcf389..746a0d614 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -17,6 +17,7 @@ use segment::index::hnsw_index::num_rayon_threads;
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
+use segment::json_path::path;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
@@ -34,8 +35,6 @@ use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
-use crate::utils::path;
-
 /// Max dimension of sparse vectors used in tests
 const MAX_SPARSE_DIM: usize = 4096;
 

commit 49e23ce7847a8218de081c3af0b12b4cbcdf8954
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri May 10 08:16:28 2024 +0000

    Misc fixes (#4212)
    
    * SparseVectorIndex: replace pub with feature-gated getters
    
    * Fixup dev-dependencies
    
    * Fixup rust doc comments

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 746a0d614..6076044ce 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -146,14 +146,14 @@ fn sparse_vector_index_fallback_plain_search() {
 
 /// Checks that the sparse vector index is consistent with the underlying storage
 fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {
-    let borrowed_vector_storage = sparse_vector_index.vector_storage.borrow();
+    let borrowed_vector_storage = sparse_vector_index.vector_storage().borrow();
     let point_count = borrowed_vector_storage.available_vector_count();
     for id in 0..point_count as PointOffsetType {
         // assuming no deleted points
         let vector = borrowed_vector_storage.get_vector(id);
         let vector: &SparseVector = vector.as_vec_ref().try_into().unwrap();
         let remapped_vector = sparse_vector_index
-            .indices_tracker
+            .indices_tracker()
             .remap_vector(vector.to_owned());
         // check posting lists are consistent with storage
         for (dim_id, dim_value) in remapped_vector
@@ -161,7 +161,7 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
             .iter()
             .zip(remapped_vector.values.iter())
         {
-            let posting_list = sparse_vector_index.inverted_index.get(dim_id).unwrap();
+            let posting_list = sparse_vector_index.inverted_index().get(dim_id).unwrap();
             // assert posting list sorted by record id
             assert!(posting_list
                 .elements
@@ -207,14 +207,14 @@ fn sparse_vector_index_consistent_with_storage() {
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
-    let mut sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
         SparseVectorIndex::open(
             sparse_index_config,
-            sparse_vector_ram_index.id_tracker.clone(),
-            sparse_vector_ram_index.vector_storage.clone(),
-            sparse_vector_ram_index.payload_index.clone(),
+            sparse_vector_ram_index.id_tracker().clone(),
+            sparse_vector_ram_index.vector_storage().clone(),
+            sparse_vector_ram_index.payload_index().clone(),
             mmap_index_dir.path(),
             &stopped,
         )
@@ -237,13 +237,13 @@ fn sparse_vector_index_consistent_with_storage() {
     drop(sparse_vector_mmap_index);
 
     // load index from memmap file
-    let mut sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
         sparse_index_config,
-        sparse_vector_ram_index.id_tracker.clone(),
-        sparse_vector_ram_index.vector_storage.clone(),
-        sparse_vector_ram_index.payload_index.clone(),
+        sparse_vector_ram_index.id_tracker().clone(),
+        sparse_vector_ram_index.vector_storage().clone(),
+        sparse_vector_ram_index.payload_index().clone(),
         mmap_index_dir.path(),
         &stopped,
     )
@@ -294,14 +294,14 @@ fn sparse_vector_index_ram_deleted_points_search() {
     // sanity check (all indexed, no deleted points)
     assert_eq!(
         sparse_vector_index
-            .id_tracker
+            .id_tracker()
             .borrow()
             .available_point_count(),
         sparse_vector_index.indexed_vector_count()
     );
     assert_eq!(
         sparse_vector_index
-            .id_tracker
+            .id_tracker()
             .borrow()
             .deleted_point_count(),
         0
@@ -318,23 +318,23 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
     // delete a point
     let deleted_external = sparse_vector_index
-        .id_tracker
+        .id_tracker()
         .borrow_mut()
         .external_id(deleted_idx)
         .unwrap();
     sparse_vector_index
-        .id_tracker
+        .id_tracker()
         .borrow_mut()
         .drop(deleted_external)
         .unwrap();
 
     assert!(sparse_vector_index
-        .id_tracker
+        .id_tracker()
         .borrow()
         .is_deleted_point(deleted_idx));
     assert_eq!(
         sparse_vector_index
-            .id_tracker
+            .id_tracker()
             .borrow()
             .deleted_point_count(),
         1
@@ -342,7 +342,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
     // still need to update index
     assert_eq!(
         sparse_vector_index
-            .id_tracker
+            .id_tracker()
             .borrow()
             .available_point_count(),
         sparse_vector_index.indexed_vector_count() - 1
@@ -355,7 +355,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
     sparse_vector_index.build_index(permit, &stopped).unwrap();
     assert_eq!(
         sparse_vector_index
-            .id_tracker
+            .id_tracker()
             .borrow()
             .available_point_count(),
         sparse_vector_index.indexed_vector_count()
@@ -411,14 +411,14 @@ fn sparse_vector_index_ram_filtered_search() {
     assert_eq!(before_result[0].len(), 0);
 
     // create payload field index
-    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     payload_index
         .set_indexed(&path(field_name), Keyword.into())
         .unwrap();
     drop(payload_index);
 
     // assert payload field index created and empty
-    let payload_index = sparse_vector_index.payload_index.borrow();
+    let payload_index = sparse_vector_index.payload_index().borrow();
     let indexed_fields = payload_index.indexed_fields();
     assert_eq!(
         *indexed_fields.get(&path(field_name)).unwrap(),
@@ -436,7 +436,7 @@ fn sparse_vector_index_ram_filtered_search() {
         field_name: field_value,
     })
     .into();
-    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..half_indexed_count {
         payload_index
             .assign(idx as PointOffsetType, &payload, &None)
@@ -445,7 +445,7 @@ fn sparse_vector_index_ram_filtered_search() {
     drop(payload_index);
 
     // assert payload index updated
-    let payload_index = sparse_vector_index.payload_index.borrow();
+    let payload_index = sparse_vector_index.payload_index().borrow();
     let field_indexes = &payload_index.field_indexes;
     let field_index = field_indexes.get(&path(field_name)).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), half_indexed_count);
@@ -512,7 +512,7 @@ fn sparse_vector_index_plain_search() {
     .into();
 
     // add payload to all points
-    let mut payload_index = sparse_vector_index.payload_index.borrow_mut();
+    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..NUM_VECTORS {
         payload_index
             .assign(idx as PointOffsetType, &payload, &None)
@@ -558,7 +558,7 @@ fn handling_empty_sparse_vectors() {
         &stopped,
     )
     .unwrap();
-    let mut borrowed_storage = sparse_vector_index.vector_storage.borrow_mut();
+    let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();
 
     // add empty points to storage
     for idx in 0..NUM_VECTORS {
@@ -572,7 +572,7 @@ fn handling_empty_sparse_vectors() {
     // assert all empty points are in storage
     assert_eq!(
         sparse_vector_index
-            .vector_storage
+            .vector_storage()
             .borrow()
             .available_vector_count(),
         NUM_VECTORS,
@@ -815,14 +815,14 @@ fn sparse_vector_index_files() {
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
-    let mut sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
         SparseVectorIndex::open(
             sparse_index_config,
-            sparse_vector_ram_index.id_tracker.clone(),
-            sparse_vector_ram_index.vector_storage.clone(),
-            sparse_vector_ram_index.payload_index.clone(),
+            sparse_vector_ram_index.id_tracker().clone(),
+            sparse_vector_ram_index.vector_storage().clone(),
+            sparse_vector_ram_index.payload_index().clone(),
             mmap_index_dir.path(),
             &stopped,
         )
@@ -845,14 +845,14 @@ fn sparse_vector_index_files() {
 
     // create mutable RAM sparse vector index
     let mutable_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
-    let mut sparse_index_config = sparse_vector_ram_index.config;
+    let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::MutableRam;
     let mut sparse_vector_mutable_index: SparseVectorIndex<InvertedIndexRam> =
         SparseVectorIndex::open(
             sparse_index_config,
-            sparse_vector_ram_index.id_tracker.clone(),
-            sparse_vector_ram_index.vector_storage.clone(),
-            sparse_vector_ram_index.payload_index.clone(),
+            sparse_vector_ram_index.id_tracker().clone(),
+            sparse_vector_ram_index.vector_storage().clone(),
+            sparse_vector_ram_index.payload_index().clone(),
             mutable_index_dir.path(),
             &stopped,
         )
@@ -908,10 +908,10 @@ fn sparse_vector_test_large_index() {
     match &*borrowed_vector_index {
         VectorIndexEnum::SparseRam(sparse_vector_index) => {
             assert!(sparse_vector_index
-                .indices_tracker
+                .indices_tracker()
                 .remap_index(DimId::MAX)
                 .is_some());
-            assert_eq!(sparse_vector_index.inverted_index.max_index().unwrap(), 0);
+            assert_eq!(sparse_vector_index.inverted_index().max_index().unwrap(), 0);
         }
         _ => panic!("unexpected vector index type"),
     }

commit 1d724579dfd6ed5adeda31429bab5821cab5af30
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu May 16 06:47:47 2024 +0000

    InvertedIndexImmutableRam and index migrations (#4220)
    
    * Move StorageVersion from segment crate to common/io
    
    * Refine StorageVersion API
    
    * Move methods from SparseVectorDataConfig to enum SparseIndexType
    
    * Introduce InvertedIndexImmutableRam
    
    * Add migrate
    
    * Don't migrate

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 6076044ce..ab3381769 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -30,8 +30,8 @@ use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::common::types::DimId;
+use sparse::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
-use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use tempfile::Builder;
 
@@ -550,14 +550,15 @@ fn handling_empty_sparse_vectors() {
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexRam> = fixture_open_sparse_index(
-        data_dir.path(),
-        NUM_VECTORS,
-        DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
-        SparseIndexType::ImmutableRam,
-        &stopped,
-    )
-    .unwrap();
+    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexImmutableRam> =
+        fixture_open_sparse_index(
+            data_dir.path(),
+            NUM_VECTORS,
+            DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+            SparseIndexType::ImmutableRam,
+            &stopped,
+        )
+        .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();
 
     // add empty points to storage
@@ -679,20 +680,21 @@ fn sparse_vector_index_persistence_test() {
         .prefix("inverted_index_ram")
         .tempdir()
         .unwrap();
-    let mut sparse_vector_index_ram: SparseVectorIndex<InvertedIndexRam> = SparseVectorIndex::open(
-        SparseIndexConfig {
-            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-            index_type: SparseIndexType::ImmutableRam,
-        },
-        segment.id_tracker.clone(),
-        segment.vector_data[SPARSE_VECTOR_NAME]
-            .vector_storage
-            .clone(),
-        segment.payload_index.clone(),
-        inverted_index_dir.path(),
-        &stopped,
-    )
-    .unwrap();
+    let mut sparse_vector_index_ram: SparseVectorIndex<InvertedIndexImmutableRam> =
+        SparseVectorIndex::open(
+            SparseIndexConfig {
+                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+                index_type: SparseIndexType::ImmutableRam,
+            },
+            segment.id_tracker.clone(),
+            segment.vector_data[SPARSE_VECTOR_NAME]
+                .vector_storage
+                .clone(),
+            segment.payload_index.clone(),
+            inverted_index_dir.path(),
+            &stopped,
+        )
+        .unwrap();
     // call build index to create inverted index files
     sparse_vector_index_ram
         .build_index(permit, &stopped)
@@ -700,20 +702,21 @@ fn sparse_vector_index_persistence_test() {
 
     // reload sparse index from file
     drop(sparse_vector_index_ram);
-    let sparse_vector_index_ram: SparseVectorIndex<InvertedIndexRam> = SparseVectorIndex::open(
-        SparseIndexConfig {
-            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-            index_type: SparseIndexType::ImmutableRam,
-        },
-        segment.id_tracker.clone(),
-        segment.vector_data[SPARSE_VECTOR_NAME]
-            .vector_storage
-            .clone(),
-        segment.payload_index.clone(),
-        inverted_index_dir.path(),
-        &stopped,
-    )
-    .unwrap();
+    let sparse_vector_index_ram: SparseVectorIndex<InvertedIndexImmutableRam> =
+        SparseVectorIndex::open(
+            SparseIndexConfig {
+                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
+                index_type: SparseIndexType::ImmutableRam,
+            },
+            segment.id_tracker.clone(),
+            segment.vector_data[SPARSE_VECTOR_NAME]
+                .vector_storage
+                .clone(),
+            segment.payload_index.clone(),
+            inverted_index_dir.path(),
+            &stopped,
+        )
+        .unwrap();
 
     // check that the loaded index performs the same search
     let search_after_reload_result = sparse_vector_index_ram
@@ -835,41 +838,13 @@ fn sparse_vector_index_files() {
 
     // files for immutable RAM index
     let ram_files = sparse_vector_ram_index.files();
-    // sparse index config + inverted index config + inverted index data + tracker
-    assert_eq!(ram_files.len(), 4);
+    // sparse index config + version + inverted index config + inverted index data + tracker
+    assert_eq!(ram_files.len(), 5);
 
     // files for mmap index
     let mmap_files = sparse_vector_mmap_index.files();
-    // sparse index config + inverted index config + inverted index data + tracker
-    assert_eq!(mmap_files.len(), 4);
-
-    // create mutable RAM sparse vector index
-    let mutable_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
-    let mut sparse_index_config = sparse_vector_ram_index.config();
-    sparse_index_config.index_type = SparseIndexType::MutableRam;
-    let mut sparse_vector_mutable_index: SparseVectorIndex<InvertedIndexRam> =
-        SparseVectorIndex::open(
-            sparse_index_config,
-            sparse_vector_ram_index.id_tracker().clone(),
-            sparse_vector_ram_index.vector_storage().clone(),
-            sparse_vector_ram_index.payload_index().clone(),
-            mutable_index_dir.path(),
-            &stopped,
-        )
-        .unwrap();
-
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-    sparse_vector_mutable_index
-        .build_index(permit, &stopped)
-        .unwrap();
-    assert_eq!(
-        sparse_vector_mutable_index.indexed_vector_count(),
-        sparse_vector_mmap_index.indexed_vector_count(),
-    );
-
-    // files for mutable index
-    let mutable_index_files = sparse_vector_mutable_index.files();
-    assert_eq!(mutable_index_files.len(), 1); // only the sparse index config file
+    // sparse index config + version + inverted index config + inverted index data + tracker
+    assert_eq!(mmap_files.len(), 5);
 }
 
 #[test]

commit 3b778fec2b771a8c1f349bad5ca7a63983cd5fff
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed May 22 18:18:20 2024 +0000

    Compressed posting lists (#4253)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index ab3381769..d0c93576a 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -5,6 +5,7 @@ use std::sync::Arc;
 
 use common::cpu::CpuPermit;
 use common::types::{PointOffsetType, TelemetryDetail};
+use itertools::Itertools;
 use rand::rngs::StdRng;
 use rand::SeedableRng;
 use segment::common::operation_error::OperationResult;
@@ -33,6 +34,7 @@ use sparse::common::types::DimId;
 use sparse::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
 use sparse::index::inverted_index::InvertedIndex;
+use sparse::index::posting_list_common::PostingListIter as _;
 use tempfile::Builder;
 
 /// Max dimension of sparse vectors used in tests
@@ -164,13 +166,13 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
             let posting_list = sparse_vector_index.inverted_index().get(dim_id).unwrap();
             // assert posting list sorted by record id
             assert!(posting_list
-                .elements
-                .windows(2)
-                .all(|w| w[0].record_id < w[1].record_id));
+                .clone()
+                .into_std_iter()
+                .tuple_windows()
+                .all(|(w0, w1)| w0.record_id < w1.record_id));
             // assert posted list contains record id
             assert!(posting_list
-                .elements
-                .iter()
+                .into_std_iter()
                 .any(|e| e.record_id == id && e.weight == *dim_value));
         }
         // check the vector can be found via search using large top

commit a712d48e44fb92a2f901c43eb0208e74672b4adc
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri May 24 21:42:38 2024 +0200

    allow reading of the non-existent sparse vector same way we allow dense (#4322)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index d0c93576a..a0e38956a 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -147,6 +147,7 @@ fn sparse_vector_index_fallback_plain_search() {
 }
 
 /// Checks that the sparse vector index is consistent with the underlying storage
+#[cfg(test)]
 fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {
     let borrowed_vector_storage = sparse_vector_index.vector_storage().borrow();
     let point_count = borrowed_vector_storage.available_vector_count();

commit e945a6f359fdfe4a0be6df12bf47202d85d511d8
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed May 29 17:04:17 2024 +0000

    Recreate sparse vector index (#4313)
    
    * Recreate sparse vector index
    
    * Rename index file; add simple migration

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index a0e38956a..0c94f0f2b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -1,10 +1,12 @@
 use std::cmp::max;
 use std::collections::HashMap;
+use std::fs::remove_file;
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::cpu::CpuPermit;
 use common::types::{PointOffsetType, TelemetryDetail};
+use io::storage_version::VERSION_FILE;
 use itertools::Itertools;
 use rand::rngs::StdRng;
 use rand::SeedableRng;
@@ -19,11 +21,12 @@ use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, Spars
 use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
 use segment::json_path::path;
+use segment::segment::Segment;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
-    Condition, FieldCondition, Filter, Payload, SegmentConfig, SeqNumberType,
+    Condition, FieldCondition, Filter, Payload, ScoredPoint, SegmentConfig, SeqNumberType,
     SparseVectorDataConfig, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
@@ -677,39 +680,35 @@ fn sparse_vector_index_persistence_test() {
     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
 
-    // persistence using loading RAM index from file
-    // because `segment` is appendable, create sparse index manually
+    check_persistence::<InvertedIndexImmutableRam>(
+        &segment,
+        &permit,
+        &search_result,
+        &query_vector,
+        top,
+    );
+    check_persistence::<InvertedIndexMmap>(&segment, &permit, &search_result, &query_vector, top);
+}
+
+fn check_persistence<TInvertedIndex: InvertedIndex>(
+    segment: &Segment,
+    permit: &Arc<CpuPermit>,
+    search_result: &[ScoredPoint],
+    query_vector: &QueryVector,
+    top: usize,
+) {
+    let stopped = AtomicBool::new(false);
+
     let inverted_index_dir = Builder::new()
         .prefix("inverted_index_ram")
         .tempdir()
         .unwrap();
-    let mut sparse_vector_index_ram: SparseVectorIndex<InvertedIndexImmutableRam> =
-        SparseVectorIndex::open(
-            SparseIndexConfig {
-                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-                index_type: SparseIndexType::ImmutableRam,
-            },
-            segment.id_tracker.clone(),
-            segment.vector_data[SPARSE_VECTOR_NAME]
-                .vector_storage
-                .clone(),
-            segment.payload_index.clone(),
-            inverted_index_dir.path(),
-            &stopped,
-        )
-        .unwrap();
-    // call build index to create inverted index files
-    sparse_vector_index_ram
-        .build_index(permit, &stopped)
-        .unwrap();
 
-    // reload sparse index from file
-    drop(sparse_vector_index_ram);
-    let sparse_vector_index_ram: SparseVectorIndex<InvertedIndexImmutableRam> =
+    let open_index = || -> SparseVectorIndex<TInvertedIndex> {
         SparseVectorIndex::open(
             SparseIndexConfig {
                 full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-                index_type: SparseIndexType::ImmutableRam,
+                index_type: SparseIndexType::Mmap,
             },
             segment.id_tracker.clone(),
             segment.vector_data[SPARSE_VECTOR_NAME]
@@ -719,85 +718,48 @@ fn sparse_vector_index_persistence_test() {
             inverted_index_dir.path(),
             &stopped,
         )
-        .unwrap();
+        .unwrap()
+    };
 
-    // check that the loaded index performs the same search
-    let search_after_reload_result = sparse_vector_index_ram
-        .search(&[&query_vector], None, top, None, &Default::default())
-        .unwrap();
-    assert_eq!(search_after_reload_result[0].len(), top);
-    for (search_1, search_2) in search_result
-        .iter()
-        .zip(search_after_reload_result[0].iter())
-    {
-        let id_1 = segment
-            .id_tracker
-            .borrow_mut()
-            .internal_id(search_1.id)
+    let check_search = |sparse_vector_index: &SparseVectorIndex<TInvertedIndex>| {
+        // check that the loaded index performs the same search
+        let search_after_reload_result = sparse_vector_index
+            .search(&[query_vector], None, top, None, &Default::default())
             .unwrap();
-        assert_eq!(id_1, search_2.idx);
-    }
+        assert_eq!(search_after_reload_result[0].len(), top);
+        for (search_1, search_2) in search_result
+            .iter()
+            .zip(search_after_reload_result[0].iter())
+        {
+            let id_1 = segment
+                .id_tracker
+                .borrow_mut()
+                .internal_id(search_1.id)
+                .unwrap();
+            assert_eq!(id_1, search_2.idx);
+        }
+    };
 
-    // MMAP persistence
-    // because `segment` is appendable, create sparse index manually
-    let inverted_index_dir = Builder::new()
-        .prefix("inverted_index_ram")
-        .tempdir()
-        .unwrap();
-    let mut sparse_vector_index_mmap: SparseVectorIndex<InvertedIndexMmap> =
-        SparseVectorIndex::open(
-            SparseIndexConfig {
-                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-                index_type: SparseIndexType::Mmap,
-            },
-            segment.id_tracker.clone(),
-            segment.vector_data[SPARSE_VECTOR_NAME]
-                .vector_storage
-                .clone(),
-            segment.payload_index.clone(),
-            inverted_index_dir.path(),
-            &stopped,
-        )
-        .unwrap();
+    let mut sparse_vector_index = open_index();
     // call build index to create inverted index files
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-    sparse_vector_index_mmap
-        .build_index(permit, &stopped)
+    sparse_vector_index
+        .build_index(Arc::clone(permit), &stopped)
         .unwrap();
 
-    // reload sparse index from file
-    drop(sparse_vector_index_mmap);
-    let sparse_vector_index_mmap: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
-        SparseIndexConfig {
-            full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-            index_type: SparseIndexType::Mmap,
-        },
-        segment.id_tracker.clone(),
-        segment.vector_data[SPARSE_VECTOR_NAME]
-            .vector_storage
-            .clone(),
-        segment.payload_index.clone(),
-        inverted_index_dir.path(),
-        &stopped,
-    )
-    .unwrap();
+    let version_file = inverted_index_dir.path().join(VERSION_FILE);
+    assert!(version_file.exists());
 
-    // check that the loaded index performs the same search
-    let search_after_reload_result = sparse_vector_index_mmap
-        .search(&[&query_vector], None, top, None, &Default::default())
-        .unwrap();
-    assert_eq!(search_after_reload_result[0].len(), top);
-    for (search_1, search_2) in search_result
-        .iter()
-        .zip(search_after_reload_result[0].iter())
-    {
-        let id_1 = segment
-            .id_tracker
-            .borrow_mut()
-            .internal_id(search_1.id)
-            .unwrap();
-        assert_eq!(id_1, search_2.idx);
-    }
+    // reload sparse index from file
+    drop(sparse_vector_index);
+    let sparse_vector_index = open_index();
+    check_search(&sparse_vector_index);
+
+    // drop version file and reload index
+    drop(sparse_vector_index);
+    remove_file(&version_file).unwrap();
+    let sparse_vector_index = open_index();
+    assert!(version_file.exists(), "version file should be recreated");
+    check_search(&sparse_vector_index);
 }
 
 #[test]

commit d62a455da1daaf0bcc23248bfa06c8803b0d3e8b
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 17 12:41:38 2024 +0000

    Integrate compressed posting list (attempt 2) (#4453)
    
    * Rename InvertedIndex* -> InvertedIndexCompressed*
    
    * Extract method VectorIndexEnum::fill_idf_statistics
    
    * Extend VectorIndexEnum with new variants
    
    * Introduce sparse::InvertedIndex::Version
    
    * Replace SparseVectorIndexVersion -> InvertedIndex::Version
    
    * Introduce sparse_vector_index::OpenArgs
    
    * SparseVectorIndex::open: do not build index if directory is empty
    
    Otherwise it would build the index twice since `SegmentBuilder::build()`
    calls `::open()`, then `::build_index()`. This restores the old (<=v1.9)
    behavior.
    
    * Renames

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 0c94f0f2b..942410701 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -18,7 +18,9 @@ use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
 use segment::index::hnsw_index::num_rayon_threads;
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
-use segment::index::sparse_index::sparse_vector_index::SparseVectorIndex;
+use segment::index::sparse_index::sparse_vector_index::{
+    SparseVectorIndex, SparseVectorIndexOpenArgs,
+};
 use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
 use segment::json_path::path;
 use segment::segment::Segment;
@@ -216,14 +218,14 @@ fn sparse_vector_index_consistent_with_storage() {
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
-        SparseVectorIndex::open(
-            sparse_index_config,
-            sparse_vector_ram_index.id_tracker().clone(),
-            sparse_vector_ram_index.vector_storage().clone(),
-            sparse_vector_ram_index.payload_index().clone(),
-            mmap_index_dir.path(),
-            &stopped,
-        )
+        SparseVectorIndex::open(SparseVectorIndexOpenArgs {
+            config: sparse_index_config,
+            id_tracker: sparse_vector_ram_index.id_tracker().clone(),
+            vector_storage: sparse_vector_ram_index.vector_storage().clone(),
+            payload_index: sparse_vector_ram_index.payload_index().clone(),
+            path: mmap_index_dir.path(),
+            stopped: &stopped,
+        })
         .unwrap();
 
     // build index
@@ -245,15 +247,16 @@ fn sparse_vector_index_consistent_with_storage() {
     // load index from memmap file
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
-    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> = SparseVectorIndex::open(
-        sparse_index_config,
-        sparse_vector_ram_index.id_tracker().clone(),
-        sparse_vector_ram_index.vector_storage().clone(),
-        sparse_vector_ram_index.payload_index().clone(),
-        mmap_index_dir.path(),
-        &stopped,
-    )
-    .unwrap();
+    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+        SparseVectorIndex::open(SparseVectorIndexOpenArgs {
+            config: sparse_index_config,
+            id_tracker: sparse_vector_ram_index.id_tracker().clone(),
+            vector_storage: sparse_vector_ram_index.vector_storage().clone(),
+            payload_index: sparse_vector_ram_index.payload_index().clone(),
+            path: mmap_index_dir.path(),
+            stopped: &stopped,
+        })
+        .unwrap();
 
     assert_eq!(
         sparse_vector_mmap_index.indexed_vector_count(),
@@ -705,19 +708,19 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
         .unwrap();
 
     let open_index = || -> SparseVectorIndex<TInvertedIndex> {
-        SparseVectorIndex::open(
-            SparseIndexConfig {
+        SparseVectorIndex::open(SparseVectorIndexOpenArgs {
+            config: SparseIndexConfig {
                 full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                 index_type: SparseIndexType::Mmap,
             },
-            segment.id_tracker.clone(),
-            segment.vector_data[SPARSE_VECTOR_NAME]
+            id_tracker: segment.id_tracker.clone(),
+            vector_storage: segment.vector_data[SPARSE_VECTOR_NAME]
                 .vector_storage
                 .clone(),
-            segment.payload_index.clone(),
-            inverted_index_dir.path(),
-            &stopped,
-        )
+            payload_index: segment.payload_index.clone(),
+            path: inverted_index_dir.path(),
+            stopped: &stopped,
+        })
         .unwrap()
     };
 
@@ -786,14 +789,14 @@ fn sparse_vector_index_files() {
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
     let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
-        SparseVectorIndex::open(
-            sparse_index_config,
-            sparse_vector_ram_index.id_tracker().clone(),
-            sparse_vector_ram_index.vector_storage().clone(),
-            sparse_vector_ram_index.payload_index().clone(),
-            mmap_index_dir.path(),
-            &stopped,
-        )
+        SparseVectorIndex::open(SparseVectorIndexOpenArgs {
+            config: sparse_index_config,
+            id_tracker: sparse_vector_ram_index.id_tracker().clone(),
+            vector_storage: sparse_vector_ram_index.vector_storage().clone(),
+            payload_index: sparse_vector_ram_index.payload_index().clone(),
+            path: mmap_index_dir.path(),
+            stopped: &stopped,
+        })
         .unwrap();
 
     // build index

commit b389b4e422a2c86d2d8509b940433e32f7a38d02
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jun 18 13:32:06 2024 +0000

    Add datatype option for sparse vector index (#4454)
    
    * Add SparseVectorIndexDatatype
    
    * Update tests
    
    * Review fixes
    
    * review
    
    * gen openAPI
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 942410701..f508820da 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -17,7 +17,9 @@ use segment::entry::entry_point::SegmentEntry;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
 use segment::index::hnsw_index::num_rayon_threads;
-use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
+use segment::index::sparse_index::sparse_index_config::{
+    SparseIndexConfig, SparseIndexType, SparseVectorIndexDatatype,
+};
 use segment::index::sparse_index::sparse_vector_index::{
     SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
@@ -624,6 +626,7 @@ fn sparse_vector_index_persistence_test() {
                 index: SparseIndexConfig {
                     full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                     index_type: SparseIndexType::MutableRam,
+                    datatype: Some(SparseVectorIndexDatatype::Float32),
                 },
             },
         )]),
@@ -712,6 +715,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
             config: SparseIndexConfig {
                 full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                 index_type: SparseIndexType::Mmap,
+                datatype: Some(SparseVectorIndexDatatype::Float32),
             },
             id_tracker: segment.id_tracker.clone(),
             vector_storage: segment.vector_data[SPARSE_VECTOR_NAME]
@@ -826,6 +830,7 @@ fn sparse_vector_test_large_index() {
                 index: SparseIndexConfig {
                     full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                     index_type: SparseIndexType::MutableRam,
+                    datatype: Some(SparseVectorIndexDatatype::Float32),
                 },
             },
         )]),

commit 1a4d8c827a4bc4b93d001c551db552dab17d0840
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 12:44:34 2024 +0000

    Move build_index out of VectorIndex (#4490)
    
    * Move build_index out of VectorIndex
    
    * Build index in HNSWIndex::open()
    
    * Introduce HnswIndexOpenArgs
    
    * Proper deletion
    
    * Improve tests
    
    * HNSW::open(): add warn, comment and assert
    
    * Revert to making up the config if it does not exist

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index f508820da..bea91707b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -2,9 +2,7 @@ use std::cmp::max;
 use std::collections::HashMap;
 use std::fs::remove_file;
 use std::sync::atomic::AtomicBool;
-use std::sync::Arc;
 
-use common::cpu::CpuPermit;
 use common::types::{PointOffsetType, TelemetryDetail};
 use io::storage_version::VERSION_FILE;
 use itertools::Itertools;
@@ -14,9 +12,9 @@ use segment::common::operation_error::OperationResult;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::{QueryVector, Vector};
 use segment::entry::entry_point::SegmentEntry;
+use segment::fixture_for_all_indices;
 use segment::fixtures::payload_fixtures::STR_KEY;
-use segment::fixtures::sparse_fixtures::{fixture_open_sparse_index, fixture_sparse_index_ram};
-use segment::index::hnsw_index::num_rayon_threads;
+use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};
 use segment::index::sparse_index::sparse_index_config::{
     SparseIndexConfig, SparseIndexType, SparseVectorIndexDatatype,
 };
@@ -38,8 +36,11 @@ use serde_json::json;
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::common::types::DimId;
+use sparse::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;
+use sparse::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;
 use sparse::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;
 use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
+use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use sparse::index::posting_list_common::PostingListIter as _;
 use tempfile::Builder;
@@ -61,18 +62,16 @@ const SPARSE_VECTOR_NAME: &str = "sparse_vector";
 
 /// Expects the filter to match ALL points in order to compare the results with/without filter
 fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {
-    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
-    let sparse_vector_index = fixture_sparse_index_ram(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
         full_scan_threshold,
         data_dir.path(),
-        &stopped,
     );
 
     // random query vectors
@@ -199,18 +198,14 @@ fn sparse_vector_index_consistent_with_storage() {
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let sparse_vector_ram_index = fixture_sparse_index_ram(
+    let sparse_vector_ram_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
         LOW_FULL_SCAN_THRESHOLD,
         data_dir.path(),
-        &stopped,
     );
 
-    let permit_cpu_count = num_rayon_threads(0);
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-
     // check consistency with underlying RAM inverted index
     check_index_storage_consistency(&sparse_vector_ram_index);
 
@@ -219,7 +214,7 @@ fn sparse_vector_index_consistent_with_storage() {
     // create mmap sparse vector index
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
-    let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
         SparseVectorIndex::open(SparseVectorIndexOpenArgs {
             config: sparse_index_config,
             id_tracker: sparse_vector_ram_index.id_tracker().clone(),
@@ -227,14 +222,10 @@ fn sparse_vector_index_consistent_with_storage() {
             payload_index: sparse_vector_ram_index.payload_index().clone(),
             path: mmap_index_dir.path(),
             stopped: &stopped,
+            tick_progress: || (),
         })
         .unwrap();
 
-    // build index
-    sparse_vector_mmap_index
-        .build_index(permit, &stopped)
-        .unwrap();
-
     assert_eq!(
         sparse_vector_mmap_index.indexed_vector_count(),
         sparse_vector_ram_index.indexed_vector_count()
@@ -257,6 +248,7 @@ fn sparse_vector_index_consistent_with_storage() {
             payload_index: sparse_vector_ram_index.payload_index().clone(),
             path: mmap_index_dir.path(),
             stopped: &stopped,
+            tick_progress: || (),
         })
         .unwrap();
 
@@ -273,12 +265,11 @@ fn sparse_vector_index_consistent_with_storage() {
 fn sparse_vector_index_load_missing_mmap() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
-        fixture_open_sparse_index(
+        fixture_sparse_index_from_iter(
             data_dir.path(),
-            0,
+            [].iter().cloned(),
             10_000,
             SparseIndexType::Mmap,
-            &AtomicBool::new(false),
         );
     // absent configuration file for mmap are ignored
     // a new index is created
@@ -287,20 +278,18 @@ fn sparse_vector_index_load_missing_mmap() {
 
 #[test]
 fn sparse_vector_index_ram_deleted_points_search() {
-    let stopped = AtomicBool::new(false);
     let top = 10;
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
-    let mut sparse_vector_index = fixture_sparse_index_ram(
-        &mut rnd,
-        NUM_VECTORS,
-        MAX_SPARSE_DIM,
-        LOW_FULL_SCAN_THRESHOLD,
+    let sparse_vector_index = fixture_sparse_index_from_iter::<InvertedIndexRam>(
         data_dir.path(),
-        &stopped,
-    );
+        (0..NUM_VECTORS).map(|_| random_sparse_vector(&mut rnd, MAX_SPARSE_DIM)),
+        LOW_FULL_SCAN_THRESHOLD,
+        SparseIndexType::MutableRam,
+    )
+    .unwrap();
 
     // sanity check (all indexed, no deleted points)
     assert_eq!(
@@ -350,27 +339,6 @@ fn sparse_vector_index_ram_deleted_points_search() {
             .deleted_point_count(),
         1
     );
-    // still need to update index
-    assert_eq!(
-        sparse_vector_index
-            .id_tracker()
-            .borrow()
-            .available_point_count(),
-        sparse_vector_index.indexed_vector_count() - 1
-    );
-
-    let permit_cpu_count = num_rayon_threads(0);
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-
-    // refresh index to remove point
-    sparse_vector_index.build_index(permit, &stopped).unwrap();
-    assert_eq!(
-        sparse_vector_index
-            .id_tracker()
-            .borrow()
-            .available_point_count(),
-        sparse_vector_index.indexed_vector_count()
-    );
 
     // assert that the deleted point is no longer in the index
     let after_deletion_results: Vec<_> = sparse_vector_index
@@ -384,19 +352,17 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
 #[test]
 fn sparse_vector_index_ram_filtered_search() {
-    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
     // setup index
-    let sparse_vector_index = fixture_sparse_index_ram(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
         LOW_FULL_SCAN_THRESHOLD,
         data_dir.path(),
-        &stopped,
     );
 
     // query index by payload
@@ -478,18 +444,16 @@ fn sparse_vector_index_ram_filtered_search() {
 
 #[test]
 fn sparse_vector_index_plain_search() {
-    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     // setup index
-    let sparse_vector_index = fixture_sparse_index_ram(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
         LARGE_FULL_SCAN_THRESHOLD,
         data_dir.path(),
-        &stopped,
     );
 
     // query index by payload
@@ -557,17 +521,15 @@ fn sparse_vector_index_plain_search() {
 
 #[test]
 fn handling_empty_sparse_vectors() {
-    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let mut sparse_vector_index: SparseVectorIndex<InvertedIndexImmutableRam> =
-        fixture_open_sparse_index(
+    let sparse_vector_index: SparseVectorIndex<InvertedIndexImmutableRam> =
+        fixture_sparse_index_from_iter(
             data_dir.path(),
-            NUM_VECTORS,
+            (0..NUM_VECTORS).map(|_| SparseVector::default()),
             DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
             SparseIndexType::ImmutableRam,
-            &stopped,
         )
         .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();
@@ -590,11 +552,7 @@ fn handling_empty_sparse_vectors() {
         NUM_VECTORS,
     );
 
-    let permit_cpu_count = num_rayon_threads(0);
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-
     // empty vectors are not indexed
-    sparse_vector_index.build_index(permit, &stopped).unwrap();
     assert_eq!(sparse_vector_index.indexed_vector_count(), 0);
 
     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();
@@ -634,9 +592,6 @@ fn sparse_vector_index_persistence_test() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
-    let permit_cpu_count = num_rayon_threads(0);
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-
     for n in 0..num_vectors {
         let vector: Vector = random_sparse_vector(&mut rnd, dim).into();
         let mut named_vector = NamedVectors::default();
@@ -686,19 +641,16 @@ fn sparse_vector_index_persistence_test() {
     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
 
-    check_persistence::<InvertedIndexImmutableRam>(
+    fixture_for_all_indices!(check_persistence::<_>(
         &segment,
-        &permit,
         &search_result,
         &query_vector,
-        top,
-    );
-    check_persistence::<InvertedIndexMmap>(&segment, &permit, &search_result, &query_vector, top);
+        top
+    ));
 }
 
 fn check_persistence<TInvertedIndex: InvertedIndex>(
     segment: &Segment,
-    permit: &Arc<CpuPermit>,
     search_result: &[ScoredPoint],
     query_vector: &QueryVector,
     top: usize,
@@ -724,6 +676,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
             payload_index: segment.payload_index.clone(),
             path: inverted_index_dir.path(),
             stopped: &stopped,
+            tick_progress: || (),
         })
         .unwrap()
     };
@@ -747,11 +700,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
         }
     };
 
-    let mut sparse_vector_index = open_index();
-    // call build index to create inverted index files
-    sparse_vector_index
-        .build_index(Arc::clone(permit), &stopped)
-        .unwrap();
+    let sparse_vector_index = open_index();
 
     let version_file = inverted_index_dir.path().join(VERSION_FILE);
     assert!(version_file.exists());
@@ -771,52 +720,25 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
 
 #[test]
 fn sparse_vector_index_files() {
-    let stopped = AtomicBool::new(false);
-    let mut rnd = StdRng::seed_from_u64(42);
+    fixture_for_all_indices!(check_sparse_vector_index_files::<_>());
+}
 
+fn check_sparse_vector_index_files<I: InvertedIndex>() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let sparse_vector_ram_index = fixture_sparse_index_ram(
-        &mut rnd,
+    let index = fixture_sparse_index::<I, _>(
+        &mut StdRng::seed_from_u64(42),
         1,
         MAX_SPARSE_DIM,
         LOW_FULL_SCAN_THRESHOLD,
         data_dir.path(),
-        &stopped,
     );
 
-    let permit_cpu_count = num_rayon_threads(0);
-    let permit = Arc::new(CpuPermit::dummy(permit_cpu_count as u32));
-
-    let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
-
-    // create mmap sparse vector index
-    let mut sparse_index_config = sparse_vector_ram_index.config();
-    sparse_index_config.index_type = SparseIndexType::Mmap;
-    let mut sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
-        SparseVectorIndex::open(SparseVectorIndexOpenArgs {
-            config: sparse_index_config,
-            id_tracker: sparse_vector_ram_index.id_tracker().clone(),
-            vector_storage: sparse_vector_ram_index.vector_storage().clone(),
-            payload_index: sparse_vector_ram_index.payload_index().clone(),
-            path: mmap_index_dir.path(),
-            stopped: &stopped,
-        })
-        .unwrap();
-
-    // build index
-    sparse_vector_mmap_index
-        .build_index(permit, &stopped)
-        .unwrap();
-
-    // files for immutable RAM index
-    let ram_files = sparse_vector_ram_index.files();
+    let files = index.files();
     // sparse index config + version + inverted index config + inverted index data + tracker
-    assert_eq!(ram_files.len(), 5);
-
-    // files for mmap index
-    let mmap_files = sparse_vector_mmap_index.files();
-    // sparse index config + version + inverted index config + inverted index data + tracker
-    assert_eq!(mmap_files.len(), 5);
+    assert_eq!(files.len(), 5);
+    for file in files.iter() {
+        assert!(file.exists(), "file {file:?} does not exist");
+    }
 }
 
 #[test]

commit 7e7a96c80f4b3826fc599cb5f52010d3a2c88650
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 17:27:34 2024 +0000

    Drop SparseVectorIndexDatatype in favor of VectorStorageDatatype (#4541)
    
    * Drop SparseVectorIndexDatatype in favour of VectorStorageDatatype
    
    * Split Datatype doc for VectorParams and SparseIndexParams

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index bea91707b..682c85f2a 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -15,9 +15,7 @@ use segment::entry::entry_point::SegmentEntry;
 use segment::fixture_for_all_indices;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};
-use segment::index::sparse_index::sparse_index_config::{
-    SparseIndexConfig, SparseIndexType, SparseVectorIndexDatatype,
-};
+use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
 use segment::index::sparse_index::sparse_vector_index::{
     SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
@@ -29,7 +27,7 @@ use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
     Condition, FieldCondition, Filter, Payload, ScoredPoint, SegmentConfig, SeqNumberType,
-    SparseVectorDataConfig, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+    SparseVectorDataConfig, VectorStorageDatatype, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
@@ -584,7 +582,7 @@ fn sparse_vector_index_persistence_test() {
                 index: SparseIndexConfig {
                     full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                     index_type: SparseIndexType::MutableRam,
-                    datatype: Some(SparseVectorIndexDatatype::Float32),
+                    datatype: Some(VectorStorageDatatype::Float32),
                 },
             },
         )]),
@@ -667,7 +665,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(
             config: SparseIndexConfig {
                 full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                 index_type: SparseIndexType::Mmap,
-                datatype: Some(SparseVectorIndexDatatype::Float32),
+                datatype: Some(VectorStorageDatatype::Float32),
             },
             id_tracker: segment.id_tracker.clone(),
             vector_storage: segment.vector_data[SPARSE_VECTOR_NAME]
@@ -752,7 +750,7 @@ fn sparse_vector_test_large_index() {
                 index: SparseIndexConfig {
                     full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
                     index_type: SparseIndexType::MutableRam,
-                    datatype: Some(SparseVectorIndexDatatype::Float32),
+                    datatype: Some(VectorStorageDatatype::Float32),
                 },
             },
         )]),

commit 4c1dfe6bf8a837dd8e77de7ee12fb5df164b57e1
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jun 27 14:09:02 2024 +0000

    Set USE_COMPRESSED to true (#4575)
    
    * Set USE_COMPRESSED to true
    
    * Switch to using compressed posting lists in tests

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 682c85f2a..61d016b1d 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -36,8 +36,6 @@ use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sp
 use sparse::common::types::DimId;
 use sparse::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;
 use sparse::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;
-use sparse::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;
-use sparse::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;
 use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
 use sparse::index::inverted_index::InvertedIndex;
 use sparse::index::posting_list_common::PostingListIter as _;
@@ -64,7 +62,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
@@ -196,7 +194,7 @@ fn sparse_vector_index_consistent_with_storage() {
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let sparse_vector_ram_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
+    let sparse_vector_ram_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
@@ -212,7 +210,7 @@ fn sparse_vector_index_consistent_with_storage() {
     // create mmap sparse vector index
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
-    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =
         SparseVectorIndex::open(SparseVectorIndexOpenArgs {
             config: sparse_index_config,
             id_tracker: sparse_vector_ram_index.id_tracker().clone(),
@@ -238,7 +236,7 @@ fn sparse_vector_index_consistent_with_storage() {
     // load index from memmap file
     let mut sparse_index_config = sparse_vector_ram_index.config();
     sparse_index_config.index_type = SparseIndexType::Mmap;
-    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexMmap> =
+    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =
         SparseVectorIndex::open(SparseVectorIndexOpenArgs {
             config: sparse_index_config,
             id_tracker: sparse_vector_ram_index.id_tracker().clone(),
@@ -262,7 +260,7 @@ fn sparse_vector_index_consistent_with_storage() {
 #[test]
 fn sparse_vector_index_load_missing_mmap() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexMmap>> =
+    let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexCompressedMmap<f32>>> =
         fixture_sparse_index_from_iter(
             data_dir.path(),
             [].iter().cloned(),
@@ -355,7 +353,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 
     // setup index
-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
@@ -446,7 +444,7 @@ fn sparse_vector_index_plain_search() {
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     // setup index
-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexImmutableRam, _>(
+    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(
         &mut rnd,
         NUM_VECTORS,
         MAX_SPARSE_DIM,
@@ -522,7 +520,7 @@ fn handling_empty_sparse_vectors() {
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
-    let sparse_vector_index: SparseVectorIndex<InvertedIndexImmutableRam> =
+    let sparse_vector_index: SparseVectorIndex<InvertedIndexCompressedImmutableRam<f32>> =
         fixture_sparse_index_from_iter(
             data_dir.path(),
             (0..NUM_VECTORS).map(|_| SparseVector::default()),

commit 40830a1729f176a8691022e47119ad5dce2d1a54
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Jul 8 15:58:19 2024 +0200

    Merge pull request #4620
    
    * Add `force` flag to `SegmentEntry::flush` and `ShardHolder::flush_all

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 61d016b1d..34a558225 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -597,7 +597,7 @@ fn sparse_vector_index_persistence_test() {
             .upsert_point(n as SeqNumberType, idx, named_vector)
             .unwrap();
     }
-    segment.flush(true).unwrap();
+    segment.flush(true, false).unwrap();
 
     let search_vector = random_sparse_vector(&mut rnd, dim);
     let query_vector: QueryVector = search_vector.into();

commit 4fdf7152f0977adc07bdf9258109ed8600c13f9f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jul 11 04:06:40 2024 +0000

    Drop JsonPathString (#4621)
    
    * drop some code
    
    * Drop JsonPathString
    
    * Fix test_remove_key
    
    Drop failing tests:
    - Deleting array indices is not idempotent, so we don't support it.
    - Empty JSONPath is not supported.
    
    * Make json_path::path() non-generic
    
    * Remove references to JsonPathV2
    
    * Drop JsonPathInterface
    
    * Move json_path::v2 code into json_path
    
    * Drop validate_not_empty
    
    * Drop JsonPath::head() as being unused
    
    * Replace path() with JsonPath::new()
    
    * Restore comments
    
    * Move tests to json_path
    
    * Use json() consistently in tests
    
    * Replace many into calls with Into trait
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 34a558225..a82515f99 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -20,7 +20,7 @@ use segment::index::sparse_index::sparse_vector_index::{
     SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
 use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};
-use segment::json_path::path;
+use segment::json_path::JsonPath;
 use segment::segment::Segment;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
@@ -78,7 +78,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
 
     // filter matches everything
     let filter = Filter::new_must_not(Condition::Field(FieldCondition::new_match(
-        path(STR_KEY),
+        JsonPath::new(STR_KEY),
         STR_KEY.to_owned().into(),
     )));
 
@@ -365,7 +365,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let field_name = "field";
     let field_value = "important value";
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
-        path(field_name),
+        JsonPath::new(field_name),
         field_value.to_owned().into(),
     )));
 
@@ -386,7 +386,7 @@ fn sparse_vector_index_ram_filtered_search() {
     // create payload field index
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     payload_index
-        .set_indexed(&path(field_name), Keyword.into())
+        .set_indexed(&JsonPath::new(field_name), Keyword)
         .unwrap();
     drop(payload_index);
 
@@ -394,12 +394,12 @@ fn sparse_vector_index_ram_filtered_search() {
     let payload_index = sparse_vector_index.payload_index().borrow();
     let indexed_fields = payload_index.indexed_fields();
     assert_eq!(
-        *indexed_fields.get(&path(field_name)).unwrap(),
+        *indexed_fields.get(&JsonPath::new(field_name)).unwrap(),
         FieldType(Keyword)
     );
 
     let field_indexes = &payload_index.field_indexes;
-    let field_index = field_indexes.get(&path(field_name)).unwrap();
+    let field_index = field_indexes.get(&JsonPath::new(field_name)).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), 0);
     drop(payload_index);
 
@@ -420,7 +420,7 @@ fn sparse_vector_index_ram_filtered_search() {
     // assert payload index updated
     let payload_index = sparse_vector_index.payload_index().borrow();
     let field_indexes = &payload_index.field_indexes;
-    let field_index = field_indexes.get(&path(field_name)).unwrap();
+    let field_index = field_indexes.get(&JsonPath::new(field_name)).unwrap();
     assert_eq!(field_index[0].count_indexed_points(), half_indexed_count);
     drop(payload_index);
 
@@ -456,7 +456,7 @@ fn sparse_vector_index_plain_search() {
     let field_name = "field";
     let field_value = "important value";
     let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
-        path(field_name),
+        JsonPath::new(field_name),
         field_value.to_owned().into(),
     )));
 

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index a82515f99..5b0053c3f 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -84,7 +84,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
 
     // compares results with and without filters
     // expects the filter to have no effect on the results because the filter matches everything
-    for query in query_vectors.into_iter() {
+    for query in query_vectors {
         let maximum_number_of_results = sparse_vector_index.max_result_count(&query);
         // get all results minus 10 to force a bit of pruning
         let top = max(1, maximum_number_of_results.saturating_sub(10));
@@ -114,10 +114,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
             assert_eq!(
                 filter_result.len(),
                 no_filter_result.len(),
-                "query = {:#?}, filter_result = {:#?} no_filter_result = {:#?}",
-                query,
-                filter_result,
-                no_filter_result,
+                "query = {query:#?}, filter_result = {filter_result:#?} no_filter_result = {no_filter_result:#?}",
             );
             // skip zero scores because index skips non-overlapping points, but plain search does not
             for (filter_result, no_filter_result) in filter_result

commit 4f59f72c02e6b62f027c88888831c1bf60f24019
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 16 12:42:11 2024 +0200

    Rename payload storage operations for consistency (#5087)

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 5b0053c3f..3e0ddbae9 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -409,7 +409,7 @@ fn sparse_vector_index_ram_filtered_search() {
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..half_indexed_count {
         payload_index
-            .assign(idx as PointOffsetType, &payload, &None)
+            .set_payload(idx as PointOffsetType, &payload, &None)
             .unwrap();
     }
     drop(payload_index);
@@ -483,7 +483,7 @@ fn sparse_vector_index_plain_search() {
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..NUM_VECTORS {
         payload_index
-            .assign(idx as PointOffsetType, &payload, &None)
+            .set_payload(idx as PointOffsetType, &payload, &None)
             .unwrap();
     }
     drop(payload_index);

commit 1d0ee7ea32043598f8b240e6a3a52be20663fa44
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Oct 9 10:15:46 2024 +0200

    Inference interface in REST and gRPC (#5165)
    
    * include document & image objects into grpc API
    
    * introduce image and object to rest api
    
    * minor refactoring
    
    * rename Vector -> VectorInternal
    
    * decompose vector data structures
    
    * add schema
    
    * fmt
    
    * grpc docs
    
    * fix conversion
    
    * fix clippy
    
    * fix another conversion
    
    * rename VectorInput -> VectorInputInternal
    
    * replace grpc TryFrom with async functions
    
    * fmt
    
    * replace rest TryFrom with async functions
    
    * add image and object into query rest
    
    * separate inference related conversions
    
    * move json-related conversions into a separate file
    
    * move vector-related transformations into a separate file
    
    * move more vector related-conversions into dedicated module

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 3e0ddbae9..9bcf83c8a 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -10,7 +10,7 @@ use rand::rngs::StdRng;
 use rand::SeedableRng;
 use segment::common::operation_error::OperationResult;
 use segment::data_types::named_vectors::NamedVectors;
-use segment::data_types::vectors::{QueryVector, Vector};
+use segment::data_types::vectors::{QueryVector, VectorInternal};
 use segment::entry::entry_point::SegmentEntry;
 use segment::fixture_for_all_indices;
 use segment::fixtures::payload_fixtures::STR_KEY;
@@ -586,7 +586,7 @@ fn sparse_vector_index_persistence_test() {
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
     for n in 0..num_vectors {
-        let vector: Vector = random_sparse_vector(&mut rnd, dim).into();
+        let vector: VectorInternal = random_sparse_vector(&mut rnd, dim).into();
         let mut named_vector = NamedVectors::default();
         named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
         let idx = n.into();
@@ -753,7 +753,7 @@ fn sparse_vector_test_large_index() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
-    let vector: Vector = SparseVector {
+    let vector: VectorInternal = SparseVector {
         indices: vec![DimId::MAX],
         values: vec![0.0],
     }

commit c10c145a754b3825a60aaaa143fe91b5b98502b0
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 27 11:45:16 2024 -0600

    Compatibility for mmap sparse vectors (#5454)
    
    * implement mmap sparse vector storage
    
    * add to VectorStorageEnum
    
    * clippy
    
    * add tests, fix both simple and mmap storages
    
    * smol correction on total_vector_count
    
    * add sparse storage type to config
    
    * fix reading config without storage type
    
    * generate openapi
    
    * use blob_store by path
    
    * hidden setting to enable new storage
    
    * validate existing path in `BlobStore::open()`
    
    * use new dir for each sparse vector name
    
    * fix and rename `max_point_offset`
    
    Plus some extra refactors
    
    * add storage compat test, to always check both storages work
    
    * fix opening of storage + other misc fixes
    
    * FIX!!!
    
    `Unset` operations in the Tracker weren't updating the
    `next_pointer_id`. So, when reopening the storage, those points wouldn't
    get marked as deleted in the bitslice, thus creating the illusion that
    they should exist, when they did not.
    
    * refactor naming from `iter_*` to `for_each_*`
    
    * fix checking for BlobStore existance
    
    * fix typo
    
    * fix error message
    
    * better docs for open_or_create
    
    * fix after rebase

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 9bcf83c8a..8361b89a1 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -27,7 +27,8 @@ use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
     Condition, FieldCondition, Filter, Payload, ScoredPoint, SegmentConfig, SeqNumberType,
-    SparseVectorDataConfig, VectorStorageDatatype, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+    SparseVectorDataConfig, SparseVectorStorageType, VectorStorageDatatype,
+    DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
 use serde_json::json;
@@ -579,6 +580,7 @@ fn sparse_vector_index_persistence_test() {
                     index_type: SparseIndexType::MutableRam,
                     datatype: Some(VectorStorageDatatype::Float32),
                 },
+                storage_type: SparseVectorStorageType::default(),
             },
         )]),
         payload_storage_type: Default::default(),
@@ -747,6 +749,7 @@ fn sparse_vector_test_large_index() {
                     index_type: SparseIndexType::MutableRam,
                     datatype: Some(VectorStorageDatatype::Float32),
                 },
+                storage_type: SparseVectorStorageType::OnDisk,
             },
         )]),
         payload_storage_type: Default::default(),

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 8361b89a1..83f600a54 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -3,6 +3,7 @@ use std::collections::HashMap;
 use std::fs::remove_file;
 use std::sync::atomic::AtomicBool;
 
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::{PointOffsetType, TelemetryDetail};
 use io::storage_version::VERSION_FILE;
 use itertools::Itertools;
@@ -587,13 +588,15 @@ fn sparse_vector_index_persistence_test() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
+    let hw_counter = HardwareCounterCell::new();
+
     for n in 0..num_vectors {
         let vector: VectorInternal = random_sparse_vector(&mut rnd, dim).into();
         let mut named_vector = NamedVectors::default();
         named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
         let idx = n.into();
         segment
-            .upsert_point(n as SeqNumberType, idx, named_vector)
+            .upsert_point(n as SeqNumberType, idx, named_vector, &hw_counter)
             .unwrap();
     }
     segment.flush(true, false).unwrap();
@@ -756,6 +759,8 @@ fn sparse_vector_test_large_index() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
+    let hw_counter = HardwareCounterCell::new();
+
     let vector: VectorInternal = SparseVector {
         indices: vec![DimId::MAX],
         values: vec![0.0],
@@ -765,7 +770,7 @@ fn sparse_vector_test_large_index() {
     named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
     let idx = 0.into();
     segment
-        .upsert_point(0 as SeqNumberType, idx, named_vector)
+        .upsert_point(0 as SeqNumberType, idx, named_vector, &hw_counter)
         .unwrap();
 
     let borrowed_vector_index = segment.vector_data[SPARSE_VECTOR_NAME]

commit b0eb8d3431b19ed8beaeb1ceee7872d07d620314
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 10:58:25 2025 +0100

    Io measurement rename functions (#5816)
    
    * replace _measured functions with original name
    
    * Rename more functions

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 83f600a54..e35ec4d6e 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -408,10 +408,11 @@ fn sparse_vector_index_ram_filtered_search() {
         field_name: field_value,
     })
     .into();
+    let hw_counter = HardwareCounterCell::new();
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..half_indexed_count {
         payload_index
-            .set_payload(idx as PointOffsetType, &payload, &None)
+            .set_payload(idx as PointOffsetType, &payload, &None, &hw_counter)
             .unwrap();
     }
     drop(payload_index);
@@ -481,11 +482,13 @@ fn sparse_vector_index_plain_search() {
     })
     .into();
 
+    let hw_counter = HardwareCounterCell::new();
+
     // add payload to all points
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..NUM_VECTORS {
         payload_index
-            .set_payload(idx as PointOffsetType, &payload, &None)
+            .set_payload(idx as PointOffsetType, &payload, &None, &hw_counter)
             .unwrap();
     }
     drop(payload_index);

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index e35ec4d6e..5e0d6ffe4 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -28,7 +28,7 @@ use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
     Condition, FieldCondition, Filter, Payload, ScoredPoint, SegmentConfig, SeqNumberType,
-    SparseVectorDataConfig, SparseVectorStorageType, VectorStorageDatatype,
+    SparseVectorDataConfig, SparseVectorStorageType, VectorName, VectorStorageDatatype,
     DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
@@ -56,7 +56,7 @@ const LOW_FULL_SCAN_THRESHOLD: usize = 1;
 /// Full scan threshold to force plain search
 const LARGE_FULL_SCAN_THRESHOLD: usize = 10 * NUM_VECTORS;
 
-const SPARSE_VECTOR_NAME: &str = "sparse_vector";
+const SPARSE_VECTOR_NAME: &VectorName = "sparse_vector";
 
 /// Expects the filter to match ALL points in order to compare the results with/without filter
 fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {

commit 6e1316bfb5e916378e41a4776a0205b555e950cd
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jan 28 09:35:02 2025 +0000

    Add payload_json! macro (#5881)
    
    * Add payload_json! macro
    
    * Replace usage of `json!({...})` with `payload_json! {...}`
    
    * Drop `impl From<Value> for Payload`

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 5e0d6ffe4..203b2599a 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -13,7 +13,6 @@ use segment::common::operation_error::OperationResult;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::{QueryVector, VectorInternal};
 use segment::entry::entry_point::SegmentEntry;
-use segment::fixture_for_all_indices;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
@@ -27,12 +26,12 @@ use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
-    Condition, FieldCondition, Filter, Payload, ScoredPoint, SegmentConfig, SeqNumberType,
+    Condition, FieldCondition, Filter, ScoredPoint, SegmentConfig, SeqNumberType,
     SparseVectorDataConfig, SparseVectorStorageType, VectorName, VectorStorageDatatype,
     DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
 };
 use segment::vector_storage::VectorStorage;
-use serde_json::json;
+use segment::{fixture_for_all_indices, payload_json};
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::common::types::DimId;
@@ -404,10 +403,7 @@ fn sparse_vector_index_ram_filtered_search() {
 
     // add payload on the first half of the points
     let half_indexed_count = sparse_vector_index.indexed_vector_count() / 2;
-    let payload: Payload = json!({
-        field_name: field_value,
-    })
-    .into();
+    let payload = payload_json! {field_name: field_value};
     let hw_counter = HardwareCounterCell::new();
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..half_indexed_count {
@@ -477,10 +473,7 @@ fn sparse_vector_index_plain_search() {
     assert_eq!(before_plain_results.len(), 1);
     assert_eq!(before_plain_results[0].len(), 0);
 
-    let payload: Payload = json!({
-        field_name: field_value,
-    })
-    .into();
+    let payload = payload_json! {field_name: field_value};
 
     let hw_counter = HardwareCounterCell::new();
 

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 203b2599a..3feb5b151 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -59,7 +59,7 @@ const SPARSE_VECTOR_NAME: &VectorName = "sparse_vector";
 
 /// Expects the filter to match ALL points in order to compare the results with/without filter
 fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {
-    let mut rnd = StdRng::seed_from_u64(42);
+    let mut rnd = StdRng::seed_from_u64(43);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
 

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 3feb5b151..e9a821f47 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -7,8 +7,8 @@ use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::{PointOffsetType, TelemetryDetail};
 use io::storage_version::VERSION_FILE;
 use itertools::Itertools;
-use rand::rngs::StdRng;
 use rand::SeedableRng;
+use rand::rngs::StdRng;
 use segment::common::operation_error::OperationResult;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::{QueryVector, VectorInternal};
@@ -26,19 +26,19 @@ use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::PayloadFieldSchema::FieldType;
 use segment::types::PayloadSchemaType::Keyword;
 use segment::types::{
-    Condition, FieldCondition, Filter, ScoredPoint, SegmentConfig, SeqNumberType,
-    SparseVectorDataConfig, SparseVectorStorageType, VectorName, VectorStorageDatatype,
-    DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
+    Condition, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD, FieldCondition, Filter, ScoredPoint,
+    SegmentConfig, SeqNumberType, SparseVectorDataConfig, SparseVectorStorageType, VectorName,
+    VectorStorageDatatype,
 };
 use segment::vector_storage::VectorStorage;
 use segment::{fixture_for_all_indices, payload_json};
 use sparse::common::sparse_vector::SparseVector;
 use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};
 use sparse::common::types::DimId;
+use sparse::index::inverted_index::InvertedIndex;
 use sparse::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;
 use sparse::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;
 use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;
-use sparse::index::inverted_index::InvertedIndex;
 use sparse::index::posting_list_common::PostingListIter as _;
 use tempfile::Builder;
 
@@ -166,15 +166,19 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
         {
             let posting_list = sparse_vector_index.inverted_index().get(dim_id).unwrap();
             // assert posting list sorted by record id
-            assert!(posting_list
-                .clone()
-                .into_std_iter()
-                .tuple_windows()
-                .all(|(w0, w1)| w0.record_id < w1.record_id));
+            assert!(
+                posting_list
+                    .clone()
+                    .into_std_iter()
+                    .tuple_windows()
+                    .all(|(w0, w1)| w0.record_id < w1.record_id),
+            );
             // assert posted list contains record id
-            assert!(posting_list
-                .into_std_iter()
-                .any(|e| e.record_id == id && e.weight == *dim_value));
+            assert!(
+                posting_list
+                    .into_std_iter()
+                    .any(|e| e.record_id == id && e.weight == *dim_value),
+            );
         }
         // check the vector can be found via search using large top
         let top = sparse_vector_index.max_result_count(vector);
@@ -322,10 +326,12 @@ fn sparse_vector_index_ram_deleted_points_search() {
         .drop(deleted_external)
         .unwrap();
 
-    assert!(sparse_vector_index
-        .id_tracker()
-        .borrow()
-        .is_deleted_point(deleted_idx));
+    assert!(
+        sparse_vector_index
+            .id_tracker()
+            .borrow()
+            .is_deleted_point(deleted_idx),
+    );
     assert_eq!(
         sparse_vector_index
             .id_tracker()
@@ -339,9 +345,11 @@ fn sparse_vector_index_ram_deleted_points_search() {
         .search(&[&query_vector], None, top, None, &Default::default())
         .unwrap();
     assert_ne!(before_deletion_results, after_deletion_results);
-    assert!(after_deletion_results
-        .iter()
-        .all(|x| x.iter().all(|y| y.idx != deleted_idx)));
+    assert!(
+        after_deletion_results
+            .iter()
+            .all(|x| x.iter().all(|y| y.idx != deleted_idx)),
+    );
 }
 
 #[test]
@@ -774,10 +782,12 @@ fn sparse_vector_test_large_index() {
         .borrow();
     match &*borrowed_vector_index {
         VectorIndexEnum::SparseRam(sparse_vector_index) => {
-            assert!(sparse_vector_index
-                .indices_tracker()
-                .remap_index(DimId::MAX)
-                .is_some());
+            assert!(
+                sparse_vector_index
+                    .indices_tracker()
+                    .remap_index(DimId::MAX)
+                    .is_some(),
+            );
             assert_eq!(sparse_vector_index.inverted_index().max_index().unwrap(), 0);
         }
         _ => panic!("unexpected vector index type"),

commit a2d7947917ca8d58c85360d1f07a387289b67a1b
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 10 15:27:06 2025 +0100

    Measure io writes for vector upsertions (#5944)
    
    * Add counter to vector storage API
    
    * Measuring IO write for dense vectors
    
    * Tests, GPU and sparse
    
    * Measure multi vectors too
    
    * Fix comment

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index e9a821f47..39475c9c1 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -533,11 +533,12 @@ fn handling_empty_sparse_vectors() {
         .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();
 
+    let hw_counter = HardwareCounterCell::new();
     // add empty points to storage
     for idx in 0..NUM_VECTORS {
         let vec = &SparseVector::new(vec![], vec![]).unwrap();
         borrowed_storage
-            .insert_vector(idx as PointOffsetType, vec.into())
+            .insert_vector(idx as PointOffsetType, vec.into(), &hw_counter)
             .unwrap();
     }
     drop(borrowed_storage);

commit ad4743a85ff316d191fa55a445c7506892e7f6d1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 24 13:15:04 2025 +0100

    vector-io-read measurement on query (#6197)
    
    * remove mut getters from HardwareCounterCell, as mutability is not useful
    
    * introduce vector-io multiplier
    
    * remove RealCpuMeasurement structure
    
    * set vector-io reads multipliers
    
    * account vector reads in dense scorers
    
    * fmt
    
    * fix tests
    
    * propagate hw_counter into posting list iterator
    
    * fmt
    
    * fix test
    
    * wip: measure of sparse iterator
    
    * fmt
    
    * optimize skip_to
    
    * minor refactoring
    
    * keep current PointOffset in iterator to prevent unnecessary reads from memory
    
    * adjust sparse search cpu cost - account for datatype
    
    * fix test
    
    * refactor search_context tests
    
    * move tests into a module
    
    * introduce more tests
    
    * grammar
    
    * review fixes
    
    * fix clippy
    
    * fix clippy again
    
    * change disposable -> new

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index 39475c9c1..f416e9ac3 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -151,6 +151,7 @@ fn sparse_vector_index_fallback_plain_search() {
 fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {
     let borrowed_vector_storage = sparse_vector_index.vector_storage().borrow();
     let point_count = borrowed_vector_storage.available_vector_count();
+    let hw_counter = HardwareCounterCell::disposable();
     for id in 0..point_count as PointOffsetType {
         // assuming no deleted points
         let vector = borrowed_vector_storage.get_vector(id);
@@ -164,7 +165,10 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars
             .iter()
             .zip(remapped_vector.values.iter())
         {
-            let posting_list = sparse_vector_index.inverted_index().get(dim_id).unwrap();
+            let posting_list = sparse_vector_index
+                .inverted_index()
+                .get(*dim_id, &hw_counter)
+                .unwrap();
             // assert posting list sorted by record id
             assert!(
                 posting_list

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
index f416e9ac3..23042ce7b 100644
--- a/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
+++ b/lib/segment/tests/integration/sparse_vector_index_search_tests.rs
@@ -393,10 +393,12 @@ fn sparse_vector_index_ram_filtered_search() {
     assert_eq!(before_result.len(), 1);
     assert_eq!(before_result[0].len(), 0);
 
+    let hw_counter = HardwareCounterCell::new();
+
     // create payload field index
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     payload_index
-        .set_indexed(&JsonPath::new(field_name), Keyword)
+        .set_indexed(&JsonPath::new(field_name), Keyword, &hw_counter)
         .unwrap();
     drop(payload_index);
 

