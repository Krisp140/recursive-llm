# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/validate/src/lib/validation.ts

commit 7307282f1f38a056b1313b3e0d2f196b28bd5586
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Jun 3 09:27:44 2023 +0100

    Rename tlvalidate to validate (#1508)
    
    This PR renames the @tldraw/tlvalidate package to @tldraw/validate.
    
    ### Change Type
    
    - [x] `major` â€” Breaking Change
    
    ### Release Notes
    
    - Rename tlvalidate to validate

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
new file mode 100644
index 000000000..048d3f8d5
--- /dev/null
+++ b/packages/validate/src/lib/validation.ts
@@ -0,0 +1,556 @@
+import { exhaustiveSwitchError, getOwnProperty, hasOwnProperty } from '@tldraw/utils'
+
+/** @public */
+export type ValidatorFn<T> = (value: unknown) => T
+
+function formatPath(path: ReadonlyArray<number | string>): string | null {
+	if (!path.length) {
+		return null
+	}
+	let formattedPath = ''
+	for (const item of path) {
+		if (typeof item === 'number') {
+			formattedPath += `.${item}`
+		} else if (item.startsWith('(')) {
+			if (formattedPath.endsWith(')')) {
+				formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`
+			} else {
+				formattedPath += item
+			}
+		} else {
+			formattedPath += `.${item}`
+		}
+	}
+	if (formattedPath.startsWith('.')) {
+		return formattedPath.slice(1)
+	}
+	return formattedPath
+}
+
+/** @public */
+export class ValidationError extends Error {
+	override name = 'ValidationError'
+
+	constructor(
+		public readonly rawMessage: string,
+		public readonly path: ReadonlyArray<number | string> = []
+	) {
+		const formattedPath = formatPath(path)
+		const indentedMessage = rawMessage
+			.split('\n')
+			.map((line, i) => (i === 0 ? line : `  ${line}`))
+			.join('\n')
+		super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage)
+	}
+}
+
+function prefixError<T>(path: string | number, fn: () => T): T {
+	try {
+		return fn()
+	} catch (err) {
+		if (err instanceof ValidationError) {
+			throw new ValidationError(err.rawMessage, [path, ...err.path])
+		}
+		throw new ValidationError((err as Error).toString(), [path])
+	}
+}
+
+function typeToString(value: unknown): string {
+	if (value === null) return 'null'
+	if (Array.isArray(value)) return 'an array'
+	const type = typeof value
+	switch (type) {
+		case 'bigint':
+		case 'boolean':
+		case 'function':
+		case 'number':
+		case 'string':
+		case 'symbol':
+			return `a ${type}`
+		case 'object':
+			return `an ${type}`
+		case 'undefined':
+			return 'undefined'
+		default:
+			exhaustiveSwitchError(type)
+	}
+}
+
+/** @public */
+export type TypeOf<V extends Validator<unknown>> = V extends Validator<infer T> ? T : never
+
+/** @public */
+export class Validator<T> {
+	constructor(readonly validationFn: ValidatorFn<T>) {}
+
+	/**
+	 * Asserts that the passed value is of the correct type and returns it. The returned value is
+	 * guaranteed to be referentially equal to the passed value.
+	 */
+	validate(value: unknown): T {
+		const validated = this.validationFn(value)
+		if (process.env.NODE_ENV !== 'production' && !Object.is(value, validated)) {
+			throw new ValidationError('Validator functions must return the same value they were passed')
+		}
+		return validated
+	}
+
+	/**
+	 * Returns a new validator that also accepts null or undefined. The resulting value will always be
+	 * null.
+	 */
+	nullable(): Validator<T | null> {
+		return new Validator((value) => {
+			if (value === null) return null
+			return this.validate(value)
+		})
+	}
+
+	/**
+	 * Returns a new validator that also accepts null or undefined. The resulting value will always be
+	 * null.
+	 */
+	optional(): Validator<T | undefined> {
+		return new Validator((value) => {
+			if (value === undefined) return undefined
+			return this.validate(value)
+		})
+	}
+
+	/**
+	 * Refine this validation to a new type. The passed-in validation function should throw an error
+	 * if the value can't be converted to the new type, or return the new type otherwise.
+	 */
+	refine<U>(otherValidationFn: (value: T) => U): Validator<U> {
+		return new Validator((value) => {
+			return otherValidationFn(this.validate(value))
+		})
+	}
+
+	/**
+	 * Refine this validation with an additional check that doesn't change the resulting value.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * const numberLessThan10Validator = T.number.check((value) => {
+	 * 	if (value >= 10) {
+	 * 		throw new ValidationError(`Expected number less than 10, got ${value}`)
+	 * 	}
+	 * })
+	 * ```
+	 */
+	check(name: string, checkFn: (value: T) => void): Validator<T>
+	check(checkFn: (value: T) => void): Validator<T>
+	check(nameOrCheckFn: string | ((value: T) => void), checkFn?: (value: T) => void): Validator<T> {
+		if (typeof nameOrCheckFn === 'string') {
+			return this.refine((value) => {
+				prefixError(`(check ${nameOrCheckFn})`, () => checkFn!(value))
+				return value
+			})
+		} else {
+			return this.refine((value) => {
+				nameOrCheckFn(value)
+				return value
+			})
+		}
+	}
+}
+
+/** @public */
+export class ArrayOfValidator<T> extends Validator<T[]> {
+	constructor(readonly itemValidator: Validator<T>) {
+		super((value) => {
+			const arr = array.validate(value)
+			for (let i = 0; i < arr.length; i++) {
+				prefixError(i, () => itemValidator.validate(arr[i]))
+			}
+			return arr as T[]
+		})
+	}
+
+	nonEmpty() {
+		return this.check((value) => {
+			if (value.length === 0) {
+				throw new ValidationError('Expected a non-empty array')
+			}
+		})
+	}
+
+	lengthGreaterThan1() {
+		return this.check((value) => {
+			if (value.length <= 1) {
+				throw new ValidationError('Expected an array with length greater than 1')
+			}
+		})
+	}
+}
+
+/** @public */
+export class ObjectValidator<Shape extends object> extends Validator<Shape> {
+	constructor(
+		public readonly config: {
+			readonly [K in keyof Shape]: Validator<Shape[K]>
+		},
+		private readonly shouldAllowUnknownProperties = false
+	) {
+		super((object) => {
+			if (typeof object !== 'object' || object === null) {
+				throw new ValidationError(`Expected object, got ${typeToString(object)}`)
+			}
+
+			for (const [key, validator] of Object.entries(config)) {
+				prefixError(key, () => {
+					;(validator as Validator<unknown>).validate(getOwnProperty(object, key))
+				})
+			}
+
+			if (!shouldAllowUnknownProperties) {
+				for (const key of Object.keys(object)) {
+					if (!hasOwnProperty(config, key)) {
+						throw new ValidationError(`Unexpected property`, [key])
+					}
+				}
+			}
+
+			return object as Shape
+		})
+	}
+
+	allowUnknownProperties() {
+		return new ObjectValidator(this.config, true)
+	}
+
+	/**
+	 * Extend an object validator by adding additional properties.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * const animalValidator = T.object({
+	 * 	name: T.string,
+	 * })
+	 * const catValidator = animalValidator.extend({
+	 * 	meowVolume: T.number,
+	 * })
+	 * ```
+	 */
+	extend<Extension extends Record<string, unknown>>(extension: {
+		readonly [K in keyof Extension]: Validator<Extension[K]>
+	}): ObjectValidator<Shape & Extension> {
+		return new ObjectValidator({ ...this.config, ...extension }) as ObjectValidator<
+			Shape & Extension
+		>
+	}
+}
+
+// pass this into itself e.g. Config extends UnionObjectSchemaConfig<Key, Config>
+type UnionValidatorConfig<Key extends string, Config> = {
+	readonly [Variant in keyof Config]: Validator<any> & {
+		validate: (input: any) => { readonly [K in Key]: Variant }
+	}
+}
+/** @public */
+export class UnionValidator<
+	Key extends string,
+	Config extends UnionValidatorConfig<Key, Config>,
+	UnknownValue = never
+> extends Validator<TypeOf<Config[keyof Config]> | UnknownValue> {
+	constructor(
+		private readonly key: Key,
+		private readonly config: Config,
+		private readonly unknownValueValidation: (value: object, variant: string) => UnknownValue
+	) {
+		super((input) => {
+			if (typeof input !== 'object' || input === null) {
+				throw new ValidationError(`Expected an object, got ${typeToString(input)}`, [])
+			}
+
+			const variant = getOwnProperty(input, key) as keyof Config | undefined
+			if (typeof variant !== 'string') {
+				throw new ValidationError(
+					`Expected a string for key "${key}", got ${typeToString(variant)}`
+				)
+			}
+
+			const matchingSchema = hasOwnProperty(config, variant) ? config[variant] : undefined
+			if (matchingSchema === undefined) {
+				return this.unknownValueValidation(input, variant)
+			}
+
+			return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))
+		})
+	}
+
+	validateUnknownVariants<Unknown>(
+		unknownValueValidation: (value: object, variant: string) => Unknown
+	): UnionValidator<Key, Config, Unknown> {
+		return new UnionValidator(this.key, this.config, unknownValueValidation)
+	}
+}
+
+/** @public */
+export class DictValidator<Key extends string, Value> extends Validator<Record<Key, Value>> {
+	constructor(
+		public readonly keyValidator: Validator<Key>,
+		public readonly valueValidator: Validator<Value>
+	) {
+		super((object) => {
+			if (typeof object !== 'object' || object === null) {
+				throw new ValidationError(`Expected object, got ${typeToString(object)}`)
+			}
+
+			for (const [key, value] of Object.entries(object)) {
+				prefixError(key, () => {
+					keyValidator.validate(key)
+					valueValidator.validate(value)
+				})
+			}
+
+			return object as Record<Key, Value>
+		})
+	}
+}
+
+function typeofValidator<T>(type: string): Validator<T> {
+	return new Validator((value) => {
+		if (typeof value !== type) {
+			throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`)
+		}
+		return value as T
+	})
+}
+
+/**
+ * Validation that accepts any value. Useful as a starting point for building your own custom
+ * validations.
+ *
+ * @public
+ */
+export const unknown = new Validator((value) => value)
+/**
+ * Validation that accepts any value. Generally this should be avoided, but you can use it as an
+ * escape hatch if you want to work without validations for e.g. a prototype.
+ *
+ * @public
+ */
+export const any = new Validator((value): any => value)
+
+/**
+ * Validates that a value is a string.
+ *
+ * @public
+ */
+export const string = typeofValidator<string>('string')
+
+/**
+ * Validates that a value is a finite non-NaN number.
+ *
+ * @public
+ */
+export const number = typeofValidator<number>('number').check((number) => {
+	if (Number.isNaN(number)) {
+		throw new ValidationError('Expected a number, got NaN')
+	}
+	if (!Number.isFinite(number)) {
+		throw new ValidationError(`Expected a finite number, got ${number}`)
+	}
+})
+/**
+ * Fails if value \< 0
+ *
+ * @public
+ */
+export const positiveNumber = number.check((value) => {
+	if (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`)
+})
+/**
+ * Fails if value \<= 0
+ *
+ * @public
+ */
+export const nonZeroNumber = number.check((value) => {
+	if (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`)
+})
+/**
+ * Fails if number is not an integer
+ *
+ * @public
+ */
+export const integer = number.check((value) => {
+	if (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`)
+})
+/**
+ * Fails if value \< 0 and is not an integer
+ *
+ * @public
+ */
+export const positiveInteger = integer.check((value) => {
+	if (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`)
+})
+/**
+ * Fails if value \<= 0 and is not an integer
+ *
+ * @public
+ */
+export const nonZeroInteger = integer.check((value) => {
+	if (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`)
+})
+
+/**
+ * Validates that a value is boolean.
+ *
+ * @public
+ */
+export const boolean = typeofValidator<boolean>('boolean')
+/**
+ * Validates that a value is a bigint.
+ *
+ * @public
+ */
+export const bigint = typeofValidator<bigint>('bigint')
+/**
+ * Validates that a value matches another that was passed in.
+ *
+ * @example
+ *
+ * ```ts
+ * const trueValidator = T.literal(true)
+ * ```
+ *
+ * @public
+ */
+export function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {
+	return new Validator((actualValue) => {
+		if (actualValue !== expectedValue) {
+			throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)
+		}
+		return expectedValue
+	})
+}
+
+/**
+ * Validates that a value is an array. To check the contents of the array, use T.arrayOf.
+ *
+ * @public
+ */
+export const array = new Validator<unknown[]>((value) => {
+	if (!Array.isArray(value)) {
+		throw new ValidationError(`Expected an array, got ${typeToString(value)}`)
+	}
+	return value
+})
+
+/**
+ * Validates that a value is an array whose contents matches the passed-in validator.
+ *
+ * @public
+ */
+export function arrayOf<T>(itemValidator: Validator<T>): ArrayOfValidator<T> {
+	return new ArrayOfValidator(itemValidator)
+}
+
+/** @public */
+export const unknownObject = new Validator<Record<string, unknown>>((value) => {
+	if (typeof value !== 'object' || value === null) {
+		throw new ValidationError(`Expected object, got ${typeToString(value)}`)
+	}
+	return value as Record<string, unknown>
+})
+
+/**
+ * Validate an object has a particular shape.
+ *
+ * @public
+ */
+export function object<Shape extends object>(config: {
+	readonly [K in keyof Shape]: Validator<Shape[K]>
+}): ObjectValidator<Shape> {
+	return new ObjectValidator(config)
+}
+
+/**
+ * Validation that an option is a dict with particular keys and values.
+ *
+ * @public
+ */
+export function dict<Key extends string, Value>(
+	keyValidator: Validator<Key>,
+	valueValidator: Validator<Value>
+): DictValidator<Key, Value> {
+	return new DictValidator(keyValidator, valueValidator)
+}
+
+/**
+ * Validate a union of several object types. Each object must have a property matching `key` which
+ * should be a unique string.
+ *
+ * @example
+ *
+ * ```ts
+ * const catValidator = T.object({ kind: T.value('cat'), meow: T.boolean })
+ * const dogValidator = T.object({ kind: T.value('dog'), bark: T.boolean })
+ * const animalValidator = T.union('kind', { cat: catValidator, dog: dogValidator })
+ * ```
+ *
+ * @public
+ */
+export function union<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(
+	key: Key,
+	config: Config
+): UnionValidator<Key, Config> {
+	return new UnionValidator(key, config, (unknownValue, unknownVariant) => {
+		throw new ValidationError(
+			`Expected one of ${Object.keys(config)
+				.map((key) => JSON.stringify(key))
+				.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
+			[key]
+		)
+	})
+}
+
+/**
+ * A named object with an ID. Errors will be reported as being part of the object with the given
+ * name.
+ *
+ * @public
+ */
+export function model<T extends { readonly id: string }>(
+	name: string,
+	validator: Validator<T>
+): Validator<T> {
+	return new Validator((value) => {
+		const prefix =
+			value && typeof value === 'object' && 'id' in value && typeof value.id === 'string'
+				? `${name}(id = ${value.id})`
+				: name
+
+		return prefixError(prefix, () => validator.validate(value))
+	})
+}
+
+/** @public */
+export function setEnum<T>(values: ReadonlySet<T>): Validator<T> {
+	return new Validator((value) => {
+		if (!values.has(value as T)) {
+			const valuesString = Array.from(values, (value) => JSON.stringify(value)).join(' or ')
+			throw new ValidationError(`Expected ${valuesString}, got ${value}`)
+		}
+		return value as T
+	})
+}
+
+/** @public */
+export const point = object({
+	x: number,
+	y: number,
+	z: number.optional(),
+})
+
+/** @public */
+export const boxModel = object({
+	x: number,
+	y: number,
+	w: number,
+	h: number,
+})

commit 1927f8804158ed4bc1df42eb8a08bdc6b305c379
Author: alex <alex@dytry.ch>
Date:   Mon Jun 12 15:04:14 2023 +0100

    mini `defineShape` API (#1563)
    
    Based on #1549, but with a lot of code-structure related changes backed
    out. Shape schemas are still defined in tlschemas with this diff.
    
    Couple differences between this and #1549:
    - This tightens up the relationship between store schemas and editor
    schemas a bit
    - Reduces the number of places we need to remember to include core
    shapes
    - Only `<TLdrawEditor />` sets default shapes by default. If you're
    doing something funky with lower-level APIs, you need to specify
    `defaultShapes` manually
    - Replaces `validator` with `props` for shapes
    
    ### Change Type
    
    - [x] `major` â€” Breaking Change
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [x] Unit Tests
    - [ ] Webdriver tests
    
    ### Release Notes
    
    [dev-facing, notes to come]

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 048d3f8d5..1b4914064 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -3,6 +3,9 @@ import { exhaustiveSwitchError, getOwnProperty, hasOwnProperty } from '@tldraw/u
 /** @public */
 export type ValidatorFn<T> = (value: unknown) => T
 
+/** @public */
+export type Validatable<T> = { validate: (value: unknown) => T }
+
 function formatPath(path: ReadonlyArray<number | string>): string | null {
 	if (!path.length) {
 		return null
@@ -77,10 +80,10 @@ function typeToString(value: unknown): string {
 }
 
 /** @public */
-export type TypeOf<V extends Validator<unknown>> = V extends Validator<infer T> ? T : never
+export type TypeOf<V extends Validatable<unknown>> = V extends Validatable<infer T> ? T : never
 
 /** @public */
-export class Validator<T> {
+export class Validator<T> implements Validatable<T> {
 	constructor(readonly validationFn: ValidatorFn<T>) {}
 
 	/**
@@ -159,7 +162,7 @@ export class Validator<T> {
 
 /** @public */
 export class ArrayOfValidator<T> extends Validator<T[]> {
-	constructor(readonly itemValidator: Validator<T>) {
+	constructor(readonly itemValidator: Validatable<T>) {
 		super((value) => {
 			const arr = array.validate(value)
 			for (let i = 0; i < arr.length; i++) {
@@ -190,7 +193,7 @@ export class ArrayOfValidator<T> extends Validator<T[]> {
 export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 	constructor(
 		public readonly config: {
-			readonly [K in keyof Shape]: Validator<Shape[K]>
+			readonly [K in keyof Shape]: Validatable<Shape[K]>
 		},
 		private readonly shouldAllowUnknownProperties = false
 	) {
@@ -236,7 +239,7 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 	 * ```
 	 */
 	extend<Extension extends Record<string, unknown>>(extension: {
-		readonly [K in keyof Extension]: Validator<Extension[K]>
+		readonly [K in keyof Extension]: Validatable<Extension[K]>
 	}): ObjectValidator<Shape & Extension> {
 		return new ObjectValidator({ ...this.config, ...extension }) as ObjectValidator<
 			Shape & Extension
@@ -246,7 +249,7 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 
 // pass this into itself e.g. Config extends UnionObjectSchemaConfig<Key, Config>
 type UnionValidatorConfig<Key extends string, Config> = {
-	readonly [Variant in keyof Config]: Validator<any> & {
+	readonly [Variant in keyof Config]: Validatable<any> & {
 		validate: (input: any) => { readonly [K in Key]: Variant }
 	}
 }
@@ -292,8 +295,8 @@ export class UnionValidator<
 /** @public */
 export class DictValidator<Key extends string, Value> extends Validator<Record<Key, Value>> {
 	constructor(
-		public readonly keyValidator: Validator<Key>,
-		public readonly valueValidator: Validator<Value>
+		public readonly keyValidator: Validatable<Key>,
+		public readonly valueValidator: Validatable<Value>
 	) {
 		super((object) => {
 			if (typeof object !== 'object' || object === null) {
@@ -446,7 +449,7 @@ export const array = new Validator<unknown[]>((value) => {
  *
  * @public
  */
-export function arrayOf<T>(itemValidator: Validator<T>): ArrayOfValidator<T> {
+export function arrayOf<T>(itemValidator: Validatable<T>): ArrayOfValidator<T> {
 	return new ArrayOfValidator(itemValidator)
 }
 
@@ -464,7 +467,7 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
  * @public
  */
 export function object<Shape extends object>(config: {
-	readonly [K in keyof Shape]: Validator<Shape[K]>
+	readonly [K in keyof Shape]: Validatable<Shape[K]>
 }): ObjectValidator<Shape> {
 	return new ObjectValidator(config)
 }
@@ -475,8 +478,8 @@ export function object<Shape extends object>(config: {
  * @public
  */
 export function dict<Key extends string, Value>(
-	keyValidator: Validator<Key>,
-	valueValidator: Validator<Value>
+	keyValidator: Validatable<Key>,
+	valueValidator: Validatable<Value>
 ): DictValidator<Key, Value> {
 	return new DictValidator(keyValidator, valueValidator)
 }
@@ -517,7 +520,7 @@ export function union<Key extends string, Config extends UnionValidatorConfig<Ke
  */
 export function model<T extends { readonly id: string }>(
 	name: string,
-	validator: Validator<T>
+	validator: Validatable<T>
 ): Validator<T> {
 	return new Validator((value) => {
 		const prefix =

commit b88a2370b314855237774548d627ed4d3301a1ad
Author: alex <alex@dytry.ch>
Date:   Fri Jun 16 11:33:47 2023 +0100

    Styles API (#1580)
    
    Removes `propsForNextShape` and replaces it with the new styles API.
    
    Changes in here:
    - New custom style example
    - `setProp` is now `setStyle` and takes a `StyleProp` instead of a
    string
    - `Editor.props` and `Editor.opacity` are now `Editor.sharedStyles` and
    `Editor.sharedOpacity`
    - They return an object that flags mixed vs shared types instead of
    using null to signal mixed types
    - `Editor.styles` returns a `SharedStyleMap` - keyed on `StyleProp`
    instead of `string`
    - `StateNode.shapeType` is now the shape util rather than just a string.
    This lets us pull the styles from the shape type directly.
    - `color` is no longer a core part of the editor set on the shape
    parent. Individual child shapes have to use color directly.
    - `propsForNextShape` is now `stylesForNextShape`
    - `InstanceRecordType` is created at runtime in the same way
    `ShapeRecordType` is. This is so it can pull style validators out of
    shape defs for `stylesForNextShape`
    - Shape type are now defined by their props rather than having separate
    validators & type defs
    
    ### Change Type
    
    - [x] `major` â€” Breaking change
    
    ### Test Plan
    
    1. Big time regression testing around styles!
    2. Check UI works as intended for all shape/style/tool combos
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    -
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 1b4914064..82465fcda 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -103,10 +103,7 @@ export class Validator<T> implements Validatable<T> {
 	 * null.
 	 */
 	nullable(): Validator<T | null> {
-		return new Validator((value) => {
-			if (value === null) return null
-			return this.validate(value)
-		})
+		return nullable(this)
 	}
 
 	/**
@@ -114,10 +111,7 @@ export class Validator<T> implements Validatable<T> {
 	 * null.
 	 */
 	optional(): Validator<T | undefined> {
-		return new Validator((value) => {
-			if (value === undefined) return undefined
-			return this.validate(value)
-		})
+		return optional(this)
 	}
 
 	/**
@@ -544,16 +538,24 @@ export function setEnum<T>(values: ReadonlySet<T>): Validator<T> {
 }
 
 /** @public */
-export const point = object({
-	x: number,
-	y: number,
-	z: number.optional(),
-})
+export function optional<T>(validator: Validatable<T>): Validator<T | undefined> {
+	return new Validator((value) => {
+		if (value === undefined) return undefined
+		return validator.validate(value)
+	})
+}
 
 /** @public */
-export const boxModel = object({
-	x: number,
-	y: number,
-	w: number,
-	h: number,
-})
+export function nullable<T>(validator: Validatable<T>): Validator<T | null> {
+	return new Validator((value) => {
+		if (value === null) return null
+		return validator.validate(value)
+	})
+}
+
+/** @public */
+export function literalEnum<const Values extends readonly unknown[]>(
+	...values: Values
+): Validator<Values[number]> {
+	return setEnum(new Set(values))
+}

commit fd29006538ab2e01b7d6c1275ac6d164e676398f
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jun 28 15:24:05 2023 +0100

    [feature] add `meta` property to records (#1627)
    
    This PR adds a `meta` property to shapes and other records.
    
    It adds it to:
    - asset
    - camera
    - document
    - instance
    - instancePageState
    - instancePresence
    - page
    - pointer
    - rootShape
    
    ## Setting meta
    
    This data can generally be added wherever you would normally update the
    corresponding record.
    
    An exception exists for shapes, which can be updated using a partial of
    the `meta` in the same way that we update shapes with a partial of
    `props`.
    
    ```ts
    this.updateShapes([{
        id: myShape.id,
        type: "geo",
        meta: {
          nemesis: "steve",
          special: true
        }
    ])
    ```
    
    ## `Editor.getInitialMetaForShape`
    
    The `Editor.getInitialMetaForShape` method is kind of a hack to set the
    initial meta property for newly created shapes. You can set it
    externally. Escape hatch!
    
    ### Change Type
    
    - [x] `minor` â€” New feature
    
    ### Test Plan
    
    todo
    
    - [ ] Unit Tests (todo)
    
    ### Release Notes
    
    - todo

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 82465fcda..9e9ea59eb 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1,4 +1,4 @@
-import { exhaustiveSwitchError, getOwnProperty, hasOwnProperty } from '@tldraw/utils'
+import { JsonValue, exhaustiveSwitchError, getOwnProperty, hasOwnProperty } from '@tldraw/utils'
 
 /** @public */
 export type ValidatorFn<T> = (value: unknown) => T
@@ -466,6 +466,49 @@ export function object<Shape extends object>(config: {
 	return new ObjectValidator(config)
 }
 
+function isValidJson(value: any): value is JsonValue {
+	if (
+		value === null ||
+		typeof value === 'number' ||
+		typeof value === 'string' ||
+		typeof value === 'boolean'
+	) {
+		return true
+	}
+
+	if (Array.isArray(value)) {
+		return value.every(isValidJson)
+	}
+
+	if (typeof value === 'object') {
+		return Object.values(value).every(isValidJson)
+	}
+
+	return false
+}
+
+/**
+ * Validate that a value is valid JSON.
+ *
+ * @public
+ */
+export const jsonValue = new Validator<JsonValue>((value): JsonValue => {
+	if (isValidJson(value)) {
+		return value as JsonValue
+	}
+
+	throw new ValidationError(`Expected json serializable value, got ${typeof value}`)
+})
+
+/**
+ * Validate an object has a particular shape.
+ *
+ * @public
+ */
+export function jsonDict(): DictValidator<string, JsonValue> {
+	return dict(string, jsonValue)
+}
+
 /**
  * Validation that an option is a dict with particular keys and values.
  *

commit 6e9fe0c8be339c11e922b1e7ff4ffd177f33d23e
Author: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>
Date:   Tue Jan 9 11:49:57 2024 +0100

    Add url validation (#2428)
    
    Adds validation for urls we use for our shapes and assets. This PR
    includes a migration so we should check that existing rooms still load
    correctly. There might be some that won't, but that means that they had
    invalid url set.
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    - [ ] `minor` â€” New feature
    - [ ] `major` â€” Breaking change
    - [ ] `dependencies` â€” Changes to package dependencies[^1]
    - [ ] `documentation` â€” Changes to the documentation only[^2]
    - [ ] `tests` â€” Changes to any test code only[^2]
    - [ ] `internal` â€” Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    1. Existing rooms should still load correctly (there should be no
    validation errors).
    2. Adding new images and videos should also work (test both local and
    multiplayer rooms as they handle assets differently).
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add validation to urls.
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 9e9ea59eb..cd8deb95e 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -98,6 +98,16 @@ export class Validator<T> implements Validatable<T> {
 		return validated
 	}
 
+	/** Checks that the passed value is of the correct type. */
+	isValid(value: unknown): value is T {
+		try {
+			this.validate(value)
+			return true
+		} catch {
+			return false
+		}
+	}
+
 	/**
 	 * Returns a new validator that also accepts null or undefined. The resulting value will always be
 	 * null.
@@ -602,3 +612,47 @@ export function literalEnum<const Values extends readonly unknown[]>(
 ): Validator<Values[number]> {
 	return setEnum(new Set(values))
 }
+
+function parseUrl(str: string) {
+	try {
+		return new URL(str)
+	} catch (error) {
+		throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
+	}
+}
+
+const validLinkProtocols = new Set(['http:', 'https:', 'mailto:'])
+
+/**
+ * Validates that a value is a url safe to use as a link.
+ *
+ * @public
+ */
+export const linkUrl = string.check((value) => {
+	if (value === '') return
+	const url = parseUrl(value)
+
+	if (!validLinkProtocols.has(url.protocol.toLowerCase())) {
+		throw new ValidationError(
+			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
+		)
+	}
+})
+
+const validSrcProtocols = new Set(['http:', 'https:', 'data:'])
+
+/**
+ * Validates that a valid is a url safe to load as an asset.
+ *
+ * @public
+ */
+export const srcUrl = string.check((value) => {
+	if (value === '') return
+	const url = parseUrl(value)
+
+	if (!validSrcProtocols.has(url.protocol.toLowerCase())) {
+		throw new ValidationError(
+			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
+		)
+	}
+})

commit 29044867dd2e49a3711e95c547fa9352e66720b9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 15 12:33:15 2024 +0000

    Add docs (#2470)
    
    This PR adds the docs app back into the tldraw monorepo.
    
    ## Deploying
    
    We'll want to update our deploy script to update the SOURCE_SHA to the
    newest release sha... and then deploy the docs pulling api.json files
    from that release. We _could_ update the docs on every push to main, but
    we don't have to unless something has changed. Right now there's no
    automated deployments from this repo.
    
    ## Side effects
    
    To make this one work, I needed to update the lock file. This might be
    ok (new year new lock file), and everything builds as expected, though
    we may want to spend some time with our scripts to be sure that things
    are all good.
    
    I also updated our prettier installation, which decided to add trailing
    commas to every generic type. Which is, I suppose, [correct
    behavior](https://github.com/prettier/prettier-vscode/issues/955)? But
    that caused diffs in every file, which is unfortunate.
    
    ### Change Type
    
    - [x] `internal` â€” Any other changes that don't affect the published
    package[^2]

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index cd8deb95e..77ba5b7e7 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -261,7 +261,7 @@ type UnionValidatorConfig<Key extends string, Config> = {
 export class UnionValidator<
 	Key extends string,
 	Config extends UnionValidatorConfig<Key, Config>,
-	UnknownValue = never
+	UnknownValue = never,
 > extends Validator<TypeOf<Config[keyof Config]> | UnknownValue> {
 	constructor(
 		private readonly key: Key,

commit 9c91b2c4cd4b0e6866c5aae89253442dfb479f87
Author: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>
Date:   Mon Jan 15 13:33:46 2024 +0100

    Fix validation for local files. (#2447)
    
    Allow urls for local files. This addresses the comment from
    [here](https://github.com/tldraw/tldraw/pull/2428#issuecomment-1886221841).
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    - [ ] `minor` â€” New feature
    - [ ] `major` â€” Breaking change
    - [ ] `dependencies` â€” Changes to package dependencies[^1]
    - [ ] `documentation` â€” Changes to the documentation only[^2]
    - [ ] `tests` â€” Changes to any test code only[^2]
    - [ ] `internal` â€” Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Local images example should now work. We use images from the public
    folder there.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 77ba5b7e7..aaea52e8f 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -617,6 +617,13 @@ function parseUrl(str: string) {
 	try {
 		return new URL(str)
 	} catch (error) {
+		if (str.startsWith('/') || str.startsWith('./')) {
+			try {
+				return new URL(str, 'http://example.com')
+			} catch (error) {
+				throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
+			}
+		}
 		throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
 	}
 }

commit e6e4e7f6cbac1cb72c0f530dae703c657dc8b6bf
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Feb 5 17:54:02 2024 +0000

    [dx] use Biome instead of Prettier, part 2 (#2731)
    
    Biome seems to be MUCH faster than Prettier. Unfortunately, it
    introduces some formatting changes around the ternary operator, so we
    have to update files in the repo. To make revert easier if we need it,
    the change is split into two PRs. This PR introduces a Biome CI check
    and reformats all files accordingly.
    
    ## Change Type
    - [x] `minor` â€” New feature

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index aaea52e8f..beab57988 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -242,9 +242,11 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 	 * })
 	 * ```
 	 */
-	extend<Extension extends Record<string, unknown>>(extension: {
-		readonly [K in keyof Extension]: Validatable<Extension[K]>
-	}): ObjectValidator<Shape & Extension> {
+	extend<Extension extends Record<string, unknown>>(
+		extension: {
+			readonly [K in keyof Extension]: Validatable<Extension[K]>
+		}
+	): ObjectValidator<Shape & Extension> {
 		return new ObjectValidator({ ...this.config, ...extension }) as ObjectValidator<
 			Shape & Extension
 		>
@@ -470,9 +472,11 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
  *
  * @public
  */
-export function object<Shape extends object>(config: {
-	readonly [K in keyof Shape]: Validatable<Shape[K]>
-}): ObjectValidator<Shape> {
+export function object<Shape extends object>(
+	config: {
+		readonly [K in keyof Shape]: Validatable<Shape[K]>
+	}
+): ObjectValidator<Shape> {
 	return new ObjectValidator(config)
 }
 

commit 86cce6d161e2018f02fc4271bbcff803d07fa339
Author: Dan Groshev <git@dgroshev.com>
Date:   Wed Feb 7 16:02:22 2024 +0000

    Unbiome (#2776)
    
    Biome as it is now didn't work out for us ðŸ˜¢
    
    Summary for posterity:
    
    * it IS much, much faster, fast enough to skip any sort of caching
    * we couldn't fully replace Prettier just yet. We use Prettier
    programmatically to format code in docs, and Biome's JS interface is
    officially alpha and [had legacy peer deps
    set](https://github.com/biomejs/biome/pull/1756) (which would fail our
    CI build as we don't allow installation warnings)
    * ternary formatting differs from Prettier, leading to a large diff
    https://github.com/biomejs/biome/issues/1661
    * import sorting differs from Prettier's
    `prettier-plugin-organize-imports`, making the diff even bigger
    * the deal breaker is a multi-second delay on saving large files (for us
    it's
    [Editor.ts](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/editor/Editor.ts))
    in VSCode when import sorting is enabled. There is a seemingly relevant
    Biome issue where I posted a small summary of our findings:
    https://github.com/biomejs/biome/issues/1569#issuecomment-1930411623
    
    Further actions:
    
    * reevaluate in a few months as Biome matures
    
    ### Change Type
    
    - [x] `internal` â€” Any other changes that don't affect the published
    package

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index beab57988..aaea52e8f 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -242,11 +242,9 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 	 * })
 	 * ```
 	 */
-	extend<Extension extends Record<string, unknown>>(
-		extension: {
-			readonly [K in keyof Extension]: Validatable<Extension[K]>
-		}
-	): ObjectValidator<Shape & Extension> {
+	extend<Extension extends Record<string, unknown>>(extension: {
+		readonly [K in keyof Extension]: Validatable<Extension[K]>
+	}): ObjectValidator<Shape & Extension> {
 		return new ObjectValidator({ ...this.config, ...extension }) as ObjectValidator<
 			Shape & Extension
 		>
@@ -472,11 +470,9 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
  *
  * @public
  */
-export function object<Shape extends object>(
-	config: {
-		readonly [K in keyof Shape]: Validatable<Shape[K]>
-	}
-): ObjectValidator<Shape> {
+export function object<Shape extends object>(config: {
+	readonly [K in keyof Shape]: Validatable<Shape[K]>
+}): ObjectValidator<Shape> {
 	return new ObjectValidator(config)
 }
 

commit a03edcff9d65780a3c0109e152c724358cc71058
Author: Mime ÄŒuvalo <mimecuvalo@gmail.com>
Date:   Wed Feb 7 16:30:46 2024 +0000

    error reporting: rm ids from msgs for better Sentry grouping (#2738)
    
    This removes the ids from shape paths so that they can be grouped on our
    error reporting tool.
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    
    ### Release Notes
    
    - Error reporting: improve grouping for Sentry.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index aaea52e8f..77fa46637 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -10,6 +10,7 @@ function formatPath(path: ReadonlyArray<number | string>): string | null {
 	if (!path.length) {
 		return null
 	}
+
 	let formattedPath = ''
 	for (const item of path) {
 		if (typeof item === 'number') {
@@ -24,6 +25,10 @@ function formatPath(path: ReadonlyArray<number | string>): string | null {
 			formattedPath += `.${item}`
 		}
 	}
+
+	// N.B. We don't want id's in the path because they make grouping in Sentry tough.
+	formattedPath = formattedPath.replace(/id = [^,]+, /, '').replace(/id = [^)]+/, '')
+
 	if (formattedPath.startsWith('.')) {
 		return formattedPath.slice(1)
 	}

commit 93c2ed615c61f09a3d4936c2ed06bcebd85cf363
Author: alex <alex@dytry.ch>
Date:   Wed Feb 14 17:53:30 2024 +0000

    [Snapping 1/5] Validation & strict types for fractional indexes  (#2827)
    
    Currently, we type our fractional index keys as `string` and don't have
    any validation for them. I'm touching some of this code for my work on
    line handles and wanted to change that:
    - fractional indexes are now `IndexKey`s, not `string`s. `IndexKey`s
    have a brand property so can't be used interchangeably with strings
    (like our IDs)
    - There's a new `T.indexKey` validator which we can use in our
    validations to make sure we don't end up with nonsense keys.
    
    This PR is part of a series - please don't merge it until the things
    before it have landed!
    1. #2827 (you are here)
    2. #2831
    3. #2793
    4. #2841
    5. #2845
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    
    ### Test Plan
    
    1. Mostly relying on unit & end to end tests here - no user facing
    changes.
    
    - [x] Unit Tests

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 77fa46637..0a34cb08f 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1,4 +1,11 @@
-import { JsonValue, exhaustiveSwitchError, getOwnProperty, hasOwnProperty } from '@tldraw/utils'
+import {
+	IndexKey,
+	JsonValue,
+	exhaustiveSwitchError,
+	getOwnProperty,
+	hasOwnProperty,
+	validateIndexKey,
+} from '@tldraw/utils'
 
 /** @public */
 export type ValidatorFn<T> = (value: unknown) => T
@@ -668,3 +675,16 @@ export const srcUrl = string.check((value) => {
 		)
 	}
 })
+
+/**
+ * Validates that a value is an IndexKey.
+ * @public
+ */
+export const indexKey = string.refine<IndexKey>((key) => {
+	try {
+		validateIndexKey(key)
+		return key
+	} catch {
+		throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)
+	}
+})

commit 4a2040f92ce6a13a03977195ebf8985dcc19b5d7
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Feb 20 12:35:25 2024 +0000

    Faster validations + record reference stability at the same time (#2848)
    
    This PR adds a validation mode whereby previous known-to-be-valid values
    can be used to speed up the validation process itself. At the same time
    it enables us to do fine-grained equality checking on records much more
    quickly than by using something like lodash isEqual, and using that we
    can prevent triggering effects for record updates that don't actually
    alter any values in the store.
    
    Here's some preliminary perf testing of average time spent in
    `store.put()` during some common interactions
    
    | task | before (ms) | after (ms) |
    | ---- | ---- | ---- |
    | drawing lines | 0.0403 | 0.0214 |
    | drawing boxes | 0.0408 | 0.0348 |
    | translating lines | 0.0352 | 0.0042 |
    | translating boxes | 0.0051 | 0.0032 |
    | rotating lines | 0.0312 | 0.0065 |
    | rotating boxes | 0.0053 | 0.0035 |
    | brush selecting boxes | 0.0200 | 0.0232 |
    | traversal with shapes | 0.0130 | 0.0108 |
    | traversal without shapes | 0.0201 | 0.0173 |
    
    **traversal** means moving the camera and pointer around the canvas
    
    #### Discussion
    
    At the scale of hundredths of a millisecond these .put operations are so
    fast that even if they became literally instantaneous the change would
    not be human perceptible. That said, there is an overall marked
    improvement here. Especially for dealing with draw shapes.
    
    These figures are also mostly in line with expectations, aside from a
    couple of things:
    
    - I don't understand why the `brush selecting boxes` task got slower
    after the change.
    - I don't understand why the `traversal` tasks are slower than the
    `translating boxes` task, both before and after. I would expect that
    .putting shape records would be much slower than .putting pointer/camera
    records (since the latter have fewer and simpler properties)
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 0a34cb08f..e16e52805 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -9,9 +9,26 @@ import {
 
 /** @public */
 export type ValidatorFn<T> = (value: unknown) => T
+/** @public */
+export type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (
+	knownGoodValue: In,
+	value: unknown
+) => Out
 
 /** @public */
-export type Validatable<T> = { validate: (value: unknown) => T }
+export type Validatable<T> = {
+	validate: (value: unknown) => T
+	/**
+	 * This is a performance optimizing version of validate that can use a previous
+	 * version of the value to avoid revalidating every part of the new value if
+	 * any part of it has not changed since the last validation.
+	 *
+	 * If the value has not changed but is not referentially equal, the function
+	 * should return the previous value.
+	 * @returns
+	 */
+	validateUsingKnownGoodVersion?: (knownGoodValue: T, newValue: unknown) => T
+}
 
 function formatPath(path: ReadonlyArray<number | string>): string | null {
 	if (!path.length) {
@@ -92,11 +109,14 @@ function typeToString(value: unknown): string {
 }
 
 /** @public */
-export type TypeOf<V extends Validatable<unknown>> = V extends Validatable<infer T> ? T : never
+export type TypeOf<V extends Validatable<any>> = V extends Validatable<infer T> ? T : never
 
 /** @public */
 export class Validator<T> implements Validatable<T> {
-	constructor(readonly validationFn: ValidatorFn<T>) {}
+	constructor(
+		readonly validationFn: ValidatorFn<T>,
+		readonly validateUsingKnownGoodVersionFn?: ValidatorUsingKnownGoodVersionFn<T>
+	) {}
 
 	/**
 	 * Asserts that the passed value is of the correct type and returns it. The returned value is
@@ -110,6 +130,18 @@ export class Validator<T> implements Validatable<T> {
 		return validated
 	}
 
+	validateUsingKnownGoodVersion(knownGoodValue: T, newValue: unknown): T {
+		if (Object.is(knownGoodValue, newValue)) {
+			return knownGoodValue as T
+		}
+
+		if (this.validateUsingKnownGoodVersionFn) {
+			return this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue)
+		}
+
+		return this.validate(newValue)
+	}
+
 	/** Checks that the passed value is of the correct type. */
 	isValid(value: unknown): value is T {
 		try {
@@ -141,9 +173,19 @@ export class Validator<T> implements Validatable<T> {
 	 * if the value can't be converted to the new type, or return the new type otherwise.
 	 */
 	refine<U>(otherValidationFn: (value: T) => U): Validator<U> {
-		return new Validator((value) => {
-			return otherValidationFn(this.validate(value))
-		})
+		return new Validator(
+			(value) => {
+				return otherValidationFn(this.validate(value))
+			},
+
+			(knownGoodValue, newValue) => {
+				const validated = this.validateUsingKnownGoodVersion(knownGoodValue as any, newValue)
+				if (Object.is(knownGoodValue, validated)) {
+					return knownGoodValue
+				}
+				return otherValidationFn(validated)
+			}
+		)
 	}
 
 	/**
@@ -179,13 +221,40 @@ export class Validator<T> implements Validatable<T> {
 /** @public */
 export class ArrayOfValidator<T> extends Validator<T[]> {
 	constructor(readonly itemValidator: Validatable<T>) {
-		super((value) => {
-			const arr = array.validate(value)
-			for (let i = 0; i < arr.length; i++) {
-				prefixError(i, () => itemValidator.validate(arr[i]))
+		super(
+			(value) => {
+				const arr = array.validate(value)
+				for (let i = 0; i < arr.length; i++) {
+					prefixError(i, () => itemValidator.validate(arr[i]))
+				}
+				return arr as T[]
+			},
+			(knownGoodValue, newValue) => {
+				if (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue)
+				const arr = array.validate(newValue)
+				let isDifferent = knownGoodValue.length !== arr.length
+				for (let i = 0; i < arr.length; i++) {
+					const item = arr[i]
+					if (i >= knownGoodValue.length) {
+						isDifferent = true
+						prefixError(i, () => itemValidator.validate(item))
+						continue
+					}
+					// sneaky quick check here to avoid the prefix + validator overhead
+					if (Object.is(knownGoodValue[i], item)) {
+						continue
+					}
+					const checkedItem = prefixError(i, () =>
+						itemValidator.validateUsingKnownGoodVersion!(knownGoodValue[i], item)
+					)
+					if (!Object.is(checkedItem, knownGoodValue[i])) {
+						isDifferent = true
+					}
+				}
+
+				return isDifferent ? (newValue as T[]) : knownGoodValue
 			}
-			return arr as T[]
-		})
+		)
 	}
 
 	nonEmpty() {
@@ -213,27 +282,68 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 		},
 		private readonly shouldAllowUnknownProperties = false
 	) {
-		super((object) => {
-			if (typeof object !== 'object' || object === null) {
-				throw new ValidationError(`Expected object, got ${typeToString(object)}`)
-			}
+		super(
+			(object) => {
+				if (typeof object !== 'object' || object === null) {
+					throw new ValidationError(`Expected object, got ${typeToString(object)}`)
+				}
 
-			for (const [key, validator] of Object.entries(config)) {
-				prefixError(key, () => {
-					;(validator as Validator<unknown>).validate(getOwnProperty(object, key))
-				})
-			}
+				for (const [key, validator] of Object.entries(config)) {
+					prefixError(key, () => {
+						;(validator as Validator<unknown>).validate(getOwnProperty(object, key))
+					})
+				}
 
-			if (!shouldAllowUnknownProperties) {
-				for (const key of Object.keys(object)) {
-					if (!hasOwnProperty(config, key)) {
-						throw new ValidationError(`Unexpected property`, [key])
+				if (!shouldAllowUnknownProperties) {
+					for (const key of Object.keys(object)) {
+						if (!hasOwnProperty(config, key)) {
+							throw new ValidationError(`Unexpected property`, [key])
+						}
 					}
 				}
-			}
 
-			return object as Shape
-		})
+				return object as Shape
+			},
+			(knownGoodValue, newValue) => {
+				if (typeof newValue !== 'object' || newValue === null) {
+					throw new ValidationError(`Expected object, got ${typeToString(newValue)}`)
+				}
+
+				let isDifferent = false
+
+				for (const [key, validator] of Object.entries(config)) {
+					const prev = getOwnProperty(knownGoodValue, key)
+					const next = getOwnProperty(newValue, key)
+					// sneaky quick check here to avoid the prefix + validator overhead
+					if (Object.is(prev, next)) {
+						continue
+					}
+					const checked = prefixError(key, () => {
+						return (validator as Validator<unknown>).validateUsingKnownGoodVersion(prev, next)
+					})
+					if (!Object.is(checked, prev)) {
+						isDifferent = true
+					}
+				}
+
+				if (!shouldAllowUnknownProperties) {
+					for (const key of Object.keys(newValue)) {
+						if (!hasOwnProperty(config, key)) {
+							throw new ValidationError(`Unexpected property`, [key])
+						}
+					}
+				}
+
+				for (const key of Object.keys(knownGoodValue)) {
+					if (!hasOwnProperty(newValue, key)) {
+						isDifferent = true
+						break
+					}
+				}
+
+				return isDifferent ? (newValue as Shape) : knownGoodValue
+			}
+		)
 	}
 
 	allowUnknownProperties() {
@@ -257,7 +367,7 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 	extend<Extension extends Record<string, unknown>>(extension: {
 		readonly [K in keyof Extension]: Validatable<Extension[K]>
 	}): ObjectValidator<Shape & Extension> {
-		return new ObjectValidator({ ...this.config, ...extension }) as ObjectValidator<
+		return new ObjectValidator({ ...this.config, ...extension }) as any as ObjectValidator<
 			Shape & Extension
 		>
 	}
@@ -280,25 +390,61 @@ export class UnionValidator<
 		private readonly config: Config,
 		private readonly unknownValueValidation: (value: object, variant: string) => UnknownValue
 	) {
-		super((input) => {
-			if (typeof input !== 'object' || input === null) {
-				throw new ValidationError(`Expected an object, got ${typeToString(input)}`, [])
-			}
+		super(
+			(input) => {
+				this.expectObject(input)
 
-			const variant = getOwnProperty(input, key) as keyof Config | undefined
-			if (typeof variant !== 'string') {
-				throw new ValidationError(
-					`Expected a string for key "${key}", got ${typeToString(variant)}`
-				)
-			}
+				const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input)
+				if (matchingSchema === undefined) {
+					return this.unknownValueValidation(input, variant)
+				}
 
-			const matchingSchema = hasOwnProperty(config, variant) ? config[variant] : undefined
-			if (matchingSchema === undefined) {
-				return this.unknownValueValidation(input, variant)
+				return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))
+			},
+			(prevValue, newValue) => {
+				this.expectObject(newValue)
+				this.expectObject(prevValue)
+
+				const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue)
+				if (matchingSchema === undefined) {
+					return this.unknownValueValidation(newValue, variant)
+				}
+
+				if (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {
+					// the type has changed so bail out and do a regular validation
+					return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue))
+				}
+
+				return prefixError(`(${key} = ${variant})`, () => {
+					if (matchingSchema.validateUsingKnownGoodVersion) {
+						return matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue)
+					} else {
+						return matchingSchema.validate(newValue)
+					}
+				})
 			}
+		)
+	}
 
-			return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))
-		})
+	private expectObject(value: unknown): asserts value is object {
+		if (typeof value !== 'object' || value === null) {
+			throw new ValidationError(`Expected an object, got ${typeToString(value)}`, [])
+		}
+	}
+
+	private getMatchingSchemaAndVariant(object: object): {
+		matchingSchema: Validatable<any> | undefined
+		variant: string
+	} {
+		const variant = getOwnProperty(object, this.key) as keyof Config | undefined
+		if (typeof variant !== 'string') {
+			throw new ValidationError(
+				`Expected a string for key "${this.key}", got ${typeToString(variant)}`
+			)
+		}
+
+		const matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : undefined
+		return { matchingSchema, variant }
 	}
 
 	validateUnknownVariants<Unknown>(
@@ -314,20 +460,65 @@ export class DictValidator<Key extends string, Value> extends Validator<Record<K
 		public readonly keyValidator: Validatable<Key>,
 		public readonly valueValidator: Validatable<Value>
 	) {
-		super((object) => {
-			if (typeof object !== 'object' || object === null) {
-				throw new ValidationError(`Expected object, got ${typeToString(object)}`)
-			}
+		super(
+			(object) => {
+				if (typeof object !== 'object' || object === null) {
+					throw new ValidationError(`Expected object, got ${typeToString(object)}`)
+				}
 
-			for (const [key, value] of Object.entries(object)) {
-				prefixError(key, () => {
-					keyValidator.validate(key)
-					valueValidator.validate(value)
-				})
-			}
+				for (const [key, value] of Object.entries(object)) {
+					prefixError(key, () => {
+						keyValidator.validate(key)
+						valueValidator.validate(value)
+					})
+				}
 
-			return object as Record<Key, Value>
-		})
+				return object as Record<Key, Value>
+			},
+			(knownGoodValue, newValue) => {
+				if (typeof newValue !== 'object' || newValue === null) {
+					throw new ValidationError(`Expected object, got ${typeToString(newValue)}`)
+				}
+
+				let isDifferent = false
+
+				for (const [key, value] of Object.entries(newValue)) {
+					if (!hasOwnProperty(knownGoodValue, key)) {
+						isDifferent = true
+						prefixError(key, () => {
+							keyValidator.validate(key)
+							valueValidator.validate(value)
+						})
+						continue
+					}
+					const prev = getOwnProperty(knownGoodValue, key)
+					const next = value
+					// sneaky quick check here to avoid the prefix + validator overhead
+					if (Object.is(prev, next)) {
+						continue
+					}
+					const checked = prefixError(key, () => {
+						if (valueValidator.validateUsingKnownGoodVersion) {
+							return valueValidator.validateUsingKnownGoodVersion(prev as any, next)
+						} else {
+							return valueValidator.validate(next)
+						}
+					})
+					if (!Object.is(checked, prev)) {
+						isDifferent = true
+					}
+				}
+
+				for (const key of Object.keys(knownGoodValue)) {
+					if (!hasOwnProperty(newValue, key)) {
+						isDifferent = true
+						break
+					}
+				}
+
+				return isDifferent ? (newValue as Record<Key, Value>) : knownGoodValue
+			}
+		)
 	}
 }
 
@@ -477,6 +668,14 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
 	return value as Record<string, unknown>
 })
 
+type ExtractRequiredKeys<T extends object> = {
+	[K in keyof T]: undefined extends T[K] ? never : K
+}[keyof T]
+
+type ExtractOptionalKeys<T extends object> = {
+	[K in keyof T]: undefined extends T[K] ? K : never
+}[keyof T]
+
 /**
  * Validate an object has a particular shape.
  *
@@ -484,8 +683,18 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
  */
 export function object<Shape extends object>(config: {
 	readonly [K in keyof Shape]: Validatable<Shape[K]>
-}): ObjectValidator<Shape> {
-	return new ObjectValidator(config)
+}): ObjectValidator<
+	{ [P in ExtractRequiredKeys<Shape>]: Shape[P] } & { [P in ExtractOptionalKeys<Shape>]?: Shape[P] }
+> {
+	return new ObjectValidator(config) as any
+}
+
+function isPlainObject(value: unknown): value is Record<string, unknown> {
+	return (
+		typeof value === 'object' &&
+		value !== null &&
+		(value.constructor === Object || !value.constructor)
+	)
 }
 
 function isValidJson(value: any): value is JsonValue {
@@ -502,7 +711,7 @@ function isValidJson(value: any): value is JsonValue {
 		return value.every(isValidJson)
 	}
 
-	if (typeof value === 'object') {
+	if (isPlainObject(value)) {
 		return Object.values(value).every(isValidJson)
 	}
 
@@ -514,13 +723,64 @@ function isValidJson(value: any): value is JsonValue {
  *
  * @public
  */
-export const jsonValue = new Validator<JsonValue>((value): JsonValue => {
-	if (isValidJson(value)) {
-		return value as JsonValue
-	}
+export const jsonValue: Validator<JsonValue> = new Validator<JsonValue>(
+	(value): JsonValue => {
+		if (isValidJson(value)) {
+			return value as JsonValue
+		}
 
-	throw new ValidationError(`Expected json serializable value, got ${typeof value}`)
-})
+		throw new ValidationError(`Expected json serializable value, got ${typeof value}`)
+	},
+	(knownGoodValue, newValue) => {
+		if (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {
+			let isDifferent = knownGoodValue.length !== newValue.length
+			for (let i = 0; i < newValue.length; i++) {
+				if (i >= knownGoodValue.length) {
+					isDifferent = true
+					jsonValue.validate(newValue[i])
+					continue
+				}
+				const prev = knownGoodValue[i]
+				const next = newValue[i]
+				if (Object.is(prev, next)) {
+					continue
+				}
+				const checked = jsonValue.validateUsingKnownGoodVersion!(prev, next)
+				if (!Object.is(checked, prev)) {
+					isDifferent = true
+				}
+			}
+			return isDifferent ? (newValue as JsonValue) : knownGoodValue
+		} else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {
+			let isDifferent = false
+			for (const key of Object.keys(newValue)) {
+				if (!hasOwnProperty(knownGoodValue, key)) {
+					isDifferent = true
+					jsonValue.validate(newValue[key])
+					continue
+				}
+				const prev = knownGoodValue[key]
+				const next = newValue[key]
+				if (Object.is(prev, next)) {
+					continue
+				}
+				const checked = jsonValue.validateUsingKnownGoodVersion!(prev!, next)
+				if (!Object.is(checked, prev)) {
+					isDifferent = true
+				}
+			}
+			for (const key of Object.keys(knownGoodValue)) {
+				if (!hasOwnProperty(newValue, key)) {
+					isDifferent = true
+					break
+				}
+			}
+			return isDifferent ? (newValue as JsonValue) : knownGoodValue
+		} else {
+			return jsonValue.validate(newValue)
+		}
+	}
+)
 
 /**
  * Validate an object has a particular shape.
@@ -581,14 +841,20 @@ export function model<T extends { readonly id: string }>(
 	name: string,
 	validator: Validatable<T>
 ): Validator<T> {
-	return new Validator((value) => {
-		const prefix =
-			value && typeof value === 'object' && 'id' in value && typeof value.id === 'string'
-				? `${name}(id = ${value.id})`
-				: name
-
-		return prefixError(prefix, () => validator.validate(value))
-	})
+	return new Validator(
+		(value) => {
+			return prefixError(name, () => validator.validate(value))
+		},
+		(prevValue, newValue) => {
+			return prefixError(name, () => {
+				if (validator.validateUsingKnownGoodVersion) {
+					return validator.validateUsingKnownGoodVersion(prevValue, newValue)
+				} else {
+					return validator.validate(newValue)
+				}
+			})
+		}
+	)
 }
 
 /** @public */
@@ -604,18 +870,37 @@ export function setEnum<T>(values: ReadonlySet<T>): Validator<T> {
 
 /** @public */
 export function optional<T>(validator: Validatable<T>): Validator<T | undefined> {
-	return new Validator((value) => {
-		if (value === undefined) return undefined
-		return validator.validate(value)
-	})
+	return new Validator(
+		(value) => {
+			if (value === undefined) return undefined
+			return validator.validate(value)
+		},
+		(knownGoodValue, newValue) => {
+			if (knownGoodValue === undefined && newValue === undefined) return undefined
+			if (newValue === undefined) return undefined
+			if (validator.validateUsingKnownGoodVersion && knownGoodValue !== undefined) {
+				return validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)
+			}
+			return validator.validate(newValue)
+		}
+	)
 }
 
 /** @public */
 export function nullable<T>(validator: Validatable<T>): Validator<T | null> {
-	return new Validator((value) => {
-		if (value === null) return null
-		return validator.validate(value)
-	})
+	return new Validator(
+		(value) => {
+			if (value === null) return null
+			return validator.validate(value)
+		},
+		(knownGoodValue, newValue) => {
+			if (newValue === null) return null
+			if (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {
+				return validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)
+			}
+			return validator.validate(newValue)
+		}
+	)
 }
 
 /** @public */

commit 5fd6b4dca7b67fe1775eb4f527de5d7fbf7e06d1
Author: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>
Date:   Wed Feb 21 13:15:51 2024 +0100

    Fix object validator (#2897)
    
    Make sure we check if we have the optional function before calling it
    
    ### Change Type
    
    - [x] `patch` â€” Bug fix
    - [ ] `minor` â€” New feature
    - [ ] `major` â€” Breaking change
    - [ ] `dependencies` â€” Changes to package dependencies[^1]
    - [ ] `documentation` â€” Changes to the documentation only[^2]
    - [ ] `tests` â€” Changes to any test code only[^2]
    - [ ] `internal` â€” Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index e16e52805..cbb6ffb64 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -290,7 +290,7 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 
 				for (const [key, validator] of Object.entries(config)) {
 					prefixError(key, () => {
-						;(validator as Validator<unknown>).validate(getOwnProperty(object, key))
+						;(validator as Validatable<unknown>).validate(getOwnProperty(object, key))
 					})
 				}
 
@@ -319,7 +319,12 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 						continue
 					}
 					const checked = prefixError(key, () => {
-						return (validator as Validator<unknown>).validateUsingKnownGoodVersion(prev, next)
+						const validatable = validator as Validatable<unknown>
+						if (validatable.validateUsingKnownGoodVersion) {
+							return validatable.validateUsingKnownGoodVersion(prev, next)
+						} else {
+							return validatable.validate(next)
+						}
 					})
 					if (!Object.is(checked, prev)) {
 						isDifferent = true

commit d7b80baa316237ee2ad982d4ae96df2ecc795065
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Mar 18 17:16:09 2024 +0000

    use native structuredClone on node, cloudflare workers, and in tests (#3166)
    
    Currently, we only use native `structuredClone` in the browser, falling
    back to `JSON.parse(JSON.stringify(...))` elsewhere, despite Node
    supporting `structuredClone` [since
    v17](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    and Cloudflare Workers supporting it [since
    2022](https://blog.cloudflare.com/standards-compliant-workers-api/).
    This PR adjusts our shim to use the native `structuredClone` on all
    platforms, if available.
    
    Additionally, `jsdom` doesn't implement `structuredClone`, a bug [open
    since 2022](https://github.com/jsdom/jsdom/issues/3363). This PR patches
    `jsdom` environment in all packages/apps that use it for tests.
    
    Also includes a driveby removal of `deepCopy`, a function that is
    strictly inferior to `structuredClone`.
    
    ### Change Type
    
    <!-- â— Please select a 'Scope' label â—ï¸ -->
    
    - [x] `sdk` â€” Changes the tldraw SDK
    - [x] `dotcom` â€” Changes the tldraw.com web app
    - [ ] `docs` â€” Changes to the documentation, examples, or templates.
    - [ ] `vs code` â€” Changes to the vscode plugin
    - [ ] `internal` â€” Does not affect user-facing stuff
    
    <!-- â— Please select a 'Type' label â—ï¸ -->
    
    - [ ] `bugfix` â€” Bug fix
    - [ ] `feature` â€” New feature
    - [x] `improvement` â€” Improving existing features
    - [x] `chore` â€” Updating dependencies, other boring stuff
    - [ ] `galaxy brain` â€” Architectural changes
    - [ ] `tests` â€” Changes to any test code
    - [ ] `tools` â€” Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` â€” I don't know
    
    
    ### Test Plan
    
    1. A smoke test would be enough
    
    - [ ] Unit Tests
    - [x] End to end tests

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index cbb6ffb64..b9d4d21f3 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1,6 +1,7 @@
 import {
 	IndexKey,
 	JsonValue,
+	STRUCTURED_CLONE_OBJECT_PROTOTYPE,
 	exhaustiveSwitchError,
 	getOwnProperty,
 	hasOwnProperty,
@@ -698,7 +699,9 @@ function isPlainObject(value: unknown): value is Record<string, unknown> {
 	return (
 		typeof value === 'object' &&
 		value !== null &&
-		(value.constructor === Object || !value.constructor)
+		(Object.getPrototypeOf(value) === Object.prototype ||
+			Object.getPrototypeOf(value) === null ||
+			Object.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE)
 	)
 }
 

commit 625f4abc3b90a4873e2e7b4038b6299a2b0d8722
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Apr 17 20:38:31 2024 +0100

    [fix] allow loading files (#3517)
    
    I messed up the schema validator for loading files.
    
    ### Change Type
    
    <!-- â— Please select a 'Scope' label â—ï¸ -->
    
    - [x] `sdk` â€” Changes the tldraw SDK
    - [ ] `dotcom` â€” Changes the tldraw.com web app
    - [ ] `docs` â€” Changes to the documentation, examples, or templates.
    - [ ] `vs code` â€” Changes to the vscode plugin
    - [ ] `internal` â€” Does not affect user-facing stuff
    
    <!-- â— Please select a 'Type' label â—ï¸ -->
    
    - [x] `bugfix` â€” Bug fix
    - [ ] `feature` â€” New feature
    - [ ] `improvement` â€” Improving existing features
    - [ ] `chore` â€” Updating dependencies, other boring stuff
    - [ ] `galaxy brain` â€” Architectural changes
    - [ ] `tests` â€” Changes to any test code
    - [ ] `tools` â€” Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` â€” I don't know

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index b9d4d21f3..145746437 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -394,7 +394,8 @@ export class UnionValidator<
 	constructor(
 		private readonly key: Key,
 		private readonly config: Config,
-		private readonly unknownValueValidation: (value: object, variant: string) => UnknownValue
+		private readonly unknownValueValidation: (value: object, variant: string) => UnknownValue,
+		private readonly useNumberKeys: boolean
 	) {
 		super(
 			(input) => {
@@ -442,11 +443,13 @@ export class UnionValidator<
 		matchingSchema: Validatable<any> | undefined
 		variant: string
 	} {
-		const variant = getOwnProperty(object, this.key) as keyof Config | undefined
-		if (typeof variant !== 'string') {
+		const variant = getOwnProperty(object, this.key) as string & keyof Config
+		if (!this.useNumberKeys && typeof variant !== 'string') {
 			throw new ValidationError(
 				`Expected a string for key "${this.key}", got ${typeToString(variant)}`
 			)
+		} else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {
+			throw new ValidationError(`Expected a number for key "${this.key}", got "${variant as any}"`)
 		}
 
 		const matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : undefined
@@ -456,7 +459,7 @@ export class UnionValidator<
 	validateUnknownVariants<Unknown>(
 		unknownValueValidation: (value: object, variant: string) => Unknown
 	): UnionValidator<Key, Config, Unknown> {
-		return new UnionValidator(this.key, this.config, unknownValueValidation)
+		return new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys)
 	}
 }
 
@@ -829,14 +832,41 @@ export function union<Key extends string, Config extends UnionValidatorConfig<Ke
 	key: Key,
 	config: Config
 ): UnionValidator<Key, Config> {
-	return new UnionValidator(key, config, (unknownValue, unknownVariant) => {
-		throw new ValidationError(
-			`Expected one of ${Object.keys(config)
-				.map((key) => JSON.stringify(key))
-				.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
-			[key]
-		)
-	})
+	return new UnionValidator(
+		key,
+		config,
+		(unknownValue, unknownVariant) => {
+			throw new ValidationError(
+				`Expected one of ${Object.keys(config)
+					.map((key) => JSON.stringify(key))
+					.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
+				[key]
+			)
+		},
+		false
+	)
+}
+
+/**
+ * @internal
+ */
+export function numberUnion<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(
+	key: Key,
+	config: Config
+): UnionValidator<Key, Config> {
+	return new UnionValidator(
+		key,
+		config,
+		(unknownValue, unknownVariant) => {
+			throw new ValidationError(
+				`Expected one of ${Object.keys(config)
+					.map((key) => JSON.stringify(key))
+					.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
+				[key]
+			)
+		},
+		true
+	)
 }
 
 /**

commit 38b1f7d0c9594b9dd05e610973f3accbdcbf72d2
Author: Lorenzo Lewis <lorenzo_lewis@icloud.com>
Date:   Tue May 21 17:28:52 2024 +0200

    Update validation.ts (#3324)
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    <!-- â— Please select a 'Scope' label â—ï¸ -->
    
    - [ ] `sdk` â€” Changes the tldraw SDK
    - [ ] `dotcom` â€” Changes the tldraw.com web app
    - [x] `docs` â€” Changes to the documentation, examples, or templates.
    - [ ] `vs code` â€” Changes to the vscode plugin
    - [ ] `internal` â€” Does not affect user-facing stuff
    
    <!-- â— Please select a 'Type' label â—ï¸ -->
    
    - [ ] `bugfix` â€” Bug fix
    - [ ] `feature` â€” New feature
    - [ ] `improvement` â€” Improving existing features
    - [x] `chore` â€” Updating dependencies, other boring stuff
    - [ ] `galaxy brain` â€” Architectural changes
    - [ ] `tests` â€” Changes to any test code
    - [ ] `tools` â€” Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` â€” I don't know
    
    
    ### Test Plan
    
    N/A
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Update example for Union type
    
    ---
    
    I believe this type was changed and `literal` is what it should be now.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 145746437..736be025d 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -821,8 +821,8 @@ export function dict<Key extends string, Value>(
  * @example
  *
  * ```ts
- * const catValidator = T.object({ kind: T.value('cat'), meow: T.boolean })
- * const dogValidator = T.object({ kind: T.value('dog'), bark: T.boolean })
+ * const catValidator = T.object({ kind: T.literal('cat'), meow: T.boolean })
+ * const dogValidator = T.object({ kind: T.literal('dog'), bark: T.boolean })
  * const animalValidator = T.union('kind', { cat: catValidator, dog: dogValidator })
  * ```
  *

commit f9ed1bf2c9480b1c49f591a8609adfb4fcf91eae
Author: alex <alex@dytry.ch>
Date:   Wed May 22 16:55:49 2024 +0100

    Force `interface` instead of `type` for better docs (#3815)
    
    Typescript's type aliases (`type X = thing`) can refer to basically
    anything, which makes it hard to write an automatic document formatter
    for them. Interfaces on the other hand are only object, so they play
    much nicer with docs. Currently, object-flavoured type aliases don't
    really get expanded at all on our docs site, which means we have a bunch
    of docs content that's not shown on the site.
    
    This diff introduces a lint rule that forces `interface X {foo: bar}`s
    instead of `type X = {foo: bar}` where possible, as it results in a much
    better documentation experience:
    
    Before:
    <img width="437" alt="Screenshot 2024-05-22 at 15 24 13"
    src="https://github.com/tldraw/tldraw/assets/1489520/32606fd1-6832-4a1e-aa5f-f0534d160c92">
    
    After:
    <img width="431" alt="Screenshot 2024-05-22 at 15 33 01"
    src="https://github.com/tldraw/tldraw/assets/1489520/4e0d59ee-c38e-4056-b9fd-6a7f15d28f0f">
    
    
    ### Change Type
    
    - [x] `sdk` â€” Changes the tldraw SDK
    - [x] `docs` â€” Changes to the documentation, examples, or templates.
    - [x] `improvement` â€” Improving existing features

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 736be025d..694af8fa2 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -17,7 +17,7 @@ export type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (
 ) => Out
 
 /** @public */
-export type Validatable<T> = {
+export interface Validatable<T> {
 	validate: (value: unknown) => T
 	/**
 	 * This is a performance optimizing version of validate that can use a previous

commit fb0dd1d2fe7d974dfa194264b4c3f196469cba97
Author: alex <alex@dytry.ch>
Date:   Mon Jun 10 14:50:03 2024 +0100

    make sure everything marked @public gets documented (#3892)
    
    Previously, we had the `ae-forgotten-export` rule from api-extractor
    disabled. This rule makes sure that everything that's referred to in the
    public API is actually exported. There are more details on the rule
    [here](https://api-extractor.com/pages/messages/ae-forgotten-export/),
    but not exporting public API entires is bad because they're hard to
    document and can't be typed/called from consumer code. For us, the big
    effect is that they don't appear in our docs at all.
    
    This diff re-enables that rule. Now, if you introduce something new to
    the public API but don't export it, your build will fail.
    
    ### Change Type
    
    - [x] `docs` â€” Changes to the documentation, examples, or templates.
    - [x] `improvement` â€” Improving existing features

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 694af8fa2..9508d71b4 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -380,7 +380,8 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 }
 
 // pass this into itself e.g. Config extends UnionObjectSchemaConfig<Key, Config>
-type UnionValidatorConfig<Key extends string, Config> = {
+/** @public */
+export type UnionValidatorConfig<Key extends string, Config> = {
 	readonly [Variant in keyof Config]: Validatable<any> & {
 		validate: (input: any) => { readonly [K in Key]: Variant }
 	}
@@ -677,11 +678,13 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
 	return value as Record<string, unknown>
 })
 
-type ExtractRequiredKeys<T extends object> = {
+/** @public */
+export type ExtractRequiredKeys<T extends object> = {
 	[K in keyof T]: undefined extends T[K] ? never : K
 }[keyof T]
 
-type ExtractOptionalKeys<T extends object> = {
+/** @public */
+export type ExtractOptionalKeys<T extends object> = {
 	[K in keyof T]: undefined extends T[K] ? K : never
 }[keyof T]
 

commit 735161c4a81fb617805ffb7f76a274954ec1d2f4
Author: Mime ÄŒuvalo <mimecuvalo@gmail.com>
Date:   Fri Jun 14 11:23:52 2024 +0100

    assets: store in indexedDB, not as base64 (#3836)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3745
    
    As I look at LOD holistically and whether we have multiple sources when
    working locally, I learned that our system used base64 encoding of
    assets directly. Issue https://github.com/tldraw/tldraw/issues/3728
    
    <img width="1350" alt="assetstore"
    src="https://github.com/tldraw/tldraw/assets/469604/e7b41e29-6656-4d9b-b462-72d43b98f3f7">
    
    
    The motivations and benefits are:
    - store size: not having a huge base64 blobs injected in room data
    - perf on loading snapshot: this helps with loading the room data more
    quickly
    - multiple sources: furthermore, if we do decide to have multiple
    sources locally (for each asset), then we won't get a multiplicative
    effect of even larger JSON blobs that have lots of base64 data in them
    - encoding/decoding perf: this also saves the (slow) step of having to
    base64 encode/decode our assets, we can just strictly with work with
    blobs.
    
    
    Todo:
    - [x] decodes video and images
    - [x] make sure it syncs to other tabs
    - [x] make sure it syncs to other multiplayer room
    - [x] fix tests
    
    
    ### Change Type
    
    <!-- â— Please select a 'Scope' label â—ï¸ -->
    
    - [x] `sdk` â€” Changes the tldraw SDK
    - [ ] `dotcom` â€” Changes the tldraw.com web app
    - [ ] `docs` â€” Changes to the documentation, examples, or templates.
    - [ ] `vs code` â€” Changes to the vscode plugin
    - [ ] `internal` â€” Does not affect user-facing stuff
    
    <!-- â— Please select a 'Type' label â—ï¸ -->
    
    - [ ] `bugfix` â€” Bug fix
    - [ ] `feature` â€” New feature
    - [x] `improvement` â€” Improving existing features
    - [ ] `chore` â€” Updating dependencies, other boring stuff
    - [ ] `galaxy brain` â€” Architectural changes
    - [ ] `tests` â€” Changes to any test code
    - [ ] `tools` â€” Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` â€” I don't know
    
    
    ### Test Plan
    
    1. Test the shit out of uploading/downloading video/image assets,
    locally+multiplayer.
    
    - [ ] Need to fix current tests and write new ones
    
    ### Release Notes
    
    - Assets: store as reference to blob in indexedDB instead of storing
    directly as base64 in the snapshot.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 9508d71b4..3b0fea30a 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -984,7 +984,8 @@ export const linkUrl = string.check((value) => {
 	}
 })
 
-const validSrcProtocols = new Set(['http:', 'https:', 'data:'])
+// N.B. asset: is a reference to the local indexedDB object store.
+const validSrcProtocols = new Set(['http:', 'https:', 'data:', 'asset:'])
 
 /**
  * Validates that a valid is a url safe to load as an asset.

commit ee6aa172b22bbf0452ca0c1fa5417f36d883d35b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Jul 1 15:40:03 2024 +0100

    Unfurl bookmarks in worker (#4039)
    
    This PR adds a `GET /api/unfurl?url=blahblah` endpoint to our worker.
    
    I tried out the existing cheerio implementation but it added 300kb to
    our worker bundle in the end, due to transitive dependencies.
    
    So I implemented the same logic with cloudflare's sanctioned streaming
    HTML parser `HTMLRewriter` and it seems to work fine.
    
    I also made the vscode extension do its fetching locally (from the node
    process so it's not bound by security policies), retaining the cheerio
    version for that. At the same time I fixed a bug in the RPC layer that
    was preventing unfurled metadata from loading correctly.
    
    In a few months we can retire the bookmark-extractor app by just
    deleting it in the vercel dashboard.
    
    ### Change Type
    
    
    <!-- â— Please select a 'Type' label â—ï¸ -->
    
    - [ ] `feature` â€” New feature
    - [x] `improvement` â€” Product improvement
    - [ ] `api` â€” API change
    - [ ] `bugfix` â€” Bug fix
    - [ ] `other` â€” Changes that don't affect SDK users, e.g. internal or
    .com changes
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Do link unfurling on the same subdomain as all our other api
    endpoints.

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 3b0fea30a..5ac3f0800 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1003,6 +1003,22 @@ export const srcUrl = string.check((value) => {
 	}
 })
 
+/**
+ * Validates an http(s) url
+ *
+ * @public
+ */
+export const httpUrl = string.check((value) => {
+	if (value === '') return
+	const url = parseUrl(value)
+
+	if (!url.protocol.toLowerCase().match(/^https?:$/)) {
+		throw new ValidationError(
+			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
+		)
+	}
+})
+
 /**
  * Validates that a value is an IndexKey.
  * @public

commit 8906bd8ffa085c76103a56f23a22e67dd8b5ded9
Author: alex <alex@dytry.ch>
Date:   Wed Jul 3 11:48:34 2024 +0100

    Demo server bookmark unfurl endpoint (#4062)
    
    This adds the HTMLRewriter-based bookmark unfurler to the demo server.
    It moves the unfurler into worker-shared, and adds some better shared
    error handling across our workers.
    
    I removed the fallback bookmark fetcher where we try and fetch websites
    locally. This will almost never work, as it requires sites to set public
    CORS.
    
    ### Change type
    - [x] `other`

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 5ac3f0800..ab4860b6c 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1,4 +1,5 @@
 import {
+	Expand,
 	IndexKey,
 	JsonValue,
 	STRUCTURED_CLONE_OBJECT_PROTOTYPE,
@@ -696,7 +697,11 @@ export type ExtractOptionalKeys<T extends object> = {
 export function object<Shape extends object>(config: {
 	readonly [K in keyof Shape]: Validatable<Shape[K]>
 }): ObjectValidator<
-	{ [P in ExtractRequiredKeys<Shape>]: Shape[P] } & { [P in ExtractOptionalKeys<Shape>]?: Shape[P] }
+	Expand<
+		{ [P in ExtractRequiredKeys<Shape>]: Shape[P] } & {
+			[P in ExtractOptionalKeys<Shape>]?: Shape[P]
+		}
+	>
 > {
 	return new ObjectValidator(config) as any
 }

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index ab4860b6c..61aa3c863 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -19,7 +19,7 @@ export type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (
 
 /** @public */
 export interface Validatable<T> {
-	validate: (value: unknown) => T
+	validate(value: unknown): T
 	/**
 	 * This is a performance optimizing version of validate that can use a previous
 	 * version of the value to avoid revalidating every part of the new value if
@@ -29,7 +29,7 @@ export interface Validatable<T> {
 	 * should return the previous value.
 	 * @returns
 	 */
-	validateUsingKnownGoodVersion?: (knownGoodValue: T, newValue: unknown) => T
+	validateUsingKnownGoodVersion?(knownGoodValue: T, newValue: unknown): T
 }
 
 function formatPath(path: ReadonlyArray<number | string>): string | null {
@@ -384,7 +384,7 @@ export class ObjectValidator<Shape extends object> extends Validator<Shape> {
 /** @public */
 export type UnionValidatorConfig<Key extends string, Config> = {
 	readonly [Variant in keyof Config]: Validatable<any> & {
-		validate: (input: any) => { readonly [K in Key]: Variant }
+		validate(input: any): { readonly [K in Key]: Variant }
 	}
 }
 /** @public */
@@ -843,7 +843,7 @@ export function union<Key extends string, Config extends UnionValidatorConfig<Ke
 	return new UnionValidator(
 		key,
 		config,
-		(unknownValue, unknownVariant) => {
+		(_unknownValue, unknownVariant) => {
 			throw new ValidationError(
 				`Expected one of ${Object.keys(config)
 					.map((key) => JSON.stringify(key))

commit 966406f0f88cb39fc72cb78eb220a4b4acc463f9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Sep 25 11:34:05 2024 +0100

    [in the voice of David S: MERGE] tldraw.com v2 (#4576)
    
    iykyk
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mime ÄŒuvalo <mimecuvalo@gmail.com>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 61aa3c863..d0d9de289 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1036,3 +1036,18 @@ export const indexKey = string.refine<IndexKey>((key) => {
 		throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)
 	}
 })
+
+/**
+ * Validate a value against one of two types.
+ *
+ * @public
+ */
+export function or<T1, T2>(v1: Validatable<T1>, v2: Validatable<T2>): Validator<T1 | T2> {
+	return new Validator((value) => {
+		try {
+			return v1.validate(value)
+		} catch {
+			return v2.validate(value)
+		}
+	})
+}

commit b301aeb64e5ff7bcd55928d7200a39092da8c501
Author: Mime ÄŒuvalo <mimecuvalo@gmail.com>
Date:   Wed Oct 23 15:55:42 2024 +0100

    npm: upgrade eslint v8 â†’ v9 (#4757)
    
    As I worked on the i18n PR (https://github.com/tldraw/tldraw/pull/4719)
    I noticed that `react-intl` required a new version of `eslint`. That led
    me down a bit of a rabbit hole of upgrading v8 â†’ v9. There were a couple
    things to upgrade to make this work.
    
    - ran `npx @eslint/migrate-config .eslintrc.js` to upgrade to the new
    `eslint.config.mjs`
    - `.eslintignore` is now deprecated and part of `eslint.config.mjs`
    - some packages are no longer relevant, of note: `eslint-plugin-local`
    and `eslint-plugin-deprecation`
    - the upgrade caught a couple bugs/dead code
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Upgrade eslint v8 â†’ v9
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Mitja BezenÅ¡ek <mitja.bezensek@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index d0d9de289..a982b69f8 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -959,11 +959,11 @@ export function literalEnum<const Values extends readonly unknown[]>(
 function parseUrl(str: string) {
 	try {
 		return new URL(str)
-	} catch (error) {
+	} catch {
 		if (str.startsWith('/') || str.startsWith('./')) {
 			try {
 				return new URL(str, 'http://example.com')
-			} catch (error) {
+			} catch {
 				throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
 			}
 		}

commit 7f45ba074d3c8c50a917eb828015fbdbf1b6cb26
Author: alex <alex@dytry.ch>
Date:   Tue Dec 3 11:08:23 2024 +0000

    Create a utility type for making undefined properties optional  (#5055)
    
    Adapted from #5011.
    
    This extracts a type used in the object validation for making all
    properties of an object that accepts undefined optional. This is useful
    when you have an object of validators (e.g. props for a shape) and want
    to create the typescript type for an object that will be accepted by it.
    With this, any of the properties that has a validator with `.optional()`
    will be optional in that object.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ### Test plan
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Expose a utility type for making undefined properties optional
    
    ---------
    
    Co-authored-by: Trygve Aaberge <trygve.aaberge@autodesk.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index a982b69f8..87c68cb9e 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -1,7 +1,7 @@
 import {
-	Expand,
 	IndexKey,
 	JsonValue,
+	MakeUndefinedOptional,
 	STRUCTURED_CLONE_OBJECT_PROTOTYPE,
 	exhaustiveSwitchError,
 	getOwnProperty,
@@ -679,16 +679,6 @@ export const unknownObject = new Validator<Record<string, unknown>>((value) => {
 	return value as Record<string, unknown>
 })
 
-/** @public */
-export type ExtractRequiredKeys<T extends object> = {
-	[K in keyof T]: undefined extends T[K] ? never : K
-}[keyof T]
-
-/** @public */
-export type ExtractOptionalKeys<T extends object> = {
-	[K in keyof T]: undefined extends T[K] ? K : never
-}[keyof T]
-
 /**
  * Validate an object has a particular shape.
  *
@@ -696,13 +686,7 @@ export type ExtractOptionalKeys<T extends object> = {
  */
 export function object<Shape extends object>(config: {
 	readonly [K in keyof Shape]: Validatable<Shape[K]>
-}): ObjectValidator<
-	Expand<
-		{ [P in ExtractRequiredKeys<Shape>]: Shape[P] } & {
-			[P in ExtractOptionalKeys<Shape>]?: Shape[P]
-		}
-	>
-> {
+}): ObjectValidator<MakeUndefinedOptional<Shape>> {
 	return new ObjectValidator(config) as any
 }
 

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime ÄŒuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between listsâ†”headers, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster â€” I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool â€” can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/validate/src/lib/validation.ts b/packages/validate/src/lib/validation.ts
index 87c68cb9e..1ece2f223 100644
--- a/packages/validate/src/lib/validation.ts
+++ b/packages/validate/src/lib/validation.ts
@@ -445,7 +445,7 @@ export class UnionValidator<
 		matchingSchema: Validatable<any> | undefined
 		variant: string
 	} {
-		const variant = getOwnProperty(object, this.key) as string & keyof Config
+		const variant = getOwnProperty(object, this.key)! as string & keyof Config
 		if (!this.useNumberKeys && typeof variant !== 'string') {
 			throw new ValidationError(
 				`Expected a string for key "${this.key}", got ${typeToString(variant)}`

