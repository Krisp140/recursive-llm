# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/ReactFiberLane.js

commit db6513914f99c260090f26f0a547ee1432c934e6
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 24 23:26:04 2020 -0700

    Make ExpirationTime an opaque type (#18732)
    
    * Add LanePriority type
    
    React's internal scheduler has more priority levels than the external
    Scheduler package. Let's use React as the source of truth for tracking
    the priority of updates so we have more control. We'll still fall back
    to Scheduler in the default case. In the future, we should consider
    removing `runWithPriority` from Scheduler and replacing the valid use
    cases with React-specific APIs.
    
    This commit adds a new type, called a LanePriority to disambiguate from
    the Scheduler one.
    
    ("Lane" refers to another type that I'm planning. It roughly translates
    to "thread." Each lane will have a priority associated with it.)
    
    I'm not actually using the lane anywhere, yet. Only setting stuff up.
    
    * Remove expiration times train model
    
    In the old reconciler, expiration times are computed by applying an
    offset to the current system time. This has the effect of increasing
    the priority of updates as time progresses. Because we also use
    expiration times as a kind of "thread" identifier, it turns out this
    is quite limiting because we can only flush work sequentially along
    the timeline.
    
    The new model will use a bitmask to represent parallel threads that
    can be worked on in any combination and in any order.
    
    In this commit, expiration times and the linear timeline are still in
    place, but they are no longer based on a timestamp. Effectively, they
    are constants based on their priority level.
    
    * Stop using ExpirationTime to represent timestamps
    
    Follow up to the previous commit. This converts the remaining places
    where we were using the ExpirationTime type to represent a timestamp,
    like Suspense timeouts.
    
    * Fork Dependencies and PendingInteractionMap types
    
    These contain expiration times
    
    * Make ExpirationTime an opaque type
    
    ExpirationTime is currently just an alias for the `number` type, for a
    few reasons. One is that it predates Flow's opaque type feature. Another
    is that making it opaque means we have to move all our comparisons and
    number math to the ExpirationTime module, and use utility functions
    everywhere else.
    
    However, this is actually what we want in the new system, because the
    Lanes type that will replace ExpirationTime is a bitmask with a
    particular layout, and performing operations on it will involve more
    than just number comparisions and artihmetic. I don't want this logic to
    spread ad hoc around the whole codebase.
    
    The utility functions get inlined by Closure so it doesn't matter
    performance-wise.
    
    I automated most of the changes with JSCodeshift, with only a few manual
    tweaks to stuff like imports. My goal was to port the logic exactly to
    prevent subtle mistakes, without trying to simplify anything in the
    process. I'll likely need to audit many of these sites again when I
    replace them with the new type, though, especially the ones
    in ReactFiberRoot.
    
    I added the codemods I used to the `scripts` directory. I won't merge
    these to master. I'll remove them in a subsequent commit. I'm only
    committing them here so they show up in the PR for future reference.
    
    I had a lot of trouble getting Flow to pass. Somehow it was not
    inferring the correct type of the constants exported from the
    ExpirationTime module, despite being annotated correctly.
    
    I tried converting them them to constructor functions — `NoWork`
    becomes `NoWork()` — and that made it work. I used that to unblock me,
    and fixed all the other type errors. Once there were no more type
    errors, I tried converting the constructors back to constants. Started
    getting errors again.
    
    Then I added a type constraint everywhere a constant was referenced.
    That fixed it. I also figured out that you only have to add a constraint
    when the constant is passed to another function, even if the function is
    annotated. So this indicates to me that it's probably a Flow bug. I'll
    file an issue with Flow.
    
    * Delete temporary codemods used in previous commit
    
    I only added these to the previous commit so that I can easily run it
    again when rebasing. When the stack is squashed, it will be as if they
    never existed.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
new file mode 100644
index 0000000000..4e389fe737
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+export opaque type LanePriority = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
+
+export const SyncLanePriority: LanePriority = 10;
+export const SyncBatchedLanePriority: LanePriority = 9;
+export const InputDiscreteLanePriority: LanePriority = 8;
+export const InputContinuousLanePriority: LanePriority = 7;
+export const DefaultLanePriority: LanePriority = 6;
+export const TransitionShortLanePriority: LanePriority = 5;
+export const TransitionLongLanePriority: LanePriority = 4;
+export const HydrationContinuousLanePriority: LanePriority = 3;
+export const IdleLanePriority: LanePriority = 2;
+export const OffscreenLanePriority: LanePriority = 1;
+export const NoLanePriority: LanePriority = 0;

commit 93e078ddf274636b0a40bd5501ce3549aec700fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat May 2 17:09:31 2020 -0700

    Initial Lanes implementation (#18796)
    
    See PR #18796 for more information.
    
    All of the changes I've made in this commit are behind the
    `enableNewReconciler` flag. Merging this to master will not affect the
    open source builds or the build that we ship to Facebook.
    
    The only build that is affected is the `ReactDOMForked` build, which is
    deployed to Facebook **behind an experimental flag (currently disabled
    for all users)**. We will use this flag to gradually roll out the new
    reconciler, and quickly roll it back if we find any problems.
    
    Because we have those protections in place, what I'm aiming for with
    this initial PR is the **smallest possible atomic change that lands
    cleanly and doesn't rely on too many hacks**. The goal has not been to
    get every single test or feature passing, and it definitely is not to
    implement all the features that we intend to build on top of the new
    model. When possible, I have chosen to preserve existing semantics and
    defer changes to follow-up steps. (Listed in the section below.)
    
    (I did not end up having to disable any tests, although if I had, that
    should not have necessarily been a merge blocker.)
    
    For example, even though one of the primary goals of this project is to
    improve our model for parallel Suspense transitions, in this initial
    implementation, I have chosen to keep the same core heuristics for
    sequencing and flushing that existed in the ExpirationTimes model: low
    priority updates cannot finish without also finishing high priority
    ones.
    
    Despite all these precautions, **because the scope of this refactor is
    inherently large, I do expect we will find regressions.** The flip side
    is that I also expect the new model to improve the stability of the
    codebase and make it easier to fix bugs when they arise.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 4e389fe737..65d35d7640 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -7,16 +7,682 @@
  * @flow
  */
 
-export opaque type LanePriority = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
-
-export const SyncLanePriority: LanePriority = 10;
-export const SyncBatchedLanePriority: LanePriority = 9;
-export const InputDiscreteLanePriority: LanePriority = 8;
-export const InputContinuousLanePriority: LanePriority = 7;
-export const DefaultLanePriority: LanePriority = 6;
-export const TransitionShortLanePriority: LanePriority = 5;
-export const TransitionLongLanePriority: LanePriority = 4;
-export const HydrationContinuousLanePriority: LanePriority = 3;
-export const IdleLanePriority: LanePriority = 2;
-export const OffscreenLanePriority: LanePriority = 1;
-export const NoLanePriority: LanePriority = 0;
+import type {FiberRoot, ReactPriorityLevel} from './ReactInternalTypes';
+
+export opaque type LanePriority =
+  | 0
+  | 1
+  | 2
+  | 3
+  | 4
+  | 5
+  | 6
+  | 7
+  | 8
+  | 9
+  | 10
+  | 11
+  | 12
+  | 13
+  | 14
+  | 15
+  | 16;
+export opaque type Lanes = number;
+export opaque type Lane = number;
+
+import invariant from 'shared/invariant';
+
+import {
+  ImmediatePriority as ImmediateSchedulerPriority,
+  UserBlockingPriority as UserBlockingSchedulerPriority,
+  NormalPriority as NormalSchedulerPriority,
+  LowPriority as LowSchedulerPriority,
+  IdlePriority as IdleSchedulerPriority,
+  NoPriority as NoSchedulerPriority,
+} from './SchedulerWithReactIntegration.new';
+
+export const SyncLanePriority: LanePriority = 16;
+const SyncBatchedLanePriority: LanePriority = 15;
+
+const InputDiscreteHydrationLanePriority: LanePriority = 14;
+export const InputDiscreteLanePriority: LanePriority = 13;
+
+const InputContinuousHydrationLanePriority: LanePriority = 12;
+const InputContinuousLanePriority: LanePriority = 11;
+
+const DefaultHydrationLanePriority: LanePriority = 10;
+const DefaultLanePriority: LanePriority = 9;
+
+const TransitionShortHydrationLanePriority: LanePriority = 8;
+export const TransitionShortLanePriority: LanePriority = 7;
+
+const TransitionLongHydrationLanePriority: LanePriority = 6;
+export const TransitionLongLanePriority: LanePriority = 5;
+
+const SelectiveHydrationLanePriority: LanePriority = 4;
+
+const IdleHydrationLanePriority: LanePriority = 3;
+const IdleLanePriority: LanePriority = 2;
+
+const OffscreenLanePriority: LanePriority = 1;
+
+const NoLanePriority: LanePriority = 0;
+
+const TotalLanes = 31;
+
+export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
+export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
+
+export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
+const SyncUpdateRangeEnd = 1;
+export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;
+const SyncBatchedUpdateRangeEnd = 2;
+
+export const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;
+const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011100;
+const InputDiscreteUpdateRangeStart = 3;
+const InputDiscreteUpdateRangeEnd = 5;
+
+const InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;
+const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011100000;
+const InputContinuousUpdateRangeStart = 6;
+const InputContinuousUpdateRangeEnd = 8;
+
+export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
+const DefaultLanes: Lanes = /*                          */ 0b0000000000000000011111100000000;
+const DefaultUpdateRangeStart = 9;
+const DefaultUpdateRangeEnd = 14;
+
+const TransitionShortHydrationLane: Lane = /*           */ 0b0000000000000000100000000000000;
+const TransitionShortLanes: Lanes = /*                  */ 0b0000000000011111100000000000000;
+const TransitionShortUpdateRangeStart = 15;
+const TransitionShortUpdateRangeEnd = 20;
+
+const TransitionLongHydrationLane: Lane = /*            */ 0b0000000000100000000000000000000;
+const TransitionLongLanes: Lanes = /*                   */ 0b0000011111100000000000000000000;
+const TransitionLongUpdateRangeStart = 21;
+const TransitionLongUpdateRangeEnd = 26;
+
+export const SelectiveHydrationLane: Lane = /*          */ 0b0000110000000000000000000000000;
+const SelectiveHydrationRangeEnd = 27;
+
+// Includes all non-Idle updates
+const UpdateRangeEnd = 27;
+const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;
+
+export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
+const IdleLanes: Lanes = /*                             */ 0b0111000000000000000000000000000;
+const IdleUpdateRangeStart = 28;
+const IdleUpdateRangeEnd = 30;
+
+export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
+
+// "Registers" used to "return" multiple values
+// Used by getHighestPriorityLanes and getNextLanes:
+let return_highestLanePriority: LanePriority = DefaultLanePriority;
+let return_updateRangeEnd: number = -1;
+
+function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
+  if ((SyncLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncLanePriority;
+    return_updateRangeEnd = SyncUpdateRangeEnd;
+    return SyncLane;
+  }
+  if ((SyncBatchedLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncBatchedLanePriority;
+    return_updateRangeEnd = SyncBatchedUpdateRangeEnd;
+    return SyncBatchedLane;
+  }
+  const inputDiscreteLanes = InputDiscreteLanes & lanes;
+  if (inputDiscreteLanes !== NoLanes) {
+    if (inputDiscreteLanes & InputDiscreteHydrationLane) {
+      return_highestLanePriority = InputDiscreteHydrationLanePriority;
+      return_updateRangeEnd = InputDiscreteUpdateRangeStart;
+      return InputDiscreteHydrationLane;
+    } else {
+      return_highestLanePriority = InputDiscreteLanePriority;
+      return_updateRangeEnd = InputDiscreteUpdateRangeEnd;
+      return inputDiscreteLanes;
+    }
+  }
+  const inputContinuousLanes = InputContinuousLanes & lanes;
+  if (inputContinuousLanes !== NoLanes) {
+    if (inputContinuousLanes & InputContinuousHydrationLane) {
+      return_highestLanePriority = InputContinuousHydrationLanePriority;
+      return_updateRangeEnd = InputContinuousUpdateRangeStart;
+      return InputContinuousHydrationLane;
+    } else {
+      return_highestLanePriority = InputContinuousLanePriority;
+      return_updateRangeEnd = InputContinuousUpdateRangeEnd;
+      return inputContinuousLanes;
+    }
+  }
+  const defaultLanes = DefaultLanes & lanes;
+  if (defaultLanes !== NoLanes) {
+    if (defaultLanes & DefaultHydrationLane) {
+      return_highestLanePriority = DefaultHydrationLanePriority;
+      return_updateRangeEnd = DefaultUpdateRangeStart;
+      return DefaultHydrationLane;
+    } else {
+      return_highestLanePriority = DefaultLanePriority;
+      return_updateRangeEnd = DefaultUpdateRangeEnd;
+      return defaultLanes;
+    }
+  }
+  const transitionShortLanes = TransitionShortLanes & lanes;
+  if (transitionShortLanes !== NoLanes) {
+    if (transitionShortLanes & TransitionShortHydrationLane) {
+      return_highestLanePriority = TransitionShortHydrationLanePriority;
+      return_updateRangeEnd = TransitionShortUpdateRangeStart;
+      return TransitionShortHydrationLane;
+    } else {
+      return_highestLanePriority = TransitionShortLanePriority;
+      return_updateRangeEnd = TransitionShortUpdateRangeEnd;
+      return transitionShortLanes;
+    }
+  }
+  const transitionLongLanes = TransitionLongLanes & lanes;
+  if (transitionLongLanes !== NoLanes) {
+    if (transitionLongLanes & TransitionLongHydrationLane) {
+      return_highestLanePriority = TransitionLongHydrationLanePriority;
+      return_updateRangeEnd = TransitionLongUpdateRangeStart;
+      return TransitionLongHydrationLane;
+    } else {
+      return_highestLanePriority = TransitionLongLanePriority;
+      return_updateRangeEnd = TransitionLongUpdateRangeEnd;
+      return transitionLongLanes;
+    }
+  }
+  if (lanes & SelectiveHydrationLane) {
+    return_highestLanePriority = SelectiveHydrationLanePriority;
+    return_updateRangeEnd = SelectiveHydrationRangeEnd;
+    return SelectiveHydrationLane;
+  }
+  const idleLanes = IdleLanes & lanes;
+  if (idleLanes !== NoLanes) {
+    if (idleLanes & IdleHydrationLane) {
+      return_highestLanePriority = IdleHydrationLanePriority;
+      return_updateRangeEnd = IdleUpdateRangeStart;
+      return IdleHydrationLane;
+    } else {
+      return_updateRangeEnd = IdleUpdateRangeEnd;
+      return idleLanes;
+    }
+  }
+  if ((OffscreenLane & lanes) !== NoLanes) {
+    return_highestLanePriority = OffscreenLanePriority;
+    return_updateRangeEnd = TotalLanes;
+    return OffscreenLane;
+  }
+  if (__DEV__) {
+    console.error('Should have found matching lanes. This is a bug in React.');
+  }
+  // This shouldn't be reachable, but as a fallback, return the entire bitmask.
+  return_highestLanePriority = DefaultLanePriority;
+  return_updateRangeEnd = DefaultUpdateRangeEnd;
+  return lanes;
+}
+
+export function schedulerPriorityToLanePriority(
+  schedulerPriorityLevel: ReactPriorityLevel,
+): LanePriority {
+  switch (schedulerPriorityLevel) {
+    case ImmediateSchedulerPriority:
+      return SyncLanePriority;
+    case UserBlockingSchedulerPriority:
+      return InputContinuousLanePriority;
+    case NormalSchedulerPriority:
+    case LowSchedulerPriority:
+      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
+      return DefaultLanePriority;
+    case IdleSchedulerPriority:
+      return IdleLanePriority;
+    default:
+      return NoLanePriority;
+  }
+}
+
+export function lanePriorityToSchedulerPriority(
+  lanePriority: LanePriority,
+): ReactPriorityLevel {
+  switch (lanePriority) {
+    case SyncLanePriority:
+    case SyncBatchedLanePriority:
+      return ImmediateSchedulerPriority;
+    case InputDiscreteHydrationLanePriority:
+    case InputDiscreteLanePriority:
+    case InputContinuousHydrationLanePriority:
+    case InputContinuousLanePriority:
+      return UserBlockingSchedulerPriority;
+    case DefaultHydrationLanePriority:
+    case DefaultLanePriority:
+    case TransitionShortHydrationLanePriority:
+    case TransitionShortLanePriority:
+    case TransitionLongHydrationLanePriority:
+    case TransitionLongLanePriority:
+    case SelectiveHydrationLanePriority:
+      return NormalSchedulerPriority;
+    case IdleHydrationLanePriority:
+    case IdleLanePriority:
+    case OffscreenLanePriority:
+      return IdleSchedulerPriority;
+    case NoLanePriority:
+      return NoSchedulerPriority;
+    default:
+      invariant(
+        false,
+        'Invalid update priority: %s. This is a bug in React.',
+        lanePriority,
+      );
+  }
+}
+
+export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
+  // Early bailout if there's no pending work left.
+  const pendingLanes = root.pendingLanes;
+  if (pendingLanes === NoLanes) {
+    return_highestLanePriority = NoLanePriority;
+    return NoLanes;
+  }
+
+  let nextLanes = NoLanes;
+  let nextLanePriority = NoLanePriority;
+  let equalOrHigherPriorityLanes = NoLanes;
+
+  const expiredLanes = root.expiredLanes;
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+
+  // Check if any work has expired.
+  if (expiredLanes !== NoLanes) {
+    nextLanes = expiredLanes;
+    nextLanePriority = return_highestLanePriority = SyncLanePriority;
+    equalOrHigherPriorityLanes = (getLowestPriorityLane(nextLanes) << 1) - 1;
+  } else {
+    // Do not work on any idle work until all the non-idle work has finished,
+    // even if the work is suspended.
+    const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
+    if (nonIdlePendingLanes !== NoLanes) {
+      const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
+      if (nonIdleUnblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+        equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
+      } else {
+        const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
+        if (nonIdlePingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
+          nextLanePriority = return_highestLanePriority;
+          equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
+        }
+      }
+    } else {
+      // The only remaining work is Idle.
+      const unblockedLanes = pendingLanes & ~suspendedLanes;
+      if (unblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(unblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+        equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
+      } else {
+        if (pingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(pingedLanes);
+          nextLanePriority = return_highestLanePriority;
+          equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
+        }
+      }
+    }
+  }
+
+  if (nextLanes === NoLanes) {
+    // This should only be reachable if we're suspended
+    // TODO: Consider warning in this path if a fallback timer is not scheduled.
+    return NoLanes;
+  }
+
+  // If there are higher priority lanes, we'll include them even if they
+  // are suspended.
+  nextLanes = pendingLanes & equalOrHigherPriorityLanes;
+
+  // If we're already in the middle of a render, switching lanes will interrupt
+  // it and we'll lose our progress. We should only do this if the new lanes are
+  // higher priority.
+  if (
+    wipLanes !== NoLanes &&
+    wipLanes !== nextLanes &&
+    // If we already suspended with a delay, then interrupting is fine. Don't
+    // bother waiting until the root is complete.
+    (wipLanes & suspendedLanes) === NoLanes
+  ) {
+    getHighestPriorityLanes(wipLanes);
+    const wipLanePriority = return_highestLanePriority;
+    if (nextLanePriority <= wipLanePriority) {
+      return wipLanes;
+    } else {
+      return_highestLanePriority = nextLanePriority;
+    }
+  }
+
+  return nextLanes;
+}
+
+// This returns the highest priority pending lanes regardless of whether they
+// are suspended.
+export function getHighestPriorityPendingLanes(root: FiberRoot) {
+  return getHighestPriorityLanes(root.pendingLanes);
+}
+
+export function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes {
+  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
+  if (everythingButOffscreen !== NoLanes) {
+    return everythingButOffscreen;
+  }
+  if (everythingButOffscreen & OffscreenLane) {
+    return OffscreenLane;
+  }
+  return NoLanes;
+}
+
+export function returnNextLanesPriority() {
+  return return_highestLanePriority;
+}
+export function hasUpdatePriority(lanes: Lanes) {
+  return (lanes & NonIdleLanes) !== NoLanes;
+}
+
+// To ensure consistency across multiple updates in the same event, this should
+// be a pure function, so that it always returns the same lane for given inputs.
+export function findUpdateLane(
+  lanePriority: LanePriority,
+  wipLanes: Lanes,
+): Lane {
+  switch (lanePriority) {
+    case NoLanePriority:
+      break;
+    case SyncLanePriority:
+      return SyncLane;
+    case SyncBatchedLanePriority:
+      return SyncBatchedLane;
+    case InputDiscreteLanePriority: {
+      let lane = findLane(
+        InputDiscreteUpdateRangeStart,
+        UpdateRangeEnd,
+        wipLanes,
+      );
+      if (lane === NoLane) {
+        lane = InputDiscreteHydrationLane;
+      }
+      return lane;
+    }
+    case InputContinuousLanePriority: {
+      let lane = findLane(
+        InputContinuousUpdateRangeStart,
+        UpdateRangeEnd,
+        wipLanes,
+      );
+      if (lane === NoLane) {
+        lane = InputContinuousHydrationLane;
+      }
+      return lane;
+    }
+    case DefaultLanePriority: {
+      let lane = findLane(DefaultUpdateRangeStart, UpdateRangeEnd, wipLanes);
+      if (lane === NoLane) {
+        lane = DefaultHydrationLane;
+      }
+      return lane;
+    }
+    case TransitionShortLanePriority:
+    case TransitionLongLanePriority:
+      // Should be handled by findTransitionLane instead
+      break;
+    case IdleLanePriority:
+      let lane = findLane(IdleUpdateRangeStart, IdleUpdateRangeEnd, IdleLanes);
+      if (lane === NoLane) {
+        lane = IdleHydrationLane;
+      }
+      return lane;
+    default:
+      // The remaining priorities are not valid for updates
+      break;
+  }
+  invariant(
+    false,
+    'Invalid update priority: %s. This is a bug in React.',
+    lanePriority,
+  );
+}
+
+// To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
+export function findTransitionLane(
+  lanePriority: LanePriority,
+  wipLanes: Lanes,
+  pendingLanes: Lanes,
+): Lane {
+  if (lanePriority === TransitionShortLanePriority) {
+    let lane = findLane(
+      TransitionShortUpdateRangeStart,
+      TransitionShortUpdateRangeEnd,
+      wipLanes | pendingLanes,
+    );
+    if (lane === NoLane) {
+      lane = findLane(
+        TransitionShortUpdateRangeStart,
+        TransitionShortUpdateRangeEnd,
+        wipLanes,
+      );
+      if (lane === NoLane) {
+        lane = TransitionShortHydrationLane;
+      }
+    }
+    return lane;
+  }
+  if (lanePriority === TransitionLongLanePriority) {
+    let lane = findLane(
+      TransitionLongUpdateRangeStart,
+      TransitionLongUpdateRangeEnd,
+      wipLanes | pendingLanes,
+    );
+    if (lane === NoLane) {
+      lane = findLane(
+        TransitionLongUpdateRangeStart,
+        TransitionLongUpdateRangeEnd,
+        wipLanes,
+      );
+      if (lane === NoLane) {
+        lane = TransitionLongHydrationLane;
+      }
+    }
+    return lane;
+  }
+  invariant(
+    false,
+    'Invalid transition priority: %s. This is a bug in React.',
+    lanePriority,
+  );
+}
+
+function findLane(start, end, skipLanes) {
+  // This finds the first bit between the `start` and `end` positions that isn't
+  // in `skipLanes`.
+  // TODO: This will always favor the rightmost bits. That's usually fine
+  // because any bit that's pending will be part of `skipLanes`, so we'll do our
+  // best to avoid accidental entanglement. However, lanes that are pending
+  // inside an Offscreen tree aren't considered "pending" at the root level. So
+  // they aren't included in `skipLanes`. So we should try not to favor any
+  // particular part of the range, perhaps by incrementing an offset for each
+  // distinct event. Must be the same within a single event, though.
+  const bitsInRange = ((1 << (end - start)) - 1) << start;
+  const possibleBits = bitsInRange & ~skipLanes;
+  const leastSignificantBit = possibleBits & -possibleBits;
+  return leastSignificantBit;
+}
+
+function getLowestPriorityLane(lanes: Lanes): Lane {
+  // This finds the most significant non-zero bit.
+  const index = 31 - clz32(lanes);
+  return index < 0 ? NoLanes : 1 << index;
+}
+
+export function pickArbitraryLane(lanes: Lanes): Lane {
+  return getLowestPriorityLane(lanes);
+}
+
+export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
+  return (a & b) !== NoLanes;
+}
+
+export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
+  return (set & subset) === subset;
+}
+
+export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
+  return a | b;
+}
+
+export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
+  return set & ~subset;
+}
+
+// Seems redundant, but it changes the type from a single lane (used for
+// updates) to a group of lanes (used for flushing work).
+export function laneToLanes(lane: Lane): Lanes {
+  return lane;
+}
+
+export function higherPriorityLane(a: Lane, b: Lane) {
+  // This works because the bit ranges decrease in priority as you go left.
+  return a !== NoLane && a < b ? a : b;
+}
+
+export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
+  root.pendingLanes |= updateLane;
+
+  // TODO: Theoretically, any update to any lane can unblock any other lane. But
+  // it's not practical to try every single possible combination. We need a
+  // heuristic to decide which lanes to attempt to render, and in which batches.
+  // For now, we use the same heuristic as in the old ExpirationTimes model:
+  // retry any lane at equal or lower priority, but don't try updates at higher
+  // priority without also including the lower priority updates. This works well
+  // when considering updates across different priority levels, but isn't
+  // sufficient for updates within the same priority, since we want to treat
+  // those updates as parallel.
+
+  // Unsuspend any update at equal or lower priority.
+  const higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
+  root.suspendedLanes &= higherPriorityLanes;
+  root.pingedLanes &= higherPriorityLanes;
+}
+
+export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+}
+
+export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+}
+
+export function markRootExpired(root: FiberRoot, expiredLanes: Lanes) {
+  root.expiredLanes |= expiredLanes & root.pendingLanes;
+}
+
+export function markDiscreteUpdatesExpired(root: FiberRoot) {
+  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
+}
+
+export function hasDiscreteLanes(lanes: Lanes) {
+  return (lanes & InputDiscreteLanes) !== NoLanes;
+}
+
+export function markRootMutableRead(root: FiberRoot, updateLane: Lane) {
+  root.mutableReadLanes |= updateLane & root.pendingLanes;
+}
+
+export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
+  root.pendingLanes = remainingLanes;
+
+  // Let's try everything again
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+
+  root.expiredLanes &= remainingLanes;
+  root.mutableReadLanes &= remainingLanes;
+}
+
+export function getBumpedLaneForHydration(
+  root: FiberRoot,
+  renderLanes: Lanes,
+): Lane {
+  getHighestPriorityLanes(renderLanes);
+  const highestLanePriority = return_highestLanePriority;
+
+  let lane;
+  switch (highestLanePriority) {
+    case SyncLanePriority:
+    case SyncBatchedLanePriority:
+      lane = NoLane;
+      break;
+    case InputDiscreteHydrationLanePriority:
+    case InputDiscreteLanePriority:
+      lane = InputDiscreteHydrationLane;
+      break;
+    case InputContinuousHydrationLanePriority:
+    case InputContinuousLanePriority:
+      lane = InputContinuousHydrationLane;
+      break;
+    case DefaultHydrationLanePriority:
+    case DefaultLanePriority:
+      lane = DefaultHydrationLane;
+      break;
+    case TransitionShortHydrationLanePriority:
+    case TransitionShortLanePriority:
+      lane = TransitionShortHydrationLane;
+      break;
+    case TransitionLongHydrationLanePriority:
+    case TransitionLongLanePriority:
+      lane = TransitionLongHydrationLane;
+      break;
+    case SelectiveHydrationLanePriority:
+      lane = SelectiveHydrationLane;
+      break;
+    case IdleHydrationLanePriority:
+    case IdleLanePriority:
+      lane = IdleHydrationLane;
+      break;
+    case OffscreenLanePriority:
+    case NoLanePriority:
+      lane = NoLane;
+      break;
+    default:
+      invariant(false, 'Invalid lane: %s. This is a bug in React.', lane);
+  }
+
+  // Check if the lane we chose is suspended. If so, that indicates that we
+  // already attempted and failed to hydrate at that level. Also check if we're
+  // already rendering that lane, which is rare but could happen.
+  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
+    // Give up trying to hydrate and fall back to client render.
+    return NoLane;
+  }
+
+  return lane;
+}
+
+const clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
+
+// Taken from:
+// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
+const log = Math.log;
+const LN2 = Math.LN2;
+function clz32Fallback(x) {
+  // Let n be ToUint32(x).
+  // Let p be the number of leading zero bits in
+  // the 32-bit binary representation of n.
+  // Return p.
+  const asUint = x >>> 0;
+  if (asUint === 0) {
+    return 32;
+  }
+  return (31 - ((log(asUint) / LN2) | 0)) | 0; // the "| 0" acts like math.floor
+}

commit 6edaf6f764f23043f0cd1c2da355b42f641afd8b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri May 8 12:47:51 2020 -0700

    Detect and prevent render starvation, per lane (#18864)
    
    * Detect and prevent render starvation, per lane
    
    If an update is CPU-bound for longer than expected according to its
    priority, we assume it's being starved by other work on the main thread.
    
    To detect this, we keep track of the elapsed time using a fixed-size
    array where each slot corresponds to a lane. What we actually store is
    the event time when the lane first became CPU-bound.
    
    Then, when receiving a new update or yielding to the main thread, we
    check how long each lane has been pending. If the time exceeds a
    threshold constant corresponding to its priority, we mark it as expired
    to force it to synchronously finish.
    
    We don't want to mistake time elapsed while an update is IO-bound
    (waiting for data to resolve) for time when it is CPU-bound. So when a
    lane suspends, we clear its associated event time from the array. When
    it receives a signal to try again, either a ping or an update, we assign
    a new event time to restart the clock.
    
    * Store as expiration time, not start time
    
    I originally stored the start time because I thought I could use this
    in the future to also measure Suspense timeouts. (Event times are
    currently stored on each update object for this purpose.) But that
    won't work because in the case of expiration times, we reset the clock
    whenever the update becomes IO-bound. So to replace the per-update
    field, I'm going to have to track those on the room separately from
    expiration times.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 65d35d7640..68c3afbd54 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -29,6 +29,7 @@ export opaque type LanePriority =
   | 16;
 export opaque type Lanes = number;
 export opaque type Lane = number;
+export opaque type LaneMap<T> = Array<T>;
 
 import invariant from 'shared/invariant';
 
@@ -66,7 +67,7 @@ const IdleLanePriority: LanePriority = 2;
 
 const OffscreenLanePriority: LanePriority = 1;
 
-const NoLanePriority: LanePriority = 0;
+export const NoLanePriority: LanePriority = 0;
 
 const TotalLanes = 31;
 
@@ -117,6 +118,8 @@ const IdleUpdateRangeEnd = 30;
 
 export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
 
+export const NoTimestamp = -1;
+
 // "Registers" used to "return" multiple values
 // Used by getHighestPriorityLanes and getNextLanes:
 let return_highestLanePriority: LanePriority = DefaultLanePriority;
@@ -365,6 +368,63 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   return nextLanes;
 }
 
+function computeExpirationTime(lane: Lane, currentTime: number) {
+  // TODO: Expiration heuristic is constant per lane, so could use a map.
+  getHighestPriorityLanes(lane);
+  const priority = return_highestLanePriority;
+  if (priority >= InputContinuousLanePriority) {
+    // User interactions should expire slightly more quickly.
+    return currentTime + 1000;
+  } else if (priority >= TransitionLongLanePriority) {
+    return currentTime + 5000;
+  } else {
+    // Anything idle priority or lower should never expire.
+    return NoTimestamp;
+  }
+}
+
+export function markStarvedLanesAsExpired(
+  root: FiberRoot,
+  currentTime: number,
+): void {
+  // TODO: This gets called every time we yield. We can optimize by storing
+  // the earliest expiration time on the root. Then use that to quickly bail out
+  // of this function.
+
+  const pendingLanes = root.pendingLanes;
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+  const expirationTimes = root.expirationTimes;
+
+  // Iterate through the pending lanes and check if we've reached their
+  // expiration time. If so, we'll assume the update is being starved and mark
+  // it as expired to force it to finish.
+  let lanes = pendingLanes;
+  while (lanes > 0) {
+    const index = ctrz(lanes);
+    const lane = 1 << index;
+
+    const expirationTime = expirationTimes[index];
+    if (expirationTime === NoTimestamp) {
+      // Found a pending lane with no expiration time. If it's not suspended, or
+      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
+      // using the current time.
+      if (
+        (lane & suspendedLanes) === NoLanes ||
+        (lane & pingedLanes) !== NoLanes
+      ) {
+        // Assumes timestamps are monotonically increasing.
+        expirationTimes[index] = computeExpirationTime(lane, currentTime);
+      }
+    } else if (expirationTime <= currentTime) {
+      // This lane expired
+      root.expiredLanes |= lane;
+    }
+
+    lanes &= ~lane;
+  }
+}
+
 // This returns the highest priority pending lanes regardless of whether they
 // are suspended.
 export function getHighestPriorityPendingLanes(root: FiberRoot) {
@@ -555,6 +615,10 @@ export function higherPriorityLane(a: Lane, b: Lane) {
   return a !== NoLane && a < b ? a : b;
 }
 
+export function createLaneMap<T>(initial: T): LaneMap<T> {
+  return new Array(TotalLanes).fill(initial);
+}
+
 export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
   root.pendingLanes |= updateLane;
 
@@ -570,6 +634,7 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
 
   // Unsuspend any update at equal or lower priority.
   const higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
+
   root.suspendedLanes &= higherPriorityLanes;
   root.pingedLanes &= higherPriorityLanes;
 }
@@ -577,9 +642,25 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
 export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
+
+  // The suspended lanes are no longer CPU-bound. Clear their expiration times.
+  const expirationTimes = root.expirationTimes;
+  let lanes = suspendedLanes;
+  while (lanes > 0) {
+    const index = ctrz(lanes);
+    const lane = 1 << index;
+
+    expirationTimes[index] = NoTimestamp;
+
+    lanes &= ~lane;
+  }
 }
 
-export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
+export function markRootPinged(
+  root: FiberRoot,
+  pingedLanes: Lanes,
+  eventTime: number,
+) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
 }
 
@@ -600,6 +681,8 @@ export function markRootMutableRead(root: FiberRoot, updateLane: Lane) {
 }
 
 export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
+  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
+
   root.pendingLanes = remainingLanes;
 
   // Let's try everything again
@@ -608,6 +691,18 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
 
   root.expiredLanes &= remainingLanes;
   root.mutableReadLanes &= remainingLanes;
+
+  const expirationTimes = root.expirationTimes;
+  let lanes = noLongerPendingLanes;
+  while (lanes > 0) {
+    const index = ctrz(lanes);
+    const lane = 1 << index;
+
+    // Clear the expiration time
+    expirationTimes[index] = -1;
+
+    lanes &= ~lane;
+  }
 }
 
 export function getBumpedLaneForHydration(
@@ -671,18 +766,25 @@ export function getBumpedLaneForHydration(
 
 const clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
 
-// Taken from:
+// Count leading zeros. Only used on lanes, so assume input is an integer.
+// Based on:
 // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
 const log = Math.log;
 const LN2 = Math.LN2;
-function clz32Fallback(x) {
-  // Let n be ToUint32(x).
-  // Let p be the number of leading zero bits in
-  // the 32-bit binary representation of n.
-  // Return p.
-  const asUint = x >>> 0;
-  if (asUint === 0) {
+function clz32Fallback(lanes: Lanes | Lane) {
+  if (lanes === 0) {
     return 32;
   }
-  return (31 - ((log(asUint) / LN2) | 0)) | 0; // the "| 0" acts like math.floor
+  return (31 - ((log(lanes) / LN2) | 0)) | 0;
+}
+
+// Count trailing zeros. Only used on lanes, so assume input is an integer.
+function ctrz(lanes: Lanes | Lane) {
+  let bits = lanes;
+  bits |= bits << 16;
+  bits |= bits << 8;
+  bits |= bits << 4;
+  bits |= bits << 2;
+  bits |= bits << 1;
+  return 32 - clz32(~bits);
 }

commit 33589f7423fa498c97001898af730c461a1fdc7d
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 13 11:33:32 2020 -0700

    useMutableSource: "Entangle" instead of expiring (#18889)
    
    * useMutableSource: "Entangle" instead of expiring
    
    A lane is said to be entangled with another when it's not allowed to
    render in a batch that does not also include the other lane.
    
    This commit implements entanglement for `useMutableSource`. If a source
    is mutated in between when it's read in the render phase, but before
    it's subscribed to in the commit phase, we must account for whether the
    same source has pending mutations elsewhere. The old subscriptions must
    not be allowed to re-render without also including the new subscription
    (and vice versa), to prevent tearing.
    
    In the old reconciler, we did this by synchronously flushing all the
    pending subscription updates. This works, but isn't ideal. The new
    reconciler can entangle the updates without de-opting to sync.
    
    In the future, we plan to use this same mechanism for other features,
    like skipping over intermediate useTransition states.
    
    * Use clz instead of ctrz to pick an arbitrary lane
    
    Should be slightly faster since most engines have built-in support.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 68c3afbd54..d107913e10 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -365,6 +365,37 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
     }
   }
 
+  // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  //
+  // For those exceptions where entanglement is semantically important, like
+  // useMutableSource, we should ensure that there is no partial work at the
+  // time we apply the entanglement.
+  const entangledLanes = root.entangledLanes;
+  if (entangledLanes !== NoLanes) {
+    const entanglements = root.entanglements;
+    let lanes = nextLanes & entangledLanes;
+    while (lanes > 0) {
+      const index = pickArbitraryLaneIndex(lanes);
+      const lane = 1 << index;
+
+      nextLanes |= entanglements[index];
+
+      lanes &= ~lane;
+    }
+  }
+
   return nextLanes;
 }
 
@@ -401,7 +432,7 @@ export function markStarvedLanesAsExpired(
   // it as expired to force it to finish.
   let lanes = pendingLanes;
   while (lanes > 0) {
-    const index = ctrz(lanes);
+    const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
 
     const expirationTime = expirationTimes[index];
@@ -588,6 +619,10 @@ export function pickArbitraryLane(lanes: Lanes): Lane {
   return getLowestPriorityLane(lanes);
 }
 
+function pickArbitraryLaneIndex(lanes: Lane | Lanes) {
+  return 31 - clz32(lanes);
+}
+
 export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
   return (a & b) !== NoLanes;
 }
@@ -647,7 +682,7 @@ export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
   const expirationTimes = root.expirationTimes;
   let lanes = suspendedLanes;
   while (lanes > 0) {
-    const index = ctrz(lanes);
+    const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
 
     expirationTimes[index] = NoTimestamp;
@@ -692,10 +727,12 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   root.expiredLanes &= remainingLanes;
   root.mutableReadLanes &= remainingLanes;
 
+  root.entangledLanes &= remainingLanes;
+
   const expirationTimes = root.expirationTimes;
   let lanes = noLongerPendingLanes;
   while (lanes > 0) {
-    const index = ctrz(lanes);
+    const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
 
     // Clear the expiration time
@@ -705,6 +742,21 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   }
 }
 
+export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
+  root.entangledLanes |= entangledLanes;
+
+  const entanglements = root.entanglements;
+  let lanes = entangledLanes;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    entanglements[index] |= entangledLanes;
+
+    lanes &= ~lane;
+  }
+}
+
 export function getBumpedLaneForHydration(
   root: FiberRoot,
   renderLanes: Lanes,
@@ -777,14 +829,3 @@ function clz32Fallback(lanes: Lanes | Lane) {
   }
   return (31 - ((log(lanes) / LN2) | 0)) | 0;
 }
-
-// Count trailing zeros. Only used on lanes, so assume input is an integer.
-function ctrz(lanes: Lanes | Lane) {
-  let bits = lanes;
-  bits |= bits << 16;
-  bits |= bits << 8;
-  bits |= bits << 4;
-  bits |= bits << 2;
-  bits |= bits << 1;
-  return 32 - clz32(~bits);
-}

commit 18de3b6e7c8a93289d9df67339d876bba6ff3e0c
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue May 26 18:53:50 2020 -0700

    Bug: Spawning hydration in response to Idle update (#19011)
    
    * Bug: Spawning hydration in response to Idle update
    
    Adds a test that fails in the new fork.
    
    * Fix typos related to Idle priority
    
    These are just silly mistakes that weren't caught by any of our tests.
    
    There's a lot of duplication in the Lanes module right now. It's also
    not super stable as we continue to refine our heuristics. Hopefully the
    final state is simpler and less prone to these types of mistakes.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index d107913e10..72a6b015f3 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -208,6 +208,7 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return_updateRangeEnd = IdleUpdateRangeStart;
       return IdleHydrationLane;
     } else {
+      return_highestLanePriority = IdleLanePriority;
       return_updateRangeEnd = IdleUpdateRangeEnd;
       return idleLanes;
     }
@@ -527,7 +528,7 @@ export function findUpdateLane(
       // Should be handled by findTransitionLane instead
       break;
     case IdleLanePriority:
-      let lane = findLane(IdleUpdateRangeStart, IdleUpdateRangeEnd, IdleLanes);
+      let lane = findLane(IdleUpdateRangeStart, IdleUpdateRangeEnd, wipLanes);
       if (lane === NoLane) {
         lane = IdleHydrationLane;
       }

commit ffe516f3bf57a13e123411a9ca76b48915a00acb
Author: Chen Gang <gangc.cxy@foxmail.com>
Date:   Wed Jun 24 04:28:24 2020 +0800

    use NoTimestamp instead of -1 (#19182)

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 72a6b015f3..eae1194836 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -737,7 +737,7 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
     const lane = 1 << index;
 
     // Clear the expiration time
-    expirationTimes[index] = -1;
+    expirationTimes[index] = NoTimestamp;
 
     lanes &= ~lane;
   }

commit 91a2e8173f1fadd2dfd4b12753ebcdc60986d42d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jul 6 18:53:42 2020 -0400

    Decouple update priority tracking from Scheduler package (#19121)
    
    * Initial currentLanePriority implementation
    
    * Minor updates from review
    
    * Fix typos and enable flag
    
    * Fix feature flags and lint
    
    * Fix simple event tests by switching to withSuspenseConfig
    
    * Don't lower the priority of setPending in startTransition below InputContinuous
    
    * Move currentUpdateLanePriority in commit root into the first effect block
    
    * Refactor requestUpdateLane to log for priority mismatches
    
    Also verifies that the update lane priority matches the scheduler lane priority before using it
    
    * Fix four tests by adding ReactDOM.unstable_runWithPriority
    
    * Fix partial hydration when using update lane priority
    
    * Fix partial hydration when using update lane priority
    
    * Rename feature flag and only log for now
    
    * Move unstable_runWithPriority to ReactFiberReconciler
    
    * Add unstable_runWithPriority to ReactNoopPersistent too
    
    * Bug fixes and performance improvements
    
    * Initial currentLanePriority implementation
    
    * Minor updates from review
    
    * Fix typos and enable flag
    
    * Remove higherLanePriority from ReactDOMEventReplaying.js
    
    * Change warning implementation and startTransition update lane priority
    
    * Inject reconciler functions to avoid importing src/
    
    * Fix feature flags and lint
    
    * Fix simple event tests by switching to withSuspenseConfig
    
    * Don't lower the priority of setPending in startTransition below InputContinuous
    
    * Move currentUpdateLanePriority in commit root into the first effect block
    
    * Refactor requestUpdateLane to log for priority mismatches
    
    Also verifies that the update lane priority matches the scheduler lane priority before using it
    
    * Fix four tests by adding ReactDOM.unstable_runWithPriority
    
    * Fix partial hydration when using update lane priority
    
    * Fix partial hydration when using update lane priority
    
    * Rename feature flag and only log for now
    
    * Move unstable_runWithPriority to ReactFiberReconciler
    
    * Bug fixes and performance improvements
    
    * Remove higherLanePriority from ReactDOMEventReplaying.js
    
    * Change warning implementation and startTransition update lane priority
    
    * Inject reconciler functions to avoid importing src/
    
    * Fixes from bad rebase

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index eae1194836..843582cd9d 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -49,10 +49,10 @@ const InputDiscreteHydrationLanePriority: LanePriority = 14;
 export const InputDiscreteLanePriority: LanePriority = 13;
 
 const InputContinuousHydrationLanePriority: LanePriority = 12;
-const InputContinuousLanePriority: LanePriority = 11;
+export const InputContinuousLanePriority: LanePriority = 11;
 
 const DefaultHydrationLanePriority: LanePriority = 10;
-const DefaultLanePriority: LanePriority = 9;
+export const DefaultLanePriority: LanePriority = 9;
 
 const TransitionShortHydrationLanePriority: LanePriority = 8;
 export const TransitionShortLanePriority: LanePriority = 7;
@@ -120,6 +120,16 @@ export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000
 
 export const NoTimestamp = -1;
 
+let currentUpdateLanePriority: LanePriority = NoLanePriority;
+
+export function getCurrentUpdateLanePriority(): LanePriority {
+  return currentUpdateLanePriority;
+}
+
+export function setCurrentUpdateLanePriority(newLanePriority: LanePriority) {
+  currentUpdateLanePriority = newLanePriority;
+}
+
 // "Registers" used to "return" multiple values
 // Used by getHighestPriorityLanes and getNextLanes:
 let return_highestLanePriority: LanePriority = DefaultLanePriority;
@@ -651,6 +661,13 @@ export function higherPriorityLane(a: Lane, b: Lane) {
   return a !== NoLane && a < b ? a : b;
 }
 
+export function higherLanePriority(
+  a: LanePriority,
+  b: LanePriority,
+): LanePriority {
+  return a !== NoLanePriority && a > b ? a : b;
+}
+
 export function createLaneMap<T>(initial: T): LaneMap<T> {
   return new Array(TotalLanes).fill(initial);
 }

commit 965d08cfff50609eed5d3f2317145f7be762423d
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Jul 8 23:09:22 2020 -0500

    Add dedicated LanePriority for Suspense retries (#19287)
    
    A "retry" is a special type of update that attempts to flip a Suspense
    boundary from its placeholder state back to its primary/resolved state.
    
    Currently, retries are given default priority, using the same algorithm
    as normal updates and occupying range of lanes.
    
    This adds a new range of lanes dedicated specifically to retries, and
    gives them lower priority than normal updates.
    
    A couple of existing tests were affected because retries are no longer
    batched with normal updates; they commit in separate batches.
    
    Not totally satisfied with this design, but I think things will snap more
    into place once the rest of the Lanes changes (like how we handle
    parallel Suspense transitions) have settled.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 843582cd9d..8e2617cfa6 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -26,7 +26,8 @@ export opaque type LanePriority =
   | 13
   | 14
   | 15
-  | 16;
+  | 16
+  | 17;
 export opaque type Lanes = number;
 export opaque type Lane = number;
 export opaque type LaneMap<T> = Array<T>;
@@ -42,23 +43,25 @@ import {
   NoPriority as NoSchedulerPriority,
 } from './SchedulerWithReactIntegration.new';
 
-export const SyncLanePriority: LanePriority = 16;
-const SyncBatchedLanePriority: LanePriority = 15;
+export const SyncLanePriority: LanePriority = 17;
+const SyncBatchedLanePriority: LanePriority = 16;
 
-const InputDiscreteHydrationLanePriority: LanePriority = 14;
-export const InputDiscreteLanePriority: LanePriority = 13;
+const InputDiscreteHydrationLanePriority: LanePriority = 15;
+export const InputDiscreteLanePriority: LanePriority = 14;
 
-const InputContinuousHydrationLanePriority: LanePriority = 12;
-export const InputContinuousLanePriority: LanePriority = 11;
+const InputContinuousHydrationLanePriority: LanePriority = 13;
+export const InputContinuousLanePriority: LanePriority = 12;
 
-const DefaultHydrationLanePriority: LanePriority = 10;
-export const DefaultLanePriority: LanePriority = 9;
+const DefaultHydrationLanePriority: LanePriority = 11;
+export const DefaultLanePriority: LanePriority = 10;
 
-const TransitionShortHydrationLanePriority: LanePriority = 8;
-export const TransitionShortLanePriority: LanePriority = 7;
+const TransitionShortHydrationLanePriority: LanePriority = 9;
+export const TransitionShortLanePriority: LanePriority = 8;
 
-const TransitionLongHydrationLanePriority: LanePriority = 6;
-export const TransitionLongLanePriority: LanePriority = 5;
+const TransitionLongHydrationLanePriority: LanePriority = 7;
+export const TransitionLongLanePriority: LanePriority = 6;
+
+const RetryLanePriority: LanePriority = 5;
 
 const SelectiveHydrationLanePriority: LanePriority = 4;
 
@@ -90,25 +93,30 @@ const InputContinuousUpdateRangeStart = 6;
 const InputContinuousUpdateRangeEnd = 8;
 
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
-const DefaultLanes: Lanes = /*                          */ 0b0000000000000000011111100000000;
+export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111100000000;
 const DefaultUpdateRangeStart = 9;
-const DefaultUpdateRangeEnd = 14;
+const DefaultUpdateRangeEnd = 12;
+
+const TransitionShortHydrationLane: Lane = /*           */ 0b0000000000000000001000000000000;
+const TransitionShortLanes: Lanes = /*                  */ 0b0000000000000011111000000000000;
+const TransitionShortUpdateRangeStart = 13;
+const TransitionShortUpdateRangeEnd = 17;
 
-const TransitionShortHydrationLane: Lane = /*           */ 0b0000000000000000100000000000000;
-const TransitionShortLanes: Lanes = /*                  */ 0b0000000000011111100000000000000;
-const TransitionShortUpdateRangeStart = 15;
-const TransitionShortUpdateRangeEnd = 20;
+const TransitionLongHydrationLane: Lane = /*            */ 0b0000000000000100000000000000000;
+const TransitionLongLanes: Lanes = /*                   */ 0b0000000001111100000000000000000;
+const TransitionLongUpdateRangeStart = 18;
+const TransitionLongUpdateRangeEnd = 22;
 
-const TransitionLongHydrationLane: Lane = /*            */ 0b0000000000100000000000000000000;
-const TransitionLongLanes: Lanes = /*                   */ 0b0000011111100000000000000000000;
-const TransitionLongUpdateRangeStart = 21;
-const TransitionLongUpdateRangeEnd = 26;
+// Includes all updates. Except Idle updates, which have special semantics.
+const UpdateRangeEnd = TransitionLongUpdateRangeEnd;
 
-export const SelectiveHydrationLane: Lane = /*          */ 0b0000110000000000000000000000000;
+const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
+const RetryRangeStart = 22;
+const RetryRangeEnd = 26;
+
+export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
 const SelectiveHydrationRangeEnd = 27;
 
-// Includes all non-Idle updates
-const UpdateRangeEnd = 27;
 const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;
 
 export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
@@ -206,6 +214,12 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return transitionLongLanes;
     }
   }
+  const retryLanes = RetryLanes & lanes;
+  if (retryLanes !== NoLanes) {
+    return_highestLanePriority = RetryLanePriority;
+    return_updateRangeEnd = RetryRangeEnd;
+    return retryLanes;
+  }
   if (lanes & SelectiveHydrationLane) {
     return_highestLanePriority = SelectiveHydrationLanePriority;
     return_updateRangeEnd = SelectiveHydrationRangeEnd;
@@ -275,6 +289,7 @@ export function lanePriorityToSchedulerPriority(
     case TransitionLongHydrationLanePriority:
     case TransitionLongLanePriority:
     case SelectiveHydrationLanePriority:
+    case RetryLanePriority:
       return NormalSchedulerPriority;
     case IdleHydrationLanePriority:
     case IdleLanePriority:
@@ -537,6 +552,9 @@ export function findUpdateLane(
     case TransitionLongLanePriority:
       // Should be handled by findTransitionLane instead
       break;
+    case RetryLanePriority:
+      // Should be handled by findRetryLane instead
+      break;
     case IdleLanePriority:
       let lane = findLane(IdleUpdateRangeStart, IdleUpdateRangeEnd, wipLanes);
       if (lane === NoLane) {
@@ -604,6 +622,19 @@ export function findTransitionLane(
   );
 }
 
+// To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
+export function findRetryLane(wipLanes: Lanes): Lane {
+  // This is a fork of `findUpdateLane` designed specifically for Suspense
+  // "retries" — a special update that attempts to flip a Suspense boundary
+  // from its placeholder state to its primary/resolved state.
+  let lane = findLane(RetryRangeStart, RetryRangeEnd, wipLanes);
+  if (lane === NoLane) {
+    lane = pickArbitraryLane(RetryLanes);
+  }
+  return lane;
+}
+
 function findLane(start, end, skipLanes) {
   // This finds the first bit between the `start` and `end` positions that isn't
   // in `skipLanes`.
@@ -808,6 +839,11 @@ export function getBumpedLaneForHydration(
     case TransitionLongLanePriority:
       lane = TransitionLongHydrationLane;
       break;
+    case RetryLanePriority:
+      // Shouldn't be reachable under normal circumstances, so there's no
+      // dedicated lane for retry priority. Use the one for long transitions.
+      lane = TransitionLongHydrationLane;
+      break;
     case SelectiveHydrationLanePriority:
       lane = SelectiveHydrationLane;
       break;

commit 14084be286d09df49d5410c751bc28f0180a54b2
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jul 9 18:53:54 2020 -0500

    Refactor algorithm for next Lanes to work on (#19302)
    
    Some clean up to make the Lanes type easier to maintain.
    
    I removed the "start" and "end" range markers; they don't provide any
    information that isn't already encoded in the bitmask for each range,
    and there's no computation saved compared to the
    `pickArbitraryLane` function.
    
    The overall algorithm is largely the same but I did tweak some of the
    details. For example, if the lanes for a given priority are already
    being worked on, the previous algorithm would assign to the next
    available lane, including the dedicated hydration lanes that exist
    in between each priority.
    
    The updated algorithm skips over the hydration lanes and goes to the
    next priority level. In the rare instance when all the non-Idle update
    lanes are occupied, it will pick an abitrary default lane. This will
    have the effect of invalidating the current work-in-progress, and
    indicates a starvation scenario.
    
    Eventually, if there are too many interruptions, the expiration time
    mechanism will kick in and force the update to synchronously finish.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 8e2617cfa6..602c99f882 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -78,51 +78,31 @@ export const NoLanes: Lanes = /*                        */ 0b0000000000000000000
 export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
 
 export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
-const SyncUpdateRangeEnd = 1;
 export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;
-const SyncBatchedUpdateRangeEnd = 2;
 
 export const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;
-const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011100;
-const InputDiscreteUpdateRangeStart = 3;
-const InputDiscreteUpdateRangeEnd = 5;
+const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;
 
 const InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;
-const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011100000;
-const InputContinuousUpdateRangeStart = 6;
-const InputContinuousUpdateRangeEnd = 8;
+const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;
 
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
-export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111100000000;
-const DefaultUpdateRangeStart = 9;
-const DefaultUpdateRangeEnd = 12;
+export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;
 
 const TransitionShortHydrationLane: Lane = /*           */ 0b0000000000000000001000000000000;
-const TransitionShortLanes: Lanes = /*                  */ 0b0000000000000011111000000000000;
-const TransitionShortUpdateRangeStart = 13;
-const TransitionShortUpdateRangeEnd = 17;
+const TransitionShortLanes: Lanes = /*                  */ 0b0000000000000011110000000000000;
 
 const TransitionLongHydrationLane: Lane = /*            */ 0b0000000000000100000000000000000;
-const TransitionLongLanes: Lanes = /*                   */ 0b0000000001111100000000000000000;
-const TransitionLongUpdateRangeStart = 18;
-const TransitionLongUpdateRangeEnd = 22;
-
-// Includes all updates. Except Idle updates, which have special semantics.
-const UpdateRangeEnd = TransitionLongUpdateRangeEnd;
+const TransitionLongLanes: Lanes = /*                   */ 0b0000000001111000000000000000000;
 
 const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
-const RetryRangeStart = 22;
-const RetryRangeEnd = 26;
 
 export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
-const SelectiveHydrationRangeEnd = 27;
 
 const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;
 
 export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
-const IdleLanes: Lanes = /*                             */ 0b0111000000000000000000000000000;
-const IdleUpdateRangeStart = 28;
-const IdleUpdateRangeEnd = 30;
+const IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;
 
 export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
 
@@ -141,105 +121,81 @@ export function setCurrentUpdateLanePriority(newLanePriority: LanePriority) {
 // "Registers" used to "return" multiple values
 // Used by getHighestPriorityLanes and getNextLanes:
 let return_highestLanePriority: LanePriority = DefaultLanePriority;
-let return_updateRangeEnd: number = -1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   if ((SyncLane & lanes) !== NoLanes) {
     return_highestLanePriority = SyncLanePriority;
-    return_updateRangeEnd = SyncUpdateRangeEnd;
     return SyncLane;
   }
   if ((SyncBatchedLane & lanes) !== NoLanes) {
     return_highestLanePriority = SyncBatchedLanePriority;
-    return_updateRangeEnd = SyncBatchedUpdateRangeEnd;
     return SyncBatchedLane;
   }
+  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
+    return_highestLanePriority = InputDiscreteHydrationLanePriority;
+    return InputDiscreteHydrationLane;
+  }
   const inputDiscreteLanes = InputDiscreteLanes & lanes;
   if (inputDiscreteLanes !== NoLanes) {
-    if (inputDiscreteLanes & InputDiscreteHydrationLane) {
-      return_highestLanePriority = InputDiscreteHydrationLanePriority;
-      return_updateRangeEnd = InputDiscreteUpdateRangeStart;
-      return InputDiscreteHydrationLane;
-    } else {
-      return_highestLanePriority = InputDiscreteLanePriority;
-      return_updateRangeEnd = InputDiscreteUpdateRangeEnd;
-      return inputDiscreteLanes;
-    }
+    return_highestLanePriority = InputDiscreteLanePriority;
+    return inputDiscreteLanes;
+  }
+  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
+    return_highestLanePriority = InputContinuousHydrationLanePriority;
+    return InputContinuousHydrationLane;
   }
   const inputContinuousLanes = InputContinuousLanes & lanes;
   if (inputContinuousLanes !== NoLanes) {
-    if (inputContinuousLanes & InputContinuousHydrationLane) {
-      return_highestLanePriority = InputContinuousHydrationLanePriority;
-      return_updateRangeEnd = InputContinuousUpdateRangeStart;
-      return InputContinuousHydrationLane;
-    } else {
-      return_highestLanePriority = InputContinuousLanePriority;
-      return_updateRangeEnd = InputContinuousUpdateRangeEnd;
-      return inputContinuousLanes;
-    }
+    return_highestLanePriority = InputContinuousLanePriority;
+    return inputContinuousLanes;
+  }
+  if ((lanes & DefaultHydrationLane) !== NoLanes) {
+    return_highestLanePriority = DefaultHydrationLanePriority;
+    return DefaultHydrationLane;
   }
   const defaultLanes = DefaultLanes & lanes;
   if (defaultLanes !== NoLanes) {
-    if (defaultLanes & DefaultHydrationLane) {
-      return_highestLanePriority = DefaultHydrationLanePriority;
-      return_updateRangeEnd = DefaultUpdateRangeStart;
-      return DefaultHydrationLane;
-    } else {
-      return_highestLanePriority = DefaultLanePriority;
-      return_updateRangeEnd = DefaultUpdateRangeEnd;
-      return defaultLanes;
-    }
+    return_highestLanePriority = DefaultLanePriority;
+    return defaultLanes;
+  }
+  if ((lanes & TransitionShortHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionShortHydrationLanePriority;
+    return TransitionShortHydrationLane;
   }
   const transitionShortLanes = TransitionShortLanes & lanes;
   if (transitionShortLanes !== NoLanes) {
-    if (transitionShortLanes & TransitionShortHydrationLane) {
-      return_highestLanePriority = TransitionShortHydrationLanePriority;
-      return_updateRangeEnd = TransitionShortUpdateRangeStart;
-      return TransitionShortHydrationLane;
-    } else {
-      return_highestLanePriority = TransitionShortLanePriority;
-      return_updateRangeEnd = TransitionShortUpdateRangeEnd;
-      return transitionShortLanes;
-    }
+    return_highestLanePriority = TransitionShortLanePriority;
+    return transitionShortLanes;
+  }
+  if ((lanes & TransitionLongHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionLongHydrationLanePriority;
+    return TransitionLongHydrationLane;
   }
   const transitionLongLanes = TransitionLongLanes & lanes;
   if (transitionLongLanes !== NoLanes) {
-    if (transitionLongLanes & TransitionLongHydrationLane) {
-      return_highestLanePriority = TransitionLongHydrationLanePriority;
-      return_updateRangeEnd = TransitionLongUpdateRangeStart;
-      return TransitionLongHydrationLane;
-    } else {
-      return_highestLanePriority = TransitionLongLanePriority;
-      return_updateRangeEnd = TransitionLongUpdateRangeEnd;
-      return transitionLongLanes;
-    }
+    return_highestLanePriority = TransitionLongLanePriority;
+    return transitionLongLanes;
   }
   const retryLanes = RetryLanes & lanes;
   if (retryLanes !== NoLanes) {
     return_highestLanePriority = RetryLanePriority;
-    return_updateRangeEnd = RetryRangeEnd;
     return retryLanes;
   }
   if (lanes & SelectiveHydrationLane) {
     return_highestLanePriority = SelectiveHydrationLanePriority;
-    return_updateRangeEnd = SelectiveHydrationRangeEnd;
     return SelectiveHydrationLane;
   }
+  if ((lanes & IdleHydrationLane) !== NoLanes) {
+    return_highestLanePriority = IdleHydrationLanePriority;
+    return IdleHydrationLane;
+  }
   const idleLanes = IdleLanes & lanes;
   if (idleLanes !== NoLanes) {
-    if (idleLanes & IdleHydrationLane) {
-      return_highestLanePriority = IdleHydrationLanePriority;
-      return_updateRangeEnd = IdleUpdateRangeStart;
-      return IdleHydrationLane;
-    } else {
-      return_highestLanePriority = IdleLanePriority;
-      return_updateRangeEnd = IdleUpdateRangeEnd;
-      return idleLanes;
-    }
+    return_highestLanePriority = IdleLanePriority;
+    return idleLanes;
   }
   if ((OffscreenLane & lanes) !== NoLanes) {
     return_highestLanePriority = OffscreenLanePriority;
-    return_updateRangeEnd = TotalLanes;
     return OffscreenLane;
   }
   if (__DEV__) {
@@ -247,7 +203,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   }
   // This shouldn't be reachable, but as a fallback, return the entire bitmask.
   return_highestLanePriority = DefaultLanePriority;
-  return_updateRangeEnd = DefaultUpdateRangeEnd;
   return lanes;
 }
 
@@ -316,7 +271,6 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
 
   let nextLanes = NoLanes;
   let nextLanePriority = NoLanePriority;
-  let equalOrHigherPriorityLanes = NoLanes;
 
   const expiredLanes = root.expiredLanes;
   const suspendedLanes = root.suspendedLanes;
@@ -326,7 +280,6 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   if (expiredLanes !== NoLanes) {
     nextLanes = expiredLanes;
     nextLanePriority = return_highestLanePriority = SyncLanePriority;
-    equalOrHigherPriorityLanes = (getLowestPriorityLane(nextLanes) << 1) - 1;
   } else {
     // Do not work on any idle work until all the non-idle work has finished,
     // even if the work is suspended.
@@ -336,13 +289,11 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (nonIdleUnblockedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
         nextLanePriority = return_highestLanePriority;
-        equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
       } else {
         const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
         if (nonIdlePingedLanes !== NoLanes) {
           nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
           nextLanePriority = return_highestLanePriority;
-          equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
         }
       }
     } else {
@@ -351,12 +302,10 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (unblockedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(unblockedLanes);
         nextLanePriority = return_highestLanePriority;
-        equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
       } else {
         if (pingedLanes !== NoLanes) {
           nextLanes = getHighestPriorityLanes(pingedLanes);
           nextLanePriority = return_highestLanePriority;
-          equalOrHigherPriorityLanes = (1 << return_updateRangeEnd) - 1;
         }
       }
     }
@@ -370,7 +319,7 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
 
   // If there are higher priority lanes, we'll include them even if they
   // are suspended.
-  nextLanes = pendingLanes & equalOrHigherPriorityLanes;
+  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
 
   // If we're already in the middle of a render, switching lanes will interrupt
   // it and we'll lose our progress. We should only do this if the new lanes are
@@ -520,45 +469,46 @@ export function findUpdateLane(
     case SyncBatchedLanePriority:
       return SyncBatchedLane;
     case InputDiscreteLanePriority: {
-      let lane = findLane(
-        InputDiscreteUpdateRangeStart,
-        UpdateRangeEnd,
-        wipLanes,
-      );
+      const lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = InputDiscreteHydrationLane;
+        // Shift to the next priority level
+        return findUpdateLane(InputContinuousLanePriority, wipLanes);
       }
       return lane;
     }
     case InputContinuousLanePriority: {
-      let lane = findLane(
-        InputContinuousUpdateRangeStart,
-        UpdateRangeEnd,
-        wipLanes,
-      );
+      const lane = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = InputContinuousHydrationLane;
+        // Shift to the next priority level
+        return findUpdateLane(DefaultLanePriority, wipLanes);
       }
       return lane;
     }
     case DefaultLanePriority: {
-      let lane = findLane(DefaultUpdateRangeStart, UpdateRangeEnd, wipLanes);
+      let lane = pickArbitraryLane(DefaultLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = DefaultHydrationLane;
+        // If all the default lanes are already being worked on, look for a
+        // lane in the transition range.
+        lane = pickArbitraryLane(
+          (TransitionShortLanes | TransitionLongLanes) & ~wipLanes,
+        );
+        if (lane === NoLane) {
+          // All the transition lanes are taken, too. This should be very
+          // rare, but as a last resort, pick a default lane. This will have
+          // the effect of interrupting the current work-in-progress render.
+          lane = pickArbitraryLane(DefaultLanes);
+        }
       }
       return lane;
     }
-    case TransitionShortLanePriority:
+    case TransitionShortLanePriority: // Should be handled by findTransitionLane instead
     case TransitionLongLanePriority:
-      // Should be handled by findTransitionLane instead
-      break;
-    case RetryLanePriority:
-      // Should be handled by findRetryLane instead
+    case RetryLanePriority: // Should be handled by findRetryLane instead
       break;
     case IdleLanePriority:
-      let lane = findLane(IdleUpdateRangeStart, IdleUpdateRangeEnd, wipLanes);
+      let lane = pickArbitraryLane(IdleLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = IdleHydrationLane;
+        lane = pickArbitraryLane(IdleLanes);
       }
       return lane;
     default:
@@ -580,37 +530,33 @@ export function findTransitionLane(
   pendingLanes: Lanes,
 ): Lane {
   if (lanePriority === TransitionShortLanePriority) {
-    let lane = findLane(
-      TransitionShortUpdateRangeStart,
-      TransitionShortUpdateRangeEnd,
-      wipLanes | pendingLanes,
-    );
+    // First look for lanes that are completely unclaimed, i.e. have no
+    // pending work.
+    let lane = pickArbitraryLane(TransitionShortLanes & ~pendingLanes);
     if (lane === NoLane) {
-      lane = findLane(
-        TransitionShortUpdateRangeStart,
-        TransitionShortUpdateRangeEnd,
-        wipLanes,
-      );
+      // If all lanes have pending work, look for a lane that isn't currently
+      // being worked on.
+      lane = pickArbitraryLane(TransitionShortLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = TransitionShortHydrationLane;
+        // If everything is being worked on, pick any lane. This has the
+        // effect of interrupting the current work-in-progress.
+        lane = pickArbitraryLane(TransitionShortLanes);
       }
     }
     return lane;
   }
   if (lanePriority === TransitionLongLanePriority) {
-    let lane = findLane(
-      TransitionLongUpdateRangeStart,
-      TransitionLongUpdateRangeEnd,
-      wipLanes | pendingLanes,
-    );
+    // First look for lanes that are completely unclaimed, i.e. have no
+    // pending work.
+    let lane = pickArbitraryLane(TransitionLongLanes & ~pendingLanes);
     if (lane === NoLane) {
-      lane = findLane(
-        TransitionLongUpdateRangeStart,
-        TransitionLongUpdateRangeEnd,
-        wipLanes,
-      );
+      // If all lanes have pending work, look for a lane that isn't currently
+      // being worked on.
+      lane = pickArbitraryLane(TransitionLongLanes & ~wipLanes);
       if (lane === NoLane) {
-        lane = TransitionLongHydrationLane;
+        // If everything is being worked on, pick any lane. This has the
+        // effect of interrupting the current work-in-progress.
+        lane = pickArbitraryLane(TransitionLongLanes);
       }
     }
     return lane;
@@ -628,27 +574,15 @@ export function findRetryLane(wipLanes: Lanes): Lane {
   // This is a fork of `findUpdateLane` designed specifically for Suspense
   // "retries" — a special update that attempts to flip a Suspense boundary
   // from its placeholder state to its primary/resolved state.
-  let lane = findLane(RetryRangeStart, RetryRangeEnd, wipLanes);
+  let lane = pickArbitraryLane(RetryLanes & ~wipLanes);
   if (lane === NoLane) {
     lane = pickArbitraryLane(RetryLanes);
   }
   return lane;
 }
 
-function findLane(start, end, skipLanes) {
-  // This finds the first bit between the `start` and `end` positions that isn't
-  // in `skipLanes`.
-  // TODO: This will always favor the rightmost bits. That's usually fine
-  // because any bit that's pending will be part of `skipLanes`, so we'll do our
-  // best to avoid accidental entanglement. However, lanes that are pending
-  // inside an Offscreen tree aren't considered "pending" at the root level. So
-  // they aren't included in `skipLanes`. So we should try not to favor any
-  // particular part of the range, perhaps by incrementing an offset for each
-  // distinct event. Must be the same within a single event, though.
-  const bitsInRange = ((1 << (end - start)) - 1) << start;
-  const possibleBits = bitsInRange & ~skipLanes;
-  const leastSignificantBit = possibleBits & -possibleBits;
-  return leastSignificantBit;
+function getHighestPriorityLane(lanes: Lanes) {
+  return lanes & -lanes;
 }
 
 function getLowestPriorityLane(lanes: Lanes): Lane {
@@ -657,8 +591,16 @@ function getLowestPriorityLane(lanes: Lanes): Lane {
   return index < 0 ? NoLanes : 1 << index;
 }
 
+function getEqualOrHigherPriorityLanes(lanes: Lanes | Lane): Lanes {
+  return (getLowestPriorityLane(lanes) << 1) - 1;
+}
+
 export function pickArbitraryLane(lanes: Lanes): Lane {
-  return getLowestPriorityLane(lanes);
+  // This wrapper function gets inlined. Only exists so to communicate that it
+  // doesn't matter which bit is selected; you can pick any bit without
+  // affecting the algorithms where its used. Here I'm using
+  // getHighestPriorityLane because it requires the fewest operations.
+  return getHighestPriorityLane(lanes);
 }
 
 function pickArbitraryLaneIndex(lanes: Lane | Lanes) {

commit 970fa122d8188bafa600e9b5214833487fbf1092
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jul 10 08:58:05 2020 -0500

    Use lanes to check if a render is a Suspense retry (#19307)
    
    Now that Suspense retries have their own dedicated set of lanes
    (#19287), we can determine if a render includes only retries by checking
    if its lanes are a subset of the retry lanes.
    
    Previously we inferred this by checking
    `workInProgressRootLatestProcessedEventTime`. If it's not set, that
    implies that no updates were processed in the current render, which
    implies it must be a Suspense retry. The eventual plan is to get rid of
    `workInProgressRootLatestProcessedEventTime` and instead track event
    times on the root; this change is one the steps toward that goal.
    
    The relevant tests were originally added in #15769.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 602c99f882..bc30a468f7 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -451,9 +451,12 @@ export function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes {
 export function returnNextLanesPriority() {
   return return_highestLanePriority;
 }
-export function hasUpdatePriority(lanes: Lanes) {
+export function includesNonIdleWork(lanes: Lanes) {
   return (lanes & NonIdleLanes) !== NoLanes;
 }
+export function includesOnlyRetries(lanes: Lanes) {
+  return (lanes & RetryLanes) === lanes;
+}
 
 // To ensure consistency across multiple updates in the same event, this should
 // be a pure function, so that it always returns the same lane for given inputs.

commit b23ea02be507cc08747d49c1994f283514c5aeea
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jul 17 12:47:39 2020 -0500

    Track event times per lane on the root (#19387)
    
    * Pass event time to markRootUpdated
    
    Some minor rearranging so that eventTime gets threaded through. No
    change in behavior.
    
    * Track event times per lane on the root
    
    Previous strategy was to store the event time on the update object
    and accumulate the most recent one during the render phase.
    
    Among other advantages, by tracking them on the root, we can read the
    event time before the render phase has finished.
    
    I haven't removed the `eventTime` field from the update object yet,
    because it's still used to compute the timeout. Tracking the timeout
    on the root is my next step.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index bc30a468f7..fc74f7782a 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -374,6 +374,25 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   return nextLanes;
 }
 
+export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
+  const eventTimes = root.eventTimes;
+
+  let mostRecentEventTime = NoTimestamp;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    const eventTime = eventTimes[index];
+    if (eventTime > mostRecentEventTime) {
+      mostRecentEventTime = eventTime;
+    }
+
+    lanes &= ~lane;
+  }
+
+  return mostRecentEventTime;
+}
+
 function computeExpirationTime(lane: Lane, currentTime: number) {
   // TODO: Expiration heuristic is constant per lane, so could use a map.
   getHighestPriorityLanes(lane);
@@ -606,10 +625,14 @@ export function pickArbitraryLane(lanes: Lanes): Lane {
   return getHighestPriorityLane(lanes);
 }
 
-function pickArbitraryLaneIndex(lanes: Lane | Lanes) {
+function pickArbitraryLaneIndex(lanes: Lanes) {
   return 31 - clz32(lanes);
 }
 
+function laneToIndex(lane: Lane) {
+  return pickArbitraryLaneIndex(lane);
+}
+
 export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
   return (a & b) !== NoLanes;
 }
@@ -648,7 +671,11 @@ export function createLaneMap<T>(initial: T): LaneMap<T> {
   return new Array(TotalLanes).fill(initial);
 }
 
-export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
+export function markRootUpdated(
+  root: FiberRoot,
+  updateLane: Lane,
+  eventTime: number,
+) {
   root.pendingLanes |= updateLane;
 
   // TODO: Theoretically, any update to any lane can unblock any other lane. But
@@ -666,6 +693,12 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
 
   root.suspendedLanes &= higherPriorityLanes;
   root.pingedLanes &= higherPriorityLanes;
+
+  const eventTimes = root.eventTimes;
+  const index = laneToIndex(updateLane);
+  // We can always overwrite an existing timestamp because we prefer the most
+  // recent event, and we assume time is monotonically increasing.
+  eventTimes[index] = eventTime;
 }
 
 export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
@@ -723,13 +756,18 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
 
   root.entangledLanes &= remainingLanes;
 
+  const entanglements = root.entanglements;
+  const eventTimes = root.eventTimes;
   const expirationTimes = root.expirationTimes;
+
+  // Clear the lanes that no longer have pending work
   let lanes = noLongerPendingLanes;
   while (lanes > 0) {
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
 
-    // Clear the expiration time
+    entanglements[index] = NoLanes;
+    eventTimes[index] = NoTimestamp;
     expirationTimes[index] = NoTimestamp;
 
     lanes &= ~lane;

commit 722bc046dcd748dde7109bc959318d3b14cf5196
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Jul 27 16:42:44 2020 -0500

    Don't rely on `didTimeout` for SyncBatched (#19469)
    
    Tasks with SyncBatchedPriority — used by Blocking Mode — should always
    be rendered by the `peformSyncWorkOnRoot` path, not
    `performConcurrentWorkOnRoot`.
    
    Currently, they go through the `performConcurrentWorkOnRoot` callback.
    Then, we check `didTimeout` to see if the task expired. Since
    SyncBatchedPriority translates to ImmediatePriority in the Scheduler,
    `didTimeout` is always `true`, so we mark it as expired. Then it exits
    and re-enters in the `performSyncWorkOnRoot` path.
    
    Aside from being overly convoluted, we shouldn't rely on Scheduler to
    tell us that SyncBatchedPriority work is synchronous. We should handle
    that ourselves.
    
    This will allow us to remove the `didTimeout` check. And it further
    decouples us from the Scheduler priority, so we can eventually remove
    that, too.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index fc74f7782a..d6d49ff042 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -44,7 +44,7 @@ import {
 } from './SchedulerWithReactIntegration.new';
 
 export const SyncLanePriority: LanePriority = 17;
-const SyncBatchedLanePriority: LanePriority = 16;
+export const SyncBatchedLanePriority: LanePriority = 16;
 
 const InputDiscreteHydrationLanePriority: LanePriority = 15;
 export const InputDiscreteLanePriority: LanePriority = 14;

commit d6e433899f387be42a3cec2115b4607f32910a3b
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Aug 20 17:39:29 2020 -0400

    Use Global Render Timeout for CPU Suspense (#19643)
    
    * Use Retry lane for resuming CPU suspended work
    
    * Use a global render timeout for CPU suspense heuristics
    
    * Fix profiler test since we're now reading time more often
    
    * Sync to new reconciler
    
    * Test synchronously rerendering should not render more rows

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index d6d49ff042..d571216771 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -97,6 +97,8 @@ const TransitionLongLanes: Lanes = /*                   */ 0b0000000001111000000
 
 const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
 
+export const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;
+
 export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
 
 const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;

commit 8da0da0937af154b775b243c9d28b6aa50db696b
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Aug 26 16:35:13 2020 -0500

    Disable timeoutMs argument (#19703)
    
    * Remove distinction between long, short transitions
    
    We're removing the `timeoutMs` option, so there's no longer any
    distinction between "short" and "long" transitions. They're all treated
    the same.
    
    This commit doesn't remove `timeoutMs` yet, only combines the internal
    priority levels.
    
    * Disable `timeoutMs` argument
    
    tl;dr
    -----
    
    - We're removing the `timeoutMs` argument from `useTransition`.
    - Transitions will either immediately switch to a skeleton/placeholder
      view (when loading new content) or wait indefinitely until the data
      resolves (when refreshing stale content).
    - This commit disables the `timeoutMS` so that the API has the desired
      semantics. It doesn't yet update the types or migrate all the test
      callers. I'll do those steps in follow-up PRs.
    
    Motivation
    ----------
    
    Currently, transitions initiated by `startTransition` / `useTransition`
    accept a `timeoutMs` option. You can use this to control the maximum
    amount of time that a transition is allowed to delay before we give up
    and show a placeholder.
    
    What we've discovered is that, in practice, every transition falls into
    one of two categories: a **load** or a **refresh**:
    
    - **Loading a new screen**: show the next screen as soon as possible,
      even if the data hasn't finished loading. Use a skeleton/placeholder
      UI to show progress.
    - **Refreshing a screen that's already visible**: keep showing the
      current screen indefinitely, for as long as it takes to load the fresh
      data, even if the current data is stale. Use a pending state (and
      maybe a busy indicator) to show progress.
    
    In other words, transitions should either *delay indefinitely* (for a
    refresh) or they should show a placeholder *instantly* (for a load).
    There's not much use for transitions that are delayed for a
    small-but-noticeable amount of time.
    
    So, the plan is to remove the `timeoutMs` option. Instead, we'll assign
    an effective timeout of `0` for loads, and `Infinity` for refreshes.
    
    The mechanism for distinguishing a load from a refresh already exists in
    the current model. If a component suspends, and the nearest Suspense
    boundary hasn't already mounted, we treat that as a load, because
    there's nothing on the screen. However, if the nearest boundary is
    mounted, we treat that as a refresh, since it's already showing content.
    
    If you need to fix a transition to be treated as a load instead of a
    refresh, or vice versa, the solution will involve rearranging the
    location of your Suspense boundaries. It may also involve adding a key.
    
    We're still working on proper documentation for these patterns. In the
    meantime, please reach out to us if you run into problems that you're
    unsure how to fix.
    
    We will remove `timeoutMs` from `useDeferredValue`, too, and apply the
    same load versus refresh semantics to the update that spawns the
    deferred value.
    
    Note that there are other types of delays that are not related to
    transitions; for example, we will still throttle the appearance of
    nested placeholders (we refer to this as the placeholder "train model"),
    and we may still apply a Just Noticeable Difference heuristic (JND) in
    some cases. These aren't going anywhere. (Well, the JND heuristic might
    but for different reasons than those discussed above.)

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index d571216771..d9ee9f43eb 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -43,23 +43,20 @@ import {
   NoPriority as NoSchedulerPriority,
 } from './SchedulerWithReactIntegration.new';
 
-export const SyncLanePriority: LanePriority = 17;
-export const SyncBatchedLanePriority: LanePriority = 16;
+export const SyncLanePriority: LanePriority = 15;
+export const SyncBatchedLanePriority: LanePriority = 14;
 
-const InputDiscreteHydrationLanePriority: LanePriority = 15;
-export const InputDiscreteLanePriority: LanePriority = 14;
+const InputDiscreteHydrationLanePriority: LanePriority = 13;
+export const InputDiscreteLanePriority: LanePriority = 12;
 
-const InputContinuousHydrationLanePriority: LanePriority = 13;
-export const InputContinuousLanePriority: LanePriority = 12;
+const InputContinuousHydrationLanePriority: LanePriority = 11;
+export const InputContinuousLanePriority: LanePriority = 10;
 
-const DefaultHydrationLanePriority: LanePriority = 11;
-export const DefaultLanePriority: LanePriority = 10;
+const DefaultHydrationLanePriority: LanePriority = 9;
+export const DefaultLanePriority: LanePriority = 8;
 
-const TransitionShortHydrationLanePriority: LanePriority = 9;
-export const TransitionShortLanePriority: LanePriority = 8;
-
-const TransitionLongHydrationLanePriority: LanePriority = 7;
-export const TransitionLongLanePriority: LanePriority = 6;
+const TransitionHydrationPriority: LanePriority = 7;
+export const TransitionPriority: LanePriority = 6;
 
 const RetryLanePriority: LanePriority = 5;
 
@@ -89,11 +86,8 @@ const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
 export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;
 
-const TransitionShortHydrationLane: Lane = /*           */ 0b0000000000000000001000000000000;
-const TransitionShortLanes: Lanes = /*                  */ 0b0000000000000011110000000000000;
-
-const TransitionLongHydrationLane: Lane = /*            */ 0b0000000000000100000000000000000;
-const TransitionLongLanes: Lanes = /*                   */ 0b0000000001111000000000000000000;
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;
 
 const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
 
@@ -160,23 +154,14 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     return_highestLanePriority = DefaultLanePriority;
     return defaultLanes;
   }
-  if ((lanes & TransitionShortHydrationLane) !== NoLanes) {
-    return_highestLanePriority = TransitionShortHydrationLanePriority;
-    return TransitionShortHydrationLane;
-  }
-  const transitionShortLanes = TransitionShortLanes & lanes;
-  if (transitionShortLanes !== NoLanes) {
-    return_highestLanePriority = TransitionShortLanePriority;
-    return transitionShortLanes;
+  if ((lanes & TransitionHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionHydrationPriority;
+    return TransitionHydrationLane;
   }
-  if ((lanes & TransitionLongHydrationLane) !== NoLanes) {
-    return_highestLanePriority = TransitionLongHydrationLanePriority;
-    return TransitionLongHydrationLane;
-  }
-  const transitionLongLanes = TransitionLongLanes & lanes;
-  if (transitionLongLanes !== NoLanes) {
-    return_highestLanePriority = TransitionLongLanePriority;
-    return transitionLongLanes;
+  const transitionLanes = TransitionLanes & lanes;
+  if (transitionLanes !== NoLanes) {
+    return_highestLanePriority = TransitionPriority;
+    return transitionLanes;
   }
   const retryLanes = RetryLanes & lanes;
   if (retryLanes !== NoLanes) {
@@ -241,10 +226,8 @@ export function lanePriorityToSchedulerPriority(
       return UserBlockingSchedulerPriority;
     case DefaultHydrationLanePriority:
     case DefaultLanePriority:
-    case TransitionShortHydrationLanePriority:
-    case TransitionShortLanePriority:
-    case TransitionLongHydrationLanePriority:
-    case TransitionLongLanePriority:
+    case TransitionHydrationPriority:
+    case TransitionPriority:
     case SelectiveHydrationLanePriority:
     case RetryLanePriority:
       return NormalSchedulerPriority;
@@ -402,7 +385,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
   if (priority >= InputContinuousLanePriority) {
     // User interactions should expire slightly more quickly.
     return currentTime + 1000;
-  } else if (priority >= TransitionLongLanePriority) {
+  } else if (priority >= TransitionPriority) {
     return currentTime + 5000;
   } else {
     // Anything idle priority or lower should never expire.
@@ -513,9 +496,7 @@ export function findUpdateLane(
       if (lane === NoLane) {
         // If all the default lanes are already being worked on, look for a
         // lane in the transition range.
-        lane = pickArbitraryLane(
-          (TransitionShortLanes | TransitionLongLanes) & ~wipLanes,
-        );
+        lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
         if (lane === NoLane) {
           // All the transition lanes are taken, too. This should be very
           // rare, but as a last resort, pick a default lane. This will have
@@ -525,8 +506,7 @@ export function findUpdateLane(
       }
       return lane;
     }
-    case TransitionShortLanePriority: // Should be handled by findTransitionLane instead
-    case TransitionLongLanePriority:
+    case TransitionPriority: // Should be handled by findTransitionLane instead
     case RetryLanePriority: // Should be handled by findRetryLane instead
       break;
     case IdleLanePriority:
@@ -548,48 +528,21 @@ export function findUpdateLane(
 
 // To ensure consistency across multiple updates in the same event, this should
 // be pure function, so that it always returns the same lane for given inputs.
-export function findTransitionLane(
-  lanePriority: LanePriority,
-  wipLanes: Lanes,
-  pendingLanes: Lanes,
-): Lane {
-  if (lanePriority === TransitionShortLanePriority) {
-    // First look for lanes that are completely unclaimed, i.e. have no
-    // pending work.
-    let lane = pickArbitraryLane(TransitionShortLanes & ~pendingLanes);
-    if (lane === NoLane) {
-      // If all lanes have pending work, look for a lane that isn't currently
-      // being worked on.
-      lane = pickArbitraryLane(TransitionShortLanes & ~wipLanes);
-      if (lane === NoLane) {
-        // If everything is being worked on, pick any lane. This has the
-        // effect of interrupting the current work-in-progress.
-        lane = pickArbitraryLane(TransitionShortLanes);
-      }
-    }
-    return lane;
-  }
-  if (lanePriority === TransitionLongLanePriority) {
-    // First look for lanes that are completely unclaimed, i.e. have no
-    // pending work.
-    let lane = pickArbitraryLane(TransitionLongLanes & ~pendingLanes);
+export function findTransitionLane(wipLanes: Lanes, pendingLanes: Lanes): Lane {
+  // First look for lanes that are completely unclaimed, i.e. have no
+  // pending work.
+  let lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
+  if (lane === NoLane) {
+    // If all lanes have pending work, look for a lane that isn't currently
+    // being worked on.
+    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
     if (lane === NoLane) {
-      // If all lanes have pending work, look for a lane that isn't currently
-      // being worked on.
-      lane = pickArbitraryLane(TransitionLongLanes & ~wipLanes);
-      if (lane === NoLane) {
-        // If everything is being worked on, pick any lane. This has the
-        // effect of interrupting the current work-in-progress.
-        lane = pickArbitraryLane(TransitionLongLanes);
-      }
+      // If everything is being worked on, pick any lane. This has the
+      // effect of interrupting the current work-in-progress.
+      lane = pickArbitraryLane(TransitionLanes);
     }
-    return lane;
   }
-  invariant(
-    false,
-    'Invalid transition priority: %s. This is a bug in React.',
-    lanePriority,
-  );
+  return lane;
 }
 
 // To ensure consistency across multiple updates in the same event, this should
@@ -816,18 +769,14 @@ export function getBumpedLaneForHydration(
     case DefaultLanePriority:
       lane = DefaultHydrationLane;
       break;
-    case TransitionShortHydrationLanePriority:
-    case TransitionShortLanePriority:
-      lane = TransitionShortHydrationLane;
-      break;
-    case TransitionLongHydrationLanePriority:
-    case TransitionLongLanePriority:
-      lane = TransitionLongHydrationLane;
+    case TransitionHydrationPriority:
+    case TransitionPriority:
+      lane = TransitionHydrationLane;
       break;
     case RetryLanePriority:
       // Shouldn't be reachable under normal circumstances, so there's no
       // dedicated lane for retry priority. Use the one for long transitions.
-      lane = TransitionLongHydrationLane;
+      lane = TransitionHydrationLane;
       break;
     case SelectiveHydrationLanePriority:
       lane = SelectiveHydrationLane;

commit 1eaafc9ade46ba708b2361b324dd907d019e3939
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Aug 27 11:47:58 2020 -0500

    Clean up timeoutMs-related implementation details (#19704)
    
    * Disable busyDelayMs and busyMinDurationMs
    
    Refer to explanation in previous commit.
    
    * Remove unnecessary work loop variables
    
    Since we no longer support SuspenseConfig options, we don't need to
    track these values.
    
    * Remove unnecessary Update fields

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index d9ee9f43eb..8e6a66f921 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -461,6 +461,9 @@ export function includesNonIdleWork(lanes: Lanes) {
 export function includesOnlyRetries(lanes: Lanes) {
   return (lanes & RetryLanes) === lanes;
 }
+export function includesOnlyTransitions(lanes: Lanes) {
+  return (lanes & TransitionLanes) === lanes;
+}
 
 // To ensure consistency across multiple updates in the same event, this should
 // be a pure function, so that it always returns the same lane for given inputs.

commit 708fa77a783bbe729cfcebdd513d23eafc455b8b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Sep 4 12:42:09 2020 -0500

    Decrease expiration time of input updates (#19772)
    
    Changes the expiration time of input updates from 1000ms to 250ms, to
    match the corresponding constant in Scheduler.js.
    
    When we made it larger, a product metric in www regressed, suggesting
    there's a user interaction that's being starved by a series of
    synchronous updates. If that theory is correct, the proper solution is
    to fix the starvation. However, this scenario supports the idea that
    expiration times are an important safeguard when starvation does happen.
    
    Also note that, in the case of user input specifically, this will soon
    no longer be an issue because we plan to make user input synchronous by
    default (until you enter `startTransition`, of course.)
    
    If weren't planning to make these updates synchronous soon anyway, I
    would probably make this number a configurable parameter.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 8e6a66f921..3dc89c45a9 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -384,7 +384,21 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
   const priority = return_highestLanePriority;
   if (priority >= InputContinuousLanePriority) {
     // User interactions should expire slightly more quickly.
-    return currentTime + 1000;
+    //
+    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
+    // we made it larger, a product metric in www regressed, suggesting there's
+    // a user interaction that's being starved by a series of synchronous
+    // updates. If that theory is correct, the proper solution is to fix the
+    // starvation. However, this scenario supports the idea that expiration
+    // times are an important safeguard when starvation does happen.
+    //
+    // Also note that, in the case of user input specifically, this will soon no
+    // longer be an issue because we plan to make user input synchronous by
+    // default (until you enter `startTransition`, of course.)
+    //
+    // If weren't planning to make these updates synchronous soon anyway, I
+    // would probably make this number a configurable parameter.
+    return currentTime + 250;
   } else if (priority >= TransitionPriority) {
     return currentTime + 5000;
   } else {

commit 6f62abb58ae46d9c88525635f1790487285666e6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Oct 21 13:17:44 2020 +0100

    Remove usage of Array#fill (#20071)

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 3dc89c45a9..027754dd76 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -640,7 +640,13 @@ export function higherLanePriority(
 }
 
 export function createLaneMap<T>(initial: T): LaneMap<T> {
-  return new Array(TotalLanes).fill(initial);
+  // Intentionally pushing one by one.
+  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
+  const laneMap = [];
+  for (let i = 0; i < TotalLanes; i++) {
+    laneMap.push(initial);
+  }
+  return laneMap;
 }
 
 export function markRootUpdated(

commit 88ef95712d315705b2d6654f3c0d5c5ace4a6456
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Dec 4 10:54:09 2020 -0600

    Fork ReactFiberLane (#20371)
    
    This wasn't forked previously because Lane and associated types are
    opaque, and they leak into non-reconciler packages. So forking the type
    would also require forking all those other packages.
    
    But I really want to use the reconciler fork infra for lanes changes.
    So I made them no longer opaque.
    
    Another possible solution would be to add separate `new` and `old`
    fields to the Fiber type, like I did when migrating from expiration
    times. But that seems so excessive. This seems fine.
    
    But we should still treat them like they're opaque and only do lanes
    manipulation in the ReactFiberLane module. At least until the model
    stabilizes more. We'll just need to enforce this with discipline
    instead of with the type system.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
deleted file mode 100644
index 027754dd76..0000000000
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ /dev/null
@@ -1,842 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- */
-
-import type {FiberRoot, ReactPriorityLevel} from './ReactInternalTypes';
-
-export opaque type LanePriority =
-  | 0
-  | 1
-  | 2
-  | 3
-  | 4
-  | 5
-  | 6
-  | 7
-  | 8
-  | 9
-  | 10
-  | 11
-  | 12
-  | 13
-  | 14
-  | 15
-  | 16
-  | 17;
-export opaque type Lanes = number;
-export opaque type Lane = number;
-export opaque type LaneMap<T> = Array<T>;
-
-import invariant from 'shared/invariant';
-
-import {
-  ImmediatePriority as ImmediateSchedulerPriority,
-  UserBlockingPriority as UserBlockingSchedulerPriority,
-  NormalPriority as NormalSchedulerPriority,
-  LowPriority as LowSchedulerPriority,
-  IdlePriority as IdleSchedulerPriority,
-  NoPriority as NoSchedulerPriority,
-} from './SchedulerWithReactIntegration.new';
-
-export const SyncLanePriority: LanePriority = 15;
-export const SyncBatchedLanePriority: LanePriority = 14;
-
-const InputDiscreteHydrationLanePriority: LanePriority = 13;
-export const InputDiscreteLanePriority: LanePriority = 12;
-
-const InputContinuousHydrationLanePriority: LanePriority = 11;
-export const InputContinuousLanePriority: LanePriority = 10;
-
-const DefaultHydrationLanePriority: LanePriority = 9;
-export const DefaultLanePriority: LanePriority = 8;
-
-const TransitionHydrationPriority: LanePriority = 7;
-export const TransitionPriority: LanePriority = 6;
-
-const RetryLanePriority: LanePriority = 5;
-
-const SelectiveHydrationLanePriority: LanePriority = 4;
-
-const IdleHydrationLanePriority: LanePriority = 3;
-const IdleLanePriority: LanePriority = 2;
-
-const OffscreenLanePriority: LanePriority = 1;
-
-export const NoLanePriority: LanePriority = 0;
-
-const TotalLanes = 31;
-
-export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
-export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
-
-export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
-export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;
-
-export const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;
-const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;
-
-const InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;
-const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;
-
-export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
-export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;
-
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;
-
-const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
-
-export const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;
-
-export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
-
-const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;
-
-export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
-const IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;
-
-export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
-
-export const NoTimestamp = -1;
-
-let currentUpdateLanePriority: LanePriority = NoLanePriority;
-
-export function getCurrentUpdateLanePriority(): LanePriority {
-  return currentUpdateLanePriority;
-}
-
-export function setCurrentUpdateLanePriority(newLanePriority: LanePriority) {
-  currentUpdateLanePriority = newLanePriority;
-}
-
-// "Registers" used to "return" multiple values
-// Used by getHighestPriorityLanes and getNextLanes:
-let return_highestLanePriority: LanePriority = DefaultLanePriority;
-
-function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
-  if ((SyncLane & lanes) !== NoLanes) {
-    return_highestLanePriority = SyncLanePriority;
-    return SyncLane;
-  }
-  if ((SyncBatchedLane & lanes) !== NoLanes) {
-    return_highestLanePriority = SyncBatchedLanePriority;
-    return SyncBatchedLane;
-  }
-  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
-    return_highestLanePriority = InputDiscreteHydrationLanePriority;
-    return InputDiscreteHydrationLane;
-  }
-  const inputDiscreteLanes = InputDiscreteLanes & lanes;
-  if (inputDiscreteLanes !== NoLanes) {
-    return_highestLanePriority = InputDiscreteLanePriority;
-    return inputDiscreteLanes;
-  }
-  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
-    return_highestLanePriority = InputContinuousHydrationLanePriority;
-    return InputContinuousHydrationLane;
-  }
-  const inputContinuousLanes = InputContinuousLanes & lanes;
-  if (inputContinuousLanes !== NoLanes) {
-    return_highestLanePriority = InputContinuousLanePriority;
-    return inputContinuousLanes;
-  }
-  if ((lanes & DefaultHydrationLane) !== NoLanes) {
-    return_highestLanePriority = DefaultHydrationLanePriority;
-    return DefaultHydrationLane;
-  }
-  const defaultLanes = DefaultLanes & lanes;
-  if (defaultLanes !== NoLanes) {
-    return_highestLanePriority = DefaultLanePriority;
-    return defaultLanes;
-  }
-  if ((lanes & TransitionHydrationLane) !== NoLanes) {
-    return_highestLanePriority = TransitionHydrationPriority;
-    return TransitionHydrationLane;
-  }
-  const transitionLanes = TransitionLanes & lanes;
-  if (transitionLanes !== NoLanes) {
-    return_highestLanePriority = TransitionPriority;
-    return transitionLanes;
-  }
-  const retryLanes = RetryLanes & lanes;
-  if (retryLanes !== NoLanes) {
-    return_highestLanePriority = RetryLanePriority;
-    return retryLanes;
-  }
-  if (lanes & SelectiveHydrationLane) {
-    return_highestLanePriority = SelectiveHydrationLanePriority;
-    return SelectiveHydrationLane;
-  }
-  if ((lanes & IdleHydrationLane) !== NoLanes) {
-    return_highestLanePriority = IdleHydrationLanePriority;
-    return IdleHydrationLane;
-  }
-  const idleLanes = IdleLanes & lanes;
-  if (idleLanes !== NoLanes) {
-    return_highestLanePriority = IdleLanePriority;
-    return idleLanes;
-  }
-  if ((OffscreenLane & lanes) !== NoLanes) {
-    return_highestLanePriority = OffscreenLanePriority;
-    return OffscreenLane;
-  }
-  if (__DEV__) {
-    console.error('Should have found matching lanes. This is a bug in React.');
-  }
-  // This shouldn't be reachable, but as a fallback, return the entire bitmask.
-  return_highestLanePriority = DefaultLanePriority;
-  return lanes;
-}
-
-export function schedulerPriorityToLanePriority(
-  schedulerPriorityLevel: ReactPriorityLevel,
-): LanePriority {
-  switch (schedulerPriorityLevel) {
-    case ImmediateSchedulerPriority:
-      return SyncLanePriority;
-    case UserBlockingSchedulerPriority:
-      return InputContinuousLanePriority;
-    case NormalSchedulerPriority:
-    case LowSchedulerPriority:
-      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
-      return DefaultLanePriority;
-    case IdleSchedulerPriority:
-      return IdleLanePriority;
-    default:
-      return NoLanePriority;
-  }
-}
-
-export function lanePriorityToSchedulerPriority(
-  lanePriority: LanePriority,
-): ReactPriorityLevel {
-  switch (lanePriority) {
-    case SyncLanePriority:
-    case SyncBatchedLanePriority:
-      return ImmediateSchedulerPriority;
-    case InputDiscreteHydrationLanePriority:
-    case InputDiscreteLanePriority:
-    case InputContinuousHydrationLanePriority:
-    case InputContinuousLanePriority:
-      return UserBlockingSchedulerPriority;
-    case DefaultHydrationLanePriority:
-    case DefaultLanePriority:
-    case TransitionHydrationPriority:
-    case TransitionPriority:
-    case SelectiveHydrationLanePriority:
-    case RetryLanePriority:
-      return NormalSchedulerPriority;
-    case IdleHydrationLanePriority:
-    case IdleLanePriority:
-    case OffscreenLanePriority:
-      return IdleSchedulerPriority;
-    case NoLanePriority:
-      return NoSchedulerPriority;
-    default:
-      invariant(
-        false,
-        'Invalid update priority: %s. This is a bug in React.',
-        lanePriority,
-      );
-  }
-}
-
-export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
-  // Early bailout if there's no pending work left.
-  const pendingLanes = root.pendingLanes;
-  if (pendingLanes === NoLanes) {
-    return_highestLanePriority = NoLanePriority;
-    return NoLanes;
-  }
-
-  let nextLanes = NoLanes;
-  let nextLanePriority = NoLanePriority;
-
-  const expiredLanes = root.expiredLanes;
-  const suspendedLanes = root.suspendedLanes;
-  const pingedLanes = root.pingedLanes;
-
-  // Check if any work has expired.
-  if (expiredLanes !== NoLanes) {
-    nextLanes = expiredLanes;
-    nextLanePriority = return_highestLanePriority = SyncLanePriority;
-  } else {
-    // Do not work on any idle work until all the non-idle work has finished,
-    // even if the work is suspended.
-    const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
-    if (nonIdlePendingLanes !== NoLanes) {
-      const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
-      if (nonIdleUnblockedLanes !== NoLanes) {
-        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
-        nextLanePriority = return_highestLanePriority;
-      } else {
-        const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
-        if (nonIdlePingedLanes !== NoLanes) {
-          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
-          nextLanePriority = return_highestLanePriority;
-        }
-      }
-    } else {
-      // The only remaining work is Idle.
-      const unblockedLanes = pendingLanes & ~suspendedLanes;
-      if (unblockedLanes !== NoLanes) {
-        nextLanes = getHighestPriorityLanes(unblockedLanes);
-        nextLanePriority = return_highestLanePriority;
-      } else {
-        if (pingedLanes !== NoLanes) {
-          nextLanes = getHighestPriorityLanes(pingedLanes);
-          nextLanePriority = return_highestLanePriority;
-        }
-      }
-    }
-  }
-
-  if (nextLanes === NoLanes) {
-    // This should only be reachable if we're suspended
-    // TODO: Consider warning in this path if a fallback timer is not scheduled.
-    return NoLanes;
-  }
-
-  // If there are higher priority lanes, we'll include them even if they
-  // are suspended.
-  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
-
-  // If we're already in the middle of a render, switching lanes will interrupt
-  // it and we'll lose our progress. We should only do this if the new lanes are
-  // higher priority.
-  if (
-    wipLanes !== NoLanes &&
-    wipLanes !== nextLanes &&
-    // If we already suspended with a delay, then interrupting is fine. Don't
-    // bother waiting until the root is complete.
-    (wipLanes & suspendedLanes) === NoLanes
-  ) {
-    getHighestPriorityLanes(wipLanes);
-    const wipLanePriority = return_highestLanePriority;
-    if (nextLanePriority <= wipLanePriority) {
-      return wipLanes;
-    } else {
-      return_highestLanePriority = nextLanePriority;
-    }
-  }
-
-  // Check for entangled lanes and add them to the batch.
-  //
-  // A lane is said to be entangled with another when it's not allowed to render
-  // in a batch that does not also include the other lane. Typically we do this
-  // when multiple updates have the same source, and we only want to respond to
-  // the most recent event from that source.
-  //
-  // Note that we apply entanglements *after* checking for partial work above.
-  // This means that if a lane is entangled during an interleaved event while
-  // it's already rendering, we won't interrupt it. This is intentional, since
-  // entanglement is usually "best effort": we'll try our best to render the
-  // lanes in the same batch, but it's not worth throwing out partially
-  // completed work in order to do it.
-  //
-  // For those exceptions where entanglement is semantically important, like
-  // useMutableSource, we should ensure that there is no partial work at the
-  // time we apply the entanglement.
-  const entangledLanes = root.entangledLanes;
-  if (entangledLanes !== NoLanes) {
-    const entanglements = root.entanglements;
-    let lanes = nextLanes & entangledLanes;
-    while (lanes > 0) {
-      const index = pickArbitraryLaneIndex(lanes);
-      const lane = 1 << index;
-
-      nextLanes |= entanglements[index];
-
-      lanes &= ~lane;
-    }
-  }
-
-  return nextLanes;
-}
-
-export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
-  const eventTimes = root.eventTimes;
-
-  let mostRecentEventTime = NoTimestamp;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    const eventTime = eventTimes[index];
-    if (eventTime > mostRecentEventTime) {
-      mostRecentEventTime = eventTime;
-    }
-
-    lanes &= ~lane;
-  }
-
-  return mostRecentEventTime;
-}
-
-function computeExpirationTime(lane: Lane, currentTime: number) {
-  // TODO: Expiration heuristic is constant per lane, so could use a map.
-  getHighestPriorityLanes(lane);
-  const priority = return_highestLanePriority;
-  if (priority >= InputContinuousLanePriority) {
-    // User interactions should expire slightly more quickly.
-    //
-    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
-    // we made it larger, a product metric in www regressed, suggesting there's
-    // a user interaction that's being starved by a series of synchronous
-    // updates. If that theory is correct, the proper solution is to fix the
-    // starvation. However, this scenario supports the idea that expiration
-    // times are an important safeguard when starvation does happen.
-    //
-    // Also note that, in the case of user input specifically, this will soon no
-    // longer be an issue because we plan to make user input synchronous by
-    // default (until you enter `startTransition`, of course.)
-    //
-    // If weren't planning to make these updates synchronous soon anyway, I
-    // would probably make this number a configurable parameter.
-    return currentTime + 250;
-  } else if (priority >= TransitionPriority) {
-    return currentTime + 5000;
-  } else {
-    // Anything idle priority or lower should never expire.
-    return NoTimestamp;
-  }
-}
-
-export function markStarvedLanesAsExpired(
-  root: FiberRoot,
-  currentTime: number,
-): void {
-  // TODO: This gets called every time we yield. We can optimize by storing
-  // the earliest expiration time on the root. Then use that to quickly bail out
-  // of this function.
-
-  const pendingLanes = root.pendingLanes;
-  const suspendedLanes = root.suspendedLanes;
-  const pingedLanes = root.pingedLanes;
-  const expirationTimes = root.expirationTimes;
-
-  // Iterate through the pending lanes and check if we've reached their
-  // expiration time. If so, we'll assume the update is being starved and mark
-  // it as expired to force it to finish.
-  let lanes = pendingLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    const expirationTime = expirationTimes[index];
-    if (expirationTime === NoTimestamp) {
-      // Found a pending lane with no expiration time. If it's not suspended, or
-      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
-      // using the current time.
-      if (
-        (lane & suspendedLanes) === NoLanes ||
-        (lane & pingedLanes) !== NoLanes
-      ) {
-        // Assumes timestamps are monotonically increasing.
-        expirationTimes[index] = computeExpirationTime(lane, currentTime);
-      }
-    } else if (expirationTime <= currentTime) {
-      // This lane expired
-      root.expiredLanes |= lane;
-    }
-
-    lanes &= ~lane;
-  }
-}
-
-// This returns the highest priority pending lanes regardless of whether they
-// are suspended.
-export function getHighestPriorityPendingLanes(root: FiberRoot) {
-  return getHighestPriorityLanes(root.pendingLanes);
-}
-
-export function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes {
-  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
-  if (everythingButOffscreen !== NoLanes) {
-    return everythingButOffscreen;
-  }
-  if (everythingButOffscreen & OffscreenLane) {
-    return OffscreenLane;
-  }
-  return NoLanes;
-}
-
-export function returnNextLanesPriority() {
-  return return_highestLanePriority;
-}
-export function includesNonIdleWork(lanes: Lanes) {
-  return (lanes & NonIdleLanes) !== NoLanes;
-}
-export function includesOnlyRetries(lanes: Lanes) {
-  return (lanes & RetryLanes) === lanes;
-}
-export function includesOnlyTransitions(lanes: Lanes) {
-  return (lanes & TransitionLanes) === lanes;
-}
-
-// To ensure consistency across multiple updates in the same event, this should
-// be a pure function, so that it always returns the same lane for given inputs.
-export function findUpdateLane(
-  lanePriority: LanePriority,
-  wipLanes: Lanes,
-): Lane {
-  switch (lanePriority) {
-    case NoLanePriority:
-      break;
-    case SyncLanePriority:
-      return SyncLane;
-    case SyncBatchedLanePriority:
-      return SyncBatchedLane;
-    case InputDiscreteLanePriority: {
-      const lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
-      if (lane === NoLane) {
-        // Shift to the next priority level
-        return findUpdateLane(InputContinuousLanePriority, wipLanes);
-      }
-      return lane;
-    }
-    case InputContinuousLanePriority: {
-      const lane = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
-      if (lane === NoLane) {
-        // Shift to the next priority level
-        return findUpdateLane(DefaultLanePriority, wipLanes);
-      }
-      return lane;
-    }
-    case DefaultLanePriority: {
-      let lane = pickArbitraryLane(DefaultLanes & ~wipLanes);
-      if (lane === NoLane) {
-        // If all the default lanes are already being worked on, look for a
-        // lane in the transition range.
-        lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
-        if (lane === NoLane) {
-          // All the transition lanes are taken, too. This should be very
-          // rare, but as a last resort, pick a default lane. This will have
-          // the effect of interrupting the current work-in-progress render.
-          lane = pickArbitraryLane(DefaultLanes);
-        }
-      }
-      return lane;
-    }
-    case TransitionPriority: // Should be handled by findTransitionLane instead
-    case RetryLanePriority: // Should be handled by findRetryLane instead
-      break;
-    case IdleLanePriority:
-      let lane = pickArbitraryLane(IdleLanes & ~wipLanes);
-      if (lane === NoLane) {
-        lane = pickArbitraryLane(IdleLanes);
-      }
-      return lane;
-    default:
-      // The remaining priorities are not valid for updates
-      break;
-  }
-  invariant(
-    false,
-    'Invalid update priority: %s. This is a bug in React.',
-    lanePriority,
-  );
-}
-
-// To ensure consistency across multiple updates in the same event, this should
-// be pure function, so that it always returns the same lane for given inputs.
-export function findTransitionLane(wipLanes: Lanes, pendingLanes: Lanes): Lane {
-  // First look for lanes that are completely unclaimed, i.e. have no
-  // pending work.
-  let lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
-  if (lane === NoLane) {
-    // If all lanes have pending work, look for a lane that isn't currently
-    // being worked on.
-    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
-    if (lane === NoLane) {
-      // If everything is being worked on, pick any lane. This has the
-      // effect of interrupting the current work-in-progress.
-      lane = pickArbitraryLane(TransitionLanes);
-    }
-  }
-  return lane;
-}
-
-// To ensure consistency across multiple updates in the same event, this should
-// be pure function, so that it always returns the same lane for given inputs.
-export function findRetryLane(wipLanes: Lanes): Lane {
-  // This is a fork of `findUpdateLane` designed specifically for Suspense
-  // "retries" — a special update that attempts to flip a Suspense boundary
-  // from its placeholder state to its primary/resolved state.
-  let lane = pickArbitraryLane(RetryLanes & ~wipLanes);
-  if (lane === NoLane) {
-    lane = pickArbitraryLane(RetryLanes);
-  }
-  return lane;
-}
-
-function getHighestPriorityLane(lanes: Lanes) {
-  return lanes & -lanes;
-}
-
-function getLowestPriorityLane(lanes: Lanes): Lane {
-  // This finds the most significant non-zero bit.
-  const index = 31 - clz32(lanes);
-  return index < 0 ? NoLanes : 1 << index;
-}
-
-function getEqualOrHigherPriorityLanes(lanes: Lanes | Lane): Lanes {
-  return (getLowestPriorityLane(lanes) << 1) - 1;
-}
-
-export function pickArbitraryLane(lanes: Lanes): Lane {
-  // This wrapper function gets inlined. Only exists so to communicate that it
-  // doesn't matter which bit is selected; you can pick any bit without
-  // affecting the algorithms where its used. Here I'm using
-  // getHighestPriorityLane because it requires the fewest operations.
-  return getHighestPriorityLane(lanes);
-}
-
-function pickArbitraryLaneIndex(lanes: Lanes) {
-  return 31 - clz32(lanes);
-}
-
-function laneToIndex(lane: Lane) {
-  return pickArbitraryLaneIndex(lane);
-}
-
-export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
-  return (a & b) !== NoLanes;
-}
-
-export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
-  return (set & subset) === subset;
-}
-
-export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
-  return a | b;
-}
-
-export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
-  return set & ~subset;
-}
-
-// Seems redundant, but it changes the type from a single lane (used for
-// updates) to a group of lanes (used for flushing work).
-export function laneToLanes(lane: Lane): Lanes {
-  return lane;
-}
-
-export function higherPriorityLane(a: Lane, b: Lane) {
-  // This works because the bit ranges decrease in priority as you go left.
-  return a !== NoLane && a < b ? a : b;
-}
-
-export function higherLanePriority(
-  a: LanePriority,
-  b: LanePriority,
-): LanePriority {
-  return a !== NoLanePriority && a > b ? a : b;
-}
-
-export function createLaneMap<T>(initial: T): LaneMap<T> {
-  // Intentionally pushing one by one.
-  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
-  const laneMap = [];
-  for (let i = 0; i < TotalLanes; i++) {
-    laneMap.push(initial);
-  }
-  return laneMap;
-}
-
-export function markRootUpdated(
-  root: FiberRoot,
-  updateLane: Lane,
-  eventTime: number,
-) {
-  root.pendingLanes |= updateLane;
-
-  // TODO: Theoretically, any update to any lane can unblock any other lane. But
-  // it's not practical to try every single possible combination. We need a
-  // heuristic to decide which lanes to attempt to render, and in which batches.
-  // For now, we use the same heuristic as in the old ExpirationTimes model:
-  // retry any lane at equal or lower priority, but don't try updates at higher
-  // priority without also including the lower priority updates. This works well
-  // when considering updates across different priority levels, but isn't
-  // sufficient for updates within the same priority, since we want to treat
-  // those updates as parallel.
-
-  // Unsuspend any update at equal or lower priority.
-  const higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
-
-  root.suspendedLanes &= higherPriorityLanes;
-  root.pingedLanes &= higherPriorityLanes;
-
-  const eventTimes = root.eventTimes;
-  const index = laneToIndex(updateLane);
-  // We can always overwrite an existing timestamp because we prefer the most
-  // recent event, and we assume time is monotonically increasing.
-  eventTimes[index] = eventTime;
-}
-
-export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-
-  // The suspended lanes are no longer CPU-bound. Clear their expiration times.
-  const expirationTimes = root.expirationTimes;
-  let lanes = suspendedLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    expirationTimes[index] = NoTimestamp;
-
-    lanes &= ~lane;
-  }
-}
-
-export function markRootPinged(
-  root: FiberRoot,
-  pingedLanes: Lanes,
-  eventTime: number,
-) {
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-}
-
-export function markRootExpired(root: FiberRoot, expiredLanes: Lanes) {
-  root.expiredLanes |= expiredLanes & root.pendingLanes;
-}
-
-export function markDiscreteUpdatesExpired(root: FiberRoot) {
-  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
-}
-
-export function hasDiscreteLanes(lanes: Lanes) {
-  return (lanes & InputDiscreteLanes) !== NoLanes;
-}
-
-export function markRootMutableRead(root: FiberRoot, updateLane: Lane) {
-  root.mutableReadLanes |= updateLane & root.pendingLanes;
-}
-
-export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
-  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
-
-  root.pendingLanes = remainingLanes;
-
-  // Let's try everything again
-  root.suspendedLanes = 0;
-  root.pingedLanes = 0;
-
-  root.expiredLanes &= remainingLanes;
-  root.mutableReadLanes &= remainingLanes;
-
-  root.entangledLanes &= remainingLanes;
-
-  const entanglements = root.entanglements;
-  const eventTimes = root.eventTimes;
-  const expirationTimes = root.expirationTimes;
-
-  // Clear the lanes that no longer have pending work
-  let lanes = noLongerPendingLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    entanglements[index] = NoLanes;
-    eventTimes[index] = NoTimestamp;
-    expirationTimes[index] = NoTimestamp;
-
-    lanes &= ~lane;
-  }
-}
-
-export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
-  root.entangledLanes |= entangledLanes;
-
-  const entanglements = root.entanglements;
-  let lanes = entangledLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    entanglements[index] |= entangledLanes;
-
-    lanes &= ~lane;
-  }
-}
-
-export function getBumpedLaneForHydration(
-  root: FiberRoot,
-  renderLanes: Lanes,
-): Lane {
-  getHighestPriorityLanes(renderLanes);
-  const highestLanePriority = return_highestLanePriority;
-
-  let lane;
-  switch (highestLanePriority) {
-    case SyncLanePriority:
-    case SyncBatchedLanePriority:
-      lane = NoLane;
-      break;
-    case InputDiscreteHydrationLanePriority:
-    case InputDiscreteLanePriority:
-      lane = InputDiscreteHydrationLane;
-      break;
-    case InputContinuousHydrationLanePriority:
-    case InputContinuousLanePriority:
-      lane = InputContinuousHydrationLane;
-      break;
-    case DefaultHydrationLanePriority:
-    case DefaultLanePriority:
-      lane = DefaultHydrationLane;
-      break;
-    case TransitionHydrationPriority:
-    case TransitionPriority:
-      lane = TransitionHydrationLane;
-      break;
-    case RetryLanePriority:
-      // Shouldn't be reachable under normal circumstances, so there's no
-      // dedicated lane for retry priority. Use the one for long transitions.
-      lane = TransitionHydrationLane;
-      break;
-    case SelectiveHydrationLanePriority:
-      lane = SelectiveHydrationLane;
-      break;
-    case IdleHydrationLanePriority:
-    case IdleLanePriority:
-      lane = IdleHydrationLane;
-      break;
-    case OffscreenLanePriority:
-    case NoLanePriority:
-      lane = NoLane;
-      break;
-    default:
-      invariant(false, 'Invalid lane: %s. This is a bug in React.', lane);
-  }
-
-  // Check if the lane we chose is suspended. If so, that indicates that we
-  // already attempted and failed to hydrate at that level. Also check if we're
-  // already rendering that lane, which is rare but could happen.
-  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
-    // Give up trying to hydrate and fall back to client render.
-    return NoLane;
-  }
-
-  return lane;
-}
-
-const clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
-
-// Count leading zeros. Only used on lanes, so assume input is an integer.
-// Based on:
-// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
-const log = Math.log;
-const LN2 = Math.LN2;
-function clz32Fallback(lanes: Lanes | Lane) {
-  if (lanes === 0) {
-    return 32;
-  }
-  return (31 - ((log(lanes) / LN2) | 0)) | 0;
-}

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
new file mode 100644
index 0000000000..97a28f8809
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -0,0 +1,924 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {Fiber, FiberRoot} from './ReactInternalTypes';
+import type {Transition} from './ReactFiberTracingMarkerComponent';
+import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
+
+// TODO: Ideally these types would be opaque but that doesn't work well with
+// our reconciler fork infra, since these leak into non-reconciler packages.
+
+export type Lanes = number;
+export type Lane = number;
+export type LaneMap<T> = Array<T>;
+
+import {
+  enableSchedulingProfiler,
+  enableUpdaterTracking,
+  allowConcurrentByDefault,
+  enableTransitionTracing,
+} from 'shared/ReactFeatureFlags';
+import {isDevToolsPresent} from './ReactFiberDevToolsHook';
+import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
+import {clz32} from './clz32';
+
+// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.
+// If those values are changed that package should be rebuilt and redeployed.
+
+export const TotalLanes = 31;
+
+export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
+export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
+
+export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
+export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
+
+export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
+export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
+
+export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
+export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
+
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
+const TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;
+
+const RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;
+const RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;
+const RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;
+const RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;
+const RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;
+
+export const SomeRetryLane: Lane = RetryLane1;
+
+export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
+
+const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
+
+export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
+export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
+
+export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
+
+// This function is used for the experimental timeline (react-devtools-timeline)
+// It should be kept in sync with the Lanes values above.
+export function getLabelForLane(lane: Lane): string | void {
+  if (enableSchedulingProfiler) {
+    if (lane & SyncHydrationLane) {
+      return 'SyncHydrationLane';
+    }
+    if (lane & SyncLane) {
+      return 'Sync';
+    }
+    if (lane & InputContinuousHydrationLane) {
+      return 'InputContinuousHydration';
+    }
+    if (lane & InputContinuousLane) {
+      return 'InputContinuous';
+    }
+    if (lane & DefaultHydrationLane) {
+      return 'DefaultHydration';
+    }
+    if (lane & DefaultLane) {
+      return 'Default';
+    }
+    if (lane & TransitionHydrationLane) {
+      return 'TransitionHydration';
+    }
+    if (lane & TransitionLanes) {
+      return 'Transition';
+    }
+    if (lane & RetryLanes) {
+      return 'Retry';
+    }
+    if (lane & SelectiveHydrationLane) {
+      return 'SelectiveHydration';
+    }
+    if (lane & IdleHydrationLane) {
+      return 'IdleHydration';
+    }
+    if (lane & IdleLane) {
+      return 'Idle';
+    }
+    if (lane & OffscreenLane) {
+      return 'Offscreen';
+    }
+  }
+}
+
+export const NoTimestamp = -1;
+
+let nextTransitionLane: Lane = TransitionLane1;
+let nextRetryLane: Lane = RetryLane1;
+
+function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
+  switch (getHighestPriorityLane(lanes)) {
+    case SyncHydrationLane:
+      return SyncHydrationLane;
+    case SyncLane:
+      return SyncLane;
+    case InputContinuousHydrationLane:
+      return InputContinuousHydrationLane;
+    case InputContinuousLane:
+      return InputContinuousLane;
+    case DefaultHydrationLane:
+      return DefaultHydrationLane;
+    case DefaultLane:
+      return DefaultLane;
+    case TransitionHydrationLane:
+      return TransitionHydrationLane;
+    case TransitionLane1:
+    case TransitionLane2:
+    case TransitionLane3:
+    case TransitionLane4:
+    case TransitionLane5:
+    case TransitionLane6:
+    case TransitionLane7:
+    case TransitionLane8:
+    case TransitionLane9:
+    case TransitionLane10:
+    case TransitionLane11:
+    case TransitionLane12:
+    case TransitionLane13:
+    case TransitionLane14:
+    case TransitionLane15:
+    case TransitionLane16:
+      return lanes & TransitionLanes;
+    case RetryLane1:
+    case RetryLane2:
+    case RetryLane3:
+    case RetryLane4:
+      return lanes & RetryLanes;
+    case SelectiveHydrationLane:
+      return SelectiveHydrationLane;
+    case IdleHydrationLane:
+      return IdleHydrationLane;
+    case IdleLane:
+      return IdleLane;
+    case OffscreenLane:
+      return OffscreenLane;
+    default:
+      if (__DEV__) {
+        console.error(
+          'Should have found matching lanes. This is a bug in React.',
+        );
+      }
+      // This shouldn't be reachable, but as a fallback, return the entire bitmask.
+      return lanes;
+  }
+}
+
+export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
+  // Early bailout if there's no pending work left.
+  const pendingLanes = root.pendingLanes;
+  if (pendingLanes === NoLanes) {
+    return NoLanes;
+  }
+
+  let nextLanes = NoLanes;
+
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+
+  // Do not work on any idle work until all the non-idle work has finished,
+  // even if the work is suspended.
+  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
+  if (nonIdlePendingLanes !== NoLanes) {
+    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
+    if (nonIdleUnblockedLanes !== NoLanes) {
+      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
+    } else {
+      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
+      if (nonIdlePingedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
+      }
+    }
+  } else {
+    // The only remaining work is Idle.
+    const unblockedLanes = pendingLanes & ~suspendedLanes;
+    if (unblockedLanes !== NoLanes) {
+      nextLanes = getHighestPriorityLanes(unblockedLanes);
+    } else {
+      if (pingedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(pingedLanes);
+      }
+    }
+  }
+
+  if (nextLanes === NoLanes) {
+    // This should only be reachable if we're suspended
+    // TODO: Consider warning in this path if a fallback timer is not scheduled.
+    return NoLanes;
+  }
+
+  // If we're already in the middle of a render, switching lanes will interrupt
+  // it and we'll lose our progress. We should only do this if the new lanes are
+  // higher priority.
+  if (
+    wipLanes !== NoLanes &&
+    wipLanes !== nextLanes &&
+    // If we already suspended with a delay, then interrupting is fine. Don't
+    // bother waiting until the root is complete.
+    (wipLanes & suspendedLanes) === NoLanes
+  ) {
+    const nextLane = getHighestPriorityLane(nextLanes);
+    const wipLane = getHighestPriorityLane(wipLanes);
+    if (
+      // Tests whether the next lane is equal or lower priority than the wip
+      // one. This works because the bits decrease in priority as you go left.
+      nextLane >= wipLane ||
+      // Default priority updates should not interrupt transition updates. The
+      // only difference between default updates and transition updates is that
+      // default updates do not support refresh transitions.
+      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)
+    ) {
+      // Keep working on the existing in-progress tree. Do not interrupt.
+      return wipLanes;
+    }
+  }
+
+  if (
+    allowConcurrentByDefault &&
+    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
+  ) {
+    // Do nothing, use the lanes as they were assigned.
+  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {
+    // When updates are sync by default, we entangle continuous priority updates
+    // and default updates, so they render in the same batch. The only reason
+    // they use separate lanes is because continuous updates should interrupt
+    // transitions, but default updates should not.
+    nextLanes |= pendingLanes & DefaultLane;
+  }
+
+  // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  // TODO: Reconsider this. The counter-argument is that the partial work
+  // represents an intermediate state, which we don't want to show to the user.
+  // And by spending extra time finishing it, we're increasing the amount of
+  // time it takes to show the final state, which is what they are actually
+  // waiting for.
+  //
+  // For those exceptions where entanglement is semantically important, like
+  // useMutableSource, we should ensure that there is no partial work at the
+  // time we apply the entanglement.
+  const entangledLanes = root.entangledLanes;
+  if (entangledLanes !== NoLanes) {
+    const entanglements = root.entanglements;
+    let lanes = nextLanes & entangledLanes;
+    while (lanes > 0) {
+      const index = pickArbitraryLaneIndex(lanes);
+      const lane = 1 << index;
+
+      nextLanes |= entanglements[index];
+
+      lanes &= ~lane;
+    }
+  }
+
+  return nextLanes;
+}
+
+export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
+  const eventTimes = root.eventTimes;
+
+  let mostRecentEventTime = NoTimestamp;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    const eventTime = eventTimes[index];
+    if (eventTime > mostRecentEventTime) {
+      mostRecentEventTime = eventTime;
+    }
+
+    lanes &= ~lane;
+  }
+
+  return mostRecentEventTime;
+}
+
+function computeExpirationTime(lane: Lane, currentTime: number) {
+  switch (lane) {
+    case SyncHydrationLane:
+    case SyncLane:
+    case InputContinuousHydrationLane:
+    case InputContinuousLane:
+      // User interactions should expire slightly more quickly.
+      //
+      // NOTE: This is set to the corresponding constant as in Scheduler.js.
+      // When we made it larger, a product metric in www regressed, suggesting
+      // there's a user interaction that's being starved by a series of
+      // synchronous updates. If that theory is correct, the proper solution is
+      // to fix the starvation. However, this scenario supports the idea that
+      // expiration times are an important safeguard when starvation
+      // does happen.
+      return currentTime + 250;
+    case DefaultHydrationLane:
+    case DefaultLane:
+    case TransitionHydrationLane:
+    case TransitionLane1:
+    case TransitionLane2:
+    case TransitionLane3:
+    case TransitionLane4:
+    case TransitionLane5:
+    case TransitionLane6:
+    case TransitionLane7:
+    case TransitionLane8:
+    case TransitionLane9:
+    case TransitionLane10:
+    case TransitionLane11:
+    case TransitionLane12:
+    case TransitionLane13:
+    case TransitionLane14:
+    case TransitionLane15:
+    case TransitionLane16:
+      return currentTime + 5000;
+    case RetryLane1:
+    case RetryLane2:
+    case RetryLane3:
+    case RetryLane4:
+      // TODO: Retries should be allowed to expire if they are CPU bound for
+      // too long, but when I made this change it caused a spike in browser
+      // crashes. There must be some other underlying bug; not super urgent but
+      // ideally should figure out why and fix it. Unfortunately we don't have
+      // a repro for the crashes, only detected via production metrics.
+      return NoTimestamp;
+    case SelectiveHydrationLane:
+    case IdleHydrationLane:
+    case IdleLane:
+    case OffscreenLane:
+      // Anything idle priority or lower should never expire.
+      return NoTimestamp;
+    default:
+      if (__DEV__) {
+        console.error(
+          'Should have found matching lanes. This is a bug in React.',
+        );
+      }
+      return NoTimestamp;
+  }
+}
+
+export function markStarvedLanesAsExpired(
+  root: FiberRoot,
+  currentTime: number,
+): void {
+  // TODO: This gets called every time we yield. We can optimize by storing
+  // the earliest expiration time on the root. Then use that to quickly bail out
+  // of this function.
+
+  const pendingLanes = root.pendingLanes;
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+  const expirationTimes = root.expirationTimes;
+
+  // Iterate through the pending lanes and check if we've reached their
+  // expiration time. If so, we'll assume the update is being starved and mark
+  // it as expired to force it to finish.
+  //
+  // We exclude retry lanes because those must always be time sliced, in order
+  // to unwrap uncached promises.
+  // TODO: Write a test for this
+  let lanes = pendingLanes & ~RetryLanes;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    const expirationTime = expirationTimes[index];
+    if (expirationTime === NoTimestamp) {
+      // Found a pending lane with no expiration time. If it's not suspended, or
+      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
+      // using the current time.
+      if (
+        (lane & suspendedLanes) === NoLanes ||
+        (lane & pingedLanes) !== NoLanes
+      ) {
+        // Assumes timestamps are monotonically increasing.
+        expirationTimes[index] = computeExpirationTime(lane, currentTime);
+      }
+    } else if (expirationTime <= currentTime) {
+      // This lane expired
+      root.expiredLanes |= lane;
+    }
+
+    lanes &= ~lane;
+  }
+}
+
+// This returns the highest priority pending lanes regardless of whether they
+// are suspended.
+export function getHighestPriorityPendingLanes(root: FiberRoot): Lanes {
+  return getHighestPriorityLanes(root.pendingLanes);
+}
+
+export function getLanesToRetrySynchronouslyOnError(
+  root: FiberRoot,
+  originallyAttemptedLanes: Lanes,
+): Lanes {
+  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {
+    // The error recovery mechanism is disabled until these lanes are cleared.
+    return NoLanes;
+  }
+
+  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
+  if (everythingButOffscreen !== NoLanes) {
+    return everythingButOffscreen;
+  }
+  if (everythingButOffscreen & OffscreenLane) {
+    return OffscreenLane;
+  }
+  return NoLanes;
+}
+
+export function includesSyncLane(lanes: Lanes): boolean {
+  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
+}
+
+export function includesNonIdleWork(lanes: Lanes): boolean {
+  return (lanes & NonIdleLanes) !== NoLanes;
+}
+export function includesOnlyRetries(lanes: Lanes): boolean {
+  return (lanes & RetryLanes) === lanes;
+}
+export function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {
+  // TODO: Should hydration lanes be included here? This function is only
+  // used in `updateDeferredValueImpl`.
+  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
+  return (lanes & UrgentLanes) === NoLanes;
+}
+export function includesOnlyTransitions(lanes: Lanes): boolean {
+  return (lanes & TransitionLanes) === lanes;
+}
+
+export function includesBlockingLane(root: FiberRoot, lanes: Lanes): boolean {
+  if (
+    allowConcurrentByDefault &&
+    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
+  ) {
+    // Concurrent updates by default always use time slicing.
+    return false;
+  }
+  const SyncDefaultLanes =
+    InputContinuousHydrationLane |
+    InputContinuousLane |
+    DefaultHydrationLane |
+    DefaultLane;
+  return (lanes & SyncDefaultLanes) !== NoLanes;
+}
+
+export function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {
+  // This is a separate check from includesBlockingLane because a lane can
+  // expire after a render has already started.
+  return (lanes & root.expiredLanes) !== NoLanes;
+}
+
+export function isTransitionLane(lane: Lane): boolean {
+  return (lane & TransitionLanes) !== NoLanes;
+}
+
+export function claimNextTransitionLane(): Lane {
+  // Cycle through the lanes, assigning each new transition to the next lane.
+  // In most cases, this means every transition gets its own lane, until we
+  // run out of lanes and cycle back to the beginning.
+  const lane = nextTransitionLane;
+  nextTransitionLane <<= 1;
+  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
+    nextTransitionLane = TransitionLane1;
+  }
+  return lane;
+}
+
+export function claimNextRetryLane(): Lane {
+  const lane = nextRetryLane;
+  nextRetryLane <<= 1;
+  if ((nextRetryLane & RetryLanes) === NoLanes) {
+    nextRetryLane = RetryLane1;
+  }
+  return lane;
+}
+
+export function getHighestPriorityLane(lanes: Lanes): Lane {
+  return lanes & -lanes;
+}
+
+export function pickArbitraryLane(lanes: Lanes): Lane {
+  // This wrapper function gets inlined. Only exists so to communicate that it
+  // doesn't matter which bit is selected; you can pick any bit without
+  // affecting the algorithms where its used. Here I'm using
+  // getHighestPriorityLane because it requires the fewest operations.
+  return getHighestPriorityLane(lanes);
+}
+
+function pickArbitraryLaneIndex(lanes: Lanes) {
+  return 31 - clz32(lanes);
+}
+
+function laneToIndex(lane: Lane) {
+  return pickArbitraryLaneIndex(lane);
+}
+
+export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {
+  return (a & b) !== NoLanes;
+}
+
+export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {
+  return (set & subset) === subset;
+}
+
+export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
+  return a | b;
+}
+
+export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
+  return set & ~subset;
+}
+
+export function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
+  return a & b;
+}
+
+// Seems redundant, but it changes the type from a single lane (used for
+// updates) to a group of lanes (used for flushing work).
+export function laneToLanes(lane: Lane): Lanes {
+  return lane;
+}
+
+export function higherPriorityLane(a: Lane, b: Lane): Lane {
+  // This works because the bit ranges decrease in priority as you go left.
+  return a !== NoLane && a < b ? a : b;
+}
+
+export function createLaneMap<T>(initial: T): LaneMap<T> {
+  // Intentionally pushing one by one.
+  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
+  const laneMap = [];
+  for (let i = 0; i < TotalLanes; i++) {
+    laneMap.push(initial);
+  }
+  return laneMap;
+}
+
+export function markRootUpdated(
+  root: FiberRoot,
+  updateLane: Lane,
+  eventTime: number,
+) {
+  root.pendingLanes |= updateLane;
+
+  // If there are any suspended transitions, it's possible this new update
+  // could unblock them. Clear the suspended lanes so that we can try rendering
+  // them again.
+  //
+  // TODO: We really only need to unsuspend only lanes that are in the
+  // `subtreeLanes` of the updated fiber, or the update lanes of the return
+  // path. This would exclude suspended updates in an unrelated sibling tree,
+  // since there's no way for this update to unblock it.
+  //
+  // We don't do this if the incoming update is idle, because we never process
+  // idle updates until after all the regular updates have finished; there's no
+  // way it could unblock a transition.
+  if (updateLane !== IdleLane) {
+    root.suspendedLanes = NoLanes;
+    root.pingedLanes = NoLanes;
+  }
+
+  const eventTimes = root.eventTimes;
+  const index = laneToIndex(updateLane);
+  // We can always overwrite an existing timestamp because we prefer the most
+  // recent event, and we assume time is monotonically increasing.
+  eventTimes[index] = eventTime;
+}
+
+export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+
+  // The suspended lanes are no longer CPU-bound. Clear their expiration times.
+  const expirationTimes = root.expirationTimes;
+  let lanes = suspendedLanes;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    expirationTimes[index] = NoTimestamp;
+
+    lanes &= ~lane;
+  }
+}
+
+export function markRootPinged(
+  root: FiberRoot,
+  pingedLanes: Lanes,
+  eventTime: number,
+) {
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+}
+
+export function markRootMutableRead(root: FiberRoot, updateLane: Lane) {
+  root.mutableReadLanes |= updateLane & root.pendingLanes;
+}
+
+export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
+  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
+
+  root.pendingLanes = remainingLanes;
+
+  // Let's try everything again
+  root.suspendedLanes = NoLanes;
+  root.pingedLanes = NoLanes;
+
+  root.expiredLanes &= remainingLanes;
+  root.mutableReadLanes &= remainingLanes;
+
+  root.entangledLanes &= remainingLanes;
+
+  root.errorRecoveryDisabledLanes &= remainingLanes;
+
+  const entanglements = root.entanglements;
+  const eventTimes = root.eventTimes;
+  const expirationTimes = root.expirationTimes;
+  const hiddenUpdates = root.hiddenUpdates;
+
+  // Clear the lanes that no longer have pending work
+  let lanes = noLongerPendingLanes;
+  while (lanes > 0) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+
+    entanglements[index] = NoLanes;
+    eventTimes[index] = NoTimestamp;
+    expirationTimes[index] = NoTimestamp;
+
+    const hiddenUpdatesForLane = hiddenUpdates[index];
+    if (hiddenUpdatesForLane !== null) {
+      hiddenUpdates[index] = null;
+      // "Hidden" updates are updates that were made to a hidden component. They
+      // have special logic associated with them because they may be entangled
+      // with updates that occur outside that tree. But once the outer tree
+      // commits, they behave like regular updates.
+      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {
+        const update = hiddenUpdatesForLane[i];
+        if (update !== null) {
+          update.lane &= ~OffscreenLane;
+        }
+      }
+    }
+
+    lanes &= ~lane;
+  }
+}
+
+export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
+  // In addition to entangling each of the given lanes with each other, we also
+  // have to consider _transitive_ entanglements. For each lane that is already
+  // entangled with *any* of the given lanes, that lane is now transitively
+  // entangled with *all* the given lanes.
+  //
+  // Translated: If C is entangled with A, then entangling A with B also
+  // entangles C with B.
+  //
+  // If this is hard to grasp, it might help to intentionally break this
+  // function and look at the tests that fail in ReactTransition-test.js. Try
+  // commenting out one of the conditions below.
+
+  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);
+  const entanglements = root.entanglements;
+  let lanes = rootEntangledLanes;
+  while (lanes) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+    if (
+      // Is this one of the newly entangled lanes?
+      (lane & entangledLanes) |
+      // Is this lane transitively entangled with the newly entangled lanes?
+      (entanglements[index] & entangledLanes)
+    ) {
+      entanglements[index] |= entangledLanes;
+    }
+    lanes &= ~lane;
+  }
+}
+
+export function markHiddenUpdate(
+  root: FiberRoot,
+  update: ConcurrentUpdate,
+  lane: Lane,
+) {
+  const index = laneToIndex(lane);
+  const hiddenUpdates = root.hiddenUpdates;
+  const hiddenUpdatesForLane = hiddenUpdates[index];
+  if (hiddenUpdatesForLane === null) {
+    hiddenUpdates[index] = [update];
+  } else {
+    hiddenUpdatesForLane.push(update);
+  }
+  update.lane = lane | OffscreenLane;
+}
+
+export function getBumpedLaneForHydration(
+  root: FiberRoot,
+  renderLanes: Lanes,
+): Lane {
+  const renderLane = getHighestPriorityLane(renderLanes);
+
+  let lane;
+  switch (renderLane) {
+    case SyncLane:
+      lane = SyncHydrationLane;
+      break;
+    case InputContinuousLane:
+      lane = InputContinuousHydrationLane;
+      break;
+    case DefaultLane:
+      lane = DefaultHydrationLane;
+      break;
+    case TransitionLane1:
+    case TransitionLane2:
+    case TransitionLane3:
+    case TransitionLane4:
+    case TransitionLane5:
+    case TransitionLane6:
+    case TransitionLane7:
+    case TransitionLane8:
+    case TransitionLane9:
+    case TransitionLane10:
+    case TransitionLane11:
+    case TransitionLane12:
+    case TransitionLane13:
+    case TransitionLane14:
+    case TransitionLane15:
+    case TransitionLane16:
+    case RetryLane1:
+    case RetryLane2:
+    case RetryLane3:
+    case RetryLane4:
+      lane = TransitionHydrationLane;
+      break;
+    case IdleLane:
+      lane = IdleHydrationLane;
+      break;
+    default:
+      // Everything else is already either a hydration lane, or shouldn't
+      // be retried at a hydration lane.
+      lane = NoLane;
+      break;
+  }
+
+  // Check if the lane we chose is suspended. If so, that indicates that we
+  // already attempted and failed to hydrate at that level. Also check if we're
+  // already rendering that lane, which is rare but could happen.
+  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
+    // Give up trying to hydrate and fall back to client render.
+    return NoLane;
+  }
+
+  return lane;
+}
+
+export function addFiberToLanesMap(
+  root: FiberRoot,
+  fiber: Fiber,
+  lanes: Lanes | Lane,
+) {
+  if (!enableUpdaterTracking) {
+    return;
+  }
+  if (!isDevToolsPresent) {
+    return;
+  }
+  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
+  while (lanes > 0) {
+    const index = laneToIndex(lanes);
+    const lane = 1 << index;
+
+    const updaters = pendingUpdatersLaneMap[index];
+    updaters.add(fiber);
+
+    lanes &= ~lane;
+  }
+}
+
+export function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {
+  if (!enableUpdaterTracking) {
+    return;
+  }
+  if (!isDevToolsPresent) {
+    return;
+  }
+  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
+  const memoizedUpdaters = root.memoizedUpdaters;
+  while (lanes > 0) {
+    const index = laneToIndex(lanes);
+    const lane = 1 << index;
+
+    const updaters = pendingUpdatersLaneMap[index];
+    if (updaters.size > 0) {
+      updaters.forEach(fiber => {
+        const alternate = fiber.alternate;
+        if (alternate === null || !memoizedUpdaters.has(alternate)) {
+          memoizedUpdaters.add(fiber);
+        }
+      });
+      updaters.clear();
+    }
+
+    lanes &= ~lane;
+  }
+}
+
+export function addTransitionToLanesMap(
+  root: FiberRoot,
+  transition: Transition,
+  lane: Lane,
+) {
+  if (enableTransitionTracing) {
+    const transitionLanesMap = root.transitionLanes;
+    const index = laneToIndex(lane);
+    let transitions = transitionLanesMap[index];
+    if (transitions === null) {
+      transitions = new Set();
+    }
+    transitions.add(transition);
+
+    transitionLanesMap[index] = transitions;
+  }
+}
+
+export function getTransitionsForLanes(
+  root: FiberRoot,
+  lanes: Lane | Lanes,
+): Array<Transition> | null {
+  if (!enableTransitionTracing) {
+    return null;
+  }
+
+  const transitionsForLanes = [];
+  while (lanes > 0) {
+    const index = laneToIndex(lanes);
+    const lane = 1 << index;
+    const transitions = root.transitionLanes[index];
+    if (transitions !== null) {
+      transitions.forEach(transition => {
+        transitionsForLanes.push(transition);
+      });
+    }
+
+    lanes &= ~lane;
+  }
+
+  if (transitionsForLanes.length === 0) {
+    return null;
+  }
+
+  return transitionsForLanes;
+}
+
+export function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {
+  if (!enableTransitionTracing) {
+    return;
+  }
+
+  while (lanes > 0) {
+    const index = laneToIndex(lanes);
+    const lane = 1 << index;
+
+    const transitions = root.transitionLanes[index];
+    if (transitions !== null) {
+      root.transitionLanes[index] = null;
+    }
+
+    lanes &= ~lane;
+  }
+}

commit d807eb52cfd999cfbcb19078a75b15f844e409bb
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Dec 5 16:10:03 2022 -0500

    Revert recent hydration changes (#25812)
    
    We're reverting the stack of changes that this code belongs to in order
    to unblock the sync to Meta's internal codebase. We will attempt to
    re-land once the sync is unblocked.
    
    I have not yet verified that this fixes the error that were reported
    internally. I will do that before landing.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 97a28f8809..7ff44ac9a5 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -36,39 +36,39 @@ export const TotalLanes = 31;
 export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
 export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
 
-export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
-export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
-
-export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
-export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
-
-export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
-export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
-
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
-const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
-const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
-const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
-const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
-const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
-const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
-const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
-const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
-const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
-const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
-const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
-const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
-const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
-const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
-const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
-const TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;
-
-const RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;
-const RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;
-const RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;
-const RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;
-const RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;
+export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
+
+export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
+export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;
+
+export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
+export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;
+
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000001000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000000010000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane15: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane16: Lane = /*                       */ 0b0000000001000000000000000000000;
+
+const RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;
+const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
+const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
+const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
+const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;
+const RetryLane5: Lane = /*                             */ 0b0000100000000000000000000000000;
 
 export const SomeRetryLane: Lane = RetryLane1;
 
@@ -85,9 +85,6 @@ export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000
 // It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {
   if (enableSchedulingProfiler) {
-    if (lane & SyncHydrationLane) {
-      return 'SyncHydrationLane';
-    }
     if (lane & SyncLane) {
       return 'Sync';
     }
@@ -134,8 +131,6 @@ let nextRetryLane: Lane = RetryLane1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   switch (getHighestPriorityLane(lanes)) {
-    case SyncHydrationLane:
-      return SyncHydrationLane;
     case SyncLane:
       return SyncLane;
     case InputContinuousHydrationLane:
@@ -169,6 +164,7 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
+    case RetryLane5:
       return lanes & RetryLanes;
     case SelectiveHydrationLane:
       return SelectiveHydrationLane;
@@ -331,7 +327,6 @@ export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
 
 function computeExpirationTime(lane: Lane, currentTime: number) {
   switch (lane) {
-    case SyncHydrationLane:
     case SyncLane:
     case InputContinuousHydrationLane:
     case InputContinuousLane:
@@ -369,6 +364,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
+    case RetryLane5:
       // TODO: Retries should be allowed to expire if they are CPU bound for
       // too long, but when I made this change it caused a spike in browser
       // crashes. There must be some other underlying bug; not super urgent but
@@ -463,7 +459,7 @@ export function getLanesToRetrySynchronouslyOnError(
 }
 
 export function includesSyncLane(lanes: Lanes): boolean {
-  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
+  return (lanes & SyncLane) !== NoLanes;
 }
 
 export function includesNonIdleWork(lanes: Lanes): boolean {
@@ -473,8 +469,6 @@ export function includesOnlyRetries(lanes: Lanes): boolean {
   return (lanes & RetryLanes) === lanes;
 }
 export function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {
-  // TODO: Should hydration lanes be included here? This function is only
-  // used in `updateDeferredValueImpl`.
   const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
   return (lanes & UrgentLanes) === NoLanes;
 }
@@ -755,9 +749,6 @@ export function getBumpedLaneForHydration(
 
   let lane;
   switch (renderLane) {
-    case SyncLane:
-      lane = SyncHydrationLane;
-      break;
     case InputContinuousLane:
       lane = InputContinuousHydrationLane;
       break;
@@ -784,6 +775,7 @@ export function getBumpedLaneForHydration(
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
+    case RetryLane5:
       lane = TransitionHydrationLane;
       break;
     case IdleLane:

commit fabef7a6b71798fe2477720e59d090a0e74e0009
Author: Tianyu Yao <skyyao@fb.com>
Date:   Thu Dec 15 12:23:53 2022 -0800

    Resubmit Add HydrationSyncLane (#25878)
    
    Depends on #25876
    
    Resubmit #25711 again(previously reverted in #25812), and added the fix
    for unwinding in selective hydration during a hydration on the sync
    lane.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 7ff44ac9a5..97a28f8809 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -36,39 +36,39 @@ export const TotalLanes = 31;
 export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
 export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
 
-export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
-
-export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
-export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;
-
-export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
-export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;
-
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
-const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
-const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;
-const TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;
-const TransitionLane4: Lane = /*                        */ 0b0000000000000000000001000000000;
-const TransitionLane5: Lane = /*                        */ 0b0000000000000000000010000000000;
-const TransitionLane6: Lane = /*                        */ 0b0000000000000000000100000000000;
-const TransitionLane7: Lane = /*                        */ 0b0000000000000000001000000000000;
-const TransitionLane8: Lane = /*                        */ 0b0000000000000000010000000000000;
-const TransitionLane9: Lane = /*                        */ 0b0000000000000000100000000000000;
-const TransitionLane10: Lane = /*                       */ 0b0000000000000001000000000000000;
-const TransitionLane11: Lane = /*                       */ 0b0000000000000010000000000000000;
-const TransitionLane12: Lane = /*                       */ 0b0000000000000100000000000000000;
-const TransitionLane13: Lane = /*                       */ 0b0000000000001000000000000000000;
-const TransitionLane14: Lane = /*                       */ 0b0000000000010000000000000000000;
-const TransitionLane15: Lane = /*                       */ 0b0000000000100000000000000000000;
-const TransitionLane16: Lane = /*                       */ 0b0000000001000000000000000000000;
-
-const RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;
-const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
-const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
-const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
-const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;
-const RetryLane5: Lane = /*                             */ 0b0000100000000000000000000000000;
+export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
+export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
+
+export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
+export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
+
+export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
+export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
+
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
+const TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;
+
+const RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;
+const RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;
+const RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;
+const RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;
+const RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;
 
 export const SomeRetryLane: Lane = RetryLane1;
 
@@ -85,6 +85,9 @@ export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000
 // It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {
   if (enableSchedulingProfiler) {
+    if (lane & SyncHydrationLane) {
+      return 'SyncHydrationLane';
+    }
     if (lane & SyncLane) {
       return 'Sync';
     }
@@ -131,6 +134,8 @@ let nextRetryLane: Lane = RetryLane1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   switch (getHighestPriorityLane(lanes)) {
+    case SyncHydrationLane:
+      return SyncHydrationLane;
     case SyncLane:
       return SyncLane;
     case InputContinuousHydrationLane:
@@ -164,7 +169,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
-    case RetryLane5:
       return lanes & RetryLanes;
     case SelectiveHydrationLane:
       return SelectiveHydrationLane;
@@ -327,6 +331,7 @@ export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
 
 function computeExpirationTime(lane: Lane, currentTime: number) {
   switch (lane) {
+    case SyncHydrationLane:
     case SyncLane:
     case InputContinuousHydrationLane:
     case InputContinuousLane:
@@ -364,7 +369,6 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
-    case RetryLane5:
       // TODO: Retries should be allowed to expire if they are CPU bound for
       // too long, but when I made this change it caused a spike in browser
       // crashes. There must be some other underlying bug; not super urgent but
@@ -459,7 +463,7 @@ export function getLanesToRetrySynchronouslyOnError(
 }
 
 export function includesSyncLane(lanes: Lanes): boolean {
-  return (lanes & SyncLane) !== NoLanes;
+  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
 }
 
 export function includesNonIdleWork(lanes: Lanes): boolean {
@@ -469,6 +473,8 @@ export function includesOnlyRetries(lanes: Lanes): boolean {
   return (lanes & RetryLanes) === lanes;
 }
 export function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {
+  // TODO: Should hydration lanes be included here? This function is only
+  // used in `updateDeferredValueImpl`.
   const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
   return (lanes & UrgentLanes) === NoLanes;
 }
@@ -749,6 +755,9 @@ export function getBumpedLaneForHydration(
 
   let lane;
   switch (renderLane) {
+    case SyncLane:
+      lane = SyncHydrationLane;
+      break;
     case InputContinuousLane:
       lane = InputContinuousHydrationLane;
       break;
@@ -775,7 +784,6 @@ export function getBumpedLaneForHydration(
     case RetryLane2:
     case RetryLane3:
     case RetryLane4:
-    case RetryLane5:
       lane = TransitionHydrationLane;
       break;
     case IdleLane:

commit 5379b6123f171bb48cc8a9c435c11ccb9f8ff0e7
Author: Tianyu Yao <skyyao@fb.com>
Date:   Thu Jan 5 15:21:35 2023 -0800

    Batch sync, default and continuous lanes (#25700)
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn debug-test --watch TestName`, open
    `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    This is the other approach for unifying default and sync lane
    https://github.com/facebook/react/pull/25524.
    The approach in that PR is to merge default and continuous lane into the
    sync lane, and use a new field to track the priority. But there are a
    couple places that field will be needed, and it is difficult to
    correctly reset the field when there is no sync lane.
    
    In this PR we take the other approach that doesn't remove any lane, but
    batch them to get the behavior we want.
    
    
    ## How did you test this change?
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    yarn test
    
    Co-authored-by: Andrew Clark <hi@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 97a28f8809..42b2fc6f9a 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -23,6 +23,7 @@ import {
   enableUpdaterTracking,
   allowConcurrentByDefault,
   enableTransitionTracing,
+  enableUnifiedSyncLane,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
@@ -45,6 +46,8 @@ export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
 export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
 
+export const SyncUpdateLanes: Lane = /*                */ 0b0000000000000000000000000101010;
+
 const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
 const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
 const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
@@ -133,6 +136,12 @@ let nextTransitionLane: Lane = TransitionLane1;
 let nextRetryLane: Lane = RetryLane1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
+  if (enableUnifiedSyncLane) {
+    const pendingSyncLanes = lanes & SyncUpdateLanes;
+    if (pendingSyncLanes !== 0) {
+      return pendingSyncLanes;
+    }
+  }
   switch (getHighestPriorityLane(lanes)) {
     case SyncHydrationLane:
       return SyncHydrationLane;
@@ -754,46 +763,50 @@ export function getBumpedLaneForHydration(
   const renderLane = getHighestPriorityLane(renderLanes);
 
   let lane;
-  switch (renderLane) {
-    case SyncLane:
-      lane = SyncHydrationLane;
-      break;
-    case InputContinuousLane:
-      lane = InputContinuousHydrationLane;
-      break;
-    case DefaultLane:
-      lane = DefaultHydrationLane;
-      break;
-    case TransitionLane1:
-    case TransitionLane2:
-    case TransitionLane3:
-    case TransitionLane4:
-    case TransitionLane5:
-    case TransitionLane6:
-    case TransitionLane7:
-    case TransitionLane8:
-    case TransitionLane9:
-    case TransitionLane10:
-    case TransitionLane11:
-    case TransitionLane12:
-    case TransitionLane13:
-    case TransitionLane14:
-    case TransitionLane15:
-    case TransitionLane16:
-    case RetryLane1:
-    case RetryLane2:
-    case RetryLane3:
-    case RetryLane4:
-      lane = TransitionHydrationLane;
-      break;
-    case IdleLane:
-      lane = IdleHydrationLane;
-      break;
-    default:
-      // Everything else is already either a hydration lane, or shouldn't
-      // be retried at a hydration lane.
-      lane = NoLane;
-      break;
+  if (enableUnifiedSyncLane && (renderLane & SyncUpdateLanes) !== NoLane) {
+    lane = SyncHydrationLane;
+  } else {
+    switch (renderLane) {
+      case SyncLane:
+        lane = SyncHydrationLane;
+        break;
+      case InputContinuousLane:
+        lane = InputContinuousHydrationLane;
+        break;
+      case DefaultLane:
+        lane = DefaultHydrationLane;
+        break;
+      case TransitionLane1:
+      case TransitionLane2:
+      case TransitionLane3:
+      case TransitionLane4:
+      case TransitionLane5:
+      case TransitionLane6:
+      case TransitionLane7:
+      case TransitionLane8:
+      case TransitionLane9:
+      case TransitionLane10:
+      case TransitionLane11:
+      case TransitionLane12:
+      case TransitionLane13:
+      case TransitionLane14:
+      case TransitionLane15:
+      case TransitionLane16:
+      case RetryLane1:
+      case RetryLane2:
+      case RetryLane3:
+      case RetryLane4:
+        lane = TransitionHydrationLane;
+        break;
+      case IdleLane:
+        lane = IdleHydrationLane;
+        break;
+      default:
+        // Everything else is already either a hydration lane, or shouldn't
+        // be retried at a hydration lane.
+        lane = NoLane;
+        break;
+    }
   }
 
   // Check if the lane we chose is suspended. If so, that indicates that we

commit afe6521e134178920f0523ede4c715942d8f0564
Author: Chris <nc_8093@163.com>
Date:   Tue Jan 10 12:25:02 2023 +0800

    Refactor: remove useless parameter (#25923)
    
    ## Summary
    
    I was reading the source code of `ReactFiberLane.js` and I found the
    third parameter of the function markRootPinged was not used. So I think
    we can remove it.
    
    ## How did you test this change?
    
    There is no logic changed, so I think there is no need to add unit
    tests. So I run `yarn test` and `yarn test --prod` locally and all tests
    are passed.
    
    Co-authored-by: Jan Kassens <jkassens@meta.com>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 42b2fc6f9a..45c8810c7f 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -647,11 +647,7 @@ export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
   }
 }
 
-export function markRootPinged(
-  root: FiberRoot,
-  pingedLanes: Lanes,
-  eventTime: number,
-) {
+export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
 }
 

commit 58742c21b8c3237e8b66c7df4e200504846a01ae
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 11 08:23:04 2023 -0400

    Delete unused `eventTimes` Fiber field (#26599)

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 45c8810c7f..835bf01193 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -319,25 +319,6 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   return nextLanes;
 }
 
-export function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {
-  const eventTimes = root.eventTimes;
-
-  let mostRecentEventTime = NoTimestamp;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    const eventTime = eventTimes[index];
-    if (eventTime > mostRecentEventTime) {
-      mostRecentEventTime = eventTime;
-    }
-
-    lanes &= ~lane;
-  }
-
-  return mostRecentEventTime;
-}
-
 function computeExpirationTime(lane: Lane, currentTime: number) {
   switch (lane) {
     case SyncHydrationLane:
@@ -599,11 +580,7 @@ export function createLaneMap<T>(initial: T): LaneMap<T> {
   return laneMap;
 }
 
-export function markRootUpdated(
-  root: FiberRoot,
-  updateLane: Lane,
-  eventTime: number,
-) {
+export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
   root.pendingLanes |= updateLane;
 
   // If there are any suspended transitions, it's possible this new update
@@ -622,12 +599,6 @@ export function markRootUpdated(
     root.suspendedLanes = NoLanes;
     root.pingedLanes = NoLanes;
   }
-
-  const eventTimes = root.eventTimes;
-  const index = laneToIndex(updateLane);
-  // We can always overwrite an existing timestamp because we prefer the most
-  // recent event, and we assume time is monotonically increasing.
-  eventTimes[index] = eventTime;
 }
 
 export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
@@ -672,7 +643,6 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   root.errorRecoveryDisabledLanes &= remainingLanes;
 
   const entanglements = root.entanglements;
-  const eventTimes = root.eventTimes;
   const expirationTimes = root.expirationTimes;
   const hiddenUpdates = root.hiddenUpdates;
 
@@ -683,7 +653,6 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
     const lane = 1 << index;
 
     entanglements[index] = NoLanes;
-    eventTimes[index] = NoTimestamp;
     expirationTimes[index] = NoTimestamp;
 
     const hiddenUpdatesForLane = hiddenUpdates[index];

commit 80d9a40114bb43c07d021e8254790852f450bd2b
Author: Noah Lemen <noah.lemen@gmail.com>
Date:   Tue Jun 27 12:45:46 2023 -0400

    Remove useMutableSource (#27011)
    
    ## Summary
    
    This PR cleans up `useMutableSource`. This has been blocked by a
    remaining dependency internally at Meta, but that has now been deleted.
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    ## How did you test this change?
    
    ```
    yarn flow
    yarn lint
    yarn test --prod
    ```
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 835bf01193..e90b02e441 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -299,8 +299,8 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   // time it takes to show the final state, which is what they are actually
   // waiting for.
   //
-  // For those exceptions where entanglement is semantically important, like
-  // useMutableSource, we should ensure that there is no partial work at the
+  // For those exceptions where entanglement is semantically important,
+  // we should ensure that there is no partial work at the
   // time we apply the entanglement.
   const entangledLanes = root.entangledLanes;
   if (entangledLanes !== NoLanes) {
@@ -622,10 +622,6 @@ export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
 }
 
-export function markRootMutableRead(root: FiberRoot, updateLane: Lane) {
-  root.mutableReadLanes |= updateLane & root.pendingLanes;
-}
-
 export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
 
@@ -636,7 +632,6 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   root.pingedLanes = NoLanes;
 
   root.expiredLanes &= remainingLanes;
-  root.mutableReadLanes &= remainingLanes;
 
   root.entangledLanes &= remainingLanes;
 

commit fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 29 16:05:00 2023 -0400

    Detect crashes caused by Async Client Components (#27019)
    
    Suspending with an uncached promise is not yet supported. We only
    support suspending on promises that are cached between render attempts.
    (We do plan to partially support this in the future, at least in certain
    constrained cases, like during a route transition.)
    
    This includes the case where a component returns an uncached promise,
    which is effectively what happens if a Client Component is authored
    using async/await syntax.
    
    This is an easy mistake to make in a Server Components app, because
    async/await _is_ available in Server Components.
    
    In the current behavior, this can sometimes cause the app to crash with
    an infinite loop, because React will repeatedly keep trying to render
    the component, which will result in a fresh promise, which will result
    in a new render attempt, and so on. We have some strategies we can use
    to prevent this — during a concurrent render, we can suspend the work
    loop until the promise resolves. If it's not a concurrent render, we can
    show a Suspense fallback and try again at concurrent priority.
    
    There's one case where neither of these strategies work, though: during
    a sync render when there's no parent Suspense boundary. (We refer to
    this as the "shell" of the app because it exists outside of any loading
    UI.)
    
    Since we don't have any great options for this scenario, we should at
    least error gracefully instead of crashing the app.
    
    So this commit adds a detection mechanism for render loops caused by
    async client components. The way it works is, if an app suspends
    repeatedly in the shell during a synchronous render, without committing
    anything in between, we will count the number of attempts and eventually
    trigger an error once the count exceeds a threshold.
    
    In the future, we will consider ways to make this case a warning instead
    of a hard error.
    
    See https://github.com/facebook/react/issues/26801 for more details.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index e90b02e441..51126c6cdb 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -636,6 +636,7 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
   root.entangledLanes &= remainingLanes;
 
   root.errorRecoveryDisabledLanes &= remainingLanes;
+  root.shellSuspendCounter = 0;
 
   const entanglements = root.entanglements;
   const expirationTimes = root.expirationTimes;

commit d900fadbf9017063fecb2641b7e99303b82a6f17
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Sep 29 14:29:35 2023 -0400

    Bugfix: Selective hydration triggers false update loop error  (#27439)
    
    This adds a regression test and fix for a case where a sync update
    triggers selective hydration, which then leads to a "Maximum update
    depth exceeded" error, even though there was only a single update. This
    happens when a single sync update flows into many sibling dehydrated
    Suspense boundaries.
    
    This fix is, if a commit was the result of selective hydration, we
    should not increment the nested update count, because those renders
    conceptually are not updates.
    
    Ideally, they wouldn't even be in a separate commit — we should be able
    to hydrate a tree and apply an update on top of it within the same
    render phase. We could do this once we implement resumable context
    stacks.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 51126c6cdb..22d8377fac 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -46,7 +46,9 @@ export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
 export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
 
-export const SyncUpdateLanes: Lane = /*                */ 0b0000000000000000000000000101010;
+export const SyncUpdateLanes: Lane = enableUnifiedSyncLane
+  ? SyncLane | InputContinuousLane | DefaultLane
+  : SyncLane;
 
 const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
 const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
@@ -84,6 +86,11 @@ export const IdleLane: Lane = /*                        */ 0b0100000000000000000
 
 export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
 
+// Any lane that might schedule an update. This is used to detect infinite
+// update loops, so it doesn't include hydration lanes or retries.
+export const UpdateLanes: Lanes =
+  SyncLane | InputContinuousLane | DefaultLane | TransitionLanes;
+
 // This function is used for the experimental timeline (react-devtools-timeline)
 // It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {

commit 309c8ad9688c491e5b17beb07ab01d65594914ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Oct 15 12:29:52 2023 -0400

    Track entangled lanes separately from update lane (#27505)
    
    A small refactor to how the lane entanglement mechanism works. We can
    now distinguish between the lane that "spawned" a render task (i.e. a
    new update) versus the lanes that it's entangled with. Both the update
    lane and the entangled lanes will be included while rendering, but by
    keeping them separate, we don't lose the original priority.
    
    In practical terms, this means we can now entangle a low priority update
    with a higher priority lane while rendering at the lower priority.
    
    To do this, lanes that are entangled at the root are now tracked using
    the same variable that we use to track the "base lanes" when revealing a
    previously hidden tree — conceptually, they are the same thing. I also
    renamed this variable (from subtreeLanes to entangledRenderLanes) to
    better reflect how it's used.
    
    My primary motivation is related to useDeferredValue, which I'll address
    in a later PR.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 22d8377fac..21055ac82f 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -39,6 +39,7 @@ export const NoLane: Lane = /*                          */ 0b0000000000000000000
 
 export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
 export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
+export const SyncLaneIndex: number = 1;
 
 export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
 export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
@@ -274,17 +275,23 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
     }
   }
 
+  return nextLanes;
+}
+
+export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
+  let entangledLanes = renderLanes;
+
   if (
     allowConcurrentByDefault &&
     (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
   ) {
     // Do nothing, use the lanes as they were assigned.
-  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {
+  } else if ((entangledLanes & InputContinuousLane) !== NoLanes) {
     // When updates are sync by default, we entangle continuous priority updates
     // and default updates, so they render in the same batch. The only reason
     // they use separate lanes is because continuous updates should interrupt
     // transitions, but default updates should not.
-    nextLanes |= pendingLanes & DefaultLane;
+    entangledLanes |= entangledLanes & DefaultLane;
   }
 
   // Check for entangled lanes and add them to the batch.
@@ -309,21 +316,21 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   // For those exceptions where entanglement is semantically important,
   // we should ensure that there is no partial work at the
   // time we apply the entanglement.
-  const entangledLanes = root.entangledLanes;
-  if (entangledLanes !== NoLanes) {
+  const allEntangledLanes = root.entangledLanes;
+  if (allEntangledLanes !== NoLanes) {
     const entanglements = root.entanglements;
-    let lanes = nextLanes & entangledLanes;
+    let lanes = entangledLanes & allEntangledLanes;
     while (lanes > 0) {
       const index = pickArbitraryLaneIndex(lanes);
       const lane = 1 << index;
 
-      nextLanes |= entanglements[index];
+      entangledLanes |= entanglements[index];
 
       lanes &= ~lane;
     }
   }
 
-  return nextLanes;
+  return entangledLanes;
 }
 
 function computeExpirationTime(lane: Lane, currentTime: number) {
@@ -404,6 +411,7 @@ export function markStarvedLanesAsExpired(
   // Iterate through the pending lanes and check if we've reached their
   // expiration time. If so, we'll assume the update is being starved and mark
   // it as expired to force it to finish.
+  // TODO: We should be able to replace this with upgradePendingLanesToSync
   //
   // We exclude retry lanes because those must always be time sliced, in order
   // to unwrap uncached promises.
@@ -708,6 +716,34 @@ export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
   }
 }
 
+export function upgradePendingLaneToSync(root: FiberRoot, lane: Lane) {
+  // Since we're upgrading the priority of the given lane, there is now pending
+  // sync work.
+  root.pendingLanes |= SyncLane;
+
+  // Entangle the sync lane with the lane we're upgrading. This means SyncLane
+  // will not be allowed to finish without also finishing the given lane.
+  root.entangledLanes |= SyncLane;
+  root.entanglements[SyncLaneIndex] |= lane;
+}
+
+export function upgradePendingLanesToSync(
+  root: FiberRoot,
+  lanesToUpgrade: Lanes,
+) {
+  // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a
+  // bit slower.
+  root.pendingLanes |= SyncLane;
+  root.entangledLanes |= SyncLane;
+  let lanes = lanesToUpgrade;
+  while (lanes) {
+    const index = pickArbitraryLaneIndex(lanes);
+    const lane = 1 << index;
+    root.entanglements[SyncLaneIndex] |= lane;
+    lanes &= ~lane;
+  }
+}
+
 export function markHiddenUpdate(
   root: FiberRoot,
   update: ConcurrentUpdate,

commit b2a68a65c84b63ac86930d88ae5c84380cbbdeb6
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 17 12:48:11 2023 -0400

    useDeferredValue should skip initialValue if it suspends (#27509)
    
    ### Based on https://github.com/facebook/react/pull/27505
    
    If a parent render spawns a deferred task with useDeferredValue, but the
    parent render suspends, we should not wait for the parent render to
    complete before attempting to render the final value.
    
    The reason is that the initialValue argument to useDeferredValue is
    meant to represent an immediate preview of the final UI. If we can't
    render it "immediately", we might as well skip it and go straight to the
    "real" value.
    
    This is an improvement over how a userspace implementation of
    useDeferredValue would work, because a userspace implementation would
    have to wait for the parent task to commit (useEffect) before spawning
    the deferred task, creating a waterfall.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 21055ac82f..864edf6ee6 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -52,7 +52,7 @@ export const SyncUpdateLanes: Lane = enableUnifiedSyncLane
   : SyncLane;
 
 const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111110000000;
 const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
 const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
 const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
@@ -68,24 +68,24 @@ const TransitionLane12: Lane = /*                       */ 0b0000000000001000000
 const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
 const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
 const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
-const TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;
 
-const RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;
-const RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;
-const RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;
-const RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;
-const RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;
+const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
+const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
+const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
+const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
+const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;
 
 export const SomeRetryLane: Lane = RetryLane1;
 
-export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
+export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
 
-const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
+const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;
 
-export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
-export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
+export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
+export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;
 
-export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
+export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;
+export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;
 
 // Any lane that might schedule an update. This is used to detect infinite
 // update loops, so it doesn't include hydration lanes or retries.
@@ -135,6 +135,9 @@ export function getLabelForLane(lane: Lane): string | void {
     if (lane & OffscreenLane) {
       return 'Offscreen';
     }
+    if (lane & DeferredLane) {
+      return 'Deferred';
+    }
   }
 }
 
@@ -180,7 +183,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case TransitionLane13:
     case TransitionLane14:
     case TransitionLane15:
-    case TransitionLane16:
       return lanes & TransitionLanes;
     case RetryLane1:
     case RetryLane2:
@@ -195,6 +197,10 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return IdleLane;
     case OffscreenLane:
       return OffscreenLane;
+    case DeferredLane:
+      // This shouldn't be reachable because deferred work is always entangled
+      // with something else.
+      return NoLanes;
     default:
       if (__DEV__) {
         console.error(
@@ -367,7 +373,6 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case TransitionLane13:
     case TransitionLane14:
     case TransitionLane15:
-    case TransitionLane16:
       return currentTime + 5000;
     case RetryLane1:
     case RetryLane2:
@@ -383,6 +388,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case IdleHydrationLane:
     case IdleLane:
     case OffscreenLane:
+    case DeferredLane:
       // Anything idle priority or lower should never expire.
       return NoTimestamp;
     default:
@@ -616,7 +622,11 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
   }
 }
 
-export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
+export function markRootSuspended(
+  root: FiberRoot,
+  suspendedLanes: Lanes,
+  spawnedLane: Lane,
+) {
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
@@ -631,13 +641,21 @@ export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
 
     lanes &= ~lane;
   }
+
+  if (spawnedLane !== NoLane) {
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+  }
 }
 
 export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
 }
 
-export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
+export function markRootFinished(
+  root: FiberRoot,
+  remainingLanes: Lanes,
+  spawnedLane: Lane,
+) {
   const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
 
   root.pendingLanes = remainingLanes;
@@ -683,6 +701,37 @@ export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
 
     lanes &= ~lane;
   }
+
+  if (spawnedLane !== NoLane) {
+    markSpawnedDeferredLane(
+      root,
+      spawnedLane,
+      // This render finished successfully without suspending, so we don't need
+      // to entangle the spawned task with the parent task.
+      NoLanes,
+    );
+  }
+}
+
+function markSpawnedDeferredLane(
+  root: FiberRoot,
+  spawnedLane: Lane,
+  entangledLanes: Lanes,
+) {
+  // This render spawned a deferred task. Mark it as pending.
+  root.pendingLanes |= spawnedLane;
+  root.suspendedLanes &= ~spawnedLane;
+
+  // Entangle the spawned lane with the DeferredLane bit so that we know it
+  // was the result of another render. This lets us avoid a useDeferredValue
+  // waterfall — only the first level will defer.
+  const spawnedLaneIndex = laneToIndex(spawnedLane);
+  root.entangledLanes |= spawnedLane;
+  root.entanglements[spawnedLaneIndex] |=
+    DeferredLane |
+    // If the parent render task suspended, we must also entangle those lanes
+    // with the spawned task.
+    entangledLanes;
 }
 
 export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
@@ -795,7 +844,6 @@ export function getBumpedLaneForHydration(
       case TransitionLane13:
       case TransitionLane14:
       case TransitionLane15:
-      case TransitionLane16:
       case RetryLane1:
       case RetryLane2:
       case RetryLane3:

commit 779d59374e8e852ce00728d895156a7574e1b456
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Oct 23 10:48:48 2023 -0700

    useDeferredValue has higher priority than partial hydration (#27550)
    
    By default, partial hydration is given the lowest possible priority,
    because until a tree is updated, the server-rendered HTML is assumed to
    match the final resolved HTML.
    
    However, this isn't completely true because a component may choose to
    "upgrade" itself upon hydration. The simplest example is a component
    that calls setState in a useEffect to switch to a richer implementation
    of the UI. Another example is a component that doesn't have a server-
    rendered implementation, so it intentionally suspends to force a client-
    only render.
    
    useDeferredValue is an example, too: the server only renders the first
    pass (the initialValue) argument, and relies on the client to upgrade to
    the final value.
    
    What we should really do in these cases is emit some information into
    the Fizz stream so that Fiber knows to prioritize the hydration of
    certain trees. We plan to add a mechanism for this in the future.
    
    In the meantime, though, we can at least ensure that the priority of the
    upgrade task is correct once it's "discovered" during hydration. In this
    case, the priority of the task spawned by useDeferredValue should have
    Transition priority, not Offscreen priority.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 864edf6ee6..75bf09dc01 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -730,8 +730,10 @@ function markSpawnedDeferredLane(
   root.entanglements[spawnedLaneIndex] |=
     DeferredLane |
     // If the parent render task suspended, we must also entangle those lanes
-    // with the spawned task.
-    entangledLanes;
+    // with the spawned task, so that the deferred task includes all the same
+    // updates that the parent task did. We can exclude any lane that is not
+    // used for updates (e.g. Offscreen).
+    (entangledLanes & UpdateLanes);
 }
 
 export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {

commit 593ecee66a609d4a4c2b36b39b1e5e23b2456dd1
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Nov 14 10:15:17 2023 -0500

    Add a feature flag to enable expiration of retry lanes (#27694)
    
    An attempt to see if we can bring back expiration of retry lanes to
    avoid cases resolving Suspense can be starved by frequent updates.
    
    In the past, this caused increase browser crashes, but a lot of time has
    passed since then. Just trying if we can re-enable this.
    
    Old PR that reverted adding the timeout:
    https://github.com/facebook/react/pull/21300

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 75bf09dc01..905eda36a9 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -19,11 +19,12 @@ export type Lane = number;
 export type LaneMap<T> = Array<T>;
 
 import {
-  enableSchedulingProfiler,
-  enableUpdaterTracking,
   allowConcurrentByDefault,
+  enableRetryLaneExpiration,
+  enableSchedulingProfiler,
   enableTransitionTracing,
   enableUnifiedSyncLane,
+  enableUpdaterTracking,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
@@ -383,7 +384,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
       // crashes. There must be some other underlying bug; not super urgent but
       // ideally should figure out why and fix it. Unfortunately we don't have
       // a repro for the crashes, only detected via production metrics.
-      return NoTimestamp;
+      return enableRetryLaneExpiration ? currentTime + 5000 : NoTimestamp;
     case SelectiveHydrationLane:
     case IdleHydrationLane:
     case IdleLane:

commit f193213d29e7fabf68b21951c4b96701aeaecbf8
Author: Tianyu Yao <skyyao@fb.com>
Date:   Fri Dec 8 09:21:36 2023 -0800

    Add a regression test for an infinite suspense + Fix (#27703)
    
    Add a regression test for the [minimal
    repro](https://codesandbox.io/s/react-18-suspense-state-never-resolving-bug-hmlny5?file=/src/App.js)
    from @kassens
    
    And includes the fix from @acdlite:
    > This is another place we special-case Retry lanes to opt them out of
    expiration. The reason is we rely on time slicing to unwrap uncached
    promises (i.e. async functions during render). Since that ability is
    still experimental, and enableRetryLaneExpiration is Meta-only, we can
    remove the special case when enableRetryLaneExpiration is on, for now.
    
    ---------
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 905eda36a9..c110b29c25 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -423,7 +423,9 @@ export function markStarvedLanesAsExpired(
   // We exclude retry lanes because those must always be time sliced, in order
   // to unwrap uncached promises.
   // TODO: Write a test for this
-  let lanes = pendingLanes & ~RetryLanes;
+  let lanes = enableRetryLaneExpiration
+    ? pendingLanes
+    : pendingLanes & ~RetryLanes;
   while (lanes > 0) {
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;

commit 0cdfef19b96cc6202d48e0812b5069c286d12b04
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Dec 11 09:58:18 2023 -0500

    Add feature flags for expiration times (#27821)
    
    It seems worthwhile to me to run a test to experiment with different
    expiration times. This moves the expiration times for scheduler and
    reconciler into FeatureFlags for the facebook build. Non-facebook should
    not be affected by these changes.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index c110b29c25..7e056f2e71 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -25,6 +25,9 @@ import {
   enableTransitionTracing,
   enableUnifiedSyncLane,
   enableUpdaterTracking,
+  syncLaneExpirationMs,
+  transitionLaneExpirationMs,
+  retryLaneExpirationMs,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
@@ -355,7 +358,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
       // to fix the starvation. However, this scenario supports the idea that
       // expiration times are an important safeguard when starvation
       // does happen.
-      return currentTime + 250;
+      return currentTime + syncLaneExpirationMs;
     case DefaultHydrationLane:
     case DefaultLane:
     case TransitionHydrationLane:
@@ -374,7 +377,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case TransitionLane13:
     case TransitionLane14:
     case TransitionLane15:
-      return currentTime + 5000;
+      return currentTime + transitionLaneExpirationMs;
     case RetryLane1:
     case RetryLane2:
     case RetryLane3:
@@ -384,7 +387,9 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
       // crashes. There must be some other underlying bug; not super urgent but
       // ideally should figure out why and fix it. Unfortunately we don't have
       // a repro for the crashes, only detected via production metrics.
-      return enableRetryLaneExpiration ? currentTime + 5000 : NoTimestamp;
+      return enableRetryLaneExpiration
+        ? currentTime + retryLaneExpirationMs
+        : NoTimestamp;
     case SelectiveHydrationLane:
     case IdleHydrationLane:
     case IdleLane:

commit 8e1462e8c471fbec98aac2b3e1326498d0ff7139
Author: Josh Story <story@hey.com>
Date:   Mon Apr 8 08:53:17 2024 -0700

    [Fiber] Move updatePriority tracking to renderers (#28751)
    
    Currently updatePriority is tracked in the reconciler. `flushSync` is
    going to be implemented reconciler agnostic soon and we need to move the
    tracking of this state to the renderer and out of reconciler. This
    change implements new renderer bin dings for getCurrentUpdatePriority
    and setCurrentUpdatePriority.
    
    I was originally going to have the getter also do the event priority
    defaulting using window.event so we eliminate getCur rentEventPriority
    but this makes all the callsites where we store the true current
    updatePriority on the stack harder to work with so for now they remain
    separate.
    
    I also moved runWithPriority to the renderer since it really belongs
    whereever the state is being managed and it is only currently exposed in
    the DOM renderer.
    
    Additionally the current update priority is not stored on
    ReactDOMSharedInternals. While not particularly meaningful in this
    change it opens the door to implementing `flushSync` outside of the
    reconciler

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 7e056f2e71..cde23ef9a6 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -223,7 +223,7 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
     return NoLanes;
   }
 
-  let nextLanes = NoLanes;
+  let nextLanes: Lanes = NoLanes;
 
   const suspendedLanes = root.suspendedLanes;
   const pingedLanes = root.pingedLanes;

commit c21bcd627b6a8f31548edfc149dd3b879fea6558
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Jun 24 11:18:22 2024 -0400

    Clean up enableUnifiedSyncLane flag (#30062)
    
    `enableUnifiedSyncLane` now passes everywhere. Let's clean it up
    
    Implemented with https://github.com/facebook/react/pull/27646
    
    Flag enabled with https://github.com/facebook/react/pull/27646,
    https://github.com/facebook/react/pull/28269,
    https://github.com/facebook/react/pull/29052

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index cde23ef9a6..7b81c406cf 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -23,7 +23,6 @@ import {
   enableRetryLaneExpiration,
   enableSchedulingProfiler,
   enableTransitionTracing,
-  enableUnifiedSyncLane,
   enableUpdaterTracking,
   syncLaneExpirationMs,
   transitionLaneExpirationMs,
@@ -51,9 +50,8 @@ export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
 export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
 
-export const SyncUpdateLanes: Lane = enableUnifiedSyncLane
-  ? SyncLane | InputContinuousLane | DefaultLane
-  : SyncLane;
+export const SyncUpdateLanes: Lane =
+  SyncLane | InputContinuousLane | DefaultLane;
 
 const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
 const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111110000000;
@@ -151,11 +149,9 @@ let nextTransitionLane: Lane = TransitionLane1;
 let nextRetryLane: Lane = RetryLane1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
-  if (enableUnifiedSyncLane) {
-    const pendingSyncLanes = lanes & SyncUpdateLanes;
-    if (pendingSyncLanes !== 0) {
-      return pendingSyncLanes;
-    }
+  const pendingSyncLanes = lanes & SyncUpdateLanes;
+  if (pendingSyncLanes !== 0) {
+    return pendingSyncLanes;
   }
   switch (getHighestPriorityLane(lanes)) {
     case SyncHydrationLane:
@@ -826,7 +822,7 @@ export function getBumpedLaneForHydration(
   const renderLane = getHighestPriorityLane(renderLanes);
 
   let lane;
-  if (enableUnifiedSyncLane && (renderLane & SyncUpdateLanes) !== NoLane) {
+  if ((renderLane & SyncUpdateLanes) !== NoLane) {
     lane = SyncHydrationLane;
   } else {
     switch (renderLane) {

commit 14a4699ff173936a30ec453f7b94d47105bbb252
Author: Jack Pope <jackpope1@gmail.com>
Date:   Thu Jul 25 11:59:50 2024 -0400

    Remove allowConcurrentByDefault flag (#30445)
    
    Following https://github.com/facebook/react/pull/30436
    
    Concurrent by default strategy has been unshipped. Here we clean up the
    `allowConcurrentByDefault` path and related logic/tests.
    
    For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
    `createContainer` and `createHydrationContainer` and ignores the value
    to prevent more breaking changes to `react-reconciler` in the RC stage.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 7b81c406cf..f34f1aeccd 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -19,7 +19,6 @@ export type Lane = number;
 export type LaneMap<T> = Array<T>;
 
 import {
-  allowConcurrentByDefault,
   enableRetryLaneExpiration,
   enableSchedulingProfiler,
   enableTransitionTracing,
@@ -29,7 +28,6 @@ import {
   retryLaneExpirationMs,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
-import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
 import {clz32} from './clz32';
 
 // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.
@@ -287,12 +285,7 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
 export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
   let entangledLanes = renderLanes;
 
-  if (
-    allowConcurrentByDefault &&
-    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
-  ) {
-    // Do nothing, use the lanes as they were assigned.
-  } else if ((entangledLanes & InputContinuousLane) !== NoLanes) {
+  if ((entangledLanes & InputContinuousLane) !== NoLanes) {
     // When updates are sync by default, we entangle continuous priority updates
     // and default updates, so they render in the same batch. The only reason
     // they use separate lanes is because continuous updates should interrupt
@@ -498,13 +491,6 @@ export function includesOnlyTransitions(lanes: Lanes): boolean {
 }
 
 export function includesBlockingLane(root: FiberRoot, lanes: Lanes): boolean {
-  if (
-    allowConcurrentByDefault &&
-    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
-  ) {
-    // Concurrent updates by default always use time slicing.
-    return false;
-  }
   const SyncDefaultLanes =
     InputContinuousHydrationLane |
     InputContinuousLane |

commit ee7f6757c446c4e79ecc7e2bc22b8c9b712834b7
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 23 12:30:08 2024 -0400

    Fix: Synchronous popstate transitions (#30759)
    
    This is a refactor of the fix in #27505.
    
    When a transition update is scheduled by a popstate event, (i.e. a back/
    forward navigation) we attempt to render it synchronously even though
    it's a transition, since it's likely the previous page's data is cached.
    
    In #27505, I changed the implementation so that it only "upgrades" the
    priority of the transition for a single attempt. If the attempt
    suspends, say because the data is not cached after all, from then on it
    should be treated as a normal transition.
    
    But it turns out #27505 did not work as intended, because it relied on
    marking the root with pending synchronous work (root.pendingLanes),
    which was never cleared until the popstate update completed.
    
    The test scenarios I wrote accidentally worked for a different reason
    related to suspending the work loop, which I'm currently in the middle
    of refactoring.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index f34f1aeccd..6ed4caae70 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -92,6 +92,14 @@ export const DeferredLane: Lane = /*                    */ 0b1000000000000000000
 export const UpdateLanes: Lanes =
   SyncLane | InputContinuousLane | DefaultLane | TransitionLanes;
 
+export const HydrationLanes =
+  SyncHydrationLane |
+  InputContinuousHydrationLane |
+  DefaultHydrationLane |
+  TransitionHydrationLane |
+  SelectiveHydrationLane |
+  IdleHydrationLane;
+
 // This function is used for the experimental timeline (react-devtools-timeline)
 // It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {
@@ -282,6 +290,51 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   return nextLanes;
 }
 
+export function getNextLanesToFlushSync(
+  root: FiberRoot,
+  extraLanesToForceSync: Lane | Lanes,
+): Lanes {
+  // Similar to getNextLanes, except instead of choosing the next lanes to work
+  // on based on their priority, it selects all the lanes that have equal or
+  // higher priority than those are given. That way they can be synchronously
+  // rendered in a single batch.
+  //
+  // The main use case is updates scheduled by popstate events, which are
+  // flushed synchronously even though they are transitions.
+  const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;
+
+  // Early bailout if there's no pending work left.
+  const pendingLanes = root.pendingLanes;
+  if (pendingLanes === NoLanes) {
+    return NoLanes;
+  }
+
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+
+  // Remove lanes that are suspended (but not pinged)
+  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
+  const unblockedLanesWithMatchingPriority =
+    unblockedLanes & getLanesOfEqualOrHigherPriority(lanesToFlush);
+
+  // If there are matching hydration lanes, we should do those by themselves.
+  // Hydration lanes must never include updates.
+  if (unblockedLanesWithMatchingPriority & HydrationLanes) {
+    return (
+      (unblockedLanesWithMatchingPriority & HydrationLanes) | SyncHydrationLane
+    );
+  }
+
+  if (unblockedLanesWithMatchingPriority) {
+    // Always include the SyncLane as part of the result, even if there's no
+    // pending sync work, to indicate the priority of the entire batch of work
+    // is considered Sync.
+    return unblockedLanesWithMatchingPriority | SyncLane;
+  }
+
+  return NoLanes;
+}
+
 export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
   let entangledLanes = renderLanes;
 
@@ -534,6 +587,14 @@ export function getHighestPriorityLane(lanes: Lanes): Lane {
   return lanes & -lanes;
 }
 
+function getLanesOfEqualOrHigherPriority(lanes: Lane | Lanes): Lanes {
+  // Create a mask with all bits to the right or same as the highest bit.
+  // So if lanes is 0b100, the result would be 0b111.
+  // If lanes is 0b101, the result would be 0b111.
+  const lowestPriorityLaneIndex = 31 - clz32(lanes);
+  return (1 << (lowestPriorityLaneIndex + 1)) - 1;
+}
+
 export function pickArbitraryLane(lanes: Lanes): Lane {
   // This wrapper function gets inlined. Only exists so to communicate that it
   // doesn't matter which bit is selected; you can pick any bit without
@@ -757,17 +818,6 @@ export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
   }
 }
 
-export function upgradePendingLaneToSync(root: FiberRoot, lane: Lane) {
-  // Since we're upgrading the priority of the given lane, there is now pending
-  // sync work.
-  root.pendingLanes |= SyncLane;
-
-  // Entangle the sync lane with the lane we're upgrading. This means SyncLane
-  // will not be allowed to finish without also finishing the given lane.
-  root.entangledLanes |= SyncLane;
-  root.entanglements[SyncLaneIndex] |= lane;
-}
-
 export function upgradePendingLanesToSync(
   root: FiberRoot,
   lanesToUpgrade: Lanes,

commit e10e8681824e56c10fdb14e0359d878bcd748937
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 4 13:55:29 2024 -0400

    Schedule prerender after something suspends (#30800)
    
    Adds the concept of a "prerender". These special renders are spawned
    whenever something suspends (and we're not already prerendering).
    
    The purpose is to move speculative rendering work into a separate phase
    that does not block the UI from updating. For example, during a
    transition, if something suspends, we should not speculatively prerender
    siblings that will be replaced by a fallback in the UI until *after* the
    fallback has been shown to the user.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 6ed4caae70..2995548fbb 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -229,28 +229,49 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
 
   const suspendedLanes = root.suspendedLanes;
   const pingedLanes = root.pingedLanes;
+  const warmLanes = root.warmLanes;
 
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.
   const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
   if (nonIdlePendingLanes !== NoLanes) {
+    // First check for fresh updates.
     const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
     if (nonIdleUnblockedLanes !== NoLanes) {
       nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
     } else {
+      // No fresh updates. Check if suspended work has been pinged.
       const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
+      } else {
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+        if (lanesToPrewarm !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        }
       }
     }
   } else {
     // The only remaining work is Idle.
+    // TODO: Idle isn't really used anywhere, and the thinking around
+    // speculative rendering has evolved since this was implemented. Consider
+    // removing until we've thought about this again.
+
+    // First check for fresh updates.
     const unblockedLanes = pendingLanes & ~suspendedLanes;
     if (unblockedLanes !== NoLanes) {
       nextLanes = getHighestPriorityLanes(unblockedLanes);
     } else {
+      // No fresh updates. Check if suspended work has been pinged.
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
+      } else {
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        const lanesToPrewarm = pendingLanes & ~warmLanes;
+        if (lanesToPrewarm !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        }
       }
     }
   }
@@ -335,6 +356,21 @@ export function getNextLanesToFlushSync(
   return NoLanes;
 }
 
+export function checkIfRootIsPrerendering(
+  root: FiberRoot,
+  renderLanes: Lanes,
+): boolean {
+  const pendingLanes = root.pendingLanes;
+  const suspendedLanes = root.suspendedLanes;
+  const pingedLanes = root.pingedLanes;
+  // Remove lanes that are suspended (but not pinged)
+  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
+
+  // If there are no unsuspended or pinged lanes, that implies that we're
+  // performing a prerender.
+  return (unblockedLanes & renderLanes) === 0;
+}
+
 export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
   let entangledLanes = renderLanes;
 
@@ -670,6 +706,7 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
   if (updateLane !== IdleLane) {
     root.suspendedLanes = NoLanes;
     root.pingedLanes = NoLanes;
+    root.warmLanes = NoLanes;
   }
 }
 
@@ -677,10 +714,19 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
+  didSkipSuspendedSiblings: boolean,
 ) {
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
+  if (!didSkipSuspendedSiblings) {
+    // Mark these lanes as warm so we know there's nothing else to work on.
+    root.warmLanes |= suspendedLanes;
+  } else {
+    // Render unwound without attempting all the siblings. Do no mark the lanes
+    // as warm. This will cause a prewarm render to be scheduled.
+  }
+
   // The suspended lanes are no longer CPU-bound. Clear their expiration times.
   const expirationTimes = root.expirationTimes;
   let lanes = suspendedLanes;
@@ -700,6 +746,9 @@ export function markRootSuspended(
 
 export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  // The data that just resolved could have unblocked additional children, which
+  // will also need to be prewarmed if something suspends again.
+  root.warmLanes &= ~pingedLanes;
 }
 
 export function markRootFinished(
@@ -714,6 +763,7 @@ export function markRootFinished(
   // Let's try everything again
   root.suspendedLanes = NoLanes;
   root.pingedLanes = NoLanes;
+  root.warmLanes = NoLanes;
 
   root.expiredLanes &= remainingLanes;
 

commit 66cf2cfc8a8c4b09d2b783fd7302ae6b24150935
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 10 13:23:32 2024 -0400

    Prerender during same pass if blocked anyway (#30879)
    
    If something suspends in the shell — i.e. we won't replace the suspended
    content with a fallback — we might as well prerender the siblings during
    the current render pass, instead of spawning a separate prerender pass.
    
    This is implemented by setting the "is prerendering" flag to true
    whenever we suspend in the shell. But only if we haven't already skipped
    over some siblings, because if so, then we need to schedule a separate
    prerender pass regardless.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 2995548fbb..fe36ce548b 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -579,7 +579,7 @@ export function includesOnlyTransitions(lanes: Lanes): boolean {
   return (lanes & TransitionLanes) === lanes;
 }
 
-export function includesBlockingLane(root: FiberRoot, lanes: Lanes): boolean {
+export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |
     InputContinuousLane |

commit d6cb4e771341ff82489c00f4907990cb8a75696b
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 11 11:41:54 2024 -0400

    Start prerendering Suspense retries immediately (#30934)
    
    When a component suspends and is replaced by a fallback, we should start
    prerendering the fallback immediately, even before any new data is
    received. During the retry, we can enter prerender mode directly if
    we're sure that no new data was received since we last attempted to
    render the boundary.
    
    To do this, when completing the fallback, we leave behind a pending
    retry lane on the Suspense boundary. Previously we only did this once a
    promise resolved, but by assigning a lane during the complete phase, we
    will know that there's speculative work to be done.
    
    Then, upon committing the fallback, we mark the retry lane as suspended
    — but only if nothing was pinged or updated in the meantime. That allows
    us to immediately enter prerender mode (i.e. render without skipping any
    siblings) when performing the retry.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index fe36ce548b..4338d3af58 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -26,9 +26,11 @@ import {
   syncLaneExpirationMs,
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
+  disableLegacyMode,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
+import {LegacyRoot} from './ReactRootTags';
 
 // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.
 // If those values are changed that package should be rebuilt and redeployed.
@@ -231,6 +233,29 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   const pingedLanes = root.pingedLanes;
   const warmLanes = root.warmLanes;
 
+  // finishedLanes represents a completed tree that is ready to commit.
+  //
+  // It's not worth doing discarding the completed tree in favor of performing
+  // speculative work. So always check this before deciding to warm up
+  // the siblings.
+  //
+  // Note that this is not set in a "suspend indefinitely" scenario, like when
+  // suspending outside of a Suspense boundary, or in the shell during a
+  // transition — only in cases where we are very likely to commit the tree in
+  // a brief amount of time (i.e. below the "Just Noticeable Difference"
+  // threshold).
+  //
+  // TODO: finishedLanes is also set when a Suspensey resource, like CSS or
+  // images, suspends during the commit phase. (We could detect that here by
+  // checking for root.cancelPendingCommit.) These are also expected to resolve
+  // quickly, because of preloading, but theoretically they could block forever
+  // like in a normal "suspend indefinitely" scenario. In the future, we should
+  // consider only blocking for up to some time limit before discarding the
+  // commit in favor of prerendering. If we do discard a pending commit, then
+  // the commit phase callback should act as a ping to try the original
+  // render again.
+  const rootHasPendingCommit = root.finishedLanes !== NoLanes;
+
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.
   const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
@@ -246,9 +271,11 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
         // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-        if (lanesToPrewarm !== NoLanes) {
-          nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+          }
         }
       }
     }
@@ -268,9 +295,11 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
         // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        const lanesToPrewarm = pendingLanes & ~warmLanes;
-        if (lanesToPrewarm !== NoLanes) {
-          nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = pendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+          }
         }
       }
     }
@@ -753,10 +782,14 @@ export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
 
 export function markRootFinished(
   root: FiberRoot,
+  finishedLanes: Lanes,
   remainingLanes: Lanes,
   spawnedLane: Lane,
+  updatedLanes: Lanes,
+  suspendedRetryLanes: Lanes,
 ) {
-  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
+  const previouslyPendingLanes = root.pendingLanes;
+  const noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;
 
   root.pendingLanes = remainingLanes;
 
@@ -812,6 +845,37 @@ export function markRootFinished(
       NoLanes,
     );
   }
+
+  // suspendedRetryLanes represents the retry lanes spawned by new Suspense
+  // boundaries during this render that were not later pinged.
+  //
+  // These lanes were marked as pending on their associated Suspense boundary
+  // fiber during the render phase so that we could start rendering them
+  // before new data streams in. As soon as the fallback commits, we can try
+  // to render them again.
+  //
+  // But since we know they're still suspended, we can skip straight to the
+  // "prerender" mode (i.e. don't skip over siblings after something
+  // suspended) instead of the regular mode (i.e. unwind and skip the siblings
+  // as soon as something suspends to unblock the rest of the update).
+  if (
+    suspendedRetryLanes !== NoLanes &&
+    // Note that we only do this if there were no updates since we started
+    // rendering. This mirrors the logic in markRootUpdated — whenever we
+    // receive an update, we reset all the suspended and pinged lanes.
+    updatedLanes === NoLanes &&
+    !(disableLegacyMode && root.tag === LegacyRoot)
+  ) {
+    // We also need to avoid marking a retry lane as suspended if it was already
+    // pending before this render. We can't say these are now suspended if they
+    // weren't included in our attempt.
+    const freshlySpawnedRetryLanes =
+      suspendedRetryLanes &
+      // Remove any retry lane that was already pending before our just-finished
+      // attempt, and also wasn't included in that attempt.
+      ~(previouslyPendingLanes & ~finishedLanes);
+    root.suspendedLanes |= freshlySpawnedRetryLanes;
+  }
 }
 
 function markSpawnedDeferredLane(

commit f2df5694f2be141954f22618fd3ad035203241a3
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Sep 16 11:45:50 2024 -0400

    [Fiber] Log Component Renders to Custom Performance Track (#30967)
    
    Stacked on #30960 and #30966. Behind the enableComponentPerformanceTrack
    flag.
    
    This is the first step of performance logging. This logs the start and
    end time of a component render in the passive effect phase. We use the
    data we're already tracking on components when the Profiler component or
    DevTools is active in the Profiling or Dev builds. By backdating this
    after committing we avoid adding more overhead in the hot path. By only
    logging things that actually committed, we avoid the costly unwinding of
    an interrupted render which was hard to maintain in earlier versions.
    
    We already have the start time but we don't have the end time. That's
    because `actualStartTime + actualDuration` isn't enough since
    `actualDuration` counts the actual CPU time excluding yields and
    suspending in the render.
    
    Instead, we infer the end time to be the start time of the next sibling
    or the complete time of the whole root if there are no more siblings. We
    need to pass this down the passive effect tree. This will mean that any
    overhead and yields are attributed to this component's span. In a follow
    up, we'll need to start logging these yields to make it clear that this
    is not part of the component's self-time.
    
    In follow ups, I'll do the same for commit phases. We'll also need to
    log more information about the phases in the top track. We'll also need
    to filter out more components from the trees that we don't need to
    highlight like the internal Offscreen components. It also needs polish
    on colors etc.
    
    Currently, I place the components into separate tracks depending on
    which lane currently committed. That way you can see what was blocking
    Transitions or Suspense etc. One problem that I've hit with the new
    performance.measure extensions is that these tracks show up in the order
    they're used which is not the order of priority that we use. Even when
    you add fake markers they have to actually be within the performance run
    since otherwise the calls are noops so it's not enough to do that once.
    
    However, I think this visualization is actually not good because these
    trees end up so large that you can't see any other lanes once you expand
    one. Therefore, I think in a follow up I'll actually instead switch to a
    model where Components is a single track regardless of lane since we
    don't currently have overlap anyway. Then the description about what is
    actually rendering can be separate lanes.
    
    <img width="1512" alt="Screenshot 2024-09-15 at 10 55 55 PM"
    src="https://github.com/user-attachments/assets/5ca3fa74-97ce-40c7-97f7-80c1dd7d6470">
    
    <img width="1512" alt="Screenshot 2024-09-15 at 10 56 27 PM"
    src="https://github.com/user-attachments/assets/557ad65b-4190-465f-843c-0bc6cbb9326d">

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 4338d3af58..f72174e208 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -1143,3 +1143,35 @@ export function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {
     lanes &= ~lane;
   }
 }
+
+// Used to name the Performance Track
+export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
+  if (
+    lanes &
+    (SyncHydrationLane |
+      SyncLane |
+      InputContinuousHydrationLane |
+      InputContinuousLane |
+      DefaultHydrationLane |
+      DefaultLane)
+  ) {
+    return 'Blocking';
+  }
+  if (lanes & (TransitionHydrationLane | TransitionLanes)) {
+    return 'Transition';
+  }
+  if (lanes & RetryLanes) {
+    return 'Suspense';
+  }
+  if (
+    lanes &
+    (SelectiveHydrationLane |
+      IdleHydrationLane |
+      IdleLane |
+      OffscreenLane |
+      DeferredLane)
+  ) {
+    return 'Idle';
+  }
+  return 'Other';
+}

commit d4688dfaafe51a4cb6e3c51fc2330662cb4e2296
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Sep 20 14:27:12 2024 -0400

    [Fiber] Track Event Time, startTransition Time and setState Time (#31008)
    
    This tracks the current window.event.timeStamp the first time we
    setState or call startTransition. For either the blocking track or
    transition track. We can use this to show how long we were blocked by
    other events or overhead from when the user interacted until we got
    called into React.
    
    Then we track the time we start awaiting a Promise returned from
    startTransition. We can use this track how long we waited on an Action
    to complete before setState was called.
    
    Then finally we track when setState was called so we can track how long
    we were blocked by other word before we could actually start rendering.
    For a Transition this might be blocked by Blocking React render work.
    
    We only log these once a subsequent render actually happened. If no
    render was actually scheduled, then we don't log these. E.g. if an
    isomorphic Action doesn't call startTransition there's no render so we
    don't log it.
    
    We only log the first event/update/transition even if multiple are
    batched into it later. If multiple Actions are entangled they're all
    treated as one until an update happens. If no update happens and all
    entangled actions finish, we clear the transition so that the next time
    a new sequence starts we can log it.
    
    We also clamp these (start the track later) if they were scheduled
    within a render/commit. Since we share a single track we don't want to
    create overlapping tracks.
    
    The purpose of this is not to show every event/action that happens but
    to show a prelude to how long we were blocked before a render started.
    So you can follow the first event to commit.
    
    <img width="674" alt="Screenshot 2024-09-20 at 1 59 58 AM"
    src="https://github.com/user-attachments/assets/151ba9e8-6b3c-4fa1-9f8d-e3602745eeb7">
    
    I still need to add the rendering/suspended phases to the timeline which
    why this screenshot has a gap.
    
    <img width="993" alt="Screenshot 2024-09-20 at 12 50 27 AM"
    src="https://github.com/user-attachments/assets/155b6675-b78a-4a22-a32b-212c15051074">
    
    In this case it's a Form Action which started a render into the form
    which then suspended on the action. The action then caused a refresh,
    which interrupts with its own update that's blocked before rendering.
    Suspended roots like this is interesting because we could in theory
    start working on a different root in the meantime which makes this
    timeline less linear.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index f72174e208..b8c051def4 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -592,6 +592,10 @@ export function includesSyncLane(lanes: Lanes): boolean {
   return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
 }
 
+export function isSyncLane(lanes: Lanes): boolean {
+  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
+}
+
 export function includesNonIdleWork(lanes: Lanes): boolean {
   return (lanes & NonIdleLanes) !== NoLanes;
 }
@@ -608,6 +612,10 @@ export function includesOnlyTransitions(lanes: Lanes): boolean {
   return (lanes & TransitionLanes) === lanes;
 }
 
+export function includesTransitionLane(lanes: Lanes): boolean {
+  return (lanes & TransitionLanes) !== NoLanes;
+}
+
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |
@@ -623,6 +631,15 @@ export function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {
   return (lanes & root.expiredLanes) !== NoLanes;
 }
 
+export function isBlockingLane(lane: Lane): boolean {
+  const SyncDefaultLanes =
+    InputContinuousHydrationLane |
+    InputContinuousLane |
+    DefaultHydrationLane |
+    DefaultLane;
+  return (lane & SyncDefaultLanes) !== NoLanes;
+}
+
 export function isTransitionLane(lane: Lane): boolean {
   return (lane & TransitionLanes) !== NoLanes;
 }

commit 0f1856c49febe96923e469f98c0b123130ea015c
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 25 16:31:44 2024 -0400

    Make prerendering always non-blocking (#31056)
    
    When a synchronous update suspends, and we prerender the siblings, the
    prerendering should be non-blocking so that we can immediately restart
    once the data arrives.
    
    This happens automatically when there's a Suspense boundary, because we
    immediately commit the boundary and then proceed to a Retry render,
    which are always concurrent. When there's not a Suspense boundary, there
    is no Retry, so we need to take care to switch from the synchronous work
    loop to the concurrent one, to enable time slicing.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index b8c051def4..b98019046e 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -27,6 +27,7 @@ import {
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
   disableLegacyMode,
+  enableSiblingPrerendering,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
@@ -270,11 +271,13 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
-        // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        if (!rootHasPendingCommit) {
-          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-          if (lanesToPrewarm !== NoLanes) {
-            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (enableSiblingPrerendering) {
+          // Nothing has been pinged. Check for lanes that need to be prewarmed.
+          if (!rootHasPendingCommit) {
+            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+            if (lanesToPrewarm !== NoLanes) {
+              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+            }
           }
         }
       }
@@ -294,11 +297,13 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
-        // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        if (!rootHasPendingCommit) {
-          const lanesToPrewarm = pendingLanes & ~warmLanes;
-          if (lanesToPrewarm !== NoLanes) {
-            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (enableSiblingPrerendering) {
+          // Nothing has been pinged. Check for lanes that need to be prewarmed.
+          if (!rootHasPendingCommit) {
+            const lanesToPrewarm = pendingLanes & ~warmLanes;
+            if (lanesToPrewarm !== NoLanes) {
+              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+            }
           }
         }
       }
@@ -760,12 +765,14 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didSkipSuspendedSiblings: boolean,
+  didAttemptEntireTree: boolean,
 ) {
+  // TODO: Split this into separate functions for marking the root at the end of
+  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (!didSkipSuspendedSiblings) {
+  if (enableSiblingPrerendering && didAttemptEntireTree) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {
@@ -876,6 +883,7 @@ export function markRootFinished(
   // suspended) instead of the regular mode (i.e. unwind and skip the siblings
   // as soon as something suspends to unblock the rest of the update).
   if (
+    enableSiblingPrerendering &&
     suspendedRetryLanes !== NoLanes &&
     // Note that we only do this if there were no updates since we started
     // rendering. This mirrors the logic in markRootUpdated — whenever we

commit 76aee6f39d94caa04c11be92d75d12cb9ee56494
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Sep 26 16:48:57 2024 -0400

    Revert "Make prerendering always non-blocking" (#31080)
    
    Reverts facebook/react#31056

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index b98019046e..b8c051def4 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -27,7 +27,6 @@ import {
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
   disableLegacyMode,
-  enableSiblingPrerendering,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
@@ -271,13 +270,11 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -297,13 +294,11 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = pendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = pendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -765,14 +760,12 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
+  didSkipSuspendedSiblings: boolean,
 ) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
+  if (!didSkipSuspendedSiblings) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {
@@ -883,7 +876,6 @@ export function markRootFinished(
   // suspended) instead of the regular mode (i.e. unwind and skip the siblings
   // as soon as something suspends to unblock the rest of the update).
   if (
-    enableSiblingPrerendering &&
     suspendedRetryLanes !== NoLanes &&
     // Note that we only do this if there were no updates since we started
     // rendering. This mirrors the logic in markRootUpdated — whenever we

commit 13411e4589f3d999727c5322781e2dd7bef3b256
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Oct 14 14:12:23 2024 -0400

    [Re-land] Make prerendering always non-blocking: Add missing feature flag checks (#31238)
    
    This is a partial re-land of
    https://github.com/facebook/react/pull/31056. We saw breakages surface
    after the original land and had to revert. Now that they've been fixed,
    let's try this again. This time we'll split up the commits to give us
    more control of testing and rollout internally.
    
    Original PR: https://github.com/facebook/react/pull/31056
    Original Commit:
    https://github.com/facebook/react/pull/31056/commits/2a9fb445d98b60a97f3642cec2ff22469727e0c7
    Revert PR: https://github.com/facebook/react/pull/31080
    
    Commit description:
    ```
    Neglected to wrap some places in the enableSiblingPrerendering flag.
    ```
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index b8c051def4..7d6bfd16e8 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -27,6 +27,7 @@ import {
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
   disableLegacyMode,
+  enableSiblingPrerendering,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
@@ -270,11 +271,13 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
-        // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        if (!rootHasPendingCommit) {
-          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-          if (lanesToPrewarm !== NoLanes) {
-            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (enableSiblingPrerendering) {
+          // Nothing has been pinged. Check for lanes that need to be prewarmed.
+          if (!rootHasPendingCommit) {
+            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+            if (lanesToPrewarm !== NoLanes) {
+              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+            }
           }
         }
       }
@@ -294,11 +297,13 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
-        // Nothing has been pinged. Check for lanes that need to be prewarmed.
-        if (!rootHasPendingCommit) {
-          const lanesToPrewarm = pendingLanes & ~warmLanes;
-          if (lanesToPrewarm !== NoLanes) {
-            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+        if (enableSiblingPrerendering) {
+          // Nothing has been pinged. Check for lanes that need to be prewarmed.
+          if (!rootHasPendingCommit) {
+            const lanesToPrewarm = pendingLanes & ~warmLanes;
+            if (lanesToPrewarm !== NoLanes) {
+              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
+            }
           }
         }
       }
@@ -765,7 +770,7 @@ export function markRootSuspended(
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (!didSkipSuspendedSiblings) {
+  if (enableSiblingPrerendering && !didSkipSuspendedSiblings) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {
@@ -876,6 +881,7 @@ export function markRootFinished(
   // suspended) instead of the regular mode (i.e. unwind and skip the siblings
   // as soon as something suspends to unblock the rest of the update).
   if (
+    enableSiblingPrerendering &&
     suspendedRetryLanes !== NoLanes &&
     // Note that we only do this if there were no updates since we started
     // rendering. This mirrors the logic in markRootUpdated — whenever we

commit 6c4bbc783286bf6eebd9927cb52e8fec5ad4dd74
Author: Jack Pope <jackpope1@gmail.com>
Date:   Tue Oct 15 16:47:02 2024 -0400

    [Re-land] Make prerendering always non-blocking (#31268)
    
    Follows https://github.com/facebook/react/pull/31238
    
    ___
    
    This is a partial re-land of
    https://github.com/facebook/react/pull/31056. We saw breakages surface
    after the original land and had to revert. Now that they've been fixed,
    let's try this again. This time we'll split up the commits to give us
    more control of testing and rollout internally.
    
    Original PR: https://github.com/facebook/react/pull/31056
    Original Commit:
    https://github.com/facebook/react/pull/31056/commits/4c71025d8d1bd46344ad793e7ed3049d24f7395a
    Revert PR: https://github.com/facebook/react/pull/31080
    
    Commit description:
    
    > When a synchronous update suspends, and we prerender the siblings, the
    prerendering should be non-blocking so that we can immediately restart
    once the data arrives.
    >
    > This happens automatically when there's a Suspense boundary, because
    we immediately commit the boundary and then proceed to a Retry render,
    which are always concurrent. When there's not a Suspense boundary, there
    is no Retry, so we need to take care to switch from the synchronous work
    loop to the concurrent one, to enable time slicing.
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 7d6bfd16e8..b98019046e 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -765,12 +765,14 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didSkipSuspendedSiblings: boolean,
+  didAttemptEntireTree: boolean,
 ) {
+  // TODO: Split this into separate functions for marking the root at the end of
+  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && !didSkipSuspendedSiblings) {
+  if (enableSiblingPrerendering && didAttemptEntireTree) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {

commit cae764ce81b1bd6c418e9e23651794b6b09208e8
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Oct 25 09:17:07 2024 -0700

    Revert "[Re-land] Make prerendering always non-blocking (#31268)" (#31355)
    
    This reverts commit 6c4bbc783286bf6eebd9927cb52e8fec5ad4dd74.
    
    It looked like the bug we found on the original land was related to
    broken product code. But through landing #31268 we found additional bugs
    internally. Since disabling the feature flag does not fix the bugs, we
    have to revert again to unblock the sync. We can continue to debug with
    our internal build.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index b98019046e..7d6bfd16e8 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -765,14 +765,12 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
+  didSkipSuspendedSiblings: boolean,
 ) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
+  if (enableSiblingPrerendering && !didSkipSuspendedSiblings) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {

commit 989af12f72080c17db03ead91d99b6394a215564
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Nov 8 12:38:41 2024 -0500

    Make prerendering always non-blocking with fix (#31452)
    
    We've previously failed to land this change due to some internal apps
    seeing infinite render loops due to external store state updates during
    render. It turns out that since the `renderWasConcurrent` var was moved
    into the do block, the sync render triggered from the external store
    check was stuck with a `RootSuspended` `exitStatus`. So this is not
    unique to sibling prerendering but more generally related to how we
    handle update to a sync external store during render.
    
    We've tested this build against local repros which now render without
    crashes. We will try to add a unit test to cover the scenario as well.
    
    ---------
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>
    Co-authored-by: Rick Hanlon <rickhanlonii@fb.com>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 7d6bfd16e8..b98019046e 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -765,12 +765,14 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didSkipSuspendedSiblings: boolean,
+  didAttemptEntireTree: boolean,
 ) {
+  // TODO: Split this into separate functions for marking the root at the end of
+  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && !didSkipSuspendedSiblings) {
+  if (enableSiblingPrerendering && didAttemptEntireTree) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {

commit d5e8f79cf4d11fa7eee263b3f937deecbe65ffd7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Dec 12 23:06:07 2024 -0500

    [Fiber] Use hydration lanes when scheduling hydration work (#31751)
    
    When scheduling the initial root and when using
    `unstable_scheduleHydration` we should use the Hydration Lanes rather
    than the raw update lane. This ensures that we're always hydrating using
    a Hydration Lane or the Offscreen Lane rather than other lanes getting
    some random hydration in it.
    
    This fixes an issue where updating a root while it is still hydrating
    causes it to trigger client rendering when it could just hydrate and
    then apply the update on top of that.
    
    It also fixes a potential performance issue where
    `unstable_scheduleHydration` gets batched with an update that then ends
    up forcing an update of a boundary that requires it to rewind to do the
    hydration lane anyway. Might as well just start with the hydration
    without the update applied first.
    
    I added a kill switch (`enableHydrationLaneScheduling`) just in case but
    seems very safe given that using `unstable_scheduleHydration` at all is
    very rare and updating the root before the shell hydrates is extremely
    rare (and used to trigger a recoverable error).

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index b98019046e..ee3a0a3df2 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -995,61 +995,66 @@ export function getBumpedLaneForHydration(
   renderLanes: Lanes,
 ): Lane {
   const renderLane = getHighestPriorityLane(renderLanes);
-
-  let lane;
-  if ((renderLane & SyncUpdateLanes) !== NoLane) {
-    lane = SyncHydrationLane;
-  } else {
-    switch (renderLane) {
-      case SyncLane:
-        lane = SyncHydrationLane;
-        break;
-      case InputContinuousLane:
-        lane = InputContinuousHydrationLane;
-        break;
-      case DefaultLane:
-        lane = DefaultHydrationLane;
-        break;
-      case TransitionLane1:
-      case TransitionLane2:
-      case TransitionLane3:
-      case TransitionLane4:
-      case TransitionLane5:
-      case TransitionLane6:
-      case TransitionLane7:
-      case TransitionLane8:
-      case TransitionLane9:
-      case TransitionLane10:
-      case TransitionLane11:
-      case TransitionLane12:
-      case TransitionLane13:
-      case TransitionLane14:
-      case TransitionLane15:
-      case RetryLane1:
-      case RetryLane2:
-      case RetryLane3:
-      case RetryLane4:
-        lane = TransitionHydrationLane;
-        break;
-      case IdleLane:
-        lane = IdleHydrationLane;
-        break;
-      default:
-        // Everything else is already either a hydration lane, or shouldn't
-        // be retried at a hydration lane.
-        lane = NoLane;
-        break;
-    }
-  }
-
+  const bumpedLane =
+    (renderLane & SyncUpdateLanes) !== NoLane
+      ? // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane
+        // because that causes things to flush synchronously when they shouldn't.
+        // TODO: This is not coherent but that's beacuse the unification is not coherent.
+        // We need to get merge these into an actual single lane.
+        SyncHydrationLane
+      : getBumpedLaneForHydrationByLane(renderLane);
   // Check if the lane we chose is suspended. If so, that indicates that we
   // already attempted and failed to hydrate at that level. Also check if we're
   // already rendering that lane, which is rare but could happen.
-  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
+  // TODO: This should move into the caller to decide whether giving up is valid.
+  if ((bumpedLane & (root.suspendedLanes | renderLanes)) !== NoLane) {
     // Give up trying to hydrate and fall back to client render.
     return NoLane;
   }
+  return bumpedLane;
+}
 
+export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
+  switch (lane) {
+    case SyncLane:
+      lane = SyncHydrationLane;
+      break;
+    case InputContinuousLane:
+      lane = InputContinuousHydrationLane;
+      break;
+    case DefaultLane:
+      lane = DefaultHydrationLane;
+      break;
+    case TransitionLane1:
+    case TransitionLane2:
+    case TransitionLane3:
+    case TransitionLane4:
+    case TransitionLane5:
+    case TransitionLane6:
+    case TransitionLane7:
+    case TransitionLane8:
+    case TransitionLane9:
+    case TransitionLane10:
+    case TransitionLane11:
+    case TransitionLane12:
+    case TransitionLane13:
+    case TransitionLane14:
+    case TransitionLane15:
+    case RetryLane1:
+    case RetryLane2:
+    case RetryLane3:
+    case RetryLane4:
+      lane = TransitionHydrationLane;
+      break;
+    case IdleLane:
+      lane = IdleHydrationLane;
+      break;
+    default:
+      // Everything else is already either a hydration lane, or shouldn't
+      // be retried at a hydration lane.
+      lane = NoLane;
+      break;
+  }
   return lane;
 }
 

commit c32780eeb4c44e138d09a35da841926f512d3b07
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Dec 14 13:49:47 2024 -0500

    [Fiber] Highlight hydration and offscreen render phases (#31752)
    
    This highlights the render phase as the tertiary color (green) when
    we're render a hydration lane or offscreen lane.
    
    I call the "Render" phase "Hydrated" instead in this case. For the
    offscreen case we don't currently have a differentiation between
    hydrated or activity. I just called that "Prepared". Even for the
    hydration case where there's no discovered client rendered boundaries
    it's more like it's preparing for an interaction rather than blocking
    one. Where as for the other lanes the hydration might block something.
    
    <img width="1173" alt="Screenshot 2024-12-12 at 11 23 14 PM"
    src="https://github.com/user-attachments/assets/49ab1508-840f-4188-a085-18fe94b14187"
    />
    
    In a follow up I'd like to color the components in the Components tree
    green if they were hydrated but not the ones that was actually client
    rendered e.g. due to a mismatch or forced client rendering so you can
    tell the difference. Unfortunately, the current signals we have for this
    get reset earlier in the commit phase than when we log these.
    
    Another thing is that a failed hydration should probably be colored red
    even though it ends up committing successfully. I.e. a recoverable
    error.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index ee3a0a3df2..4c96207bd6 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -621,6 +621,18 @@ export function includesTransitionLane(lanes: Lanes): boolean {
   return (lanes & TransitionLanes) !== NoLanes;
 }
 
+export function includesOnlyHydrationLanes(lanes: Lanes): boolean {
+  return (lanes & HydrationLanes) === lanes;
+}
+
+export function includesOnlyOffscreenLanes(lanes: Lanes): boolean {
+  return (lanes & OffscreenLane) === lanes;
+}
+
+export function includesOnlyHydrationOrOffscreenLanes(lanes: Lanes): boolean {
+  return (lanes & (HydrationLanes | OffscreenLane)) === lanes;
+}
+
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |

commit c81312e3a78dcbf71ed98c8893abe6dbfeaef3f2
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Jan 2 14:55:34 2025 -0500

    [Fiber] Refactor Commit Phase into Separate Functions for Before Mutation/Mutation/Layout (#31930)
    
    This is doing some general clean up to be able to split the commit root three phases into three separate async steps.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 4c96207bd6..71a1e973c3 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -221,7 +221,11 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   }
 }
 
-export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
+export function getNextLanes(
+  root: FiberRoot,
+  wipLanes: Lanes,
+  rootHasPendingCommit: boolean,
+): Lanes {
   // Early bailout if there's no pending work left.
   const pendingLanes = root.pendingLanes;
   if (pendingLanes === NoLanes) {
@@ -246,16 +250,6 @@ export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   // a brief amount of time (i.e. below the "Just Noticeable Difference"
   // threshold).
   //
-  // TODO: finishedLanes is also set when a Suspensey resource, like CSS or
-  // images, suspends during the commit phase. (We could detect that here by
-  // checking for root.cancelPendingCommit.) These are also expected to resolve
-  // quickly, because of preloading, but theoretically they could block forever
-  // like in a normal "suspend indefinitely" scenario. In the future, we should
-  // consider only blocking for up to some time limit before discarding the
-  // commit in favor of prerendering. If we do discard a pending commit, then
-  // the commit phase callback should act as a ping to try the original
-  // render again.
-  const rootHasPendingCommit = root.finishedLanes !== NoLanes;
 
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.

commit a4d122f2d192fe0b6480e669cca43c8f953aaf85
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Jan 8 12:11:18 2025 -0500

    Add <ViewTransition> Component (#31975)
    
    This will provide the opt-in for using [View
    Transitions](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API)
    in React.
    
    View Transitions only trigger for async updates like `startTransition`,
    `useDeferredValue`, Actions or `<Suspense>` revealing from fallback to
    content. Synchronous updates provide an opt-out but also guarantee that
    they commit immediately which View Transitions can't.
    
    There's no need to opt-in to View Transitions at the "cause" side like
    event handlers or actions. They don't know what UI will change and
    whether that has an animated transition described.
    
    Conceptually the `<ViewTransition>` component is like a DOM fragment
    that transitions its children in its own isolate/snapshot. The API works
    by wrapping a DOM node or inner component:
    
    ```js
    import {ViewTransition} from 'react';
    
    <ViewTransition><Component /></ViewTransition>
    ```
    
    The default is `name="auto"` which will automatically assign a
    `view-transition-name` to the inner DOM node. That way you can add a
    View Transition to a Component without controlling its DOM nodes styling
    otherwise.
    
    A difference between this and the browser's built-in
    `view-transition-name: auto` is that switching the DOM nodes within the
    `<ViewTransition>` component preserves the same name so this example
    cross-fades between the DOM nodes instead of causing an exit and enter:
    
    ```js
    <ViewTransition>{condition ? <ComponentA /> : <ComponentB />}</ViewTransition>
    ```
    
    This becomes especially useful with `<Suspense>` as this example
    cross-fades between Skeleton and Content:
    
    ```js
    <ViewTransition>
      <Suspense fallback={<Skeleton />}>
        <Content />
      </Suspense>
    </ViewTransition>
    ```
    
    Where as this example triggers an exit of the Skeleton and an enter of
    the Content:
    
    ```js
    <Suspense fallback={<ViewTransition><Skeleton /></ViewTransition>}>
      <ViewTransition><Content /></ViewTransition>
    </Suspense>
    ```
    
    Managing instances and keys becomes extra important.
    
    You can also specify an explicit `name` property for example for
    animating the same conceptual item from one page onto another. However,
    best practices is to property namespace these since they can easily
    collide. It's also useful to add an `id` to it if available.
    
    ```js
    <ViewTransition name="my-shared-view">
    ```
    
    The model in general is the same as plain `view-transition-name` except
    React manages a set of heuristics for when to apply it. A problem with
    the naive View Transitions model is that it overly opts in every
    boundary that *might* transition into transitioning. This is leads to
    unfortunate effects like things floating around when unrelated updates
    happen. This leads the whole document to animate which means that
    nothing is clickable in the meantime. It makes it not useful for smaller
    and more local transitions. Best practice is to add
    `view-transition-name` only right before you're about to need to animate
    the thing. This is tricky to manage globally on complex apps and is not
    compositional. Instead we let React manage when a `<ViewTransition>`
    "activates" and add/remove the `view-transition-name`. This is also when
    React calls `startViewTransition` behind the scenes while it mutates the
    DOM.
    
    I've come up with a number of heuristics that I think will make a lot
    easier to coordinate this. The principle is that only if something that
    updates that particular boundary do we activate it. I hope that one day
    maybe browsers will have something like these built-in and we can remove
    our implementation.
    
    A `<ViewTransition>` only activates if:
    
    - If a mounted Component renders a `<ViewTransition>` within it outside
    the first DOM node, and it is within the viewport, then that
    ViewTransition activates as an "enter" animation. This avoids inner
    "enter" animations trigger when the parent mounts.
    - If an unmounted Component had a `<ViewTransition>` within it outside
    the first DOM node, and it was within the viewport, then that
    ViewTransition activates as an "exit" animation. This avoids inner
    "exit" animations triggering when the parent unmounts.
    - If an explicitly named `<ViewTransition name="...">` is deep within an
    unmounted tree and one with the same name appears in a mounted tree at
    the same time, then both are activated as a pair, but only if they're
    both in the viewport. This avoids these triggering "enter" or "exit"
    animations when going between parents that don't have a pair.
    - If an already mounted `<ViewTransition>` is visible and a DOM
    mutation, that might affect how it's painted, happens within its
    children but outside any nested `<ViewTransition>`. This allows it to
    "cross-fade" between its updates.
    - If an already mounted `<ViewTransition>` resizes or moves as the
    result of direct DOM nodes siblings changing or moving around. This
    allows insertion, deletion and reorders into a list to animate all
    children. It is only within one DOM node though, to avoid unrelated
    changes in the parent to trigger this. If an item is outside the
    viewport before and after, then it's skipped to avoid things flying
    across the screen.
    - If a `<ViewTransition>` boundary changes size, due to a DOM mutation
    within it, then the parent activates (or the root document if there are
    no more parents). This ensures that the container can cross-fade to
    avoid abrupt relayout. This can be avoided by using absolutely
    positioned children. When this can avoid bubbling to the root document,
    whatever is not animating is still responsive to clicks during the
    transition.
    
    Conceptually each DOM node has its own default that activates the parent
    `<ViewTransition>` or no transition if the parent is the root. That
    means that if you add a DOM node like `<div><ViewTransition><Component
    /></ViewTransition></div>` this won't trigger an "enter" animation since
    it was the div that was added, not the ViewTransition. Instead, it might
    cause a cross-fade of the parent ViewTransition or no transition if it
    had no parent. This ensures that only explicit boundaries perform coarse
    animations instead of every single node which is really the benefit of
    the View Transitions model. This ends up working out well for simple
    cases like switching between two pages immediately while transitioning
    one floating item that appears on both pages. Because only the floating
    item transitions by default.
    
    Note that it's possible to add manual `view-transition-name` with CSS or
    `style={{ viewTransitionName: 'auto' }}` that always transitions as long
    as something else has a `<ViewTransition>` that activates. For example a
    `<ViewTransition>` can wrap a whole page for a cross-fade but inside of
    it an explicit name can be added to something to ensure it animates as a
    move when something relates else changes its layout. Instead of just
    cross-fading it along with the Page which would be the default.
    
    There's more PRs coming with some optimizations, fixes and expanded
    APIs. This first PR explores the above core heuristic.
    
    ---------
    
    Co-authored-by: Sebastian "Sebbie" Silbermann <silbermann.sebastian@gmail.com>

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 71a1e973c3..11037d5f24 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -627,6 +627,10 @@ export function includesOnlyHydrationOrOffscreenLanes(lanes: Lanes): boolean {
   return (lanes & (HydrationLanes | OffscreenLane)) === lanes;
 }
 
+export function includesOnlyViewTransitionEligibleLanes(lanes: Lanes): boolean {
+  return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;
+}
+
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |

commit 800c9db22e69680f17e238724478537282215f89
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Jan 8 18:57:54 2025 -0500

    ViewTransitions in Navigation (#32028)
    
    This adds navigation support to the View Transition fixture using both
    `history.pushState/popstate` and the Navigation API models.
    
    Because `popstate` does scroll restoration synchronously at the end of
    the event, but `startViewTransition` cannot start synchronously, it
    would observe the "old" state as after applying scroll restoration. This
    leads to weird artifacts. So we intentionally do not support View
    Transitions in `popstate`. If it suspends anyway for some other reason,
    then scroll restoration is broken anyway and then it is supported. We
    don't have to do anything here because this is already how things worked
    because the sync `popstate` special case already included the sync lane
    which opts it out of View Transitions.
    
    For the Navigation API, scroll restoration can be blocked. The best way
    to do this is to resolve the Navigation API promise after React has
    applied its mutation. We can detect if there's currently any pending
    navigation and wait to resolve the `startViewTransition` until it
    finishes and any scroll restoration has been applied.
    
    
    https://github.com/user-attachments/assets/f53b3282-6315-4513-b3d6-b8981d66964e
    
    There is a subtle thing here. If we read the viewport metrics before
    scroll restoration has been applied, then we might assume something is
    or isn't going to be within the viewport incorrectly. This is evident on
    the "Slide In from Left" example. When we're going forward to that page
    we shift the scroll position such that it's going to appear in the
    viewport. If we did this before applying scroll restoration, it would
    not animate because it wasn't in the viewport then. Therefore, we need
    to run the after mutation phase after scroll restoration.
    
    A consequence of this is that you have to resolve Navigation in
    `useInsertionEffect` as otherwise it leads to a deadlock (which
    eventually gets broken by `startViewTransition`'s timeout of 10
    seconds). Another consequence is that now `useLayoutEffect` observes the
    restored state. However, I think what we'll likely do is move the layout
    phase to before the after mutation phase which also ensures that
    auto-scrolling inside `useLayoutEffect` are considered in the viewport
    measurements as well.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 11037d5f24..922fe2f977 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -350,6 +350,10 @@ export function getNextLanesToFlushSync(
   //
   // The main use case is updates scheduled by popstate events, which are
   // flushed synchronously even though they are transitions.
+  // Note that we intentionally treat this as a sync flush to include any
+  // sync updates in a single pass but also intentionally disables View Transitions
+  // inside popstate. Because they can start synchronously before scroll restoration
+  // happens.
   const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;
 
   // Early bailout if there's no pending work left.

commit a53da6abe1593483098df2baf927fe07d80153a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 13 16:06:01 2025 -0500

    Add useSwipeTransition Hook Behind Experimental Flag (#32373)
    
    This Hook will be used to drive a View Transition based on a gesture.
    
    ```js
    const [value, startGesture] = useSwipeTransition(prev, current, next);
    ```
    
    The `enableSwipeTransition` flag will depend on `enableViewTransition`
    flag but we may decide to ship them independently. This PR doesn't do
    anything interesting yet. There will be a lot more PRs to build out the
    actual functionality. This is just wiring up the plumbing for the new
    Hook.
    
    This first PR is mainly concerned with how the whole starts (and stops).
    The core API is the `startGesture` function (although there will be
    other conveniences added in the future). You can call this to start a
    gesture with a source provider. You can call this multiple times in one
    event to batch multiple Hooks listening to the same provider. However,
    each render can only handle one source provider at a time and so it does
    one render per scheduled gesture provider.
    
    This uses a separate `GestureLane` to drive gesture renders by marking
    the Hook as having an update on that lane. Then schedule a render. These
    renders should be blocking and in the same microtask as the
    `startGesture` to ensure it can block the paint. So it's similar to
    sync.
    
    It may not be possible to finish it synchronously e.g. if something
    suspends. If so, it just tries again later when it can like any other
    render. This can also happen because it also may not be possible to
    drive more than one gesture at a time like if we're limited to one View
    Transition per document. So right now you can only run one gesture at a
    time in practice.
    
    These renders never commit. This means that we can't clear the
    `GestureLane` the normal way. Instead, we have to clear only the root's
    `pendingLanes` if we don't have any new renders scheduled. Then wait
    until something else updates the Fiber after all gestures on it have
    stopped before it really clears.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 922fe2f977..22bf99624d 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -54,23 +54,24 @@ export const DefaultLane: Lane = /*                     */ 0b0000000000000000000
 export const SyncUpdateLanes: Lane =
   SyncLane | InputContinuousLane | DefaultLane;
 
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111110000000;
-const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
-const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
-const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
-const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
-const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
-const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
-const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
-const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
-const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
-const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
-const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
-const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
-const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
-const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
-const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
+export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;
+
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000;
 
 const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
 const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
@@ -175,6 +176,8 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return DefaultHydrationLane;
     case DefaultLane:
       return DefaultLane;
+    case GestureLane:
+      return GestureLane;
     case TransitionHydrationLane:
       return TransitionHydrationLane;
     case TransitionLane1:
@@ -191,7 +194,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
-    case TransitionLane15:
       return lanes & TransitionLanes;
     case RetryLane1:
     case RetryLane2:
@@ -459,6 +461,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case SyncLane:
     case InputContinuousHydrationLane:
     case InputContinuousLane:
+    case GestureLane:
       // User interactions should expire slightly more quickly.
       //
       // NOTE: This is set to the corresponding constant as in Scheduler.js.
@@ -486,7 +489,6 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
-    case TransitionLane15:
       return currentTime + transitionLaneExpirationMs;
     case RetryLane1:
     case RetryLane2:
@@ -640,7 +642,8 @@ export function includesBlockingLane(lanes: Lanes): boolean {
     InputContinuousHydrationLane |
     InputContinuousLane |
     DefaultHydrationLane |
-    DefaultLane;
+    DefaultLane |
+    GestureLane;
   return (lanes & SyncDefaultLanes) !== NoLanes;
 }
 
@@ -663,6 +666,11 @@ export function isTransitionLane(lane: Lane): boolean {
   return (lane & TransitionLanes) !== NoLanes;
 }
 
+export function isGestureRender(lanes: Lanes): boolean {
+  // This should render only the one lane.
+  return lanes === GestureLane;
+}
+
 export function claimNextTransitionLane(): Lane {
   // Cycle through the lanes, assigning each new transition to the next lane.
   // In most cases, this means every transition gets its own lane, until we
@@ -1053,7 +1061,6 @@ export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
-    case TransitionLane15:
     case RetryLane1:
     case RetryLane2:
     case RetryLane3:
@@ -1197,7 +1204,8 @@ export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
       InputContinuousHydrationLane |
       InputContinuousLane |
       DefaultHydrationLane |
-      DefaultLane)
+      DefaultLane |
+      GestureLane)
   ) {
     return 'Blocking';
   }

commit d3b8ff6e589bcacfd1c9b0aa48c42fd1c93001c1
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Mar 31 19:59:07 2025 -0400

    Unify BatchConfigTransition and Transition types  (#32783)
    
    This is some overdue refactoring. The two types never made sense. It
    also should be defined by isomorphic since it defines how it should be
    used by renderers rather than isomorphic depending on Fiber.
    
    Clean up hidden classes to be consistent.
    
    Fix missing name due to wrong types. I choose not to invoke the
    transition tracing callbacks if there's no name since the name is
    required there.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index 22bf99624d..eb65e69508 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -8,7 +8,7 @@
  */
 
 import type {Fiber, FiberRoot} from './ReactInternalTypes';
-import type {Transition} from './ReactFiberTracingMarkerComponent';
+import type {Transition} from 'react/src/ReactStartTransition';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 
 // TODO: Ideally these types would be opaque but that doesn't work well with

commit efb22d8850382c3b53c1b2b8d22036d7e6cc9488
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Apr 4 14:54:05 2025 -0400

    Add Suspensey Images behind a Flag (#32819)
    
    We've known we've wanted this for many years and most of the
    implementation was already done for Suspensey CSS. This waits to commit
    until images have decoded by default or up to 500ms timeout (same as
    suspensey fonts).
    
    It only applies to Transitions, Retries (Suspense), Gesture Transitions
    (flag) and Idle (doesn't exist). Sync updates just commit immediately.
    
    `<img loading="lazy" src="..." />` opts out since you explicitly want it
    to load lazily in that case.
    
    `<img onLoad={...} src="..." />` also opts out since that implies you're
    ok with managing your own reveal.
    
    In the future, we may add an opt in e.g. `<img blocking="render"
    src="..." />` that opts into longer timeouts and re-suspends even sync
    updates. Perhaps also triggering error boundaries on errors.
    
    The rollout for this would have to go in a major and we may have to
    relax the default timeout to not delay too much by default. However, we
    can also make this part of `enableViewTransition` so that if you opt-in
    by using View Transitions then those animations will suspend on images.
    That we could ship in a minor.

diff --git a/packages/react-reconciler/src/ReactFiberLane.js b/packages/react-reconciler/src/ReactFiberLane.js
index eb65e69508..6548aeac3a 100644
--- a/packages/react-reconciler/src/ReactFiberLane.js
+++ b/packages/react-reconciler/src/ReactFiberLane.js
@@ -637,6 +637,14 @@ export function includesOnlyViewTransitionEligibleLanes(lanes: Lanes): boolean {
   return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;
 }
 
+export function includesOnlySuspenseyCommitEligibleLanes(
+  lanes: Lanes,
+): boolean {
+  return (
+    (lanes & (TransitionLanes | RetryLanes | IdleLane | GestureLane)) === lanes
+  );
+}
+
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |

