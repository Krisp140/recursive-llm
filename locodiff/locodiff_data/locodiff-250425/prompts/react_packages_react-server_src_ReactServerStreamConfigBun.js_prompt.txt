# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-server/src/ReactServerStreamConfigBun.js

commit 56ffca8b9e4e49ad46136fe705203afc2d20fd9f
Author: Colin McDonnell <colinmcd94@gmail.com>
Date:   Thu Nov 17 13:15:56 2022 -0800

    Add Bun streaming server renderer (#25597)
    
    Add support for Bun server renderer

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
new file mode 100644
index 0000000000..c50ce77fa9
--- /dev/null
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -0,0 +1,81 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+type BunReadableStreamController = ReadableStreamController & {
+  end(): mixed,
+  write(data: Chunk): void,
+  error(error: Error): void,
+};
+export type Destination = BunReadableStreamController;
+
+export type PrecomputedChunk = string;
+export opaque type Chunk = string;
+
+export function scheduleWork(callback: () => void) {
+  callback();
+}
+
+export function flushBuffered(destination: Destination) {
+  // WHATWG Streams do not yet have a way to flush the underlying
+  // transform streams. https://github.com/whatwg/streams/issues/960
+}
+
+// AsyncLocalStorage is not available in bun
+export const supportsRequestStorage = false;
+export const requestStorage = (null: any);
+
+export function beginWriting(destination: Destination) {}
+
+export function writeChunk(
+  destination: Destination,
+  chunk: PrecomputedChunk | Chunk,
+): void {
+  if (chunk.length === 0) {
+    return;
+  }
+
+  destination.write(chunk);
+}
+
+export function writeChunkAndReturn(
+  destination: Destination,
+  chunk: PrecomputedChunk | Chunk,
+): boolean {
+  return !!destination.write(chunk);
+}
+
+export function completeWriting(destination: Destination) {}
+
+export function close(destination: Destination) {
+  destination.end();
+}
+
+export function stringToChunk(content: string): Chunk {
+  return content;
+}
+
+export function stringToPrecomputedChunk(content: string): PrecomputedChunk {
+  return content;
+}
+
+export function closeWithError(destination: Destination, error: mixed): void {
+  // $FlowFixMe[method-unbinding]
+  if (typeof destination.error === 'function') {
+    // $FlowFixMe: This is an Error object or the destination accepts other types.
+    destination.error(error);
+  } else {
+    // Earlier implementations doesn't support this method. In that environment you're
+    // supposed to throw from a promise returned but we don't return a promise in our
+    // approach. We could fork this implementation but this is environment is an edge
+    // case to begin with. It's even less common to run this in an older environment.
+    // Even then, this is not where errors are supposed to happen and they get reported
+    // to a global callback in addition to this anyway. So it's fine just to close this.
+    destination.close();
+  }
+}

commit 2655c9354d8e1c54ba888444220f63e836925caa
Author: Jimmy Lai <laijimmy0@gmail.com>
Date:   Tue Nov 22 01:33:41 2022 +0100

    Fizz Browser: fix precomputed chunk being cleared on Node 18 (#25645)
    
    ## Edit
    
    Went for another approach after talking with @gnoff. The approach is
    now:
    - add a dev-only error when a precomputed chunk is too big to be written
    - suggest to copy it before passing it to `writeChunk`
    
    This PR also includes porting the React Float tests to use the browser
    build of Fizz so that we can test it out on that environment (which is
    the one used by next).
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn debug-test --watch TestName`, open
    `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    Someone reported [a bug](https://github.com/vercel/next.js/issues/42466)
    in Next.js that pointed to an issue with Node 18 in the streaming
    renderer when using importing a CSS module where it only returned a
    malformed bootstraping script only after loading the page once.
    
    After investigating a bit, here's what I found:
    
    - when using a CSS module in Next, we go into this code path, which
    writes the aforementioned bootstrapping script
    
    
    https://github.com/facebook/react/blob/5f7ef8c4cbe824ef126a947b7ae0e1c07b143357/packages/react-dom-bindings/src/server/ReactDOMServerFormatConfig.js#L2443-L2447
    
    - the reason for the malformed script is that
    `completeBoundaryWithStylesScript1FullBoth` is emptied after the call to
    `writeChunk`
    - it gets emptied in `writeChunk` because we stream the chunk directly
    without copying it in this codepath
    
    https://github.com/facebook/react/blob/a438590144d2ad40865b58e0c0e69595fc1aa377/packages/react-server/src/ReactServerStreamConfigBrowser.js#L63
    - the reason why it only happens from Node 18 is because the Webstreams
    APIs are available natively from that version and in their
    implementation, [`enqueue` transfers the array buffer
    ownership](https://github.com/nodejs/node/blob/9454ba6138d11e8a4d18b073de25781cad4bd2c8/lib/internal/webstreams/readablestream.js#L2641),
    thus making it unavailable/empty for subsequent calls. In older Node
    versions, we don't encounter the bug because we are using a polyfill in
    Next.js, [which does not implement properly the array buffer transfer
    behaviour](https://cs.github.com/MattiasBuelens/web-streams-polyfill/blob/d354a7457ca8a24030dbd0a135ee40baed7c774d/src/lib/abstract-ops/ecmascript.ts#L16).
    
    I think the proper fix for this is to clone the array buffer before
    enqueuing it. (we do this in the other code paths in the function later
    on, see ```((currentView: any): Uint8Array).set(bytesToWrite,
    writtenBytes);```
    
    
    
    
    
    ## How did you test this change?
    
    Manually tested by applying the change in the compiled Next.js version.
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    
    Co-authored-by: Sebastian Markbage <sebastian@calyptus.eu>

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index c50ce77fa9..fd90c17a3d 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -64,6 +64,12 @@ export function stringToPrecomputedChunk(content: string): PrecomputedChunk {
   return content;
 }
 
+export function clonePrecomputedChunk(
+  chunk: PrecomputedChunk,
+): PrecomputedChunk {
+  return chunk;
+}
+
 export function closeWithError(destination: Destination, error: mixed): void {
   // $FlowFixMe[method-unbinding]
   if (typeof destination.error === 'function') {

commit c49131669ba23500b8b071a5ca6ef189a28aa83e
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 10 10:32:42 2023 -0500

    Remove unused Flow suppressions (#25977)
    
    These suppressions are no longer required.
    
    Generated using:
    ```sh
    flow/tool update-suppressions .
    ```
    followed by adding back 1 or 2 suppressions that were only triggered in
    some configurations.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index fd90c17a3d..addbd51113 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -71,7 +71,6 @@ export function clonePrecomputedChunk(
 }
 
 export function closeWithError(destination: Destination, error: mixed): void {
-  // $FlowFixMe[method-unbinding]
   if (typeof destination.error === 'function') {
     // $FlowFixMe: This is an Error object or the destination accepts other types.
     destination.error(error);

commit afea1d0c536e0336735b0ea5c74f635527b65785
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Mar 27 13:43:04 2023 +0200

    [flow] make Flow suppressions explicit on the error (#26487)
    
    Added an explicit type to all $FlowFixMe suppressions to reduce
    over-suppressions of new errors that might be caused on the same lines.
    
    Also removes suppressions that aren't used (e.g. in a `@noflow` file as
    they're purely misleading)
    
    Test Plan:
    yarn flow-ci

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index addbd51113..9cc88c4086 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -72,7 +72,7 @@ export function clonePrecomputedChunk(
 
 export function closeWithError(destination: Destination, error: mixed): void {
   if (typeof destination.error === 'function') {
-    // $FlowFixMe: This is an Error object or the destination accepts other types.
+    // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.
     destination.error(error);
   } else {
     // Earlier implementations doesn't support this method. In that environment you're

commit 36e4cbe2e918ec9c8a7abbfda28898c835361fb2
Author: Josh Story <story@hey.com>
Date:   Fri Apr 21 20:45:51 2023 -0700

    [Float][Flight] Flight support for Float (#26502)
    
    Stacked on #26557
    
    Supporting Float methods such as ReactDOM.preload() are challenging for
    flight because it does not have an easy means to convey direct
    executions in other environments. Because the flight wire format is a
    JSON-like serialization that is expected to be rendered it currently
    only describes renderable elements. We need a way to convey a function
    invocation that gets run in the context of the client environment
    whether that is Fizz or Fiber.
    
    Fiber is somewhat straightforward because the HostDispatcher is always
    active and we can just have the FlightClient dispatch the serialized
    directive.
    
    Fizz is much more challenging becaue the dispatcher is always scoped but
    the specific request the dispatch belongs to is not readily available.
    Environments that support AsyncLocalStorage (or in the future
    AsyncContext) we will use this to be able to resolve directives in Fizz
    to the appropriate Request. For other environments directives will be
    elided. Right now this is pragmatic and non-breaking because all
    directives are opportunistic and non-critical. If this changes in the
    future we will need to reconsider how widespread support for async
    context tracking is.
    
    For Flight, if AsyncLocalStorage is available Float methods can be
    called before and after await points and be expected to work. If
    AsyncLocalStorage is not available float methods called in the sync
    phase of a component render will be captured but anything after an await
    point will be a noop. If a float call is dropped in this manner a DEV
    warning should help you realize your code may need to be modified.
    
    This PR also introduces a way for resources (Fizz) and hints (Flight) to
    flush even if there is not active task being worked on. This will help
    when Float methods are called in between async points within a function
    execution but the task is blocked on the entire function finishing.
    
    This PR also introduces deduping of Hints in Flight using the same
    resource keys used in Fizz. This will help shrink payload sizes when the
    same hint is attempted to emit over and over again

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 9cc88c4086..b71b6542f3 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -26,10 +26,6 @@ export function flushBuffered(destination: Destination) {
   // transform streams. https://github.com/whatwg/streams/issues/960
 }
 
-// AsyncLocalStorage is not available in bun
-export const supportsRequestStorage = false;
-export const requestStorage = (null: any);
-
 export function beginWriting(destination: Destination) {}
 
 export function writeChunk(

commit db50164dbac39d7421c936689a5c026e9fd2f034
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Jun 12 22:16:47 2023 -0400

    [Flight] Optimize Large Strings by Not Escaping Them (#26932)
    
    This introduces a Text row (T) which is essentially a string blob and
    refactors the parsing to now happen at the binary level.
    
    ```
    RowID + ":" + "T" + ByteLengthInHex + "," + Text
    ```
    
    Today, we encode all row data in JSON, which conveniently never has
    newline characters and so we use newline as the line terminator. We
    can't do that if we pass arbitrary unicode without escaping it. Instead,
    we pass the byte length (in hexadecimal) in the leading header for this
    row tag followed by a comma.
    
    We could be clever and use fixed or variable-length binary integers for
    the row id and length but it's not worth the more difficult
    debuggability so we keep these human readable in text.
    
    Before this PR, we used to decode the binary stream into UTF-8 strings
    before parsing them. This is inefficient because sometimes the slices
    end up having to be copied so it's better to decode it directly into the
    format. The follow up to this is also to add support for binary data and
    then we can't assume the entire payload is UTF-8 anyway. So this
    refactors the parser to parse the rows in binary and then decode the
    result into UTF-8. It does add some overhead to decoding on a per row
    basis though.
    
    Since we do this, we need to encode the byte length that we want decode
    - not the string length. Therefore, this requires clients to receive
    binary data and why I had to delete the string option.
    
    It also means that I had to add a way to get the byteLength from a chunk
    since they're not always binary. For Web streams it's easy since they're
    always typed arrays. For Node streams it's trickier so we use the
    byteLength helper which may not be very efficient. Might be worth
    eagerly encoding them to UTF8 - perhaps only for this case.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index b71b6542f3..ac245209d5 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -66,6 +66,10 @@ export function clonePrecomputedChunk(
   return chunk;
 }
 
+export function byteLengthOfChunk(chunk: Chunk | PrecomputedChunk): number {
+  return Buffer.byteLength(chunk, 'utf8');
+}
+
 export function closeWithError(destination: Destination, error: mixed): void {
   if (typeof destination.error === 'function') {
     // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.

commit d9c333199ed19798484e49eef992735321c32cb9
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Jun 29 13:16:12 2023 -0400

    [Flight] Add Serialization of Typed Arrays / ArrayBuffer / DataView (#26954)
    
    This uses the same mechanism as [large
    strings](https://github.com/facebook/react/pull/26932) to encode chunks
    of length based binary data in the RSC payload behind a flag.
    
    I introduce a new BinaryChunk type that's specific to each stream and
    ways to convert into it. That's because we sometimes need all chunks to
    be Uint8Array for the output, even if the source is another array buffer
    view, and sometimes we need to clone it before transferring.
    
    Each type of typed array is its own row tag. This lets us ensure that
    the instance is directly in the right format in the cached entry instead
    of creating a wrapper at each reference. Ideally this is also how
    Map/Set should work but those are lazy which complicates that approach a
    bit.
    
    We assume both server and client use little-endian for now. If we want
    to support other modes, we'd convert it to/from little-endian so that
    the transfer protocol is always little-endian. That way the common
    clients can be the fastest possible.
    
    So far this only implements Server to Client. Still need to implement
    Client to Server for parity.
    
    NOTE: This is the first time we make RSC effectively a binary format.
    This is not compatible with existing SSR techniques which serialize the
    stream as unicode in the HTML. To be compatible, those implementations
    would have to use base64 or something like that. Which is what we'll do
    when we move this technique to be built-in to Fizz.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index ac245209d5..27317f0925 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -9,13 +9,14 @@
 
 type BunReadableStreamController = ReadableStreamController & {
   end(): mixed,
-  write(data: Chunk): void,
+  write(data: Chunk | BinaryChunk): void,
   error(error: Error): void,
 };
 export type Destination = BunReadableStreamController;
 
 export type PrecomputedChunk = string;
 export opaque type Chunk = string;
+export type BinaryChunk = $ArrayBufferView;
 
 export function scheduleWork(callback: () => void) {
   callback();
@@ -30,7 +31,7 @@ export function beginWriting(destination: Destination) {}
 
 export function writeChunk(
   destination: Destination,
-  chunk: PrecomputedChunk | Chunk,
+  chunk: PrecomputedChunk | Chunk | BinaryChunk,
 ): void {
   if (chunk.length === 0) {
     return;
@@ -41,7 +42,7 @@ export function writeChunk(
 
 export function writeChunkAndReturn(
   destination: Destination,
-  chunk: PrecomputedChunk | Chunk,
+  chunk: PrecomputedChunk | Chunk | BinaryChunk,
 ): boolean {
   return !!destination.write(chunk);
 }
@@ -60,6 +61,13 @@ export function stringToPrecomputedChunk(content: string): PrecomputedChunk {
   return content;
 }
 
+export function typedArrayToBinaryChunk(
+  content: $ArrayBufferView,
+): BinaryChunk {
+  // TODO: Does this needs to be cloned if it's transferred in enqueue()?
+  return content;
+}
+
 export function clonePrecomputedChunk(
   chunk: PrecomputedChunk,
 ): PrecomputedChunk {
@@ -70,6 +78,10 @@ export function byteLengthOfChunk(chunk: Chunk | PrecomputedChunk): number {
   return Buffer.byteLength(chunk, 'utf8');
 }
 
+export function byteLengthOfBinaryChunk(chunk: BinaryChunk): number {
+  return chunk.byteLength;
+}
+
 export function closeWithError(destination: Destination, error: mixed): void {
   if (typeof destination.error === 'function') {
     // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.

commit 2b3d5826836ac59f8446281976762d594e55d97e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 20 17:13:14 2023 -0400

    useFormState: Hash the component key path for more compact output (#27397)
    
    To support MPA-style form submissions, useFormState sends down a key
    that represents the identity of the hook on the page. It's based on the
    key path of the component within the React tree; for deeply nested
    hooks, this keypath can become very long. We can hash the key to make it
    shorter.
    
    Adds a method called createFastHash to the Stream Config interface.
    We're not using this for security or obfuscation, only to generate a
    more compact key without sacrificing too much collision resistance.
    
    - In Node.js builds, createFastHash uses the built-in crypto module.
    - In Bun builds, createFastHash uses Bun.hash. See:
    https://bun.sh/docs/api/hashing#bun-hash
    
    I have not yet implemented createFastHash in the Edge, Browser, or FB
    (Hermes) stream configs because those environments do not have a
    built-in hashing function that meets our requirements. (We can't use the
    web standard `crypto` API because those methods are async, and yielding
    to the main thread is too costly to be worth it for this particular use
    case.) We'll likely use a pure JS implementation in those environments;
    for now, they just return the original string without hashing it. I'll
    address this in separate PRs.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 27317f0925..276c7f59e4 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -7,6 +7,8 @@
  * @flow
  */
 
+/* global Bun */
+
 type BunReadableStreamController = ReadableStreamController & {
   end(): mixed,
   write(data: Chunk | BinaryChunk): void,
@@ -96,3 +98,7 @@ export function closeWithError(destination: Destination, error: mixed): void {
     destination.close();
   }
 }
+
+export function createFastHash(input: string): string | number {
+  return Bun.hash(input);
+}

commit b09e102ff1e2aaaf5eb6585b04609ac7ff54a5c8
Author: Josh Story <story@hey.com>
Date:   Sat Mar 16 12:39:37 2024 -0700

    [Fizz] Prevent uncloned large precomputed chunks without relying on render-time assertions (#28568)
    
    A while back we implemented a heuristic that if a chunk was large it was
    assumed to be produced by the render and thus was safe to stream which
    results in transferring the underlying object memory. Later we ran into
    an issue where a precomputed chunk grew large enough to trigger this
    hueristic and it started causing renders to fail because once a second
    render had occurred the precomputed chunk would not have an underlying
    buffer of bytes to send and these bytes would be omitted from the
    stream. We implemented a technique to detect large precomputed chunks
    and we enforced that these always be cloned before writing.
    Unfortunately our test coverage was not perfect and there has been for a
    very long time now a usage pattern where if you complete a boundary in
    one flush and then complete a boundary that has stylehsheet dependencies
    in another flush you can get a large precomputed chunk that was not
    being cloned to be sent twice causing streaming errors.
    
    I've thought about why we even went with this solution in the first
    place and I think it was a mistake. It relies on a dev only check to
    catch paired with potentially version specific order of operations on
    the streaming side. This is too unreliable. Additionally the low limit
    of view size for Edge is not used in Node.js but there is not real
    justification for this.
    
    In this change I updated the view size for edge streaming to match Node
    at 2048 bytes which is still relatively small and we have no data one
    way or another to preference 512 over this. Then I updated the assertion
    logic to error anytime a precomputed chunk exceeds the size. This
    eliminates the need to clone these chunks by just making sure our view
    size is always larger than the largest precomputed chunk we can possibly
    write. I'm generally in favor of this for a few reasons.
    
    First, we'll always know during testing whether we've violated the limit
    as long as we exercise each stream config because the precomputed chunks
    are created in module scope. Second, we can always split up large chunks
    so making sure the precomptued chunk is smaller than whatever view size
    we actually desire is relatively trivial.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 276c7f59e4..ac8ae3f1a5 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -70,12 +70,6 @@ export function typedArrayToBinaryChunk(
   return content;
 }
 
-export function clonePrecomputedChunk(
-  chunk: PrecomputedChunk,
-): PrecomputedChunk {
-  return chunk;
-}
-
 export function byteLengthOfChunk(chunk: Chunk | PrecomputedChunk): number {
   return Buffer.byteLength(chunk, 'utf8');
 }

commit c113503ad131101b19b4a5c1e4639b8588ecd993
Author: Kenta Iwasaki <63115601+lithdew@users.noreply.github.com>
Date:   Mon Apr 15 23:25:08 2024 +0800

    Flush direct streams in Bun (#28837)
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn test --debug --watch TestName`,
    open `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    The ReadableStreamController for [direct
    streams](https://bun.sh/docs/api/streams#direct-readablestream) in Bun
    supports a flush() method to flush all buffered items to its underlying
    sink.
    
    Without manually calling flush(), all buffered items are only flushed to
    the underlying sink when the stream is closed. This behavior causes the
    shell rendered against Suspense boundaries never to be flushed to the
    underlying sink.
    
    ## How did you test this change?
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    
    A lot of changes to the test runner will need to be made in order to
    support the Bun runtime. A separate test was manually run in order to
    ensure that the changes made are correct.
    
    The test works by sanity-checking that the shell rendered against
    Suspense boundaries are emitted first in the stream.
    
    This test was written and run on Bun v1.1.3.
    
    ```ts
    import { Suspense } from "react";
    import { renderToReadableStream } from "react-dom/server";
    
    if (!import.meta.resolveSync("react-dom/server").endsWith("server.bun.js")) {
      throw new Error("react-dom/server is not the correct version:\n  " + import.meta.resolveSync("react-dom/server"));
    }
    
    const A = async () => {
      await new Promise(resolve => setImmediate(resolve));
      return <div>hi</div>;
    };
    
    const B = async () => {
      return (
        <Suspense fallback={<div>loading</div>}>
          <A />
        </Suspense>
      );
    };
    
    const stream = await renderToReadableStream(<B />);
    
    let text = "";
    let count = 0;
    for await (const chunk of stream) {
      text += new TextDecoder().decode(chunk);
      count++;
    }
    
    if (
      text !==
      `<!--$?--><template id="B:0"></template><div>loading</div><!--/$--><div hidden id="S:0"><div>hi</div></div><script>$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("B:0","S:0")</script>`
    ) {
      throw new Error("unexpected output");
    }
    if (count !== 2) {
      throw new Error("expected 2 chunks from react ssr stream");
    }
    ```

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index ac8ae3f1a5..4686e0e970 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -13,6 +13,7 @@ type BunReadableStreamController = ReadableStreamController & {
   end(): mixed,
   write(data: Chunk | BinaryChunk): void,
   error(error: Error): void,
+  flush?: () => void,
 };
 export type Destination = BunReadableStreamController;
 
@@ -25,8 +26,12 @@ export function scheduleWork(callback: () => void) {
 }
 
 export function flushBuffered(destination: Destination) {
-  // WHATWG Streams do not yet have a way to flush the underlying
-  // transform streams. https://github.com/whatwg/streams/issues/960
+  // Bun direct streams provide a flush function.
+  // If we don't have any more data to send right now.
+  // Flush whatever is in the buffer to the wire.
+  if (typeof destination.flush === 'function') {
+    destination.flush();
+  }
 }
 
 export function beginWriting(destination: Destination) {}

commit b526a0a419029eea31f4d967951b6feca123012d
Author: Josh Story <story@hey.com>
Date:   Thu Jun 6 10:07:24 2024 -0700

    [Flight][Fizz] schedule work async (#29551)
    
    While most builds of Flight and Fizz schedule work in new tasks some do
    execute work synchronously. While this is necessary for legacy APIs like
    renderToString for modern APIs there really isn't a great reason to do
    this synchronously.
    
    We could schedule works as microtasks but we actually want to yield so
    the runtime can run events and other things that will unblock additional
    work before starting the next work loop.
    
    This change updates all non-legacy uses to be async using the best
    availalble macrotask scheduler.
    
    Browser now uses postMessage
    Bun uses setTimeout because while it also supports setImmediate the
    scheduling is not as eager as the same API in node
    the FB build also uses setTimeout
    
    This change required a number of changes to tests which were utilizing
    the sync nature of work in the Browser builds to avoid having to manage
    timers and tasks. I added a patch to install MessageChannel which is
    required by the browser builds and made this patched version integrate
    with the Scheduler mock. This way we can effectively use `act` to flush
    flight and fizz work similar to how we do this on the client.

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 4686e0e970..36c94570ec 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -22,7 +22,7 @@ export opaque type Chunk = string;
 export type BinaryChunk = $ArrayBufferView;
 
 export function scheduleWork(callback: () => void) {
-  callback();
+  setTimeout(callback, 0);
 }
 
 export function flushBuffered(destination: Destination) {

commit 1e1e5cd25223fddbce0e3fb7889b06df0d93a950
Author: Josh Story <story@hey.com>
Date:   Thu Jun 6 10:19:57 2024 -0700

    [Flight] Schedule work in a microtask (#29491)
    
    Stacked on #29551
    
    Flight pings much more often than Fizz because async function components
    will always take at least a microtask to resolve . Rather than
    scheduling this work as a new macrotask Flight now schedules pings in a
    microtask. This allows more microtasks to ping before actually doing a
    work flush but doesn't force the vm to spin up a new task which is quite
    common give n the nature of Server Components

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 36c94570ec..81f86a50b7 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -25,6 +25,8 @@ export function scheduleWork(callback: () => void) {
   setTimeout(callback, 0);
 }
 
+export const scheduleMicrotask = queueMicrotask;
+
 export function flushBuffered(destination: Destination) {
   // Bun direct streams provide a flush function.
   // If we don't have any more data to send right now.

commit ea05b750a5374458fc8c74ea0918059c818d1167
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 8 12:11:41 2025 -0400

    Allow Passing Blob/File/MediaSource/MediaStream to src of <img>, <video> and <audio> (#32828)
    
    Behind the `enableSrcObject` flag. This is revisiting a variant of what
    was discussed in #11163.
    
    Instead of supporting the [`srcObject`
    property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/srcObject)
    as a separate name, this adds an overload of `src` to allow objects to
    be passed. The DOM needs to add separate properties for the object forms
    since you read back but it doesn't make sense for React's write-only API
    to do that. Similar to how we'll like add an overload for
    `popoverTarget` instead of calling it `popoverTargetElement` and how
    `style` accepts an object and it's not `styleObject={{...}}`.
    
    There are a number of reason to revisit this.
    
    - It's just way more convenient to have this built-in and it makes
    conceptual sense. We typically support declarative APIs and polyfill
    them when necessary.
    - RSC supports Blobs and by having it built-in you don't need a Client
    Component wrapper to render it where as doing it with effects would
    require more complex wrappers. By picking Blobs over base64,
    client-navigations can use the more optimized binary encoding in the RSC
    protocol.
    - The timing aspect of coordinating it with Suspensey images and image
    decoding is a bit tricky to get right because if you set it in an effect
    it's too late because you've already rendered it.
    - SSR gets complicated when done in user space because you have to
    handle both branches. Likely with `useSyncExternalStore`.
    - By having it built-in we could optimize the payloads shared between
    RSC payloads embedded in the HTML and data URLs.
    
    This does not support objects for `<source src>` nor `<img srcset>`.
    Those don't really have equivalents in the DOM neither. They're mainly
    for picking an option when you don't know programmatically. However, for
    this use case you're really better off picking a variant before
    generating the blobs.
    
    We may support Response objects in the future too as per
    https://github.com/whatwg/fetch/issues/49

diff --git a/packages/react-server/src/ReactServerStreamConfigBun.js b/packages/react-server/src/ReactServerStreamConfigBun.js
index 81f86a50b7..a8efb778e8 100644
--- a/packages/react-server/src/ReactServerStreamConfigBun.js
+++ b/packages/react-server/src/ReactServerStreamConfigBun.js
@@ -103,3 +103,11 @@ export function closeWithError(destination: Destination, error: mixed): void {
 export function createFastHash(input: string): string | number {
   return Bun.hash(input);
 }
+
+export function readAsDataURL(blob: Blob): Promise<string> {
+  return blob.arrayBuffer().then(arrayBuffer => {
+    const encoded = Buffer.from(arrayBuffer).toString('base64');
+    const mimeType = blob.type || 'application/octet-stream';
+    return 'data:' + mimeType + ';base64,' + encoded;
+  });
+}

