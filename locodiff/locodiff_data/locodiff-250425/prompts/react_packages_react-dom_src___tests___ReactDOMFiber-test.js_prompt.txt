# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactDOMFiber-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
new file mode 100644
index 0000000000..36f63a3b4f
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -0,0 +1,1152 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var React = require('react');
+var ReactDOM = require('react-dom');
+var ReactTestUtils = require('react-dom/test-utils');
+var PropTypes = require('prop-types');
+
+describe('ReactDOMFiber', () => {
+  function normalizeCodeLocInfo(str) {
+    return str && str.replace(/\(at .+?:\d+\)/g, '(at **)');
+  }
+
+  var container;
+
+  beforeEach(() => {
+    container = document.createElement('div');
+  });
+
+  it('should render strings as children', () => {
+    const Box = ({value}) => <div>{value}</div>;
+
+    ReactDOM.render(<Box value="foo" />, container);
+    expect(container.textContent).toEqual('foo');
+  });
+
+  it('should render numbers as children', () => {
+    const Box = ({value}) => <div>{value}</div>;
+
+    ReactDOM.render(<Box value={10} />, container);
+
+    expect(container.textContent).toEqual('10');
+  });
+
+  it('should be called a callback argument', () => {
+    // mounting phase
+    let called = false;
+    ReactDOM.render(<div>Foo</div>, container, () => (called = true));
+    expect(called).toEqual(true);
+
+    // updating phase
+    called = false;
+    ReactDOM.render(<div>Foo</div>, container, () => (called = true));
+    expect(called).toEqual(true);
+  });
+
+  it('should call a callback argument when the same element is re-rendered', () => {
+    class Foo extends React.Component {
+      render() {
+        return <div>Foo</div>;
+      }
+    }
+    const element = <Foo />;
+
+    // mounting phase
+    let called = false;
+    ReactDOM.render(element, container, () => (called = true));
+    expect(called).toEqual(true);
+
+    // updating phase
+    called = false;
+    ReactDOM.unstable_batchedUpdates(() => {
+      ReactDOM.render(element, container, () => (called = true));
+    });
+    expect(called).toEqual(true);
+  });
+
+  it('should render a component returning strings directly from render', () => {
+    const Text = ({value}) => value;
+
+    ReactDOM.render(<Text value="foo" />, container);
+    expect(container.textContent).toEqual('foo');
+  });
+
+  it('should render a component returning numbers directly from render', () => {
+    const Text = ({value}) => value;
+
+    ReactDOM.render(<Text value={10} />, container);
+
+    expect(container.textContent).toEqual('10');
+  });
+
+  it('finds the DOM Text node of a string child', () => {
+    class Text extends React.Component {
+      render() {
+        return this.props.value;
+      }
+    }
+
+    let instance = null;
+    ReactDOM.render(
+      <Text value="foo" ref={ref => (instance = ref)} />,
+      container,
+    );
+
+    const textNode = ReactDOM.findDOMNode(instance);
+    expect(textNode).toBe(container.firstChild);
+    expect(textNode.nodeType).toBe(3);
+    expect(textNode.nodeValue).toBe('foo');
+  });
+
+  it('finds the first child when a component returns a fragment', () => {
+    class Fragment extends React.Component {
+      render() {
+        return [<div key="a" />, <span key="b" />];
+      }
+    }
+
+    let instance = null;
+    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
+
+    expect(container.childNodes.length).toBe(2);
+
+    const firstNode = ReactDOM.findDOMNode(instance);
+    expect(firstNode).toBe(container.firstChild);
+    expect(firstNode.tagName).toBe('DIV');
+  });
+
+  it('finds the first child even when fragment is nested', () => {
+    class Wrapper extends React.Component {
+      render() {
+        return this.props.children;
+      }
+    }
+
+    class Fragment extends React.Component {
+      render() {
+        return [<Wrapper key="a"><div /></Wrapper>, <span key="b" />];
+      }
+    }
+
+    let instance = null;
+    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
+
+    expect(container.childNodes.length).toBe(2);
+
+    const firstNode = ReactDOM.findDOMNode(instance);
+    expect(firstNode).toBe(container.firstChild);
+    expect(firstNode.tagName).toBe('DIV');
+  });
+
+  it('finds the first child even when first child renders null', () => {
+    class NullComponent extends React.Component {
+      render() {
+        return null;
+      }
+    }
+
+    class Fragment extends React.Component {
+      render() {
+        return [<NullComponent key="a" />, <div key="b" />, <span key="c" />];
+      }
+    }
+
+    let instance = null;
+    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
+
+    expect(container.childNodes.length).toBe(2);
+
+    const firstNode = ReactDOM.findDOMNode(instance);
+    expect(firstNode).toBe(container.firstChild);
+    expect(firstNode.tagName).toBe('DIV');
+  });
+
+  var svgEls, htmlEls, mathEls;
+  var expectSVG = {ref: el => svgEls.push(el)};
+  var expectHTML = {ref: el => htmlEls.push(el)};
+  var expectMath = {ref: el => mathEls.push(el)};
+
+  var usePortal = function(tree) {
+    return ReactDOM.createPortal(tree, document.createElement('div'));
+  };
+
+  var assertNamespacesMatch = function(tree) {
+    container = document.createElement('div');
+    svgEls = [];
+    htmlEls = [];
+    mathEls = [];
+
+    ReactDOM.render(tree, container);
+    svgEls.forEach(el => {
+      expect(el.namespaceURI).toBe('http://www.w3.org/2000/svg');
+    });
+    htmlEls.forEach(el => {
+      expect(el.namespaceURI).toBe('http://www.w3.org/1999/xhtml');
+    });
+    mathEls.forEach(el => {
+      expect(el.namespaceURI).toBe('http://www.w3.org/1998/Math/MathML');
+    });
+
+    ReactDOM.unmountComponentAtNode(container);
+    expect(container.innerHTML).toBe('');
+  };
+
+  it('should render one portal', () => {
+    var portalContainer = document.createElement('div');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(<div>portal</div>, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.unmountComponentAtNode(container);
+    expect(portalContainer.innerHTML).toBe('');
+    expect(container.innerHTML).toBe('');
+  });
+
+  // TODO: remove in React 17
+  it('should support unstable_createPortal alias', () => {
+    var portalContainer = document.createElement('div');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.unmountComponentAtNode(container);
+    expect(portalContainer.innerHTML).toBe('');
+    expect(container.innerHTML).toBe('');
+  });
+
+  it('should render many portals', () => {
+    var portalContainer1 = document.createElement('div');
+    var portalContainer2 = document.createElement('div');
+
+    var ops = [];
+    class Child extends React.Component {
+      componentDidMount() {
+        ops.push(`${this.props.name} componentDidMount`);
+      }
+      componentDidUpdate() {
+        ops.push(`${this.props.name} componentDidUpdate`);
+      }
+      componentWillUnmount() {
+        ops.push(`${this.props.name} componentWillUnmount`);
+      }
+      render() {
+        return <div>{this.props.name}</div>;
+      }
+    }
+
+    class Parent extends React.Component {
+      componentDidMount() {
+        ops.push(`Parent:${this.props.step} componentDidMount`);
+      }
+      componentDidUpdate() {
+        ops.push(`Parent:${this.props.step} componentDidUpdate`);
+      }
+      componentWillUnmount() {
+        ops.push(`Parent:${this.props.step} componentWillUnmount`);
+      }
+      render() {
+        const {step} = this.props;
+        return [
+          <Child key="a" name={`normal[0]:${step}`} />,
+          ReactDOM.createPortal(
+            <Child key="b" name={`portal1[0]:${step}`} />,
+            portalContainer1,
+          ),
+          <Child key="c" name={`normal[1]:${step}`} />,
+          ReactDOM.createPortal(
+            [
+              <Child key="d" name={`portal2[0]:${step}`} />,
+              <Child key="e" name={`portal2[1]:${step}`} />,
+            ],
+            portalContainer2,
+          ),
+        ];
+      }
+    }
+
+    ReactDOM.render(<Parent step="a" />, container);
+    expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:a</div>');
+    expect(portalContainer2.innerHTML).toBe(
+      '<div>portal2[0]:a</div><div>portal2[1]:a</div>',
+    );
+    expect(container.innerHTML).toBe(
+      '<div>normal[0]:a</div><div>normal[1]:a</div>',
+    );
+    expect(ops).toEqual([
+      'normal[0]:a componentDidMount',
+      'portal1[0]:a componentDidMount',
+      'normal[1]:a componentDidMount',
+      'portal2[0]:a componentDidMount',
+      'portal2[1]:a componentDidMount',
+      'Parent:a componentDidMount',
+    ]);
+
+    ops.length = 0;
+    ReactDOM.render(<Parent step="b" />, container);
+    expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:b</div>');
+    expect(portalContainer2.innerHTML).toBe(
+      '<div>portal2[0]:b</div><div>portal2[1]:b</div>',
+    );
+    expect(container.innerHTML).toBe(
+      '<div>normal[0]:b</div><div>normal[1]:b</div>',
+    );
+    expect(ops).toEqual([
+      'normal[0]:b componentDidUpdate',
+      'portal1[0]:b componentDidUpdate',
+      'normal[1]:b componentDidUpdate',
+      'portal2[0]:b componentDidUpdate',
+      'portal2[1]:b componentDidUpdate',
+      'Parent:b componentDidUpdate',
+    ]);
+
+    ops.length = 0;
+    ReactDOM.unmountComponentAtNode(container);
+    expect(portalContainer1.innerHTML).toBe('');
+    expect(portalContainer2.innerHTML).toBe('');
+    expect(container.innerHTML).toBe('');
+    expect(ops).toEqual([
+      'Parent:b componentWillUnmount',
+      'normal[0]:b componentWillUnmount',
+      'portal1[0]:b componentWillUnmount',
+      'normal[1]:b componentWillUnmount',
+      'portal2[0]:b componentWillUnmount',
+      'portal2[1]:b componentWillUnmount',
+    ]);
+  });
+
+  it('should render nested portals', () => {
+    var portalContainer1 = document.createElement('div');
+    var portalContainer2 = document.createElement('div');
+    var portalContainer3 = document.createElement('div');
+
+    ReactDOM.render(
+      [
+        <div key="a">normal[0]</div>,
+        ReactDOM.createPortal(
+          [
+            <div key="b">portal1[0]</div>,
+            ReactDOM.createPortal(
+              <div key="c">portal2[0]</div>,
+              portalContainer2,
+            ),
+            ReactDOM.createPortal(
+              <div key="d">portal3[0]</div>,
+              portalContainer3,
+            ),
+            <div key="e">portal1[1]</div>,
+          ],
+          portalContainer1,
+        ),
+        <div key="f">normal[1]</div>,
+      ],
+      container,
+    );
+    expect(portalContainer1.innerHTML).toBe(
+      '<div>portal1[0]</div><div>portal1[1]</div>',
+    );
+    expect(portalContainer2.innerHTML).toBe('<div>portal2[0]</div>');
+    expect(portalContainer3.innerHTML).toBe('<div>portal3[0]</div>');
+    expect(container.innerHTML).toBe(
+      '<div>normal[0]</div><div>normal[1]</div>',
+    );
+
+    ReactDOM.unmountComponentAtNode(container);
+    expect(portalContainer1.innerHTML).toBe('');
+    expect(portalContainer2.innerHTML).toBe('');
+    expect(portalContainer3.innerHTML).toBe('');
+    expect(container.innerHTML).toBe('');
+  });
+
+  it('should reconcile portal children', () => {
+    var portalContainer = document.createElement('div');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('<div>portal:1</div>');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(<div>portal:2</div>, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('<div>portal:2</div>');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(<p>portal:3</p>, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('<p>portal:3</p>');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(['Hi', 'Bye'], portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('HiBye');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(['Bye', 'Hi'], portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('ByeHi');
+    expect(container.innerHTML).toBe('<div></div>');
+
+    ReactDOM.render(
+      <div>
+        {ReactDOM.createPortal(null, portalContainer)}
+      </div>,
+      container,
+    );
+    expect(portalContainer.innerHTML).toBe('');
+    expect(container.innerHTML).toBe('<div></div>');
+  });
+
+  it('should keep track of namespace across portals (simple)', () => {
+    assertNamespacesMatch(
+      <svg {...expectSVG}>
+        <image {...expectSVG} />
+        {usePortal(<div {...expectHTML} />)}
+        <image {...expectSVG} />
+      </svg>,
+    );
+    assertNamespacesMatch(
+      <math {...expectMath}>
+        <mi {...expectMath} />
+        {usePortal(<div {...expectHTML} />)}
+        <mi {...expectMath} />
+      </math>,
+    );
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        <p {...expectHTML} />
+        {usePortal(
+          <svg {...expectSVG}>
+            <image {...expectSVG} />
+          </svg>,
+        )}
+        <p {...expectHTML} />
+      </div>,
+    );
+  });
+
+  it('should keep track of namespace across portals (medium)', () => {
+    assertNamespacesMatch(
+      <svg {...expectSVG}>
+        <image {...expectSVG} />
+        {usePortal(<div {...expectHTML} />)}
+        <image {...expectSVG} />
+        {usePortal(<div {...expectHTML} />)}
+        <image {...expectSVG} />
+      </svg>,
+    );
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        <math {...expectMath}>
+          <mi {...expectMath} />
+          {usePortal(
+            <svg {...expectSVG}>
+              <image {...expectSVG} />
+            </svg>,
+          )}
+        </math>
+        <p {...expectHTML} />
+      </div>,
+    );
+    assertNamespacesMatch(
+      <math {...expectMath}>
+        <mi {...expectMath} />
+        {usePortal(
+          <svg {...expectSVG}>
+            <image {...expectSVG} />
+            <foreignObject {...expectSVG}>
+              <p {...expectHTML} />
+              <math {...expectMath}>
+                <mi {...expectMath} />
+              </math>
+              <p {...expectHTML} />
+            </foreignObject>
+            <image {...expectSVG} />
+          </svg>,
+        )}
+        <mi {...expectMath} />
+      </math>,
+    );
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        {usePortal(
+          <svg {...expectSVG}>
+            {usePortal(<div {...expectHTML} />)}
+            <image {...expectSVG} />
+          </svg>,
+        )}
+        <p {...expectHTML} />
+      </div>,
+    );
+    assertNamespacesMatch(
+      <svg {...expectSVG}>
+        <svg {...expectSVG}>
+          {usePortal(<div {...expectHTML} />)}
+          <image {...expectSVG} />
+        </svg>
+        <image {...expectSVG} />
+      </svg>,
+    );
+  });
+
+  it('should keep track of namespace across portals (complex)', () => {
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        {usePortal(
+          <svg {...expectSVG}>
+            <image {...expectSVG} />
+          </svg>,
+        )}
+        <p {...expectHTML} />
+        <svg {...expectSVG}>
+          <image {...expectSVG} />
+        </svg>
+        <svg {...expectSVG}>
+          <svg {...expectSVG}>
+            <image {...expectSVG} />
+          </svg>
+          <image {...expectSVG} />
+        </svg>
+        <p {...expectHTML} />
+      </div>,
+    );
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        <svg {...expectSVG}>
+          <svg {...expectSVG}>
+            <image {...expectSVG} />
+            {usePortal(
+              <svg {...expectSVG}>
+                <image {...expectSVG} />
+                <svg {...expectSVG}>
+                  <image {...expectSVG} />
+                </svg>
+                <image {...expectSVG} />
+              </svg>,
+            )}
+            <image {...expectSVG} />
+            <foreignObject {...expectSVG}>
+              <p {...expectHTML} />
+              {usePortal(<p {...expectHTML} />)}
+              <p {...expectHTML} />
+            </foreignObject>
+          </svg>
+          <image {...expectSVG} />
+        </svg>
+        <p {...expectHTML} />
+      </div>,
+    );
+    assertNamespacesMatch(
+      <div {...expectHTML}>
+        <svg {...expectSVG}>
+          <foreignObject {...expectSVG}>
+            <p {...expectHTML} />
+            {usePortal(
+              <svg {...expectSVG}>
+                <image {...expectSVG} />
+                <svg {...expectSVG}>
+                  <image {...expectSVG} />
+                  <foreignObject {...expectSVG}>
+                    <p {...expectHTML} />
+                  </foreignObject>
+                  {usePortal(<p {...expectHTML} />)}
+                </svg>
+                <image {...expectSVG} />
+              </svg>,
+            )}
+            <p {...expectHTML} />
+          </foreignObject>
+          <image {...expectSVG} />
+        </svg>
+        <p {...expectHTML} />
+      </div>,
+    );
+  });
+
+  it('should unwind namespaces on uncaught errors', () => {
+    function BrokenRender() {
+      throw new Error('Hello');
+    }
+
+    expect(() => {
+      assertNamespacesMatch(
+        <svg {...expectSVG}>
+          <BrokenRender />
+        </svg>,
+      );
+    }).toThrow('Hello');
+    assertNamespacesMatch(<div {...expectHTML} />);
+  });
+
+  it('should unwind namespaces on caught errors', () => {
+    function BrokenRender() {
+      throw new Error('Hello');
+    }
+
+    class ErrorBoundary extends React.Component {
+      state = {error: null};
+      componentDidCatch(error) {
+        this.setState({error});
+      }
+      render() {
+        if (this.state.error) {
+          return <p {...expectHTML} />;
+        }
+        return this.props.children;
+      }
+    }
+
+    assertNamespacesMatch(
+      <svg {...expectSVG}>
+        <foreignObject {...expectSVG}>
+          <ErrorBoundary>
+            <math {...expectMath}>
+              <BrokenRender />
+            </math>
+          </ErrorBoundary>
+        </foreignObject>
+        <image {...expectSVG} />
+      </svg>,
+    );
+    assertNamespacesMatch(<div {...expectHTML} />);
+  });
+
+  it('should unwind namespaces on caught errors in a portal', () => {
+    function BrokenRender() {
+      throw new Error('Hello');
+    }
+
+    class ErrorBoundary extends React.Component {
+      state = {error: null};
+      componentDidCatch(error) {
+        this.setState({error});
+      }
+      render() {
+        if (this.state.error) {
+          return <image {...expectSVG} />;
+        }
+        return this.props.children;
+      }
+    }
+
+    assertNamespacesMatch(
+      <svg {...expectSVG}>
+        <ErrorBoundary>
+          {usePortal(
+            <div {...expectHTML}>
+              <math {...expectMath}>
+                <BrokenRender />)
+              </math>
+            </div>,
+          )}
+        </ErrorBoundary>
+        {usePortal(<div {...expectHTML} />)}
+      </svg>,
+    );
+  });
+
+  it('should pass portal context when rendering subtree elsewhere', () => {
+    var portalContainer = document.createElement('div');
+
+    class Component extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      render() {
+        return <div>{this.context.foo}</div>;
+      }
+    }
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+        };
+      }
+
+      render() {
+        return ReactDOM.createPortal(<Component />, portalContainer);
+      }
+    }
+
+    ReactDOM.render(<Parent />, container);
+    expect(container.innerHTML).toBe('');
+    expect(portalContainer.innerHTML).toBe('<div>bar</div>');
+  });
+
+  it('should update portal context if it changes due to setState', () => {
+    var portalContainer = document.createElement('div');
+
+    class Component extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+        getFoo: PropTypes.func.isRequired,
+      };
+
+      render() {
+        return <div>{this.context.foo + '-' + this.context.getFoo()}</div>;
+      }
+    }
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string.isRequired,
+        getFoo: PropTypes.func.isRequired,
+      };
+
+      state = {
+        bar: 'initial',
+      };
+
+      getChildContext() {
+        return {
+          foo: this.state.bar,
+          getFoo: () => this.state.bar,
+        };
+      }
+
+      render() {
+        return ReactDOM.createPortal(<Component />, portalContainer);
+      }
+    }
+
+    var instance = ReactDOM.render(<Parent />, container);
+    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
+    expect(container.innerHTML).toBe('');
+    instance.setState({bar: 'changed'});
+    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
+    expect(container.innerHTML).toBe('');
+  });
+
+  it('should update portal context if it changes due to re-render', () => {
+    var portalContainer = document.createElement('div');
+
+    class Component extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+        getFoo: PropTypes.func.isRequired,
+      };
+
+      render() {
+        return <div>{this.context.foo + '-' + this.context.getFoo()}</div>;
+      }
+    }
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string.isRequired,
+        getFoo: PropTypes.func.isRequired,
+      };
+
+      getChildContext() {
+        return {
+          foo: this.props.bar,
+          getFoo: () => this.props.bar,
+        };
+      }
+
+      render() {
+        return ReactDOM.createPortal(<Component />, portalContainer);
+      }
+    }
+
+    ReactDOM.render(<Parent bar="initial" />, container);
+    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
+    expect(container.innerHTML).toBe('');
+    ReactDOM.render(<Parent bar="changed" />, container);
+    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
+    expect(container.innerHTML).toBe('');
+  });
+
+  it('findDOMNode should find dom element after expanding a fragment', () => {
+    class MyNode extends React.Component {
+      render() {
+        return !this.props.flag
+          ? [<div key="a" />]
+          : [<span key="b" />, <div key="a" />];
+      }
+    }
+
+    var myNodeA = ReactDOM.render(<MyNode />, container);
+    var a = ReactDOM.findDOMNode(myNodeA);
+    expect(a.tagName).toBe('DIV');
+
+    var myNodeB = ReactDOM.render(<MyNode flag={true} />, container);
+    expect(myNodeA === myNodeB).toBe(true);
+
+    var b = ReactDOM.findDOMNode(myNodeB);
+    expect(b.tagName).toBe('SPAN');
+  });
+
+  it('should bubble events from the portal to the parent', () => {
+    var portalContainer = document.createElement('div');
+
+    var ops = [];
+    var portal = null;
+
+    ReactDOM.render(
+      <div onClick={() => ops.push('parent clicked')}>
+        {ReactDOM.createPortal(
+          <div
+            onClick={() => ops.push('portal clicked')}
+            ref={n => (portal = n)}>
+            portal
+          </div>,
+          portalContainer,
+        )}
+      </div>,
+      container,
+    );
+
+    expect(portal.tagName).toBe('DIV');
+
+    var fakeNativeEvent = {};
+    ReactTestUtils.simulateNativeEventOnNode(
+      'topClick',
+      portal,
+      fakeNativeEvent,
+    );
+
+    expect(ops).toEqual(['portal clicked', 'parent clicked']);
+  });
+
+  it('should not onMouseLeave when staying in the portal', () => {
+    var portalContainer = document.createElement('div');
+
+    var ops = [];
+    var firstTarget = null;
+    var secondTarget = null;
+    var thirdTarget = null;
+
+    function simulateMouseMove(from, to) {
+      if (from) {
+        ReactTestUtils.simulateNativeEventOnNode('topMouseOut', from, {
+          target: from,
+          relatedTarget: to,
+        });
+      }
+      if (to) {
+        ReactTestUtils.simulateNativeEventOnNode('topMouseOver', to, {
+          target: to,
+          relatedTarget: from,
+        });
+      }
+    }
+
+    ReactDOM.render(
+      <div>
+        <div
+          onMouseEnter={() => ops.push('enter parent')}
+          onMouseLeave={() => ops.push('leave parent')}>
+          <div ref={n => (firstTarget = n)} />
+          {ReactDOM.createPortal(
+            <div
+              onMouseEnter={() => ops.push('enter portal')}
+              onMouseLeave={() => ops.push('leave portal')}
+              ref={n => (secondTarget = n)}>
+              portal
+            </div>,
+            portalContainer,
+          )}
+        </div>
+        <div ref={n => (thirdTarget = n)} />
+      </div>,
+      container,
+    );
+
+    simulateMouseMove(null, firstTarget);
+    expect(ops).toEqual(['enter parent']);
+
+    ops = [];
+
+    simulateMouseMove(firstTarget, secondTarget);
+    expect(ops).toEqual([
+      // Parent did not invoke leave because we're still inside the portal.
+      'enter portal',
+    ]);
+
+    ops = [];
+
+    simulateMouseMove(secondTarget, thirdTarget);
+    expect(ops).toEqual([
+      'leave portal',
+      'leave parent', // Only when we leave the portal does onMouseLeave fire.
+    ]);
+  });
+
+  it('should throw on bad createPortal argument', () => {
+    expect(() => {
+      ReactDOM.createPortal(<div>portal</div>, null);
+    }).toThrow('Target container is not a DOM element.');
+    expect(() => {
+      ReactDOM.createPortal(<div>portal</div>, document.createTextNode('hi'));
+    }).toThrow('Target container is not a DOM element.');
+  });
+
+  it('should warn for non-functional event listeners', () => {
+    spyOn(console, 'error');
+    class Example extends React.Component {
+      render() {
+        return <div onClick="woops" />;
+      }
+    }
+    ReactDOM.render(<Example />, container);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(
+      normalizeCodeLocInfo(console.error.calls.argsFor(0)[0]),
+    ).toContain(
+      'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
+        '    in div (at **)\n' +
+        '    in Example (at **)',
+    );
+  });
+
+  it('should not update event handlers until commit', () => {
+    let ops = [];
+    const handlerA = () => ops.push('A');
+    const handlerB = () => ops.push('B');
+
+    class Example extends React.Component {
+      state = {flip: false, count: 0};
+      flip() {
+        this.setState({flip: true, count: this.state.count + 1});
+      }
+      tick() {
+        this.setState({count: this.state.count + 1});
+      }
+      render() {
+        const useB = !this.props.forceA && this.state.flip;
+        return <div onClick={useB ? handlerB : handlerA} />;
+      }
+    }
+
+    class Click extends React.Component {
+      constructor() {
+        super();
+        click(node);
+      }
+      render() {
+        return null;
+      }
+    }
+
+    let inst;
+    ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
+    const node = container.firstChild;
+    expect(node.tagName).toEqual('DIV');
+
+    function click(target) {
+      var fakeNativeEvent = {};
+      ReactTestUtils.simulateNativeEventOnNode(
+        'topClick',
+        target,
+        fakeNativeEvent,
+      );
+    }
+
+    click(node);
+
+    expect(ops).toEqual(['A']);
+    ops = [];
+
+    // Render with the other event handler.
+    inst.flip();
+
+    click(node);
+
+    expect(ops).toEqual(['B']);
+    ops = [];
+
+    // Rerender without changing any props.
+    inst.tick();
+
+    click(node);
+
+    expect(ops).toEqual(['B']);
+    ops = [];
+
+    // Render a flip back to the A handler. The second component invokes the
+    // click handler during render to simulate a click during an aborted
+    // render. I use this hack because at current time we don't have a way to
+    // test aborted ReactDOM renders.
+    ReactDOM.render(
+      [<Example key="a" forceA={true} />, <Click key="b" />],
+      container,
+    );
+
+    // Because the new click handler has not yet committed, we should still
+    // invoke B.
+    expect(ops).toEqual(['B']);
+    ops = [];
+
+    // Any click that happens after commit, should invoke A.
+    click(node);
+    expect(ops).toEqual(['A']);
+  });
+
+  it('should not crash encountering low-priority tree', () => {
+    ReactDOM.render(
+      <div hidden={true}>
+        <div />
+      </div>,
+      container,
+    );
+  });
+
+  it('should not warn when rendering into an empty container', () => {
+    spyOn(console, 'error');
+    ReactDOM.render(<div>foo</div>, container);
+    expect(container.innerHTML).toBe('<div>foo</div>');
+    ReactDOM.render(null, container);
+    expect(container.innerHTML).toBe('');
+    expectDev(console.error.calls.count()).toBe(0);
+    ReactDOM.render(<div>bar</div>, container);
+    expect(container.innerHTML).toBe('<div>bar</div>');
+    expectDev(console.error.calls.count()).toBe(0);
+  });
+
+  it('should warn when replacing a container which was manually updated outside of React', () => {
+    spyOn(console, 'error');
+    // when not messing with the DOM outside of React
+    ReactDOM.render(<div key="1">foo</div>, container);
+    ReactDOM.render(<div key="1">bar</div>, container);
+    expect(container.innerHTML).toBe('<div>bar</div>');
+    // then we mess with the DOM before an update
+    // we know this will error - that is expected right now
+    // It's an error of type 'NotFoundError' with no message
+    expect(() => {
+      container.innerHTML = '<div>MEOW.</div>';
+      ReactDOM.render(<div key="2">baz</div>, container);
+    }).toThrowError();
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'render(...): ' +
+        'It looks like the React-rendered content of this container was ' +
+        'removed without using React. This is not supported and will ' +
+        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+        'to empty a container.',
+    );
+  });
+
+  it('should warn when doing an update to a container manually updated outside of React', () => {
+    spyOn(console, 'error');
+    // when not messing with the DOM outside of React
+    ReactDOM.render(<div>foo</div>, container);
+    ReactDOM.render(<div>bar</div>, container);
+    expect(container.innerHTML).toBe('<div>bar</div>');
+    // then we mess with the DOM before an update
+    container.innerHTML = '<div>MEOW.</div>';
+    ReactDOM.render(<div>baz</div>, container);
+    // silently fails to update
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'render(...): ' +
+        'It looks like the React-rendered content of this container was ' +
+        'removed without using React. This is not supported and will ' +
+        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+        'to empty a container.',
+    );
+  });
+
+  it('should warn when doing an update to a container manually cleared outside of React', () => {
+    spyOn(console, 'error');
+    // when not messing with the DOM outside of React
+    ReactDOM.render(<div>foo</div>, container);
+    ReactDOM.render(<div>bar</div>, container);
+    expect(container.innerHTML).toBe('<div>bar</div>');
+    // then we mess with the DOM before an update
+    container.innerHTML = '';
+    ReactDOM.render(<div>baz</div>, container);
+    // silently fails to update
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'render(...): ' +
+        'It looks like the React-rendered content of this container was ' +
+        'removed without using React. This is not supported and will ' +
+        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+        'to empty a container.',
+    );
+  });
+
+  it('should render a text component with a text DOM node on the same document as the container', () => {
+    // 1. Create a new document through the use of iframe
+    // 2. Set up the spy to make asserts when a text component
+    //    is rendered inside the iframe container
+    var textContent = 'Hello world';
+    var iframe = document.createElement('iframe');
+    document.body.appendChild(iframe);
+    var iframeDocument = iframe.contentDocument;
+    iframeDocument.write(
+      '<!DOCTYPE html><html><head></head><body><div></div></body></html>',
+    );
+    iframeDocument.close();
+    var iframeContainer = iframeDocument.body.firstChild;
+
+    var actualDocument;
+    var textNode;
+
+    spyOn(iframeContainer, 'appendChild').and.callFake(node => {
+      actualDocument = node.ownerDocument;
+      textNode = node;
+    });
+
+    ReactDOM.render(textContent, iframeContainer);
+
+    expect(textNode.textContent).toBe(textContent);
+    expect(actualDocument).not.toBe(document);
+    expect(actualDocument).toBe(iframeDocument);
+    expect(iframeContainer.appendChild).toHaveBeenCalledTimes(1);
+  });
+
+  it('should mount into a document fragment', () => {
+    var fragment = document.createDocumentFragment();
+    ReactDOM.render(<div>foo</div>, fragment);
+    expect(container.innerHTML).toBe('');
+    container.appendChild(fragment);
+    expect(container.innerHTML).toBe('<div>foo</div>');
+  });
+});

commit 544d5c720812c95131f7f572e401fadd3c65d27e
Author: Nic Bonetto <nick.bonetto@gmail.com>
Date:   Tue Oct 31 06:02:41 2017 -0700

    Fixed invalid prop types error message to be more specific (#11308)
    
    * Modified tests and corrected error message. #3
    
    * Fixed syntax issues. #3
    
    * Modified test. #3
    
    * Prettified. #3
    
    * Changed warning message to handle true and false boolean values. #3
    
    * Changed test to contain undefined instead of value. #3
    
    * Simplified branch structure. #3
    
    * Refactored branching logic. #3
    
    * Refactored falsy warning message and tests. #3
    
    * Changed condition to attribute name. #3
    
    * Refactored falsy and truthy warning messages with tests updated. #3
    
    * Added missing character. #3
    
    * Fixed warning message. #3
    
    * Cleared extra whitespace. #3
    
    * Refactored warning messages to be clear. #3
    
    * Prettified. #3
    
    * Grammar fix
    
    * Tweak unrelated warning
    
    The message didn't make sense because it appears for *any* attributes, not just numeric ones.
    
    * Tweak the message for more clarity
    
    * Add a special message for false event handlers
    
    * Add missing whitespace
    
    * Revert size changes

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 36f63a3b4f..d208cb5861 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -945,6 +945,25 @@ describe('ReactDOMFiber', () => {
     );
   });
 
+  it('should warn with a special message for `false` event listeners', () => {
+    spyOn(console, 'error');
+    class Example extends React.Component {
+      render() {
+        return <div onClick={false} />;
+      }
+    }
+    ReactDOM.render(<Example />, container);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(
+      normalizeCodeLocInfo(console.error.calls.argsFor(0)[0]),
+    ).toContain(
+      'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
+        'If you used to conditionally omit it with onClick={condition && value}, ' +
+        'pass onClick={condition ? value : undefined} instead.\n',
+      '    in div (at **)\n' + '    in Example (at **)',
+    );
+  });
+
   it('should not update event handlers until commit', () => {
     let ops = [];
     const handlerA = () => ops.push('A');

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index d208cb5861..6f74f741d4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -133,7 +133,12 @@ describe('ReactDOMFiber', () => {
 
     class Fragment extends React.Component {
       render() {
-        return [<Wrapper key="a"><div /></Wrapper>, <span key="b" />];
+        return [
+          <Wrapper key="a">
+            <div />
+          </Wrapper>,
+          <span key="b" />,
+        ];
       }
     }
 
@@ -204,9 +209,7 @@ describe('ReactDOMFiber', () => {
     var portalContainer = document.createElement('div');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(<div>portal</div>, portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(<div>portal</div>, portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('<div>portal</div>');
@@ -382,54 +385,42 @@ describe('ReactDOMFiber', () => {
     var portalContainer = document.createElement('div');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('<div>portal:1</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(<div>portal:2</div>, portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(<div>portal:2</div>, portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('<div>portal:2</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(<p>portal:3</p>, portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(<p>portal:3</p>, portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('<p>portal:3</p>');
     expect(container.innerHTML).toBe('<div></div>');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(['Hi', 'Bye'], portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(['Hi', 'Bye'], portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('HiBye');
     expect(container.innerHTML).toBe('<div></div>');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(['Bye', 'Hi'], portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(['Bye', 'Hi'], portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('ByeHi');
     expect(container.innerHTML).toBe('<div></div>');
 
     ReactDOM.render(
-      <div>
-        {ReactDOM.createPortal(null, portalContainer)}
-      </div>,
+      <div>{ReactDOM.createPortal(null, portalContainer)}</div>,
       container,
     );
     expect(portalContainer.innerHTML).toBe('');

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 6f74f741d4..016a3fb3f7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -919,40 +919,40 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should warn for non-functional event listeners', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     class Example extends React.Component {
       render() {
         return <div onClick="woops" />;
       }
     }
     ReactDOM.render(<Example />, container);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(
-      normalizeCodeLocInfo(console.error.calls.argsFor(0)[0]),
-    ).toContain(
-      'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
-        '    in div (at **)\n' +
-        '    in Example (at **)',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toContain(
+        'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
+          '    in div (at **)\n' +
+          '    in Example (at **)',
+      );
+    }
   });
 
   it('should warn with a special message for `false` event listeners', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     class Example extends React.Component {
       render() {
         return <div onClick={false} />;
       }
     }
     ReactDOM.render(<Example />, container);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(
-      normalizeCodeLocInfo(console.error.calls.argsFor(0)[0]),
-    ).toContain(
-      'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
-        'If you used to conditionally omit it with onClick={condition && value}, ' +
-        'pass onClick={condition ? value : undefined} instead.\n',
-      '    in div (at **)\n' + '    in Example (at **)',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toContain(
+        'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
+          'If you used to conditionally omit it with onClick={condition && value}, ' +
+          'pass onClick={condition ? value : undefined} instead.\n',
+        '    in div (at **)\n' + '    in Example (at **)',
+      );
+    }
   });
 
   it('should not update event handlers until commit', () => {
@@ -1048,19 +1048,23 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not warn when rendering into an empty container', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     ReactDOM.render(<div>foo</div>, container);
     expect(container.innerHTML).toBe('<div>foo</div>');
     ReactDOM.render(null, container);
     expect(container.innerHTML).toBe('');
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
     ReactDOM.render(<div>bar</div>, container);
     expect(container.innerHTML).toBe('<div>bar</div>');
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
   });
 
   it('should warn when replacing a container which was manually updated outside of React', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div key="1">foo</div>, container);
     ReactDOM.render(<div key="1">bar</div>, container);
@@ -1072,18 +1076,20 @@ describe('ReactDOMFiber', () => {
       container.innerHTML = '<div>MEOW.</div>';
       ReactDOM.render(<div key="2">baz</div>, container);
     }).toThrowError();
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'render(...): ' +
-        'It looks like the React-rendered content of this container was ' +
-        'removed without using React. This is not supported and will ' +
-        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-        'to empty a container.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'render(...): ' +
+          'It looks like the React-rendered content of this container was ' +
+          'removed without using React. This is not supported and will ' +
+          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+          'to empty a container.',
+      );
+    }
   });
 
   it('should warn when doing an update to a container manually updated outside of React', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div>foo</div>, container);
     ReactDOM.render(<div>bar</div>, container);
@@ -1092,18 +1098,20 @@ describe('ReactDOMFiber', () => {
     container.innerHTML = '<div>MEOW.</div>';
     ReactDOM.render(<div>baz</div>, container);
     // silently fails to update
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'render(...): ' +
-        'It looks like the React-rendered content of this container was ' +
-        'removed without using React. This is not supported and will ' +
-        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-        'to empty a container.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'render(...): ' +
+          'It looks like the React-rendered content of this container was ' +
+          'removed without using React. This is not supported and will ' +
+          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+          'to empty a container.',
+      );
+    }
   });
 
   it('should warn when doing an update to a container manually cleared outside of React', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div>foo</div>, container);
     ReactDOM.render(<div>bar</div>, container);
@@ -1112,14 +1120,16 @@ describe('ReactDOMFiber', () => {
     container.innerHTML = '';
     ReactDOM.render(<div>baz</div>, container);
     // silently fails to update
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'render(...): ' +
-        'It looks like the React-rendered content of this container was ' +
-        'removed without using React. This is not supported and will ' +
-        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-        'to empty a container.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'render(...): ' +
+          'It looks like the React-rendered content of this container was ' +
+          'removed without using React. This is not supported and will ' +
+          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+          'to empty a container.',
+      );
+    }
   });
 
   it('should render a text component with a text DOM node on the same document as the container', () => {

commit 53ab1948b5bb1da29f121d7f32afa0bea42bffd0
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Nov 28 14:06:26 2017 -0800

    Blacklist spyOn(). Add explicit spyOnProd() and spyOnDevAndProd() (#11691)
    
    * Blacklist spyOn(). Add explicit spyOnProd() and spyOnDevAndProd()
    
    * Wording tweak.
    
    * Fixed lint no-shadow warning

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 016a3fb3f7..66a0d34057 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1149,7 +1149,7 @@ describe('ReactDOMFiber', () => {
     var actualDocument;
     var textNode;
 
-    spyOn(iframeContainer, 'appendChild').and.callFake(node => {
+    spyOnDevAndProd(iframeContainer, 'appendChild').and.callFake(node => {
       actualDocument = node.ownerDocument;
       textNode = node;
     });

commit 48616e591fe23c0b89b0823c3ec99bae2d7b6853
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Tue Dec 5 16:29:22 2017 -0200

    react-dom: convert packages/react-dom/src/__tests__ (#11776)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 66a0d34057..3db78615a1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -9,17 +9,17 @@
 
 'use strict';
 
-var React = require('react');
-var ReactDOM = require('react-dom');
-var ReactTestUtils = require('react-dom/test-utils');
-var PropTypes = require('prop-types');
+const React = require('react');
+const ReactDOM = require('react-dom');
+const ReactTestUtils = require('react-dom/test-utils');
+const PropTypes = require('prop-types');
 
 describe('ReactDOMFiber', () => {
   function normalizeCodeLocInfo(str) {
     return str && str.replace(/\(at .+?:\d+\)/g, '(at **)');
   }
 
-  var container;
+  let container;
 
   beforeEach(() => {
     container = document.createElement('div');
@@ -175,16 +175,16 @@ describe('ReactDOMFiber', () => {
     expect(firstNode.tagName).toBe('DIV');
   });
 
-  var svgEls, htmlEls, mathEls;
-  var expectSVG = {ref: el => svgEls.push(el)};
-  var expectHTML = {ref: el => htmlEls.push(el)};
-  var expectMath = {ref: el => mathEls.push(el)};
+  let svgEls, htmlEls, mathEls;
+  const expectSVG = {ref: el => svgEls.push(el)};
+  const expectHTML = {ref: el => htmlEls.push(el)};
+  const expectMath = {ref: el => mathEls.push(el)};
 
-  var usePortal = function(tree) {
+  const usePortal = function(tree) {
     return ReactDOM.createPortal(tree, document.createElement('div'));
   };
 
-  var assertNamespacesMatch = function(tree) {
+  const assertNamespacesMatch = function(tree) {
     container = document.createElement('div');
     svgEls = [];
     htmlEls = [];
@@ -206,7 +206,7 @@ describe('ReactDOMFiber', () => {
   };
 
   it('should render one portal', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     ReactDOM.render(
       <div>{ReactDOM.createPortal(<div>portal</div>, portalContainer)}</div>,
@@ -222,7 +222,7 @@ describe('ReactDOMFiber', () => {
 
   // TODO: remove in React 17
   it('should support unstable_createPortal alias', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     ReactDOM.render(
       <div>
@@ -239,10 +239,10 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should render many portals', () => {
-    var portalContainer1 = document.createElement('div');
-    var portalContainer2 = document.createElement('div');
+    const portalContainer1 = document.createElement('div');
+    const portalContainer2 = document.createElement('div');
 
-    var ops = [];
+    const ops = [];
     class Child extends React.Component {
       componentDidMount() {
         ops.push(`${this.props.name} componentDidMount`);
@@ -339,9 +339,9 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should render nested portals', () => {
-    var portalContainer1 = document.createElement('div');
-    var portalContainer2 = document.createElement('div');
-    var portalContainer3 = document.createElement('div');
+    const portalContainer1 = document.createElement('div');
+    const portalContainer2 = document.createElement('div');
+    const portalContainer3 = document.createElement('div');
 
     ReactDOM.render(
       [
@@ -382,7 +382,7 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should reconcile portal children', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     ReactDOM.render(
       <div>{ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}</div>,
@@ -676,7 +676,7 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should pass portal context when rendering subtree elsewhere', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     class Component extends React.Component {
       static contextTypes = {
@@ -710,7 +710,7 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should update portal context if it changes due to setState', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     class Component extends React.Component {
       static contextTypes = {
@@ -745,7 +745,7 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    var instance = ReactDOM.render(<Parent />, container);
+    const instance = ReactDOM.render(<Parent />, container);
     expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
     expect(container.innerHTML).toBe('');
     instance.setState({bar: 'changed'});
@@ -754,7 +754,7 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should update portal context if it changes due to re-render', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
     class Component extends React.Component {
       static contextTypes = {
@@ -802,22 +802,22 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    var myNodeA = ReactDOM.render(<MyNode />, container);
-    var a = ReactDOM.findDOMNode(myNodeA);
+    const myNodeA = ReactDOM.render(<MyNode />, container);
+    const a = ReactDOM.findDOMNode(myNodeA);
     expect(a.tagName).toBe('DIV');
 
-    var myNodeB = ReactDOM.render(<MyNode flag={true} />, container);
+    const myNodeB = ReactDOM.render(<MyNode flag={true} />, container);
     expect(myNodeA === myNodeB).toBe(true);
 
-    var b = ReactDOM.findDOMNode(myNodeB);
+    const b = ReactDOM.findDOMNode(myNodeB);
     expect(b.tagName).toBe('SPAN');
   });
 
   it('should bubble events from the portal to the parent', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
-    var ops = [];
-    var portal = null;
+    const ops = [];
+    let portal = null;
 
     ReactDOM.render(
       <div onClick={() => ops.push('parent clicked')}>
@@ -835,7 +835,7 @@ describe('ReactDOMFiber', () => {
 
     expect(portal.tagName).toBe('DIV');
 
-    var fakeNativeEvent = {};
+    const fakeNativeEvent = {};
     ReactTestUtils.simulateNativeEventOnNode(
       'topClick',
       portal,
@@ -846,12 +846,12 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not onMouseLeave when staying in the portal', () => {
-    var portalContainer = document.createElement('div');
+    const portalContainer = document.createElement('div');
 
-    var ops = [];
-    var firstTarget = null;
-    var secondTarget = null;
-    var thirdTarget = null;
+    let ops = [];
+    let firstTarget = null;
+    let secondTarget = null;
+    let thirdTarget = null;
 
     function simulateMouseMove(from, to) {
       if (from) {
@@ -990,7 +990,7 @@ describe('ReactDOMFiber', () => {
     expect(node.tagName).toEqual('DIV');
 
     function click(target) {
-      var fakeNativeEvent = {};
+      const fakeNativeEvent = {};
       ReactTestUtils.simulateNativeEventOnNode(
         'topClick',
         target,
@@ -1136,18 +1136,18 @@ describe('ReactDOMFiber', () => {
     // 1. Create a new document through the use of iframe
     // 2. Set up the spy to make asserts when a text component
     //    is rendered inside the iframe container
-    var textContent = 'Hello world';
-    var iframe = document.createElement('iframe');
+    const textContent = 'Hello world';
+    const iframe = document.createElement('iframe');
     document.body.appendChild(iframe);
-    var iframeDocument = iframe.contentDocument;
+    const iframeDocument = iframe.contentDocument;
     iframeDocument.write(
       '<!DOCTYPE html><html><head></head><body><div></div></body></html>',
     );
     iframeDocument.close();
-    var iframeContainer = iframeDocument.body.firstChild;
+    const iframeContainer = iframeDocument.body.firstChild;
 
-    var actualDocument;
-    var textNode;
+    let actualDocument;
+    let textNode;
 
     spyOnDevAndProd(iframeContainer, 'appendChild').and.callFake(node => {
       actualDocument = node.ownerDocument;
@@ -1163,7 +1163,7 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should mount into a document fragment', () => {
-    var fragment = document.createDocumentFragment();
+    const fragment = document.createDocumentFragment();
     ReactDOM.render(<div>foo</div>, fragment);
     expect(container.innerHTML).toBe('');
     container.appendChild(fragment);

commit ac630e4a2f2a6e794c3f9858f606476147e735fd
Author: Manas <prometheansacrifice@gmail.com>
Date:   Fri Dec 8 15:59:55 2017 +0000

    Adds deprecation warning for ReactDOM.unstable_createPortal (#11747)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 3db78615a1..fb6fb3abdd 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -222,6 +222,7 @@ describe('ReactDOMFiber', () => {
 
   // TODO: remove in React 17
   it('should support unstable_createPortal alias', () => {
+    spyOnDev(console, 'warn');
     const portalContainer = document.createElement('div');
 
     ReactDOM.render(
@@ -233,6 +234,16 @@ describe('ReactDOMFiber', () => {
     expect(portalContainer.innerHTML).toBe('<div>portal</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
+    if (__DEV__) {
+      expect(console.warn.calls.count()).toBe(1);
+      expect(console.warn.calls.argsFor(0)[0]).toContain(
+        'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
+          'and will be removed in React 17+. Update your code to use ' +
+          'ReactDOM.createPortal() instead. It has the exact same API, ' +
+          'but without the "unstable_" prefix.',
+      );
+    }
+
     ReactDOM.unmountComponentAtNode(container);
     expect(portalContainer.innerHTML).toBe('');
     expect(container.innerHTML).toBe('');

commit a442d9bc082878ccf66872b1eeed3465927801b6
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 10:08:24 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11952)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index fb6fb3abdd..deffd4680d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -15,10 +15,6 @@ const ReactTestUtils = require('react-dom/test-utils');
 const PropTypes = require('prop-types');
 
 describe('ReactDOMFiber', () => {
-  function normalizeCodeLocInfo(str) {
-    return str && str.replace(/\(at .+?:\d+\)/g, '(at **)');
-  }
-
   let container;
 
   beforeEach(() => {
@@ -222,28 +218,24 @@ describe('ReactDOMFiber', () => {
 
   // TODO: remove in React 17
   it('should support unstable_createPortal alias', () => {
-    spyOnDev(console, 'warn');
     const portalContainer = document.createElement('div');
 
-    ReactDOM.render(
-      <div>
-        {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
-      </div>,
-      container,
+    expect(() =>
+      ReactDOM.render(
+        <div>
+          {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
+        </div>,
+        container,
+      ),
+    ).toLowPriorityWarnDev(
+      'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
+        'and will be removed in React 17+. Update your code to use ' +
+        'ReactDOM.createPortal() instead. It has the exact same API, ' +
+        'but without the "unstable_" prefix.',
     );
     expect(portalContainer.innerHTML).toBe('<div>portal</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
-    if (__DEV__) {
-      expect(console.warn.calls.count()).toBe(1);
-      expect(console.warn.calls.argsFor(0)[0]).toContain(
-        'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
-          'and will be removed in React 17+. Update your code to use ' +
-          'ReactDOM.createPortal() instead. It has the exact same API, ' +
-          'but without the "unstable_" prefix.',
-      );
-    }
-
     ReactDOM.unmountComponentAtNode(container);
     expect(portalContainer.innerHTML).toBe('');
     expect(container.innerHTML).toBe('');
@@ -930,40 +922,30 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should warn for non-functional event listeners', () => {
-    spyOnDev(console, 'error');
     class Example extends React.Component {
       render() {
         return <div onClick="woops" />;
       }
     }
-    ReactDOM.render(<Example />, container);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toContain(
-        'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
-          '    in div (at **)\n' +
-          '    in Example (at **)',
-      );
-    }
+    expect(() => ReactDOM.render(<Example />, container)).toWarnDev(
+      'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
+        '    in div (at **)\n' +
+        '    in Example (at **)',
+    );
   });
 
   it('should warn with a special message for `false` event listeners', () => {
-    spyOnDev(console, 'error');
     class Example extends React.Component {
       render() {
         return <div onClick={false} />;
       }
     }
-    ReactDOM.render(<Example />, container);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toContain(
-        'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
-          'If you used to conditionally omit it with onClick={condition && value}, ' +
-          'pass onClick={condition ? value : undefined} instead.\n',
-        '    in div (at **)\n' + '    in Example (at **)',
-      );
-    }
+    expect(() => ReactDOM.render(<Example />, container)).toWarnDev(
+      'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
+        'If you used to conditionally omit it with onClick={condition && value}, ' +
+        'pass onClick={condition ? value : undefined} instead.\n',
+      '    in div (at **)\n' + '    in Example (at **)',
+    );
   });
 
   it('should not update event handlers until commit', () => {
@@ -1059,23 +1041,15 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not warn when rendering into an empty container', () => {
-    spyOnDev(console, 'error');
     ReactDOM.render(<div>foo</div>, container);
     expect(container.innerHTML).toBe('<div>foo</div>');
     ReactDOM.render(null, container);
     expect(container.innerHTML).toBe('');
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
     ReactDOM.render(<div>bar</div>, container);
     expect(container.innerHTML).toBe('<div>bar</div>');
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
   });
 
   it('should warn when replacing a container which was manually updated outside of React', () => {
-    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div key="1">foo</div>, container);
     ReactDOM.render(<div key="1">bar</div>, container);
@@ -1083,64 +1057,51 @@ describe('ReactDOMFiber', () => {
     // then we mess with the DOM before an update
     // we know this will error - that is expected right now
     // It's an error of type 'NotFoundError' with no message
+    container.innerHTML = '<div>MEOW.</div>';
+
     expect(() => {
-      container.innerHTML = '<div>MEOW.</div>';
-      ReactDOM.render(<div key="2">baz</div>, container);
-    }).toThrowError();
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
+      expect(() =>
+        ReactDOM.render(<div key="2">baz</div>, container),
+      ).toWarnDev(
         'render(...): ' +
           'It looks like the React-rendered content of this container was ' +
           'removed without using React. This is not supported and will ' +
           'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
           'to empty a container.',
       );
-    }
+    }).toThrowError();
   });
 
   it('should warn when doing an update to a container manually updated outside of React', () => {
-    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div>foo</div>, container);
     ReactDOM.render(<div>bar</div>, container);
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '<div>MEOW.</div>';
-    ReactDOM.render(<div>baz</div>, container);
-    // silently fails to update
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'render(...): ' +
-          'It looks like the React-rendered content of this container was ' +
-          'removed without using React. This is not supported and will ' +
-          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-          'to empty a container.',
-      );
-    }
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toWarnDev(
+      'render(...): ' +
+        'It looks like the React-rendered content of this container was ' +
+        'removed without using React. This is not supported and will ' +
+        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+        'to empty a container.',
+    );
   });
 
   it('should warn when doing an update to a container manually cleared outside of React', () => {
-    spyOnDev(console, 'error');
     // when not messing with the DOM outside of React
     ReactDOM.render(<div>foo</div>, container);
     ReactDOM.render(<div>bar</div>, container);
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '';
-    ReactDOM.render(<div>baz</div>, container);
-    // silently fails to update
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'render(...): ' +
-          'It looks like the React-rendered content of this container was ' +
-          'removed without using React. This is not supported and will ' +
-          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-          'to empty a container.',
-      );
-    }
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toWarnDev(
+      'render(...): ' +
+        'It looks like the React-rendered content of this container was ' +
+        'removed without using React. This is not supported and will ' +
+        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
+        'to empty a container.',
+    );
   });
 
   it('should render a text component with a text DOM node on the same document as the container', () => {

commit e96dc140599363029bd05565d58bcd4a432db370
Author: Philipp Spie <hello@philippspiess.com>
Date:   Tue May 15 11:38:50 2018 +0200

    Use browser event names for top-level event types in React DOM (#12629)
    
    * Add TopLevelEventTypes
    
    * Fix `ReactBrowserEventEmitter`
    
    * Fix EventPluginUtils
    
    * Fix TapEventPlugin
    
    * Fix ResponderEventPlugin
    
    * Update ReactDOMFiberComponent
    
    * Fix BeforeInputEventPlugin
    
    * Fix ChangeEventPlugin
    
    * Fix EnterLeaveEventPlugin
    
    * Add missing non top event type used in ChangeEventPlugin
    
    * Fix SelectEventPlugin
    
    * Fix SimpleEventPlugin
    
    * Fix outstanding Flow issues and move TopLevelEventTypes
    
    * Inline a list of all events in `ReactTestUtils`
    
    * Fix tests
    
    * Make it pretty
    
    * Fix completly unrelated typo
    
    * Dont use map constructor because of IE11
    
    * Update typings, revert changes to native code
    
    * Make topLevelTypes in ResponderEventPlugin injectable and create DOM and ReactNative variant
    
    * Set proper dependencies for DOMResponderEventPlugin
    
    * Prettify
    
    * Make some react dom tests no longer depend on internal API
    
    * Use factories to create top level speific generic event modules
    
    * Remove unused dependency
    
    * Revert exposed module renaming, hide store creation, and inline dependency decleration
    
    * Add Flow types to createResponderEventPlugin and its consumers
    
    * Remove unused dependency
    
    * Use opaque flow type for TopLevelType
    
    * Add missing semis
    
    * Use raw event names as top level identifer
    
    * Upgrade baylon
    
    This is required for parsing opaque flow types in our CI tests.
    
    * Clean up flow types
    
    * Revert Map changes of ReactBrowserEventEmitter
    
    * Upgrade babel-* packages
    
    Apparently local unit tests also have issues with parsing JavaScript
    modules that contain opaque types (not sure why I didn't notice
    earlier!?).
    
    * Revert Map changes of SimpleEventPlugin
    
    * Clean up ReactTestUtils
    
    * Add missing semi
    
    * Fix Flow issue
    
    * Make TopLevelType clearer
    
    * Favor for loops
    
    * Explain the new DOMTopLevelEventTypes concept
    
    * Use static injection for Responder plugin types
    
    * Remove null check and rely on flow checks
    
    * Add missing ResponderEventPlugin dependencies

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index deffd4680d..a93dda6ce1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -838,12 +838,7 @@ describe('ReactDOMFiber', () => {
 
     expect(portal.tagName).toBe('DIV');
 
-    const fakeNativeEvent = {};
-    ReactTestUtils.simulateNativeEventOnNode(
-      'topClick',
-      portal,
-      fakeNativeEvent,
-    );
+    ReactTestUtils.Simulate.click(portal);
 
     expect(ops).toEqual(['portal clicked', 'parent clicked']);
   });
@@ -858,14 +853,12 @@ describe('ReactDOMFiber', () => {
 
     function simulateMouseMove(from, to) {
       if (from) {
-        ReactTestUtils.simulateNativeEventOnNode('topMouseOut', from, {
-          target: from,
+        ReactTestUtils.SimulateNative.mouseOut(from, {
           relatedTarget: to,
         });
       }
       if (to) {
-        ReactTestUtils.simulateNativeEventOnNode('topMouseOver', to, {
-          target: to,
+        ReactTestUtils.SimulateNative.mouseOver(to, {
           relatedTarget: from,
         });
       }
@@ -983,12 +976,7 @@ describe('ReactDOMFiber', () => {
     expect(node.tagName).toEqual('DIV');
 
     function click(target) {
-      const fakeNativeEvent = {};
-      ReactTestUtils.simulateNativeEventOnNode(
-        'topClick',
-        target,
-        fakeNativeEvent,
-      );
+      ReactTestUtils.Simulate.click(target);
     }
 
     click(node);

commit d480782c4162431d06c077ebf8fdf6b8ba7896ef
Author: Philipp Spie <hello@philippspiess.com>
Date:   Mon Jun 11 15:43:30 2018 +0200

    Dont error when returning an empty Fragment (#12966)
    
    * Dont error when returning an empty Fragment
    
    When a fragment is reconciled, we directly move onto its children.
    Since an empty `<React.Fragment/>` will have children of `undefined`,
    this would always throw.
    
    To fix this, we bail out in those cases.
    
    * Test the update path as well
    
    * Reuse existing code path
    
    * An even more explicit solution that also fixes Flow

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a93dda6ce1..911f161b0e 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -171,6 +171,31 @@ describe('ReactDOMFiber', () => {
     expect(firstNode.tagName).toBe('DIV');
   });
 
+  it('renders an empty fragment', () => {
+    const Div = () => <div />;
+    const EmptyFragment = () => <React.Fragment />;
+    const NonEmptyFragment = () => (
+      <React.Fragment>
+        <Div />
+      </React.Fragment>
+    );
+
+    ReactDOM.render(<EmptyFragment />, container);
+    expect(container.firstChild).toBe(null);
+
+    ReactDOM.render(<NonEmptyFragment />, container);
+    expect(container.firstChild.tagName).toBe('DIV');
+
+    ReactDOM.render(<EmptyFragment />, container);
+    expect(container.firstChild).toBe(null);
+
+    ReactDOM.render(<Div />, container);
+    expect(container.firstChild.tagName).toBe('DIV');
+
+    ReactDOM.render(<EmptyFragment />, container);
+    expect(container.firstChild).toBe(null);
+  });
+
   let svgEls, htmlEls, mathEls;
   const expectSVG = {ref: el => svgEls.push(el)};
   const expectHTML = {ref: el => htmlEls.push(el)};

commit 036ae3c6e2f056adffc31dfb78d1b6f0c63272f0
Author: Philipp Spie <hello@philippspiess.com>
Date:   Wed Jun 13 13:41:23 2018 +0200

    Use native event dispatching instead of Simulate or SimulateNative (#13023)
    
    * Use native event dispatching instead of Simulate or SimulateNative
    
    In #12629 @gaearon suggested that it would be better to drop usage of
    `ReactTestUtils.Simulate` and `ReactTestUtils.SimulateNative`. In this
    PR Im attempting at removing it from a lot of places with only a few
    leftovers.
    
    Those leftovers can be categorized into three groups:
    
    1. Anything that tests that `SimulateNative` throws. This is a property
       that native event dispatching doesnt have so I cant convert that
       easily. Affected test suites: `EventPluginHub-test`,
       `ReactBrowserEventEmitter-test`.
    2. Anything that tests `ReactTestUtils` directly. Affected test suites:
       `ReactBrowserEventEmitter-test` (this file has one test that reads
        "should have mouse enter simulated by test utils"),
        `ReactTestUtils-test`.
    3. Anything that dispatches a `change` event. The reason here goes a bit
       deeper and is rooted in the way we shim onChange. Usually when using
       native event dispatching, you would set the nodes `.value` and then
       dispatch the event. However inside [`inputValueTracking.js`][] we
       install a setter on the nodes `.value` that will ignore the next
       `change` event (I found [this][near-perfect-oninput-shim] article
       from Sophie that explains that this is to avoid onChange when
       updating the value via JavaScript).
    
    All remaining usages of `Simulate` or `SimulateNative` can be avoided
    by mounting the containers inside the `document` and dispatching native
    events.
    
    Here some remarks:
    
    1. Im using `Element#click()` instead of `dispatchEvent`. In the jsdom
       changelog I read that `click()` now properly sets the correct values
       (you can also verify it does the same thing by looking at the
       [source][jsdom-source]).
    2. I had to update jsdom in order to get `TouchEvent` constructors
       working (and while doing so also updated jest). There was one
       unexpected surprise: `ReactScheduler-test` was relying on not having
       `window.performance` available. Ive recreated the previous
       environment by deleting this property from the global object.
    3. I was a bit confused that `ReactTestUtils.renderIntoDocument()` does
       not render into the document 
    
    [`inputValueTracking.js`]: https://github.com/facebook/react/blob/392530104c00c25074ce38e1f7e1dd363018c7ce/packages/react-dom/src/client/inputValueTracking.js#L79
    [near-perfect-oninput-shim]: https://sophiebits.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html
    [jsdom-source]: https://github.com/jsdom/jsdom/blob/45b77f5d21cef74cad278d089937d8462c29acce/lib/jsdom/living/nodes/HTMLElement-impl.js#L43-L76
    
    * Make sure contains are unlinked from the document even if the test fails
    
    * Remove unnecessary findDOMNode calls

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 911f161b0e..530232becb 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -11,7 +11,6 @@
 
 const React = require('react');
 const ReactDOM = require('react-dom');
-const ReactTestUtils = require('react-dom/test-utils');
 const PropTypes = require('prop-types');
 
 describe('ReactDOMFiber', () => {
@@ -843,33 +842,39 @@ describe('ReactDOMFiber', () => {
 
   it('should bubble events from the portal to the parent', () => {
     const portalContainer = document.createElement('div');
+    document.body.appendChild(portalContainer);
+    try {
+      const ops = [];
+      let portal = null;
 
-    const ops = [];
-    let portal = null;
-
-    ReactDOM.render(
-      <div onClick={() => ops.push('parent clicked')}>
-        {ReactDOM.createPortal(
-          <div
-            onClick={() => ops.push('portal clicked')}
-            ref={n => (portal = n)}>
-            portal
-          </div>,
-          portalContainer,
-        )}
-      </div>,
-      container,
-    );
+      ReactDOM.render(
+        <div onClick={() => ops.push('parent clicked')}>
+          {ReactDOM.createPortal(
+            <div
+              onClick={() => ops.push('portal clicked')}
+              ref={n => (portal = n)}>
+              portal
+            </div>,
+            portalContainer,
+          )}
+        </div>,
+        container,
+      );
 
-    expect(portal.tagName).toBe('DIV');
+      expect(portal.tagName).toBe('DIV');
 
-    ReactTestUtils.Simulate.click(portal);
+      portal.click();
 
-    expect(ops).toEqual(['portal clicked', 'parent clicked']);
+      expect(ops).toEqual(['portal clicked', 'parent clicked']);
+    } finally {
+      document.body.removeChild(portalContainer);
+    }
   });
 
   it('should not onMouseLeave when staying in the portal', () => {
     const portalContainer = document.createElement('div');
+    document.body.appendChild(container);
+    document.body.appendChild(portalContainer);
 
     let ops = [];
     let firstTarget = null;
@@ -878,56 +883,69 @@ describe('ReactDOMFiber', () => {
 
     function simulateMouseMove(from, to) {
       if (from) {
-        ReactTestUtils.SimulateNative.mouseOut(from, {
-          relatedTarget: to,
-        });
+        from.dispatchEvent(
+          new MouseEvent('mouseout', {
+            bubbles: true,
+            cancelable: true,
+            relatedTarget: to,
+          }),
+        );
       }
       if (to) {
-        ReactTestUtils.SimulateNative.mouseOver(to, {
-          relatedTarget: from,
-        });
+        to.dispatchEvent(
+          new MouseEvent('mouseover', {
+            bubbles: true,
+            cancelable: true,
+            relatedTarget: from,
+          }),
+        );
       }
     }
 
-    ReactDOM.render(
-      <div>
-        <div
-          onMouseEnter={() => ops.push('enter parent')}
-          onMouseLeave={() => ops.push('leave parent')}>
-          <div ref={n => (firstTarget = n)} />
-          {ReactDOM.createPortal(
-            <div
-              onMouseEnter={() => ops.push('enter portal')}
-              onMouseLeave={() => ops.push('leave portal')}
-              ref={n => (secondTarget = n)}>
-              portal
-            </div>,
-            portalContainer,
-          )}
-        </div>
-        <div ref={n => (thirdTarget = n)} />
-      </div>,
-      container,
-    );
+    try {
+      ReactDOM.render(
+        <div>
+          <div
+            onMouseEnter={() => ops.push('enter parent')}
+            onMouseLeave={() => ops.push('leave parent')}>
+            <div ref={n => (firstTarget = n)} />
+            {ReactDOM.createPortal(
+              <div
+                onMouseEnter={() => ops.push('enter portal')}
+                onMouseLeave={() => ops.push('leave portal')}
+                ref={n => (secondTarget = n)}>
+                portal
+              </div>,
+              portalContainer,
+            )}
+          </div>
+          <div ref={n => (thirdTarget = n)} />
+        </div>,
+        container,
+      );
 
-    simulateMouseMove(null, firstTarget);
-    expect(ops).toEqual(['enter parent']);
+      simulateMouseMove(null, firstTarget);
+      expect(ops).toEqual(['enter parent']);
 
-    ops = [];
+      ops = [];
 
-    simulateMouseMove(firstTarget, secondTarget);
-    expect(ops).toEqual([
-      // Parent did not invoke leave because we're still inside the portal.
-      'enter portal',
-    ]);
+      simulateMouseMove(firstTarget, secondTarget);
+      expect(ops).toEqual([
+        // Parent did not invoke leave because we're still inside the portal.
+        'enter portal',
+      ]);
 
-    ops = [];
+      ops = [];
 
-    simulateMouseMove(secondTarget, thirdTarget);
-    expect(ops).toEqual([
-      'leave portal',
-      'leave parent', // Only when we leave the portal does onMouseLeave fire.
-    ]);
+      simulateMouseMove(secondTarget, thirdTarget);
+      expect(ops).toEqual([
+        'leave portal',
+        'leave parent', // Only when we leave the portal does onMouseLeave fire.
+      ]);
+    } finally {
+      document.body.removeChild(container);
+      document.body.removeChild(portalContainer);
+    }
   });
 
   it('should throw on bad createPortal argument', () => {
@@ -967,81 +985,82 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not update event handlers until commit', () => {
-    let ops = [];
-    const handlerA = () => ops.push('A');
-    const handlerB = () => ops.push('B');
-
-    class Example extends React.Component {
-      state = {flip: false, count: 0};
-      flip() {
-        this.setState({flip: true, count: this.state.count + 1});
-      }
-      tick() {
-        this.setState({count: this.state.count + 1});
-      }
-      render() {
-        const useB = !this.props.forceA && this.state.flip;
-        return <div onClick={useB ? handlerB : handlerA} />;
+    document.body.appendChild(container);
+    try {
+      let ops = [];
+      const handlerA = () => ops.push('A');
+      const handlerB = () => ops.push('B');
+
+      class Example extends React.Component {
+        state = {flip: false, count: 0};
+        flip() {
+          this.setState({flip: true, count: this.state.count + 1});
+        }
+        tick() {
+          this.setState({count: this.state.count + 1});
+        }
+        render() {
+          const useB = !this.props.forceA && this.state.flip;
+          return <div onClick={useB ? handlerB : handlerA} />;
+        }
       }
-    }
 
-    class Click extends React.Component {
-      constructor() {
-        super();
-        click(node);
-      }
-      render() {
-        return null;
+      class Click extends React.Component {
+        constructor() {
+          super();
+          node.click();
+        }
+        render() {
+          return null;
+        }
       }
-    }
-
-    let inst;
-    ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
-    const node = container.firstChild;
-    expect(node.tagName).toEqual('DIV');
 
-    function click(target) {
-      ReactTestUtils.Simulate.click(target);
-    }
+      let inst;
+      ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
+      const node = container.firstChild;
+      expect(node.tagName).toEqual('DIV');
 
-    click(node);
+      node.click();
 
-    expect(ops).toEqual(['A']);
-    ops = [];
+      expect(ops).toEqual(['A']);
+      ops = [];
 
-    // Render with the other event handler.
-    inst.flip();
+      // Render with the other event handler.
+      inst.flip();
 
-    click(node);
+      node.click();
 
-    expect(ops).toEqual(['B']);
-    ops = [];
+      expect(ops).toEqual(['B']);
+      ops = [];
 
-    // Rerender without changing any props.
-    inst.tick();
+      // Rerender without changing any props.
+      inst.tick();
 
-    click(node);
+      node.click();
 
-    expect(ops).toEqual(['B']);
-    ops = [];
+      expect(ops).toEqual(['B']);
+      ops = [];
 
-    // Render a flip back to the A handler. The second component invokes the
-    // click handler during render to simulate a click during an aborted
-    // render. I use this hack because at current time we don't have a way to
-    // test aborted ReactDOM renders.
-    ReactDOM.render(
-      [<Example key="a" forceA={true} />, <Click key="b" />],
-      container,
-    );
+      // Render a flip back to the A handler. The second component invokes the
+      // click handler during render to simulate a click during an aborted
+      // render. I use this hack because at current time we don't have a way to
+      // test aborted ReactDOM renders.
+      ReactDOM.render(
+        [<Example key="a" forceA={true} />, <Click key="b" />],
+        container,
+      );
 
-    // Because the new click handler has not yet committed, we should still
-    // invoke B.
-    expect(ops).toEqual(['B']);
-    ops = [];
+      // Because the new click handler has not yet committed, we should still
+      // invoke B.
+      expect(ops).toEqual(['B']);
+      ops = [];
 
-    // Any click that happens after commit, should invoke A.
-    click(node);
-    expect(ops).toEqual(['A']);
+      // Any click that happens after commit, should invoke A.
+      node.click();
+      expect(ops).toEqual(['A']);
+    } finally {
+      document.body.removeChild(container);
+    }
   });
 
   it('should not crash encountering low-priority tree', () => {

commit 467d1391016dd2df8e1946aa33c6d6e1219c9dbb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 20:20:18 2018 +0100

    Enforce presence or absence of component stack in tests (#13215)
    
    * Enforce presence or absence of stack in tests
    
    * Rename expectNoStack to withoutStack
    
    * Fix lint
    
    * Add some tests for toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 530232becb..c47653fba4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -256,6 +256,7 @@ describe('ReactDOMFiber', () => {
         'and will be removed in React 17+. Update your code to use ' +
         'ReactDOM.createPortal() instead. It has the exact same API, ' +
         'but without the "unstable_" prefix.',
+      {withoutStack: true},
     );
     expect(portalContainer.innerHTML).toBe('<div>portal</div>');
     expect(container.innerHTML).toBe('<div></div>');
@@ -1100,6 +1101,7 @@ describe('ReactDOMFiber', () => {
           'removed without using React. This is not supported and will ' +
           'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
           'to empty a container.',
+        {withoutStack: true},
       );
     }).toThrowError();
   });
@@ -1117,6 +1119,7 @@ describe('ReactDOMFiber', () => {
         'removed without using React. This is not supported and will ' +
         'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
         'to empty a container.',
+      {withoutStack: true},
     );
   });
 
@@ -1133,6 +1136,7 @@ describe('ReactDOMFiber', () => {
         'removed without using React. This is not supported and will ' +
         'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
         'to empty a container.',
+      {withoutStack: true},
     );
   });
 

commit 236f6087236c42ccafe94674cd1c5736a1868b00
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Jul 18 02:38:39 2018 +0100

    Fail tests if toWarnDev() does not wrap warnings in array (#13227)
    
    * Fail tests if toWarn() does not wrap warnings in array
    
    * Fix newly failing tests
    
    * Another fix

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index c47653fba4..18e95407a8 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -980,8 +980,9 @@ describe('ReactDOMFiber', () => {
     expect(() => ReactDOM.render(<Example />, container)).toWarnDev(
       'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
         'If you used to conditionally omit it with onClick={condition && value}, ' +
-        'pass onClick={condition ? value : undefined} instead.\n',
-      '    in div (at **)\n' + '    in Example (at **)',
+        'pass onClick={condition ? value : undefined} instead.\n' +
+        '    in div (at **)\n' +
+        '    in Example (at **)',
     );
   });
 

commit d2f5c3fbc211a2ff257c43c879f3213d95f31222
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Aug 17 18:13:46 2018 +0100

    Don't diff memoized host components in completion phase (#13423)
    
    * Add a regression test for 12643#issuecomment-413727104
    
    * Don't diff memoized host components
    
    * Add regression tests for noop renderer
    
    * No early return
    
    * Strengthen the test for host siblings
    
    * Flow types

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 18e95407a8..a28be568f7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -18,6 +18,12 @@ describe('ReactDOMFiber', () => {
 
   beforeEach(() => {
     container = document.createElement('div');
+    document.body.appendChild(container);
+  });
+
+  afterEach(() => {
+    document.body.removeChild(container);
+    container = null;
   });
 
   it('should render strings as children', () => {
@@ -205,12 +211,12 @@ describe('ReactDOMFiber', () => {
   };
 
   const assertNamespacesMatch = function(tree) {
-    container = document.createElement('div');
+    let testContainer = document.createElement('div');
     svgEls = [];
     htmlEls = [];
     mathEls = [];
 
-    ReactDOM.render(tree, container);
+    ReactDOM.render(tree, testContainer);
     svgEls.forEach(el => {
       expect(el.namespaceURI).toBe('http://www.w3.org/2000/svg');
     });
@@ -221,8 +227,8 @@ describe('ReactDOMFiber', () => {
       expect(el.namespaceURI).toBe('http://www.w3.org/1998/Math/MathML');
     });
 
-    ReactDOM.unmountComponentAtNode(container);
-    expect(container.innerHTML).toBe('');
+    ReactDOM.unmountComponentAtNode(testContainer);
+    expect(testContainer.innerHTML).toBe('');
   };
 
   it('should render one portal', () => {
@@ -874,7 +880,6 @@ describe('ReactDOMFiber', () => {
 
   it('should not onMouseLeave when staying in the portal', () => {
     const portalContainer = document.createElement('div');
-    document.body.appendChild(container);
     document.body.appendChild(portalContainer);
 
     let ops = [];
@@ -944,7 +949,6 @@ describe('ReactDOMFiber', () => {
         'leave parent', // Only when we leave the portal does onMouseLeave fire.
       ]);
     } finally {
-      document.body.removeChild(container);
       document.body.removeChild(portalContainer);
     }
   });
@@ -987,82 +991,77 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not update event handlers until commit', () => {
-    document.body.appendChild(container);
-    try {
-      let ops = [];
-      const handlerA = () => ops.push('A');
-      const handlerB = () => ops.push('B');
-
-      class Example extends React.Component {
-        state = {flip: false, count: 0};
-        flip() {
-          this.setState({flip: true, count: this.state.count + 1});
-        }
-        tick() {
-          this.setState({count: this.state.count + 1});
-        }
-        render() {
-          const useB = !this.props.forceA && this.state.flip;
-          return <div onClick={useB ? handlerB : handlerA} />;
-        }
+    let ops = [];
+    const handlerA = () => ops.push('A');
+    const handlerB = () => ops.push('B');
+
+    class Example extends React.Component {
+      state = {flip: false, count: 0};
+      flip() {
+        this.setState({flip: true, count: this.state.count + 1});
       }
+      tick() {
+        this.setState({count: this.state.count + 1});
+      }
+      render() {
+        const useB = !this.props.forceA && this.state.flip;
+        return <div onClick={useB ? handlerB : handlerA} />;
+      }
+    }
 
-      class Click extends React.Component {
-        constructor() {
-          super();
-          node.click();
-        }
-        render() {
-          return null;
-        }
+    class Click extends React.Component {
+      constructor() {
+        super();
+        node.click();
       }
+      render() {
+        return null;
+      }
+    }
 
-      let inst;
-      ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
-      const node = container.firstChild;
-      expect(node.tagName).toEqual('DIV');
+    let inst;
+    ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
+    const node = container.firstChild;
+    expect(node.tagName).toEqual('DIV');
 
-      node.click();
+    node.click();
 
-      expect(ops).toEqual(['A']);
-      ops = [];
+    expect(ops).toEqual(['A']);
+    ops = [];
 
-      // Render with the other event handler.
-      inst.flip();
+    // Render with the other event handler.
+    inst.flip();
 
-      node.click();
+    node.click();
 
-      expect(ops).toEqual(['B']);
-      ops = [];
+    expect(ops).toEqual(['B']);
+    ops = [];
 
-      // Rerender without changing any props.
-      inst.tick();
+    // Rerender without changing any props.
+    inst.tick();
 
-      node.click();
+    node.click();
 
-      expect(ops).toEqual(['B']);
-      ops = [];
+    expect(ops).toEqual(['B']);
+    ops = [];
 
-      // Render a flip back to the A handler. The second component invokes the
-      // click handler during render to simulate a click during an aborted
-      // render. I use this hack because at current time we don't have a way to
-      // test aborted ReactDOM renders.
-      ReactDOM.render(
-        [<Example key="a" forceA={true} />, <Click key="b" />],
-        container,
-      );
+    // Render a flip back to the A handler. The second component invokes the
+    // click handler during render to simulate a click during an aborted
+    // render. I use this hack because at current time we don't have a way to
+    // test aborted ReactDOM renders.
+    ReactDOM.render(
+      [<Example key="a" forceA={true} />, <Click key="b" />],
+      container,
+    );
 
-      // Because the new click handler has not yet committed, we should still
-      // invoke B.
-      expect(ops).toEqual(['B']);
-      ops = [];
+    // Because the new click handler has not yet committed, we should still
+    // invoke B.
+    expect(ops).toEqual(['B']);
+    ops = [];
 
-      // Any click that happens after commit, should invoke A.
-      node.click();
-      expect(ops).toEqual(['A']);
-    } finally {
-      document.body.removeChild(container);
-    }
+    // Any click that happens after commit, should invoke A.
+    node.click();
+    expect(ops).toEqual(['A']);
   });
 
   it('should not crash encountering low-priority tree', () => {
@@ -1178,4 +1177,63 @@ describe('ReactDOMFiber', () => {
     container.appendChild(fragment);
     expect(container.innerHTML).toBe('<div>foo</div>');
   });
+
+  // Regression test for https://github.com/facebook/react/issues/12643#issuecomment-413727104
+  it('should not diff memoized host components', () => {
+    let inputRef = React.createRef();
+    let didCallOnChange = false;
+
+    class Child extends React.Component {
+      state = {};
+      componentDidMount() {
+        document.addEventListener('click', this.update, true);
+      }
+      componentWillUnmount() {
+        document.removeEventListener('click', this.update, true);
+      }
+      update = () => {
+        // We're testing that this setState()
+        // doesn't cause React to commit updates
+        // to the input outside (which would itself
+        // prevent the parent's onChange parent handler
+        // from firing).
+        this.setState({});
+        // Note that onChange was always broken when there was an
+        // earlier setState() in a manual document capture phase
+        // listener *in the same component*. But that's very rare.
+        // Here we're testing that a *child* component doesn't break
+        // the parent if this happens.
+      };
+      render() {
+        return <div />;
+      }
+    }
+
+    class Parent extends React.Component {
+      handleChange = val => {
+        didCallOnChange = true;
+      };
+      render() {
+        return (
+          <div>
+            <Child />
+            <input
+              ref={inputRef}
+              type="checkbox"
+              checked={true}
+              onChange={this.handleChange}
+            />
+          </div>
+        );
+      }
+    }
+
+    ReactDOM.render(<Parent />, container);
+    inputRef.current.dispatchEvent(
+      new MouseEvent('click', {
+        bubbles: true,
+      }),
+    );
+    expect(didCallOnChange).toBe(true);
+  });
 });

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Hctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a28be568f7..864caa0f33 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 1fecba92307041e181ce425082d4d21ec8928728
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Feb 11 18:37:53 2019 +0000

    Fix crash unmounting an empty Portal (#14820)
    
    * Adds failing test for https://github.com/facebook/react/issues/14811
    
    * Fix removeChild() crash when removing an empty Portal

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 864caa0f33..c19777e7e5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -461,6 +461,40 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div></div>');
   });
 
+  it('should unmount empty portal component wherever it appears', () => {
+    const portalContainer = document.createElement('div');
+
+    class Wrapper extends React.Component {
+      constructor(props) {
+        super(props);
+        this.state = {
+          show: true,
+        };
+      }
+      render() {
+        return (
+          <div>
+            {this.state.show && (
+              <React.Fragment>
+                {ReactDOM.createPortal(null, portalContainer)}
+                <div>child</div>
+              </React.Fragment>
+            )}
+            <div>parent</div>
+          </div>
+        );
+      }
+    }
+
+    const instance = ReactDOM.render(<Wrapper />, container);
+    expect(container.innerHTML).toBe(
+      '<div><div>child</div><div>parent</div></div>',
+    );
+    instance.setState({show: false});
+    expect(instance.state.show).toBe(false);
+    expect(container.innerHTML).toBe('<div><div>parent</div></div>');
+  });
+
   it('should keep track of namespace across portals (simple)', () => {
     assertNamespacesMatch(
       <svg {...expectSVG}>

commit ef4ac42f8893afd0240d2679db7438f1b599bbd4
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue May 21 22:03:45 2019 +0100

    [Flare] Update interactiveUpdates flushing heuristics (#15687)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index c19777e7e5..a664ed5d95 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1026,9 +1026,15 @@ describe('ReactDOMFiber', () => {
 
   it('should not update event handlers until commit', () => {
     let ops = [];
+    let eventErrors = [];
     const handlerA = () => ops.push('A');
     const handlerB = () => ops.push('B');
 
+    spyOnProd(console, 'error');
+    window.addEventListener('error', e => {
+      eventErrors.push(e.message);
+    });
+
     class Example extends React.Component {
       state = {flip: false, count: 0};
       flip() {
@@ -1090,12 +1096,16 @@ describe('ReactDOMFiber', () => {
 
     // Because the new click handler has not yet committed, we should still
     // invoke B.
-    expect(ops).toEqual(['B']);
+    expect(ops).toEqual([]);
     ops = [];
 
     // Any click that happens after commit, should invoke A.
     node.click();
     expect(ops).toEqual(['A']);
+    expect(eventErrors[0]).toEqual(
+      'unstable_flushDiscreteUpdates: Cannot flush ' +
+        'updates when React is already rendering.',
+    );
   });
 
   it('should not crash encountering low-priority tree', () => {

commit e180f656f364cd8a0e8441cb268f99a312265b21
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed May 22 01:09:34 2019 +0100

    Flare: change flushDiscreteUpdates invariant to warning (#15702)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a664ed5d95..963b8a09ff 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1026,15 +1026,9 @@ describe('ReactDOMFiber', () => {
 
   it('should not update event handlers until commit', () => {
     let ops = [];
-    let eventErrors = [];
     const handlerA = () => ops.push('A');
     const handlerB = () => ops.push('B');
 
-    spyOnProd(console, 'error');
-    window.addEventListener('error', e => {
-      eventErrors.push(e.message);
-    });
-
     class Example extends React.Component {
       state = {flip: false, count: 0};
       flip() {
@@ -1052,7 +1046,11 @@ describe('ReactDOMFiber', () => {
     class Click extends React.Component {
       constructor() {
         super();
-        node.click();
+        expect(() => {
+          node.click();
+        }).toWarnDev(
+          'Warning: unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
+        );
       }
       render() {
         return null;
@@ -1096,16 +1094,12 @@ describe('ReactDOMFiber', () => {
 
     // Because the new click handler has not yet committed, we should still
     // invoke B.
-    expect(ops).toEqual([]);
+    expect(ops).toEqual(['B']);
     ops = [];
 
     // Any click that happens after commit, should invoke A.
     node.click();
     expect(ops).toEqual(['A']);
-    expect(eventErrors[0]).toEqual(
-      'unstable_flushDiscreteUpdates: Cannot flush ' +
-        'updates when React is already rendering.',
-    );
   });
 
   it('should not crash encountering low-priority tree', () => {

commit 0bd0c5269f2fe90ff7897ed5ce9146db99126eaf
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 9 12:59:02 2019 -0700

    Upgrade ESLint so we can use JSX Fragment syntax (#16328)
    
    Now that we're using Babel 7, this is the last blocker.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 963b8a09ff..a3d44d419b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -178,11 +178,11 @@ describe('ReactDOMFiber', () => {
 
   it('renders an empty fragment', () => {
     const Div = () => <div />;
-    const EmptyFragment = () => <React.Fragment />;
+    const EmptyFragment = () => <></>;
     const NonEmptyFragment = () => (
-      <React.Fragment>
+      <>
         <Div />
-      </React.Fragment>
+      </>
     );
 
     ReactDOM.render(<EmptyFragment />, container);
@@ -475,10 +475,10 @@ describe('ReactDOMFiber', () => {
         return (
           <div>
             {this.state.show && (
-              <React.Fragment>
+              <>
                 {ReactDOM.createPortal(null, portalContainer)}
                 <div>child</div>
-              </React.Fragment>
+              </>
             )}
             <div>parent</div>
           </div>

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a3d44d419b..59d9b5a1fc 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -257,7 +257,7 @@ describe('ReactDOMFiber', () => {
         </div>,
         container,
       ),
-    ).toLowPriorityWarnDev(
+    ).toWarnDev(
       'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
         'and will be removed in React 17+. Update your code to use ' +
         'ReactDOM.createPortal() instead. It has the exact same API, ' +
@@ -1002,7 +1002,7 @@ describe('ReactDOMFiber', () => {
         return <div onClick="woops" />;
       }
     }
-    expect(() => ReactDOM.render(<Example />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
       'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
         '    in div (at **)\n' +
         '    in Example (at **)',
@@ -1015,7 +1015,7 @@ describe('ReactDOMFiber', () => {
         return <div onClick={false} />;
       }
     }
-    expect(() => ReactDOM.render(<Example />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
       'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
         'If you used to conditionally omit it with onClick={condition && value}, ' +
         'pass onClick={condition ? value : undefined} instead.\n' +
@@ -1048,7 +1048,7 @@ describe('ReactDOMFiber', () => {
         super();
         expect(() => {
           node.click();
-        }).toWarnDev(
+        }).toErrorDev(
           'Warning: unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
         );
       }
@@ -1133,7 +1133,7 @@ describe('ReactDOMFiber', () => {
     expect(() => {
       expect(() =>
         ReactDOM.render(<div key="2">baz</div>, container),
-      ).toWarnDev(
+      ).toErrorDev(
         'render(...): ' +
           'It looks like the React-rendered content of this container was ' +
           'removed without using React. This is not supported and will ' +
@@ -1151,7 +1151,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '<div>MEOW.</div>';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toWarnDev(
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +
@@ -1168,7 +1168,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toWarnDev(
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +

commit b979db4e7215957f03c4221622f0b115a868439a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 13:54:11 2020 +0000

    Bump Prettier (#17811)
    
    * Bump Prettier
    
    * Reformat
    
    * Use non-deprecated option

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 59d9b5a1fc..a9856cc3f0 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1151,7 +1151,9 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '<div>MEOW.</div>';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
+    expect(() =>
+      ReactDOM.render(<div>baz</div>, container),
+    ).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +
@@ -1168,7 +1170,9 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
+    expect(() =>
+      ReactDOM.render(<div>baz</div>, container),
+    ).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +

commit c322f5913f5ec4f0f8d7926ba7401e94c0aaa772
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Jan 21 21:17:42 2020 +0000

    Add unstable_renderSubtreeIntoContainer and unstable_createPortal feature flags (#17880)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a9856cc3f0..efc605a9ed 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -13,6 +13,8 @@ const React = require('react');
 const ReactDOM = require('react-dom');
 const PropTypes = require('prop-types');
 
+const ReactFeatureFlags = require('shared/ReactFeatureFlags');
+
 describe('ReactDOMFiber', () => {
   let container;
 
@@ -247,30 +249,32 @@ describe('ReactDOMFiber', () => {
   });
 
   // TODO: remove in React 17
-  it('should support unstable_createPortal alias', () => {
-    const portalContainer = document.createElement('div');
+  if (!ReactFeatureFlags.disableUnstableCreatePortal) {
+    it('should support unstable_createPortal alias', () => {
+      const portalContainer = document.createElement('div');
 
-    expect(() =>
-      ReactDOM.render(
-        <div>
-          {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
-        </div>,
-        container,
-      ),
-    ).toWarnDev(
-      'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
-        'and will be removed in React 17+. Update your code to use ' +
-        'ReactDOM.createPortal() instead. It has the exact same API, ' +
-        'but without the "unstable_" prefix.',
-      {withoutStack: true},
-    );
-    expect(portalContainer.innerHTML).toBe('<div>portal</div>');
-    expect(container.innerHTML).toBe('<div></div>');
+      expect(() =>
+        ReactDOM.render(
+          <div>
+            {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
+          </div>,
+          container,
+        ),
+      ).toWarnDev(
+        'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
+          'and will be removed in React 17+. Update your code to use ' +
+          'ReactDOM.createPortal() instead. It has the exact same API, ' +
+          'but without the "unstable_" prefix.',
+        {withoutStack: true},
+      );
+      expect(portalContainer.innerHTML).toBe('<div>portal</div>');
+      expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.unmountComponentAtNode(container);
-    expect(portalContainer.innerHTML).toBe('');
-    expect(container.innerHTML).toBe('');
-  });
+      ReactDOM.unmountComponentAtNode(container);
+      expect(portalContainer.innerHTML).toBe('');
+      expect(container.innerHTML).toBe('');
+    });
+  }
 
   it('should render many portals', () => {
     const portalContainer1 = document.createElement('div');

commit 60016c448bb7d19fc989acd05dda5aca2e124381
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Feb 25 13:54:27 2020 -0800

    Export React as Named Exports instead of CommonJS (#18106)
    
    * Add options for forked entry points
    
    We currently fork .fb.js entry points. This adds a few more options.
    
    .modern.fb.js - experimental FB builds
    .classic.fb.js - stable FB builds
    .fb.js - if no other FB build, use this for FB builds
    .experimental.js - experimental builds
    .stable.js - stable builds
    .js - used if no other override exists
    
    This will be used to have different ES exports for different builds.
    
    * Switch React to named exports
    
    * Export named exports from the export point itself
    
    We need to re-export the Flow exported types so we can use them in our code.
    
    We don't want to use the Flow types from upstream since it doesn't have the non-public APIs that we have.
    
    This should be able to use export * but I don't know why it doesn't work.
    
    This actually enables Flow typing of React which was just "any" before.
    This exposed some Flow errors that needs fixing.
    
    * Create forks for the react entrypoint
    
    None of our builds expose all exports and they all differ in at least one
    way, so we need four forks.
    
    * Set esModule flag to false
    
    We don't want to emit the esModule compatibility flag on our CommonJS
    output. For now we treat our named exports as if they're CommonJS.
    
    This is a potentially breaking change for scheduler (but all those apis
    are unstable), react-is and use-subscription. However, it seems unlikely
    that anyone would rely on this since these only have named exports.
    
    * Remove unused Feature Flags
    
    * Let jest observe the stable fork for stable tests
    
    This lets it do the negative test by ensuring that the right tests fail.
    
    However, this in turn will make other tests that are not behind
    __EXPERIMENTAL__ fail. So I need to do that next.
    
    * Put all tests that depend on exports behind __EXPERIMENTAL__
    
    Since there's no way to override the exports using feature flags
    in .intern.js anymore we can't use these APIs in stable.
    
    The tradeoff here is that we can either enable the negative tests on
    "stable" that means experimental are expected to fail, or we can disable
    tests on stable. This is unfortunate since some of these APIs now run on
    a "stable" config at FB instead of the experimental.
    
    * Switch ReactDOM to named exports
    
    Same strategy as React.
    
    I moved the ReactDOMFB runtime injection to classic.fb.js
    
    Since we only fork the entrypoint, the `/testing` entrypoint needs to
    be forked too to re-export the same things plus `act`. This is a bit
    unfortunate. If it becomes a pattern we can consider forking in the
    module resolution deeply.
    
    fix flow
    
    * Fix ReactDOM Flow Types
    
    Now that ReactDOM is Flow type checked we need to fix up its types.
    
    * Configure jest to use stable entry for ReactDOM in non-experimental
    
    * Remove additional FeatureFlags that are no longer needed
    
    These are only flagging the exports and no implementation details so we
    can control them fully through the export overrides.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index efc605a9ed..ef872dfeb4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -13,8 +13,6 @@ const React = require('react');
 const ReactDOM = require('react-dom');
 const PropTypes = require('prop-types');
 
-const ReactFeatureFlags = require('shared/ReactFeatureFlags');
-
 describe('ReactDOMFiber', () => {
   let container;
 
@@ -249,7 +247,7 @@ describe('ReactDOMFiber', () => {
   });
 
   // TODO: remove in React 17
-  if (!ReactFeatureFlags.disableUnstableCreatePortal) {
+  if (!__EXPERIMENTAL__) {
     it('should support unstable_createPortal alias', () => {
       const portalContainer = document.createElement('div');
 

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index ef872dfeb4..51c66e773f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -211,7 +211,7 @@ describe('ReactDOMFiber', () => {
   };
 
   const assertNamespacesMatch = function(tree) {
-    let testContainer = document.createElement('div');
+    const testContainer = document.createElement('div');
     svgEls = [];
     htmlEls = [];
     mathEls = [];
@@ -1224,7 +1224,7 @@ describe('ReactDOMFiber', () => {
 
   // Regression test for https://github.com/facebook/react/issues/12643#issuecomment-413727104
   it('should not diff memoized host components', () => {
-    let inputRef = React.createRef();
+    const inputRef = React.createRef();
     let didCallOnChange = false;
 
     class Child extends React.Component {

commit ac533fde3dff81023809a92d3f5432df7fc2c418
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu Apr 30 15:56:21 2020 -0700

    Prevent stale legacy root from clearing a container (DRAFT) (#18792)
    
    * Don't clear a container because of a stale legacy root
    
    * Added test repro for FB error

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 51c66e773f..9391b34c44 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1280,4 +1280,36 @@ describe('ReactDOMFiber', () => {
     );
     expect(didCallOnChange).toBe(true);
   });
+
+  it('unmounted legacy roots should never clear newer root content from a container', () => {
+    const ref = React.createRef();
+
+    function OldApp() {
+      const hideOnFocus = () => {
+        // This app unmounts itself inside of a focus event.
+        ReactDOM.unmountComponentAtNode(container);
+      };
+
+      return (
+        <button onFocus={hideOnFocus} ref={ref}>
+          old
+        </button>
+      );
+    }
+
+    function NewApp() {
+      return <button ref={ref}>new</button>;
+    }
+
+    ReactDOM.render(<OldApp />, container);
+    ref.current.focus();
+
+    ReactDOM.render(<NewApp />, container);
+
+    // Calling focus again will flush previously scheduled discerete work for the old root-
+    // but this should not clear out the newly mounted app.
+    ref.current.focus();
+
+    expect(container.textContent).toBe('new');
+  });
 });

commit 4985bb0a80f5cbeaa61d21a7daf7da5ecff2d892
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Thu May 28 10:25:39 2020 -0700

    Rename 17 to 18 in warnings (#19031)
    
    We're not really supposed to refer to future versions by numbers.
    
    These will all slip so these numbers don't make sense anymore.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 9391b34c44..ddec9c9ba2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -246,7 +246,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('');
   });
 
-  // TODO: remove in React 17
+  // TODO: remove in React 18
   if (!__EXPERIMENTAL__) {
     it('should support unstable_createPortal alias', () => {
       const portalContainer = document.createElement('div');
@@ -260,7 +260,7 @@ describe('ReactDOMFiber', () => {
         ),
       ).toWarnDev(
         'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
-          'and will be removed in React 17+. Update your code to use ' +
+          'and will be removed in React 18+. Update your code to use ' +
           'ReactDOM.createPortal() instead. It has the exact same API, ' +
           'but without the "unstable_" prefix.',
         {withoutStack: true},

commit 30b47103d4354d9187dc0f1fb804855a5208ca9f
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 15 19:59:44 2020 -0400

    Fix spelling errors and typos (#19138)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index ddec9c9ba2..7a44cc8136 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1306,7 +1306,7 @@ describe('ReactDOMFiber', () => {
 
     ReactDOM.render(<NewApp />, container);
 
-    // Calling focus again will flush previously scheduled discerete work for the old root-
+    // Calling focus again will flush previously scheduled discrete work for the old root-
     // but this should not clear out the newly mounted app.
     ref.current.focus();
 

commit f77c7b9d76205d93908a06fb2d58ee8c31188d16
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Aug 6 13:21:05 2020 +0100

    Re-add discrete flushing timeStamp heuristic (behind flag) (#19540)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 7a44cc8136..abf076597c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1031,6 +1031,17 @@ describe('ReactDOMFiber', () => {
     const handlerA = () => ops.push('A');
     const handlerB = () => ops.push('B');
 
+    function click() {
+      const event = new MouseEvent('click', {
+        bubbles: true,
+        cancelable: true,
+      });
+      Object.defineProperty(event, 'timeStamp', {
+        value: 0,
+      });
+      node.dispatchEvent(event);
+    }
+
     class Example extends React.Component {
       state = {flip: false, count: 0};
       flip() {
@@ -1064,7 +1075,7 @@ describe('ReactDOMFiber', () => {
     const node = container.firstChild;
     expect(node.tagName).toEqual('DIV');
 
-    node.click();
+    click();
 
     expect(ops).toEqual(['A']);
     ops = [];
@@ -1072,7 +1083,7 @@ describe('ReactDOMFiber', () => {
     // Render with the other event handler.
     inst.flip();
 
-    node.click();
+    click();
 
     expect(ops).toEqual(['B']);
     ops = [];
@@ -1080,7 +1091,7 @@ describe('ReactDOMFiber', () => {
     // Rerender without changing any props.
     inst.tick();
 
-    node.click();
+    click();
 
     expect(ops).toEqual(['B']);
     ops = [];
@@ -1100,7 +1111,7 @@ describe('ReactDOMFiber', () => {
     ops = [];
 
     // Any click that happens after commit, should invoke A.
-    node.click();
+    click();
     expect(ops).toEqual(['A']);
   });
 

commit 94c0244bab7515c9b2c00b8e5312a9b6f31ef13a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Aug 10 15:08:22 2020 +0100

    Fix double-firing mouseenter (#19571)
    
    * test: Simulate mouseover in browser
    
    * Fix duplicate onMouseEnter event when relatedTarget is a root
    
    * Test leave as well
    
    Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index abf076597c..b05b4c1f96 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -989,6 +989,57 @@ describe('ReactDOMFiber', () => {
     }
   });
 
+  // Regression test for https://github.com/facebook/react/issues/19562
+  it('does not fire mouseEnter twice when relatedTarget is the root node', () => {
+    let ops = [];
+    let target = null;
+
+    function simulateMouseMove(from, to) {
+      if (from) {
+        from.dispatchEvent(
+          new MouseEvent('mouseout', {
+            bubbles: true,
+            cancelable: true,
+            relatedTarget: to,
+          }),
+        );
+      }
+      if (to) {
+        to.dispatchEvent(
+          new MouseEvent('mouseover', {
+            bubbles: true,
+            cancelable: true,
+            relatedTarget: from,
+          }),
+        );
+      }
+    }
+
+    ReactDOM.render(
+      <div
+        ref={n => (target = n)}
+        onMouseEnter={() => ops.push('enter')}
+        onMouseLeave={() => ops.push('leave')}
+      />,
+      container,
+    );
+
+    simulateMouseMove(null, container);
+    expect(ops).toEqual([]);
+
+    ops = [];
+    simulateMouseMove(container, target);
+    expect(ops).toEqual(['enter']);
+
+    ops = [];
+    simulateMouseMove(target, container);
+    expect(ops).toEqual(['leave']);
+
+    ops = [];
+    simulateMouseMove(container, null);
+    expect(ops).toEqual([]);
+  });
+
   it('should throw on bad createPortal argument', () => {
     expect(() => {
       ReactDOM.createPortal(<div>portal</div>, null);

commit 848bb2426e44606e0a55dfe44c7b3ece33772485
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Aug 24 16:50:20 2020 +0100

    Attach Listeners Eagerly to Roots and Portal Containers (#19659)
    
    * Failing test for #19608
    
    * Attach Listeners Eagerly to Roots and Portal Containers
    
    * Forbid createEventHandle with custom events
    
    We can't support this without adding more complexity. It's not clear that this is even desirable, as none of our existing use cases need custom events. This API primarily exists as a deprecation strategy for Flare, so I don't think it is important to expand its support beyond what Flare replacement code currently needs. We can later revisit it with a better understanding of the eager/lazy tradeoff but for now let's remove the inconsistency.
    
    * Reduce risk by changing condition only under the flag
    
    Co-authored-by: koba04 <koba0004@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index b05b4c1f96..a91c2fac41 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1040,6 +1040,25 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual([]);
   });
 
+  // @gate enableEagerRootListeners
+  it('listens to events that do not exist in the Portal subtree', () => {
+    const onClick = jest.fn();
+
+    const ref = React.createRef();
+    ReactDOM.render(
+      <div onClick={onClick}>
+        {ReactDOM.createPortal(<button ref={ref}>click</button>, document.body)}
+      </div>,
+      container,
+    );
+    const event = new MouseEvent('click', {
+      bubbles: true,
+    });
+    ref.current.dispatchEvent(event);
+
+    expect(onClick).toHaveBeenCalledTimes(1);
+  });
+
   it('should throw on bad createPortal argument', () => {
     expect(() => {
       ReactDOM.createPortal(<div>portal</div>, null);

commit b754caaaf23a070de281dcd0a9d32846470e1907
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Aug 28 12:23:28 2020 +0100

    Enable eager listeners in open source (#19716)
    
    * Enable eager listeners in open source
    
    * Fix tests
    
    * Enable in all places

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a91c2fac41..130c06b443 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1097,6 +1097,8 @@ describe('ReactDOMFiber', () => {
   });
 
   it('should not update event handlers until commit', () => {
+    spyOnDev(console, 'error');
+
     let ops = [];
     const handlerA = () => ops.push('A');
     const handlerB = () => ops.push('B');
@@ -1129,11 +1131,7 @@ describe('ReactDOMFiber', () => {
     class Click extends React.Component {
       constructor() {
         super();
-        expect(() => {
-          node.click();
-        }).toErrorDev(
-          'Warning: unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
-        );
+        node.click();
       }
       render() {
         return null;
@@ -1183,6 +1181,16 @@ describe('ReactDOMFiber', () => {
     // Any click that happens after commit, should invoke A.
     click();
     expect(ops).toEqual(['A']);
+
+    if (__DEV__) {
+      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
+      const errorCalls = console.error.calls.count();
+      for (let i = 0; i < errorCalls; i++) {
+        expect(console.error.calls.argsFor(i)[0]).toMatch(
+          'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
+        );
+      }
+    }
   });
 
   it('should not crash encountering low-priority tree', () => {

commit 993ca533b42756811731f6b7791ae06a35ee6b4d
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 8 19:32:28 2020 +0100

    Enable eager listeners statically (#19983)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 130c06b443..ec3ec75ce4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1040,7 +1040,6 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual([]);
   });
 
-  // @gate enableEagerRootListeners
   it('listens to events that do not exist in the Portal subtree', () => {
     const onClick = jest.fn();
 

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index ec3ec75ce4..fefcb2b080 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -246,34 +246,6 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('');
   });
 
-  // TODO: remove in React 18
-  if (!__EXPERIMENTAL__) {
-    it('should support unstable_createPortal alias', () => {
-      const portalContainer = document.createElement('div');
-
-      expect(() =>
-        ReactDOM.render(
-          <div>
-            {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
-          </div>,
-          container,
-        ),
-      ).toWarnDev(
-        'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
-          'and will be removed in React 18+. Update your code to use ' +
-          'ReactDOM.createPortal() instead. It has the exact same API, ' +
-          'but without the "unstable_" prefix.',
-        {withoutStack: true},
-      );
-      expect(portalContainer.innerHTML).toBe('<div>portal</div>');
-      expect(container.innerHTML).toBe('<div></div>');
-
-      ReactDOM.unmountComponentAtNode(container);
-      expect(portalContainer.innerHTML).toBe('');
-      expect(container.innerHTML).toBe('');
-    });
-  }
-
   it('should render many portals', () => {
     const portalContainer1 = document.createElement('div');
     const portalContainer2 = document.createElement('div');

commit aecb3b6d114e8fafddf6982133737198e8ea7cb3
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Jun 9 16:46:55 2021 -0400

    Deprecate ReactDOM.render and ReactDOM.hydrate (#21652)
    
    * Use existing test warning filter for server tests
    
    We have a warning filter for our internal tests to ignore warnings
    that are too noisy or that we haven't removed from our test suite yet:
    shouldIgnoreConsoleError.
    
    Many of our server rendering tests don't use this filter, though,
    because it has its own special of asserting warnings.
    
    So I added the warning filter to the server tests, too.
    
    * Deprecate ReactDOM.render and ReactDOM.hydrate
    
    These are no longer supported in React 18. They are replaced by the
    `createRoot` API.
    
    The warning includes a link to documentation of the new API. Currently
    it redirects to the corresponding working group post. Here's the PR to
    set up the redirect: https://github.com/reactjs/reactjs.org/pull/3730
    
    Many of our tests still use ReactDOM.render. We will need to gradually
    migrate them over to createRoot.
    
    In the meantime, I added the warnings to our internal warning filter.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index fefcb2b080..36c8367af5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1154,9 +1154,15 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual(['A']);
 
     if (__DEV__) {
-      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
       const errorCalls = console.error.calls.count();
-      for (let i = 0; i < errorCalls; i++) {
+      expect(console.error.calls.argsFor(0)[0]).toMatch(
+        'ReactDOM.render is no longer supported in React 18',
+      );
+      expect(console.error.calls.argsFor(1)[0]).toMatch(
+        'ReactDOM.render is no longer supported in React 18',
+      );
+      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
+      for (let i = 2; i < errorCalls; i++) {
         expect(console.error.calls.argsFor(i)[0]).toMatch(
           'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
         );

commit 32eefcb3c5131f4d77a2195ff11a00a2513cf62f
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jul 1 18:13:00 2021 -0400

    Replace flushDiscreteUpdates with flushSync (#21775)
    
    * Replace flushDiscreteUpdates with flushSync
    
    flushDiscreteUpdates is almost the same as flushSync. It forces passive
    effects to fire, because of an outdated heuristic, which isn't ideal but
    not that important.
    
    Besides that, the only remaining difference between flushDiscreteUpdates
    and flushSync is that flushDiscreteUpdates does not warn if you call it
    from inside an effect/lifecycle. This is because it might get triggered
    by a nested event dispatch, like `el.focus()`.
    
    So I added a new method, flushSyncWithWarningIfAlreadyRendering, which
    is used for the public flushSync API. It includes the warning. And I
    removed the warning from flushSync, so the event system can call that
    one. In production, flushSyncWithWarningIfAlreadyRendering gets inlined
    to flushSync, so the behavior is identical.
    
    Another way of thinking about this PR is that I renamed flushSync to
    flushSyncWithWarningIfAlreadyRendering and flushDiscreteUpdates to
    flushSync (and fixed the passive effects thing). The point is to prevent
    these from subtly diverging in the future.
    
    * Invert so the one with the warning is the default one
    
    To make Seb happy

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 36c8367af5..ff1ea1771f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1154,19 +1154,13 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual(['A']);
 
     if (__DEV__) {
-      const errorCalls = console.error.calls.count();
+      expect(console.error.calls.count()).toBe(2);
       expect(console.error.calls.argsFor(0)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
       expect(console.error.calls.argsFor(1)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
-      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
-      for (let i = 2; i < errorCalls; i++) {
-        expect(console.error.calls.argsFor(i)[0]).toMatch(
-          'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
-        );
-      }
     }
   });
 

commit 9ccc25a0ea322b39ea04f8dfc03620ea90e0da94
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed Jul 7 15:07:55 2021 -0400

    Reverting recent flushSync changes (#21816)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index ff1ea1771f..36c8367af5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1154,13 +1154,19 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual(['A']);
 
     if (__DEV__) {
-      expect(console.error.calls.count()).toBe(2);
+      const errorCalls = console.error.calls.count();
       expect(console.error.calls.argsFor(0)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
       expect(console.error.calls.argsFor(1)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
+      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
+      for (let i = 2; i < errorCalls; i++) {
+        expect(console.error.calls.argsFor(i)[0]).toMatch(
+          'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
+        );
+      }
     }
   });
 

commit 54e88ed12c931fa717738849ba5656cc1cf3527a
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Jul 10 14:15:11 2021 -0400

    Bugfix: Flush legacy sync passive effects at beginning of event (#21846)
    
    * Re-land recent flushSync changes
    
    Adds back #21776 and #21775, which were removed due to an internal
    e2e test failure.
    
    Will attempt to fix in subsequent commits.
    
    * Failing test: Legacy mode sync passive effects
    
    In concurrent roots, if a render is synchronous, we flush its passive
    effects synchronously. In legacy roots, we don't do this because all
    updates are synchronous  so we need to flush at the beginning of the
    next event. This is how `discreteUpdates` worked.
    
    * Flush legacy passive effects at beginning of event
    
    Fixes test added in previous commit.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 36c8367af5..ff1ea1771f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1154,19 +1154,13 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual(['A']);
 
     if (__DEV__) {
-      const errorCalls = console.error.calls.count();
+      expect(console.error.calls.count()).toBe(2);
       expect(console.error.calls.argsFor(0)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
       expect(console.error.calls.argsFor(1)[0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
-      // TODO: this warning shouldn't be firing in the first place if user didn't call it.
-      for (let i = 2; i < errorCalls; i++) {
-        expect(console.error.calls.argsFor(i)[0]).toMatch(
-          'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
-        );
-      }
     }
   });
 

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index ff1ea1771f..c8dc164ba8 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index c8dc164ba8..b342cc9461 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -206,11 +206,11 @@ describe('ReactDOMFiber', () => {
   const expectHTML = {ref: el => htmlEls.push(el)};
   const expectMath = {ref: el => mathEls.push(el)};
 
-  const usePortal = function(tree) {
+  const usePortal = function (tree) {
     return ReactDOM.createPortal(tree, document.createElement('div'));
   };
 
-  const assertNamespacesMatch = function(tree) {
+  const assertNamespacesMatch = function (tree) {
     const testContainer = document.createElement('div');
     svgEls = [];
     htmlEls = [];
@@ -1213,9 +1213,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '<div>MEOW.</div>';
-    expect(() =>
-      ReactDOM.render(<div>baz</div>, container),
-    ).toErrorDev(
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +
@@ -1232,9 +1230,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('<div>bar</div>');
     // then we mess with the DOM before an update
     container.innerHTML = '';
-    expect(() =>
-      ReactDOM.render(<div>baz</div>, container),
-    ).toErrorDev(
+    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
       'render(...): ' +
         'It looks like the React-rendered content of this container was ' +
         'removed without using React. This is not supported and will ' +

commit 71cace4d3267e4527964db51ccaf5eab7234f37f
Author: Ming Ye <ymqyit@gmail.com>
Date:   Sat Feb 11 02:39:14 2023 +0800

    Migrate testRunner from jasmine2 to jest-circus (#26144)
    
    ## Summary
    
    In jest v27, jest-circus as default test runner
    (https://github.com/facebook/jest/pull/10686)
    
    ## How did you test this change?
    
    ci green

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index b342cc9461..865337e8b5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -24,6 +24,7 @@ describe('ReactDOMFiber', () => {
   afterEach(() => {
     document.body.removeChild(container);
     container = null;
+    jest.restoreAllMocks();
   });
 
   it('should render strings as children', () => {
@@ -1154,11 +1155,11 @@ describe('ReactDOMFiber', () => {
     expect(ops).toEqual(['A']);
 
     if (__DEV__) {
-      expect(console.error.calls.count()).toBe(2);
-      expect(console.error.calls.argsFor(0)[0]).toMatch(
+      expect(console.error).toHaveBeenCalledTimes(2);
+      expect(console.error.mock.calls[0][0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
-      expect(console.error.calls.argsFor(1)[0]).toMatch(
+      expect(console.error.mock.calls[1][0]).toMatch(
         'ReactDOM.render is no longer supported in React 18',
       );
     }
@@ -1257,7 +1258,7 @@ describe('ReactDOMFiber', () => {
     let actualDocument;
     let textNode;
 
-    spyOnDevAndProd(iframeContainer, 'appendChild').and.callFake(node => {
+    spyOnDevAndProd(iframeContainer, 'appendChild').mockImplementation(node => {
       actualDocument = node.ownerDocument;
       textNode = node;
     });

commit 63346148603675f5d03509969007b7937cfddff2
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 11 15:32:02 2023 -0500

    Add disableLegacyContext test gates where needed (#26371)
    
    The www builds include disableLegacyContext as a dynamic flag, so we
    should be running the tests in that mode, too. Previously we were
    overriding the flag during the test run. This strategy usually doesn't
    work because the flags get compiled out in the final build, but we
    happen to not test www in build mode, only source.
    
    To get of this hacky override, I added a test gate to every test that
    uses legacy context. When we eventually remove legacy context from the
    codebase, this should make it slightly easier to find which tests are
    affected. And removes one more hack from our hack-ridden test config.
    
    Given that sometimes www has features enabled that aren't on in other
    builds, we might want to consider testing its build artifacts in CI,
    rather than just source. That would have forced this cleanup to happen
    sooner. Currently we only test the public builds in CI.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 865337e8b5..06773b68f1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -718,6 +718,7 @@ describe('ReactDOMFiber', () => {
     );
   });
 
+  // @gate !disableLegacyContext
   it('should pass portal context when rendering subtree elsewhere', () => {
     const portalContainer = document.createElement('div');
 
@@ -752,6 +753,7 @@ describe('ReactDOMFiber', () => {
     expect(portalContainer.innerHTML).toBe('<div>bar</div>');
   });
 
+  // @gate !disableLegacyContext
   it('should update portal context if it changes due to setState', () => {
     const portalContainer = document.createElement('div');
 
@@ -796,6 +798,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe('');
   });
 
+  // @gate !disableLegacyContext
   it('should update portal context if it changes due to re-render', () => {
     const portalContainer = document.createElement('div');
 

commit 696953fd51deaf60fd55733493a372cc3520d8b7
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Jan 24 23:55:42 2024 -0500

    Convert ReactDOMFiber to createRoot (#28077)
    
    Copies the existing tests to `ReactDOMLegacyFiber`, and updates
    `ReactDOMFiber` to new root.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 06773b68f1..94172ab77b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -9,16 +9,31 @@
 
 'use strict';
 
-const React = require('react');
-const ReactDOM = require('react-dom');
-const PropTypes = require('prop-types');
+let React;
+let ReactDOM;
+let PropTypes;
+let ReactDOMClient;
+let root;
+let Scheduler;
+let act;
+let assertLog;
 
 describe('ReactDOMFiber', () => {
   let container;
 
   beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+    PropTypes = require('prop-types');
+    ReactDOMClient = require('react-dom/client');
+    Scheduler = require('scheduler');
+    act = require('internal-test-utils').act;
+    assertLog = require('internal-test-utils').assertLog;
+
     container = document.createElement('div');
     document.body.appendChild(container);
+    root = ReactDOMClient.createRoot(container);
   });
 
   afterEach(() => {
@@ -27,157 +42,86 @@ describe('ReactDOMFiber', () => {
     jest.restoreAllMocks();
   });
 
-  it('should render strings as children', () => {
+  it('should render strings as children', async () => {
     const Box = ({value}) => <div>{value}</div>;
-
-    ReactDOM.render(<Box value="foo" />, container);
+    await act(async () => {
+      root.render(<Box value="foo" />);
+    });
     expect(container.textContent).toEqual('foo');
   });
 
-  it('should render numbers as children', () => {
+  it('should render numbers as children', async () => {
     const Box = ({value}) => <div>{value}</div>;
 
-    ReactDOM.render(<Box value={10} />, container);
+    await act(async () => {
+      root.render(<Box value={10} />);
+    });
 
     expect(container.textContent).toEqual('10');
   });
 
-  it('should be called a callback argument', () => {
+  it('should call an effect after mount/update (replacing render callback pattern)', async () => {
+    function Component() {
+      React.useEffect(() => {
+        Scheduler.log('Callback');
+      });
+      return <div>Foo</div>;
+    }
+
     // mounting phase
-    let called = false;
-    ReactDOM.render(<div>Foo</div>, container, () => (called = true));
-    expect(called).toEqual(true);
+    await act(async () => {
+      root.render(<Component />);
+    });
+    assertLog(['Callback']);
 
     // updating phase
-    called = false;
-    ReactDOM.render(<div>Foo</div>, container, () => (called = true));
-    expect(called).toEqual(true);
+    await act(async () => {
+      root.render(<Component />);
+    });
+    assertLog(['Callback']);
   });
 
-  it('should call a callback argument when the same element is re-rendered', () => {
-    class Foo extends React.Component {
-      render() {
-        return <div>Foo</div>;
-      }
+  it('should call an effect when the same element is re-rendered (replacing render callback pattern)', async () => {
+    function Component({prop}) {
+      React.useEffect(() => {
+        Scheduler.log('Callback');
+      });
+      return <div>{prop}</div>;
     }
-    const element = <Foo />;
 
     // mounting phase
-    let called = false;
-    ReactDOM.render(element, container, () => (called = true));
-    expect(called).toEqual(true);
+    await act(async () => {
+      root.render(<Component prop="Foo" />);
+    });
+    assertLog(['Callback']);
 
     // updating phase
-    called = false;
-    ReactDOM.unstable_batchedUpdates(() => {
-      ReactDOM.render(element, container, () => (called = true));
+    await act(async () => {
+      root.render(<Component prop="Bar" />);
     });
-    expect(called).toEqual(true);
+    assertLog(['Callback']);
   });
 
-  it('should render a component returning strings directly from render', () => {
+  it('should render a component returning strings directly from render', async () => {
     const Text = ({value}) => value;
 
-    ReactDOM.render(<Text value="foo" />, container);
+    await act(async () => {
+      root.render(<Text value="foo" />);
+    });
+
     expect(container.textContent).toEqual('foo');
   });
 
-  it('should render a component returning numbers directly from render', () => {
+  it('should render a component returning numbers directly from render', async () => {
     const Text = ({value}) => value;
-
-    ReactDOM.render(<Text value={10} />, container);
+    await act(async () => {
+      root.render(<Text value={10} />);
+    });
 
     expect(container.textContent).toEqual('10');
   });
 
-  it('finds the DOM Text node of a string child', () => {
-    class Text extends React.Component {
-      render() {
-        return this.props.value;
-      }
-    }
-
-    let instance = null;
-    ReactDOM.render(
-      <Text value="foo" ref={ref => (instance = ref)} />,
-      container,
-    );
-
-    const textNode = ReactDOM.findDOMNode(instance);
-    expect(textNode).toBe(container.firstChild);
-    expect(textNode.nodeType).toBe(3);
-    expect(textNode.nodeValue).toBe('foo');
-  });
-
-  it('finds the first child when a component returns a fragment', () => {
-    class Fragment extends React.Component {
-      render() {
-        return [<div key="a" />, <span key="b" />];
-      }
-    }
-
-    let instance = null;
-    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
-
-    expect(container.childNodes.length).toBe(2);
-
-    const firstNode = ReactDOM.findDOMNode(instance);
-    expect(firstNode).toBe(container.firstChild);
-    expect(firstNode.tagName).toBe('DIV');
-  });
-
-  it('finds the first child even when fragment is nested', () => {
-    class Wrapper extends React.Component {
-      render() {
-        return this.props.children;
-      }
-    }
-
-    class Fragment extends React.Component {
-      render() {
-        return [
-          <Wrapper key="a">
-            <div />
-          </Wrapper>,
-          <span key="b" />,
-        ];
-      }
-    }
-
-    let instance = null;
-    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
-
-    expect(container.childNodes.length).toBe(2);
-
-    const firstNode = ReactDOM.findDOMNode(instance);
-    expect(firstNode).toBe(container.firstChild);
-    expect(firstNode.tagName).toBe('DIV');
-  });
-
-  it('finds the first child even when first child renders null', () => {
-    class NullComponent extends React.Component {
-      render() {
-        return null;
-      }
-    }
-
-    class Fragment extends React.Component {
-      render() {
-        return [<NullComponent key="a" />, <div key="b" />, <span key="c" />];
-      }
-    }
-
-    let instance = null;
-    ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container);
-
-    expect(container.childNodes.length).toBe(2);
-
-    const firstNode = ReactDOM.findDOMNode(instance);
-    expect(firstNode).toBe(container.firstChild);
-    expect(firstNode.tagName).toBe('DIV');
-  });
-
-  it('renders an empty fragment', () => {
+  it('renders an empty fragment', async () => {
     const Div = () => <div />;
     const EmptyFragment = () => <></>;
     const NonEmptyFragment = () => (
@@ -186,19 +130,29 @@ describe('ReactDOMFiber', () => {
       </>
     );
 
-    ReactDOM.render(<EmptyFragment />, container);
+    await act(async () => {
+      root.render(<EmptyFragment />);
+    });
     expect(container.firstChild).toBe(null);
 
-    ReactDOM.render(<NonEmptyFragment />, container);
+    await act(async () => {
+      root.render(<NonEmptyFragment />);
+    });
     expect(container.firstChild.tagName).toBe('DIV');
 
-    ReactDOM.render(<EmptyFragment />, container);
+    await act(async () => {
+      root.render(<EmptyFragment />);
+    });
     expect(container.firstChild).toBe(null);
 
-    ReactDOM.render(<Div />, container);
+    await act(async () => {
+      root.render(<Div />);
+    });
     expect(container.firstChild.tagName).toBe('DIV');
 
-    ReactDOM.render(<EmptyFragment />, container);
+    await act(async () => {
+      root.render(<EmptyFragment />);
+    });
     expect(container.firstChild).toBe(null);
   });
 
@@ -211,13 +165,16 @@ describe('ReactDOMFiber', () => {
     return ReactDOM.createPortal(tree, document.createElement('div'));
   };
 
-  const assertNamespacesMatch = function (tree) {
+  const assertNamespacesMatch = async function (tree) {
     const testContainer = document.createElement('div');
     svgEls = [];
     htmlEls = [];
     mathEls = [];
 
-    ReactDOM.render(tree, testContainer);
+    const testRoot = ReactDOMClient.createRoot(testContainer);
+    await act(async () => {
+      testRoot.render(tree);
+    });
     svgEls.forEach(el => {
       expect(el.namespaceURI).toBe('http://www.w3.org/2000/svg');
     });
@@ -228,39 +185,39 @@ describe('ReactDOMFiber', () => {
       expect(el.namespaceURI).toBe('http://www.w3.org/1998/Math/MathML');
     });
 
-    ReactDOM.unmountComponentAtNode(testContainer);
+    testRoot.unmount();
     expect(testContainer.innerHTML).toBe('');
   };
 
-  it('should render one portal', () => {
+  it('should render one portal', async () => {
     const portalContainer = document.createElement('div');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(<div>portal</div>, portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>{ReactDOM.createPortal(<div>portal</div>, portalContainer)}</div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('<div>portal</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.unmountComponentAtNode(container);
+    root.unmount();
     expect(portalContainer.innerHTML).toBe('');
     expect(container.innerHTML).toBe('');
   });
 
-  it('should render many portals', () => {
+  it('should render many portals', async () => {
     const portalContainer1 = document.createElement('div');
     const portalContainer2 = document.createElement('div');
 
-    const ops = [];
     class Child extends React.Component {
       componentDidMount() {
-        ops.push(`${this.props.name} componentDidMount`);
+        Scheduler.log(`${this.props.name} componentDidMount`);
       }
       componentDidUpdate() {
-        ops.push(`${this.props.name} componentDidUpdate`);
+        Scheduler.log(`${this.props.name} componentDidUpdate`);
       }
       componentWillUnmount() {
-        ops.push(`${this.props.name} componentWillUnmount`);
+        Scheduler.log(`${this.props.name} componentWillUnmount`);
       }
       render() {
         return <div>{this.props.name}</div>;
@@ -269,13 +226,13 @@ describe('ReactDOMFiber', () => {
 
     class Parent extends React.Component {
       componentDidMount() {
-        ops.push(`Parent:${this.props.step} componentDidMount`);
+        Scheduler.log(`Parent:${this.props.step} componentDidMount`);
       }
       componentDidUpdate() {
-        ops.push(`Parent:${this.props.step} componentDidUpdate`);
+        Scheduler.log(`Parent:${this.props.step} componentDidUpdate`);
       }
       componentWillUnmount() {
-        ops.push(`Parent:${this.props.step} componentWillUnmount`);
+        Scheduler.log(`Parent:${this.props.step} componentWillUnmount`);
       }
       render() {
         const {step} = this.props;
@@ -297,7 +254,9 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    ReactDOM.render(<Parent step="a" />, container);
+    await act(() => {
+      root.render(<Parent step="a" />);
+    });
     expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:a</div>');
     expect(portalContainer2.innerHTML).toBe(
       '<div>portal2[0]:a</div><div>portal2[1]:a</div>',
@@ -305,7 +264,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe(
       '<div>normal[0]:a</div><div>normal[1]:a</div>',
     );
-    expect(ops).toEqual([
+    assertLog([
       'normal[0]:a componentDidMount',
       'portal1[0]:a componentDidMount',
       'normal[1]:a componentDidMount',
@@ -314,8 +273,9 @@ describe('ReactDOMFiber', () => {
       'Parent:a componentDidMount',
     ]);
 
-    ops.length = 0;
-    ReactDOM.render(<Parent step="b" />, container);
+    await act(() => {
+      root.render(<Parent step="b" />);
+    });
     expect(portalContainer1.innerHTML).toBe('<div>portal1[0]:b</div>');
     expect(portalContainer2.innerHTML).toBe(
       '<div>portal2[0]:b</div><div>portal2[1]:b</div>',
@@ -323,7 +283,7 @@ describe('ReactDOMFiber', () => {
     expect(container.innerHTML).toBe(
       '<div>normal[0]:b</div><div>normal[1]:b</div>',
     );
-    expect(ops).toEqual([
+    assertLog([
       'normal[0]:b componentDidUpdate',
       'portal1[0]:b componentDidUpdate',
       'normal[1]:b componentDidUpdate',
@@ -332,12 +292,11 @@ describe('ReactDOMFiber', () => {
       'Parent:b componentDidUpdate',
     ]);
 
-    ops.length = 0;
-    ReactDOM.unmountComponentAtNode(container);
+    root.unmount();
     expect(portalContainer1.innerHTML).toBe('');
     expect(portalContainer2.innerHTML).toBe('');
     expect(container.innerHTML).toBe('');
-    expect(ops).toEqual([
+    assertLog([
       'Parent:b componentWillUnmount',
       'normal[0]:b componentWillUnmount',
       'portal1[0]:b componentWillUnmount',
@@ -347,13 +306,13 @@ describe('ReactDOMFiber', () => {
     ]);
   });
 
-  it('should render nested portals', () => {
+  it('should render nested portals', async () => {
     const portalContainer1 = document.createElement('div');
     const portalContainer2 = document.createElement('div');
     const portalContainer3 = document.createElement('div');
 
-    ReactDOM.render(
-      [
+    await act(() => {
+      root.render([
         <div key="a">normal[0]</div>,
         ReactDOM.createPortal(
           [
@@ -371,9 +330,8 @@ describe('ReactDOMFiber', () => {
           portalContainer1,
         ),
         <div key="f">normal[1]</div>,
-      ],
-      container,
-    );
+      ]);
+    });
     expect(portalContainer1.innerHTML).toBe(
       '<div>portal1[0]</div><div>portal1[1]</div>',
     );
@@ -383,65 +341,74 @@ describe('ReactDOMFiber', () => {
       '<div>normal[0]</div><div>normal[1]</div>',
     );
 
-    ReactDOM.unmountComponentAtNode(container);
+    root.unmount();
     expect(portalContainer1.innerHTML).toBe('');
     expect(portalContainer2.innerHTML).toBe('');
     expect(portalContainer3.innerHTML).toBe('');
     expect(container.innerHTML).toBe('');
   });
 
-  it('should reconcile portal children', () => {
+  it('should reconcile portal children', async () => {
     const portalContainer = document.createElement('div');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>
+          {ReactDOM.createPortal(<div>portal:1</div>, portalContainer)}
+        </div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('<div>portal:1</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(<div>portal:2</div>, portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>
+          {ReactDOM.createPortal(<div>portal:2</div>, portalContainer)}
+        </div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('<div>portal:2</div>');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(<p>portal:3</p>, portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>{ReactDOM.createPortal(<p>portal:3</p>, portalContainer)}</div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('<p>portal:3</p>');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(['Hi', 'Bye'], portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>{ReactDOM.createPortal(['Hi', 'Bye'], portalContainer)}</div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('HiBye');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(['Bye', 'Hi'], portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div>{ReactDOM.createPortal(['Bye', 'Hi'], portalContainer)}</div>,
+      );
+    });
     expect(portalContainer.innerHTML).toBe('ByeHi');
     expect(container.innerHTML).toBe('<div></div>');
 
-    ReactDOM.render(
-      <div>{ReactDOM.createPortal(null, portalContainer)}</div>,
-      container,
-    );
+    await act(() => {
+      root.render(<div>{ReactDOM.createPortal(null, portalContainer)}</div>);
+    });
     expect(portalContainer.innerHTML).toBe('');
     expect(container.innerHTML).toBe('<div></div>');
   });
 
-  it('should unmount empty portal component wherever it appears', () => {
+  it('should unmount empty portal component wherever it appears', async () => {
     const portalContainer = document.createElement('div');
-
+    let instance;
     class Wrapper extends React.Component {
       constructor(props) {
         super(props);
+        instance = this;
         this.state = {
           show: true,
         };
@@ -461,31 +428,35 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    const instance = ReactDOM.render(<Wrapper />, container);
+    await act(() => {
+      root.render(<Wrapper />);
+    });
     expect(container.innerHTML).toBe(
       '<div><div>child</div><div>parent</div></div>',
     );
-    instance.setState({show: false});
+    await act(() => {
+      instance.setState({show: false});
+    });
     expect(instance.state.show).toBe(false);
     expect(container.innerHTML).toBe('<div><div>parent</div></div>');
   });
 
-  it('should keep track of namespace across portals (simple)', () => {
-    assertNamespacesMatch(
+  it('should keep track of namespace across portals (simple)', async () => {
+    await assertNamespacesMatch(
       <svg {...expectSVG}>
         <image {...expectSVG} />
         {usePortal(<div {...expectHTML} />)}
         <image {...expectSVG} />
       </svg>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <math {...expectMath}>
         <mi {...expectMath} />
         {usePortal(<div {...expectHTML} />)}
         <mi {...expectMath} />
       </math>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         <p {...expectHTML} />
         {usePortal(
@@ -498,8 +469,8 @@ describe('ReactDOMFiber', () => {
     );
   });
 
-  it('should keep track of namespace across portals (medium)', () => {
-    assertNamespacesMatch(
+  it('should keep track of namespace across portals (medium)', async () => {
+    await assertNamespacesMatch(
       <svg {...expectSVG}>
         <image {...expectSVG} />
         {usePortal(<div {...expectHTML} />)}
@@ -508,7 +479,7 @@ describe('ReactDOMFiber', () => {
         <image {...expectSVG} />
       </svg>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         <math {...expectMath}>
           <mi {...expectMath} />
@@ -521,7 +492,7 @@ describe('ReactDOMFiber', () => {
         <p {...expectHTML} />
       </div>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <math {...expectMath}>
         <mi {...expectMath} />
         {usePortal(
@@ -540,7 +511,7 @@ describe('ReactDOMFiber', () => {
         <mi {...expectMath} />
       </math>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         {usePortal(
           <svg {...expectSVG}>
@@ -551,7 +522,7 @@ describe('ReactDOMFiber', () => {
         <p {...expectHTML} />
       </div>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <svg {...expectSVG}>
         <svg {...expectSVG}>
           {usePortal(<div {...expectHTML} />)}
@@ -562,8 +533,8 @@ describe('ReactDOMFiber', () => {
     );
   });
 
-  it('should keep track of namespace across portals (complex)', () => {
-    assertNamespacesMatch(
+  it('should keep track of namespace across portals (complex)', async () => {
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         {usePortal(
           <svg {...expectSVG}>
@@ -583,7 +554,7 @@ describe('ReactDOMFiber', () => {
         <p {...expectHTML} />
       </div>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         <svg {...expectSVG}>
           <svg {...expectSVG}>
@@ -609,7 +580,7 @@ describe('ReactDOMFiber', () => {
         <p {...expectHTML} />
       </div>,
     );
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <div {...expectHTML}>
         <svg {...expectSVG}>
           <foreignObject {...expectSVG}>
@@ -636,22 +607,22 @@ describe('ReactDOMFiber', () => {
     );
   });
 
-  it('should unwind namespaces on uncaught errors', () => {
+  it('should unwind namespaces on uncaught errors', async () => {
     function BrokenRender() {
       throw new Error('Hello');
     }
 
-    expect(() => {
-      assertNamespacesMatch(
+    await expect(async () => {
+      await assertNamespacesMatch(
         <svg {...expectSVG}>
           <BrokenRender />
         </svg>,
       );
-    }).toThrow('Hello');
-    assertNamespacesMatch(<div {...expectHTML} />);
+    }).rejects.toThrow('Hello');
+    await assertNamespacesMatch(<div {...expectHTML} />);
   });
 
-  it('should unwind namespaces on caught errors', () => {
+  it('should unwind namespaces on caught errors', async () => {
     function BrokenRender() {
       throw new Error('Hello');
     }
@@ -669,7 +640,7 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <svg {...expectSVG}>
         <foreignObject {...expectSVG}>
           <ErrorBoundary>
@@ -681,10 +652,10 @@ describe('ReactDOMFiber', () => {
         <image {...expectSVG} />
       </svg>,
     );
-    assertNamespacesMatch(<div {...expectHTML} />);
+    await assertNamespacesMatch(<div {...expectHTML} />);
   });
 
-  it('should unwind namespaces on caught errors in a portal', () => {
+  it('should unwind namespaces on caught errors in a portal', async () => {
     function BrokenRender() {
       throw new Error('Hello');
     }
@@ -702,7 +673,7 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    assertNamespacesMatch(
+    await assertNamespacesMatch(
       <svg {...expectSVG}>
         <ErrorBoundary>
           {usePortal(
@@ -719,7 +690,7 @@ describe('ReactDOMFiber', () => {
   });
 
   // @gate !disableLegacyContext
-  it('should pass portal context when rendering subtree elsewhere', () => {
+  it('should pass portal context when rendering subtree elsewhere', async () => {
     const portalContainer = document.createElement('div');
 
     class Component extends React.Component {
@@ -748,153 +719,50 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    ReactDOM.render(<Parent />, container);
+    await act(async () => {
+      root.render(<Parent />);
+    });
     expect(container.innerHTML).toBe('');
     expect(portalContainer.innerHTML).toBe('<div>bar</div>');
   });
 
-  // @gate !disableLegacyContext
-  it('should update portal context if it changes due to setState', () => {
-    const portalContainer = document.createElement('div');
-
-    class Component extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-        getFoo: PropTypes.func.isRequired,
-      };
-
-      render() {
-        return <div>{this.context.foo + '-' + this.context.getFoo()}</div>;
-      }
-    }
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string.isRequired,
-        getFoo: PropTypes.func.isRequired,
-      };
-
-      state = {
-        bar: 'initial',
-      };
-
-      getChildContext() {
-        return {
-          foo: this.state.bar,
-          getFoo: () => this.state.bar,
-        };
-      }
-
-      render() {
-        return ReactDOM.createPortal(<Component />, portalContainer);
-      }
-    }
-
-    const instance = ReactDOM.render(<Parent />, container);
-    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
-    expect(container.innerHTML).toBe('');
-    instance.setState({bar: 'changed'});
-    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
-    expect(container.innerHTML).toBe('');
-  });
-
-  // @gate !disableLegacyContext
-  it('should update portal context if it changes due to re-render', () => {
-    const portalContainer = document.createElement('div');
-
-    class Component extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-        getFoo: PropTypes.func.isRequired,
-      };
-
-      render() {
-        return <div>{this.context.foo + '-' + this.context.getFoo()}</div>;
-      }
-    }
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string.isRequired,
-        getFoo: PropTypes.func.isRequired,
-      };
-
-      getChildContext() {
-        return {
-          foo: this.props.bar,
-          getFoo: () => this.props.bar,
-        };
-      }
-
-      render() {
-        return ReactDOM.createPortal(<Component />, portalContainer);
-      }
-    }
-
-    ReactDOM.render(<Parent bar="initial" />, container);
-    expect(portalContainer.innerHTML).toBe('<div>initial-initial</div>');
-    expect(container.innerHTML).toBe('');
-    ReactDOM.render(<Parent bar="changed" />, container);
-    expect(portalContainer.innerHTML).toBe('<div>changed-changed</div>');
-    expect(container.innerHTML).toBe('');
-  });
-
-  it('findDOMNode should find dom element after expanding a fragment', () => {
-    class MyNode extends React.Component {
-      render() {
-        return !this.props.flag
-          ? [<div key="a" />]
-          : [<span key="b" />, <div key="a" />];
-      }
-    }
-
-    const myNodeA = ReactDOM.render(<MyNode />, container);
-    const a = ReactDOM.findDOMNode(myNodeA);
-    expect(a.tagName).toBe('DIV');
-
-    const myNodeB = ReactDOM.render(<MyNode flag={true} />, container);
-    expect(myNodeA === myNodeB).toBe(true);
-
-    const b = ReactDOM.findDOMNode(myNodeB);
-    expect(b.tagName).toBe('SPAN');
-  });
-
-  it('should bubble events from the portal to the parent', () => {
+  it('should bubble events from the portal to the parent', async () => {
     const portalContainer = document.createElement('div');
     document.body.appendChild(portalContainer);
     try {
-      const ops = [];
       let portal = null;
 
-      ReactDOM.render(
-        <div onClick={() => ops.push('parent clicked')}>
-          {ReactDOM.createPortal(
-            <div
-              onClick={() => ops.push('portal clicked')}
-              ref={n => (portal = n)}>
-              portal
-            </div>,
-            portalContainer,
-          )}
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div onClick={() => Scheduler.log('parent clicked')}>
+            {ReactDOM.createPortal(
+              <div
+                onClick={() => Scheduler.log('portal clicked')}
+                ref={n => (portal = n)}>
+                portal
+              </div>,
+              portalContainer,
+            )}
+          </div>,
+        );
+      });
 
       expect(portal.tagName).toBe('DIV');
 
-      portal.click();
+      await act(() => {
+        portal.click();
+      });
 
-      expect(ops).toEqual(['portal clicked', 'parent clicked']);
+      assertLog(['portal clicked', 'parent clicked']);
     } finally {
       document.body.removeChild(portalContainer);
     }
   });
 
-  it('should not onMouseLeave when staying in the portal', () => {
+  it('should not onMouseLeave when staying in the portal', async () => {
     const portalContainer = document.createElement('div');
     document.body.appendChild(portalContainer);
 
-    let ops = [];
     let firstTarget = null;
     let secondTarget = null;
     let thirdTarget = null;
@@ -921,42 +789,44 @@ describe('ReactDOMFiber', () => {
     }
 
     try {
-      ReactDOM.render(
-        <div>
-          <div
-            onMouseEnter={() => ops.push('enter parent')}
-            onMouseLeave={() => ops.push('leave parent')}>
-            <div ref={n => (firstTarget = n)} />
-            {ReactDOM.createPortal(
-              <div
-                onMouseEnter={() => ops.push('enter portal')}
-                onMouseLeave={() => ops.push('leave portal')}
-                ref={n => (secondTarget = n)}>
-                portal
-              </div>,
-              portalContainer,
-            )}
-          </div>
-          <div ref={n => (thirdTarget = n)} />
-        </div>,
-        container,
-      );
-
-      simulateMouseMove(null, firstTarget);
-      expect(ops).toEqual(['enter parent']);
-
-      ops = [];
+      await act(() => {
+        root.render(
+          <div>
+            <div
+              onMouseEnter={() => Scheduler.log('enter parent')}
+              onMouseLeave={() => Scheduler.log('leave parent')}>
+              <div ref={n => (firstTarget = n)} />
+              {ReactDOM.createPortal(
+                <div
+                  onMouseEnter={() => Scheduler.log('enter portal')}
+                  onMouseLeave={() => Scheduler.log('leave portal')}
+                  ref={n => (secondTarget = n)}>
+                  portal
+                </div>,
+                portalContainer,
+              )}
+            </div>
+            <div ref={n => (thirdTarget = n)} />
+          </div>,
+        );
+      });
+      await act(() => {
+        simulateMouseMove(null, firstTarget);
+      });
+      assertLog(['enter parent']);
 
-      simulateMouseMove(firstTarget, secondTarget);
-      expect(ops).toEqual([
+      await act(() => {
+        simulateMouseMove(firstTarget, secondTarget);
+      });
+      assertLog([
         // Parent did not invoke leave because we're still inside the portal.
         'enter portal',
       ]);
 
-      ops = [];
-
-      simulateMouseMove(secondTarget, thirdTarget);
-      expect(ops).toEqual([
+      await act(() => {
+        simulateMouseMove(secondTarget, thirdTarget);
+      });
+      assertLog([
         'leave portal',
         'leave parent', // Only when we leave the portal does onMouseLeave fire.
       ]);
@@ -966,8 +836,7 @@ describe('ReactDOMFiber', () => {
   });
 
   // Regression test for https://github.com/facebook/react/issues/19562
-  it('does not fire mouseEnter twice when relatedTarget is the root node', () => {
-    let ops = [];
+  it('does not fire mouseEnter twice when relatedTarget is the root node', async () => {
     let target = null;
 
     function simulateMouseMove(from, to) {
@@ -991,45 +860,57 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    ReactDOM.render(
-      <div
-        ref={n => (target = n)}
-        onMouseEnter={() => ops.push('enter')}
-        onMouseLeave={() => ops.push('leave')}
-      />,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div
+          ref={n => (target = n)}
+          onMouseEnter={() => Scheduler.log('enter')}
+          onMouseLeave={() => Scheduler.log('leave')}
+        />,
+      );
+    });
 
-    simulateMouseMove(null, container);
-    expect(ops).toEqual([]);
+    await act(() => {
+      simulateMouseMove(null, container);
+    });
+    assertLog([]);
 
-    ops = [];
-    simulateMouseMove(container, target);
-    expect(ops).toEqual(['enter']);
+    await act(() => {
+      simulateMouseMove(container, target);
+    });
+    assertLog(['enter']);
 
-    ops = [];
-    simulateMouseMove(target, container);
-    expect(ops).toEqual(['leave']);
+    await act(() => {
+      simulateMouseMove(target, container);
+    });
+    assertLog(['leave']);
 
-    ops = [];
-    simulateMouseMove(container, null);
-    expect(ops).toEqual([]);
+    await act(() => {
+      simulateMouseMove(container, null);
+    });
+    assertLog([]);
   });
 
-  it('listens to events that do not exist in the Portal subtree', () => {
+  it('listens to events that do not exist in the Portal subtree', async () => {
     const onClick = jest.fn();
 
     const ref = React.createRef();
-    ReactDOM.render(
-      <div onClick={onClick}>
-        {ReactDOM.createPortal(<button ref={ref}>click</button>, document.body)}
-      </div>,
-      container,
-    );
+    await act(() => {
+      root.render(
+        <div onClick={onClick}>
+          {ReactDOM.createPortal(
+            <button ref={ref}>click</button>,
+            document.body,
+          )}
+        </div>,
+      );
+    });
     const event = new MouseEvent('click', {
       bubbles: true,
     });
-    ref.current.dispatchEvent(event);
+    await act(() => {
+      ref.current.dispatchEvent(event);
+    });
 
     expect(onClick).toHaveBeenCalledTimes(1);
   });
@@ -1049,7 +930,11 @@ describe('ReactDOMFiber', () => {
         return <div onClick="woops" />;
       }
     }
-    expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Example />);
+      });
+    }).toErrorDev(
       'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
         '    in div (at **)\n' +
         '    in Example (at **)',
@@ -1062,7 +947,11 @@ describe('ReactDOMFiber', () => {
         return <div onClick={false} />;
       }
     }
-    expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Example />);
+      });
+    }).toErrorDev(
       'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
         'If you used to conditionally omit it with onClick={condition && value}, ' +
         'pass onClick={condition ? value : undefined} instead.\n' +
@@ -1071,12 +960,9 @@ describe('ReactDOMFiber', () => {
     );
   });
 
-  it('should not update event handlers until commit', () => {
-    spyOnDev(console, 'error');
-
-    let ops = [];
-    const handlerA = () => ops.push('A');
-    const handlerB = () => ops.push('B');
+  it('should not update event handlers until commit', async () => {
+    const handlerA = () => Scheduler.log('A');
+    const handlerB = () => Scheduler.log('B');
 
     function click() {
       const event = new MouseEvent('click', {
@@ -1114,137 +1000,155 @@ describe('ReactDOMFiber', () => {
     }
 
     let inst;
-    ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container);
+    await act(() => {
+      root.render([<Example key="a" ref={n => (inst = n)} />]);
+    });
     const node = container.firstChild;
     expect(node.tagName).toEqual('DIV');
 
-    click();
+    await act(() => {
+      click();
+    });
 
-    expect(ops).toEqual(['A']);
-    ops = [];
+    assertLog(['A']);
 
     // Render with the other event handler.
-    inst.flip();
+    await act(() => {
+      inst.flip();
+    });
 
-    click();
+    await act(() => {
+      click();
+    });
 
-    expect(ops).toEqual(['B']);
-    ops = [];
+    assertLog(['B']);
 
     // Rerender without changing any props.
-    inst.tick();
+    await act(() => {
+      inst.tick();
+    });
 
-    click();
+    await act(() => {
+      click();
+    });
 
-    expect(ops).toEqual(['B']);
-    ops = [];
+    assertLog(['B']);
 
     // Render a flip back to the A handler. The second component invokes the
     // click handler during render to simulate a click during an aborted
     // render. I use this hack because at current time we don't have a way to
     // test aborted ReactDOM renders.
-    ReactDOM.render(
-      [<Example key="a" forceA={true} />, <Click key="b" />],
-      container,
-    );
+    await act(() => {
+      root.render([<Example key="a" forceA={true} />, <Click key="b" />]);
+    });
 
     // Because the new click handler has not yet committed, we should still
     // invoke B.
-    expect(ops).toEqual(['B']);
-    ops = [];
+    assertLog(['B']);
 
     // Any click that happens after commit, should invoke A.
-    click();
-    expect(ops).toEqual(['A']);
+    await act(() => {
+      click();
+    });
+    assertLog(['A']);
+  });
 
-    if (__DEV__) {
-      expect(console.error).toHaveBeenCalledTimes(2);
-      expect(console.error.mock.calls[0][0]).toMatch(
-        'ReactDOM.render is no longer supported in React 18',
-      );
-      expect(console.error.mock.calls[1][0]).toMatch(
-        'ReactDOM.render is no longer supported in React 18',
+  it('should not crash encountering low-priority tree', async () => {
+    await act(() => {
+      root.render(
+        <div hidden={true}>
+          <div />
+        </div>,
       );
-    }
-  });
+    });
 
-  it('should not crash encountering low-priority tree', () => {
-    ReactDOM.render(
-      <div hidden={true}>
-        <div />
-      </div>,
-      container,
-    );
+    expect(container.innerHTML).toBe('<div hidden=""><div></div></div>');
   });
 
-  it('should not warn when rendering into an empty container', () => {
-    ReactDOM.render(<div>foo</div>, container);
+  it('should not warn when rendering into an empty container', async () => {
+    await act(() => {
+      root.render(<div>foo</div>);
+    });
     expect(container.innerHTML).toBe('<div>foo</div>');
-    ReactDOM.render(null, container);
+    await act(() => {
+      root.render(null);
+    });
     expect(container.innerHTML).toBe('');
-    ReactDOM.render(<div>bar</div>, container);
+    await act(() => {
+      root.render(<div>bar</div>);
+    });
     expect(container.innerHTML).toBe('<div>bar</div>');
   });
 
-  it('should warn when replacing a container which was manually updated outside of React', () => {
+  it('should warn when replacing a container which was manually updated outside of React', async () => {
     // when not messing with the DOM outside of React
-    ReactDOM.render(<div key="1">foo</div>, container);
-    ReactDOM.render(<div key="1">bar</div>, container);
+    await act(() => {
+      root.render(<div key="1">foo</div>);
+    });
+    expect(container.innerHTML).toBe('<div>foo</div>');
+
+    await act(() => {
+      root.render(<div key="1">bar</div>);
+    });
     expect(container.innerHTML).toBe('<div>bar</div>');
+
     // then we mess with the DOM before an update
     // we know this will error - that is expected right now
     // It's an error of type 'NotFoundError' with no message
     container.innerHTML = '<div>MEOW.</div>';
 
     expect(() => {
-      expect(() =>
-        ReactDOM.render(<div key="2">baz</div>, container),
-      ).toErrorDev(
-        'render(...): ' +
-          'It looks like the React-rendered content of this container was ' +
-          'removed without using React. This is not supported and will ' +
-          'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-          'to empty a container.',
-        {withoutStack: true},
-      );
-    }).toThrowError();
+      ReactDOM.flushSync(() => {
+        root.render(<div key="2">baz</div>);
+      });
+    }).toThrow('The node to be removed is not a child of this node');
   });
 
-  it('should warn when doing an update to a container manually updated outside of React', () => {
+  it('should not warn when doing an update to a container manually updated outside of React', async () => {
     // when not messing with the DOM outside of React
-    ReactDOM.render(<div>foo</div>, container);
-    ReactDOM.render(<div>bar</div>, container);
+    await act(() => {
+      root.render(<div>foo</div>);
+    });
+    expect(container.innerHTML).toBe('<div>foo</div>');
+
+    await act(() => {
+      root.render(<div>bar</div>);
+    });
     expect(container.innerHTML).toBe('<div>bar</div>');
+
     // then we mess with the DOM before an update
     container.innerHTML = '<div>MEOW.</div>';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
-      'render(...): ' +
-        'It looks like the React-rendered content of this container was ' +
-        'removed without using React. This is not supported and will ' +
-        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-        'to empty a container.',
-      {withoutStack: true},
-    );
+
+    await act(() => {
+      root.render(<div>baz</div>);
+    });
+    // TODO: why not, and no error?
+    expect(container.innerHTML).toBe('<div>MEOW.</div>');
   });
 
-  it('should warn when doing an update to a container manually cleared outside of React', () => {
+  it('should not warn when doing an update to a container manually cleared outside of React', async () => {
     // when not messing with the DOM outside of React
-    ReactDOM.render(<div>foo</div>, container);
-    ReactDOM.render(<div>bar</div>, container);
+    await act(() => {
+      root.render(<div>foo</div>);
+    });
+    expect(container.innerHTML).toBe('<div>foo</div>');
+
+    await act(() => {
+      root.render(<div>bar</div>);
+    });
     expect(container.innerHTML).toBe('<div>bar</div>');
+
     // then we mess with the DOM before an update
     container.innerHTML = '';
-    expect(() => ReactDOM.render(<div>baz</div>, container)).toErrorDev(
-      'render(...): ' +
-        'It looks like the React-rendered content of this container was ' +
-        'removed without using React. This is not supported and will ' +
-        'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
-        'to empty a container.',
-      {withoutStack: true},
-    );
+
+    await act(() => {
+      root.render(<div>baz</div>);
+    });
+    // TODO: why not, and no error?
+    expect(container.innerHTML).toBe('');
   });
 
-  it('should render a text component with a text DOM node on the same document as the container', () => {
+  it('should render a text component with a text DOM node on the same document as the container', async () => {
     // 1. Create a new document through the use of iframe
     // 2. Set up the spy to make asserts when a text component
     //    is rendered inside the iframe container
@@ -1266,7 +1170,10 @@ describe('ReactDOMFiber', () => {
       textNode = node;
     });
 
-    ReactDOM.render(textContent, iframeContainer);
+    const iFrameRoot = ReactDOMClient.createRoot(iframeContainer);
+    await act(() => {
+      iFrameRoot.render(textContent);
+    });
 
     expect(textNode.textContent).toBe(textContent);
     expect(actualDocument).not.toBe(document);
@@ -1274,16 +1181,19 @@ describe('ReactDOMFiber', () => {
     expect(iframeContainer.appendChild).toHaveBeenCalledTimes(1);
   });
 
-  it('should mount into a document fragment', () => {
+  it('should mount into a document fragment', async () => {
     const fragment = document.createDocumentFragment();
-    ReactDOM.render(<div>foo</div>, fragment);
+    const fragmentRoot = ReactDOMClient.createRoot(fragment);
+    await act(() => {
+      fragmentRoot.render(<div>foo</div>);
+    });
     expect(container.innerHTML).toBe('');
     container.appendChild(fragment);
     expect(container.innerHTML).toBe('<div>foo</div>');
   });
 
   // Regression test for https://github.com/facebook/react/issues/12643#issuecomment-413727104
-  it('should not diff memoized host components', () => {
+  it('should not diff memoized host components', async () => {
     const inputRef = React.createRef();
     let didCallOnChange = false;
 
@@ -1332,44 +1242,16 @@ describe('ReactDOMFiber', () => {
       }
     }
 
-    ReactDOM.render(<Parent />, container);
-    inputRef.current.dispatchEvent(
-      new MouseEvent('click', {
-        bubbles: true,
-      }),
-    );
-    expect(didCallOnChange).toBe(true);
-  });
-
-  it('unmounted legacy roots should never clear newer root content from a container', () => {
-    const ref = React.createRef();
-
-    function OldApp() {
-      const hideOnFocus = () => {
-        // This app unmounts itself inside of a focus event.
-        ReactDOM.unmountComponentAtNode(container);
-      };
-
-      return (
-        <button onFocus={hideOnFocus} ref={ref}>
-          old
-        </button>
+    await act(() => {
+      root.render(<Parent />);
+    });
+    await act(() => {
+      inputRef.current.dispatchEvent(
+        new MouseEvent('click', {
+          bubbles: true,
+        }),
       );
-    }
-
-    function NewApp() {
-      return <button ref={ref}>new</button>;
-    }
-
-    ReactDOM.render(<OldApp />, container);
-    ref.current.focus();
-
-    ReactDOM.render(<NewApp />, container);
-
-    // Calling focus again will flush previously scheduled discrete work for the old root-
-    // but this should not clear out the newly mounted app.
-    ref.current.focus();
-
-    expect(container.textContent).toBe('new');
+    });
+    expect(didCallOnChange).toBe(true);
   });
 });

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 94172ab77b..6b9eb72228 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -22,7 +22,6 @@ describe('ReactDOMFiber', () => {
   let container;
 
   beforeEach(() => {
-    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     PropTypes = require('prop-types');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 6b9eb72228..94172ab77b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -22,6 +22,7 @@ describe('ReactDOMFiber', () => {
   let container;
 
   beforeEach(() => {
+    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     PropTypes = require('prop-types');

commit 2f240c91ed54900adee213565cb2039e161629e9
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Mon Feb 26 19:18:50 2024 +0100

    Add support for rendering BigInt (#24580)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 94172ab77b..2882cab2e9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -60,6 +60,17 @@ describe('ReactDOMFiber', () => {
     expect(container.textContent).toEqual('10');
   });
 
+  // @gate enableBigIntSupport
+  it('should render bigints as children', async () => {
+    const Box = ({value}) => <div>{value}</div>;
+
+    await act(async () => {
+      root.render(<Box value={10n} />);
+    });
+
+    expect(container.textContent).toEqual('10');
+  });
+
   it('should call an effect after mount/update (replacing render callback pattern)', async () => {
     function Component() {
       React.useEffect(() => {

commit 6786563f3cbbc9b16d5a8187207b5bd904386e53
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 26 20:44:07 2024 -0700

    [Fiber] Don't Rethrow Errors at the Root (#28627)
    
    Stacked on top of #28498 for test fixes.
    
    ### Don't Rethrow
    
    When we started React it was 1:1 setState calls a series of renders and
    if they error, it errors where the setState was called. Simple. However,
    then batching came and the error actually got thrown somewhere else.
    With concurrent mode, it's not even possible to get setState itself to
    throw anymore.
    
    In fact, all APIs that can rethrow out of React are executed either at
    the root of the scheduler or inside a DOM event handler.
    If you throw inside a React.startTransition callback that's sync, then
    that will bubble out of the startTransition but if you throw inside an
    async callback or a useTransition we now need to handle it at the hook
    site. So in 19 we need to make all React.startTransition swallow the
    error (and report them to reportError).
    
    The only one remaining that can throw is flushSync but it doesn't really
    make sense for it to throw at the callsite neither because batching.
    Just because something rendered in this flush doesn't mean it was
    rendered due to what was just scheduled and doesn't mean that it should
    abort any of the remaining code afterwards. setState is fire and forget.
    It's send an instruction elsewhere, it's not part of the current
    imperative code.
    
    Error boundaries never rethrow. Since you should really always have
    error boundaries, most of the time, it wouldn't rethrow anyway.
    
    Rethrowing also actually currently drops errors on the floor since we
    can only rethrow the first error, so to avoid that we'd need to call
    reportError anyway. This happens in RN events.
    
    The other issue with rethrowing is that it logs an extra console.error.
    Since we're not sure that user code will actually log it anywhere we
    still log it too just like we do with errors inside error boundaries
    which leads all of these to log twice.
    The goal of this PR is to never rethrow out of React instead, errors
    outside of error boundaries get logged to reportError. Event system
    errors too.
    
    ### Breaking Changes
    
    The main thing this affects is testing where you want to inspect the
    errors thrown. To make it easier to port, if you're inside `act` we
    track the error into act in an aggregate error and then rethrow it at
    the root of `act`. Unlike before though, if you flush synchronously
    inside of act it'll still continue until the end of act before
    rethrowing.
    
    I expect most user code breakages would be to migrate from `flushSync`
    to `act` if you assert on throwing.
    
    However, in the React repo we also have `internalAct` and the
    `waitForThrow` helpers. Since these have to use public production
    implementations we track these using the global onerror or process
    uncaughtException. Unlike regular act, includes both event handler
    errors and onRecoverableError by default too. Not just render/commit
    errors. So I had to account for that in our tests.
    
    We restore logging an extra log for uncaught errors after the main log
    with the component stack in it. We use `console.warn`. This is not yet
    ignorable if you preventDefault to the main error event. To avoid
    confusion if you don't end up logging the error to console I just added
    `An error occurred`.
    
    ### Polyfill
    
    All browsers we support really supports `reportError` but not all test
    and server environments do, so I implemented a polyfill for browser and
    node in `shared/reportGlobalError`. I don't love that this is included
    in all builds and gets duplicated into isomorphic even though it's not
    actually needed in production. Maybe in the future we can require a
    polyfill for this.
    
    ### Follow Ups
    
    In a follow up, I'll make caught vs uncaught error handling be
    configurable too.
    
    ---------
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 2882cab2e9..f135bd288d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -1108,11 +1108,13 @@ describe('ReactDOMFiber', () => {
     // It's an error of type 'NotFoundError' with no message
     container.innerHTML = '<div>MEOW.</div>';
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<div key="2">baz</div>);
+    await expect(async () => {
+      await act(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<div key="2">baz</div>);
+        });
       });
-    }).toThrow('The node to be removed is not a child of this node');
+    }).rejects.toThrow('The node to be removed is not a child of this node');
   });
 
   it('should not warn when doing an update to a container manually updated outside of React', async () => {

commit 7a2609eedc571049a3272e60d5f7d84601ffca3f
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Apr 3 09:25:02 2024 -0400

    Cleanup enableBigIntSupport flag (#28711)
    
    Cleanup enableBigIntSupport flag

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index f135bd288d..a1633fa1e6 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -60,7 +60,6 @@ describe('ReactDOMFiber', () => {
     expect(container.textContent).toEqual('10');
   });
 
-  // @gate enableBigIntSupport
   it('should render bigints as children', async () => {
     const Box = ({value}) => <div>{value}</div>;
 

commit 378b305958eb7259cacfce8ad0e66eec07e07074
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Jul 10 11:53:00 2024 -0400

    Warn about legacy context when legacy context is not disabled (#30297)
    
    For environments that still have legacy contexts available, this adds a
    warning to make the remaining call sites easier to locate and encourage
    upgrades.

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index a1633fa1e6..7c701219ec 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -13,10 +13,12 @@ let React;
 let ReactDOM;
 let PropTypes;
 let ReactDOMClient;
-let root;
 let Scheduler;
+
 let act;
+let assertConsoleErrorDev;
 let assertLog;
+let root;
 
 describe('ReactDOMFiber', () => {
   let container;
@@ -29,7 +31,7 @@ describe('ReactDOMFiber', () => {
     ReactDOMClient = require('react-dom/client');
     Scheduler = require('scheduler');
     act = require('internal-test-utils').act;
-    assertLog = require('internal-test-utils').assertLog;
+    ({assertConsoleErrorDev, assertLog} = require('internal-test-utils'));
 
     container = document.createElement('div');
     document.body.appendChild(container);
@@ -732,6 +734,10 @@ describe('ReactDOMFiber', () => {
     await act(async () => {
       root.render(<Parent />);
     });
+    assertConsoleErrorDev([
+      'Parent uses the legacy childContextTypes API which will soon be removed. Use React.createContext() instead.',
+      'Component uses the legacy contextTypes API which will soon be removed. Use React.createContext() with static contextType instead.',
+    ]);
     expect(container.innerHTML).toBe('');
     expect(portalContainer.innerHTML).toBe('<div>bar</div>');
   });

commit d9c4920e8b3fff3d3da24d14adf7ac884aee55b2
Author: ling1726 <lingfangao@hotmail.com>
Date:   Fri Sep 13 22:29:40 2024 +0200

    fix: restore selection should consider the window of the container (#30951)
    
    ## Summary
    
    
    Fixes #30864
    
    Before this PR the active elemen was always taken from the global
    `window`. This is incorrect if the renderer is in one window rendering
    into a container element in another window. The changes in this PR adds
    another code branch to use a `defaultView` of the container element if
    it exists so that `restoreSelection` after a commit will actually
    restore to the correct window.
    
    ## How did you test this change?
    
    I patched these changes to the repro repo in the linked issue #39864
    https://github.com/ling1726/react-child-window-focus-repro/blob/master/patches/react-dom%2B18.3.1.patch.
    
    I followed the same repro steps in the linked issue and and could not
    repro the reported problem. Attaching screen recordings below:
    
    Before
    ![focus
    repro](https://github.com/user-attachments/assets/81c4b4f9-08b5-4356-8251-49b909771f3f)
    
    After
    
    ![after](https://github.com/user-attachments/assets/84883032-5558-4650-9b9a-bd4d5fd9cb13)

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 7c701219ec..cf0526fd61 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -19,12 +19,23 @@ let act;
 let assertConsoleErrorDev;
 let assertLog;
 let root;
+let JSDOM;
 
 describe('ReactDOMFiber', () => {
   let container;
 
   beforeEach(() => {
     jest.resetModules();
+
+    // JSDOM needs to be setup with a TextEncoder and TextDecoder when used standalone
+    // https://github.com/jsdom/jsdom/issues/2524
+    (() => {
+      const {TextEncoder, TextDecoder} = require('util');
+      global.TextEncoder = TextEncoder;
+      global.TextDecoder = TextDecoder;
+      JSDOM = require('jsdom').JSDOM;
+    })();
+
     React = require('react');
     ReactDOM = require('react-dom');
     PropTypes = require('prop-types');
@@ -1272,4 +1283,48 @@ describe('ReactDOMFiber', () => {
     });
     expect(didCallOnChange).toBe(true);
   });
+
+  it('should restore selection in the correct window', async () => {
+    // creating new JSDOM instance to get a second window as window.open is not implemented
+    // https://github.com/jsdom/jsdom/blob/c53efc81e75f38a0558fbf3ed75d30b78b4c4898/lib/jsdom/browser/Window.js#L987
+    const {window: newWindow} = new JSDOM('');
+    // creating a new container since the default cleanup expects the existing container to be in the document
+    const newContainer = newWindow.document.createElement('div');
+    newWindow.document.body.appendChild(newContainer);
+    root = ReactDOMClient.createRoot(newContainer);
+
+    const Test = () => {
+      const [reverse, setReverse] = React.useState(false);
+      const [items] = React.useState(() => ['a', 'b', 'c']);
+      const onClick = () => {
+        setReverse(true);
+      };
+
+      // shuffle the items so that the react commit needs to restore focus
+      // to the correct element after commit
+      const itemsToRender = reverse ? items.reverse() : items;
+
+      return (
+        <div>
+          {itemsToRender.map(item => (
+            <button onClick={onClick} key={item} id={item}>
+              {item}
+            </button>
+          ))}
+        </div>
+      );
+    };
+
+    await act(() => {
+      root.render(<Test />);
+    });
+
+    newWindow.document.getElementById('a').focus();
+    await act(() => {
+      newWindow.document.getElementById('a').click();
+    });
+
+    expect(newWindow.document.activeElement).not.toBe(newWindow.document.body);
+    expect(newWindow.document.activeElement.innerHTML).toBe('a');
+  });
 });

commit 7c11aad3746d7aa89435d12322e79a72896d5a9b
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jan 2 15:53:06 2025 -0500

    [assert helpers] react-dom (pt2) (#31902)
    
    Converts more react-dom tests

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index cf0526fd61..9784e4f849 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -746,8 +746,13 @@ describe('ReactDOMFiber', () => {
       root.render(<Parent />);
     });
     assertConsoleErrorDev([
-      'Parent uses the legacy childContextTypes API which will soon be removed. Use React.createContext() instead.',
-      'Component uses the legacy contextTypes API which will soon be removed. Use React.createContext() with static contextType instead.',
+      'Parent uses the legacy childContextTypes API which will soon be removed. ' +
+        'Use React.createContext() instead. (https://react.dev/link/legacy-context)\n' +
+        '    in Parent (at **)',
+      'Component uses the legacy contextTypes API which will soon be removed. ' +
+        'Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\n' +
+        (gate('enableOwnerStacks') ? '' : '    in Component (at **)\n') +
+        '    in Parent (at **)',
     ]);
     expect(container.innerHTML).toBe('');
     expect(portalContainer.innerHTML).toBe('<div>bar</div>');
@@ -957,15 +962,14 @@ describe('ReactDOMFiber', () => {
         return <div onClick="woops" />;
       }
     }
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Example />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Example />);
+    });
+    assertConsoleErrorDev([
       'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
         '    in div (at **)\n' +
         '    in Example (at **)',
-    );
+    ]);
   });
 
   it('should warn with a special message for `false` event listeners', () => {
@@ -974,17 +978,16 @@ describe('ReactDOMFiber', () => {
         return <div onClick={false} />;
       }
     }
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Example />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Example />);
+    });
+    assertConsoleErrorDev([
       'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
         'If you used to conditionally omit it with onClick={condition && value}, ' +
         'pass onClick={condition ? value : undefined} instead.\n' +
         '    in div (at **)\n' +
         '    in Example (at **)',
-    );
+    ]);
   });
 
   it('should not update event handlers until commit', async () => {

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
index 9784e4f849..87cc136530 100644
--- a/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
@@ -751,7 +751,6 @@ describe('ReactDOMFiber', () => {
         '    in Parent (at **)',
       'Component uses the legacy contextTypes API which will soon be removed. ' +
         'Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\n' +
-        (gate('enableOwnerStacks') ? '' : '    in Component (at **)\n') +
         '    in Parent (at **)',
     ]);
     expect(container.innerHTML).toBe('');

