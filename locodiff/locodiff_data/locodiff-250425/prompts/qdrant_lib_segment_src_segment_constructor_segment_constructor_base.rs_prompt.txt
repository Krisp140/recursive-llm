# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/segment_constructor/segment_constructor_base.rs

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
new file mode 100644
index 000000000..8e4a6f562
--- /dev/null
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -0,0 +1,154 @@
+use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
+use crate::index::hnsw_index::hnsw::HNSWIndex;
+use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
+use crate::index::struct_payload_index::StructPayloadIndex;
+use crate::index::{PayloadIndex, VectorIndex};
+use crate::payload_storage::query_checker::SimpleConditionChecker;
+use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
+use crate::segment::{Segment, SEGMENT_STATE_FILE};
+use crate::types::{
+    Indexes, PayloadIndexType, SegmentConfig, SegmentState, SegmentType, SeqNumberType, StorageType,
+};
+use crate::vector_storage::memmap_vector_storage::MemmapVectorStorage;
+use crate::vector_storage::simple_vector_storage::SimpleVectorStorage;
+use crate::vector_storage::VectorStorage;
+use atomic_refcell::AtomicRefCell;
+use std::fs::{create_dir_all, File};
+use std::io::Read;
+use std::path::Path;
+use std::sync::{Arc, Mutex};
+use uuid::Uuid;
+
+fn sp<T>(t: T) -> Arc<AtomicRefCell<T>> {
+    Arc::new(AtomicRefCell::new(t))
+}
+
+fn create_segment(
+    version: SeqNumberType,
+    segment_path: &Path,
+    config: &SegmentConfig,
+) -> OperationResult<Segment> {
+    let mapper_path = segment_path.join("id_mapper");
+    let payload_storage_path = segment_path.join("payload_storage");
+    let payload_index_path = segment_path.join("payload_index");
+    let vector_storage_path = segment_path.join("vector_storage");
+    let vector_index_path = segment_path.join("vector_index");
+
+    let id_mapper = sp(SimpleIdMapper::open(mapper_path.as_path())?);
+
+    let vector_storage: Arc<AtomicRefCell<dyn VectorStorage>> = match config.storage_type {
+        StorageType::InMemory => sp(SimpleVectorStorage::open(
+            vector_storage_path.as_path(),
+            config.vector_size,
+            config.distance,
+        )?),
+        StorageType::Mmap => sp(MemmapVectorStorage::open(
+            vector_storage_path.as_path(),
+            config.vector_size,
+            config.distance,
+        )?),
+    };
+
+    let payload_storage = sp(SimplePayloadStorage::open(payload_storage_path.as_path())?);
+
+    let condition_checker = sp(SimpleConditionChecker::new(
+        payload_storage.clone(),
+        id_mapper.clone(),
+    ));
+
+    let payload_index: Arc<AtomicRefCell<dyn PayloadIndex>> =
+        match config.payload_index.unwrap_or_default() {
+            PayloadIndexType::Plain => sp(PlainPayloadIndex::open(
+                condition_checker.clone(),
+                vector_storage.clone(),
+                &payload_index_path,
+            )?),
+            PayloadIndexType::Struct => sp(StructPayloadIndex::open(
+                condition_checker.clone(),
+                vector_storage.clone(),
+                payload_storage.clone(),
+                id_mapper.clone(),
+                &payload_index_path,
+            )?),
+        };
+
+    let vector_index: Arc<AtomicRefCell<dyn VectorIndex>> = match config.index {
+        Indexes::Plain { .. } => sp(PlainIndex::new(
+            vector_storage.clone(),
+            payload_index.clone(),
+        )),
+        Indexes::Hnsw(hnsw_config) => sp(HNSWIndex::open(
+            &vector_index_path,
+            condition_checker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+            hnsw_config,
+        )?),
+    };
+
+    let segment_type = match config.index {
+        Indexes::Plain { .. } => match config.payload_index.unwrap_or_default() {
+            PayloadIndexType::Plain => SegmentType::Plain,
+            PayloadIndexType::Struct => SegmentType::Indexed,
+        },
+        Indexes::Hnsw { .. } => SegmentType::Indexed,
+    };
+
+    let appendable_flag =
+        segment_type == SegmentType::Plain {} && config.storage_type == StorageType::InMemory;
+
+    Ok(Segment {
+        version,
+        persisted_version: Arc::new(Mutex::new(version)),
+        current_path: segment_path.to_owned(),
+        id_mapper,
+        vector_storage,
+        payload_storage,
+        payload_index,
+        condition_checker,
+        vector_index,
+        appendable_flag,
+        segment_type,
+        segment_config: config.clone(),
+    })
+}
+
+pub fn load_segment(path: &Path) -> OperationResult<Segment> {
+    let segment_config_path = path.join(SEGMENT_STATE_FILE);
+    let mut contents = String::new();
+
+    let mut file = File::open(segment_config_path)?;
+    file.read_to_string(&mut contents)?;
+
+    let segment_state: SegmentState =
+        serde_json::from_str(&contents).map_err(|err| OperationError::ServiceError {
+            description: format!(
+                "Failed to read segment {}. Error: {}",
+                path.to_str().unwrap(),
+                err
+            ),
+        })?;
+
+    create_segment(segment_state.version, path, &segment_state.config)
+}
+
+/// Build segment instance using given configuration.
+/// Builder will generate folder for the segment and store all segment information inside it.
+///
+/// # Arguments
+///
+/// * `path` - A path to collection. Segment folder will be created in this directory
+/// * `config` - Segment configuration
+///
+///
+pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Segment> {
+    let segment_path = path.join(Uuid::new_v4().to_string());
+
+    create_dir_all(&segment_path)?;
+
+    let segment = create_segment(0, segment_path.as_path(), config)?;
+    segment.save_current_state()?;
+
+    Ok(segment)
+}

commit f3e8194310af69b13f67317556aa8cae77712536
Author: Alexander Galibey <48586936+galibey@users.noreply.github.com>
Date:   Tue Aug 3 11:35:55 2021 +0300

    Remove AtomicRefCell wrapper for condition checker (#84)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 8e4a6f562..783342e5d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -52,7 +52,7 @@ fn create_segment(
 
     let payload_storage = sp(SimplePayloadStorage::open(payload_storage_path.as_path())?);
 
-    let condition_checker = sp(SimpleConditionChecker::new(
+    let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
         id_mapper.clone(),
     ));

commit bf3d8c25753188b4ca5e69a13c7f26e3c383f05b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Oct 24 18:10:39 2021 +0200

    data consistency fixes and updates (#112)
    
    * update segment version after completed update only
    
    * more stable updates: check pre-existing points on update, fail recovery, WAL proper ack. check_unprocessed_points WIP
    
    * switch to async channel
    
    * perform update operations in a separate thread (#111)
    
    * perform update operations in a separate thread
    
    * ordered sending update signal
    
    * locate a segment merging versioning bug
    
    * rename id_mapper -> id_tracker
    
    * per-record versioning
    
    * clippy fixes
    
    * cargo fmt
    
    * rm limit of open files
    
    * fail recovery test
    
    * cargo fmt
    
    * wait for worker stops befor dropping the runtime

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 783342e5d..4dbc24cc6 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,5 +1,5 @@
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
+use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
 use crate::index::struct_payload_index::StructPayloadIndex;
@@ -29,13 +29,13 @@ fn create_segment(
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
-    let mapper_path = segment_path.join("id_mapper");
+    let tracker_path = segment_path.join("id_tracker");
     let payload_storage_path = segment_path.join("payload_storage");
     let payload_index_path = segment_path.join("payload_index");
     let vector_storage_path = segment_path.join("vector_storage");
     let vector_index_path = segment_path.join("vector_index");
 
-    let id_mapper = sp(SimpleIdMapper::open(mapper_path.as_path())?);
+    let id_tracker = sp(SimpleIdTracker::open(tracker_path.as_path())?);
 
     let vector_storage: Arc<AtomicRefCell<dyn VectorStorage>> = match config.storage_type {
         StorageType::InMemory => sp(SimpleVectorStorage::open(
@@ -54,7 +54,7 @@ fn create_segment(
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
-        id_mapper.clone(),
+        id_tracker.clone(),
     ));
 
     let payload_index: Arc<AtomicRefCell<dyn PayloadIndex>> =
@@ -68,7 +68,7 @@ fn create_segment(
                 condition_checker.clone(),
                 vector_storage.clone(),
                 payload_storage.clone(),
-                id_mapper.clone(),
+                id_tracker.clone(),
                 &payload_index_path,
             )?),
         };
@@ -102,7 +102,7 @@ fn create_segment(
         version,
         persisted_version: Arc::new(Mutex::new(version)),
         current_path: segment_path.to_owned(),
-        id_mapper,
+        id_tracker,
         vector_storage,
         payload_storage,
         payload_index,
@@ -111,6 +111,7 @@ fn create_segment(
         appendable_flag,
         segment_type,
         segment_config: config.clone(),
+        error_status: None,
     })
 }
 

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 4dbc24cc6..930861afc 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -35,22 +35,22 @@ fn create_segment(
     let vector_storage_path = segment_path.join("vector_storage");
     let vector_index_path = segment_path.join("vector_index");
 
-    let id_tracker = sp(SimpleIdTracker::open(tracker_path.as_path())?);
+    let id_tracker = sp(SimpleIdTracker::open(&tracker_path)?);
 
     let vector_storage: Arc<AtomicRefCell<dyn VectorStorage>> = match config.storage_type {
         StorageType::InMemory => sp(SimpleVectorStorage::open(
-            vector_storage_path.as_path(),
+            &vector_storage_path,
             config.vector_size,
             config.distance,
         )?),
         StorageType::Mmap => sp(MemmapVectorStorage::open(
-            vector_storage_path.as_path(),
+            &vector_storage_path,
             config.vector_size,
             config.distance,
         )?),
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(payload_storage_path.as_path())?);
+    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?);
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
@@ -148,7 +148,7 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
 
     create_dir_all(&segment_path)?;
 
-    let segment = create_segment(0, segment_path.as_path(), config)?;
+    let segment = create_segment(0, &segment_path, config)?;
     segment.save_current_state()?;
 
     Ok(segment)

commit bcaa160ad8658fa4052aae4a854686379b1e35d7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 31 11:38:33 2021 +0300

    Remove dyn Metric from vector storage and use generics (#163)
    
    * Remove dyn Metric from vector storage and use generics
    
    * upd benchmark code
    
    * fix benchmark usage
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 930861afc..6d10a3add 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -10,8 +10,8 @@ use crate::segment::{Segment, SEGMENT_STATE_FILE};
 use crate::types::{
     Indexes, PayloadIndexType, SegmentConfig, SegmentState, SegmentType, SeqNumberType, StorageType,
 };
-use crate::vector_storage::memmap_vector_storage::MemmapVectorStorage;
-use crate::vector_storage::simple_vector_storage::SimpleVectorStorage;
+use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
+use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorage;
 use atomic_refcell::AtomicRefCell;
 use std::fs::{create_dir_all, File};
@@ -38,16 +38,12 @@ fn create_segment(
     let id_tracker = sp(SimpleIdTracker::open(&tracker_path)?);
 
     let vector_storage: Arc<AtomicRefCell<dyn VectorStorage>> = match config.storage_type {
-        StorageType::InMemory => sp(SimpleVectorStorage::open(
-            &vector_storage_path,
-            config.vector_size,
-            config.distance,
-        )?),
-        StorageType::Mmap => sp(MemmapVectorStorage::open(
-            &vector_storage_path,
-            config.vector_size,
-            config.distance,
-        )?),
+        StorageType::InMemory => {
+            open_simple_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
+        }
+        StorageType::Mmap => {
+            open_memmap_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
+        }
     };
 
     let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?);

commit ee461ce0a6cc031e8289bc7a238bb2e807e85b20
Author: Prokudin Alexander <prok20@inbox.ru>
Date:   Tue Jan 18 01:33:26 2022 +0300

    Extend clippy to workspace and fix some warnings (#199)
    
    * Fix clippy in linting workflow
    
    * Add toolchain override flag
    
    * Add components to toolchain installation explicitly
    
    * Add --workspace flag to clippy to check all packages
    
    * Remove unnecessary clones
    
    * remove redundant .clone() calls
    
    * fix wrong arguments order in tests (typo)
    
    * Fix vec! macro usage in test
    
    * Correct redundant assert! usages
    
    * Provide a quick fix for 'unused' test function lint
    
    * fix unsound Send + Sync
    
    * fix clippy complains
    
    * fmt
    
    * fix clippy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 6d10a3add..76a544822 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -3,7 +3,7 @@ use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::{PayloadIndex, VectorIndex};
+use crate::index::{PayloadIndexSS, VectorIndexSS};
 use crate::payload_storage::query_checker::SimpleConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SEGMENT_STATE_FILE};
@@ -12,7 +12,7 @@ use crate::types::{
 };
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use crate::vector_storage::VectorStorage;
+use crate::vector_storage::VectorStorageSS;
 use atomic_refcell::AtomicRefCell;
 use std::fs::{create_dir_all, File};
 use std::io::Read;
@@ -37,7 +37,7 @@ fn create_segment(
 
     let id_tracker = sp(SimpleIdTracker::open(&tracker_path)?);
 
-    let vector_storage: Arc<AtomicRefCell<dyn VectorStorage>> = match config.storage_type {
+    let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
         StorageType::InMemory => {
             open_simple_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
         }
@@ -53,7 +53,7 @@ fn create_segment(
         id_tracker.clone(),
     ));
 
-    let payload_index: Arc<AtomicRefCell<dyn PayloadIndex>> =
+    let payload_index: Arc<AtomicRefCell<PayloadIndexSS>> =
         match config.payload_index.unwrap_or_default() {
             PayloadIndexType::Plain => sp(PlainPayloadIndex::open(
                 condition_checker.clone(),
@@ -69,7 +69,7 @@ fn create_segment(
             )?),
         };
 
-    let vector_index: Arc<AtomicRefCell<dyn VectorIndex>> = match config.index {
+    let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
         Indexes::Plain { .. } => sp(PlainIndex::new(
             vector_storage.clone(),
             payload_index.clone(),

commit 4483ea0d60bb4cf97df1267de6299556674d83fa
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Wed Feb 9 11:46:01 2022 -0300

    fix: #101 Payload type consistency is not enforced.

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 76a544822..050a092ba 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -5,6 +5,7 @@ use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndexSS, VectorIndexSS};
 use crate::payload_storage::query_checker::SimpleConditionChecker;
+use crate::payload_storage::schema_storage::SchemaStorage;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SEGMENT_STATE_FILE};
 use crate::types::{
@@ -28,6 +29,7 @@ fn create_segment(
     version: SeqNumberType,
     segment_path: &Path,
     config: &SegmentConfig,
+    schema_storage: Arc<SchemaStorage>,
 ) -> OperationResult<Segment> {
     let tracker_path = segment_path.join("id_tracker");
     let payload_storage_path = segment_path.join("payload_storage");
@@ -46,7 +48,10 @@ fn create_segment(
         }
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?);
+    let payload_storage = sp(SimplePayloadStorage::open(
+        &payload_storage_path,
+        schema_storage,
+    )?);
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
@@ -111,7 +116,7 @@ fn create_segment(
     })
 }
 
-pub fn load_segment(path: &Path) -> OperationResult<Segment> {
+pub fn load_segment(path: &Path, schema_storage: Arc<SchemaStorage>) -> OperationResult<Segment> {
     let segment_config_path = path.join(SEGMENT_STATE_FILE);
     let mut contents = String::new();
 
@@ -127,7 +132,12 @@ pub fn load_segment(path: &Path) -> OperationResult<Segment> {
             ),
         })?;
 
-    create_segment(segment_state.version, path, &segment_state.config)
+    create_segment(
+        segment_state.version,
+        path,
+        &segment_state.config,
+        schema_storage,
+    )
 }
 
 /// Build segment instance using given configuration.
@@ -139,12 +149,16 @@ pub fn load_segment(path: &Path) -> OperationResult<Segment> {
 /// * `config` - Segment configuration
 ///
 ///
-pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Segment> {
+pub fn build_segment(
+    path: &Path,
+    config: &SegmentConfig,
+    schema_storage: Arc<SchemaStorage>,
+) -> OperationResult<Segment> {
     let segment_path = path.join(Uuid::new_v4().to_string());
 
     create_dir_all(&segment_path)?;
 
-    let segment = create_segment(0, &segment_path, config)?;
+    let segment = create_segment(0, &segment_path, config, schema_storage)?;
     segment.save_current_state()?;
 
     Ok(segment)

commit e45379e4384062e92ee1c9be82c250047464c9ef
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 16 09:59:11 2022 +0100

    Better optimizer error reporting + small bug fixes (#316)
    
    * optimizer error reporting, decouple data removing, optimizator fix
    
    * fmt
    
    * fmt + clippy
    
    * update openapi

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 050a092ba..0e1ff230f 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -123,14 +123,13 @@ pub fn load_segment(path: &Path, schema_storage: Arc<SchemaStorage>) -> Operatio
     let mut file = File::open(segment_config_path)?;
     file.read_to_string(&mut contents)?;
 
-    let segment_state: SegmentState =
-        serde_json::from_str(&contents).map_err(|err| OperationError::ServiceError {
-            description: format!(
-                "Failed to read segment {}. Error: {}",
-                path.to_str().unwrap(),
-                err
-            ),
-        })?;
+    let segment_state: SegmentState = serde_json::from_str(&contents).map_err(|err| {
+        OperationError::service_error(&format!(
+            "Failed to read segment {}. Error: {}",
+            path.to_str().unwrap(),
+            err
+        ))
+    })?;
 
     create_segment(
         segment_state.version,

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 0e1ff230f..ea2f1c10c 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -5,7 +5,6 @@ use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndexSS, VectorIndexSS};
 use crate::payload_storage::query_checker::SimpleConditionChecker;
-use crate::payload_storage::schema_storage::SchemaStorage;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SEGMENT_STATE_FILE};
 use crate::types::{
@@ -29,7 +28,6 @@ fn create_segment(
     version: SeqNumberType,
     segment_path: &Path,
     config: &SegmentConfig,
-    schema_storage: Arc<SchemaStorage>,
 ) -> OperationResult<Segment> {
     let tracker_path = segment_path.join("id_tracker");
     let payload_storage_path = segment_path.join("payload_storage");
@@ -48,10 +46,7 @@ fn create_segment(
         }
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(
-        &payload_storage_path,
-        schema_storage,
-    )?);
+    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?);
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
@@ -116,7 +111,7 @@ fn create_segment(
     })
 }
 
-pub fn load_segment(path: &Path, schema_storage: Arc<SchemaStorage>) -> OperationResult<Segment> {
+pub fn load_segment(path: &Path) -> OperationResult<Segment> {
     let segment_config_path = path.join(SEGMENT_STATE_FILE);
     let mut contents = String::new();
 
@@ -131,12 +126,7 @@ pub fn load_segment(path: &Path, schema_storage: Arc<SchemaStorage>) -> Operatio
         ))
     })?;
 
-    create_segment(
-        segment_state.version,
-        path,
-        &segment_state.config,
-        schema_storage,
-    )
+    create_segment(segment_state.version, path, &segment_state.config)
 }
 
 /// Build segment instance using given configuration.
@@ -148,16 +138,12 @@ pub fn load_segment(path: &Path, schema_storage: Arc<SchemaStorage>) -> Operatio
 /// * `config` - Segment configuration
 ///
 ///
-pub fn build_segment(
-    path: &Path,
-    config: &SegmentConfig,
-    schema_storage: Arc<SchemaStorage>,
-) -> OperationResult<Segment> {
+pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Segment> {
     let segment_path = path.join(Uuid::new_v4().to_string());
 
     create_dir_all(&segment_path)?;
 
-    let segment = create_segment(0, &segment_path, config, schema_storage)?;
+    let segment = create_segment(0, &segment_path, config)?;
     segment.save_current_state()?;
 
     Ok(segment)

commit c29c9a46d46c22d3210e61cc3a111747ace31fb1
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Thu Mar 31 08:57:18 2022 -0300

    [json storage] Filtering context (#413)
    
    * [WIP] add a basic filtering context scaffold
    
    * add PlainFilterContext and StructFilterContext

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index ea2f1c10c..12eb45482 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -76,7 +76,6 @@ fn create_segment(
         )),
         Indexes::Hnsw(hnsw_config) => sp(HNSWIndex::open(
             &vector_index_path,
-            condition_checker.clone(),
             vector_storage.clone(),
             payload_index.clone(),
             hnsw_config,

commit ef67a2ec59180ca599b0c61cc957c45a56454410
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:43:02 2022 +0200

    Condition search benchmark (#435)
    
    * decouple payload index and vector storage
    
    * wip: test fixtures
    
    * conditional search benchmark
    
    * fmt
    
    * use arc iterator for filtered queries
    
    * fmt
    
    * enable all benches
    
    * fix warn
    
    * upd tests
    
    * fmt
    
    * Update lib/segment/src/fixtures/payload_context_fixture.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 12eb45482..080928bc3 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -57,12 +57,12 @@ fn create_segment(
         match config.payload_index.unwrap_or_default() {
             PayloadIndexType::Plain => sp(PlainPayloadIndex::open(
                 condition_checker.clone(),
-                vector_storage.clone(),
+                id_tracker.clone(),
                 &payload_index_path,
             )?),
             PayloadIndexType::Struct => sp(StructPayloadIndex::open(
                 condition_checker.clone(),
-                vector_storage.clone(),
+                id_tracker.clone(),
                 payload_storage.clone(),
                 id_tracker.clone(),
                 &payload_index_path,

commit bc6df8bd12327ea3a88aecf94a0a2a26b3b70506
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 19 16:04:55 2022 +0200

    Better use of column index (#461)
    
    * fmt
    
    * remove redundent condition checker
    
    * remove condition_checker from test
    
    * fmt
    
    * enum_dispatch for payload storage
    
    * rm unused imports
    
    * fmt
    
    * replace enum_dispatch with manual stuff
    
    * fmt
    
    * filter optiizer
    
    * cargo fix
    
    * fmt
    
    * refactor callback approach to payload checking
    
    * cargo fix
    
    * cargo fix
    
    * fix
    
    * fmt
    
    * more filtering condition random fixture types
    
    * clippy
    
    * fmt
    
    * restore lost value counts test
    
    * Update lib/segment/src/index/query_optimization/optimized_filter.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 080928bc3..2ddce6e93 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -46,7 +46,7 @@ fn create_segment(
         }
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?);
+    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?.into());
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
@@ -61,7 +61,6 @@ fn create_segment(
                 &payload_index_path,
             )?),
             PayloadIndexType::Struct => sp(StructPayloadIndex::open(
-                condition_checker.clone(),
                 id_tracker.clone(),
                 payload_storage.clone(),
                 id_tracker.clone(),

commit effb79733d8936b5a1afb4ab45dba4b355f75999
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri May 13 17:06:07 2022 +0400

    Unite rocksdb of segment (#585)
    
    unite rocksdb for segment

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 2ddce6e93..382c2b661 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,3 +1,4 @@
+use crate::common::rocksdb_operations::open_db;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
@@ -29,24 +30,24 @@ fn create_segment(
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
-    let tracker_path = segment_path.join("id_tracker");
-    let payload_storage_path = segment_path.join("payload_storage");
+    let database = open_db(segment_path)?;
+
     let payload_index_path = segment_path.join("payload_index");
     let vector_storage_path = segment_path.join("vector_storage");
     let vector_index_path = segment_path.join("vector_index");
 
-    let id_tracker = sp(SimpleIdTracker::open(&tracker_path)?);
+    let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
 
     let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
         StorageType::InMemory => {
-            open_simple_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
+            open_simple_vector_storage(database.clone(), config.vector_size, config.distance)?
         }
         StorageType::Mmap => {
             open_memmap_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
         }
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(&payload_storage_path)?.into());
+    let payload_storage = sp(SimplePayloadStorage::open(database.clone())?.into());
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),
@@ -106,6 +107,7 @@ fn create_segment(
         segment_type,
         segment_config: config.clone(),
         error_status: None,
+        database,
     })
 }
 

commit 54a66844c512c312d69120fa51e0f4eb8493213f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue May 31 14:16:49 2022 +0200

    add version to the segment (#640)
    
    * add version to the segment
    
    * add collection version saving
    
    * Update lib/collection/src/lib.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * remove self
    
    * add comment
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 382c2b661..c085322e0 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,4 +1,5 @@
 use crate::common::rocksdb_operations::open_db;
+use crate::common::version::StorageVersion;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
@@ -7,7 +8,7 @@ use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndexSS, VectorIndexSS};
 use crate::payload_storage::query_checker::SimpleConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-use crate::segment::{Segment, SEGMENT_STATE_FILE};
+use crate::segment::{Segment, SegmentVersion, SEGMENT_STATE_FILE};
 use crate::types::{
     Indexes, PayloadIndexType, SegmentConfig, SegmentState, SegmentType, SeqNumberType, StorageType,
 };
@@ -15,6 +16,7 @@ use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorageSS;
 use atomic_refcell::AtomicRefCell;
+use log::info;
 use std::fs::{create_dir_all, File};
 use std::io::Read;
 use std::path::Path;
@@ -112,6 +114,19 @@ fn create_segment(
 }
 
 pub fn load_segment(path: &Path) -> OperationResult<Segment> {
+    let stored_version_opt = SegmentVersion::load(path)?;
+
+    if let Some(stored_version) = stored_version_opt {
+        if stored_version != SegmentVersion::current() {
+            info!(
+                "Migrating segment {} -> {}",
+                stored_version,
+                SegmentVersion::current()
+            );
+            SegmentVersion::save(path)?
+        }
+    }
+
     let segment_config_path = path.join(SEGMENT_STATE_FILE);
     let mut contents = String::new();
 
@@ -146,5 +161,7 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
     let segment = create_segment(0, &segment_path, config)?;
     segment.save_current_state()?;
 
+    SegmentVersion::save(&segment_path)?;
+
     Ok(segment)
 }

commit 1b458780eb196ebbbd7fb1f6c5d85ce3b15adb64
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 1 17:23:34 2022 +0200

    On disk payload storage (#634)
    
    * implement on-disk payload storage
    
    * fmt + clippy
    
    * config param for on-disk payload storage
    
    * upd openapi definitions
    
    * add integration test with on-disk payload
    
    * fix clippy
    
    * review fixes
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index c085322e0..57982476d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -6,11 +6,13 @@ use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndexSS, VectorIndexSS};
+use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::query_checker::SimpleConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, SEGMENT_STATE_FILE};
 use crate::types::{
-    Indexes, PayloadIndexType, SegmentConfig, SegmentState, SegmentType, SeqNumberType, StorageType,
+    Indexes, PayloadIndexType, PayloadStorageType, SegmentConfig, SegmentState, SegmentType,
+    SeqNumberType, StorageType,
 };
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
@@ -49,7 +51,10 @@ fn create_segment(
         }
     };
 
-    let payload_storage = sp(SimplePayloadStorage::open(database.clone())?.into());
+    let payload_storage = match config.payload_storage_type {
+        PayloadStorageType::InMemory => sp(SimplePayloadStorage::open(database.clone())?.into()),
+        PayloadStorageType::OnDisk => sp(OnDiskPayloadStorage::open(database.clone())?.into()),
+    };
 
     let condition_checker = Arc::new(SimpleConditionChecker::new(
         payload_storage.clone(),

commit c15981092ac33c7dde9541ab4a2df558e6abe4e6
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Jun 6 12:14:20 2022 -0300

    [WIP] [real-time index] Implement payloadstorage for structpayloadindex (#642)
    
    * [real-time index] Extend FieldIndex enum and StructPayloadIndex with method from PayloadStorage
    
    * [real-time index] add missing remove_point methods
    
    * [real-time index] add new index to FieldIndex enum
    
    * fix compile
    
    * are you happy fmt
    
    * merge load and remove
    
    * fix test generics
    
    * decrement points count
    
    * remove from histogram
    
    * simplify histogram usage
    
    * [real-time index] remove old tests and fix clippy warnings
    
    * histogram: method to derive range by size (#657)
    
    * [real-time index] add histogram based payload_blocks implementation.
    
    * payload blocks
    
    * fmt
    
    * clippy
    
    * [real-time index] refactor Segment to use PayloadIndex instead of PayloadStorage.
    
    * fix tests
    
    * fmt
    
    * clippy
    
    * rename indexes
    
    * remove redundent params
    
    * add struct payload deletion test + fix delete payload in map index
    
    * remove payload threshold
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 57982476d..4cfd403ab 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -3,16 +3,15 @@ use crate::common::version::StorageVersion;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
-use crate::index::plain_payload_index::{PlainIndex, PlainPayloadIndex};
+use crate::index::plain_payload_index::PlainIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::{PayloadIndexSS, VectorIndexSS};
+use crate::index::VectorIndexSS;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
-use crate::payload_storage::query_checker::SimpleConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, SEGMENT_STATE_FILE};
 use crate::types::{
-    Indexes, PayloadIndexType, PayloadStorageType, SegmentConfig, SegmentState, SegmentType,
-    SeqNumberType, StorageType,
+    Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
+    StorageType,
 };
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
@@ -56,25 +55,12 @@ fn create_segment(
         PayloadStorageType::OnDisk => sp(OnDiskPayloadStorage::open(database.clone())?.into()),
     };
 
-    let condition_checker = Arc::new(SimpleConditionChecker::new(
-        payload_storage.clone(),
+    let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         id_tracker.clone(),
-    ));
-
-    let payload_index: Arc<AtomicRefCell<PayloadIndexSS>> =
-        match config.payload_index.unwrap_or_default() {
-            PayloadIndexType::Plain => sp(PlainPayloadIndex::open(
-                condition_checker.clone(),
-                id_tracker.clone(),
-                &payload_index_path,
-            )?),
-            PayloadIndexType::Struct => sp(StructPayloadIndex::open(
-                id_tracker.clone(),
-                payload_storage.clone(),
-                id_tracker.clone(),
-                &payload_index_path,
-            )?),
-        };
+        payload_storage,
+        id_tracker.clone(),
+        &payload_index_path,
+    )?);
 
     let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
         Indexes::Plain { .. } => sp(PlainIndex::new(
@@ -90,10 +76,7 @@ fn create_segment(
     };
 
     let segment_type = match config.index {
-        Indexes::Plain { .. } => match config.payload_index.unwrap_or_default() {
-            PayloadIndexType::Plain => SegmentType::Plain,
-            PayloadIndexType::Struct => SegmentType::Indexed,
-        },
+        Indexes::Plain { .. } => SegmentType::Plain,
         Indexes::Hnsw { .. } => SegmentType::Indexed,
     };
 
@@ -106,9 +89,7 @@ fn create_segment(
         current_path: segment_path.to_owned(),
         id_tracker,
         vector_storage,
-        payload_storage,
         payload_index,
-        condition_checker,
         vector_index,
         appendable_flag,
         segment_type,

commit 850e937c2a883e87622b43b3603be9ee1aaf02af
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jun 27 15:17:09 2022 +0200

    Storage points tracking refactoring (#750)
    
    * segment refactoring
    
    * rm points iterator
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 4cfd403ab..e194aba25 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -56,7 +56,6 @@ fn create_segment(
     };
 
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
-        id_tracker.clone(),
         payload_storage,
         id_tracker.clone(),
         &payload_index_path,

commit ef3c6c5e15a4be6af28f92325362e82a227fb937
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Thu Jul 14 20:27:53 2022 +0300

    Fair hash ring (#816)
    
    * Fair hash ring
    
    * Python test processes removal fix

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e194aba25..e951318b0 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -99,17 +99,14 @@ fn create_segment(
 }
 
 pub fn load_segment(path: &Path) -> OperationResult<Segment> {
-    let stored_version_opt = SegmentVersion::load(path)?;
-
-    if let Some(stored_version) = stored_version_opt {
-        if stored_version != SegmentVersion::current() {
-            info!(
-                "Migrating segment {} -> {}",
-                stored_version,
-                SegmentVersion::current()
-            );
-            SegmentVersion::save(path)?
-        }
+    let stored_version = SegmentVersion::load(path)?;
+    if stored_version != SegmentVersion::current() {
+        info!(
+            "Migrating segment {} -> {}",
+            stored_version,
+            SegmentVersion::current()
+        );
+        SegmentVersion::save(path)?
     }
 
     let segment_config_path = path.join(SEGMENT_STATE_FILE);

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e951318b0..0b95f58ac 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,3 +1,12 @@
+use std::fs::{create_dir_all, File};
+use std::io::Read;
+use std::path::Path;
+use std::sync::{Arc, Mutex};
+
+use atomic_refcell::AtomicRefCell;
+use log::info;
+use uuid::Uuid;
+
 use crate::common::rocksdb_operations::open_db;
 use crate::common::version::StorageVersion;
 use crate::entry::entry_point::{OperationError, OperationResult};
@@ -16,13 +25,6 @@ use crate::types::{
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorageSS;
-use atomic_refcell::AtomicRefCell;
-use log::info;
-use std::fs::{create_dir_all, File};
-use std::io::Read;
-use std::path::Path;
-use std::sync::{Arc, Mutex};
-use uuid::Uuid;
 
 fn sp<T>(t: T) -> Arc<AtomicRefCell<T>> {
     Arc::new(AtomicRefCell::new(t))

commit 70317d1bbc16f2bc51e8aee0497bd3fde02c53a0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 3 17:39:13 2022 +0200

    check for segment integrity by checking the version, skip on failure (#904)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 0b95f58ac..ef5f3ab9c 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -100,7 +100,17 @@ fn create_segment(
     })
 }
 
-pub fn load_segment(path: &Path) -> OperationResult<Segment> {
+pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
+    if !SegmentVersion::check_exists(path) {
+        // Assume segment was not properly saved.
+        // Server might have crashed before saving the segment fully.
+        log::warn!(
+            "Segment version file not found, skipping: {}",
+            path.display()
+        );
+        return Ok(None);
+    }
+
     let stored_version = SegmentVersion::load(path)?;
     if stored_version != SegmentVersion::current() {
         info!(
@@ -125,7 +135,11 @@ pub fn load_segment(path: &Path) -> OperationResult<Segment> {
         ))
     })?;
 
-    create_segment(segment_state.version, path, &segment_state.config)
+    Ok(Some(create_segment(
+        segment_state.version,
+        path,
+        &segment_state.config,
+    )?))
 }
 
 /// Build segment instance using given configuration.
@@ -145,6 +159,8 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
     let segment = create_segment(0, &segment_path, config)?;
     segment.save_current_state()?;
 
+    // Version is the last file to save, as it will be used to check if segment was built correctly.
+    // If it is not saved, segment will be skipped.
     SegmentVersion::save(&segment_path)?;
 
     Ok(segment)

commit f357bd5d9bc8cdc05915111419894d4f25512d83
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 15 13:47:52 2022 +0400

    Allow to flush segment in separate thread (#927)
    
    * allow to flush segment in separate thread
    
    * flush as separate function (#928)
    
    * flush as separate function
    
    * review suggestion
    
    * reduce locks during vector scoring
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * don't run background flush twice
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * increase flush interval
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * are you happy fmt
    
    * test background flush
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index ef5f3ab9c..a0f8444e3 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,10 +1,11 @@
 use std::fs::{create_dir_all, File};
 use std::io::Read;
 use std::path::Path;
-use std::sync::{Arc, Mutex};
+use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use log::info;
+use parking_lot::Mutex;
 use uuid::Uuid;
 
 use crate::common::rocksdb_operations::open_db;
@@ -97,6 +98,7 @@ fn create_segment(
         segment_config: config.clone(),
         error_status: None,
         database,
+        flush_thread: Mutex::new(None),
     })
 }
 

commit f9fb0777a0fa67f3b297140493a3c71a4ef42064
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 22 10:41:08 2022 +0300

    Wrap rocksdb column usages (#951)
    
    * wrap rocksdb column usages
    
    * remove obsolete comments
    
    * are you happy clippy

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index a0f8444e3..e5a16aaae 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -8,7 +8,7 @@ use log::info;
 use parking_lot::Mutex;
 use uuid::Uuid;
 
-use crate::common::rocksdb_operations::open_db;
+use crate::common::rocksdb_wrapper::open_db;
 use crate::common::version::StorageVersion;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
@@ -36,7 +36,8 @@ fn create_segment(
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
-    let database = open_db(segment_path)?;
+    let database = open_db(segment_path)
+        .map_err(|err| OperationError::service_error(&format!("RocksDB open error: {}", err)))?;
 
     let payload_index_path = segment_path.join("payload_index");
     let vector_storage_path = segment_path.join("vector_storage");

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e5a16aaae..6af387364 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,3 +1,4 @@
+use std::collections::HashMap;
 use std::fs::{create_dir_all, File};
 use std::io::Read;
 use std::path::Path;
@@ -6,10 +7,13 @@ use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use log::info;
 use parking_lot::Mutex;
+use semver::Version;
+use serde::Deserialize;
 use uuid::Uuid;
 
-use crate::common::rocksdb_wrapper::open_db;
+use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::common::version::StorageVersion;
+use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::index::hnsw_index::hnsw::HNSWIndex;
@@ -18,10 +22,10 @@ use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexSS;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-use crate::segment::{Segment, SegmentVersion, SEGMENT_STATE_FILE};
+use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
-    Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    StorageType,
+    Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
+    StorageType, VectorDataConfig,
 };
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
@@ -36,47 +40,80 @@ fn create_segment(
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
-    let database = open_db(segment_path)
-        .map_err(|err| OperationError::service_error(&format!("RocksDB open error: {}", err)))?;
-
-    let payload_index_path = segment_path.join("payload_index");
-    let vector_storage_path = segment_path.join("vector_storage");
-    let vector_index_path = segment_path.join("vector_index");
-
-    let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
-
-    let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
-        StorageType::InMemory => {
-            open_simple_vector_storage(database.clone(), config.vector_size, config.distance)?
-        }
-        StorageType::Mmap => {
-            open_memmap_vector_storage(&vector_storage_path, config.vector_size, config.distance)?
+    let get_vector_name_with_prefix = |prefix: &str, vector_name: &str| {
+        if !vector_name.is_empty() {
+            format!("{}-{}", prefix, vector_name)
+        } else {
+            prefix.to_owned()
         }
     };
+    let vector_db_names: Vec<String> = config
+        .vector_data
+        .iter()
+        .map(|(vector_name, _)| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
+        .collect();
+    let database = open_db(segment_path, &vector_db_names)
+        .map_err(|err| OperationError::service_error(&format!("RocksDB open error: {}", err)))?;
 
     let payload_storage = match config.payload_storage_type {
         PayloadStorageType::InMemory => sp(SimplePayloadStorage::open(database.clone())?.into()),
         PayloadStorageType::OnDisk => sp(OnDiskPayloadStorage::open(database.clone())?.into()),
     };
 
+    let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
+
+    let payload_index_path = segment_path.join("payload_index");
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage,
         id_tracker.clone(),
         &payload_index_path,
     )?);
 
-    let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
-        Indexes::Plain { .. } => sp(PlainIndex::new(
-            vector_storage.clone(),
-            payload_index.clone(),
-        )),
-        Indexes::Hnsw(hnsw_config) => sp(HNSWIndex::open(
-            &vector_index_path,
-            vector_storage.clone(),
-            payload_index.clone(),
-            hnsw_config,
-        )?),
-    };
+    let mut vector_data = HashMap::new();
+    for (vector_name, vector_config) in &config.vector_data {
+        let vector_storage_path =
+            segment_path.join(&get_vector_name_with_prefix("vector_storage", vector_name));
+        let vector_index_path =
+            segment_path.join(&get_vector_name_with_prefix("vector_index", vector_name));
+
+        let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
+            StorageType::InMemory => {
+                let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+                open_simple_vector_storage(
+                    database.clone(),
+                    &db_column_name,
+                    vector_config.size,
+                    vector_config.distance,
+                )?
+            }
+            StorageType::Mmap => open_memmap_vector_storage(
+                &vector_storage_path,
+                vector_config.size,
+                vector_config.distance,
+            )?,
+        };
+
+        let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
+            Indexes::Plain { .. } => sp(PlainIndex::new(
+                vector_storage.clone(),
+                payload_index.clone(),
+            )),
+            Indexes::Hnsw(hnsw_config) => sp(HNSWIndex::open(
+                &vector_index_path,
+                vector_storage.clone(),
+                payload_index.clone(),
+                hnsw_config,
+            )?),
+        };
+
+        vector_data.insert(
+            vector_name.to_owned(),
+            VectorData {
+                vector_storage,
+                vector_index,
+            },
+        );
+    }
 
     let segment_type = match config.index {
         Indexes::Plain { .. } => SegmentType::Plain,
@@ -91,11 +128,10 @@ fn create_segment(
         persisted_version: Arc::new(Mutex::new(version)),
         current_path: segment_path.to_owned(),
         id_tracker,
-        vector_storage,
-        payload_index,
-        vector_index,
-        appendable_flag,
+        vector_data,
         segment_type,
+        appendable_flag,
+        payload_index,
         segment_config: config.clone(),
         error_status: None,
         database,
@@ -114,29 +150,26 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
         return Ok(None);
     }
 
-    let stored_version = SegmentVersion::load(path)?;
-    if stored_version != SegmentVersion::current() {
-        info!(
-            "Migrating segment {} -> {}",
-            stored_version,
-            SegmentVersion::current()
-        );
-        SegmentVersion::save(path)?
-    }
+    let stored_version: Version = SegmentVersion::load(path)?.parse()?;
+    let app_version: Version = SegmentVersion::current().parse()?;
 
-    let segment_config_path = path.join(SEGMENT_STATE_FILE);
-    let mut contents = String::new();
+    if stored_version != app_version {
+        info!("Migrating segment {} -> {}", stored_version, app_version,);
 
-    let mut file = File::open(segment_config_path)?;
-    file.read_to_string(&mut contents)?;
+        if stored_version.minor == 3 {
+            let segment_state = load_segment_state_v3(path)?;
+            Segment::save_state(&segment_state, path)?;
+        } else {
+            return Err(OperationError::service_error(&format!(
+                "Segment version({}) is not compatible with current version({})",
+                stored_version, app_version
+            )));
+        }
 
-    let segment_state: SegmentState = serde_json::from_str(&contents).map_err(|err| {
-        OperationError::service_error(&format!(
-            "Failed to read segment {}. Error: {}",
-            path.to_str().unwrap(),
-            err
-        ))
-    })?;
+        SegmentVersion::save(path)?
+    }
+
+    let segment_state = Segment::load_state(path)?;
 
     Ok(Some(create_segment(
         segment_state.version,
@@ -168,3 +201,59 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
 
     Ok(segment)
 }
+
+fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
+    #[derive(Deserialize)]
+    #[serde(rename_all = "snake_case")]
+    pub struct ObsoleteSegmentState {
+        pub version: SeqNumberType,
+        pub config: ObsoleteSegmentConfig,
+    }
+
+    #[derive(Deserialize)]
+    #[serde(rename_all = "snake_case")]
+    pub struct ObsoleteSegmentConfig {
+        /// Size of a vectors used
+        pub vector_size: usize,
+        /// Type of distance function used for measuring distance between vectors
+        pub distance: Distance,
+        /// Type of index used for search
+        pub index: Indexes,
+        /// Type of vector storage
+        pub storage_type: StorageType,
+        /// Defines payload storage type
+        #[serde(default)]
+        pub payload_storage_type: PayloadStorageType,
+    }
+
+    let path = segment_path.join(SEGMENT_STATE_FILE);
+
+    let mut contents = String::new();
+
+    let mut file = File::open(&path)?;
+    file.read_to_string(&mut contents)?;
+
+    serde_json::from_str::<ObsoleteSegmentState>(&contents)
+        .map(|state| {
+            let vector_data = VectorDataConfig {
+                size: state.config.vector_size,
+                distance: state.config.distance,
+            };
+            SegmentState {
+                version: state.version,
+                config: SegmentConfig {
+                    vector_data: HashMap::from([(DEFAULT_VECTOR_NAME.to_owned(), vector_data)]),
+                    index: state.config.index,
+                    storage_type: state.config.storage_type,
+                    payload_storage_type: state.config.payload_storage_type,
+                },
+            }
+        })
+        .map_err(|err| {
+            OperationError::service_error(&format!(
+                "Failed to read segment {}. Error: {}",
+                path.to_str().unwrap(),
+                err
+            ))
+        })
+}

commit 54e085770811b3f157cf7f7af49b05a3594325a6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 10 20:17:33 2022 +0200

    ignore points with missing expernal ids instead of panic (#1109)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 6af387364..2bf02b71a 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -171,11 +171,15 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 
     let segment_state = Segment::load_state(path)?;
 
-    Ok(Some(create_segment(
-        segment_state.version,
-        path,
-        &segment_state.config,
-    )?))
+    let segment = create_segment(segment_state.version, path, &segment_state.config)?;
+
+    #[cfg(debug_assertions)]
+    {
+        log::debug!("Checking segment consistency: {}", path.display());
+        segment.check_consistency()?;
+    }
+
+    Ok(Some(segment))
 }
 
 /// Build segment instance using given configuration.

commit 5e3416e2cef6d0a6af14407a057f84b175c15f77
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Nov 25 14:47:52 2022 +0400

    Hnsw links memmap (#1211)
    
    * add on disk key
    
    * remove obsolete graph initialization
    
    * remove obsolete max level
    
    * update openapi
    
    * graph links trait
    
    * use mmap option
    
    * same format for ram and mmap
    
    * fix segment unit tests
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix ci and add mmap test
    
    * review fixes
    
    * remove unused try-from
    
    * fix version compatibility
    
    * avoid loading from disk during conversion
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 2bf02b71a..1984e3da8 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -16,6 +16,7 @@ use crate::common::version::StorageVersion;
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
+use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
@@ -98,12 +99,23 @@ fn create_segment(
                 vector_storage.clone(),
                 payload_index.clone(),
             )),
-            Indexes::Hnsw(hnsw_config) => sp(HNSWIndex::open(
-                &vector_index_path,
-                vector_storage.clone(),
-                payload_index.clone(),
-                hnsw_config,
-            )?),
+            Indexes::Hnsw(hnsw_config) => {
+                if hnsw_config.on_disk.unwrap_or(false) {
+                    sp(HNSWIndex::<GraphLinksMmap>::open(
+                        &vector_index_path,
+                        vector_storage.clone(),
+                        payload_index.clone(),
+                        hnsw_config,
+                    )?)
+                } else {
+                    sp(HNSWIndex::<GraphLinksRam>::open(
+                        &vector_index_path,
+                        vector_storage.clone(),
+                        payload_index.clone(),
+                        hnsw_config,
+                    )?)
+                }
+            }
         };
 
         vector_data.insert(
@@ -156,16 +168,26 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
     if stored_version != app_version {
         info!("Migrating segment {} -> {}", stored_version, app_version,);
 
-        if stored_version.minor == 3 {
-            let segment_state = load_segment_state_v3(path)?;
-            Segment::save_state(&segment_state, path)?;
-        } else {
+        if stored_version > app_version {
+            return Err(OperationError::service_error(&format!(
+                "Data version {} is newer than application version {}. \
+                Please upgrade the application. Compatibility is not guaranteed.",
+                stored_version, app_version
+            )));
+        }
+
+        if stored_version.major == 0 && stored_version.minor < 3 {
             return Err(OperationError::service_error(&format!(
                 "Segment version({}) is not compatible with current version({})",
                 stored_version, app_version
             )));
         }
 
+        if stored_version.major == 0 && stored_version.minor == 3 {
+            let segment_state = load_segment_state_v3(path)?;
+            Segment::save_state(&segment_state, path)?;
+        }
+
         SegmentVersion::save(path)?
     }
 

commit 9702054127430851aa927b59bdc2926adbe203d0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 16 10:53:51 2022 +0100

    Clippy for Rust 1.66 (#1284)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 1984e3da8..47f3f8436 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -50,8 +50,8 @@ fn create_segment(
     };
     let vector_db_names: Vec<String> = config
         .vector_data
-        .iter()
-        .map(|(vector_name, _)| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
+        .keys()
+        .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
         .collect();
     let database = open_db(segment_path, &vector_db_names)
         .map_err(|err| OperationError::service_error(&format!("RocksDB open error: {}", err)))?;
@@ -73,9 +73,9 @@ fn create_segment(
     let mut vector_data = HashMap::new();
     for (vector_name, vector_config) in &config.vector_data {
         let vector_storage_path =
-            segment_path.join(&get_vector_name_with_prefix("vector_storage", vector_name));
+            segment_path.join(get_vector_name_with_prefix("vector_storage", vector_name));
         let vector_index_path =
-            segment_path.join(&get_vector_name_with_prefix("vector_index", vector_name));
+            segment_path.join(get_vector_name_with_prefix("vector_index", vector_name));
 
         let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
             StorageType::InMemory => {

commit 81b3313d311bbfe86a30d58a96e77a28231b4227
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Jan 10 20:02:43 2023 +0100

    Repair segment data while checking consistency (#1314)
    
    * Repair segment data while checking consistency
    
    * code review
    
    * code review
    
    * code review
    
    * code review drop_by_internal_id
    
    * refactoring
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 47f3f8436..883a6a5ca 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -193,13 +193,10 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 
     let segment_state = Segment::load_state(path)?;
 
-    let segment = create_segment(segment_state.version, path, &segment_state.config)?;
+    let mut segment = create_segment(segment_state.version, path, &segment_state.config)?;
 
-    #[cfg(debug_assertions)]
-    {
-        log::debug!("Checking segment consistency: {}", path.display());
-        segment.check_consistency()?;
-    }
+    info!("Checking segment consistency: {}", path.display());
+    segment.check_consistency_and_repair()?;
 
     Ok(Some(segment))
 }

commit 6eca194f71bc20ca3e945560d47414eb10c14874
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 13 11:44:42 2023 +0100

    Fix segment snapshotting (#1321) (#1334)
    
    * WIP: Fix `Segment::take_snapshot`
    
    TODO:
    - This commit, probably, breaks snapshotting of segments with memmapped vector storage
    - `ProxySegment::take_snapshot` seems to potentially similar bug
    
    * WIP: Fix `Segment::take_snapshot`
    
    - Fix snapshotting of `StructPayloadIndex`
    - Fix snapshotting of segments with memmapped vector storage
    - Temporarily break `ProxySegment::take_snapshot`
    
    * Fix `ProxySegment::take_snapshot`
    
    * Remove `copy_segment_directory` test
    
    * nitpicking
    
    * clippy fixes
    
    * use OperationError::service_error
    
    * Cleanup `TinyMap` trait bounds and derive `Debug`
    
    * Fix `test_snapshot` test
    
    - Derive `Debug` for `NamedVectors`
    
    * Move utility functions from `segment.rs` to `utils` module
    
    * Contextualize `segment::utils::fs::move_all` a bit more carefully
    
    * Fix a typo
    
    * add backward compatibility with old snapshot formats
    
    * fmt
    
    * add snapshot for compatibility test
    
    * git lfs is a piece of shit
    
    * Nitpicking
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 883a6a5ca..eedcb30f1 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -54,7 +54,7 @@ fn create_segment(
         .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
         .collect();
     let database = open_db(segment_path, &vector_db_names)
-        .map_err(|err| OperationError::service_error(&format!("RocksDB open error: {}", err)))?;
+        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {}", err)))?;
 
     let payload_storage = match config.payload_storage_type {
         PayloadStorageType::InMemory => sp(SimplePayloadStorage::open(database.clone())?.into()),
@@ -169,7 +169,7 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
         info!("Migrating segment {} -> {}", stored_version, app_version,);
 
         if stored_version > app_version {
-            return Err(OperationError::service_error(&format!(
+            return Err(OperationError::service_error(format!(
                 "Data version {} is newer than application version {}. \
                 Please upgrade the application. Compatibility is not guaranteed.",
                 stored_version, app_version
@@ -177,7 +177,7 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
         }
 
         if stored_version.major == 0 && stored_version.minor < 3 {
-            return Err(OperationError::service_error(&format!(
+            return Err(OperationError::service_error(format!(
                 "Segment version({}) is not compatible with current version({})",
                 stored_version, app_version
             )));
@@ -273,7 +273,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
             }
         })
         .map_err(|err| {
-            OperationError::service_error(&format!(
+            OperationError::service_error(format!(
                 "Failed to read segment {}. Error: {}",
                 path.to_str().unwrap(),
                 err

commit 35f575ac9eade88a57351ac29d585a02c8eed8f1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 16 12:05:32 2023 +0100

    Disable extra segments checks (#1352)
    
    * optional segment check
    
    * alternative implementation

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index eedcb30f1..7a0007c5c 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -193,10 +193,7 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 
     let segment_state = Segment::load_state(path)?;
 
-    let mut segment = create_segment(segment_state.version, path, &segment_state.config)?;
-
-    info!("Checking segment consistency: {}", path.display());
-    segment.check_consistency_and_repair()?;
+    let segment = create_segment(segment_state.version, path, &segment_state.config)?;
 
     Ok(Some(segment))
 }

commit 26fc1ed5832df16d7d99214a8f7fef699da02924
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 19 07:58:45 2023 +0100

    Remove some blocking IO calls on Tokio threads (#1366)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 7a0007c5c..b44fbee92 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,5 +1,5 @@
 use std::collections::HashMap;
-use std::fs::{create_dir_all, File};
+use std::fs::File;
 use std::io::Read;
 use std::path::Path;
 use std::sync::Arc;
@@ -210,7 +210,7 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Segment> {
     let segment_path = path.join(Uuid::new_v4().to_string());
 
-    create_dir_all(&segment_path)?;
+    std::fs::create_dir_all(&segment_path)?;
 
     let segment = create_segment(0, &segment_path, config)?;
     segment.save_current_state()?;

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index b44fbee92..7681834ca 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -43,7 +43,7 @@ fn create_segment(
 ) -> OperationResult<Segment> {
     let get_vector_name_with_prefix = |prefix: &str, vector_name: &str| {
         if !vector_name.is_empty() {
-            format!("{}-{}", prefix, vector_name)
+            format!("{prefix}-{vector_name}")
         } else {
             prefix.to_owned()
         }
@@ -54,7 +54,7 @@ fn create_segment(
         .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
         .collect();
     let database = open_db(segment_path, &vector_db_names)
-        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {}", err)))?;
+        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;
 
     let payload_storage = match config.payload_storage_type {
         PayloadStorageType::InMemory => sp(SimplePayloadStorage::open(database.clone())?.into()),
@@ -170,16 +170,14 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 
         if stored_version > app_version {
             return Err(OperationError::service_error(format!(
-                "Data version {} is newer than application version {}. \
-                Please upgrade the application. Compatibility is not guaranteed.",
-                stored_version, app_version
+                "Data version {stored_version} is newer than application version {app_version}. \
+                Please upgrade the application. Compatibility is not guaranteed."
             )));
         }
 
         if stored_version.major == 0 && stored_version.minor < 3 {
             return Err(OperationError::service_error(format!(
-                "Segment version({}) is not compatible with current version({})",
-                stored_version, app_version
+                "Segment version({stored_version}) is not compatible with current version({app_version})"
             )));
         }
 

commit 128e49fcc3633e361df33818de6cca0aab95da10
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Mar 3 20:46:17 2023 +0400

    integrate quantized data to storages (#1311)
    
    * integrate quantized data to storages
    
    * revert gitignore
    
    * are you happy clippy
    
    * quantize in optimizer
    
    * provide flag
    
    * fix segfault
    
    * skip quantization flag, update scores
    
    * use quantization flag
    
    * are you happy fmt
    
    * use quantization flag
    
    * quantized search test
    
    * are you happy fmt
    
    * refactor test, refactor scorer choosing
    
    * are you happy fmt
    
    * run quantization on segment builder
    
    * decrease testing parameters
    
    * simplify segment
    
    * update version
    
    * remove use_quantization flag
    
    * provide quantization config
    
    * quantization version up
    
    * euclid dist
    
    * add euclid test
    
    * saveload
    
    * fix initialization bugs
    
    * quantization lib version up
    
    * fix arm build
    
    * refactor scorer selecting
    
    * quant lib version up
    
    * are you happy fmt
    
    * are you happy fmt
    
    * are you happy clippy
    
    * add save/load test for simple storage
    
    * add comments
    
    * quantiles
    
    * quantization mmap
    
    * remove f32
    
    * mmap test
    
    * fix mmap slice
    
    * fix mmap test
    
    * use chunks for quantization storage
    
    * fix build
    
    * are you happy fmt
    
    * update quantization library
    
    * update quantization lib
    
    * update quantization lib
    
    * integrate api changes
    
    * are you happy fmt
    
    * change quantization api
    
    * additional checks in tests
    
    * update quantization version
    
    * fix unit tests
    
    * add quantization to storage config
    
    * use quantization for all cardinality search cases
    
    * Integrate quantization suggestions 2 (#1520)
    
    * review api
    
    * wip: refactor quantization integrations
    
    * wip: refactor quantization integrations
    
    * wip: fmt
    
    * include quantization into snapshot
    
    * fmt
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 7681834ca..91ac5fdf2 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -1,7 +1,7 @@
 use std::collections::HashMap;
 use std::fs::File;
 use std::io::Read;
-use std::path::Path;
+use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
@@ -32,22 +32,38 @@ use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorageSS;
 
+pub const PAYLOAD_INDEX_PATH: &str = "payload_index";
+pub const VECTOR_STORAGE_PATH: &str = "vector_storage";
+pub const VECTOR_INDEX_PATH: &str = "vector_index";
+
 fn sp<T>(t: T) -> Arc<AtomicRefCell<T>> {
     Arc::new(AtomicRefCell::new(t))
 }
 
+fn get_vector_name_with_prefix(prefix: &str, vector_name: &str) -> String {
+    if !vector_name.is_empty() {
+        format!("{prefix}-{vector_name}")
+    } else {
+        prefix.to_owned()
+    }
+}
+
+pub fn get_vector_storage_path(segment_path: &Path, vector_name: &str) -> PathBuf {
+    segment_path.join(get_vector_name_with_prefix(
+        VECTOR_STORAGE_PATH,
+        vector_name,
+    ))
+}
+
+pub fn get_vector_index_path(segment_path: &Path, vector_name: &str) -> PathBuf {
+    segment_path.join(get_vector_name_with_prefix(VECTOR_INDEX_PATH, vector_name))
+}
+
 fn create_segment(
     version: SeqNumberType,
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
-    let get_vector_name_with_prefix = |prefix: &str, vector_name: &str| {
-        if !vector_name.is_empty() {
-            format!("{prefix}-{vector_name}")
-        } else {
-            prefix.to_owned()
-        }
-    };
     let vector_db_names: Vec<String> = config
         .vector_data
         .keys()
@@ -63,7 +79,7 @@ fn create_segment(
 
     let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
 
-    let payload_index_path = segment_path.join("payload_index");
+    let payload_index_path = segment_path.join(PAYLOAD_INDEX_PATH);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage,
         id_tracker.clone(),
@@ -72,10 +88,8 @@ fn create_segment(
 
     let mut vector_data = HashMap::new();
     for (vector_name, vector_config) in &config.vector_data {
-        let vector_storage_path =
-            segment_path.join(get_vector_name_with_prefix("vector_storage", vector_name));
-        let vector_index_path =
-            segment_path.join(get_vector_name_with_prefix("vector_index", vector_name));
+        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+        let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
         let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
             StorageType::InMemory => {
@@ -94,6 +108,15 @@ fn create_segment(
             )?,
         };
 
+        if config.quantization_config.is_some() {
+            let quantized_data_path = vector_storage_path;
+            // Try to load quantization data from disk, if exists
+            // If not exists or it's a new segment, just ignore it
+            vector_storage
+                .borrow_mut()
+                .load_quantization(&quantized_data_path)?;
+        }
+
         let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
             Indexes::Plain { .. } => sp(PlainIndex::new(
                 vector_storage.clone(),
@@ -264,6 +287,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
                     index: state.config.index,
                     storage_type: state.config.storage_type,
                     payload_storage_type: state.config.payload_storage_type,
+                    quantization_config: None,
                 },
             }
         })

commit 9bb29c26a6ddf3aa0092d45f797aca45735b9ba3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 9 09:43:20 2023 +0400

    Vector storages enum (#1533)
    
    * separate scoring and data containing
    
    * vector storage enum
    
    * fix test build
    
    * are you happy clippy
    
    * review fixes

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 91ac5fdf2..1c1d66a73 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -30,7 +30,7 @@ use crate::types::{
 };
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use crate::vector_storage::VectorStorageSS;
+use crate::vector_storage::VectorStorage;
 
 pub const PAYLOAD_INDEX_PATH: &str = "payload_index";
 pub const VECTOR_STORAGE_PATH: &str = "vector_storage";
@@ -91,7 +91,7 @@ fn create_segment(
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
-        let vector_storage: Arc<AtomicRefCell<VectorStorageSS>> = match config.storage_type {
+        let vector_storage = match config.storage_type {
             StorageType::InMemory => {
                 let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
                 open_simple_vector_storage(

commit c60ef44836ab749d39d8c99209f4a9fc086edfc8
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Mar 12 17:14:21 2023 +0400

    Enum vector index (#1539)
    
    * separate payload and vector index bases
    
    * vector index as enum

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 1c1d66a73..dd13d1209 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -20,7 +20,7 @@ use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::VectorIndexSS;
+use crate::index::VectorIndexEnum;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
@@ -117,26 +117,28 @@ fn create_segment(
                 .load_quantization(&quantized_data_path)?;
         }
 
-        let vector_index: Arc<AtomicRefCell<VectorIndexSS>> = match config.index {
-            Indexes::Plain { .. } => sp(PlainIndex::new(
+        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match config.index {
+            Indexes::Plain { .. } => sp(VectorIndexEnum::Plain(PlainIndex::new(
                 vector_storage.clone(),
                 payload_index.clone(),
-            )),
+            ))),
             Indexes::Hnsw(hnsw_config) => {
                 if hnsw_config.on_disk.unwrap_or(false) {
-                    sp(HNSWIndex::<GraphLinksMmap>::open(
-                        &vector_index_path,
-                        vector_storage.clone(),
-                        payload_index.clone(),
-                        hnsw_config,
-                    )?)
+                    sp(VectorIndexEnum::HnswMmap(
+                        HNSWIndex::<GraphLinksMmap>::open(
+                            &vector_index_path,
+                            vector_storage.clone(),
+                            payload_index.clone(),
+                            hnsw_config,
+                        )?,
+                    ))
                 } else {
-                    sp(HNSWIndex::<GraphLinksRam>::open(
+                    sp(VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
                         &vector_index_path,
                         vector_storage.clone(),
                         payload_index.clone(),
                         hnsw_config,
-                    )?)
+                    )?))
                 }
             }
         };

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index dd13d1209..fdbafdd1e 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -119,6 +119,7 @@ fn create_segment(
 
         let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match config.index {
             Indexes::Plain { .. } => sp(VectorIndexEnum::Plain(PlainIndex::new(
+                id_tracker.clone(),
                 vector_storage.clone(),
                 payload_index.clone(),
             ))),
@@ -127,6 +128,7 @@ fn create_segment(
                     sp(VectorIndexEnum::HnswMmap(
                         HNSWIndex::<GraphLinksMmap>::open(
                             &vector_index_path,
+                            id_tracker.clone(),
                             vector_storage.clone(),
                             payload_index.clone(),
                             hnsw_config,
@@ -135,6 +137,7 @@ fn create_segment(
                 } else {
                     sp(VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
                         &vector_index_path,
+                        id_tracker.clone(),
                         vector_storage.clone(),
                         payload_index.clone(),
                         hnsw_config,

commit 623f3bffe1a53036bd3a6dda4b0159aea8c5cce1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 10 15:29:39 2023 +0200

    Try to fix dying shards (#1682)
    
    * use common channel pool for healthcheck requests
    
    * add dynamic channel pool
    
    * fmt
    
    * lower parallel connections num
    
    * fmt
    
    * fix clippy
    
    * fix clippy
    
    * better status error message
    
    * smarter channel dropping conditions
    
    * per-channel stats
    
    * refactor pool
    
    * rollback dockerfile
    
    * health-check timeout
    
    * prevent reporting last active peer as dead
    
    * introduce update rate limit
    
    * only rate-limit client requests
    
    * ability to save snapshot without locking wal (#1685)
    
    * ability to save snapshot without locking wal
    
    * fix empty wal saving
    
    * skip waiting on local shard in listener mode even if it is a direct request to listener shard
    
    * snapshot recovery test + better handling of segment versions
    
    * use latest wal
    
    * review changes

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index fdbafdd1e..592605208 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -60,7 +60,7 @@ pub fn get_vector_index_path(segment_path: &Path, vector_name: &str) -> PathBuf
 }
 
 fn create_segment(
-    version: SeqNumberType,
+    version: Option<SeqNumberType>,
     segment_path: &Path,
     config: &SegmentConfig,
 ) -> OperationResult<Segment> {
@@ -238,7 +238,7 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
 
     std::fs::create_dir_all(&segment_path)?;
 
-    let segment = create_segment(0, &segment_path, config)?;
+    let segment = create_segment(None, &segment_path, config)?;
     segment.save_current_state()?;
 
     // Version is the last file to save, as it will be used to check if segment was built correctly.
@@ -286,7 +286,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
                 distance: state.config.distance,
             };
             SegmentState {
-                version: state.version,
+                version: Some(state.version),
                 config: SegmentConfig {
                     vector_data: HashMap::from([(DEFAULT_VECTOR_NAME.to_owned(), vector_data)]),
                     index: state.config.index,

commit 66ba8f17af136554e5a5a707c31d8d1fd801b70c
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 10 17:16:56 2023 +0200

    Add vector specific HNSW configuration (#1675)
    
    * Validate VectorConfig/VectorParams, remove obsolete validation
    
    * Add HNSW config diff to vector parameters
    
    * Validate params in collection config
    
    * Add HNSW config to segment vector data config
    
    * Add VectorsConfig params iterator for more elegant conversions
    
    * Prefer vector HNSW config over collection config for building HNSW index
    
    * Base segment vector param HNSW config on collection config
    
    * General improvements
    
    * Rewrite HNSW ef_construct extract function to also consider vector configs
    
    * Update OpenAPI specification
    
    * Add test to check if vector specific HNSW config is persisted
    
    * review changes
    
    * review changes
    
    * Regenerate gRPC docs
    
    * Fix test on Windows
    
    * Regenerate OpenAPI specification
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 592605208..3db41dc64 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -118,31 +118,30 @@ fn create_segment(
         }
 
         let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match config.index {
-            Indexes::Plain { .. } => sp(VectorIndexEnum::Plain(PlainIndex::new(
+            Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
                 id_tracker.clone(),
                 vector_storage.clone(),
                 payload_index.clone(),
             ))),
-            Indexes::Hnsw(hnsw_config) => {
-                if hnsw_config.on_disk.unwrap_or(false) {
-                    sp(VectorIndexEnum::HnswMmap(
-                        HNSWIndex::<GraphLinksMmap>::open(
-                            &vector_index_path,
-                            id_tracker.clone(),
-                            vector_storage.clone(),
-                            payload_index.clone(),
-                            hnsw_config,
-                        )?,
-                    ))
+            Indexes::Hnsw(collection_hnsw_config) => {
+                let hnsw_config = vector_config.hnsw_config.unwrap_or(collection_hnsw_config);
+                sp(if hnsw_config.on_disk == Some(true) {
+                    VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
+                        &vector_index_path,
+                        id_tracker.clone(),
+                        vector_storage.clone(),
+                        payload_index.clone(),
+                        hnsw_config,
+                    )?)
                 } else {
-                    sp(VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
+                    VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
                         &vector_index_path,
                         id_tracker.clone(),
                         vector_storage.clone(),
                         payload_index.clone(),
                         hnsw_config,
-                    )?))
-                }
+                    )?)
+                })
             }
         };
 
@@ -156,7 +155,7 @@ fn create_segment(
     }
 
     let segment_type = match config.index {
-        Indexes::Plain { .. } => SegmentType::Plain,
+        Indexes::Plain {} => SegmentType::Plain,
         Indexes::Hnsw { .. } => SegmentType::Indexed,
     };
 
@@ -284,6 +283,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
             let vector_data = VectorDataConfig {
                 size: state.config.vector_size,
                 distance: state.config.distance,
+                hnsw_config: None,
             };
             SegmentState {
                 version: Some(state.version),

commit 868626f409a7bcc4e2537dcf69b9b4bbe2c10208
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 10 21:39:43 2023 +0200

    Add vector specific quantization configuration (#1680)
    
    * Add QuantizationConfigDiff type
    
    * Add quantization config diff to vector parameters
    
    * Prefer vector config over collection config for quantization
    
    * Update OpenAPI specification
    
    * Validate quantization configuration quantile in 0.5-1.0 range
    
    As per https://github.com/qdrant/qdrant/pull/1681
    
    * Add test if check if vector specific quantization config is persisted
    
    * Alias quantization to quantization_config in vector parameters
    
    * Remove quantization config diff, use full vector specific config instead
    
    * Regenerate OpenAPI specification and gRPC docs
    
    * Fix compilation error
    
    * Add error handling to quantization config conversions
    
    * Fix quantization integration test, make HNSW test stricter

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 3db41dc64..c9cbbda37 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -108,7 +108,7 @@ fn create_segment(
             )?,
         };
 
-        if config.quantization_config.is_some() {
+        if config.quantization_config(vector_name).is_some() {
             let quantized_data_path = vector_storage_path;
             // Try to load quantization data from disk, if exists
             // If not exists or it's a new segment, just ignore it
@@ -284,6 +284,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
                 size: state.config.vector_size,
                 distance: state.config.distance,
                 hnsw_config: None,
+                quantization_config: None,
             };
             SegmentState {
                 version: Some(state.version),

commit 5f73329e257e10ac52f00b3917ad4a575f671012
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat May 6 18:25:09 2023 +0200

    Prevent quantization on appendable (#1847)
    
    * extra check on loading
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index c9cbbda37..bb0eeda7c 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -108,7 +108,8 @@ fn create_segment(
             )?,
         };
 
-        if config.quantization_config(vector_name).is_some() {
+        if config.quantization_config(vector_name).is_some() && config.quantization_config.is_some()
+        {
             let quantized_data_path = vector_storage_path;
             // Try to load quantization data from disk, if exists
             // If not exists or it's a new segment, just ignore it

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Vise <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index bb0eeda7c..b28aaf3db 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -118,14 +118,17 @@ fn create_segment(
                 .load_quantization(&quantized_data_path)?;
         }
 
-        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match config.index {
+        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &config.index {
             Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
                 id_tracker.clone(),
                 vector_storage.clone(),
                 payload_index.clone(),
             ))),
             Indexes::Hnsw(collection_hnsw_config) => {
-                let hnsw_config = vector_config.hnsw_config.unwrap_or(collection_hnsw_config);
+                let hnsw_config = vector_config
+                    .hnsw_config
+                    .clone()
+                    .unwrap_or_else(|| collection_hnsw_config.clone());
                 sp(if hnsw_config.on_disk == Some(true) {
                     VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
                         &vector_index_path,

commit 45ae3e048b15f10e71b5825a9fc00ee7b7676390
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue May 9 18:01:01 2023 +0200

    Dynamic mmap vector storage (#1838)
    
    * wip: chunked mmap
    
    * Fix typo
    
    * insert and get methods
    
    * dynamic bitvec
    
    * clippy
    
    * wip: vector storage
    
    * wip: fmt
    
    * wip: mmap chunks
    
    * wip: mmap problems
    
    * Share transmuted mutable reference over mmap
    
    * option to enable appendable mmap vectors
    
    * fmt
    
    * rename storage status file
    
    * update tests
    
    * fix get deleted value range
    
    * add recovery to vector storage tests
    
    * add flush to tests
    
    * fix transmute from immutable to mutable
    
    * make transmuted pointer private
    
    * remove unused unsafe functions
    
    * force WAL flush if wait=true
    
    * move wal flush into updater thread
    
    * remove flush from update api
    
    * Minimize pub visibility for specialized/dangerous functions
    
    * Allocate vector with predefined capacity
    
    * Inline format parameters
    
    * Assert we have multiple chunks while testing, test is useless otherwise
    
    * Remove unnecessary scope
    
    * Remove unnecessary dereference
    
    * Random bool has 0.5 as standard distribution, use iter::repeat_with
    
    * Replace RemovableMmap::new with Default derive
    
    * Rename len to num_flags
    
    * Use Option replace as it is convention alongside take
    
    * Add FileId enum to replace error prone manual ID rotating
    
    * Use debug_assert_eq where applicable
    
    * Refactor drop and set to replace
    
    * Change default chunk size for chunked mmap vectors to 32MB
    
    This change is made as per GitHub review, because allocating a few
    storages with 128MB would take a significant amount of time and storage.
    
    See: https://github.com/qdrant/qdrant/pull/1838#discussion_r1187215475
    
    * Replace for-loops with iterators
    
    * Draft: add typed mmap to improve code safety (#1860)
    
    * Add typed mmap
    
    * Replace some crude mmap usages with typed mmap
    
    * Use typed mmap for deleted flags
    
    * Simplify dynamic mmap flags a lot with new typed mmap, remove flags option
    
    * Reformat
    
    * Remove old mmap functions that are now unused
    
    * Reimplement mmap locking for mmap_vectors
    
    * Add MmapBitSlice tests
    
    * Replace MmapChunk with new typed mmap
    
    * Update docs
    
    * Clean-up
    
    * Disable alignment assertions on Windows for now
    
    * Rename mmap lock to mlock to prevent confusion with lockable types
    
    * one more small test
    
    * Some review fixes
    
    * Add aliasing note
    
    * Add basic error handling in typed mmap constructors
    
    * Use typed mmap error handling throughout project
    
    * Move mmap type module to common
    
    * Fix transmute functions being unsound
    
    See https://github.com/qdrant/qdrant/pull/1860#discussion_r1188593854
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index b28aaf3db..9e239ee23 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -28,6 +28,7 @@ use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
     StorageType, VectorDataConfig,
 };
+use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorage;
@@ -93,13 +94,21 @@ fn create_segment(
 
         let vector_storage = match config.storage_type {
             StorageType::InMemory => {
-                let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-                open_simple_vector_storage(
-                    database.clone(),
-                    &db_column_name,
-                    vector_config.size,
-                    vector_config.distance,
-                )?
+                if vector_config.on_disk.unwrap_or(false) {
+                    open_appendable_memmap_vector_storage(
+                        &vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    )?
+                } else {
+                    let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+                    open_simple_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                    )?
+                }
             }
             StorageType::Mmap => open_memmap_vector_storage(
                 &vector_storage_path,
@@ -289,6 +298,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
                 distance: state.config.distance,
                 hnsw_config: None,
                 quantization_config: None,
+                on_disk: None,
             };
             SegmentState {
                 version: Some(state.version),

commit df711b7c2e64ec4baf9c086fab2ba68dcdf0966e
Author: Tim Vise <tim+github@visee.me>
Date:   Wed May 17 09:49:55 2023 +0200

    Refactor segment config (#1894)
    
    * Clone current segment config to deprecated type
    
    * Remove segment level quantization config from segment config
    
    * Also deprecate current VectorDataConfig
    
    * Update old segment migration to work with new refactoring
    
    * Move index into vector data config
    
    * Move vector data config migration logic into segment level
    
    * Remove hnsw_config from vector data config
    
    * Rename collection params to vector data conversions function
    
    * Move storage type into vector data config
    
    * Set appendable flag correctly
    
    * Clean up and reformat
    
    * Make segment on disk flag not optional
    
    * Add appendable flag to segment config to replace storage type
    
    * Remove storage type from segment config
    
    * Deprecate storage type enum
    
    * Use consistent variable naming
    
    * Cleanup
    
    * Add segment config migration for v0.5.0 to current
    
    * Bump segment to 0.6.0
    
    * Remove serde defaults for new storage and vector data config types
    
    These default value configurations are not needed anymore, because these
    structs are not used to deserialize old data. All current fields should
    always be available in these structs. When new fields are added in new
    functions, the serde default annotation must be set again.
    
    * Cleanup
    
    * Update OpenAPI specification
    
    This updates the returned data structure on telemetry endpoints, as a
    result of segment configuration refactoring.
    
    * Fix quantization configuration not falling back to collection config
    
    * Fix compiler warning when building in release mode
    
    * Move deprecated type structs into compat module
    
    * Update allow deprecated attributes
    
    * Assign quantization config only in segment optimizer
    
    * Remove unsued parameter
    
    * Add vector storage type enum to vector data config
    
    * Remove appendable and on_disk flags from segment and vector config
    
    * Update OpenAPI specification
    
    * add tests
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 9e239ee23..e7b317acf 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -26,7 +26,7 @@ use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    StorageType, VectorDataConfig,
+    VectorStorageType,
 };
 use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
@@ -92,33 +92,33 @@ fn create_segment(
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
-        let vector_storage = match config.storage_type {
-            StorageType::InMemory => {
-                if vector_config.on_disk.unwrap_or(false) {
-                    open_appendable_memmap_vector_storage(
-                        &vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                    )?
-                } else {
-                    let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-                    open_simple_vector_storage(
-                        database.clone(),
-                        &db_column_name,
-                        vector_config.size,
-                        vector_config.distance,
-                    )?
-                }
+        // Select suitable vector storage type based on configuration
+        let vector_storage = match vector_config.storage_type {
+            // In memory
+            VectorStorageType::Memory => {
+                let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+                open_simple_vector_storage(
+                    database.clone(),
+                    &db_column_name,
+                    vector_config.size,
+                    vector_config.distance,
+                )?
             }
-            StorageType::Mmap => open_memmap_vector_storage(
+            // Mmap on disk, not appendable
+            VectorStorageType::Mmap => open_memmap_vector_storage(
+                &vector_storage_path,
+                vector_config.size,
+                vector_config.distance,
+            )?,
+            // Chunked mmap on disk, appendable
+            VectorStorageType::ChunkedMmap => open_appendable_memmap_vector_storage(
                 &vector_storage_path,
                 vector_config.size,
                 vector_config.distance,
             )?,
         };
 
-        if config.quantization_config(vector_name).is_some() && config.quantization_config.is_some()
-        {
+        if config.quantization_config(vector_name).is_some() {
             let quantized_data_path = vector_storage_path;
             // Try to load quantization data from disk, if exists
             // If not exists or it's a new segment, just ignore it
@@ -127,35 +127,29 @@ fn create_segment(
                 .load_quantization(&quantized_data_path)?;
         }
 
-        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &config.index {
+        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &vector_config.index {
             Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
                 id_tracker.clone(),
                 vector_storage.clone(),
                 payload_index.clone(),
             ))),
-            Indexes::Hnsw(collection_hnsw_config) => {
-                let hnsw_config = vector_config
-                    .hnsw_config
-                    .clone()
-                    .unwrap_or_else(|| collection_hnsw_config.clone());
-                sp(if hnsw_config.on_disk == Some(true) {
-                    VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
-                        &vector_index_path,
-                        id_tracker.clone(),
-                        vector_storage.clone(),
-                        payload_index.clone(),
-                        hnsw_config,
-                    )?)
-                } else {
-                    VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
-                        &vector_index_path,
-                        id_tracker.clone(),
-                        vector_storage.clone(),
-                        payload_index.clone(),
-                        hnsw_config,
-                    )?)
-                })
-            }
+            Indexes::Hnsw(vector_hnsw_config) => sp(if vector_hnsw_config.on_disk == Some(true) {
+                VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
+                    &vector_index_path,
+                    id_tracker.clone(),
+                    vector_storage.clone(),
+                    payload_index.clone(),
+                    vector_hnsw_config.clone(),
+                )?)
+            } else {
+                VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
+                    &vector_index_path,
+                    id_tracker.clone(),
+                    vector_storage.clone(),
+                    payload_index.clone(),
+                    vector_hnsw_config.clone(),
+                )?)
+            }),
         };
 
         vector_data.insert(
@@ -167,13 +161,12 @@ fn create_segment(
         );
     }
 
-    let segment_type = match config.index {
-        Indexes::Plain {} => SegmentType::Plain,
-        Indexes::Hnsw { .. } => SegmentType::Indexed,
+    let segment_type = if config.is_any_vector_indexed() {
+        SegmentType::Indexed
+    } else {
+        SegmentType::Plain
     };
-
-    let appendable_flag =
-        segment_type == SegmentType::Plain {} && config.storage_type == StorageType::InMemory;
+    let appendable_flag = vector_data.values().all(VectorData::is_appendable);
 
     Ok(Segment {
         version,
@@ -224,6 +217,9 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
         if stored_version.major == 0 && stored_version.minor == 3 {
             let segment_state = load_segment_state_v3(path)?;
             Segment::save_state(&segment_state, path)?;
+        } else if stored_version.major == 0 && stored_version.minor <= 5 {
+            let segment_state = load_segment_state_v5(path)?;
+            Segment::save_state(&segment_state, path)?;
         }
 
         SegmentVersion::save(path)?
@@ -260,17 +256,23 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
     Ok(segment)
 }
 
+/// Load v0.3.* segment data and migrate to current version
+#[allow(deprecated)]
 fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
+    use crate::compat::{SegmentConfigV5, StorageTypeV5, VectorDataConfigV5};
+
     #[derive(Deserialize)]
     #[serde(rename_all = "snake_case")]
-    pub struct ObsoleteSegmentState {
+    #[deprecated]
+    pub struct SegmentStateV3 {
         pub version: SeqNumberType,
-        pub config: ObsoleteSegmentConfig,
+        pub config: SegmentConfigV3,
     }
 
     #[derive(Deserialize)]
     #[serde(rename_all = "snake_case")]
-    pub struct ObsoleteSegmentConfig {
+    #[deprecated]
+    pub struct SegmentConfigV3 {
         /// Size of a vectors used
         pub vector_size: usize,
         /// Type of distance function used for measuring distance between vectors
@@ -278,7 +280,7 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
         /// Type of index used for search
         pub index: Indexes,
         /// Type of vector storage
-        pub storage_type: StorageType,
+        pub storage_type: StorageTypeV5,
         /// Defines payload storage type
         #[serde(default)]
         pub payload_storage_type: PayloadStorageType,
@@ -291,24 +293,27 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
     let mut file = File::open(&path)?;
     file.read_to_string(&mut contents)?;
 
-    serde_json::from_str::<ObsoleteSegmentState>(&contents)
+    serde_json::from_str::<SegmentStateV3>(&contents)
         .map(|state| {
-            let vector_data = VectorDataConfig {
+            // Construct V5 version, then convert into current
+            let vector_data = VectorDataConfigV5 {
                 size: state.config.vector_size,
                 distance: state.config.distance,
                 hnsw_config: None,
                 quantization_config: None,
                 on_disk: None,
             };
+            let segment_config = SegmentConfigV5 {
+                vector_data: HashMap::from([(DEFAULT_VECTOR_NAME.to_owned(), vector_data)]),
+                index: state.config.index,
+                storage_type: state.config.storage_type,
+                payload_storage_type: state.config.payload_storage_type,
+                quantization_config: None,
+            };
+
             SegmentState {
                 version: Some(state.version),
-                config: SegmentConfig {
-                    vector_data: HashMap::from([(DEFAULT_VECTOR_NAME.to_owned(), vector_data)]),
-                    index: state.config.index,
-                    storage_type: state.config.storage_type,
-                    payload_storage_type: state.config.payload_storage_type,
-                    quantization_config: None,
-                },
+                config: segment_config.into(),
             }
         })
         .map_err(|err| {
@@ -319,3 +324,26 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
             ))
         })
 }
+
+/// Load v0.5.0 segment data and migrate to current version
+#[allow(deprecated)]
+fn load_segment_state_v5(segment_path: &Path) -> OperationResult<SegmentState> {
+    use crate::compat::SegmentStateV5;
+
+    let path = segment_path.join(SEGMENT_STATE_FILE);
+
+    let mut contents = String::new();
+
+    let mut file = File::open(&path)?;
+    file.read_to_string(&mut contents)?;
+
+    serde_json::from_str::<SegmentStateV5>(&contents)
+        .map(Into::into)
+        .map_err(|err| {
+            OperationError::service_error(format!(
+                "Failed to read segment {}. Error: {}",
+                path.to_str().unwrap(),
+                err
+            ))
+        })
+}

commit 8797df02d4f9039db09e46af7b9cb0c26cc87e43
Author: Tim Vise <tim+github@visee.me>
Date:   Wed May 17 13:52:58 2023 +0200

    Don't store version of temp segment until payload indices are converted (#1913)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e7b317acf..429f92580 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -239,9 +239,12 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 ///
 /// * `path` - A path to collection. Segment folder will be created in this directory
 /// * `config` - Segment configuration
+/// * `ready` - Whether the segment is ready after building; will save segment version
 ///
-///
-pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Segment> {
+/// To load a segment, saving the segment version is required. If `ready` is false, the version
+/// will not be stored. Then the segment is skipped on restart when trying to load it again. In
+/// that case, the segment version must be stored manually to make it ready.
+pub fn build_segment(path: &Path, config: &SegmentConfig, ready: bool) -> OperationResult<Segment> {
     let segment_path = path.join(Uuid::new_v4().to_string());
 
     std::fs::create_dir_all(&segment_path)?;
@@ -251,7 +254,9 @@ pub fn build_segment(path: &Path, config: &SegmentConfig) -> OperationResult<Seg
 
     // Version is the last file to save, as it will be used to check if segment was built correctly.
     // If it is not saved, segment will be skipped.
-    SegmentVersion::save(&segment_path)?;
+    if ready {
+        SegmentVersion::save(&segment_path)?;
+    }
 
     Ok(segment)
 }

commit 2604357ee0a2ec2c9c78d8c8f7d14376a529b3e0
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Jun 28 14:56:33 2023 +0200

    Add debug message when segment storage has point and vector count mismatch (#2071)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 429f92580..1779ec1a2 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -16,6 +16,7 @@ use crate::common::version::StorageVersion;
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
+use crate::id_tracker::IdTracker;
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
@@ -118,6 +119,16 @@ fn create_segment(
             )?,
         };
 
+        // Warn when number of points between ID tracker and storage differs
+        let point_count = id_tracker.borrow().total_point_count();
+        let vector_count = vector_storage.borrow().total_vector_count();
+        if vector_count != point_count {
+            log::debug!(
+                "Mismatch of point and vector counts ({point_count} != {vector_count}, storage: {})",
+                vector_storage_path.display(),
+            );
+        }
+
         if config.quantization_config(vector_name).is_some() {
             let quantized_data_path = vector_storage_path;
             // Try to load quantization data from disk, if exists

commit 96a81ff2363c538a20607fa89875931362f1c101
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 17 17:10:52 2023 +0200

    detect file extension better (#2272)
    
    * detect file extension better
    
    * fix clippy
    
    * refactor + test

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 1779ec1a2..fc526ee00 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -196,6 +196,17 @@ fn create_segment(
 }
 
 pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
+    if path
+        .extension()
+        .and_then(|ext| ext.to_str())
+        .map(|ext| ext == "deleted")
+        .unwrap_or(false)
+    {
+        log::warn!("Segment is marked as deleted, skipping: {}", path.display());
+        // Skip deleted segments
+        return Ok(None);
+    }
+
     if !SegmentVersion::check_exists(path) {
         // Assume segment was not properly saved.
         // Server might have crashed before saving the segment fully.

commit 8ef51525235655112ab08adac644455d86a3d608
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Sep 4 15:24:52 2023 +0200

    immutable map index integration (#2524)
    
    * immutable map index integration
    
    * remove wipe
    
    * fix unit tests
    
    * get appendable flag from config
    
    * minor refactoring
    
    * fix chunked mmap appendable flag
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index fc526ee00..0d0dabba2 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -81,11 +81,17 @@ fn create_segment(
 
     let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
 
+    let appendable_flag = config
+        .vector_data
+        .values()
+        .all(|vector_config| vector_config.is_appendable());
+
     let payload_index_path = segment_path.join(PAYLOAD_INDEX_PATH);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage,
         id_tracker.clone(),
         &payload_index_path,
+        appendable_flag,
     )?);
 
     let mut vector_data = HashMap::new();
@@ -177,7 +183,6 @@ fn create_segment(
     } else {
         SegmentType::Plain
     };
-    let appendable_flag = vector_data.values().all(VectorData::is_appendable);
 
     Ok(Segment {
         version,

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 0d0dabba2..af8d22803 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -11,10 +11,10 @@ use semver::Version;
 use serde::Deserialize;
 use uuid::Uuid;
 
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::common::version::StorageVersion;
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
-use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::IdTracker;
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};

commit 047e4bb8bec7d2526c26ce866cc56e1f2bf816ed
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 12 11:21:34 2023 +0200

    Quantization storage as separate entity (#2797)
    
    * quantization storage as separate entity
    
    * simplify max threads calculation

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index af8d22803..4c8f052f1 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -31,6 +31,7 @@ use crate::types::{
 };
 use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
+use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorage;
 
@@ -135,14 +136,18 @@ fn create_segment(
             );
         }
 
-        if config.quantization_config(vector_name).is_some() {
+        let quantized_vectors = if config.quantization_config(vector_name).is_some() {
             let quantized_data_path = vector_storage_path;
-            // Try to load quantization data from disk, if exists
-            // If not exists or it's a new segment, just ignore it
-            vector_storage
-                .borrow_mut()
-                .load_quantization(&quantized_data_path)?;
-        }
+            if QuantizedVectors::config_exists(&quantized_data_path) {
+                let quantized_vectors =
+                    QuantizedVectors::load(&vector_storage.borrow(), &quantized_data_path)?;
+                Some(quantized_vectors)
+            } else {
+                None
+            }
+        } else {
+            None
+        };
 
         let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &vector_config.index {
             Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
@@ -155,6 +160,7 @@ fn create_segment(
                     &vector_index_path,
                     id_tracker.clone(),
                     vector_storage.clone(),
+                    quantized_vectors.clone(),
                     payload_index.clone(),
                     vector_hnsw_config.clone(),
                 )?)
@@ -163,6 +169,7 @@ fn create_segment(
                     &vector_index_path,
                     id_tracker.clone(),
                     vector_storage.clone(),
+                    quantized_vectors.clone(),
                     payload_index.clone(),
                     vector_hnsw_config.clone(),
                 )?)
@@ -174,6 +181,7 @@ fn create_segment(
             VectorData {
                 vector_storage,
                 vector_index,
+                quantized_vectors,
             },
         );
     }

commit 3fc1f9656418995d21d156bd83f6f3611a99ee96
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 1 13:10:58 2023 +0100

    Sparse index segment and collection config (#2802)
    
    * quantization storage as separate entity
    
    sparse index try to extend segment types
    
    fix build
    
    fix async scorer
    
    codespell
    
    update openapi
    
    update vector index
    
    remove code duplications
    
    more fixes
    
    more fixes
    
    fix build
    
    fix deserialization test
    
    remove transform_into
    
    are you happy clippy
    
    update openapi
    
    update openapi
    
    are you happy clippy
    
    fix build
    
    optional serialize
    
    more defaults
    
    update openapi
    
    fix comments
    
    generic transpose_map_into_named_vector
    
    rename fields in tests
    
    remove obsolete parts
    
    only named sparse config
    
    VectorStruct without unnamed sparse
    
    NamedVectorStruct without unnamed sparse
    
    remove obsolete test
    
    update openapi
    
    mmap index
    
    revert preprocess function
    
    are you happy fmt
    
    update openapi
    
    fix build
    
    fix tests
    
    are you happy fmt
    
    fix for client generation
    
    fix sparse segment creation
    
    fix basic sparse test
    
    fix conflicts
    
    remove obsolete convertion
    
    fix build
    
    config diffs
    
    update openapi
    
    review remarks
    
    update openapi
    
    fix batch upsert
    
    add failing test showing bad ids matching
    
    fix sparse vector insertion
    
    remove on_disk flag
    
    update openapi
    
    revert debug assert
    
    simplify conversions
    
    update openapi
    
    remove on disk storage flag
    
    update openapi
    
    default for vector config
    
    update openapi comment
    
    remove diffs
    
    update openapi
    
    * enable consensus test
    
    * add comment
    
    * update openapi

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 4c8f052f1..187f299f1 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -20,6 +20,7 @@ use crate::id_tracker::IdTracker;
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
+use crate::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
@@ -32,6 +33,7 @@ use crate::types::{
 use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorage;
 
@@ -71,6 +73,12 @@ fn create_segment(
         .vector_data
         .keys()
         .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name))
+        .chain(
+            config
+                .sparse_vector_data
+                .keys()
+                .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name)),
+        )
         .collect();
     let database = open_db(segment_path, &vector_db_names)
         .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;
@@ -85,7 +93,14 @@ fn create_segment(
     let appendable_flag = config
         .vector_data
         .values()
-        .all(|vector_config| vector_config.is_appendable());
+        .map(|vector_config| vector_config.is_appendable())
+        .chain(
+            config
+                .sparse_vector_data
+                .values()
+                .map(|sparse_vector_config| sparse_vector_config.is_appendable()),
+        )
+        .all(|v| v);
 
     let payload_index_path = segment_path.join(PAYLOAD_INDEX_PATH);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
@@ -186,6 +201,50 @@ fn create_segment(
         );
     }
 
+    for (vector_name, sparse_vector_config) in &config.sparse_vector_data {
+        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+        let vector_index_path = get_vector_index_path(segment_path, vector_name);
+
+        let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+        let vector_storage = open_simple_sparse_vector_storage(database.clone(), &db_column_name)?;
+
+        // Warn when number of points between ID tracker and storage differs
+        let point_count = id_tracker.borrow().total_point_count();
+        let vector_count = vector_storage.borrow().total_vector_count();
+        if vector_count != point_count {
+            log::debug!(
+                "Mismatch of point and vector counts ({point_count} != {vector_count}, storage: {})",
+                vector_storage_path.display(),
+            );
+        }
+
+        let vector_index = match sparse_vector_config.index.and_then(|c| c.on_disk) {
+            Some(true) => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
+                sparse_vector_config.index.unwrap_or_default(),
+                id_tracker.clone(),
+                vector_storage.clone(),
+                payload_index.clone(),
+                &vector_index_path,
+            )?)),
+            _ => sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
+                sparse_vector_config.index.unwrap_or_default(),
+                id_tracker.clone(),
+                vector_storage.clone(),
+                payload_index.clone(),
+                &vector_index_path,
+            )?)),
+        };
+
+        vector_data.insert(
+            vector_name.to_owned(),
+            VectorData {
+                vector_storage,
+                vector_index,
+                quantized_vectors: None,
+            },
+        );
+    }
+
     let segment_type = if config.is_any_vector_indexed() {
         SegmentType::Indexed
     } else {

commit 17827a33a1f1948df306701d8ab7560028eb2203
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 6 13:28:17 2023 +0100

    Internal sparse configs for segment (#3168)
    
    * internal sparse vector segment configs
    
    update openapi
    
    fix build
    
    provide correct index type to fixtures
    
    rename grpc stuff
    
    optional search threshold
    
    update api consistency
    
    * review fix
    
    * rollback rename
    
    * reger docs
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 187f299f1..8d633c7cc 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -20,6 +20,7 @@ use crate::id_tracker::IdTracker;
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
+use crate::index::sparse_index::sparse_index_config::SparseIndexType;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
@@ -218,21 +219,23 @@ fn create_segment(
             );
         }
 
-        let vector_index = match sparse_vector_config.index.and_then(|c| c.on_disk) {
-            Some(true) => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
-                sparse_vector_config.index.unwrap_or_default(),
-                id_tracker.clone(),
-                vector_storage.clone(),
-                payload_index.clone(),
-                &vector_index_path,
-            )?)),
-            _ => sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
-                sparse_vector_config.index.unwrap_or_default(),
+        let vector_index = match sparse_vector_config.index.index_type {
+            SparseIndexType::Mmap => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
+                sparse_vector_config.index,
                 id_tracker.clone(),
                 vector_storage.clone(),
                 payload_index.clone(),
                 &vector_index_path,
             )?)),
+            SparseIndexType::MutableRam | SparseIndexType::ImmutableRam => {
+                sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
+                    sparse_vector_config.index,
+                    id_tracker.clone(),
+                    vector_storage.clone(),
+                    payload_index.clone(),
+                    &vector_index_path,
+                )?))
+            }
         };
 
         vector_data.insert(

commit 8c93500998e7fb1fa8d6435d6561dd4316ab7b2d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 13 17:08:37 2023 +0000

    Rename SimpleDenseVectorStorage (#3223)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 8d633c7cc..3209a795e 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -34,8 +34,8 @@ use crate::types::{
 use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+use crate::vector_storage::simple_dense_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
-use crate::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::VectorStorage;
 
 pub const PAYLOAD_INDEX_PATH: &str = "payload_index";

commit b1aed910f23688aead01b484d3ddc9f2d5429e05
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 15 13:00:28 2023 +0000

    Remove quantization update from hnsw index (#3221)
    
    * remove quantization update from hnsw index
    
    * test that hnsw was builded with presented quantization
    
    * are you happy codespell
    
    * prefer method over public field
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 3209a795e..aeaa916ac 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -152,7 +152,7 @@ fn create_segment(
             );
         }
 
-        let quantized_vectors = if config.quantization_config(vector_name).is_some() {
+        let quantized_vectors = sp(if config.quantization_config(vector_name).is_some() {
             let quantized_data_path = vector_storage_path;
             if QuantizedVectors::config_exists(&quantized_data_path) {
                 let quantized_vectors =
@@ -163,7 +163,7 @@ fn create_segment(
             }
         } else {
             None
-        };
+        });
 
         let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &vector_config.index {
             Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
@@ -243,7 +243,7 @@ fn create_segment(
             VectorData {
                 vector_storage,
                 vector_index,
-                quantized_vectors: None,
+                quantized_vectors: sp(None),
             },
         );
     }

commit 8ae92d47161cbb90b6c211400cc307069858ffc6
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:52:03 2024 +0100

    allow stopping segment loading (#3498)
    
    * allow stopping segment loading
    
    * fix benches

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index aeaa916ac..eb4e5dfa4 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -2,6 +2,7 @@ use std::collections::HashMap;
 use std::fs::File;
 use std::io::Read;
 use std::path::{Path, PathBuf};
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
@@ -11,7 +12,7 @@ use semver::Version;
 use serde::Deserialize;
 use uuid::Uuid;
 
-use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::common::version::StorageVersion;
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
@@ -69,6 +70,7 @@ fn create_segment(
     version: Option<SeqNumberType>,
     segment_path: &Path,
     config: &SegmentConfig,
+    stopped: &AtomicBool,
 ) -> OperationResult<Segment> {
     let vector_db_names: Vec<String> = config
         .vector_data
@@ -126,6 +128,7 @@ fn create_segment(
                     &db_column_name,
                     vector_config.size,
                     vector_config.distance,
+                    stopped,
                 )?
             }
             // Mmap on disk, not appendable
@@ -139,6 +142,7 @@ fn create_segment(
                 &vector_storage_path,
                 vector_config.size,
                 vector_config.distance,
+                stopped,
             )?,
         };
 
@@ -192,6 +196,8 @@ fn create_segment(
             }),
         };
 
+        check_process_stopped(stopped)?;
+
         vector_data.insert(
             vector_name.to_owned(),
             VectorData {
@@ -207,7 +213,8 @@ fn create_segment(
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
         let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-        let vector_storage = open_simple_sparse_vector_storage(database.clone(), &db_column_name)?;
+        let vector_storage =
+            open_simple_sparse_vector_storage(database.clone(), &db_column_name, stopped)?;
 
         // Warn when number of points between ID tracker and storage differs
         let point_count = id_tracker.borrow().total_point_count();
@@ -226,6 +233,7 @@ fn create_segment(
                 vector_storage.clone(),
                 payload_index.clone(),
                 &vector_index_path,
+                stopped,
             )?)),
             SparseIndexType::MutableRam | SparseIndexType::ImmutableRam => {
                 sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
@@ -234,10 +242,13 @@ fn create_segment(
                     vector_storage.clone(),
                     payload_index.clone(),
                     &vector_index_path,
+                    stopped,
                 )?))
             }
         };
 
+        check_process_stopped(stopped)?;
+
         vector_data.insert(
             vector_name.to_owned(),
             VectorData {
@@ -270,7 +281,7 @@ fn create_segment(
     })
 }
 
-pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
+pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option<Segment>> {
     if path
         .extension()
         .and_then(|ext| ext.to_str())
@@ -324,7 +335,7 @@ pub fn load_segment(path: &Path) -> OperationResult<Option<Segment>> {
 
     let segment_state = Segment::load_state(path)?;
 
-    let segment = create_segment(segment_state.version, path, &segment_state.config)?;
+    let segment = create_segment(segment_state.version, path, &segment_state.config, stopped)?;
 
     Ok(Some(segment))
 }
@@ -346,7 +357,7 @@ pub fn build_segment(path: &Path, config: &SegmentConfig, ready: bool) -> Operat
 
     std::fs::create_dir_all(&segment_path)?;
 
-    let segment = create_segment(None, &segment_path, config)?;
+    let segment = create_segment(None, &segment_path, config, &AtomicBool::new(false))?;
     segment.save_current_state()?;
 
     // Version is the last file to save, as it will be used to check if segment was built correctly.

commit d1d69d12e6d9b8c0f8d2302c494bc7c1e2601e40
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Feb 28 12:30:44 2024 +0100

    Clearer names for dense storage implementations (#3712)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index eb4e5dfa4..b423f880b 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -32,8 +32,8 @@ use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
     VectorStorageType,
 };
-use crate::vector_storage::appendable_mmap_vector_storage::open_appendable_memmap_vector_storage;
-use crate::vector_storage::memmap_vector_storage::open_memmap_vector_storage;
+use crate::vector_storage::appendable_mmap_dense_vector_storage::open_appendable_memmap_vector_storage;
+use crate::vector_storage::memmap_dense_vector_storage::open_memmap_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_dense_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index b423f880b..88c9cdca7 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -32,10 +32,10 @@ use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
     VectorStorageType,
 };
-use crate::vector_storage::appendable_mmap_dense_vector_storage::open_appendable_memmap_vector_storage;
-use crate::vector_storage::memmap_dense_vector_storage::open_memmap_vector_storage;
+use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::open_appendable_memmap_vector_storage;
+use crate::vector_storage::dense::memmap_dense_vector_storage::open_memmap_vector_storage;
+use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
-use crate::vector_storage::simple_dense_vector_storage::open_simple_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::VectorStorage;
 

commit ffa363cbff245b81b225c8f09b2d4159d3a5f3a2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Apr 4 16:38:09 2024 +0200

    Multivec knob for SegmentConfig (#3963)
    
    * Multivec knob for SegmentConfig
    
    * regen openapi
    
    * add TODO for next step
    
    * introduce multivecconfig to support more similarity aggregation
    
    * update openapi

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 88c9cdca7..0dfe6ac08 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -123,6 +123,7 @@ fn create_segment(
             // In memory
             VectorStorageType::Memory => {
                 let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+                // TODO(colbert) open multivec storage
                 open_simple_vector_storage(
                     database.clone(),
                     &db_column_name,

commit a330542c8ac3b3228e0f06d1b9fd1c2ce36230f0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Apr 8 12:22:24 2024 +0200

    Integrate Multivector at segment level (#3973)
    
    * Integrate Multivector at segment level
    
    * more tests - green with lower accuracy
    
    * decrease expected accuracy to fix test
    
    * cleanup test
    
    * multivector can not be empty
    
    * vary number of vector per multivec point

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 0dfe6ac08..93c6e421e 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -34,8 +34,9 @@ use crate::types::{
 };
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::open_appendable_memmap_vector_storage;
 use crate::vector_storage::dense::memmap_dense_vector_storage::open_memmap_vector_storage;
-use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
+use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+use crate::vector_storage::simple_multi_dense_vector_storage::open_simple_multi_dense_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::VectorStorage;
 
@@ -123,14 +124,24 @@ fn create_segment(
             // In memory
             VectorStorageType::Memory => {
                 let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-                // TODO(colbert) open multivec storage
-                open_simple_vector_storage(
-                    database.clone(),
-                    &db_column_name,
-                    vector_config.size,
-                    vector_config.distance,
-                    stopped,
-                )?
+                if let Some(multi_vec_config) = &vector_config.multi_vec_config {
+                    open_simple_multi_dense_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                        stopped,
+                    )?
+                } else {
+                    open_simple_dense_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        stopped,
+                    )?
+                }
             }
             // Mmap on disk, not appendable
             VectorStorageType::Mmap => open_memmap_vector_storage(

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 93c6e421e..f30cfb781 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -30,11 +30,17 @@ use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    VectorStorageType,
+    VectorStorageDatatype, VectorStorageType,
+};
+use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::{
+    open_appendable_memmap_vector_storage, open_appendable_memmap_vector_storage_byte,
+};
+use crate::vector_storage::dense::memmap_dense_vector_storage::{
+    open_memmap_vector_storage, open_memmap_vector_storage_byte,
+};
+use crate::vector_storage::dense::simple_dense_vector_storage::{
+    open_simple_dense_byte_vector_storage, open_simple_dense_vector_storage,
 };
-use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::open_appendable_memmap_vector_storage;
-use crate::vector_storage::dense::memmap_dense_vector_storage::open_memmap_vector_storage;
-use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_multi_dense_vector_storage::open_simple_multi_dense_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
@@ -120,6 +126,7 @@ fn create_segment(
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
         // Select suitable vector storage type based on configuration
+        let storage_element_type = vector_config.datatype.unwrap_or_default();
         let vector_storage = match vector_config.storage_type {
             // In memory
             VectorStorageType::Memory => {
@@ -134,28 +141,52 @@ fn create_segment(
                         stopped,
                     )?
                 } else {
-                    open_simple_dense_vector_storage(
-                        database.clone(),
-                        &db_column_name,
-                        vector_config.size,
-                        vector_config.distance,
-                        stopped,
-                    )?
+                    match storage_element_type {
+                        VectorStorageDatatype::Float => open_simple_dense_vector_storage(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            stopped,
+                        )?,
+                        VectorStorageDatatype::Uint8 => open_simple_dense_byte_vector_storage(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            stopped,
+                        )?,
+                    }
                 }
             }
             // Mmap on disk, not appendable
-            VectorStorageType::Mmap => open_memmap_vector_storage(
-                &vector_storage_path,
-                vector_config.size,
-                vector_config.distance,
-            )?,
+            VectorStorageType::Mmap => match storage_element_type {
+                VectorStorageDatatype::Float => open_memmap_vector_storage(
+                    &vector_storage_path,
+                    vector_config.size,
+                    vector_config.distance,
+                )?,
+                VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
+                    &vector_storage_path,
+                    vector_config.size,
+                    vector_config.distance,
+                )?,
+            },
             // Chunked mmap on disk, appendable
-            VectorStorageType::ChunkedMmap => open_appendable_memmap_vector_storage(
-                &vector_storage_path,
-                vector_config.size,
-                vector_config.distance,
-                stopped,
-            )?,
+            VectorStorageType::ChunkedMmap => match storage_element_type {
+                VectorStorageDatatype::Float => open_appendable_memmap_vector_storage(
+                    &vector_storage_path,
+                    vector_config.size,
+                    vector_config.distance,
+                    stopped,
+                )?,
+                VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
+                    &vector_storage_path,
+                    vector_config.size,
+                    vector_config.distance,
+                    stopped,
+                )?,
+            },
         };
 
         // Warn when number of points between ID tracker and storage differs

commit 632ec541e28ffc8450909e52102c6ade5715a357
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 18 15:22:28 2024 +0200

    Byte storage api support (#4065)
    
    * wip: include datatype in vector params API
    
    * generate api schemas
    
    * propagate datatype to segment creation
    
    * fix review
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index f30cfb781..9b7ab13a9 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -142,7 +142,7 @@ fn create_segment(
                     )?
                 } else {
                     match storage_element_type {
-                        VectorStorageDatatype::Float => open_simple_dense_vector_storage(
+                        VectorStorageDatatype::Float32 => open_simple_dense_vector_storage(
                             database.clone(),
                             &db_column_name,
                             vector_config.size,
@@ -161,7 +161,7 @@ fn create_segment(
             }
             // Mmap on disk, not appendable
             VectorStorageType::Mmap => match storage_element_type {
-                VectorStorageDatatype::Float => open_memmap_vector_storage(
+                VectorStorageDatatype::Float32 => open_memmap_vector_storage(
                     &vector_storage_path,
                     vector_config.size,
                     vector_config.distance,
@@ -174,7 +174,7 @@ fn create_segment(
             },
             // Chunked mmap on disk, appendable
             VectorStorageType::ChunkedMmap => match storage_element_type {
-                VectorStorageDatatype::Float => open_appendable_memmap_vector_storage(
+                VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
                     &vector_storage_path,
                     vector_config.size,
                     vector_config.distance,

commit 28a31bd5b00a237261bc0e306d972c60582f22b7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon May 6 14:19:42 2024 +0200

    Simplify MaxSim configuration (#4171)
    
    * Simplify MaxSim configuration
    
    * enable extension of multivectorconfig
    
    * rename multi_vec_config to multivec_config

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 9b7ab13a9..a8ecd03b9 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -131,7 +131,7 @@ fn create_segment(
             // In memory
             VectorStorageType::Memory => {
                 let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-                if let Some(multi_vec_config) = &vector_config.multi_vec_config {
+                if let Some(multi_vec_config) = &vector_config.multivec_config {
                     open_simple_multi_dense_vector_storage(
                         database.clone(),
                         &db_column_name,

commit fc6525b0acce58cc860e2736d4ea8da3731b4a8c
Author: Tim Vise <tim+github@visee.me>
Date:   Mon May 6 16:00:35 2024 +0200

    Improve performance of dynamic mmap flags counting (#4176)
    
    * Add dynamic mmap flags function to count flags
    
    * Remove stopped flag
    
    * Add test for new count function to check correctness
    
    * Add benchmark for flag count function
    
    * Fix clippy warning
    
    * Rename bench from deleted to flag count
    
    * Fix typo
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Construct stoppable flag outside bench, add non-stoppable bench
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index a8ecd03b9..93e6349eb 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -178,13 +178,11 @@ fn create_segment(
                     &vector_storage_path,
                     vector_config.size,
                     vector_config.distance,
-                    stopped,
                 )?,
                 VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
                     &vector_storage_path,
                     vector_config.size,
                     vector_config.distance,
-                    stopped,
                 )?,
             },
         };

commit 8bdc8a3caf49d34f7bd6f90239f791684a473a5a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 10:28:31 2024 +0200

    Mmap multivector storage (#4106)
    
    * mmap multivector storage
    
    update_from
    
    fix build
    
    are you happy fmt
    
    fix bug
    
    share multivector storages tests
    
    * review remarks

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 93e6349eb..9421cfcc6 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -41,8 +41,8 @@ use crate::vector_storage::dense::memmap_dense_vector_storage::{
 use crate::vector_storage::dense::simple_dense_vector_storage::{
     open_simple_dense_byte_vector_storage, open_simple_dense_vector_storage,
 };
+use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::open_simple_multi_dense_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
-use crate::vector_storage::simple_multi_dense_vector_storage::open_simple_multi_dense_vector_storage;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::VectorStorage;
 

commit f7113e678c2be8eec0866631fc14e887dbd6e06e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 13:27:58 2024 +0200

    integrate multivector mmap and byte storages (#4194)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 9421cfcc6..02e702dcc 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -41,7 +41,12 @@ use crate::vector_storage::dense::memmap_dense_vector_storage::{
 use crate::vector_storage::dense::simple_dense_vector_storage::{
     open_simple_dense_byte_vector_storage, open_simple_dense_vector_storage,
 };
-use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::open_simple_multi_dense_vector_storage;
+use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
+    open_appendable_memmap_multi_vector_storage, open_appendable_memmap_multi_vector_storage_byte,
+};
+use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
+    open_simple_multi_dense_vector_storage, open_simple_multi_dense_vector_storage_byte,
+};
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::VectorStorage;
@@ -132,14 +137,26 @@ fn create_segment(
             VectorStorageType::Memory => {
                 let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
                 if let Some(multi_vec_config) = &vector_config.multivec_config {
-                    open_simple_multi_dense_vector_storage(
-                        database.clone(),
-                        &db_column_name,
-                        vector_config.size,
-                        vector_config.distance,
-                        *multi_vec_config,
-                        stopped,
-                    )?
+                    match storage_element_type {
+                        VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                            stopped,
+                        )?,
+                        VectorStorageDatatype::Uint8 => {
+                            open_simple_multi_dense_vector_storage_byte(
+                                database.clone(),
+                                &db_column_name,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                                stopped,
+                            )?
+                        }
+                    }
                 } else {
                     match storage_element_type {
                         VectorStorageDatatype::Float32 => open_simple_dense_vector_storage(
@@ -160,31 +177,78 @@ fn create_segment(
                 }
             }
             // Mmap on disk, not appendable
-            VectorStorageType::Mmap => match storage_element_type {
-                VectorStorageDatatype::Float32 => open_memmap_vector_storage(
-                    &vector_storage_path,
-                    vector_config.size,
-                    vector_config.distance,
-                )?,
-                VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
-                    &vector_storage_path,
-                    vector_config.size,
-                    vector_config.distance,
-                )?,
-            },
+            VectorStorageType::Mmap => {
+                if let Some(multi_vec_config) = &vector_config.multivec_config {
+                    // there are no mmap multi vector storages, appendable only
+                    match storage_element_type {
+                        VectorStorageDatatype::Float32 => {
+                            open_appendable_memmap_multi_vector_storage(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
+                        VectorStorageDatatype::Uint8 => {
+                            open_appendable_memmap_multi_vector_storage_byte(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
+                    }
+                } else {
+                    match storage_element_type {
+                        VectorStorageDatatype::Float32 => open_memmap_vector_storage(
+                            &vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )?,
+                        VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
+                            &vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )?,
+                    }
+                }
+            }
             // Chunked mmap on disk, appendable
-            VectorStorageType::ChunkedMmap => match storage_element_type {
-                VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
-                    &vector_storage_path,
-                    vector_config.size,
-                    vector_config.distance,
-                )?,
-                VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
-                    &vector_storage_path,
-                    vector_config.size,
-                    vector_config.distance,
-                )?,
-            },
+            VectorStorageType::ChunkedMmap => {
+                if let Some(multi_vec_config) = &vector_config.multivec_config {
+                    match storage_element_type {
+                        VectorStorageDatatype::Float32 => {
+                            open_appendable_memmap_multi_vector_storage(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
+                        VectorStorageDatatype::Uint8 => {
+                            open_appendable_memmap_multi_vector_storage_byte(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
+                    }
+                } else {
+                    match storage_element_type {
+                        VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
+                            &vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )?,
+                        VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
+                            &vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )?,
+                    }
+                }
+            }
         };
 
         // Warn when number of points between ID tracker and storage differs

commit b334d9fd9079c3eb1bec22bf3d33724eff8a35bf
Author: Kamyar Salahi <kam.salahi@gmail.com>
Date:   Mon May 13 14:19:21 2024 -0700

    Half-precision float vector metrics (#4122)
    
    * Adding half-precision floating point SIMD-optimized implementation for vector distance metrics.
    
    * Primitives adjustment
    
    * Remove ds store
    
    * Load assembly only for neon
    
    * Fixing linter errors
    
    * Adding float16 type
    
    * Addressing f16 comments
    
    * Refactoring and adding benchmarks
    
    * Renaming simd functions
    
    * Cleaning openapi
    
    * Merging in changes to dev
    
    * Fixing linter error
    
    * fix clippy
    
    * disable float16 feature in API
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 02e702dcc..63b37346d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -156,6 +156,7 @@ fn create_segment(
                                 stopped,
                             )?
                         }
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 } else {
                     match storage_element_type {
@@ -173,6 +174,7 @@ fn create_segment(
                             vector_config.distance,
                             stopped,
                         )?,
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 }
             }
@@ -197,6 +199,7 @@ fn create_segment(
                                 *multi_vec_config,
                             )?
                         }
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 } else {
                     match storage_element_type {
@@ -210,6 +213,7 @@ fn create_segment(
                             vector_config.size,
                             vector_config.distance,
                         )?,
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 }
             }
@@ -233,6 +237,7 @@ fn create_segment(
                                 *multi_vec_config,
                             )?
                         }
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 } else {
                     match storage_element_type {
@@ -246,6 +251,7 @@ fn create_segment(
                             vector_config.size,
                             vector_config.distance,
                         )?,
+                        VectorStorageDatatype::Float16 => todo!(),
                     }
                 }
             }

commit 78b16a16a40919218339114bfc723048731ab4b3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 15 10:36:55 2024 +0200

    Float16 integration and API (#4234)
    
    * f16 integration
    
    tests
    
    api
    
    fix test
    
    are you happy clippy
    
    * fix build

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 63b37346d..3f2c10277 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -34,18 +34,22 @@ use crate::types::{
 };
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::{
     open_appendable_memmap_vector_storage, open_appendable_memmap_vector_storage_byte,
+    open_appendable_memmap_vector_storage_half,
 };
 use crate::vector_storage::dense::memmap_dense_vector_storage::{
-    open_memmap_vector_storage, open_memmap_vector_storage_byte,
+    open_memmap_vector_storage, open_memmap_vector_storage_byte, open_memmap_vector_storage_half,
 };
 use crate::vector_storage::dense::simple_dense_vector_storage::{
-    open_simple_dense_byte_vector_storage, open_simple_dense_vector_storage,
+    open_simple_dense_byte_vector_storage, open_simple_dense_half_vector_storage,
+    open_simple_dense_vector_storage,
 };
 use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
     open_appendable_memmap_multi_vector_storage, open_appendable_memmap_multi_vector_storage_byte,
+    open_appendable_memmap_multi_vector_storage_half,
 };
 use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
     open_simple_multi_dense_vector_storage, open_simple_multi_dense_vector_storage_byte,
+    open_simple_multi_dense_vector_storage_half,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
@@ -156,7 +160,16 @@ fn create_segment(
                                 stopped,
                             )?
                         }
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => {
+                            open_simple_multi_dense_vector_storage_half(
+                                database.clone(),
+                                &db_column_name,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                                stopped,
+                            )?
+                        }
                     }
                 } else {
                     match storage_element_type {
@@ -174,7 +187,13 @@ fn create_segment(
                             vector_config.distance,
                             stopped,
                         )?,
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => open_simple_dense_half_vector_storage(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            stopped,
+                        )?,
                     }
                 }
             }
@@ -199,7 +218,14 @@ fn create_segment(
                                 *multi_vec_config,
                             )?
                         }
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => {
+                            open_appendable_memmap_multi_vector_storage_half(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
                     }
                 } else {
                     match storage_element_type {
@@ -213,7 +239,11 @@ fn create_segment(
                             vector_config.size,
                             vector_config.distance,
                         )?,
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => open_memmap_vector_storage_half(
+                            &vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )?,
                     }
                 }
             }
@@ -237,7 +267,14 @@ fn create_segment(
                                 *multi_vec_config,
                             )?
                         }
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => {
+                            open_appendable_memmap_multi_vector_storage_half(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                                *multi_vec_config,
+                            )?
+                        }
                     }
                 } else {
                     match storage_element_type {
@@ -251,7 +288,13 @@ fn create_segment(
                             vector_config.size,
                             vector_config.distance,
                         )?,
-                        VectorStorageDatatype::Float16 => todo!(),
+                        VectorStorageDatatype::Float16 => {
+                            open_appendable_memmap_vector_storage_half(
+                                &vector_storage_path,
+                                vector_config.size,
+                                vector_config.distance,
+                            )?
+                        }
                     }
                 }
             }

commit 1d724579dfd6ed5adeda31429bab5821cab5af30
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu May 16 06:47:47 2024 +0000

    InvertedIndexImmutableRam and index migrations (#4220)
    
    * Move StorageVersion from segment crate to common/io
    
    * Refine StorageVersion API
    
    * Move methods from SparseVectorDataConfig to enum SparseIndexType
    
    * Introduce InvertedIndexImmutableRam
    
    * Add migrate
    
    * Don't migrate

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 3f2c10277..e9a800bcf 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -6,15 +6,14 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::Mutex;
-use semver::Version;
 use serde::Deserialize;
 use uuid::Uuid;
 
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-use crate::common::version::StorageVersion;
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::IdTracker;
@@ -117,7 +116,7 @@ fn create_segment(
             config
                 .sparse_vector_data
                 .values()
-                .map(|sparse_vector_config| sparse_vector_config.is_appendable()),
+                .map(|sparse_vector_config| sparse_vector_config.index.index_type.is_appendable()),
         )
         .all(|v| v);
 
@@ -381,7 +380,7 @@ fn create_segment(
         }
 
         let vector_index = match sparse_vector_config.index.index_type {
-            SparseIndexType::Mmap => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
+            SparseIndexType::MutableRam => sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
                 sparse_vector_config.index,
                 id_tracker.clone(),
                 vector_storage.clone(),
@@ -389,16 +388,24 @@ fn create_segment(
                 &vector_index_path,
                 stopped,
             )?)),
-            SparseIndexType::MutableRam | SparseIndexType::ImmutableRam => {
-                sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
+            SparseIndexType::ImmutableRam => sp(VectorIndexEnum::SparseImmutableRam(
+                SparseVectorIndex::open(
                     sparse_vector_config.index,
                     id_tracker.clone(),
                     vector_storage.clone(),
                     payload_index.clone(),
                     &vector_index_path,
                     stopped,
-                )?))
-            }
+                )?,
+            )),
+            SparseIndexType::Mmap => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
+                sparse_vector_config.index,
+                id_tracker.clone(),
+                vector_storage.clone(),
+                payload_index.clone(),
+                &vector_index_path,
+                stopped,
+            )?)),
         };
 
         check_process_stopped(stopped)?;
@@ -447,7 +454,7 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
         return Ok(None);
     }
 
-    if !SegmentVersion::check_exists(path) {
+    let Some(stored_version) = SegmentVersion::load(path)? else {
         // Assume segment was not properly saved.
         // Server might have crashed before saving the segment fully.
         log::warn!(
@@ -455,10 +462,9 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
             path.display()
         );
         return Ok(None);
-    }
+    };
 
-    let stored_version: Version = SegmentVersion::load(path)?.parse()?;
-    let app_version: Version = SegmentVersion::current().parse()?;
+    let app_version = SegmentVersion::current();
 
     if stored_version != app_version {
         info!("Migrating segment {} -> {}", stored_version, app_version,);

commit aad9db1fe9c5d22dce24e1de27a92a28f7453c8d
Author: Tim Vise <tim+github@visee.me>
Date:   Mon May 27 19:03:02 2024 +0200

    Fix missing segments, use correct path for new segment created during snapshot (#4332)
    
    * Put temporary segment in correct path
    
    * Use shard directory rather than collection directory in test
    
    * Fix collection path getter, it actually returns segments path
    
    * Use segments path for temporary segment
    
    * The build segment function actually wants the segments path
    
    * Refactor parameter name

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e9a800bcf..dd3ccf1d3 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -505,15 +505,19 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
 ///
 /// # Arguments
 ///
-/// * `path` - A path to collection. Segment folder will be created in this directory
+/// * `segments_path` - Path to the segments directory. Segment folder will be created in this directory
 /// * `config` - Segment configuration
 /// * `ready` - Whether the segment is ready after building; will save segment version
 ///
 /// To load a segment, saving the segment version is required. If `ready` is false, the version
 /// will not be stored. Then the segment is skipped on restart when trying to load it again. In
 /// that case, the segment version must be stored manually to make it ready.
-pub fn build_segment(path: &Path, config: &SegmentConfig, ready: bool) -> OperationResult<Segment> {
-    let segment_path = path.join(Uuid::new_v4().to_string());
+pub fn build_segment(
+    segments_path: &Path,
+    config: &SegmentConfig,
+    ready: bool,
+) -> OperationResult<Segment> {
+    let segment_path = segments_path.join(Uuid::new_v4().to_string());
 
     std::fs::create_dir_all(&segment_path)?;
 

commit 09e1dcbb86d4be1477c1864bb5b1fc678727e6f4
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri May 31 09:02:34 2024 +0200

    Add IdTrackerEnum (#4356)
    
    * add IdTrackerEnum
    
    * rename enum variant

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index dd3ccf1d3..2c71fc82b 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -16,7 +16,7 @@ use crate::common::operation_error::{check_process_stopped, OperationError, Oper
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
-use crate::id_tracker::IdTracker;
+use crate::id_tracker::{IdTracker, IdTrackerEnum};
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
@@ -106,8 +106,6 @@ fn create_segment(
         PayloadStorageType::OnDisk => sp(OnDiskPayloadStorage::open(database.clone())?.into()),
     };
 
-    let id_tracker = sp(SimpleIdTracker::open(database.clone())?);
-
     let appendable_flag = config
         .vector_data
         .values()
@@ -120,6 +118,10 @@ fn create_segment(
         )
         .all(|v| v);
 
+    let id_tracker = sp(IdTrackerEnum::MutableIdTracker(SimpleIdTracker::open(
+        database.clone(),
+    )?));
+
     let payload_index_path = segment_path.join(PAYLOAD_INDEX_PATH);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage,

commit 96ecd2cca8ba311282b5d72c9e41ed71ddca036d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jun 4 11:16:11 2024 +0200

    Fix hnsw full scan threshold (#4369)
    
    * fix hnsw full scan threshold
    
    * add test
    
    * are you happy clippy
    
    * separate open_vector_storage
    
    * remove public fields from builder
    
    * wip: do not create segment in builder before build
    
    * avoid arc in storage test and low-level loading functions
    
    * WIP: remove internal segment from SegmentBuilder
    
    * fmt
    
    * finalize segment builder fixes
    
    * Revert "are you happy clippy"
    
    This reverts commit c04afa698995f75f8b589737c2a794aee03824d8.
    
    * Revert "add test"
    
    This reverts commit 8e7ad6207ed042f25dcd07a16fac7c109b9c5a9e.
    
    * Revert "fix hnsw full scan threshold"
    
    This reverts commit 8904443fcb849cca30885b0b6980b0113ed25c16.
    
    * remove _daatabse from builder
    
    * fix optimizer test
    
    * fix id tracker versions persistence
    
    * do flush for segment components on build
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 2c71fc82b..e17f98b5d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -8,7 +8,8 @@ use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use io::storage_version::StorageVersion;
 use log::info;
-use parking_lot::Mutex;
+use parking_lot::{Mutex, RwLock};
+use rocksdb::DB;
 use serde::Deserialize;
 use uuid::Uuid;
 
@@ -16,7 +17,7 @@ use crate::common::operation_error::{check_process_stopped, OperationError, Oper
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
-use crate::id_tracker::{IdTracker, IdTrackerEnum};
+use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
@@ -25,11 +26,12 @@ use crate::index::sparse_index::sparse_vector_index::SparseVectorIndex;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
+use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    VectorStorageDatatype, VectorStorageType,
+    SparseVectorDataConfig, VectorDataConfig, VectorStorageDatatype, VectorStorageType,
 };
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::{
     open_appendable_memmap_vector_storage, open_appendable_memmap_vector_storage_byte,
@@ -52,7 +54,7 @@ use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
-use crate::vector_storage::VectorStorage;
+use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
 pub const PAYLOAD_INDEX_PATH: &str = "payload_index";
 pub const VECTOR_STORAGE_PATH: &str = "vector_storage";
@@ -81,12 +83,175 @@ pub fn get_vector_index_path(segment_path: &Path, vector_name: &str) -> PathBuf
     segment_path.join(get_vector_name_with_prefix(VECTOR_INDEX_PATH, vector_name))
 }
 
-fn create_segment(
-    version: Option<SeqNumberType>,
+pub(crate) fn open_vector_storage(
+    database: &Arc<RwLock<DB>>,
+    vector_config: &VectorDataConfig,
+    stopped: &AtomicBool,
+    vector_storage_path: &Path,
+    vector_name: &str,
+) -> OperationResult<VectorStorageEnum> {
+    let storage_element_type = vector_config.datatype.unwrap_or_default();
+
+    match vector_config.storage_type {
+        // In memory
+        VectorStorageType::Memory => {
+            let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+
+            if let Some(multi_vec_config) = &vector_config.multivec_config {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                        stopped,
+                    ),
+                    VectorStorageDatatype::Uint8 => open_simple_multi_dense_vector_storage_byte(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                        stopped,
+                    ),
+                    VectorStorageDatatype::Float16 => open_simple_multi_dense_vector_storage_half(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                        stopped,
+                    ),
+                }
+            } else {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_simple_dense_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        stopped,
+                    ),
+                    VectorStorageDatatype::Uint8 => open_simple_dense_byte_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        stopped,
+                    ),
+                    VectorStorageDatatype::Float16 => open_simple_dense_half_vector_storage(
+                        database.clone(),
+                        &db_column_name,
+                        vector_config.size,
+                        vector_config.distance,
+                        stopped,
+                    ),
+                }
+            }
+        }
+        // Mmap on disk, not appendable
+        VectorStorageType::Mmap => {
+            if let Some(multi_vec_config) = &vector_config.multivec_config {
+                // there are no mmap multi vector storages, appendable only
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                    ),
+                    VectorStorageDatatype::Uint8 => {
+                        open_appendable_memmap_multi_vector_storage_byte(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                    VectorStorageDatatype::Float16 => {
+                        open_appendable_memmap_multi_vector_storage_half(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                }
+            } else {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_memmap_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Float16 => open_memmap_vector_storage_half(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                }
+            }
+        }
+        // Chunked mmap on disk, appendable
+        VectorStorageType::ChunkedMmap => {
+            if let Some(multi_vec_config) = &vector_config.multivec_config {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                    ),
+                    VectorStorageDatatype::Uint8 => {
+                        open_appendable_memmap_multi_vector_storage_byte(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                    VectorStorageDatatype::Float16 => {
+                        open_appendable_memmap_multi_vector_storage_half(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                }
+            } else {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Float16 => open_appendable_memmap_vector_storage_half(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                }
+            }
+        }
+    }
+}
+
+pub(crate) fn open_segment_db(
     segment_path: &Path,
     config: &SegmentConfig,
-    stopped: &AtomicBool,
-) -> OperationResult<Segment> {
+) -> OperationResult<Arc<RwLock<DB>>> {
     let vector_db_names: Vec<String> = config
         .vector_data
         .keys()
@@ -98,31 +263,129 @@ fn create_segment(
                 .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name)),
         )
         .collect();
-    let database = open_db(segment_path, &vector_db_names)
-        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;
+    open_db(segment_path, &vector_db_names)
+        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))
+}
 
+pub(crate) fn create_payload_storage(
+    database: Arc<RwLock<DB>>,
+    config: &SegmentConfig,
+) -> OperationResult<PayloadStorageEnum> {
     let payload_storage = match config.payload_storage_type {
-        PayloadStorageType::InMemory => sp(SimplePayloadStorage::open(database.clone())?.into()),
-        PayloadStorageType::OnDisk => sp(OnDiskPayloadStorage::open(database.clone())?.into()),
+        PayloadStorageType::InMemory => {
+            PayloadStorageEnum::from(SimplePayloadStorage::open(database)?)
+        }
+        PayloadStorageType::OnDisk => {
+            PayloadStorageEnum::from(OnDiskPayloadStorage::open(database)?)
+        }
     };
+    Ok(payload_storage)
+}
 
-    let appendable_flag = config
-        .vector_data
-        .values()
-        .map(|vector_config| vector_config.is_appendable())
-        .chain(
-            config
-                .sparse_vector_data
-                .values()
-                .map(|sparse_vector_config| sparse_vector_config.index.index_type.is_appendable()),
-        )
-        .all(|v| v);
+pub(crate) fn create_id_tracker(database: Arc<RwLock<DB>>) -> OperationResult<IdTrackerEnum> {
+    Ok(IdTrackerEnum::MutableIdTracker(SimpleIdTracker::open(
+        database,
+    )?))
+}
 
-    let id_tracker = sp(IdTrackerEnum::MutableIdTracker(SimpleIdTracker::open(
-        database.clone(),
-    )?));
+pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
+    segment_path.join(PAYLOAD_INDEX_PATH)
+}
 
-    let payload_index_path = segment_path.join(PAYLOAD_INDEX_PATH);
+pub(crate) fn create_vector_index(
+    vector_config: &VectorDataConfig,
+    vector_index_path: &Path,
+    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
+    payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
+    quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
+) -> OperationResult<VectorIndexEnum> {
+    let vector_index = match &vector_config.index {
+        Indexes::Plain {} => VectorIndexEnum::Plain(PlainIndex::new(
+            id_tracker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+        )),
+        Indexes::Hnsw(vector_hnsw_config) => {
+            if vector_hnsw_config.on_disk == Some(true) {
+                VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
+                    vector_index_path,
+                    id_tracker.clone(),
+                    vector_storage.clone(),
+                    quantized_vectors.clone(),
+                    payload_index.clone(),
+                    vector_hnsw_config.clone(),
+                )?)
+            } else {
+                VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
+                    vector_index_path,
+                    id_tracker.clone(),
+                    vector_storage.clone(),
+                    quantized_vectors.clone(),
+                    payload_index.clone(),
+                    vector_hnsw_config.clone(),
+                )?)
+            }
+        }
+    };
+
+    Ok(vector_index)
+}
+
+pub(crate) fn create_sparse_vector_index(
+    sparse_vector_config: SparseVectorDataConfig,
+    vector_index_path: &Path,
+    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
+    payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
+    stopped: &AtomicBool,
+) -> OperationResult<VectorIndexEnum> {
+    let vector_index = match sparse_vector_config.index.index_type {
+        SparseIndexType::MutableRam => VectorIndexEnum::SparseRam(SparseVectorIndex::open(
+            sparse_vector_config.index,
+            id_tracker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+            vector_index_path,
+            stopped,
+        )?),
+        SparseIndexType::ImmutableRam => {
+            VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(
+                sparse_vector_config.index,
+                id_tracker.clone(),
+                vector_storage.clone(),
+                payload_index.clone(),
+                vector_index_path,
+                stopped,
+            )?)
+        }
+        SparseIndexType::Mmap => VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
+            sparse_vector_config.index,
+            id_tracker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+            vector_index_path,
+            stopped,
+        )?),
+    };
+
+    Ok(vector_index)
+}
+
+fn create_segment(
+    version: Option<SeqNumberType>,
+    segment_path: &Path,
+    config: &SegmentConfig,
+    stopped: &AtomicBool,
+) -> OperationResult<Segment> {
+    let database = open_segment_db(segment_path, config)?;
+    let payload_storage = sp(create_payload_storage(database.clone(), config)?);
+
+    let appendable_flag = config.is_appendable();
+
+    let id_tracker = sp(create_id_tracker(database.clone())?);
+
+    let payload_index_path = get_payload_index_path(segment_path);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage,
         id_tracker.clone(),
@@ -136,170 +399,13 @@ fn create_segment(
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
         // Select suitable vector storage type based on configuration
-        let storage_element_type = vector_config.datatype.unwrap_or_default();
-        let vector_storage = match vector_config.storage_type {
-            // In memory
-            VectorStorageType::Memory => {
-                let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-                if let Some(multi_vec_config) = &vector_config.multivec_config {
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
-                            database.clone(),
-                            &db_column_name,
-                            vector_config.size,
-                            vector_config.distance,
-                            *multi_vec_config,
-                            stopped,
-                        )?,
-                        VectorStorageDatatype::Uint8 => {
-                            open_simple_multi_dense_vector_storage_byte(
-                                database.clone(),
-                                &db_column_name,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                                stopped,
-                            )?
-                        }
-                        VectorStorageDatatype::Float16 => {
-                            open_simple_multi_dense_vector_storage_half(
-                                database.clone(),
-                                &db_column_name,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                                stopped,
-                            )?
-                        }
-                    }
-                } else {
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => open_simple_dense_vector_storage(
-                            database.clone(),
-                            &db_column_name,
-                            vector_config.size,
-                            vector_config.distance,
-                            stopped,
-                        )?,
-                        VectorStorageDatatype::Uint8 => open_simple_dense_byte_vector_storage(
-                            database.clone(),
-                            &db_column_name,
-                            vector_config.size,
-                            vector_config.distance,
-                            stopped,
-                        )?,
-                        VectorStorageDatatype::Float16 => open_simple_dense_half_vector_storage(
-                            database.clone(),
-                            &db_column_name,
-                            vector_config.size,
-                            vector_config.distance,
-                            stopped,
-                        )?,
-                    }
-                }
-            }
-            // Mmap on disk, not appendable
-            VectorStorageType::Mmap => {
-                if let Some(multi_vec_config) = &vector_config.multivec_config {
-                    // there are no mmap multi vector storages, appendable only
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => {
-                            open_appendable_memmap_multi_vector_storage(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                        VectorStorageDatatype::Uint8 => {
-                            open_appendable_memmap_multi_vector_storage_byte(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                        VectorStorageDatatype::Float16 => {
-                            open_appendable_memmap_multi_vector_storage_half(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                    }
-                } else {
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => open_memmap_vector_storage(
-                            &vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                        )?,
-                        VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
-                            &vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                        )?,
-                        VectorStorageDatatype::Float16 => open_memmap_vector_storage_half(
-                            &vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                        )?,
-                    }
-                }
-            }
-            // Chunked mmap on disk, appendable
-            VectorStorageType::ChunkedMmap => {
-                if let Some(multi_vec_config) = &vector_config.multivec_config {
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => {
-                            open_appendable_memmap_multi_vector_storage(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                        VectorStorageDatatype::Uint8 => {
-                            open_appendable_memmap_multi_vector_storage_byte(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                        VectorStorageDatatype::Float16 => {
-                            open_appendable_memmap_multi_vector_storage_half(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                                *multi_vec_config,
-                            )?
-                        }
-                    }
-                } else {
-                    match storage_element_type {
-                        VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
-                            &vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                        )?,
-                        VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
-                            &vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                        )?,
-                        VectorStorageDatatype::Float16 => {
-                            open_appendable_memmap_vector_storage_half(
-                                &vector_storage_path,
-                                vector_config.size,
-                                vector_config.distance,
-                            )?
-                        }
-                    }
-                }
-            }
-        };
+        let vector_storage = Arc::new(AtomicRefCell::new(open_vector_storage(
+            &database,
+            vector_config,
+            stopped,
+            &vector_storage_path,
+            vector_name,
+        )?));
 
         // Warn when number of points between ID tracker and storage differs
         let point_count = id_tracker.borrow().total_point_count();
@@ -324,32 +430,14 @@ fn create_segment(
             None
         });
 
-        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = match &vector_config.index {
-            Indexes::Plain {} => sp(VectorIndexEnum::Plain(PlainIndex::new(
-                id_tracker.clone(),
-                vector_storage.clone(),
-                payload_index.clone(),
-            ))),
-            Indexes::Hnsw(vector_hnsw_config) => sp(if vector_hnsw_config.on_disk == Some(true) {
-                VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
-                    &vector_index_path,
-                    id_tracker.clone(),
-                    vector_storage.clone(),
-                    quantized_vectors.clone(),
-                    payload_index.clone(),
-                    vector_hnsw_config.clone(),
-                )?)
-            } else {
-                VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
-                    &vector_index_path,
-                    id_tracker.clone(),
-                    vector_storage.clone(),
-                    quantized_vectors.clone(),
-                    payload_index.clone(),
-                    vector_hnsw_config.clone(),
-                )?)
-            }),
-        };
+        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = sp(create_vector_index(
+            vector_config,
+            &vector_index_path,
+            id_tracker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+            quantized_vectors.clone(),
+        )?);
 
         check_process_stopped(stopped)?;
 
@@ -381,34 +469,14 @@ fn create_segment(
             );
         }
 
-        let vector_index = match sparse_vector_config.index.index_type {
-            SparseIndexType::MutableRam => sp(VectorIndexEnum::SparseRam(SparseVectorIndex::open(
-                sparse_vector_config.index,
-                id_tracker.clone(),
-                vector_storage.clone(),
-                payload_index.clone(),
-                &vector_index_path,
-                stopped,
-            )?)),
-            SparseIndexType::ImmutableRam => sp(VectorIndexEnum::SparseImmutableRam(
-                SparseVectorIndex::open(
-                    sparse_vector_config.index,
-                    id_tracker.clone(),
-                    vector_storage.clone(),
-                    payload_index.clone(),
-                    &vector_index_path,
-                    stopped,
-                )?,
-            )),
-            SparseIndexType::Mmap => sp(VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
-                sparse_vector_config.index,
-                id_tracker.clone(),
-                vector_storage.clone(),
-                payload_index.clone(),
-                &vector_index_path,
-                stopped,
-            )?)),
-        };
+        let vector_index = sp(create_sparse_vector_index(
+            sparse_vector_config.clone(),
+            &vector_index_path,
+            id_tracker.clone(),
+            vector_storage.clone(),
+            payload_index.clone(),
+            stopped,
+        )?);
 
         check_process_stopped(stopped)?;
 
@@ -502,6 +570,10 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
     Ok(Some(segment))
 }
 
+pub fn new_segment_path(segments_path: &Path) -> PathBuf {
+    segments_path.join(Uuid::new_v4().to_string())
+}
+
 /// Build segment instance using given configuration.
 /// Builder will generate folder for the segment and store all segment information inside it.
 ///
@@ -519,7 +591,7 @@ pub fn build_segment(
     config: &SegmentConfig,
     ready: bool,
 ) -> OperationResult<Segment> {
-    let segment_path = segments_path.join(Uuid::new_v4().to_string());
+    let segment_path = new_segment_path(segments_path);
 
     std::fs::create_dir_all(&segment_path)?;
 

commit 8615ffb56d466ccd537c5f1a997c7e8eb0967566
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 5 12:01:20 2024 +0200

    initialize sparse vectors in the segment builder (#4396)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index e17f98b5d..52a646c64 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -372,6 +372,15 @@ pub(crate) fn create_sparse_vector_index(
     Ok(vector_index)
 }
 
+pub(crate) fn create_sparse_vector_storage(
+    database: Arc<RwLock<DB>>,
+    vector_name: &str,
+    stopped: &AtomicBool,
+) -> OperationResult<VectorStorageEnum> {
+    let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+    open_simple_sparse_vector_storage(database, &db_column_name, stopped)
+}
+
 fn create_segment(
     version: Option<SeqNumberType>,
     segment_path: &Path,
@@ -455,9 +464,11 @@ fn create_segment(
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
-        let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-        let vector_storage =
-            open_simple_sparse_vector_storage(database.clone(), &db_column_name, stopped)?;
+        let vector_storage = sp(create_sparse_vector_storage(
+            database.clone(),
+            vector_name,
+            stopped,
+        )?);
 
         // Warn when number of points between ID tracker and storage differs
         let point_count = id_tracker.borrow().total_point_count();

commit d62a455da1daaf0bcc23248bfa06c8803b0d3e8b
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 17 12:41:38 2024 +0000

    Integrate compressed posting list (attempt 2) (#4453)
    
    * Rename InvertedIndex* -> InvertedIndexCompressed*
    
    * Extract method VectorIndexEnum::fill_idf_statistics
    
    * Extend VectorIndexEnum with new variants
    
    * Introduce sparse::InvertedIndex::Version
    
    * Replace SparseVectorIndexVersion -> InvertedIndex::Version
    
    * Introduce sparse_vector_index::OpenArgs
    
    * SparseVectorIndex::open: do not build index if directory is empty
    
    Otherwise it would build the index twice since `SegmentBuilder::build()`
    calls `::open()`, then `::build_index()`. This restores the old (<=v1.9)
    behavior.
    
    * Renames

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 52a646c64..677d7ee75 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -22,7 +22,9 @@ use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
 use crate::index::sparse_index::sparse_index_config::SparseIndexType;
-use crate::index::sparse_index::sparse_vector_index::SparseVectorIndex;
+use crate::index::sparse_index::sparse_vector_index::{
+    SparseVectorIndex, SparseVectorIndexOpenArgs,
+};
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
@@ -31,7 +33,7 @@ use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    SparseVectorDataConfig, VectorDataConfig, VectorStorageDatatype, VectorStorageType,
+    VectorDataConfig, VectorStorageDatatype, VectorStorageType,
 };
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::{
     open_appendable_memmap_vector_storage, open_appendable_memmap_vector_storage_byte,
@@ -333,40 +335,14 @@ pub(crate) fn create_vector_index(
 }
 
 pub(crate) fn create_sparse_vector_index(
-    sparse_vector_config: SparseVectorDataConfig,
-    vector_index_path: &Path,
-    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-    vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
-    payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
-    stopped: &AtomicBool,
+    args: SparseVectorIndexOpenArgs,
 ) -> OperationResult<VectorIndexEnum> {
-    let vector_index = match sparse_vector_config.index.index_type {
-        SparseIndexType::MutableRam => VectorIndexEnum::SparseRam(SparseVectorIndex::open(
-            sparse_vector_config.index,
-            id_tracker.clone(),
-            vector_storage.clone(),
-            payload_index.clone(),
-            vector_index_path,
-            stopped,
-        )?),
+    let vector_index = match args.config.index_type {
+        SparseIndexType::MutableRam => VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?),
         SparseIndexType::ImmutableRam => {
-            VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(
-                sparse_vector_config.index,
-                id_tracker.clone(),
-                vector_storage.clone(),
-                payload_index.clone(),
-                vector_index_path,
-                stopped,
-            )?)
+            VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(args)?)
         }
-        SparseIndexType::Mmap => VectorIndexEnum::SparseMmap(SparseVectorIndex::open(
-            sparse_vector_config.index,
-            id_tracker.clone(),
-            vector_storage.clone(),
-            payload_index.clone(),
-            vector_index_path,
-            stopped,
-        )?),
+        SparseIndexType::Mmap => VectorIndexEnum::SparseMmap(SparseVectorIndex::open(args)?),
     };
 
     Ok(vector_index)
@@ -480,14 +456,14 @@ fn create_segment(
             );
         }
 
-        let vector_index = sp(create_sparse_vector_index(
-            sparse_vector_config.clone(),
-            &vector_index_path,
-            id_tracker.clone(),
-            vector_storage.clone(),
-            payload_index.clone(),
+        let vector_index = sp(create_sparse_vector_index(SparseVectorIndexOpenArgs {
+            config: sparse_vector_config.index,
+            id_tracker: id_tracker.clone(),
+            vector_storage: vector_storage.clone(),
+            payload_index: payload_index.clone(),
+            path: &vector_index_path,
             stopped,
-        )?);
+        })?);
 
         check_process_stopped(stopped)?;
 

commit b389b4e422a2c86d2d8509b940433e32f7a38d02
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jun 18 13:32:06 2024 +0000

    Add datatype option for sparse vector index (#4454)
    
    * Add SparseVectorIndexDatatype
    
    * Update tests
    
    * Review fixes
    
    * review
    
    * gen openAPI
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 677d7ee75..dbe2fff23 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -21,9 +21,9 @@ use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
 use crate::index::hnsw_index::hnsw::HNSWIndex;
 use crate::index::plain_payload_index::PlainIndex;
-use crate::index::sparse_index::sparse_index_config::SparseIndexType;
+use crate::index::sparse_index::sparse_index_config::{SparseIndexType, SparseVectorIndexDatatype};
 use crate::index::sparse_index::sparse_vector_index::{
-    SparseVectorIndex, SparseVectorIndexOpenArgs,
+    self, SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
@@ -334,15 +334,50 @@ pub(crate) fn create_vector_index(
     Ok(vector_index)
 }
 
+#[cfg(feature = "testing")]
+pub fn create_sparse_vector_index_test(
+    args: SparseVectorIndexOpenArgs,
+) -> OperationResult<VectorIndexEnum> {
+    create_sparse_vector_index(args)
+}
+
 pub(crate) fn create_sparse_vector_index(
     args: SparseVectorIndexOpenArgs,
 ) -> OperationResult<VectorIndexEnum> {
-    let vector_index = match args.config.index_type {
-        SparseIndexType::MutableRam => VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?),
-        SparseIndexType::ImmutableRam => {
+    let vector_index = match (
+        args.config.index_type,
+        args.config.datatype.unwrap_or_default(),
+        sparse_vector_index::USE_COMPRESSED,
+    ) {
+        (_, SparseVectorIndexDatatype::Float16, false) => Err(OperationError::ValidationError {
+            description: "Float16 datatype is not supported".to_string(),
+        })?,
+
+        (SparseIndexType::MutableRam, _, _) => {
+            VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?)
+        }
+
+        // Non-compressed
+        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float32, false) => {
             VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(args)?)
         }
-        SparseIndexType::Mmap => VectorIndexEnum::SparseMmap(SparseVectorIndex::open(args)?),
+        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float32, false) => {
+            VectorIndexEnum::SparseMmap(SparseVectorIndex::open(args)?)
+        }
+
+        // Compressed
+        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float32, true) => {
+            VectorIndexEnum::SparseCompressedImmutableRamF32(SparseVectorIndex::open(args)?)
+        }
+        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float32, true) => {
+            VectorIndexEnum::SparseCompressedMmapF32(SparseVectorIndex::open(args)?)
+        }
+        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float16, true) => {
+            VectorIndexEnum::SparseCompressedImmutableRamF16(SparseVectorIndex::open(args)?)
+        }
+        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float16, true) => {
+            VectorIndexEnum::SparseCompressedMmapF16(SparseVectorIndex::open(args)?)
+        }
     };
 
     Ok(vector_index)

commit eba2c6be61c000a6863e83d989e4e4eb9f1309e1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 23 23:56:42 2024 +0200

    Api consistency update (#4533)
    
    * rename search_params -> params
    
    * rename multivector_config + generate schema
    
    * upd tests

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index dbe2fff23..2217a08dd 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -99,7 +99,7 @@ pub(crate) fn open_vector_storage(
         VectorStorageType::Memory => {
             let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
 
-            if let Some(multi_vec_config) = &vector_config.multivec_config {
+            if let Some(multi_vec_config) = &vector_config.multivector_config {
                 match storage_element_type {
                     VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
                         database.clone(),
@@ -154,7 +154,7 @@ pub(crate) fn open_vector_storage(
         }
         // Mmap on disk, not appendable
         VectorStorageType::Mmap => {
-            if let Some(multi_vec_config) = &vector_config.multivec_config {
+            if let Some(multi_vec_config) = &vector_config.multivector_config {
                 // there are no mmap multi vector storages, appendable only
                 match storage_element_type {
                     VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
@@ -202,7 +202,7 @@ pub(crate) fn open_vector_storage(
         }
         // Chunked mmap on disk, appendable
         VectorStorageType::ChunkedMmap => {
-            if let Some(multi_vec_config) = &vector_config.multivec_config {
+            if let Some(multi_vec_config) = &vector_config.multivector_config {
                 match storage_element_type {
                     VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
                         vector_storage_path,

commit 1a4d8c827a4bc4b93d001c551db552dab17d0840
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 12:44:34 2024 +0000

    Move build_index out of VectorIndex (#4490)
    
    * Move build_index out of VectorIndex
    
    * Build index in HNSWIndex::open()
    
    * Introduce HnswIndexOpenArgs
    
    * Proper deletion
    
    * Improve tests
    
    * HNSW::open(): add warn, comment and assert
    
    * Revert to making up the config if it does not exist

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 2217a08dd..008306bad 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -6,6 +6,7 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::cpu::CpuPermit;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -18,8 +19,7 @@ use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
-use crate::index::hnsw_index::graph_links::{GraphLinksMmap, GraphLinksRam};
-use crate::index::hnsw_index::hnsw::HNSWIndex;
+use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_payload_index::PlainIndex;
 use crate::index::sparse_index::sparse_index_config::{SparseIndexType, SparseVectorIndexDatatype};
 use crate::index::sparse_index::sparse_vector_index::{
@@ -294,6 +294,7 @@ pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
 
+#[allow(clippy::too_many_arguments)]
 pub(crate) fn create_vector_index(
     vector_config: &VectorDataConfig,
     vector_index_path: &Path,
@@ -301,6 +302,8 @@ pub(crate) fn create_vector_index(
     vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
     payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
     quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
+    permit: Option<Arc<CpuPermit>>,
+    stopped: &AtomicBool,
 ) -> OperationResult<VectorIndexEnum> {
     let vector_index = match &vector_config.index {
         Indexes::Plain {} => VectorIndexEnum::Plain(PlainIndex::new(
@@ -309,24 +312,20 @@ pub(crate) fn create_vector_index(
             payload_index.clone(),
         )),
         Indexes::Hnsw(vector_hnsw_config) => {
+            let args = HnswIndexOpenArgs {
+                path: vector_index_path,
+                id_tracker: id_tracker.clone(),
+                vector_storage: vector_storage.clone(),
+                quantized_vectors: quantized_vectors.clone(),
+                payload_index: payload_index.clone(),
+                hnsw_config: vector_hnsw_config.clone(),
+                permit,
+                stopped,
+            };
             if vector_hnsw_config.on_disk == Some(true) {
-                VectorIndexEnum::HnswMmap(HNSWIndex::<GraphLinksMmap>::open(
-                    vector_index_path,
-                    id_tracker.clone(),
-                    vector_storage.clone(),
-                    quantized_vectors.clone(),
-                    payload_index.clone(),
-                    vector_hnsw_config.clone(),
-                )?)
+                VectorIndexEnum::HnswMmap(HNSWIndex::open(args)?)
             } else {
-                VectorIndexEnum::HnswRam(HNSWIndex::<GraphLinksRam>::open(
-                    vector_index_path,
-                    id_tracker.clone(),
-                    vector_storage.clone(),
-                    quantized_vectors.clone(),
-                    payload_index.clone(),
-                    vector_hnsw_config.clone(),
-                )?)
+                VectorIndexEnum::HnswRam(HNSWIndex::open(args)?)
             }
         }
     };
@@ -336,13 +335,13 @@ pub(crate) fn create_vector_index(
 
 #[cfg(feature = "testing")]
 pub fn create_sparse_vector_index_test(
-    args: SparseVectorIndexOpenArgs,
+    args: SparseVectorIndexOpenArgs<impl FnMut()>,
 ) -> OperationResult<VectorIndexEnum> {
     create_sparse_vector_index(args)
 }
 
 pub(crate) fn create_sparse_vector_index(
-    args: SparseVectorIndexOpenArgs,
+    args: SparseVectorIndexOpenArgs<impl FnMut()>,
 ) -> OperationResult<VectorIndexEnum> {
     let vector_index = match (
         args.config.index_type,
@@ -457,6 +456,8 @@ fn create_segment(
             vector_storage.clone(),
             payload_index.clone(),
             quantized_vectors.clone(),
+            None,
+            stopped,
         )?);
 
         check_process_stopped(stopped)?;
@@ -498,6 +499,7 @@ fn create_segment(
             payload_index: payload_index.clone(),
             path: &vector_index_path,
             stopped,
+            tick_progress: || (),
         })?);
 
         check_process_stopped(stopped)?;

commit a5cb30c2085834c83d840c921998cc518a3377d1
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 14:12:29 2024 +0000

    U8 quantization for sparse vector index (#4514)
    
    * U8 quantization for sparse index
    
    * Spelling

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 008306bad..a97b38d6f 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -348,9 +348,11 @@ pub(crate) fn create_sparse_vector_index(
         args.config.datatype.unwrap_or_default(),
         sparse_vector_index::USE_COMPRESSED,
     ) {
-        (_, SparseVectorIndexDatatype::Float16, false) => Err(OperationError::ValidationError {
-            description: "Float16 datatype is not supported".to_string(),
-        })?,
+        (_, a @ (SparseVectorIndexDatatype::Float16 | SparseVectorIndexDatatype::Uint8), false) => {
+            Err(OperationError::ValidationError {
+                description: format!("{:?} datatype is not supported", a),
+            })?
+        }
 
         (SparseIndexType::MutableRam, _, _) => {
             VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?)
@@ -377,6 +379,12 @@ pub(crate) fn create_sparse_vector_index(
         (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float16, true) => {
             VectorIndexEnum::SparseCompressedMmapF16(SparseVectorIndex::open(args)?)
         }
+        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Uint8, true) => {
+            VectorIndexEnum::SparseCompressedImmutableRamU8(SparseVectorIndex::open(args)?)
+        }
+        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Uint8, true) => {
+            VectorIndexEnum::SparseCompressedMmapU8(SparseVectorIndex::open(args)?)
+        }
     };
 
     Ok(vector_index)

commit 7e7a96c80f4b3826fc599cb5f52010d3a2c88650
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 17:27:34 2024 +0000

    Drop SparseVectorIndexDatatype in favor of VectorStorageDatatype (#4541)
    
    * Drop SparseVectorIndexDatatype in favour of VectorStorageDatatype
    
    * Split Datatype doc for VectorParams and SparseIndexParams

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index a97b38d6f..c7b5063bb 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -21,7 +21,7 @@ use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_payload_index::PlainIndex;
-use crate::index::sparse_index::sparse_index_config::{SparseIndexType, SparseVectorIndexDatatype};
+use crate::index::sparse_index::sparse_index_config::SparseIndexType;
 use crate::index::sparse_index::sparse_vector_index::{
     self, SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
@@ -348,7 +348,7 @@ pub(crate) fn create_sparse_vector_index(
         args.config.datatype.unwrap_or_default(),
         sparse_vector_index::USE_COMPRESSED,
     ) {
-        (_, a @ (SparseVectorIndexDatatype::Float16 | SparseVectorIndexDatatype::Uint8), false) => {
+        (_, a @ (VectorStorageDatatype::Float16 | VectorStorageDatatype::Uint8), false) => {
             Err(OperationError::ValidationError {
                 description: format!("{:?} datatype is not supported", a),
             })?
@@ -359,30 +359,30 @@ pub(crate) fn create_sparse_vector_index(
         }
 
         // Non-compressed
-        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float32, false) => {
+        (SparseIndexType::ImmutableRam, VectorStorageDatatype::Float32, false) => {
             VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float32, false) => {
+        (SparseIndexType::Mmap, VectorStorageDatatype::Float32, false) => {
             VectorIndexEnum::SparseMmap(SparseVectorIndex::open(args)?)
         }
 
         // Compressed
-        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float32, true) => {
+        (SparseIndexType::ImmutableRam, VectorStorageDatatype::Float32, true) => {
             VectorIndexEnum::SparseCompressedImmutableRamF32(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float32, true) => {
+        (SparseIndexType::Mmap, VectorStorageDatatype::Float32, true) => {
             VectorIndexEnum::SparseCompressedMmapF32(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Float16, true) => {
+        (SparseIndexType::ImmutableRam, VectorStorageDatatype::Float16, true) => {
             VectorIndexEnum::SparseCompressedImmutableRamF16(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Float16, true) => {
+        (SparseIndexType::Mmap, VectorStorageDatatype::Float16, true) => {
             VectorIndexEnum::SparseCompressedMmapF16(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::ImmutableRam, SparseVectorIndexDatatype::Uint8, true) => {
+        (SparseIndexType::ImmutableRam, VectorStorageDatatype::Uint8, true) => {
             VectorIndexEnum::SparseCompressedImmutableRamU8(SparseVectorIndex::open(args)?)
         }
-        (SparseIndexType::Mmap, SparseVectorIndexDatatype::Uint8, true) => {
+        (SparseIndexType::Mmap, VectorStorageDatatype::Uint8, true) => {
             VectorIndexEnum::SparseCompressedMmapU8(SparseVectorIndex::open(args)?)
         }
     };

commit 6650e5885f6b622161741fb7ecfe181b81a346bf
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Jul 17 19:45:22 2024 +0200

    Merge pull request #4403
    
    * add immutable_id_tracker
    
    * add dirty flag in test
    
    * don't use immutable_id_tracker for now
    
    * improve and integrate new immutable_id_tracker
    
    * split external_to_internal into two BTreeMaps
    
    * apply rquested changes
    
    * delay mmap writes until flush
    
    * remove unnecessary clone
    
    * single source of truth for file path
    
    * use custom de/serialization for more performance
    
    * disable id tracker and fix codespell
    
    * improve code & test
    
    * Other minor nitpicks
    
    * Apply suggestions from code review
    
    * fix rebase issues
    
    * basic custom mappings storage implementation
    
    * add tests & fix bugs
    
    * add more tests and fix bugs
    
    * undo .codespellrc
    
    * disable immutable_id_tracker completely for now
    
    * fix clippy
    
    * Remove unnecessary pub
    
    * minor renaming

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index c7b5063bb..f06be2d07 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -284,12 +284,18 @@ pub(crate) fn create_payload_storage(
     Ok(payload_storage)
 }
 
-pub(crate) fn create_id_tracker(database: Arc<RwLock<DB>>) -> OperationResult<IdTrackerEnum> {
-    Ok(IdTrackerEnum::MutableIdTracker(SimpleIdTracker::open(
-        database,
-    )?))
+pub(crate) fn create_mutable_id_tracker(
+    database: Arc<RwLock<DB>>,
+) -> OperationResult<SimpleIdTracker> {
+    SimpleIdTracker::open(database)
 }
 
+/*pub(crate) fn create_immutable_id_tracker(
+    segment_path: &Path,
+) -> OperationResult<ImmutableIdTracker> {
+    ImmutableIdTracker::open(segment_path)
+}*/
+
 pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
@@ -410,7 +416,25 @@ fn create_segment(
 
     let appendable_flag = config.is_appendable();
 
-    let id_tracker = sp(create_id_tracker(database.clone())?);
+    // TODO: uncomment when releasing the next version! Also in segment_builder.rs:353
+    /*
+    let mutable_id_tracker =
+        appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
+
+    let id_tracker = if mutable_id_tracker {
+        sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
+            database.clone(),
+        )?))
+    } else {
+        sp(IdTrackerEnum::ImmutableIdTracker(
+            create_immutable_id_tracker(segment_path)?,
+        ))
+    };
+     */
+
+    let id_tracker = sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
+        database.clone(),
+    )?));
 
     let payload_index_path = get_payload_index_path(segment_path);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index f06be2d07..5ca829a91 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -356,7 +356,7 @@ pub(crate) fn create_sparse_vector_index(
     ) {
         (_, a @ (VectorStorageDatatype::Float16 | VectorStorageDatatype::Uint8), false) => {
             Err(OperationError::ValidationError {
-                description: format!("{:?} datatype is not supported", a),
+                description: format!("{a:?} datatype is not supported"),
             })?
         }
 
@@ -497,8 +497,8 @@ fn create_segment(
         vector_data.insert(
             vector_name.to_owned(),
             VectorData {
-                vector_storage,
                 vector_index,
+                vector_storage,
                 quantized_vectors,
             },
         );

commit 30a6aa4e742db5a7f1e55bcb3f4485ff05046ae5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 26 18:38:35 2024 +0200

    Enable new idtracker (#4692)
    
    * enable immutable_id_tracker and in_memory_id_tracker
    
    * remove redundent flush
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 5ca829a91..5c020999d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -17,6 +17,7 @@ use uuid::Uuid;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
+use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
@@ -290,11 +291,11 @@ pub(crate) fn create_mutable_id_tracker(
     SimpleIdTracker::open(database)
 }
 
-/*pub(crate) fn create_immutable_id_tracker(
+pub(crate) fn create_immutable_id_tracker(
     segment_path: &Path,
 ) -> OperationResult<ImmutableIdTracker> {
     ImmutableIdTracker::open(segment_path)
-}*/
+}
 
 pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
@@ -416,8 +417,6 @@ fn create_segment(
 
     let appendable_flag = config.is_appendable();
 
-    // TODO: uncomment when releasing the next version! Also in segment_builder.rs:353
-    /*
     let mutable_id_tracker =
         appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
 
@@ -430,11 +429,6 @@ fn create_segment(
             create_immutable_id_tracker(segment_path)?,
         ))
     };
-     */
-
-    let id_tracker = sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
-        database.clone(),
-    )?));
 
     let payload_index_path = get_payload_index_path(segment_path);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(

commit 649560fefd0cce811d8ada7d5c280991bfbb233f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 7 16:34:58 2024 +0200

    Use mmap lock as default vector storage (#4828)
    
    * add force_ram parameter to chuncked mmap vector storage
    
    * enable mlocked mmap vector storage on unix by default
    
    * regen openapi
    
    * add mlock on creation of chunck
    
    * minor unrelated renaming
    
    * rollback changes in LockedChunkedMmap
    
    * fmt
    
    * make AppendableMmapDenseVectorStorage generic of storage type
    
    * make AppendableMmapMultiDenseVectorStorage generic of storage type
    
    * implement initialization of InRamChunkedMmap
    
    * implement MultiDenseAppendableInRam and variations
    
    * enable InRamChunkedMmap for multivectors
    
    * use same CHUNK_SIZE for mmap and regular chuncked vectors
    
    * enable InRamChunkedMmap by default
    
    * fix tests
    
    * rollback usage of InRamChunkedMmap by default
    
    * review changes
    
    * add assertion on chunk_capacity [skip-ci]

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 5c020999d..6909e310d 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -36,9 +36,10 @@ use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
     VectorDataConfig, VectorStorageDatatype, VectorStorageType,
 };
-use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::{
-    open_appendable_memmap_vector_storage, open_appendable_memmap_vector_storage_byte,
-    open_appendable_memmap_vector_storage_half,
+use crate::vector_storage::dense::appendable_dense_vector_storage::{
+    open_appendable_in_ram_vector_storage, open_appendable_in_ram_vector_storage_byte,
+    open_appendable_in_ram_vector_storage_half, open_appendable_memmap_vector_storage,
+    open_appendable_memmap_vector_storage_byte, open_appendable_memmap_vector_storage_half,
 };
 use crate::vector_storage::dense::memmap_dense_vector_storage::{
     open_memmap_vector_storage, open_memmap_vector_storage_byte, open_memmap_vector_storage_half,
@@ -48,7 +49,9 @@ use crate::vector_storage::dense::simple_dense_vector_storage::{
     open_simple_dense_vector_storage,
 };
 use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
-    open_appendable_memmap_multi_vector_storage, open_appendable_memmap_multi_vector_storage_byte,
+    open_appendable_in_ram_multi_vector_storage, open_appendable_in_ram_multi_vector_storage_byte,
+    open_appendable_in_ram_multi_vector_storage_half, open_appendable_memmap_multi_vector_storage,
+    open_appendable_memmap_multi_vector_storage_byte,
     open_appendable_memmap_multi_vector_storage_half,
 };
 use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
@@ -248,6 +251,52 @@ pub(crate) fn open_vector_storage(
                 }
             }
         }
+        VectorStorageType::InRamChunkedMmap => {
+            if let Some(multi_vec_config) = &vector_config.multivector_config {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_appendable_in_ram_multi_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                        *multi_vec_config,
+                    ),
+                    VectorStorageDatatype::Uint8 => {
+                        open_appendable_in_ram_multi_vector_storage_byte(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                    VectorStorageDatatype::Float16 => {
+                        open_appendable_in_ram_multi_vector_storage_half(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
+                }
+            } else {
+                match storage_element_type {
+                    VectorStorageDatatype::Float32 => open_appendable_in_ram_vector_storage(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Uint8 => open_appendable_in_ram_vector_storage_byte(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                    VectorStorageDatatype::Float16 => open_appendable_in_ram_vector_storage_half(
+                        vector_storage_path,
+                        vector_config.size,
+                        vector_config.distance,
+                    ),
+                }
+            }
+        }
     }
 }
 

commit eaa338d458f190b890ee23631aead0e0d780e1c4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Oct 14 09:26:19 2024 +0200

    Payload storage can include files in snapshots (#5214)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 6909e310d..863f1fdc2 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -481,7 +481,7 @@ fn create_segment(
 
     let payload_index_path = get_payload_index_path(segment_path);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
-        payload_storage,
+        payload_storage.clone(),
         id_tracker.clone(),
         &payload_index_path,
         appendable_flag,
@@ -604,6 +604,7 @@ fn create_segment(
         segment_type,
         appendable_flag,
         payload_index,
+        payload_storage,
         segment_config: config.clone(),
         error_status: None,
         database,

commit bcf05d9e231d55f0c4317081c36d3ebc0a2de8c8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Oct 25 18:47:03 2024 +0200

    HasVector filtering condition (#5303)
    
    * include vector storage into struct vector index
    
    * implement has_vector
    
    * generate schemas
    
    * refactor query filter optimizer so avoid too many function arguments
    
    * test + fix for sparse vectors
    
    * Update lib/segment/src/index/struct_payload_index.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * Update lib/segment/src/index/query_optimization/optimizer.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * fmt
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 863f1fdc2..2ca27f586 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -479,18 +479,10 @@ fn create_segment(
         ))
     };
 
-    let payload_index_path = get_payload_index_path(segment_path);
-    let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
-        payload_storage.clone(),
-        id_tracker.clone(),
-        &payload_index_path,
-        appendable_flag,
-    )?);
+    let mut vector_storages = HashMap::new();
 
-    let mut vector_data = HashMap::new();
     for (vector_name, vector_config) in &config.vector_data {
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-        let vector_index_path = get_vector_index_path(segment_path, vector_name);
 
         // Select suitable vector storage type based on configuration
         let vector_storage = Arc::new(AtomicRefCell::new(open_vector_storage(
@@ -501,6 +493,34 @@ fn create_segment(
             vector_name,
         )?));
 
+        vector_storages.insert(vector_name.to_owned(), vector_storage);
+    }
+
+    for vector_name in config.sparse_vector_data.keys() {
+        let vector_storage = sp(create_sparse_vector_storage(
+            database.clone(),
+            vector_name,
+            stopped,
+        )?);
+
+        vector_storages.insert(vector_name.to_owned(), vector_storage);
+    }
+
+    let payload_index_path = get_payload_index_path(segment_path);
+    let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
+        payload_storage.clone(),
+        id_tracker.clone(),
+        vector_storages.clone(),
+        &payload_index_path,
+        appendable_flag,
+    )?);
+
+    let mut vector_data = HashMap::new();
+    for (vector_name, vector_config) in &config.vector_data {
+        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+        let vector_storage = vector_storages.remove(vector_name).unwrap();
+
+        let vector_index_path = get_vector_index_path(segment_path, vector_name);
         // Warn when number of points between ID tracker and storage differs
         let point_count = id_tracker.borrow().total_point_count();
         let vector_count = vector_storage.borrow().total_vector_count();
@@ -550,12 +570,7 @@ fn create_segment(
     for (vector_name, sparse_vector_config) in &config.sparse_vector_data {
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
         let vector_index_path = get_vector_index_path(segment_path, vector_name);
-
-        let vector_storage = sp(create_sparse_vector_storage(
-            database.clone(),
-            vector_name,
-            stopped,
-        )?);
+        let vector_storage = vector_storages.remove(vector_name).unwrap();
 
         // Warn when number of points between ID tracker and storage differs
         let point_count = id_tracker.borrow().total_point_count();

commit 28dfb3ef747ca8a2e0f3ab4aef096bcb13c0c835
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 8 13:02:23 2024 +0100

    Remove redundant clones (#5402)
    
    * Remove redundant clones
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 2ca27f586..122d948c0 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -362,18 +362,16 @@ pub(crate) fn create_vector_index(
     stopped: &AtomicBool,
 ) -> OperationResult<VectorIndexEnum> {
     let vector_index = match &vector_config.index {
-        Indexes::Plain {} => VectorIndexEnum::Plain(PlainIndex::new(
-            id_tracker.clone(),
-            vector_storage.clone(),
-            payload_index.clone(),
-        )),
+        Indexes::Plain {} => {
+            VectorIndexEnum::Plain(PlainIndex::new(id_tracker, vector_storage, payload_index))
+        }
         Indexes::Hnsw(vector_hnsw_config) => {
             let args = HnswIndexOpenArgs {
                 path: vector_index_path,
-                id_tracker: id_tracker.clone(),
-                vector_storage: vector_storage.clone(),
-                quantized_vectors: quantized_vectors.clone(),
-                payload_index: payload_index.clone(),
+                id_tracker,
+                vector_storage,
+                quantized_vectors,
+                payload_index,
                 hnsw_config: vector_hnsw_config.clone(),
                 permit,
                 stopped,

commit 6c162656f3a23a6e6601a58cf69f44bdcea0ab00
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 13 08:49:42 2024 -0600

    Backward compatibility for mmap payload storage (#5398)
    
    * support mmap storage backward compat
    
    * fix clippy
    
    * review fixes + bump + restore Cargo.lock
    
    * fix clippy
    
    * map_err instead of match
    
    * add sanity tests for payload storage trait
    
    * fix clippy
    
    * error conversion
    
    * test persistance too
    
    * add config to enable mmap storage (#5434)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 122d948c0..35cc13cdc 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -28,6 +28,7 @@ use crate::index::sparse_index::sparse_vector_index::{
 };
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::VectorIndexEnum;
+use crate::payload_storage::mmap_payload_storage::MmapPayloadStorage;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
@@ -322,6 +323,7 @@ pub(crate) fn open_segment_db(
 pub(crate) fn create_payload_storage(
     database: Arc<RwLock<DB>>,
     config: &SegmentConfig,
+    path: &Path,
 ) -> OperationResult<PayloadStorageEnum> {
     let payload_storage = match config.payload_storage_type {
         PayloadStorageType::InMemory => {
@@ -330,6 +332,9 @@ pub(crate) fn create_payload_storage(
         PayloadStorageType::OnDisk => {
             PayloadStorageEnum::from(OnDiskPayloadStorage::open(database)?)
         }
+        PayloadStorageType::Mmap => {
+            PayloadStorageEnum::from(MmapPayloadStorage::open_or_create(path)?)
+        }
     };
     Ok(payload_storage)
 }
@@ -460,7 +465,11 @@ fn create_segment(
     stopped: &AtomicBool,
 ) -> OperationResult<Segment> {
     let database = open_segment_db(segment_path, config)?;
-    let payload_storage = sp(create_payload_storage(database.clone(), config)?);
+    let payload_storage = sp(create_payload_storage(
+        database.clone(),
+        config,
+        segment_path,
+    )?);
 
     let appendable_flag = config.is_appendable();
 

commit c10c145a754b3825a60aaaa143fe91b5b98502b0
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 27 11:45:16 2024 -0600

    Compatibility for mmap sparse vectors (#5454)
    
    * implement mmap sparse vector storage
    
    * add to VectorStorageEnum
    
    * clippy
    
    * add tests, fix both simple and mmap storages
    
    * smol correction on total_vector_count
    
    * add sparse storage type to config
    
    * fix reading config without storage type
    
    * generate openapi
    
    * use blob_store by path
    
    * hidden setting to enable new storage
    
    * validate existing path in `BlobStore::open()`
    
    * use new dir for each sparse vector name
    
    * fix and rename `max_point_offset`
    
    Plus some extra refactors
    
    * add storage compat test, to always check both storages work
    
    * fix opening of storage + other misc fixes
    
    * FIX!!!
    
    `Unset` operations in the Tracker weren't updating the
    `next_pointer_id`. So, when reopening the storage, those points wouldn't
    get marked as deleted in the bitslice, thus creating the illusion that
    they should exist, when they did not.
    
    * refactor naming from `iter_*` to `for_each_*`
    
    * fix checking for BlobStore existance
    
    * fix typo
    
    * fix error message
    
    * better docs for open_or_create
    
    * fix after rebase

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 35cc13cdc..dadf269f3 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -35,7 +35,7 @@ use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    VectorDataConfig, VectorStorageDatatype, VectorStorageType,
+    SparseVectorStorageType, VectorDataConfig, VectorStorageDatatype, VectorStorageType,
 };
 use crate::vector_storage::dense::appendable_dense_vector_storage::{
     open_appendable_in_ram_vector_storage, open_appendable_in_ram_vector_storage_byte,
@@ -49,6 +49,7 @@ use crate::vector_storage::dense::simple_dense_vector_storage::{
     open_simple_dense_byte_vector_storage, open_simple_dense_half_vector_storage,
     open_simple_dense_vector_storage,
 };
+use crate::vector_storage::mmap_sparse_vector_storage::MmapSparseVectorStorage;
 use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
     open_appendable_in_ram_multi_vector_storage, open_appendable_in_ram_multi_vector_storage_byte,
     open_appendable_in_ram_multi_vector_storage_half, open_appendable_memmap_multi_vector_storage,
@@ -312,8 +313,14 @@ pub(crate) fn open_segment_db(
         .chain(
             config
                 .sparse_vector_data
-                .keys()
-                .map(|vector_name| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name)),
+                .iter()
+                .filter(|(_, sparse_vector_config)| {
+                    matches!(
+                        sparse_vector_config.storage_type,
+                        SparseVectorStorageType::OnDisk
+                    )
+                })
+                .map(|(vector_name, _)| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name)),
         )
         .collect();
     open_db(segment_path, &vector_db_names)
@@ -451,11 +458,21 @@ pub(crate) fn create_sparse_vector_index(
 
 pub(crate) fn create_sparse_vector_storage(
     database: Arc<RwLock<DB>>,
+    path: &Path,
     vector_name: &str,
+    storage_type: &SparseVectorStorageType,
     stopped: &AtomicBool,
 ) -> OperationResult<VectorStorageEnum> {
-    let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-    open_simple_sparse_vector_storage(database, &db_column_name, stopped)
+    match storage_type {
+        SparseVectorStorageType::OnDisk => {
+            let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
+            open_simple_sparse_vector_storage(database, &db_column_name, stopped)
+        }
+        SparseVectorStorageType::Mmap => {
+            let mmap_storage = MmapSparseVectorStorage::open_or_create(path, stopped)?;
+            Ok(VectorStorageEnum::SparseMmap(mmap_storage))
+        }
+    }
 }
 
 fn create_segment(
@@ -492,21 +509,26 @@ fn create_segment(
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
 
         // Select suitable vector storage type based on configuration
-        let vector_storage = Arc::new(AtomicRefCell::new(open_vector_storage(
+        let vector_storage = sp(open_vector_storage(
             &database,
             vector_config,
             stopped,
             &vector_storage_path,
             vector_name,
-        )?));
+        )?);
 
         vector_storages.insert(vector_name.to_owned(), vector_storage);
     }
 
-    for vector_name in config.sparse_vector_data.keys() {
+    for (vector_name, sparse_config) in config.sparse_vector_data.iter() {
+        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+
+        // Select suitable sparse vector storage type based on configuration
         let vector_storage = sp(create_sparse_vector_storage(
             database.clone(),
+            &vector_storage_path,
             vector_name,
+            &sparse_config.storage_type,
             stopped,
         )?);
 

commit 443358dbe71139d5f6fe5fdf17531c5b005396ce
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 27 13:46:57 2024 -0600

    restructure sparse storages module (#5532)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index dadf269f3..1d35ead08 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -49,7 +49,6 @@ use crate::vector_storage::dense::simple_dense_vector_storage::{
     open_simple_dense_byte_vector_storage, open_simple_dense_half_vector_storage,
     open_simple_dense_vector_storage,
 };
-use crate::vector_storage::mmap_sparse_vector_storage::MmapSparseVectorStorage;
 use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
     open_appendable_in_ram_multi_vector_storage, open_appendable_in_ram_multi_vector_storage_byte,
     open_appendable_in_ram_multi_vector_storage_half, open_appendable_memmap_multi_vector_storage,
@@ -61,7 +60,8 @@ use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
     open_simple_multi_dense_vector_storage_half,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
-use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
+use crate::vector_storage::sparse::mmap_sparse_vector_storage::MmapSparseVectorStorage;
+use crate::vector_storage::sparse::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
 pub const PAYLOAD_INDEX_PATH: &str = "payload_index";

commit 4f99e728aa0aff938211c6085050a0c803d61765
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Dec 5 00:58:49 2024 +0100

    GPU HNSW integration (#5535)
    
    * gpu hnsw
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 1d35ead08..1642f71d4 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -20,6 +20,7 @@ use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
+use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_payload_index::PlainIndex;
 use crate::index::sparse_index::sparse_index_config::SparseIndexType;
@@ -371,6 +372,7 @@ pub(crate) fn create_vector_index(
     payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
     quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
     permit: Option<Arc<CpuPermit>>,
+    gpu_device: Option<&LockedGpuDevice>,
     stopped: &AtomicBool,
 ) -> OperationResult<VectorIndexEnum> {
     let vector_index = match &vector_config.index {
@@ -386,6 +388,7 @@ pub(crate) fn create_vector_index(
                 payload_index,
                 hnsw_config: vector_hnsw_config.clone(),
                 permit,
+                gpu_device,
                 stopped,
             };
             if vector_hnsw_config.on_disk == Some(true) {
@@ -580,6 +583,7 @@ fn create_segment(
             vector_storage.clone(),
             payload_index.clone(),
             quantized_vectors.clone(),
+            Default::default(),
             None,
             stopped,
         )?);

commit ced3a29f7e22ce5c799bb8a68ec1d55434e846d9
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 18 14:56:38 2024 +0100

    Extract plain vector index (#5675)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 1642f71d4..8d6656bfc 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -22,7 +22,7 @@ use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
-use crate::index::plain_payload_index::PlainIndex;
+use crate::index::plain_vector_index::PlainVectorIndex;
 use crate::index::sparse_index::sparse_index_config::SparseIndexType;
 use crate::index::sparse_index::sparse_vector_index::{
     self, SparseVectorIndex, SparseVectorIndexOpenArgs,
@@ -376,9 +376,11 @@ pub(crate) fn create_vector_index(
     stopped: &AtomicBool,
 ) -> OperationResult<VectorIndexEnum> {
     let vector_index = match &vector_config.index {
-        Indexes::Plain {} => {
-            VectorIndexEnum::Plain(PlainIndex::new(id_tracker, vector_storage, payload_index))
-        }
+        Indexes::Plain {} => VectorIndexEnum::Plain(PlainVectorIndex::new(
+            id_tracker,
+            vector_storage,
+            payload_index,
+        )),
         Indexes::Hnsw(vector_hnsw_config) => {
             let args = HnswIndexOpenArgs {
                 path: vector_index_path,

commit f2b142620fe87662356bd82ba0ebe7beb7f3e080
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Dec 18 16:53:06 2024 -0300

    Fast loading of mmap sparse storage (#5533)
    
    * use mmap bitslice and a metadata file to avoid loading
    
    * fix and test reported files
    
    * add new files to flusher
    
    * update rocksdb+blob_store compatibility test
    
    * switch to DynamicMmapFlags
    
    * fix setting deleted to `false` on short bitslice
    
    * remove `MmapBitSlice::extend`
    
    * add some more tests to mmap sparse vector storage
    
    * calculate deleted_count and next_point_offset on load
    
    * get rid of metadata file
    
    * cleanup
    
    * fix test
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 8d6656bfc..ffb35e6b8 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -474,7 +474,7 @@ pub(crate) fn create_sparse_vector_storage(
             open_simple_sparse_vector_storage(database, &db_column_name, stopped)
         }
         SparseVectorStorageType::Mmap => {
-            let mmap_storage = MmapSparseVectorStorage::open_or_create(path, stopped)?;
+            let mmap_storage = MmapSparseVectorStorage::open_or_create(path)?;
             Ok(VectorStorageEnum::SparseMmap(mmap_storage))
         }
     }

commit 01326480419e31926c1a6c3223c5a4dc54ea748f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Dec 23 18:59:53 2024 +0000

    GraphLinks: replace trait with enum (#5651)
    
    * GraphLinks: replace trait with enum
    
    * Vec::with_capacity

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index ffb35e6b8..7b3b3b0cf 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -393,11 +393,7 @@ pub(crate) fn create_vector_index(
                 gpu_device,
                 stopped,
             };
-            if vector_hnsw_config.on_disk == Some(true) {
-                VectorIndexEnum::HnswMmap(HNSWIndex::open(args)?)
-            } else {
-                VectorIndexEnum::HnswRam(HNSWIndex::open(args)?)
-            }
+            VectorIndexEnum::Hnsw(HNSWIndex::open(args)?)
         }
     };
 

commit dc421536eabcc3cfbfc428c316ff7412024c076f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 00:09:57 2025 +0000

    Split HNSWIndex::open and HNSWIndex::build (#5853)
    
    * HNSWSearchesTelemetry::new()
    
    * Split HNSWIndex::open and HNSWIndex::build

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 7b3b3b0cf..171d359eb 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -363,41 +363,78 @@ pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
 
-#[allow(clippy::too_many_arguments)]
-pub(crate) fn create_vector_index(
+pub(crate) struct VectorIndexOpenArgs<'a> {
+    pub path: &'a Path,
+    pub id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    pub vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
+    pub payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
+    pub quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
+}
+
+pub struct VectorIndexBuildArgs<'a> {
+    pub permit: Arc<CpuPermit>,
+    pub gpu_device: Option<&'a LockedGpuDevice<'a>>,
+    pub stopped: &'a AtomicBool,
+}
+
+pub(crate) fn open_vector_index(
     vector_config: &VectorDataConfig,
-    vector_index_path: &Path,
-    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-    vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
-    payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
-    quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
-    permit: Option<Arc<CpuPermit>>,
-    gpu_device: Option<&LockedGpuDevice>,
-    stopped: &AtomicBool,
+    open_args: VectorIndexOpenArgs,
 ) -> OperationResult<VectorIndexEnum> {
-    let vector_index = match &vector_config.index {
+    let VectorIndexOpenArgs {
+        path,
+        id_tracker,
+        vector_storage,
+        payload_index,
+        quantized_vectors,
+    } = open_args;
+    Ok(match &vector_config.index {
         Indexes::Plain {} => VectorIndexEnum::Plain(PlainVectorIndex::new(
             id_tracker,
             vector_storage,
             payload_index,
         )),
-        Indexes::Hnsw(vector_hnsw_config) => {
-            let args = HnswIndexOpenArgs {
-                path: vector_index_path,
+        Indexes::Hnsw(hnsw_config) => VectorIndexEnum::Hnsw(HNSWIndex::open(HnswIndexOpenArgs {
+            path,
+            id_tracker,
+            vector_storage,
+            quantized_vectors,
+            payload_index,
+            hnsw_config: hnsw_config.clone(),
+        })?),
+    })
+}
+
+pub(crate) fn build_vector_index(
+    vector_config: &VectorDataConfig,
+    open_args: VectorIndexOpenArgs,
+    build_args: VectorIndexBuildArgs,
+) -> OperationResult<VectorIndexEnum> {
+    let VectorIndexOpenArgs {
+        path,
+        id_tracker,
+        vector_storage,
+        payload_index,
+        quantized_vectors,
+    } = open_args;
+    Ok(match &vector_config.index {
+        Indexes::Plain {} => VectorIndexEnum::Plain(PlainVectorIndex::new(
+            id_tracker,
+            vector_storage,
+            payload_index,
+        )),
+        Indexes::Hnsw(hnsw_config) => VectorIndexEnum::Hnsw(HNSWIndex::build(
+            HnswIndexOpenArgs {
+                path,
                 id_tracker,
                 vector_storage,
                 quantized_vectors,
                 payload_index,
-                hnsw_config: vector_hnsw_config.clone(),
-                permit,
-                gpu_device,
-                stopped,
-            };
-            VectorIndexEnum::Hnsw(HNSWIndex::open(args)?)
-        }
-    };
-
-    Ok(vector_index)
+                hnsw_config: hnsw_config.clone(),
+            },
+            build_args,
+        )?),
+    })
 }
 
 #[cfg(feature = "testing")]
@@ -574,16 +611,15 @@ fn create_segment(
             None
         });
 
-        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = sp(create_vector_index(
+        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = sp(open_vector_index(
             vector_config,
-            &vector_index_path,
-            id_tracker.clone(),
-            vector_storage.clone(),
-            payload_index.clone(),
-            quantized_vectors.clone(),
-            Default::default(),
-            None,
-            stopped,
+            VectorIndexOpenArgs {
+                path: &vector_index_path,
+                id_tracker: id_tracker.clone(),
+                vector_storage: vector_storage.clone(),
+                payload_index: payload_index.clone(),
+                quantized_vectors: quantized_vectors.clone(),
+            },
         )?);
 
         check_process_stopped(stopped)?;

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 171d359eb..b5eb8d55c 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -36,7 +36,8 @@ use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    SparseVectorStorageType, VectorDataConfig, VectorStorageDatatype, VectorStorageType,
+    SparseVectorStorageType, VectorDataConfig, VectorName, VectorStorageDatatype,
+    VectorStorageType,
 };
 use crate::vector_storage::dense::appendable_dense_vector_storage::{
     open_appendable_in_ram_vector_storage, open_appendable_in_ram_vector_storage_byte,
@@ -73,7 +74,7 @@ fn sp<T>(t: T) -> Arc<AtomicRefCell<T>> {
     Arc::new(AtomicRefCell::new(t))
 }
 
-fn get_vector_name_with_prefix(prefix: &str, vector_name: &str) -> String {
+fn get_vector_name_with_prefix(prefix: &str, vector_name: &VectorName) -> String {
     if !vector_name.is_empty() {
         format!("{prefix}-{vector_name}")
     } else {
@@ -81,14 +82,14 @@ fn get_vector_name_with_prefix(prefix: &str, vector_name: &str) -> String {
     }
 }
 
-pub fn get_vector_storage_path(segment_path: &Path, vector_name: &str) -> PathBuf {
+pub fn get_vector_storage_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
     segment_path.join(get_vector_name_with_prefix(
         VECTOR_STORAGE_PATH,
         vector_name,
     ))
 }
 
-pub fn get_vector_index_path(segment_path: &Path, vector_name: &str) -> PathBuf {
+pub fn get_vector_index_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
     segment_path.join(get_vector_name_with_prefix(VECTOR_INDEX_PATH, vector_name))
 }
 
@@ -97,7 +98,7 @@ pub(crate) fn open_vector_storage(
     vector_config: &VectorDataConfig,
     stopped: &AtomicBool,
     vector_storage_path: &Path,
-    vector_name: &str,
+    vector_name: &VectorName,
 ) -> OperationResult<VectorStorageEnum> {
     let storage_element_type = vector_config.datatype.unwrap_or_default();
 
@@ -497,7 +498,7 @@ pub(crate) fn create_sparse_vector_index(
 pub(crate) fn create_sparse_vector_storage(
     database: Arc<RwLock<DB>>,
     path: &Path,
-    vector_name: &str,
+    vector_name: &VectorName,
     storage_type: &SparseVectorStorageType,
     stopped: &AtomicBool,
 ) -> OperationResult<VectorStorageEnum> {

commit 64d5beb141dd17acbfc9d5ab58a81b41bef30b08
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jan 27 06:54:13 2025 +0000

    Pass `old_indices` to `HNSWIndex::new` (#5835)

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index b5eb8d55c..c2a90f6bd 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -374,6 +374,9 @@ pub(crate) struct VectorIndexOpenArgs<'a> {
 
 pub struct VectorIndexBuildArgs<'a> {
     pub permit: Arc<CpuPermit>,
+    /// Vector indices from other segments, used to speed up index building.
+    /// May or may not contain the same vectors.
+    pub old_indices: &'a [Arc<AtomicRefCell<VectorIndexEnum>>],
     pub gpu_device: Option<&'a LockedGpuDevice<'a>>,
     pub stopped: &'a AtomicBool,
 }

commit caed5729e5b7ff3db9dcb4531a4af0929b186682
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 09:05:00 2025 +0100

    IO resource usage permit (#6015)
    
    * rename cpu_budget -> resource_budget
    
    * clippy
    
    * add io budget to resources
    
    * fmt
    
    * move budget structures into a separate file
    
    * add extend permit function
    
    * dont extend existing permit
    
    * switch from IO to CPU permit
    
    * do not release resource before aquiring an extension
    
    * fmt
    
    * Review remarks
    
    * Improve resource permit number assertion
    
    * Make resource permit replace_with only acquire extra needed permits
    
    * Remove obsolete drop implementation
    
    * allocate IO budget same as CPU
    
    * review fixes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index c2a90f6bd..ab9e67547 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -6,7 +6,7 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
-use common::cpu::CpuPermit;
+use common::budget::ResourcePermit;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -373,7 +373,7 @@ pub(crate) struct VectorIndexOpenArgs<'a> {
 }
 
 pub struct VectorIndexBuildArgs<'a> {
-    pub permit: Arc<CpuPermit>,
+    pub permit: Arc<ResourcePermit>,
     /// Vector indices from other segments, used to speed up index building.
     /// May or may not contain the same vectors.
     pub old_indices: &'a [Arc<AtomicRefCell<VectorIndexEnum>>],

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index ab9e67547..264fed72e 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -2,8 +2,8 @@ use std::collections::HashMap;
 use std::fs::File;
 use std::io::Read;
 use std::path::{Path, PathBuf};
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
@@ -14,12 +14,13 @@ use rocksdb::DB;
 use serde::Deserialize;
 use uuid::Uuid;
 
-use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
-use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
+use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
+use crate::index::VectorIndexEnum;
 use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_vector_index::PlainVectorIndex;
@@ -28,12 +29,11 @@ use crate::index::sparse_index::sparse_vector_index::{
     self, SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::VectorIndexEnum;
 use crate::payload_storage::mmap_payload_storage::MmapPayloadStorage;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
+use crate::segment::{SEGMENT_STATE_FILE, Segment, SegmentVersion, VectorData};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
     SparseVectorStorageType, VectorDataConfig, VectorName, VectorStorageDatatype,

commit abf433e6c057686ca7770952a20219752af8a020
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Mar 19 13:37:54 2025 +0100

    Mutable ID tracker integration (#6174)
    
    * Rename mutable ID tracker mappings file
    
    * Make new ID tracker the default, add new variant for RocksDB tracker
    
    * In mutable ID tracker, only list files if they exist on disk
    
    * Don't use the new mutable ID tracker yet
    
    * Feature flag usage of new mutable ID tracker
    
    * Simplify RocksDB check a bit
    
    * Rename both the mutable ID tracker files

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 264fed72e..b792b5bf5 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -7,6 +7,7 @@ use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
+use common::flags::feature_flags;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -15,9 +16,10 @@ use serde::Deserialize;
 use uuid::Uuid;
 
 use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
-use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
+use crate::common::rocksdb_wrapper::{DB_MAPPING_CF, DB_VECTOR_CF, open_db};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
+use crate::id_tracker::mutable_id_tracker::{self, MutableIdTracker};
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::VectorIndexEnum;
@@ -348,7 +350,11 @@ pub(crate) fn create_payload_storage(
     Ok(payload_storage)
 }
 
-pub(crate) fn create_mutable_id_tracker(
+pub(crate) fn create_mutable_id_tracker(segment_path: &Path) -> OperationResult<MutableIdTracker> {
+    MutableIdTracker::open(segment_path)
+}
+
+pub(crate) fn create_rocksdb_id_tracker(
     database: Arc<RwLock<DB>>,
 ) -> OperationResult<SimpleIdTracker> {
     SimpleIdTracker::open(database)
@@ -536,9 +542,43 @@ fn create_segment(
         appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
 
     let id_tracker = if mutable_id_tracker {
-        sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
-            database.clone(),
-        )?))
+        let default_new_tracker = feature_flags().use_mutable_id_tracker_without_rocksdb;
+
+        // Determine whether we use the new (file based) or old (RocksDB) mutable ID tracker
+        // Decide based on the feature flag and state on disk
+        let use_new_mutable_tracker = if default_new_tracker {
+            // New ID tracker is enabled by default, but we still use the old tracker if we have
+            // any mappings stored in RocksDB
+            // TODO(1.15 or later): remove this check and use new mutable ID tracker unconditionally
+            let db = database.read();
+            match db.cf_handle(DB_MAPPING_CF) {
+                Some(cf_handle) => {
+                    let count = db
+                        .property_int_value_cf(cf_handle, rocksdb::properties::ESTIMATE_NUM_KEYS)
+                        .map_err(|err| {
+                            OperationError::service_error(format!(
+                                "Failed to get estimated number of keys from RocksDB: {err}"
+                            ))
+                        })?
+                        .unwrap_or_default();
+                    count == 0
+                }
+                None => true,
+            }
+        } else {
+            // New ID tracker is not enabled by default, only use it if its mappings are already on disk
+            mutable_id_tracker::mappings_path(segment_path).is_file()
+        };
+
+        if use_new_mutable_tracker {
+            sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
+                segment_path,
+            )?))
+        } else {
+            sp(IdTrackerEnum::RocksDbIdTracker(create_rocksdb_id_tracker(
+                database.clone(),
+            )?))
+        }
     } else {
         sp(IdTrackerEnum::ImmutableIdTracker(
             create_immutable_id_tracker(segment_path)?,

commit f230629fa0e62e069e683cce60e24319ab3cc84b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 25 10:08:21 2025 +0100

    build(deps): bump log from 0.4.26 to 0.4.27 (#6247)
    
    * build(deps): bump log from 0.4.26 to 0.4.27
    
    Bumps [log](https://github.com/rust-lang/log) from 0.4.26 to 0.4.27.
    - [Release notes](https://github.com/rust-lang/log/releases)
    - [Changelog](https://github.com/rust-lang/log/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/rust-lang/log/compare/0.4.26...0.4.27)
    
    ---
    updated-dependencies:
    - dependency-name: log
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * put variables inside the strings for log macros
    
    * also for pyroscope
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index b792b5bf5..464b9c2b7 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -763,7 +763,7 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
     let app_version = SegmentVersion::current();
 
     if stored_version != app_version {
-        info!("Migrating segment {} -> {}", stored_version, app_version,);
+        info!("Migrating segment {stored_version} -> {app_version}");
 
         if stored_version > app_version {
             return Err(OperationError::service_error(format!(

commit 7a1a96e22be04e68ed899c3cd4f0e366f8db327e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 18:56:53 2025 +0000

    Incremental HNSW index building: append-only case  (#6325)
    
    * Pass FeatureFlags into VectorIndexBuildArgs
    
    * Incremental HNSW index building: append-only case
    
    * Use debug_assert
    
    * first_few_ids
    
    * Check deleted_point_count
    
    * Drop unused method

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index 464b9c2b7..f9a590704 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -7,7 +7,7 @@ use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
-use common::flags::feature_flags;
+use common::flags::{FeatureFlags, feature_flags};
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -385,6 +385,7 @@ pub struct VectorIndexBuildArgs<'a> {
     pub old_indices: &'a [Arc<AtomicRefCell<VectorIndexEnum>>],
     pub gpu_device: Option<&'a LockedGpuDevice<'a>>,
     pub stopped: &'a AtomicBool,
+    pub feature_flags: FeatureFlags,
 }
 
 pub(crate) fn open_vector_index(

commit a6d57e910a4d5d3bfc52bd134c417586baaa5469
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 21 00:13:40 2025 +0200

    Qdrant 1.14: enable mutable ID tracker by default (#6268)
    
    * Enable mutable ID tracker by default
    
    * Remove now obsolete feature flag for new mutable ID tracker

diff --git a/lib/segment/src/segment_constructor/segment_constructor_base.rs b/lib/segment/src/segment_constructor/segment_constructor_base.rs
index f9a590704..4f81bdcf9 100644
--- a/lib/segment/src/segment_constructor/segment_constructor_base.rs
+++ b/lib/segment/src/segment_constructor/segment_constructor_base.rs
@@ -7,7 +7,7 @@ use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
-use common::flags::{FeatureFlags, feature_flags};
+use common::flags::FeatureFlags;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -19,7 +19,7 @@ use crate::common::operation_error::{OperationError, OperationResult, check_proc
 use crate::common::rocksdb_wrapper::{DB_MAPPING_CF, DB_VECTOR_CF, open_db};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
-use crate::id_tracker::mutable_id_tracker::{self, MutableIdTracker};
+use crate::id_tracker::mutable_id_tracker::MutableIdTracker;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
 use crate::index::VectorIndexEnum;
@@ -543,11 +543,9 @@ fn create_segment(
         appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
 
     let id_tracker = if mutable_id_tracker {
-        let default_new_tracker = feature_flags().use_mutable_id_tracker_without_rocksdb;
-
         // Determine whether we use the new (file based) or old (RocksDB) mutable ID tracker
         // Decide based on the feature flag and state on disk
-        let use_new_mutable_tracker = if default_new_tracker {
+        let use_new_mutable_tracker = {
             // New ID tracker is enabled by default, but we still use the old tracker if we have
             // any mappings stored in RocksDB
             // TODO(1.15 or later): remove this check and use new mutable ID tracker unconditionally
@@ -566,9 +564,6 @@ fn create_segment(
                 }
                 None => true,
             }
-        } else {
-            // New ID tracker is not enabled by default, only use it if its mappings are already on disk
-            mutable_id_tracker::mappings_path(segment_path).is_file()
         };
 
         if use_new_mutable_tracker {

