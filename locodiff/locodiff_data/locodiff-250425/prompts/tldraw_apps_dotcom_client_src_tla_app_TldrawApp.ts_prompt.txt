# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- apps/dotcom/client/src/tla/app/TldrawApp.ts

commit 9894eb43b99ee673f0d42cd4a7069c83865ded7d
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Oct 21 14:26:32 2024 +0100

    botcom: account menu [bk] (#4683)
    
    [bk=burger king, as Alex says] kinda funky b/c i'm doing these
    MaybeProviders in `TlaRootProviders.tsx`. but it does work. lemme know
    what you think — we can rework from here.
    
    <img width="708" alt="Screenshot 2024-10-07 at 22 12 33"
    src="https://github.com/user-attachments/assets/554be50a-1842-4659-adff-dfed8fc4e0a5">
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
new file mode 100644
index 000000000..c1398911a
--- /dev/null
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -0,0 +1,394 @@
+import {
+	TldrawAppFile,
+	TldrawAppFileEdit,
+	TldrawAppFileEditRecordType,
+	TldrawAppFileId,
+	TldrawAppFileRecordType,
+	TldrawAppFileVisitRecordType,
+	TldrawAppRecord,
+	TldrawAppUser,
+	TldrawAppUserId,
+	TldrawAppUserRecordType,
+	UserPreferencesKeys,
+} from '@tldraw/dotcom-shared'
+import pick from 'lodash.pick'
+import {
+	Store,
+	TLStoreSnapshot,
+	TLUserPreferences,
+	assertExists,
+	computed,
+	createTLUser,
+	getUserPreferences,
+} from 'tldraw'
+import { globalEditor } from '../../utils/globalEditor'
+import { getCurrentEditor } from '../utils/getCurrentEditor'
+import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
+
+export class TldrawApp {
+	private constructor(store: Store<TldrawAppRecord>) {
+		this.store = store
+
+		// todo: replace this when we have application-level user preferences
+		this.store.sideEffects.registerAfterChangeHandler('session', (prev, next) => {
+			if (prev.theme !== next.theme) {
+				const editor = globalEditor.get()
+				if (!editor) return
+				const editorIsDark = editor.user.getIsDarkMode()
+				const appIsDark = next.theme === 'dark'
+				if (appIsDark && !editorIsDark) {
+					editor.user.updateUserPreferences({ colorScheme: 'dark' })
+				} else if (!appIsDark && editorIsDark) {
+					editor.user.updateUserPreferences({ colorScheme: 'light' })
+				}
+			}
+		})
+	}
+
+	store: Store<TldrawAppRecord>
+
+	dispose() {
+		this.store.dispose()
+	}
+
+	tlUser = createTLUser({
+		userPreferences: computed('user prefs', () => {
+			const userId = this.getCurrentUserId()
+			if (!userId) throw Error('no user')
+			const user = this.getUser(userId)
+			return pick(user, UserPreferencesKeys) as TLUserPreferences
+		}),
+		setUserPreferences: (prefs: Partial<TLUserPreferences>) => {
+			const user = this.getCurrentUser()
+			if (!user) throw Error('no user')
+
+			this.store.put([
+				{
+					...user,
+					...(prefs as TldrawAppUser),
+				},
+			])
+		},
+	})
+
+	getAll<T extends TldrawAppRecord['typeName']>(
+		typeName: T
+	): (TldrawAppRecord & { typeName: T })[] {
+		return this.store.allRecords().filter((r) => r.typeName === typeName) as (TldrawAppRecord & {
+			typeName: T
+		})[]
+	}
+
+	get<T extends TldrawAppRecord>(id: T['id']): T | undefined {
+		return this.store.get(id) as T | undefined
+	}
+
+	getUser(userId: TldrawAppUserId): TldrawAppUser | undefined {
+		return this.get(userId)
+	}
+
+	getUserOwnFiles() {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		return Array.from(new Set(this.getAll('file').filter((f) => f.ownerId === user.id)))
+	}
+
+	getUserFileEdits() {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		return this.store.allRecords().filter((r) => {
+			if (r.typeName !== 'file-edit') return
+			if (r.ownerId !== user.id) return
+			return true
+		}) as TldrawAppFileEdit[]
+	}
+
+	getCurrentUserId() {
+		return assertExists(getLocalSessionStateUnsafe().auth).userId
+	}
+
+	getCurrentUser() {
+		const user = this.getUser(this.getCurrentUserId())
+		if (!user?.id) {
+			throw Error('no user')
+		}
+		return assertExists(user, 'no current user')
+	}
+
+	getUserRecentFiles(sessionStart: number) {
+		const userId = this.getCurrentUserId()
+
+		// Now look at which files the user has edited
+		const fileEditRecords = this.getUserFileEdits()
+
+		// Incluude any files that the user has edited
+		const fileRecords = fileEditRecords
+			.map((r) => this.get(r.fileId))
+			.filter(Boolean) as TldrawAppFile[]
+
+		// A map of file IDs to the most recent date we have for them
+		// the default date is the file's creation date; but we'll use the
+		// file edits to get the most recent edit that occurred before the
+		// current session started.
+		const filesToDates = Object.fromEntries(
+			fileRecords.map((file) => [
+				file.id,
+				{
+					file,
+					date: file.createdAt,
+					isOwnFile: file.ownerId === userId,
+				},
+			])
+		)
+
+		for (const fileEdit of fileEditRecords) {
+			// Skip file edits that happened in the current or later sessions
+			if (fileEdit.sessionStartedAt >= sessionStart) continue
+
+			// Check the current time that we have for the file
+			const item = filesToDates[fileEdit.fileId]
+			if (!item) continue
+
+			// If this edit has a more recent file open time, replace the item's date
+			if (item.date < fileEdit.fileOpenedAt) {
+				item.date = fileEdit.fileOpenedAt
+			}
+		}
+
+		// Sort the file pairs by date
+		return Object.values(filesToDates).sort((a, b) => b.date - a.date)
+	}
+
+	getUserSharedFiles() {
+		const userId = this.getCurrentUserId()
+		return Array.from(
+			new Set(
+				this.getAll('file-visit')
+					.filter((r) => r.ownerId === userId)
+					.map((s) => {
+						const file = this.get<TldrawAppFile>(s.fileId)
+						if (!file) return
+						// skip files where the owner is the current user
+						if (file.ownerId === userId) return
+						return file
+					})
+					.filter(Boolean) as TldrawAppFile[]
+			)
+		)
+	}
+
+	createFile(fileId?: TldrawAppFileId) {
+		const file = TldrawAppFileRecordType.create({
+			ownerId: this.getCurrentUserId(),
+			isEmpty: true,
+			id: fileId ?? TldrawAppFileRecordType.createId(),
+		})
+		this.store.put([file])
+		return file
+	}
+
+	getFileName(fileId: TldrawAppFileId) {
+		const file = this.store.get(fileId)
+		if (!file) return null
+		return TldrawApp.getFileName(file)
+	}
+
+	claimTemporaryFile(fileId: TldrawAppFileId) {
+		// TODO(david): check that you can't claim someone else's file (the db insert should fail and trigger a resync)
+		this.store.put([
+			TldrawAppFileRecordType.create({
+				id: fileId,
+				ownerId: this.getCurrentUserId(),
+			}),
+		])
+	}
+
+	getFileCollaborators(fileId: TldrawAppFileId): TldrawAppUserId[] {
+		const file = this.store.get(fileId)
+		if (!file) throw Error('no auth')
+
+		const users = this.getAll('user')
+
+		return users.filter((user) => user.presence.fileIds.includes(fileId)).map((user) => user.id)
+	}
+
+	toggleFileShared(fileId: TldrawAppFileId) {
+		const userId = this.getCurrentUserId()
+
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+
+		if (userId !== file.ownerId) {
+			throw Error('user cannot edit that file')
+		}
+
+		this.store.put([{ ...file, shared: !file.shared }])
+	}
+
+	setFileSharedLinkType(
+		fileId: TldrawAppFileId,
+		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
+	) {
+		const userId = this.getCurrentUserId()
+
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+
+		if (userId !== file.ownerId) {
+			throw Error('user cannot edit that file')
+		}
+
+		if (sharedLinkType === 'no-access') {
+			this.store.put([{ ...file, shared: false }])
+			return
+		}
+
+		this.store.put([{ ...file, sharedLinkType, shared: true }])
+	}
+
+	duplicateFile(fileId: TldrawAppFileId) {
+		const userId = this.getCurrentUserId()
+
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+
+		const newFile = TldrawAppFileRecordType.create({
+			...file,
+			id: TldrawAppFileRecordType.createId(),
+			ownerId: userId,
+			// todo: maybe iterate the file name
+			createdAt: Date.now(),
+		})
+
+		const editorStoreSnapshot = getCurrentEditor()?.store.getStoreSnapshot()
+		this.store.put([newFile])
+
+		return { newFile, editorStoreSnapshot }
+	}
+
+	async deleteFile(_fileId: TldrawAppFileId) {
+		// TODO we still need to remove the file completely - you can still visit this file if you have the link.
+		this.store.remove([_fileId])
+	}
+
+	async createFilesFromTldrFiles(_snapshots: TLStoreSnapshot[]) {
+		// todo: upload the files to the server and create files locally
+		console.warn('tldraw file uploads are not implemented yet, but you are in the right place')
+		return new Promise((r) => setTimeout(r, 2000))
+	}
+
+	async createSnapshotLink(_userId: TldrawAppUserId, _fileId: TldrawAppFileId) {
+		// todo: create a snapshot link on the server and return the url
+		console.warn('snapshot links are not implemented yet, but you are in the right place')
+		return new Promise((r) => setTimeout(r, 2000))
+	}
+
+	onFileEnter(fileId: TldrawAppFileId) {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		this.store.put([
+			TldrawAppFileVisitRecordType.create({
+				ownerId: user.id,
+				fileId,
+			}),
+			{
+				...user,
+				presence: {
+					...user.presence,
+					fileIds: [...user.presence.fileIds.filter((id) => id !== fileId), fileId],
+				},
+			},
+		])
+	}
+
+	updateUserExportPreferences(
+		exportPreferences: Partial<
+			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
+		>
+	) {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		this.store.put([{ ...user, ...exportPreferences }])
+	}
+
+	onFileEdit(fileId: TldrawAppFileId, sessionStartedAt: number, fileOpenedAt: number) {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		// Find the store's most recent file edit record for this user
+		const fileEdit = this.store
+			.allRecords()
+			.filter((r) => r.typeName === 'file-edit' && r.fileId === fileId && r.ownerId === user.id)
+			.sort((a, b) => b.createdAt - a.createdAt)[0] as TldrawAppFileEdit | undefined
+
+		// If the most recent file edit is part of this session or a later session, ignore it
+		if (fileEdit && fileEdit.createdAt >= fileOpenedAt) {
+			return
+		}
+
+		// Create the file edit record
+		this.store.put([
+			TldrawAppFileEditRecordType.create({
+				ownerId: user.id,
+				fileId,
+				sessionStartedAt,
+				fileOpenedAt,
+			}),
+		])
+	}
+
+	onFileExit(fileId: TldrawAppFileId) {
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+
+		this.store.put([
+			{
+				...user,
+				presence: {
+					...user.presence,
+					fileIds: user.presence.fileIds.filter((id) => id !== fileId),
+				},
+			},
+		])
+	}
+
+	static async create(opts: {
+		userId: string
+		fullName: string
+		email: string
+		avatar: string
+		store: Store<TldrawAppRecord>
+	}) {
+		const { store } = opts
+
+		// This is an issue: we may have a user record but not in the store.
+		// Could be just old accounts since before the server had a version
+		// of the store... but we should probably identify that better.
+		const userId = TldrawAppUserRecordType.createId(opts.userId)
+
+		const user = store.get(userId)
+		if (!user) {
+			const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
+			store.put([
+				TldrawAppUserRecordType.create({
+					id: userId,
+					ownerId: userId,
+					name: opts.fullName,
+					email: opts.email,
+					color: 'salmon',
+					avatar: opts.avatar,
+					presence: {
+						fileIds: [],
+					},
+					...restOfPreferences,
+				}),
+			])
+		}
+
+		const app = new TldrawApp(store)
+		return { app, userId }
+	}
+
+	static getFileName(file: TldrawAppFile) {
+		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
+	}
+}

commit b3e308b2d497eab2840ece99554115258a3db04b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Oct 22 14:07:05 2024 +0100

    [botcom] Fix file deletion and creation (#4751)
    
    - make file deletion work properly
    - There was a problem with one of the sql queries preventing the records
    from being removed
    - Need to also kick people out of the room when the file is deleted and
    remove the blob from R2
    - fix the file creation interaction (was not showing up in sidebar)
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index c1398911a..eadc1f4d9 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -20,6 +20,7 @@ import {
 	computed,
 	createTLUser,
 	getUserPreferences,
+	uniq,
 } from 'tldraw'
 import { globalEditor } from '../../utils/globalEditor'
 import { getCurrentEditor } from '../utils/getCurrentEditor'
@@ -122,9 +123,13 @@ export class TldrawApp {
 		const fileEditRecords = this.getUserFileEdits()
 
 		// Incluude any files that the user has edited
-		const fileRecords = fileEditRecords
-			.map((r) => this.get(r.fileId))
-			.filter(Boolean) as TldrawAppFile[]
+		const fileRecords = uniq([
+			...this.getUserOwnFiles(),
+			...(fileEditRecords
+				.map((r) => this.get(r.fileId))
+				.concat()
+				.filter(Boolean) as TldrawAppFile[]),
+		])
 
 		// A map of file IDs to the most recent date we have for them
 		// the default date is the file's creation date; but we'll use the
@@ -267,7 +272,6 @@ export class TldrawApp {
 	}
 
 	async deleteFile(_fileId: TldrawAppFileId) {
-		// TODO we still need to remove the file completely - you can still visit this file if you have the link.
 		this.store.remove([_fileId])
 	}
 

commit 42812e6141b09480393c2d48c017abf33af09b93
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Oct 23 17:31:53 2024 +0200

    [botcom] Publishing (#4688)
    
    Adds publishing to botcom.
    
    This allows the users to publish the existing document. This is a point
    in time snapshot, which they can then update or delete at a later time.
    Only the owner of the file has the permission to do that, while everyone
    with a link can view the published document.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Add publishing to botcom.
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index eadc1f4d9..a8b1f63d5 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,4 +1,6 @@
 import {
+	CreateSnapshotRequestBody,
+	CreateSnapshotResponseBody,
 	TldrawAppFile,
 	TldrawAppFileEdit,
 	TldrawAppFileEditRecordType,
@@ -11,8 +13,10 @@ import {
 	TldrawAppUserRecordType,
 	UserPreferencesKeys,
 } from '@tldraw/dotcom-shared'
+import { Result, fetch } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
+	Editor,
 	Store,
 	TLStoreSnapshot,
 	TLUserPreferences,
@@ -23,9 +27,12 @@ import {
 	uniq,
 } from 'tldraw'
 import { globalEditor } from '../../utils/globalEditor'
+import { getSnapshotData } from '../../utils/sharing'
 import { getCurrentEditor } from '../utils/getCurrentEditor'
 import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
 
+export const PUBLISH_ENDPOINT = `/api/app/publish`
+
 export class TldrawApp {
 	private constructor(store: Store<TldrawAppRecord>) {
 		this.store = store
@@ -218,18 +225,24 @@ export class TldrawApp {
 	}
 
 	toggleFileShared(fileId: TldrawAppFileId) {
-		const userId = this.getCurrentUserId()
-
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
 
-		if (userId !== file.ownerId) {
-			throw Error('user cannot edit that file')
-		}
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
 		this.store.put([{ ...file, shared: !file.shared }])
 	}
 
+	setFilePublished(fileId: TldrawAppFileId, value: boolean) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+
+		if (value === file.published) return
+
+		this.store.put([{ ...file, published: value }])
+	}
+
 	setFileSharedLinkType(
 		fileId: TldrawAppFileId,
 		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
@@ -271,6 +284,12 @@ export class TldrawApp {
 		return { newFile, editorStoreSnapshot }
 	}
 
+	isFileOwner(fileId: TldrawAppFileId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) return false
+		return file.ownerId === this.getCurrentUserId()
+	}
+
 	async deleteFile(_fileId: TldrawAppFileId) {
 		this.store.remove([_fileId])
 	}
@@ -281,10 +300,32 @@ export class TldrawApp {
 		return new Promise((r) => setTimeout(r, 2000))
 	}
 
-	async createSnapshotLink(_userId: TldrawAppUserId, _fileId: TldrawAppFileId) {
-		// todo: create a snapshot link on the server and return the url
-		console.warn('snapshot links are not implemented yet, but you are in the right place')
-		return new Promise((r) => setTimeout(r, 2000))
+	async createSnapshotLink(editor: Editor, parentSlug: string, fileSlug: string, token: string) {
+		const data = await getSnapshotData(editor)
+
+		if (!data) return Result.err('could not get snapshot data')
+
+		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
+
+		const res = await fetch(endpoint, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+			body: JSON.stringify({
+				snapshot: data,
+				schema: editor.store.schema.serialize(),
+				parent_slug: parentSlug,
+			} satisfies CreateSnapshotRequestBody),
+		})
+		const response = (await res.json()) as CreateSnapshotResponseBody
+
+		if (!res.ok || response.error) {
+			console.error(await res.text())
+			return Result.err('could not create snapshot')
+		}
+		return Result.ok('success')
 	}
 
 	onFileEnter(fileId: TldrawAppFileId) {

commit 6644f01d46533a79e72638730d41d5ea3c1ad9b9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Oct 23 17:44:11 2024 +0100

    [botcom] Shared file fixes (#4761)
    
    making it so that
    
    - you can't rename other people's files
    - you can't delete other people's files
    - shared files appear immediately in your nav menu
    - you can't change the share settings of other people's files
    
    ### Change type
    
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index a8b1f63d5..c693dbf56 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -290,8 +290,19 @@ export class TldrawApp {
 		return file.ownerId === this.getCurrentUserId()
 	}
 
-	async deleteFile(_fileId: TldrawAppFileId) {
-		this.store.remove([_fileId])
+	async deleteOrForgetFile(fileId: TldrawAppFileId) {
+		if (this.isFileOwner(fileId)) {
+			this.store.remove([fileId])
+		} else {
+			const myId = this.getCurrentUserId()
+			const fileVisits = this.getAll('file-visit')
+				.filter((r) => r.fileId === fileId && r.ownerId === myId)
+				.map((r) => r.id)
+			const fileEdits = this.getAll('file-edit')
+				.filter((r) => r.ownerId === myId && r.fileId === fileId)
+				.map((r) => r.id)
+			this.store.remove([...fileVisits, ...fileEdits])
+		}
 	}
 
 	async createFilesFromTldrFiles(_snapshots: TLStoreSnapshot[]) {

commit 275d500ca9eba0c9da632344a094e1c5b82d7ad4
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Oct 24 14:50:28 2024 +0100

    [botcom] file state (#4766)
    
    This PR
    
    - Replaces the file-edit and file-view records with a single record
    called `file-state` that has timestamps for first view and most recent
    edit.
    - Uses the above to simplify the recent files sorting (maintains the
    same behaviour, just achieves it with simpler code)
    - removes unused presence stuff (should have been removed back in that
    burn-it-all-down pr after we merged the prototype), we can add the UI
    bits back when we work on file-level presence.
    - Stores the UI state in the db so you go back to where you were before
    in the file next time you open the file
    
    implements INT-342
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index c693dbf56..8602af3c9 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -2,11 +2,9 @@ import {
 	CreateSnapshotRequestBody,
 	CreateSnapshotResponseBody,
 	TldrawAppFile,
-	TldrawAppFileEdit,
-	TldrawAppFileEditRecordType,
 	TldrawAppFileId,
 	TldrawAppFileRecordType,
-	TldrawAppFileVisitRecordType,
+	TldrawAppFileStateRecordType,
 	TldrawAppRecord,
 	TldrawAppUser,
 	TldrawAppUserId,
@@ -18,13 +16,16 @@ import pick from 'lodash.pick'
 import {
 	Editor,
 	Store,
+	TLSessionStateSnapshot,
 	TLStoreSnapshot,
 	TLUserPreferences,
 	assertExists,
 	computed,
 	createTLUser,
 	getUserPreferences,
-	uniq,
+	objectMapFromEntries,
+	objectMapKeys,
+	transact,
 } from 'tldraw'
 import { globalEditor } from '../../utils/globalEditor'
 import { getSnapshotData } from '../../utils/sharing'
@@ -101,16 +102,6 @@ export class TldrawApp {
 		return Array.from(new Set(this.getAll('file').filter((f) => f.ownerId === user.id)))
 	}
 
-	getUserFileEdits() {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		return this.store.allRecords().filter((r) => {
-			if (r.typeName !== 'file-edit') return
-			if (r.ownerId !== user.id) return
-			return true
-		}) as TldrawAppFileEdit[]
-	}
-
 	getCurrentUserId() {
 		return assertExists(getLocalSessionStateUnsafe().auth).userId
 	}
@@ -123,59 +114,54 @@ export class TldrawApp {
 		return assertExists(user, 'no current user')
 	}
 
-	getUserRecentFiles(sessionStart: number) {
-		const userId = this.getCurrentUserId()
-
-		// Now look at which files the user has edited
-		const fileEditRecords = this.getUserFileEdits()
+	lastRecentFileOrdering = null as null | Array<{ fileId: TldrawAppFileId; date: number }>
 
-		// Incluude any files that the user has edited
-		const fileRecords = uniq([
-			...this.getUserOwnFiles(),
-			...(fileEditRecords
-				.map((r) => this.get(r.fileId))
-				.concat()
-				.filter(Boolean) as TldrawAppFile[]),
-		])
+	getUserRecentFiles() {
+		const userId = this.getCurrentUserId()
 
-		// A map of file IDs to the most recent date we have for them
-		// the default date is the file's creation date; but we'll use the
-		// file edits to get the most recent edit that occurred before the
-		// current session started.
-		const filesToDates = Object.fromEntries(
-			fileRecords.map((file) => [
-				file.id,
-				{
-					file,
-					date: file.createdAt,
-					isOwnFile: file.ownerId === userId,
-				},
-			])
+		const myFiles = objectMapFromEntries(
+			this.getAll('file')
+				.filter((f) => f.ownerId === userId)
+				.map((f) => [f.id, f])
+		)
+		const myStates = objectMapFromEntries(
+			this.getAll('file-state')
+				.filter((f) => f.ownerId === userId)
+				.map((f) => [f.fileId, f])
 		)
 
-		for (const fileEdit of fileEditRecords) {
-			// Skip file edits that happened in the current or later sessions
-			if (fileEdit.sessionStartedAt >= sessionStart) continue
+		const myFileIds = new Set<TldrawAppFileId>([
+			...objectMapKeys(myFiles),
+			...objectMapKeys(myStates),
+		])
 
-			// Check the current time that we have for the file
-			const item = filesToDates[fileEdit.fileId]
-			if (!item) continue
+		const nextRecentFileOrdering = []
 
-			// If this edit has a more recent file open time, replace the item's date
-			if (item.date < fileEdit.fileOpenedAt) {
-				item.date = fileEdit.fileOpenedAt
+		for (const fileId of myFileIds) {
+			const existing = this.lastRecentFileOrdering?.find((f) => f.fileId === fileId)
+			if (existing) {
+				nextRecentFileOrdering.push(existing)
+				continue
 			}
+			const file = myFiles[fileId]
+			const state = myStates[fileId]
+
+			nextRecentFileOrdering.push({
+				fileId,
+				date: state?.lastEditAt ?? state?.firstVisitAt ?? file?.createdAt ?? 0,
+			})
 		}
 
-		// Sort the file pairs by date
-		return Object.values(filesToDates).sort((a, b) => b.date - a.date)
+		nextRecentFileOrdering.sort((a, b) => b.date - a.date)
+		this.lastRecentFileOrdering = nextRecentFileOrdering
+		return nextRecentFileOrdering
 	}
 
 	getUserSharedFiles() {
 		const userId = this.getCurrentUserId()
 		return Array.from(
 			new Set(
-				this.getAll('file-visit')
+				this.getAll('file-state')
 					.filter((r) => r.ownerId === userId)
 					.map((s) => {
 						const file = this.get<TldrawAppFile>(s.fileId)
@@ -201,8 +187,8 @@ export class TldrawApp {
 
 	getFileName(fileId: TldrawAppFileId) {
 		const file = this.store.get(fileId)
-		if (!file) return null
-		return TldrawApp.getFileName(file)
+		if (!file) return undefined
+		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
 	}
 
 	claimTemporaryFile(fileId: TldrawAppFileId) {
@@ -215,22 +201,22 @@ export class TldrawApp {
 		])
 	}
 
-	getFileCollaborators(fileId: TldrawAppFileId): TldrawAppUserId[] {
-		const file = this.store.get(fileId)
-		if (!file) throw Error('no auth')
-
-		const users = this.getAll('user')
-
-		return users.filter((user) => user.presence.fileIds.includes(fileId)).map((user) => user.id)
-	}
-
 	toggleFileShared(fileId: TldrawAppFileId) {
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
 
 		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
-		this.store.put([{ ...file, shared: !file.shared }])
+		transact(() => {
+			this.store.put([{ ...file, shared: !file.shared }])
+			// if it was shared, remove all shared links
+			if (file.shared) {
+				const states = this.getAll('file-state').filter(
+					(r) => r.fileId === fileId && r.ownerId !== file.ownerId
+				)
+				this.store.remove(states.map((r) => r.id))
+			}
+		})
 	}
 
 	setFilePublished(fileId: TldrawAppFileId, value: boolean) {
@@ -292,16 +278,18 @@ export class TldrawApp {
 
 	async deleteOrForgetFile(fileId: TldrawAppFileId) {
 		if (this.isFileOwner(fileId)) {
-			this.store.remove([fileId])
+			this.store.remove([
+				fileId,
+				...this.getAll('file-state')
+					.filter((r) => r.fileId === fileId)
+					.map((r) => r.id),
+			])
 		} else {
-			const myId = this.getCurrentUserId()
-			const fileVisits = this.getAll('file-visit')
-				.filter((r) => r.fileId === fileId && r.ownerId === myId)
-				.map((r) => r.id)
-			const fileEdits = this.getAll('file-edit')
-				.filter((r) => r.ownerId === myId && r.fileId === fileId)
+			const ownerId = this.getCurrentUserId()
+			const fileStates = this.getAll('file-state')
+				.filter((r) => r.fileId === fileId && r.ownerId === ownerId)
 				.map((r) => r.id)
-			this.store.remove([...fileVisits, ...fileEdits])
+			this.store.remove(fileStates)
 		}
 	}
 
@@ -339,24 +327,6 @@ export class TldrawApp {
 		return Result.ok('success')
 	}
 
-	onFileEnter(fileId: TldrawAppFileId) {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		this.store.put([
-			TldrawAppFileVisitRecordType.create({
-				ownerId: user.id,
-				fileId,
-			}),
-			{
-				...user,
-				presence: {
-					...user.presence,
-					fileIds: [...user.presence.fileIds.filter((id) => id !== fileId), fileId],
-				},
-			},
-		])
-	}
-
 	updateUserExportPreferences(
 		exportPreferences: Partial<
 			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
@@ -367,44 +337,51 @@ export class TldrawApp {
 		this.store.put([{ ...user, ...exportPreferences }])
 	}
 
-	onFileEdit(fileId: TldrawAppFileId, sessionStartedAt: number, fileOpenedAt: number) {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		// Find the store's most recent file edit record for this user
-		const fileEdit = this.store
-			.allRecords()
-			.filter((r) => r.typeName === 'file-edit' && r.fileId === fileId && r.ownerId === user.id)
-			.sort((a, b) => b.createdAt - a.createdAt)[0] as TldrawAppFileEdit | undefined
-
-		// If the most recent file edit is part of this session or a later session, ignore it
-		if (fileEdit && fileEdit.createdAt >= fileOpenedAt) {
-			return
+	getOrCreateFileState(fileId: TldrawAppFileId) {
+		let fileState = this.getFileState(fileId)
+		const ownerId = this.getCurrentUserId()
+		if (!fileState) {
+			fileState = TldrawAppFileStateRecordType.create({
+				fileId,
+				ownerId,
+			})
+			this.store.put([fileState])
 		}
+		return fileState
+	}
 
-		// Create the file edit record
+	getFileState(fileId: TldrawAppFileId) {
+		const ownerId = this.getCurrentUserId()
+		return this.getAll('file-state').find((r) => r.ownerId === ownerId && r.fileId === fileId)
+	}
+
+	onFileEnter(fileId: TldrawAppFileId) {
+		const fileState = this.getOrCreateFileState(fileId)
+		if (fileState.firstVisitAt) return
 		this.store.put([
-			TldrawAppFileEditRecordType.create({
-				ownerId: user.id,
-				fileId,
-				sessionStartedAt,
-				fileOpenedAt,
-			}),
+			{ ...fileState, firstVisitAt: fileState.firstVisitAt ?? Date.now(), lastVisitAt: Date.now() },
 		])
 	}
 
-	onFileExit(fileId: TldrawAppFileId) {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
+	onFileEdit(fileId: TldrawAppFileId) {
+		// Find the store's most recent file state record for this user
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
 
-		this.store.put([
-			{
-				...user,
-				presence: {
-					...user.presence,
-					fileIds: user.presence.fileIds.filter((id) => id !== fileId),
-				},
-			},
-		])
+		// Create the file edit record
+		this.store.put([{ ...fileState, lastEditAt: Date.now() }])
+	}
+
+	onFileSessionStateUpdate(fileId: TldrawAppFileId, sessionState: TLSessionStateSnapshot) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
+		this.store.put([{ ...fileState, lastSessionState: sessionState, lastVisitAt: Date.now() }])
+	}
+
+	onFileExit(fileId: TldrawAppFileId) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
+		this.store.put([{ ...fileState, lastVisitAt: Date.now() }])
 	}
 
 	static async create(opts: {
@@ -432,9 +409,6 @@ export class TldrawApp {
 					email: opts.email,
 					color: 'salmon',
 					avatar: opts.avatar,
-					presence: {
-						fileIds: [],
-					},
 					...restOfPreferences,
 				}),
 			])
@@ -443,8 +417,4 @@ export class TldrawApp {
 		const app = new TldrawApp(store)
 		return { app, userId }
 	}
-
-	static getFileName(file: TldrawAppFile) {
-		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
-	}
 }

commit 63f003023fc7af4d25b1a5f4f33ad8c25256a39e
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Oct 24 15:35:00 2024 +0100

    [botcom] Add tooltips / links to Share Menu (#4765)
    
    <img width="745" alt="image"
    src="https://github.com/user-attachments/assets/74dd720b-beed-40a8-91ae-67cb974fc028">
    
    
    This PR:
    - adds help links to the share menu for sharing / publishing
    - stubs pages on notion for help content
    - removes the QR code from the publish tab
    - adds `lastPublished`
    - strips published data from file when publicating
    - removes copied toasts from menu
    - adds nice animation for updating published
    - adds one second of fake delay to update published
    
    ![Kapture 2024-10-24 at 15 02
    27](https://github.com/user-attachments/assets/ae9b114f-b9c7-48d8-a481-a769eb6ba5b5)
    
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 8602af3c9..67cf06c11 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -223,10 +223,15 @@ export class TldrawApp {
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
 		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
-
 		if (value === file.published) return
+		this.store.put([{ ...file, published: value, lastPublished: Date.now() }])
+	}
 
-		this.store.put([{ ...file, published: value }])
+	updateFileLastPublished(fileId: TldrawAppFileId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+		this.store.put([{ ...file, lastPublished: Date.now() }])
 	}
 
 	setFileSharedLinkType(
@@ -256,13 +261,17 @@ export class TldrawApp {
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
 
-		const newFile = TldrawAppFileRecordType.create({
+		const newFilePartial = {
 			...file,
 			id: TldrawAppFileRecordType.createId(),
 			ownerId: userId,
-			// todo: maybe iterate the file name
-			createdAt: Date.now(),
-		})
+		} as Partial<TldrawAppFile>
+		delete newFilePartial.createdAt
+		delete newFilePartial.lastPublished
+		delete newFilePartial.publishedSlug
+		delete newFilePartial.published
+
+		const newFile = TldrawAppFileRecordType.create(newFilePartial as TldrawAppFile)
 
 		const editorStoreSnapshot = getCurrentEditor()?.store.getStoreSnapshot()
 		this.store.put([newFile])

commit bc1a4d8c98f20460685fae3c28f34a630c9e2be7
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Oct 28 14:11:39 2024 +0000

    [botcom] Duplicate / Publish / Create / Delete files on the server  (#4798)
    
    This PR improves and creates functionality on the backend.
    
    For the most part, simple changes such as creating a file or changing
    its name rely on optimistic updates. However, some actions rely on
    either sending information to the server directly. While we can make
    optimistic updates in these situations, we also need to revert those
    changes if the request fails.
    
    ## Duplicating files
    
    This PR adds duplication on the server. Previously, the duplicate
    feature required that the duplicating file be open, so duplicating other
    files (from the sidebar) would duplicate the current open file instead.
    Now the server will pull the latest file from the tldraw worker and
    duplicate that instead.
    
    If the user is viewing the duplicated page, we redirect them to the new
    page.
    
    ## Deleting / forgetting files
    
    This PR adds deletion on the server. If the user owns a file, they will
    optimistically delete the file and all states associated with the file;
    if the user does not, then they'll only "forget" the file by
    optimistically deleting all of their own states associated with the
    file. Meanwhile, the server will actually delete the file and the file's
    published snapshot. If the delete fails, the user's optimistic updates
    will be reversed.
    
    If the user is viewing the deleted / forgotten file, we redirect them to
    the root.
    
    ## Publishing / un-publishing files
    
    This PR adds publishing on the server. Previously, the user would upload
    the current editor state to the server. Now, the server pulls the latest
    file from the tldraw worker and creates a published snapshot based on
    that instead.
    
    I'd still like to build the "publish history" of versions that a user
    has published for a given file, rather than overwriting the single
    published snapshot file.
    
    ## Creating files
    
    This PR adds support for .tldr file drops. Files are created on the
    server and then added to the user's own files.
    
    ## Cleanup
    
    The sync-worker was getting pretty messy so I did some cleanup. Mostly,
    I've moved the endpoints that are related to the app to a `tla` folder,
    as I've done elsewhere. It wasn't clear to me which endpoints were
    "purely" working for the app layer and which weren't.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 67cf06c11..d1718de54 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,20 +1,22 @@
 import {
-	CreateSnapshotRequestBody,
-	CreateSnapshotResponseBody,
+	CreateFilesResponseBody,
+	DuplicateRoomResponseBody,
+	PublishFileResponseBody,
 	TldrawAppFile,
 	TldrawAppFileId,
 	TldrawAppFileRecordType,
+	TldrawAppFileState,
 	TldrawAppFileStateRecordType,
 	TldrawAppRecord,
 	TldrawAppUser,
 	TldrawAppUserId,
 	TldrawAppUserRecordType,
+	UnpublishFileResponseBody,
 	UserPreferencesKeys,
 } from '@tldraw/dotcom-shared'
 import { Result, fetch } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	Editor,
 	Store,
 	TLSessionStateSnapshot,
 	TLStoreSnapshot,
@@ -28,11 +30,13 @@ import {
 	transact,
 } from 'tldraw'
 import { globalEditor } from '../../utils/globalEditor'
-import { getSnapshotData } from '../../utils/sharing'
-import { getCurrentEditor } from '../utils/getCurrentEditor'
 import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
 
+export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
+export const UNPUBLISH_ENDPOINT = `/api/app/unpublish`
+export const DUPLICATE_ENDPOINT = `/api/app/duplicate`
+export const FILE_ENDPOINT = `/api/app/file`
 
 export class TldrawApp {
 	private constructor(store: Store<TldrawAppRecord>) {
@@ -219,123 +223,246 @@ export class TldrawApp {
 		})
 	}
 
-	setFilePublished(fileId: TldrawAppFileId, value: boolean) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
-		if (value === file.published) return
-		this.store.put([{ ...file, published: value, lastPublished: Date.now() }])
+	/**
+	 * Create files from tldr files.
+	 *
+	 * @param snapshots - The snapshots to create files from.
+	 * @param token - The user's token.
+	 *
+	 * @returns The slugs of the created files.
+	 */
+	async createFilesFromTldrFiles(snapshots: TLStoreSnapshot[], token: string) {
+		const res = await fetch(TLDR_FILE_ENDPOINT, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+			body: JSON.stringify({
+				// convert to the annoyingly similar format that the server expects
+				snapshots: snapshots.map((s) => ({
+					snapshot: s.store,
+					schema: s.schema,
+				})),
+			}),
+		})
+
+		const response = (await res.json()) as CreateFilesResponseBody
+
+		if (!res.ok || response.error) {
+			throw Error('could not create files')
+		}
+
+		// Also create a file state record for the new file
+		this.store.put(
+			response.slugs.map((slug) =>
+				TldrawAppFileStateRecordType.create({
+					fileId: TldrawAppFileRecordType.createId(slug),
+					ownerId: this.getCurrentUserId(),
+					firstVisitAt: Date.now(),
+					lastVisitAt: Date.now(),
+					lastEditAt: Date.now(),
+				})
+			)
+		)
+
+		return { slugs: response.slugs }
+	}
+
+	/**
+	 * Duplicate a file.
+	 *
+	 * @param fileSlug - The file slug to duplicate.
+	 * @param token - The user's token.
+	 *
+	 * @returns A result indicating success or failure.
+	 */
+	async duplicateFile(fileSlug: string, token: string) {
+		const endpoint = `${DUPLICATE_ENDPOINT}/${fileSlug}`
+
+		const res = await fetch(endpoint, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+		})
+
+		const response = (await res.json()) as DuplicateRoomResponseBody
+
+		if (!res.ok || response.error) {
+			return Result.err('could not duplicate file')
+		}
+
+		// Also create a file state record for the new file
+
+		this.store.put([
+			TldrawAppFileStateRecordType.create({
+				fileId: TldrawAppFileRecordType.createId(response.slug),
+				ownerId: this.getCurrentUserId(),
+				firstVisitAt: Date.now(),
+				lastVisitAt: Date.now(),
+				lastEditAt: Date.now(),
+			}),
+		])
+
+		return Result.ok({ slug: response.slug })
 	}
 
-	updateFileLastPublished(fileId: TldrawAppFileId) {
+	/**
+	 * Publish a file or re-publish changes.
+	 *
+	 * @param fileId - The file id to unpublish.
+	 * @param token - The user's token.
+	 * @returns A result indicating success or failure.
+	 */
+	async publishFile(fileId: TldrawAppFileId, token: string) {
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
 		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
-		this.store.put([{ ...file, lastPublished: Date.now() }])
-	}
 
-	setFileSharedLinkType(
-		fileId: TldrawAppFileId,
-		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
-	) {
-		const userId = this.getCurrentUserId()
+		// We're going to bake the name of the file, if it's undefined
+		const name = this.getFileName(fileId)!
 
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
+		// Optimistic update
+		this.store.put([{ ...file, name, published: true, lastPublished: Date.now() }])
 
-		if (userId !== file.ownerId) {
-			throw Error('user cannot edit that file')
-		}
+		const fileSlug = fileId.split(':')[1]
 
-		if (sharedLinkType === 'no-access') {
-			this.store.put([{ ...file, shared: false }])
-			return
+		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
+
+		const res = await fetch(endpoint, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+		})
+
+		const response = (await res.json()) as PublishFileResponseBody
+
+		if (!res.ok || response.error) {
+			// Revert optimistic update
+			const latestFile = this.get(fileId) as TldrawAppFile
+			const { published, lastPublished } = file
+			this.store.put([{ ...latestFile, published, lastPublished }])
+
+			return Result.err('could not create snapshot')
 		}
 
-		this.store.put([{ ...file, sharedLinkType, shared: true }])
+		return Result.ok('success')
 	}
 
-	duplicateFile(fileId: TldrawAppFileId) {
-		const userId = this.getCurrentUserId()
-
+	/**
+	 * Unpublish a file.
+	 *
+	 * @param fileId - The file id to unpublish.
+	 * @param token - The user's token.
+	 * @returns A result indicating success or failure.
+	 */
+	async unpublishFile(fileId: TldrawAppFileId, token: string) {
 		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
-		const newFilePartial = {
-			...file,
-			id: TldrawAppFileRecordType.createId(),
-			ownerId: userId,
-		} as Partial<TldrawAppFile>
-		delete newFilePartial.createdAt
-		delete newFilePartial.lastPublished
-		delete newFilePartial.publishedSlug
-		delete newFilePartial.published
+		if (!file.published) return Result.ok('success')
 
-		const newFile = TldrawAppFileRecordType.create(newFilePartial as TldrawAppFile)
+		// Optimistic update
+		this.store.put([{ ...file, published: false }])
 
-		const editorStoreSnapshot = getCurrentEditor()?.store.getStoreSnapshot()
-		this.store.put([newFile])
+		const fileSlug = fileId.split(':')[1]
 
-		return { newFile, editorStoreSnapshot }
-	}
+		const res = await fetch(`${PUBLISH_ENDPOINT}/${fileSlug}`, {
+			method: 'DELETE',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+		})
 
-	isFileOwner(fileId: TldrawAppFileId) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) return false
-		return file.ownerId === this.getCurrentUserId()
-	}
+		const response = (await res.json()) as UnpublishFileResponseBody
 
-	async deleteOrForgetFile(fileId: TldrawAppFileId) {
-		if (this.isFileOwner(fileId)) {
-			this.store.remove([
-				fileId,
-				...this.getAll('file-state')
-					.filter((r) => r.fileId === fileId)
-					.map((r) => r.id),
-			])
-		} else {
-			const ownerId = this.getCurrentUserId()
-			const fileStates = this.getAll('file-state')
-				.filter((r) => r.fileId === fileId && r.ownerId === ownerId)
-				.map((r) => r.id)
-			this.store.remove(fileStates)
+		if (!res.ok || response.error) {
+			// Revert optimistic update
+			this.store.put([{ ...file, published: true }])
+			return Result.err('could not unpublish')
 		}
-	}
 
-	async createFilesFromTldrFiles(_snapshots: TLStoreSnapshot[]) {
-		// todo: upload the files to the server and create files locally
-		console.warn('tldraw file uploads are not implemented yet, but you are in the right place')
-		return new Promise((r) => setTimeout(r, 2000))
+		return Result.ok('success')
 	}
 
-	async createSnapshotLink(editor: Editor, parentSlug: string, fileSlug: string, token: string) {
-		const data = await getSnapshotData(editor)
+	/**
+	 * Remove a user's file states for a file and delete the file if the user is the owner of the file.
+	 *
+	 * @param fileId - The file id.
+	 * @param token - The user's token.
+	 */
+	async deleteOrForgetFile(fileId: TldrawAppFileId, token: string) {
+		// Stash these so that we can restore them later
+		let fileStates: TldrawAppFileState[]
+		const file = this.get(fileId) as TldrawAppFile
 
-		if (!data) return Result.err('could not get snapshot data')
+		if (this.isFileOwner(fileId)) {
+			// Optimistic update, remove file and file states
+			fileStates = this.getAll('file-state').filter((r) => r.fileId === fileId)
+			this.store.remove([fileId, ...fileStates.map((s) => s.id)])
+		} else {
+			// If not the owner, just remove the file state
+			const userId = this.getCurrentUserId()
+			fileStates = this.getAll('file-state').filter(
+				(r) => r.fileId === fileId && r.ownerId === userId
+			)
+			this.store.remove(fileStates.map((s) => s.id))
+		}
 
-		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
+		const fileSlug = fileId.split(':')[1]
 
-		const res = await fetch(endpoint, {
-			method: 'POST',
+		const res = await fetch(`${FILE_ENDPOINT}/${fileSlug}`, {
+			method: 'DELETE',
 			headers: {
 				'Content-Type': 'application/json',
 				Authorization: `Bearer ${token}`,
 			},
-			body: JSON.stringify({
-				snapshot: data,
-				schema: editor.store.schema.serialize(),
-				parent_slug: parentSlug,
-			} satisfies CreateSnapshotRequestBody),
 		})
-		const response = (await res.json()) as CreateSnapshotResponseBody
+
+		const response = (await res.json()) as UnpublishFileResponseBody
 
 		if (!res.ok || response.error) {
-			console.error(await res.text())
-			return Result.err('could not create snapshot')
+			// Revert optimistic update
+			this.store.put([file, ...fileStates])
+			return Result.err('could not delete')
 		}
+
 		return Result.ok('success')
 	}
 
+	setFileSharedLinkType(
+		fileId: TldrawAppFileId,
+		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
+	) {
+		const userId = this.getCurrentUserId()
+
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+
+		if (userId !== file.ownerId) {
+			throw Error('user cannot edit that file')
+		}
+
+		if (sharedLinkType === 'no-access') {
+			this.store.put([{ ...file, shared: false }])
+			return
+		}
+
+		this.store.put([{ ...file, sharedLinkType, shared: true }])
+	}
+
+	isFileOwner(fileId: TldrawAppFileId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) return false
+		return file.ownerId === this.getCurrentUserId()
+	}
+
 	updateUserExportPreferences(
 		exportPreferences: Partial<
 			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>

commit a40ff2bac72228b7b88d5ddfce47029bf4efa52a
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Oct 28 14:44:46 2024 +0000

    [botcom] add max file limit (#4806)
    
    This PR adds a maximum limit to the number of files a user can create.
    
    It adds a (provisional?) config property to the app for these constants.
    
    ### Change type
    
    - [x] `other`
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index d1718de54..56e16222e 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -39,6 +39,10 @@ export const DUPLICATE_ENDPOINT = `/api/app/duplicate`
 export const FILE_ENDPOINT = `/api/app/file`
 
 export class TldrawApp {
+	config = {
+		maxNumberOfFiles: 100,
+	}
+
 	private constructor(store: Store<TldrawAppRecord>) {
 		this.store = store
 
@@ -179,14 +183,27 @@ export class TldrawApp {
 		)
 	}
 
-	createFile(fileId?: TldrawAppFileId) {
+	private canCreateNewFile() {
+		const userId = this.getCurrentUserId()
+		const numberOfFiles = this.getAll('file').filter((f) => f.ownerId === userId).length
+		return numberOfFiles < this.config.maxNumberOfFiles
+	}
+
+	createFile(
+		fileId?: TldrawAppFileId
+	): Result<{ file: TldrawAppFile }, 'max number of files reached'> {
+		if (!this.canCreateNewFile()) {
+			return Result.err('max number of files reached')
+		}
+
 		const file = TldrawAppFileRecordType.create({
 			ownerId: this.getCurrentUserId(),
 			isEmpty: true,
 			id: fileId ?? TldrawAppFileRecordType.createId(),
 		})
 		this.store.put([file])
-		return file
+
+		return Result.ok({ file })
 	}
 
 	getFileName(fileId: TldrawAppFileId) {

commit d6246511b82c17ffe7c18333726ab865b82b0caf
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Oct 29 11:21:34 2024 +0000

    [botcom] Fix double presence (#4819)
    
    The user thing wasn't hooked up to sync properly
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 56e16222e..d06f352f0 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -73,16 +73,19 @@ export class TldrawApp {
 			const userId = this.getCurrentUserId()
 			if (!userId) throw Error('no user')
 			const user = this.getUser(userId)
-			return pick(user, UserPreferencesKeys) as TLUserPreferences
+			return {
+				...(pick(user, UserPreferencesKeys) as TLUserPreferences),
+				id: TldrawAppUserRecordType.parseId(userId),
+			}
 		}),
-		setUserPreferences: (prefs: Partial<TLUserPreferences>) => {
+		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
 			const user = this.getCurrentUser()
 			if (!user) throw Error('no user')
 
 			this.store.put([
 				{
 					...user,
-					...(prefs as TldrawAppUser),
+					...(others as TldrawAppUser),
 				},
 			])
 		},

commit ba8fa0e42fc2aa1ad678217fe05134ded8ca9b30
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Oct 30 15:02:45 2024 +0100

    Isolate tests by resetting the db between each test. (#4817)
    
    Resets the db between tests.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Isolates tests by resetting the db.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index d06f352f0..70730287d 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -29,6 +29,7 @@ import {
 	objectMapKeys,
 	transact,
 } from 'tldraw'
+import { isDevelopmentEnv } from '../../utils/env'
 import { globalEditor } from '../../utils/globalEditor'
 import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
 
@@ -45,6 +46,9 @@ export class TldrawApp {
 
 	private constructor(store: Store<TldrawAppRecord>) {
 		this.store = store
+		if (isDevelopmentEnv) {
+			;(window as any).tla_dev_clear = () => this.store.clear()
+		}
 
 		// todo: replace this when we have application-level user preferences
 		this.store.sideEffects.registerAfterChangeHandler('session', (prev, next) => {

commit 51310c28a1933528586ca540c039289c3e7de496
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:10:41 2024 +0000

    [wip] custom botcom backend (#4879)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug with…
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 70730287d..40818caa2 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,154 +1,177 @@
+// import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
 import {
 	CreateFilesResponseBody,
-	DuplicateRoomResponseBody,
-	PublishFileResponseBody,
-	TldrawAppFile,
-	TldrawAppFileId,
-	TldrawAppFileRecordType,
-	TldrawAppFileState,
-	TldrawAppFileStateRecordType,
-	TldrawAppRecord,
-	TldrawAppUser,
-	TldrawAppUserId,
-	TldrawAppUserRecordType,
-	UnpublishFileResponseBody,
+	TlaFile,
+	TlaFileState,
+	TlaUser,
 	UserPreferencesKeys,
 } from '@tldraw/dotcom-shared'
-import { Result, fetch } from '@tldraw/utils'
+import { Result, assert, fetch, structuredClone, uniqueId } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	Store,
+	Signal,
 	TLSessionStateSnapshot,
 	TLStoreSnapshot,
+	TLUiToastsContextType,
 	TLUserPreferences,
 	assertExists,
+	atom,
 	computed,
 	createTLUser,
 	getUserPreferences,
 	objectMapFromEntries,
 	objectMapKeys,
-	transact,
+	react,
 } from 'tldraw'
-import { isDevelopmentEnv } from '../../utils/env'
-import { globalEditor } from '../../utils/globalEditor'
-import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
+import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
 export const UNPUBLISH_ENDPOINT = `/api/app/unpublish`
-export const DUPLICATE_ENDPOINT = `/api/app/duplicate`
 export const FILE_ENDPOINT = `/api/app/file`
 
+let appId = 0
+
 export class TldrawApp {
 	config = {
 		maxNumberOfFiles: 100,
 	}
 
-	private constructor(store: Store<TldrawAppRecord>) {
-		this.store = store
-		if (isDevelopmentEnv) {
-			;(window as any).tla_dev_clear = () => this.store.clear()
-		}
+	readonly id = appId++
 
-		// todo: replace this when we have application-level user preferences
-		this.store.sideEffects.registerAfterChangeHandler('session', (prev, next) => {
-			if (prev.theme !== next.theme) {
-				const editor = globalEditor.get()
-				if (!editor) return
-				const editorIsDark = editor.user.getIsDarkMode()
-				const appIsDark = next.theme === 'dark'
-				if (appIsDark && !editorIsDark) {
-					editor.user.updateUserPreferences({ colorScheme: 'dark' })
-				} else if (!appIsDark && editorIsDark) {
-					editor.user.updateUserPreferences({ colorScheme: 'light' })
-				}
-			}
+	readonly z: Zero
+
+	private readonly user$: Signal<TlaUser | undefined>
+	private readonly files$: Signal<TlaFile[]>
+	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
+
+	readonly disposables: (() => void)[] = []
+
+	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
+		// fail if closed?
+		const view = query.materialize()
+		const val$ = atom(name, view.data)
+		view.addListener((res: any) => {
+			val$.set(structuredClone(res) as any)
+		})
+		react('blah', () => {
+			val$.get()
+		})
+		this.disposables.push(() => {
+			view.destroy()
 		})
+		return val$
 	}
 
-	store: Store<TldrawAppRecord>
+	toasts: TLUiToastsContextType | null = null
+	private constructor(
+		public readonly userId: string,
+		getToken: () => Promise<string | null>
+	) {
+		const sessionId = uniqueId()
+		this.z = new Zero({
+			// userID: userId,
+			// auth: encodedJWT,
+			getUri: async () => {
+				const token = await getToken()
+				if (!token)
+					return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=no-token-found&sessionId=${sessionId}`
+				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=${token}&sessionId=${sessionId}`
+			},
+			// schema,
+			// This is often easier to develop with if you're frequently changing
+			// the schema. Switch to 'idb' for local-persistence.
+			onMutationRejected: (errorCode) => {
+				this.toasts?.addToast({
+					title: 'That didn’t work',
+					description: `Error code: ${errorCode}`,
+				})
+			},
+		})
+		this.disposables.push(() => this.z.dispose())
+
+		this.user$ = this.signalizeQuery(
+			'user signal',
+			this.z.query.user.where('id', this.userId).one()
+		)
+		this.files$ = this.signalizeQuery(
+			'files signal',
+			this.z.query.file.where('ownerId', this.userId)
+		)
+		this.fileStates$ = this.signalizeQuery(
+			'file states signal',
+			this.z.query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
+		)
+	}
+
+	async preload(initialUserData: TlaUser) {
+		await this.z.query.user.where('id', this.userId).preload().complete
+		if (!this.user$.get()) {
+			await this.z.mutate.user.create(initialUserData)
+		}
+		await new Promise((resolve) => {
+			let unsub = () => {}
+			unsub = react('wait for user', () => this.user$.get() && resolve(unsub()))
+		})
+		if (!this.user$.get()) {
+			throw Error('could not create user')
+		}
+		await this.z.query.file_state.where('userId', this.userId).preload().complete
+		await this.z.query.file.where('ownerId', this.userId).preload().complete
+	}
 
 	dispose() {
-		this.store.dispose()
+		this.disposables.forEach((d) => d())
+		// this.store.dispose()
+	}
+
+	getUser() {
+		return assertExists(this.user$.get(), 'no user')
 	}
 
 	tlUser = createTLUser({
 		userPreferences: computed('user prefs', () => {
-			const userId = this.getCurrentUserId()
-			if (!userId) throw Error('no user')
-			const user = this.getUser(userId)
+			const user = this.getUser()
 			return {
 				...(pick(user, UserPreferencesKeys) as TLUserPreferences),
-				id: TldrawAppUserRecordType.parseId(userId),
+				id: this.userId,
 			}
 		}),
 		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
-			const user = this.getCurrentUser()
-			if (!user) throw Error('no user')
+			const user = this.getUser()
 
-			this.store.put([
-				{
+			this.z.mutate((tx) => {
+				tx.user.update({
 					...user,
-					...(others as TldrawAppUser),
-				},
-			])
+					// TODO: remove nulls
+					...(others as TlaUser),
+				})
+			})
 		},
 	})
 
-	getAll<T extends TldrawAppRecord['typeName']>(
-		typeName: T
-	): (TldrawAppRecord & { typeName: T })[] {
-		return this.store.allRecords().filter((r) => r.typeName === typeName) as (TldrawAppRecord & {
-			typeName: T
-		})[]
-	}
-
-	get<T extends TldrawAppRecord>(id: T['id']): T | undefined {
-		return this.store.get(id) as T | undefined
-	}
-
-	getUser(userId: TldrawAppUserId): TldrawAppUser | undefined {
-		return this.get(userId)
-	}
+	// getAll<T extends keyof Schema['tables']>(
+	// 	typeName: T
+	// ): SchemaToRow<Schema['tables'][T]>[] {
+	// 	return this.z.query[typeName].run()
+	// }
 
 	getUserOwnFiles() {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		return Array.from(new Set(this.getAll('file').filter((f) => f.ownerId === user.id)))
-	}
-
-	getCurrentUserId() {
-		return assertExists(getLocalSessionStateUnsafe().auth).userId
+		return this.files$.get()
 	}
 
-	getCurrentUser() {
-		const user = this.getUser(this.getCurrentUserId())
-		if (!user?.id) {
-			throw Error('no user')
-		}
-		return assertExists(user, 'no current user')
+	getUserFileStates() {
+		return this.fileStates$.get()
 	}
 
-	lastRecentFileOrdering = null as null | Array<{ fileId: TldrawAppFileId; date: number }>
+	lastRecentFileOrdering = null as null | Array<{ fileId: string; date: number }>
 
+	@computed
 	getUserRecentFiles() {
-		const userId = this.getCurrentUserId()
+		const myFiles = objectMapFromEntries(this.getUserOwnFiles().map((f) => [f.id, f]))
+		const myStates = objectMapFromEntries(this.getUserFileStates().map((f) => [f.fileId, f]))
 
-		const myFiles = objectMapFromEntries(
-			this.getAll('file')
-				.filter((f) => f.ownerId === userId)
-				.map((f) => [f.id, f])
-		)
-		const myStates = objectMapFromEntries(
-			this.getAll('file-state')
-				.filter((f) => f.ownerId === userId)
-				.map((f) => [f.fileId, f])
-		)
-
-		const myFileIds = new Set<TldrawAppFileId>([
-			...objectMapKeys(myFiles),
-			...objectMapKeys(myStates),
-		])
+		const myFileIds = new Set<string>([...objectMapKeys(myFiles), ...objectMapKeys(myStates)])
 
 		const nextRecentFileOrdering = []
 
@@ -173,76 +196,85 @@ export class TldrawApp {
 	}
 
 	getUserSharedFiles() {
-		const userId = this.getCurrentUserId()
 		return Array.from(
 			new Set(
-				this.getAll('file-state')
-					.filter((r) => r.ownerId === userId)
+				this.getUserFileStates()
 					.map((s) => {
-						const file = this.get<TldrawAppFile>(s.fileId)
-						if (!file) return
 						// skip files where the owner is the current user
-						if (file.ownerId === userId) return
-						return file
+						if (s.file!.ownerId === this.userId) return
+						return s.file
 					})
-					.filter(Boolean) as TldrawAppFile[]
+					.filter(Boolean) as TlaFile[]
 			)
 		)
 	}
 
 	private canCreateNewFile() {
-		const userId = this.getCurrentUserId()
-		const numberOfFiles = this.getAll('file').filter((f) => f.ownerId === userId).length
+		const numberOfFiles = this.getUserOwnFiles().length
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	createFile(
-		fileId?: TldrawAppFileId
-	): Result<{ file: TldrawAppFile }, 'max number of files reached'> {
+	async createFile(
+		fileOrId?: string | Partial<TlaFile>
+	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
 		if (!this.canCreateNewFile()) {
 			return Result.err('max number of files reached')
 		}
 
-		const file = TldrawAppFileRecordType.create({
-			ownerId: this.getCurrentUserId(),
+		const file: TlaFile = {
+			id: typeof fileOrId === 'string' ? fileOrId : uniqueId(),
+			ownerId: this.userId,
 			isEmpty: true,
-			id: fileId ?? TldrawAppFileRecordType.createId(),
-		})
-		this.store.put([file])
+			createdAt: Date.now(),
+			lastPublished: 0,
+			name: '',
+			published: false,
+			publishedSlug: uniqueId(),
+			shared: false,
+			sharedLinkType: 'view',
+			thumbnail: '',
+			updatedAt: Date.now(),
+		}
+		if (typeof fileOrId === 'object') {
+			Object.assign(file, fileOrId)
+		}
+
+		this.z.mutate.file.create(file)
 
 		return Result.ok({ file })
 	}
 
-	getFileName(fileId: TldrawAppFileId) {
-		const file = this.store.get(fileId)
-		if (!file) return undefined
+	getFileName(file: TlaFile | string | null) {
+		if (typeof file === 'string') {
+			file = this.getFile(file)
+		}
+		if (!file) return ''
+		assert(typeof file !== 'string', 'ok')
 		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
 	}
 
-	claimTemporaryFile(fileId: TldrawAppFileId) {
-		// TODO(david): check that you can't claim someone else's file (the db insert should fail and trigger a resync)
-		this.store.put([
-			TldrawAppFileRecordType.create({
-				id: fileId,
-				ownerId: this.getCurrentUserId(),
-			}),
-		])
+	claimTemporaryFile(fileId: string) {
+		// TODO(david): check that you can't claim someone else's file (the db insert should fail)
+		// TODO(zero stuff): add table constraint
+		this.createFile(fileId)
 	}
 
-	toggleFileShared(fileId: TldrawAppFileId) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
+	toggleFileShared(fileId: string) {
+		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
+		if (!file) throw Error('no file with id ' + fileId)
 
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
+
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				shared: !file.shared,
+			})
 
-		transact(() => {
-			this.store.put([{ ...file, shared: !file.shared }])
 			// if it was shared, remove all shared links
-			if (file.shared) {
-				const states = this.getAll('file-state').filter(
-					(r) => r.fileId === fileId && r.ownerId !== file.ownerId
-				)
-				this.store.remove(states.map((r) => r.id))
+			// TODO: move this to the backend after read permissions are implemented
+			for (const fileState of this.getUserFileStates().filter((f) => f.fileId === fileId)) {
+				tx.file_state.delete(fileState)
 			}
 		})
 	}
@@ -278,140 +310,85 @@ export class TldrawApp {
 		}
 
 		// Also create a file state record for the new file
-		this.store.put(
-			response.slugs.map((slug) =>
-				TldrawAppFileStateRecordType.create({
-					fileId: TldrawAppFileRecordType.createId(slug),
-					ownerId: this.getCurrentUserId(),
+		this.z.mutate((tx) => {
+			for (const slug of response.slugs) {
+				tx.file_state.create({
+					userId: this.userId,
+					fileId: slug,
 					firstVisitAt: Date.now(),
-					lastVisitAt: Date.now(),
-					lastEditAt: Date.now(),
+					lastEditAt: undefined,
+					lastSessionState: undefined,
+					lastVisitAt: undefined,
 				})
-			)
-		)
-
-		return { slugs: response.slugs }
-	}
-
-	/**
-	 * Duplicate a file.
-	 *
-	 * @param fileSlug - The file slug to duplicate.
-	 * @param token - The user's token.
-	 *
-	 * @returns A result indicating success or failure.
-	 */
-	async duplicateFile(fileSlug: string, token: string) {
-		const endpoint = `${DUPLICATE_ENDPOINT}/${fileSlug}`
-
-		const res = await fetch(endpoint, {
-			method: 'POST',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+			}
 		})
 
-		const response = (await res.json()) as DuplicateRoomResponseBody
-
-		if (!res.ok || response.error) {
-			return Result.err('could not duplicate file')
-		}
-
-		// Also create a file state record for the new file
-
-		this.store.put([
-			TldrawAppFileStateRecordType.create({
-				fileId: TldrawAppFileRecordType.createId(response.slug),
-				ownerId: this.getCurrentUserId(),
-				firstVisitAt: Date.now(),
-				lastVisitAt: Date.now(),
-				lastEditAt: Date.now(),
-			}),
-		])
-
-		return Result.ok({ slug: response.slug })
+		return { slugs: response.slugs }
 	}
 
 	/**
 	 * Publish a file or re-publish changes.
 	 *
 	 * @param fileId - The file id to unpublish.
-	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	async publishFile(fileId: TldrawAppFileId, token: string) {
-		const file = this.get(fileId) as TldrawAppFile
+	publishFile(fileId: string) {
+		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error(`No file with that id`)
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+		if (file.ownerId !== this.userId) throw Error('user cannot publish that file')
 
 		// We're going to bake the name of the file, if it's undefined
-		const name = this.getFileName(fileId)!
+		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.store.put([{ ...file, name, published: true, lastPublished: Date.now() }])
-
-		const fileSlug = fileId.split(':')[1]
-
-		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
-
-		const res = await fetch(endpoint, {
-			method: 'POST',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				name,
+				published: true,
+				lastPublished: Date.now(),
+			})
 		})
+	}
 
-		const response = (await res.json()) as PublishFileResponseBody
+	getFile(fileId: string): TlaFile | null {
+		return this.getUserOwnFiles().find((f) => f.id === fileId) ?? null
+	}
 
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			const latestFile = this.get(fileId) as TldrawAppFile
-			const { published, lastPublished } = file
-			this.store.put([{ ...latestFile, published, lastPublished }])
+	isFileOwner(fileId: string) {
+		const file = this.getFile(fileId)
+		return file && file.ownerId === this.userId
+	}
 
-			return Result.err('could not create snapshot')
-		}
+	requireFile(fileId: string): TlaFile {
+		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
+	}
 
-		return Result.ok('success')
+	updateFile(fileId: string, cb: (file: TlaFile) => TlaFile) {
+		const file = this.requireFile(fileId)
+		this.z.mutate.file.update(cb(file))
 	}
 
 	/**
 	 * Unpublish a file.
 	 *
 	 * @param fileId - The file id to unpublish.
-	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	async unpublishFile(fileId: TldrawAppFileId, token: string) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+	unpublishFile(fileId: string) {
+		const file = this.requireFile(fileId)
+		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.store.put([{ ...file, published: false }])
-
-		const fileSlug = fileId.split(':')[1]
-
-		const res = await fetch(`${PUBLISH_ENDPOINT}/${fileSlug}`, {
-			method: 'DELETE',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				published: false,
+			})
 		})
 
-		const response = (await res.json()) as UnpublishFileResponseBody
-
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			this.store.put([{ ...file, published: true }])
-			return Result.err('could not unpublish')
-		}
-
 		return Result.ok('success')
 	}
 
@@ -419,129 +396,126 @@ export class TldrawApp {
 	 * Remove a user's file states for a file and delete the file if the user is the owner of the file.
 	 *
 	 * @param fileId - The file id.
-	 * @param token - The user's token.
 	 */
-	async deleteOrForgetFile(fileId: TldrawAppFileId, token: string) {
+	async deleteOrForgetFile(fileId: string) {
 		// Stash these so that we can restore them later
-		let fileStates: TldrawAppFileState[]
-		const file = this.get(fileId) as TldrawAppFile
+		let fileStates: TlaFileState[]
+		const file = this.getFile(fileId)
+		if (!file) return Result.err('no file with id ' + fileId)
 
-		if (this.isFileOwner(fileId)) {
+		if (file.ownerId === this.userId) {
 			// Optimistic update, remove file and file states
-			fileStates = this.getAll('file-state').filter((r) => r.fileId === fileId)
-			this.store.remove([fileId, ...fileStates.map((s) => s.id)])
+			this.z.mutate((tx) => {
+				tx.file.delete(file)
+				// TODO(blah): other file states should be deleted by backend
+				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
+				for (const state of fileStates) {
+					if (state.fileId === fileId) {
+						tx.file_state.delete(state)
+					}
+				}
+			})
 		} else {
 			// If not the owner, just remove the file state
-			const userId = this.getCurrentUserId()
-			fileStates = this.getAll('file-state').filter(
-				(r) => r.fileId === fileId && r.ownerId === userId
-			)
-			this.store.remove(fileStates.map((s) => s.id))
-		}
-
-		const fileSlug = fileId.split(':')[1]
-
-		const res = await fetch(`${FILE_ENDPOINT}/${fileSlug}`, {
-			method: 'DELETE',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
-		})
-
-		const response = (await res.json()) as UnpublishFileResponseBody
-
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			this.store.put([file, ...fileStates])
-			return Result.err('could not delete')
+			this.z.mutate((tx) => {
+				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
+				for (const state of fileStates) {
+					if (state.fileId === fileId) {
+						tx.file_state.delete(state)
+					}
+				}
+			})
 		}
-
-		return Result.ok('success')
 	}
 
-	setFileSharedLinkType(
-		fileId: TldrawAppFileId,
-		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
-	) {
-		const userId = this.getCurrentUserId()
+	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
+		const file = this.requireFile(fileId)
 
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
-
-		if (userId !== file.ownerId) {
+		if (this.userId !== file.ownerId) {
 			throw Error('user cannot edit that file')
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.store.put([{ ...file, shared: false }])
+			this.z.mutate.file.update({ ...file, shared: false })
 			return
 		}
-
-		this.store.put([{ ...file, sharedLinkType, shared: true }])
+		this.z.mutate.file.update({ ...file, shared: true, sharedLinkType })
 	}
 
-	isFileOwner(fileId: TldrawAppFileId) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) return false
-		return file.ownerId === this.getCurrentUserId()
+	updateUser(cb: (user: TlaUser) => TlaUser) {
+		const user = this.getUser()
+		this.z.mutate.user.update(cb(user))
 	}
 
 	updateUserExportPreferences(
 		exportPreferences: Partial<
-			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
+			Pick<TlaUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
 		>
 	) {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		this.store.put([{ ...user, ...exportPreferences }])
+		this.updateUser((user) => ({
+			...user,
+			...exportPreferences,
+		}))
 	}
 
-	getOrCreateFileState(fileId: TldrawAppFileId) {
+	async getOrCreateFileState(fileId: string) {
 		let fileState = this.getFileState(fileId)
-		const ownerId = this.getCurrentUserId()
 		if (!fileState) {
-			fileState = TldrawAppFileStateRecordType.create({
+			await this.z.mutate.file_state.create({
 				fileId,
-				ownerId,
+				userId: this.userId,
+				firstVisitAt: Date.now(),
+				lastEditAt: undefined,
+				lastSessionState: undefined,
+				lastVisitAt: undefined,
 			})
-			this.store.put([fileState])
 		}
+		fileState = this.getFileState(fileId)
+		if (!fileState) throw Error('could not create file state')
 		return fileState
 	}
 
-	getFileState(fileId: TldrawAppFileId) {
-		const ownerId = this.getCurrentUserId()
-		return this.getAll('file-state').find((r) => r.ownerId === ownerId && r.fileId === fileId)
+	getFileState(fileId: string) {
+		return this.getUserFileStates().find((f) => f.fileId === fileId)
 	}
 
-	onFileEnter(fileId: TldrawAppFileId) {
-		const fileState = this.getOrCreateFileState(fileId)
-		if (fileState.firstVisitAt) return
-		this.store.put([
-			{ ...fileState, firstVisitAt: fileState.firstVisitAt ?? Date.now(), lastVisitAt: Date.now() },
-		])
+	updateFileState(fileId: string, cb: (fileState: TlaFileState) => TlaFileState) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return
+		// remove relationship because zero complains
+		const { file: _, ...rest } = fileState
+		this.z.mutate.file_state.update(cb(rest))
 	}
 
-	onFileEdit(fileId: TldrawAppFileId) {
-		// Find the store's most recent file state record for this user
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
+	async onFileEnter(fileId: string) {
+		await this.getOrCreateFileState(fileId)
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			firstVisitAt: fileState.firstVisitAt ?? Date.now(),
+			lastVisitAt: Date.now(),
+		}))
+	}
 
-		// Create the file edit record
-		this.store.put([{ ...fileState, lastEditAt: Date.now() }])
+	onFileEdit(fileId: string) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastEditAt: Date.now(),
+		}))
 	}
 
-	onFileSessionStateUpdate(fileId: TldrawAppFileId, sessionState: TLSessionStateSnapshot) {
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
-		this.store.put([{ ...fileState, lastSessionState: sessionState, lastVisitAt: Date.now() }])
+	onFileSessionStateUpdate(fileId: string, sessionState: TLSessionStateSnapshot) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastSessionState: JSON.stringify(sessionState),
+			lastVisitAt: Date.now(),
+		}))
 	}
 
-	onFileExit(fileId: TldrawAppFileId) {
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
-		this.store.put([{ ...fileState, lastVisitAt: Date.now() }])
+	onFileExit(fileId: string) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastVisitAt: Date.now(),
+		}))
 	}
 
 	static async create(opts: {
@@ -549,32 +523,37 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		store: Store<TldrawAppRecord>
+		getToken(): Promise<string | null>
 	}) {
-		const { store } = opts
-
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
-		const userId = TldrawAppUserRecordType.createId(opts.userId)
-
-		const user = store.get(userId)
-		if (!user) {
-			const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
-			store.put([
-				TldrawAppUserRecordType.create({
-					id: userId,
-					ownerId: userId,
-					name: opts.fullName,
-					email: opts.email,
-					color: 'salmon',
-					avatar: opts.avatar,
-					...restOfPreferences,
-				}),
-			])
-		}
 
-		const app = new TldrawApp(store)
-		return { app, userId }
+		const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
+		const app = new TldrawApp(opts.userId, opts.getToken)
+		await app.preload({
+			id: opts.userId,
+			name: opts.fullName,
+			email: opts.email,
+			color: 'salmon',
+			avatar: opts.avatar,
+			exportFormat: 'png',
+			exportTheme: 'light',
+			exportBackground: false,
+			exportPadding: false,
+			createdAt: Date.now(),
+			updatedAt: Date.now(),
+			flags: '',
+			...restOfPreferences,
+			locale: restOfPreferences.locale ?? undefined,
+			animationSpeed: restOfPreferences.animationSpeed ?? undefined,
+			edgeScrollSpeed: restOfPreferences.edgeScrollSpeed ?? undefined,
+			colorScheme: restOfPreferences.colorScheme ?? undefined,
+			isSnapMode: restOfPreferences.isSnapMode ?? undefined,
+			isWrapMode: restOfPreferences.isWrapMode ?? undefined,
+			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? undefined,
+			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? undefined,
+		})
+		return { app, userId: opts.userId }
 	}
 }

commit 2e534b6f70c2950a1b754e12359bd786a62890f3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:39:22 2024 +0000

    Revert "[wip] custom botcom backend" (#4883)
    
    Reverts tldraw/tldraw#487
    
    - [x] other

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 40818caa2..70730287d 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,177 +1,154 @@
-// import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
 import {
 	CreateFilesResponseBody,
-	TlaFile,
-	TlaFileState,
-	TlaUser,
+	DuplicateRoomResponseBody,
+	PublishFileResponseBody,
+	TldrawAppFile,
+	TldrawAppFileId,
+	TldrawAppFileRecordType,
+	TldrawAppFileState,
+	TldrawAppFileStateRecordType,
+	TldrawAppRecord,
+	TldrawAppUser,
+	TldrawAppUserId,
+	TldrawAppUserRecordType,
+	UnpublishFileResponseBody,
 	UserPreferencesKeys,
 } from '@tldraw/dotcom-shared'
-import { Result, assert, fetch, structuredClone, uniqueId } from '@tldraw/utils'
+import { Result, fetch } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	Signal,
+	Store,
 	TLSessionStateSnapshot,
 	TLStoreSnapshot,
-	TLUiToastsContextType,
 	TLUserPreferences,
 	assertExists,
-	atom,
 	computed,
 	createTLUser,
 	getUserPreferences,
 	objectMapFromEntries,
 	objectMapKeys,
-	react,
+	transact,
 } from 'tldraw'
-import { Zero } from './zero-polyfill'
+import { isDevelopmentEnv } from '../../utils/env'
+import { globalEditor } from '../../utils/globalEditor'
+import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
 export const UNPUBLISH_ENDPOINT = `/api/app/unpublish`
+export const DUPLICATE_ENDPOINT = `/api/app/duplicate`
 export const FILE_ENDPOINT = `/api/app/file`
 
-let appId = 0
-
 export class TldrawApp {
 	config = {
 		maxNumberOfFiles: 100,
 	}
 
-	readonly id = appId++
-
-	readonly z: Zero
-
-	private readonly user$: Signal<TlaUser | undefined>
-	private readonly files$: Signal<TlaFile[]>
-	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
-
-	readonly disposables: (() => void)[] = []
+	private constructor(store: Store<TldrawAppRecord>) {
+		this.store = store
+		if (isDevelopmentEnv) {
+			;(window as any).tla_dev_clear = () => this.store.clear()
+		}
 
-	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
-		// fail if closed?
-		const view = query.materialize()
-		const val$ = atom(name, view.data)
-		view.addListener((res: any) => {
-			val$.set(structuredClone(res) as any)
-		})
-		react('blah', () => {
-			val$.get()
-		})
-		this.disposables.push(() => {
-			view.destroy()
+		// todo: replace this when we have application-level user preferences
+		this.store.sideEffects.registerAfterChangeHandler('session', (prev, next) => {
+			if (prev.theme !== next.theme) {
+				const editor = globalEditor.get()
+				if (!editor) return
+				const editorIsDark = editor.user.getIsDarkMode()
+				const appIsDark = next.theme === 'dark'
+				if (appIsDark && !editorIsDark) {
+					editor.user.updateUserPreferences({ colorScheme: 'dark' })
+				} else if (!appIsDark && editorIsDark) {
+					editor.user.updateUserPreferences({ colorScheme: 'light' })
+				}
+			}
 		})
-		return val$
 	}
 
-	toasts: TLUiToastsContextType | null = null
-	private constructor(
-		public readonly userId: string,
-		getToken: () => Promise<string | null>
-	) {
-		const sessionId = uniqueId()
-		this.z = new Zero({
-			// userID: userId,
-			// auth: encodedJWT,
-			getUri: async () => {
-				const token = await getToken()
-				if (!token)
-					return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=no-token-found&sessionId=${sessionId}`
-				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=${token}&sessionId=${sessionId}`
-			},
-			// schema,
-			// This is often easier to develop with if you're frequently changing
-			// the schema. Switch to 'idb' for local-persistence.
-			onMutationRejected: (errorCode) => {
-				this.toasts?.addToast({
-					title: 'That didn’t work',
-					description: `Error code: ${errorCode}`,
-				})
-			},
-		})
-		this.disposables.push(() => this.z.dispose())
-
-		this.user$ = this.signalizeQuery(
-			'user signal',
-			this.z.query.user.where('id', this.userId).one()
-		)
-		this.files$ = this.signalizeQuery(
-			'files signal',
-			this.z.query.file.where('ownerId', this.userId)
-		)
-		this.fileStates$ = this.signalizeQuery(
-			'file states signal',
-			this.z.query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
-		)
-	}
-
-	async preload(initialUserData: TlaUser) {
-		await this.z.query.user.where('id', this.userId).preload().complete
-		if (!this.user$.get()) {
-			await this.z.mutate.user.create(initialUserData)
-		}
-		await new Promise((resolve) => {
-			let unsub = () => {}
-			unsub = react('wait for user', () => this.user$.get() && resolve(unsub()))
-		})
-		if (!this.user$.get()) {
-			throw Error('could not create user')
-		}
-		await this.z.query.file_state.where('userId', this.userId).preload().complete
-		await this.z.query.file.where('ownerId', this.userId).preload().complete
-	}
+	store: Store<TldrawAppRecord>
 
 	dispose() {
-		this.disposables.forEach((d) => d())
-		// this.store.dispose()
-	}
-
-	getUser() {
-		return assertExists(this.user$.get(), 'no user')
+		this.store.dispose()
 	}
 
 	tlUser = createTLUser({
 		userPreferences: computed('user prefs', () => {
-			const user = this.getUser()
+			const userId = this.getCurrentUserId()
+			if (!userId) throw Error('no user')
+			const user = this.getUser(userId)
 			return {
 				...(pick(user, UserPreferencesKeys) as TLUserPreferences),
-				id: this.userId,
+				id: TldrawAppUserRecordType.parseId(userId),
 			}
 		}),
 		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
-			const user = this.getUser()
+			const user = this.getCurrentUser()
+			if (!user) throw Error('no user')
 
-			this.z.mutate((tx) => {
-				tx.user.update({
+			this.store.put([
+				{
 					...user,
-					// TODO: remove nulls
-					...(others as TlaUser),
-				})
-			})
+					...(others as TldrawAppUser),
+				},
+			])
 		},
 	})
 
-	// getAll<T extends keyof Schema['tables']>(
-	// 	typeName: T
-	// ): SchemaToRow<Schema['tables'][T]>[] {
-	// 	return this.z.query[typeName].run()
-	// }
+	getAll<T extends TldrawAppRecord['typeName']>(
+		typeName: T
+	): (TldrawAppRecord & { typeName: T })[] {
+		return this.store.allRecords().filter((r) => r.typeName === typeName) as (TldrawAppRecord & {
+			typeName: T
+		})[]
+	}
+
+	get<T extends TldrawAppRecord>(id: T['id']): T | undefined {
+		return this.store.get(id) as T | undefined
+	}
+
+	getUser(userId: TldrawAppUserId): TldrawAppUser | undefined {
+		return this.get(userId)
+	}
 
 	getUserOwnFiles() {
-		return this.files$.get()
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		return Array.from(new Set(this.getAll('file').filter((f) => f.ownerId === user.id)))
+	}
+
+	getCurrentUserId() {
+		return assertExists(getLocalSessionStateUnsafe().auth).userId
 	}
 
-	getUserFileStates() {
-		return this.fileStates$.get()
+	getCurrentUser() {
+		const user = this.getUser(this.getCurrentUserId())
+		if (!user?.id) {
+			throw Error('no user')
+		}
+		return assertExists(user, 'no current user')
 	}
 
-	lastRecentFileOrdering = null as null | Array<{ fileId: string; date: number }>
+	lastRecentFileOrdering = null as null | Array<{ fileId: TldrawAppFileId; date: number }>
 
-	@computed
 	getUserRecentFiles() {
-		const myFiles = objectMapFromEntries(this.getUserOwnFiles().map((f) => [f.id, f]))
-		const myStates = objectMapFromEntries(this.getUserFileStates().map((f) => [f.fileId, f]))
+		const userId = this.getCurrentUserId()
 
-		const myFileIds = new Set<string>([...objectMapKeys(myFiles), ...objectMapKeys(myStates)])
+		const myFiles = objectMapFromEntries(
+			this.getAll('file')
+				.filter((f) => f.ownerId === userId)
+				.map((f) => [f.id, f])
+		)
+		const myStates = objectMapFromEntries(
+			this.getAll('file-state')
+				.filter((f) => f.ownerId === userId)
+				.map((f) => [f.fileId, f])
+		)
+
+		const myFileIds = new Set<TldrawAppFileId>([
+			...objectMapKeys(myFiles),
+			...objectMapKeys(myStates),
+		])
 
 		const nextRecentFileOrdering = []
 
@@ -196,85 +173,76 @@ export class TldrawApp {
 	}
 
 	getUserSharedFiles() {
+		const userId = this.getCurrentUserId()
 		return Array.from(
 			new Set(
-				this.getUserFileStates()
+				this.getAll('file-state')
+					.filter((r) => r.ownerId === userId)
 					.map((s) => {
+						const file = this.get<TldrawAppFile>(s.fileId)
+						if (!file) return
 						// skip files where the owner is the current user
-						if (s.file!.ownerId === this.userId) return
-						return s.file
+						if (file.ownerId === userId) return
+						return file
 					})
-					.filter(Boolean) as TlaFile[]
+					.filter(Boolean) as TldrawAppFile[]
 			)
 		)
 	}
 
 	private canCreateNewFile() {
-		const numberOfFiles = this.getUserOwnFiles().length
+		const userId = this.getCurrentUserId()
+		const numberOfFiles = this.getAll('file').filter((f) => f.ownerId === userId).length
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	async createFile(
-		fileOrId?: string | Partial<TlaFile>
-	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
+	createFile(
+		fileId?: TldrawAppFileId
+	): Result<{ file: TldrawAppFile }, 'max number of files reached'> {
 		if (!this.canCreateNewFile()) {
 			return Result.err('max number of files reached')
 		}
 
-		const file: TlaFile = {
-			id: typeof fileOrId === 'string' ? fileOrId : uniqueId(),
-			ownerId: this.userId,
+		const file = TldrawAppFileRecordType.create({
+			ownerId: this.getCurrentUserId(),
 			isEmpty: true,
-			createdAt: Date.now(),
-			lastPublished: 0,
-			name: '',
-			published: false,
-			publishedSlug: uniqueId(),
-			shared: false,
-			sharedLinkType: 'view',
-			thumbnail: '',
-			updatedAt: Date.now(),
-		}
-		if (typeof fileOrId === 'object') {
-			Object.assign(file, fileOrId)
-		}
-
-		this.z.mutate.file.create(file)
+			id: fileId ?? TldrawAppFileRecordType.createId(),
+		})
+		this.store.put([file])
 
 		return Result.ok({ file })
 	}
 
-	getFileName(file: TlaFile | string | null) {
-		if (typeof file === 'string') {
-			file = this.getFile(file)
-		}
-		if (!file) return ''
-		assert(typeof file !== 'string', 'ok')
+	getFileName(fileId: TldrawAppFileId) {
+		const file = this.store.get(fileId)
+		if (!file) return undefined
 		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
 	}
 
-	claimTemporaryFile(fileId: string) {
-		// TODO(david): check that you can't claim someone else's file (the db insert should fail)
-		// TODO(zero stuff): add table constraint
-		this.createFile(fileId)
+	claimTemporaryFile(fileId: TldrawAppFileId) {
+		// TODO(david): check that you can't claim someone else's file (the db insert should fail and trigger a resync)
+		this.store.put([
+			TldrawAppFileRecordType.create({
+				id: fileId,
+				ownerId: this.getCurrentUserId(),
+			}),
+		])
 	}
 
-	toggleFileShared(fileId: string) {
-		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
-		if (!file) throw Error('no file with id ' + fileId)
+	toggleFileShared(fileId: TldrawAppFileId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
 
-		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
-
-		this.z.mutate((tx) => {
-			tx.file.update({
-				...file,
-				shared: !file.shared,
-			})
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
+		transact(() => {
+			this.store.put([{ ...file, shared: !file.shared }])
 			// if it was shared, remove all shared links
-			// TODO: move this to the backend after read permissions are implemented
-			for (const fileState of this.getUserFileStates().filter((f) => f.fileId === fileId)) {
-				tx.file_state.delete(fileState)
+			if (file.shared) {
+				const states = this.getAll('file-state').filter(
+					(r) => r.fileId === fileId && r.ownerId !== file.ownerId
+				)
+				this.store.remove(states.map((r) => r.id))
 			}
 		})
 	}
@@ -310,85 +278,140 @@ export class TldrawApp {
 		}
 
 		// Also create a file state record for the new file
-		this.z.mutate((tx) => {
-			for (const slug of response.slugs) {
-				tx.file_state.create({
-					userId: this.userId,
-					fileId: slug,
+		this.store.put(
+			response.slugs.map((slug) =>
+				TldrawAppFileStateRecordType.create({
+					fileId: TldrawAppFileRecordType.createId(slug),
+					ownerId: this.getCurrentUserId(),
 					firstVisitAt: Date.now(),
-					lastEditAt: undefined,
-					lastSessionState: undefined,
-					lastVisitAt: undefined,
+					lastVisitAt: Date.now(),
+					lastEditAt: Date.now(),
 				})
-			}
-		})
+			)
+		)
 
 		return { slugs: response.slugs }
 	}
 
+	/**
+	 * Duplicate a file.
+	 *
+	 * @param fileSlug - The file slug to duplicate.
+	 * @param token - The user's token.
+	 *
+	 * @returns A result indicating success or failure.
+	 */
+	async duplicateFile(fileSlug: string, token: string) {
+		const endpoint = `${DUPLICATE_ENDPOINT}/${fileSlug}`
+
+		const res = await fetch(endpoint, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+		})
+
+		const response = (await res.json()) as DuplicateRoomResponseBody
+
+		if (!res.ok || response.error) {
+			return Result.err('could not duplicate file')
+		}
+
+		// Also create a file state record for the new file
+
+		this.store.put([
+			TldrawAppFileStateRecordType.create({
+				fileId: TldrawAppFileRecordType.createId(response.slug),
+				ownerId: this.getCurrentUserId(),
+				firstVisitAt: Date.now(),
+				lastVisitAt: Date.now(),
+				lastEditAt: Date.now(),
+			}),
+		])
+
+		return Result.ok({ slug: response.slug })
+	}
+
 	/**
 	 * Publish a file or re-publish changes.
 	 *
 	 * @param fileId - The file id to unpublish.
+	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	publishFile(fileId: string) {
-		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
+	async publishFile(fileId: TldrawAppFileId, token: string) {
+		const file = this.get(fileId) as TldrawAppFile
 		if (!file) throw Error(`No file with that id`)
-		if (file.ownerId !== this.userId) throw Error('user cannot publish that file')
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
 		// We're going to bake the name of the file, if it's undefined
-		const name = this.getFileName(file)
+		const name = this.getFileName(fileId)!
 
 		// Optimistic update
-		this.z.mutate((tx) => {
-			tx.file.update({
-				...file,
-				name,
-				published: true,
-				lastPublished: Date.now(),
-			})
+		this.store.put([{ ...file, name, published: true, lastPublished: Date.now() }])
+
+		const fileSlug = fileId.split(':')[1]
+
+		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
+
+		const res = await fetch(endpoint, {
+			method: 'POST',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
 		})
-	}
 
-	getFile(fileId: string): TlaFile | null {
-		return this.getUserOwnFiles().find((f) => f.id === fileId) ?? null
-	}
+		const response = (await res.json()) as PublishFileResponseBody
 
-	isFileOwner(fileId: string) {
-		const file = this.getFile(fileId)
-		return file && file.ownerId === this.userId
-	}
+		if (!res.ok || response.error) {
+			// Revert optimistic update
+			const latestFile = this.get(fileId) as TldrawAppFile
+			const { published, lastPublished } = file
+			this.store.put([{ ...latestFile, published, lastPublished }])
 
-	requireFile(fileId: string): TlaFile {
-		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
-	}
+			return Result.err('could not create snapshot')
+		}
 
-	updateFile(fileId: string, cb: (file: TlaFile) => TlaFile) {
-		const file = this.requireFile(fileId)
-		this.z.mutate.file.update(cb(file))
+		return Result.ok('success')
 	}
 
 	/**
 	 * Unpublish a file.
 	 *
 	 * @param fileId - The file id to unpublish.
+	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	unpublishFile(fileId: string) {
-		const file = this.requireFile(fileId)
-		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
+	async unpublishFile(fileId: TldrawAppFileId, token: string) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
 
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.z.mutate((tx) => {
-			tx.file.update({
-				...file,
-				published: false,
-			})
+		this.store.put([{ ...file, published: false }])
+
+		const fileSlug = fileId.split(':')[1]
+
+		const res = await fetch(`${PUBLISH_ENDPOINT}/${fileSlug}`, {
+			method: 'DELETE',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
 		})
 
+		const response = (await res.json()) as UnpublishFileResponseBody
+
+		if (!res.ok || response.error) {
+			// Revert optimistic update
+			this.store.put([{ ...file, published: true }])
+			return Result.err('could not unpublish')
+		}
+
 		return Result.ok('success')
 	}
 
@@ -396,126 +419,129 @@ export class TldrawApp {
 	 * Remove a user's file states for a file and delete the file if the user is the owner of the file.
 	 *
 	 * @param fileId - The file id.
+	 * @param token - The user's token.
 	 */
-	async deleteOrForgetFile(fileId: string) {
+	async deleteOrForgetFile(fileId: TldrawAppFileId, token: string) {
 		// Stash these so that we can restore them later
-		let fileStates: TlaFileState[]
-		const file = this.getFile(fileId)
-		if (!file) return Result.err('no file with id ' + fileId)
+		let fileStates: TldrawAppFileState[]
+		const file = this.get(fileId) as TldrawAppFile
 
-		if (file.ownerId === this.userId) {
+		if (this.isFileOwner(fileId)) {
 			// Optimistic update, remove file and file states
-			this.z.mutate((tx) => {
-				tx.file.delete(file)
-				// TODO(blah): other file states should be deleted by backend
-				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
-				for (const state of fileStates) {
-					if (state.fileId === fileId) {
-						tx.file_state.delete(state)
-					}
-				}
-			})
+			fileStates = this.getAll('file-state').filter((r) => r.fileId === fileId)
+			this.store.remove([fileId, ...fileStates.map((s) => s.id)])
 		} else {
 			// If not the owner, just remove the file state
-			this.z.mutate((tx) => {
-				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
-				for (const state of fileStates) {
-					if (state.fileId === fileId) {
-						tx.file_state.delete(state)
-					}
-				}
-			})
+			const userId = this.getCurrentUserId()
+			fileStates = this.getAll('file-state').filter(
+				(r) => r.fileId === fileId && r.ownerId === userId
+			)
+			this.store.remove(fileStates.map((s) => s.id))
+		}
+
+		const fileSlug = fileId.split(':')[1]
+
+		const res = await fetch(`${FILE_ENDPOINT}/${fileSlug}`, {
+			method: 'DELETE',
+			headers: {
+				'Content-Type': 'application/json',
+				Authorization: `Bearer ${token}`,
+			},
+		})
+
+		const response = (await res.json()) as UnpublishFileResponseBody
+
+		if (!res.ok || response.error) {
+			// Revert optimistic update
+			this.store.put([file, ...fileStates])
+			return Result.err('could not delete')
 		}
+
+		return Result.ok('success')
 	}
 
-	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
-		const file = this.requireFile(fileId)
+	setFileSharedLinkType(
+		fileId: TldrawAppFileId,
+		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
+	) {
+		const userId = this.getCurrentUserId()
 
-		if (this.userId !== file.ownerId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) throw Error(`No file with that id`)
+
+		if (userId !== file.ownerId) {
 			throw Error('user cannot edit that file')
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.z.mutate.file.update({ ...file, shared: false })
+			this.store.put([{ ...file, shared: false }])
 			return
 		}
-		this.z.mutate.file.update({ ...file, shared: true, sharedLinkType })
+
+		this.store.put([{ ...file, sharedLinkType, shared: true }])
 	}
 
-	updateUser(cb: (user: TlaUser) => TlaUser) {
-		const user = this.getUser()
-		this.z.mutate.user.update(cb(user))
+	isFileOwner(fileId: TldrawAppFileId) {
+		const file = this.get(fileId) as TldrawAppFile
+		if (!file) return false
+		return file.ownerId === this.getCurrentUserId()
 	}
 
 	updateUserExportPreferences(
 		exportPreferences: Partial<
-			Pick<TlaUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
+			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
 		>
 	) {
-		this.updateUser((user) => ({
-			...user,
-			...exportPreferences,
-		}))
+		const user = this.getCurrentUser()
+		if (!user) throw Error('no user')
+		this.store.put([{ ...user, ...exportPreferences }])
 	}
 
-	async getOrCreateFileState(fileId: string) {
+	getOrCreateFileState(fileId: TldrawAppFileId) {
 		let fileState = this.getFileState(fileId)
+		const ownerId = this.getCurrentUserId()
 		if (!fileState) {
-			await this.z.mutate.file_state.create({
+			fileState = TldrawAppFileStateRecordType.create({
 				fileId,
-				userId: this.userId,
-				firstVisitAt: Date.now(),
-				lastEditAt: undefined,
-				lastSessionState: undefined,
-				lastVisitAt: undefined,
+				ownerId,
 			})
+			this.store.put([fileState])
 		}
-		fileState = this.getFileState(fileId)
-		if (!fileState) throw Error('could not create file state')
 		return fileState
 	}
 
-	getFileState(fileId: string) {
-		return this.getUserFileStates().find((f) => f.fileId === fileId)
+	getFileState(fileId: TldrawAppFileId) {
+		const ownerId = this.getCurrentUserId()
+		return this.getAll('file-state').find((r) => r.ownerId === ownerId && r.fileId === fileId)
 	}
 
-	updateFileState(fileId: string, cb: (fileState: TlaFileState) => TlaFileState) {
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return
-		// remove relationship because zero complains
-		const { file: _, ...rest } = fileState
-		this.z.mutate.file_state.update(cb(rest))
+	onFileEnter(fileId: TldrawAppFileId) {
+		const fileState = this.getOrCreateFileState(fileId)
+		if (fileState.firstVisitAt) return
+		this.store.put([
+			{ ...fileState, firstVisitAt: fileState.firstVisitAt ?? Date.now(), lastVisitAt: Date.now() },
+		])
 	}
 
-	async onFileEnter(fileId: string) {
-		await this.getOrCreateFileState(fileId)
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
-			firstVisitAt: fileState.firstVisitAt ?? Date.now(),
-			lastVisitAt: Date.now(),
-		}))
-	}
+	onFileEdit(fileId: TldrawAppFileId) {
+		// Find the store's most recent file state record for this user
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
 
-	onFileEdit(fileId: string) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
-			lastEditAt: Date.now(),
-		}))
+		// Create the file edit record
+		this.store.put([{ ...fileState, lastEditAt: Date.now() }])
 	}
 
-	onFileSessionStateUpdate(fileId: string, sessionState: TLSessionStateSnapshot) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
-			lastSessionState: JSON.stringify(sessionState),
-			lastVisitAt: Date.now(),
-		}))
+	onFileSessionStateUpdate(fileId: TldrawAppFileId, sessionState: TLSessionStateSnapshot) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
+		this.store.put([{ ...fileState, lastSessionState: sessionState, lastVisitAt: Date.now() }])
 	}
 
-	onFileExit(fileId: string) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
-			lastVisitAt: Date.now(),
-		}))
+	onFileExit(fileId: TldrawAppFileId) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return // file was deleted
+		this.store.put([{ ...fileState, lastVisitAt: Date.now() }])
 	}
 
 	static async create(opts: {
@@ -523,37 +549,32 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		getToken(): Promise<string | null>
+		store: Store<TldrawAppRecord>
 	}) {
+		const { store } = opts
+
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
+		const userId = TldrawAppUserRecordType.createId(opts.userId)
+
+		const user = store.get(userId)
+		if (!user) {
+			const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
+			store.put([
+				TldrawAppUserRecordType.create({
+					id: userId,
+					ownerId: userId,
+					name: opts.fullName,
+					email: opts.email,
+					color: 'salmon',
+					avatar: opts.avatar,
+					...restOfPreferences,
+				}),
+			])
+		}
 
-		const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
-		const app = new TldrawApp(opts.userId, opts.getToken)
-		await app.preload({
-			id: opts.userId,
-			name: opts.fullName,
-			email: opts.email,
-			color: 'salmon',
-			avatar: opts.avatar,
-			exportFormat: 'png',
-			exportTheme: 'light',
-			exportBackground: false,
-			exportPadding: false,
-			createdAt: Date.now(),
-			updatedAt: Date.now(),
-			flags: '',
-			...restOfPreferences,
-			locale: restOfPreferences.locale ?? undefined,
-			animationSpeed: restOfPreferences.animationSpeed ?? undefined,
-			edgeScrollSpeed: restOfPreferences.edgeScrollSpeed ?? undefined,
-			colorScheme: restOfPreferences.colorScheme ?? undefined,
-			isSnapMode: restOfPreferences.isSnapMode ?? undefined,
-			isWrapMode: restOfPreferences.isWrapMode ?? undefined,
-			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? undefined,
-			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? undefined,
-		})
-		return { app, userId: opts.userId }
+		const app = new TldrawApp(store)
+		return { app, userId }
 	}
 }

commit 8d8471f530a48377b3223b8cb64647ef3e590a36
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:49:21 2024 +0000

    [botcom] New backend (again) (#4884)
    
    re-attempt at #4879
    So it turns out you have to delete a durable object class in two
    deploys:
    
    1. stop using it
    2. add the 'delete' migration in wrangler.toml
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 70730287d..40818caa2 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,154 +1,177 @@
+// import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
 import {
 	CreateFilesResponseBody,
-	DuplicateRoomResponseBody,
-	PublishFileResponseBody,
-	TldrawAppFile,
-	TldrawAppFileId,
-	TldrawAppFileRecordType,
-	TldrawAppFileState,
-	TldrawAppFileStateRecordType,
-	TldrawAppRecord,
-	TldrawAppUser,
-	TldrawAppUserId,
-	TldrawAppUserRecordType,
-	UnpublishFileResponseBody,
+	TlaFile,
+	TlaFileState,
+	TlaUser,
 	UserPreferencesKeys,
 } from '@tldraw/dotcom-shared'
-import { Result, fetch } from '@tldraw/utils'
+import { Result, assert, fetch, structuredClone, uniqueId } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	Store,
+	Signal,
 	TLSessionStateSnapshot,
 	TLStoreSnapshot,
+	TLUiToastsContextType,
 	TLUserPreferences,
 	assertExists,
+	atom,
 	computed,
 	createTLUser,
 	getUserPreferences,
 	objectMapFromEntries,
 	objectMapKeys,
-	transact,
+	react,
 } from 'tldraw'
-import { isDevelopmentEnv } from '../../utils/env'
-import { globalEditor } from '../../utils/globalEditor'
-import { getLocalSessionStateUnsafe } from '../utils/local-session-state'
+import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
 export const UNPUBLISH_ENDPOINT = `/api/app/unpublish`
-export const DUPLICATE_ENDPOINT = `/api/app/duplicate`
 export const FILE_ENDPOINT = `/api/app/file`
 
+let appId = 0
+
 export class TldrawApp {
 	config = {
 		maxNumberOfFiles: 100,
 	}
 
-	private constructor(store: Store<TldrawAppRecord>) {
-		this.store = store
-		if (isDevelopmentEnv) {
-			;(window as any).tla_dev_clear = () => this.store.clear()
-		}
+	readonly id = appId++
 
-		// todo: replace this when we have application-level user preferences
-		this.store.sideEffects.registerAfterChangeHandler('session', (prev, next) => {
-			if (prev.theme !== next.theme) {
-				const editor = globalEditor.get()
-				if (!editor) return
-				const editorIsDark = editor.user.getIsDarkMode()
-				const appIsDark = next.theme === 'dark'
-				if (appIsDark && !editorIsDark) {
-					editor.user.updateUserPreferences({ colorScheme: 'dark' })
-				} else if (!appIsDark && editorIsDark) {
-					editor.user.updateUserPreferences({ colorScheme: 'light' })
-				}
-			}
+	readonly z: Zero
+
+	private readonly user$: Signal<TlaUser | undefined>
+	private readonly files$: Signal<TlaFile[]>
+	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
+
+	readonly disposables: (() => void)[] = []
+
+	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
+		// fail if closed?
+		const view = query.materialize()
+		const val$ = atom(name, view.data)
+		view.addListener((res: any) => {
+			val$.set(structuredClone(res) as any)
+		})
+		react('blah', () => {
+			val$.get()
+		})
+		this.disposables.push(() => {
+			view.destroy()
 		})
+		return val$
 	}
 
-	store: Store<TldrawAppRecord>
+	toasts: TLUiToastsContextType | null = null
+	private constructor(
+		public readonly userId: string,
+		getToken: () => Promise<string | null>
+	) {
+		const sessionId = uniqueId()
+		this.z = new Zero({
+			// userID: userId,
+			// auth: encodedJWT,
+			getUri: async () => {
+				const token = await getToken()
+				if (!token)
+					return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=no-token-found&sessionId=${sessionId}`
+				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=${token}&sessionId=${sessionId}`
+			},
+			// schema,
+			// This is often easier to develop with if you're frequently changing
+			// the schema. Switch to 'idb' for local-persistence.
+			onMutationRejected: (errorCode) => {
+				this.toasts?.addToast({
+					title: 'That didn’t work',
+					description: `Error code: ${errorCode}`,
+				})
+			},
+		})
+		this.disposables.push(() => this.z.dispose())
+
+		this.user$ = this.signalizeQuery(
+			'user signal',
+			this.z.query.user.where('id', this.userId).one()
+		)
+		this.files$ = this.signalizeQuery(
+			'files signal',
+			this.z.query.file.where('ownerId', this.userId)
+		)
+		this.fileStates$ = this.signalizeQuery(
+			'file states signal',
+			this.z.query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
+		)
+	}
+
+	async preload(initialUserData: TlaUser) {
+		await this.z.query.user.where('id', this.userId).preload().complete
+		if (!this.user$.get()) {
+			await this.z.mutate.user.create(initialUserData)
+		}
+		await new Promise((resolve) => {
+			let unsub = () => {}
+			unsub = react('wait for user', () => this.user$.get() && resolve(unsub()))
+		})
+		if (!this.user$.get()) {
+			throw Error('could not create user')
+		}
+		await this.z.query.file_state.where('userId', this.userId).preload().complete
+		await this.z.query.file.where('ownerId', this.userId).preload().complete
+	}
 
 	dispose() {
-		this.store.dispose()
+		this.disposables.forEach((d) => d())
+		// this.store.dispose()
+	}
+
+	getUser() {
+		return assertExists(this.user$.get(), 'no user')
 	}
 
 	tlUser = createTLUser({
 		userPreferences: computed('user prefs', () => {
-			const userId = this.getCurrentUserId()
-			if (!userId) throw Error('no user')
-			const user = this.getUser(userId)
+			const user = this.getUser()
 			return {
 				...(pick(user, UserPreferencesKeys) as TLUserPreferences),
-				id: TldrawAppUserRecordType.parseId(userId),
+				id: this.userId,
 			}
 		}),
 		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
-			const user = this.getCurrentUser()
-			if (!user) throw Error('no user')
+			const user = this.getUser()
 
-			this.store.put([
-				{
+			this.z.mutate((tx) => {
+				tx.user.update({
 					...user,
-					...(others as TldrawAppUser),
-				},
-			])
+					// TODO: remove nulls
+					...(others as TlaUser),
+				})
+			})
 		},
 	})
 
-	getAll<T extends TldrawAppRecord['typeName']>(
-		typeName: T
-	): (TldrawAppRecord & { typeName: T })[] {
-		return this.store.allRecords().filter((r) => r.typeName === typeName) as (TldrawAppRecord & {
-			typeName: T
-		})[]
-	}
-
-	get<T extends TldrawAppRecord>(id: T['id']): T | undefined {
-		return this.store.get(id) as T | undefined
-	}
-
-	getUser(userId: TldrawAppUserId): TldrawAppUser | undefined {
-		return this.get(userId)
-	}
+	// getAll<T extends keyof Schema['tables']>(
+	// 	typeName: T
+	// ): SchemaToRow<Schema['tables'][T]>[] {
+	// 	return this.z.query[typeName].run()
+	// }
 
 	getUserOwnFiles() {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		return Array.from(new Set(this.getAll('file').filter((f) => f.ownerId === user.id)))
-	}
-
-	getCurrentUserId() {
-		return assertExists(getLocalSessionStateUnsafe().auth).userId
+		return this.files$.get()
 	}
 
-	getCurrentUser() {
-		const user = this.getUser(this.getCurrentUserId())
-		if (!user?.id) {
-			throw Error('no user')
-		}
-		return assertExists(user, 'no current user')
+	getUserFileStates() {
+		return this.fileStates$.get()
 	}
 
-	lastRecentFileOrdering = null as null | Array<{ fileId: TldrawAppFileId; date: number }>
+	lastRecentFileOrdering = null as null | Array<{ fileId: string; date: number }>
 
+	@computed
 	getUserRecentFiles() {
-		const userId = this.getCurrentUserId()
+		const myFiles = objectMapFromEntries(this.getUserOwnFiles().map((f) => [f.id, f]))
+		const myStates = objectMapFromEntries(this.getUserFileStates().map((f) => [f.fileId, f]))
 
-		const myFiles = objectMapFromEntries(
-			this.getAll('file')
-				.filter((f) => f.ownerId === userId)
-				.map((f) => [f.id, f])
-		)
-		const myStates = objectMapFromEntries(
-			this.getAll('file-state')
-				.filter((f) => f.ownerId === userId)
-				.map((f) => [f.fileId, f])
-		)
-
-		const myFileIds = new Set<TldrawAppFileId>([
-			...objectMapKeys(myFiles),
-			...objectMapKeys(myStates),
-		])
+		const myFileIds = new Set<string>([...objectMapKeys(myFiles), ...objectMapKeys(myStates)])
 
 		const nextRecentFileOrdering = []
 
@@ -173,76 +196,85 @@ export class TldrawApp {
 	}
 
 	getUserSharedFiles() {
-		const userId = this.getCurrentUserId()
 		return Array.from(
 			new Set(
-				this.getAll('file-state')
-					.filter((r) => r.ownerId === userId)
+				this.getUserFileStates()
 					.map((s) => {
-						const file = this.get<TldrawAppFile>(s.fileId)
-						if (!file) return
 						// skip files where the owner is the current user
-						if (file.ownerId === userId) return
-						return file
+						if (s.file!.ownerId === this.userId) return
+						return s.file
 					})
-					.filter(Boolean) as TldrawAppFile[]
+					.filter(Boolean) as TlaFile[]
 			)
 		)
 	}
 
 	private canCreateNewFile() {
-		const userId = this.getCurrentUserId()
-		const numberOfFiles = this.getAll('file').filter((f) => f.ownerId === userId).length
+		const numberOfFiles = this.getUserOwnFiles().length
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	createFile(
-		fileId?: TldrawAppFileId
-	): Result<{ file: TldrawAppFile }, 'max number of files reached'> {
+	async createFile(
+		fileOrId?: string | Partial<TlaFile>
+	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
 		if (!this.canCreateNewFile()) {
 			return Result.err('max number of files reached')
 		}
 
-		const file = TldrawAppFileRecordType.create({
-			ownerId: this.getCurrentUserId(),
+		const file: TlaFile = {
+			id: typeof fileOrId === 'string' ? fileOrId : uniqueId(),
+			ownerId: this.userId,
 			isEmpty: true,
-			id: fileId ?? TldrawAppFileRecordType.createId(),
-		})
-		this.store.put([file])
+			createdAt: Date.now(),
+			lastPublished: 0,
+			name: '',
+			published: false,
+			publishedSlug: uniqueId(),
+			shared: false,
+			sharedLinkType: 'view',
+			thumbnail: '',
+			updatedAt: Date.now(),
+		}
+		if (typeof fileOrId === 'object') {
+			Object.assign(file, fileOrId)
+		}
+
+		this.z.mutate.file.create(file)
 
 		return Result.ok({ file })
 	}
 
-	getFileName(fileId: TldrawAppFileId) {
-		const file = this.store.get(fileId)
-		if (!file) return undefined
+	getFileName(file: TlaFile | string | null) {
+		if (typeof file === 'string') {
+			file = this.getFile(file)
+		}
+		if (!file) return ''
+		assert(typeof file !== 'string', 'ok')
 		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
 	}
 
-	claimTemporaryFile(fileId: TldrawAppFileId) {
-		// TODO(david): check that you can't claim someone else's file (the db insert should fail and trigger a resync)
-		this.store.put([
-			TldrawAppFileRecordType.create({
-				id: fileId,
-				ownerId: this.getCurrentUserId(),
-			}),
-		])
+	claimTemporaryFile(fileId: string) {
+		// TODO(david): check that you can't claim someone else's file (the db insert should fail)
+		// TODO(zero stuff): add table constraint
+		this.createFile(fileId)
 	}
 
-	toggleFileShared(fileId: TldrawAppFileId) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
+	toggleFileShared(fileId: string) {
+		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
+		if (!file) throw Error('no file with id ' + fileId)
 
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
+
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				shared: !file.shared,
+			})
 
-		transact(() => {
-			this.store.put([{ ...file, shared: !file.shared }])
 			// if it was shared, remove all shared links
-			if (file.shared) {
-				const states = this.getAll('file-state').filter(
-					(r) => r.fileId === fileId && r.ownerId !== file.ownerId
-				)
-				this.store.remove(states.map((r) => r.id))
+			// TODO: move this to the backend after read permissions are implemented
+			for (const fileState of this.getUserFileStates().filter((f) => f.fileId === fileId)) {
+				tx.file_state.delete(fileState)
 			}
 		})
 	}
@@ -278,140 +310,85 @@ export class TldrawApp {
 		}
 
 		// Also create a file state record for the new file
-		this.store.put(
-			response.slugs.map((slug) =>
-				TldrawAppFileStateRecordType.create({
-					fileId: TldrawAppFileRecordType.createId(slug),
-					ownerId: this.getCurrentUserId(),
+		this.z.mutate((tx) => {
+			for (const slug of response.slugs) {
+				tx.file_state.create({
+					userId: this.userId,
+					fileId: slug,
 					firstVisitAt: Date.now(),
-					lastVisitAt: Date.now(),
-					lastEditAt: Date.now(),
+					lastEditAt: undefined,
+					lastSessionState: undefined,
+					lastVisitAt: undefined,
 				})
-			)
-		)
-
-		return { slugs: response.slugs }
-	}
-
-	/**
-	 * Duplicate a file.
-	 *
-	 * @param fileSlug - The file slug to duplicate.
-	 * @param token - The user's token.
-	 *
-	 * @returns A result indicating success or failure.
-	 */
-	async duplicateFile(fileSlug: string, token: string) {
-		const endpoint = `${DUPLICATE_ENDPOINT}/${fileSlug}`
-
-		const res = await fetch(endpoint, {
-			method: 'POST',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+			}
 		})
 
-		const response = (await res.json()) as DuplicateRoomResponseBody
-
-		if (!res.ok || response.error) {
-			return Result.err('could not duplicate file')
-		}
-
-		// Also create a file state record for the new file
-
-		this.store.put([
-			TldrawAppFileStateRecordType.create({
-				fileId: TldrawAppFileRecordType.createId(response.slug),
-				ownerId: this.getCurrentUserId(),
-				firstVisitAt: Date.now(),
-				lastVisitAt: Date.now(),
-				lastEditAt: Date.now(),
-			}),
-		])
-
-		return Result.ok({ slug: response.slug })
+		return { slugs: response.slugs }
 	}
 
 	/**
 	 * Publish a file or re-publish changes.
 	 *
 	 * @param fileId - The file id to unpublish.
-	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	async publishFile(fileId: TldrawAppFileId, token: string) {
-		const file = this.get(fileId) as TldrawAppFile
+	publishFile(fileId: string) {
+		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error(`No file with that id`)
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+		if (file.ownerId !== this.userId) throw Error('user cannot publish that file')
 
 		// We're going to bake the name of the file, if it's undefined
-		const name = this.getFileName(fileId)!
+		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.store.put([{ ...file, name, published: true, lastPublished: Date.now() }])
-
-		const fileSlug = fileId.split(':')[1]
-
-		const endpoint = `${PUBLISH_ENDPOINT}/${fileSlug}`
-
-		const res = await fetch(endpoint, {
-			method: 'POST',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				name,
+				published: true,
+				lastPublished: Date.now(),
+			})
 		})
+	}
 
-		const response = (await res.json()) as PublishFileResponseBody
+	getFile(fileId: string): TlaFile | null {
+		return this.getUserOwnFiles().find((f) => f.id === fileId) ?? null
+	}
 
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			const latestFile = this.get(fileId) as TldrawAppFile
-			const { published, lastPublished } = file
-			this.store.put([{ ...latestFile, published, lastPublished }])
+	isFileOwner(fileId: string) {
+		const file = this.getFile(fileId)
+		return file && file.ownerId === this.userId
+	}
 
-			return Result.err('could not create snapshot')
-		}
+	requireFile(fileId: string): TlaFile {
+		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
+	}
 
-		return Result.ok('success')
+	updateFile(fileId: string, cb: (file: TlaFile) => TlaFile) {
+		const file = this.requireFile(fileId)
+		this.z.mutate.file.update(cb(file))
 	}
 
 	/**
 	 * Unpublish a file.
 	 *
 	 * @param fileId - The file id to unpublish.
-	 * @param token - The user's token.
 	 * @returns A result indicating success or failure.
 	 */
-	async unpublishFile(fileId: TldrawAppFileId, token: string) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
-		if (!this.isFileOwner(fileId)) throw Error('user cannot edit that file')
+	unpublishFile(fileId: string) {
+		const file = this.requireFile(fileId)
+		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.store.put([{ ...file, published: false }])
-
-		const fileSlug = fileId.split(':')[1]
-
-		const res = await fetch(`${PUBLISH_ENDPOINT}/${fileSlug}`, {
-			method: 'DELETE',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
+		this.z.mutate((tx) => {
+			tx.file.update({
+				...file,
+				published: false,
+			})
 		})
 
-		const response = (await res.json()) as UnpublishFileResponseBody
-
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			this.store.put([{ ...file, published: true }])
-			return Result.err('could not unpublish')
-		}
-
 		return Result.ok('success')
 	}
 
@@ -419,129 +396,126 @@ export class TldrawApp {
 	 * Remove a user's file states for a file and delete the file if the user is the owner of the file.
 	 *
 	 * @param fileId - The file id.
-	 * @param token - The user's token.
 	 */
-	async deleteOrForgetFile(fileId: TldrawAppFileId, token: string) {
+	async deleteOrForgetFile(fileId: string) {
 		// Stash these so that we can restore them later
-		let fileStates: TldrawAppFileState[]
-		const file = this.get(fileId) as TldrawAppFile
+		let fileStates: TlaFileState[]
+		const file = this.getFile(fileId)
+		if (!file) return Result.err('no file with id ' + fileId)
 
-		if (this.isFileOwner(fileId)) {
+		if (file.ownerId === this.userId) {
 			// Optimistic update, remove file and file states
-			fileStates = this.getAll('file-state').filter((r) => r.fileId === fileId)
-			this.store.remove([fileId, ...fileStates.map((s) => s.id)])
+			this.z.mutate((tx) => {
+				tx.file.delete(file)
+				// TODO(blah): other file states should be deleted by backend
+				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
+				for (const state of fileStates) {
+					if (state.fileId === fileId) {
+						tx.file_state.delete(state)
+					}
+				}
+			})
 		} else {
 			// If not the owner, just remove the file state
-			const userId = this.getCurrentUserId()
-			fileStates = this.getAll('file-state').filter(
-				(r) => r.fileId === fileId && r.ownerId === userId
-			)
-			this.store.remove(fileStates.map((s) => s.id))
-		}
-
-		const fileSlug = fileId.split(':')[1]
-
-		const res = await fetch(`${FILE_ENDPOINT}/${fileSlug}`, {
-			method: 'DELETE',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
-		})
-
-		const response = (await res.json()) as UnpublishFileResponseBody
-
-		if (!res.ok || response.error) {
-			// Revert optimistic update
-			this.store.put([file, ...fileStates])
-			return Result.err('could not delete')
+			this.z.mutate((tx) => {
+				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
+				for (const state of fileStates) {
+					if (state.fileId === fileId) {
+						tx.file_state.delete(state)
+					}
+				}
+			})
 		}
-
-		return Result.ok('success')
 	}
 
-	setFileSharedLinkType(
-		fileId: TldrawAppFileId,
-		sharedLinkType: TldrawAppFile['sharedLinkType'] | 'no-access'
-	) {
-		const userId = this.getCurrentUserId()
+	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
+		const file = this.requireFile(fileId)
 
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) throw Error(`No file with that id`)
-
-		if (userId !== file.ownerId) {
+		if (this.userId !== file.ownerId) {
 			throw Error('user cannot edit that file')
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.store.put([{ ...file, shared: false }])
+			this.z.mutate.file.update({ ...file, shared: false })
 			return
 		}
-
-		this.store.put([{ ...file, sharedLinkType, shared: true }])
+		this.z.mutate.file.update({ ...file, shared: true, sharedLinkType })
 	}
 
-	isFileOwner(fileId: TldrawAppFileId) {
-		const file = this.get(fileId) as TldrawAppFile
-		if (!file) return false
-		return file.ownerId === this.getCurrentUserId()
+	updateUser(cb: (user: TlaUser) => TlaUser) {
+		const user = this.getUser()
+		this.z.mutate.user.update(cb(user))
 	}
 
 	updateUserExportPreferences(
 		exportPreferences: Partial<
-			Pick<TldrawAppUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
+			Pick<TlaUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
 		>
 	) {
-		const user = this.getCurrentUser()
-		if (!user) throw Error('no user')
-		this.store.put([{ ...user, ...exportPreferences }])
+		this.updateUser((user) => ({
+			...user,
+			...exportPreferences,
+		}))
 	}
 
-	getOrCreateFileState(fileId: TldrawAppFileId) {
+	async getOrCreateFileState(fileId: string) {
 		let fileState = this.getFileState(fileId)
-		const ownerId = this.getCurrentUserId()
 		if (!fileState) {
-			fileState = TldrawAppFileStateRecordType.create({
+			await this.z.mutate.file_state.create({
 				fileId,
-				ownerId,
+				userId: this.userId,
+				firstVisitAt: Date.now(),
+				lastEditAt: undefined,
+				lastSessionState: undefined,
+				lastVisitAt: undefined,
 			})
-			this.store.put([fileState])
 		}
+		fileState = this.getFileState(fileId)
+		if (!fileState) throw Error('could not create file state')
 		return fileState
 	}
 
-	getFileState(fileId: TldrawAppFileId) {
-		const ownerId = this.getCurrentUserId()
-		return this.getAll('file-state').find((r) => r.ownerId === ownerId && r.fileId === fileId)
+	getFileState(fileId: string) {
+		return this.getUserFileStates().find((f) => f.fileId === fileId)
 	}
 
-	onFileEnter(fileId: TldrawAppFileId) {
-		const fileState = this.getOrCreateFileState(fileId)
-		if (fileState.firstVisitAt) return
-		this.store.put([
-			{ ...fileState, firstVisitAt: fileState.firstVisitAt ?? Date.now(), lastVisitAt: Date.now() },
-		])
+	updateFileState(fileId: string, cb: (fileState: TlaFileState) => TlaFileState) {
+		const fileState = this.getFileState(fileId)
+		if (!fileState) return
+		// remove relationship because zero complains
+		const { file: _, ...rest } = fileState
+		this.z.mutate.file_state.update(cb(rest))
 	}
 
-	onFileEdit(fileId: TldrawAppFileId) {
-		// Find the store's most recent file state record for this user
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
+	async onFileEnter(fileId: string) {
+		await this.getOrCreateFileState(fileId)
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			firstVisitAt: fileState.firstVisitAt ?? Date.now(),
+			lastVisitAt: Date.now(),
+		}))
+	}
 
-		// Create the file edit record
-		this.store.put([{ ...fileState, lastEditAt: Date.now() }])
+	onFileEdit(fileId: string) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastEditAt: Date.now(),
+		}))
 	}
 
-	onFileSessionStateUpdate(fileId: TldrawAppFileId, sessionState: TLSessionStateSnapshot) {
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
-		this.store.put([{ ...fileState, lastSessionState: sessionState, lastVisitAt: Date.now() }])
+	onFileSessionStateUpdate(fileId: string, sessionState: TLSessionStateSnapshot) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastSessionState: JSON.stringify(sessionState),
+			lastVisitAt: Date.now(),
+		}))
 	}
 
-	onFileExit(fileId: TldrawAppFileId) {
-		const fileState = this.getFileState(fileId)
-		if (!fileState) return // file was deleted
-		this.store.put([{ ...fileState, lastVisitAt: Date.now() }])
+	onFileExit(fileId: string) {
+		this.updateFileState(fileId, (fileState) => ({
+			...fileState,
+			lastVisitAt: Date.now(),
+		}))
 	}
 
 	static async create(opts: {
@@ -549,32 +523,37 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		store: Store<TldrawAppRecord>
+		getToken(): Promise<string | null>
 	}) {
-		const { store } = opts
-
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
-		const userId = TldrawAppUserRecordType.createId(opts.userId)
-
-		const user = store.get(userId)
-		if (!user) {
-			const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
-			store.put([
-				TldrawAppUserRecordType.create({
-					id: userId,
-					ownerId: userId,
-					name: opts.fullName,
-					email: opts.email,
-					color: 'salmon',
-					avatar: opts.avatar,
-					...restOfPreferences,
-				}),
-			])
-		}
 
-		const app = new TldrawApp(store)
-		return { app, userId }
+		const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
+		const app = new TldrawApp(opts.userId, opts.getToken)
+		await app.preload({
+			id: opts.userId,
+			name: opts.fullName,
+			email: opts.email,
+			color: 'salmon',
+			avatar: opts.avatar,
+			exportFormat: 'png',
+			exportTheme: 'light',
+			exportBackground: false,
+			exportPadding: false,
+			createdAt: Date.now(),
+			updatedAt: Date.now(),
+			flags: '',
+			...restOfPreferences,
+			locale: restOfPreferences.locale ?? undefined,
+			animationSpeed: restOfPreferences.animationSpeed ?? undefined,
+			edgeScrollSpeed: restOfPreferences.edgeScrollSpeed ?? undefined,
+			colorScheme: restOfPreferences.colorScheme ?? undefined,
+			isSnapMode: restOfPreferences.isSnapMode ?? undefined,
+			isWrapMode: restOfPreferences.isWrapMode ?? undefined,
+			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? undefined,
+			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? undefined,
+		})
+		return { app, userId: opts.userId }
 	}
 }

commit b504ba4891d2dc545c5fb2771b8d2ea3dd835769
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 12 08:26:54 2024 +0000

    Robustify replicator bootup (#4888)
    
    - read the initial data in a transaction, at the same time write a
    unique id for the boot sequence to the db
    - wait for the boot id update to come through before handling messages
    on the subscription queue.
    - stream the initial data into sqlite, rather than loading it all into
    memory (which caps out at 130mb)
    - use the zero schema format to define data types, and to provide
    runtime info to generate the initial load sql query.
    - added a postgres config that you can opt in to, to log out the queries
    that are being executed.
    
    TODO:
    
    - [ ] load test the db up to 1gb of data, figure out how to measure the
    data size, get a sense of how many users we can theoretically support
    with this setup.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 40818caa2..3005a60b7 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -316,9 +316,9 @@ export class TldrawApp {
 					userId: this.userId,
 					fileId: slug,
 					firstVisitAt: Date.now(),
-					lastEditAt: undefined,
-					lastSessionState: undefined,
-					lastVisitAt: undefined,
+					lastEditAt: null,
+					lastSessionState: null,
+					lastVisitAt: null,
 				})
 			}
 		})
@@ -465,9 +465,9 @@ export class TldrawApp {
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),
-				lastEditAt: undefined,
-				lastSessionState: undefined,
-				lastVisitAt: undefined,
+				lastEditAt: null,
+				lastSessionState: null,
+				lastVisitAt: null,
 			})
 		}
 		fileState = this.getFileState(fileId)
@@ -545,14 +545,14 @@ export class TldrawApp {
 			updatedAt: Date.now(),
 			flags: '',
 			...restOfPreferences,
-			locale: restOfPreferences.locale ?? undefined,
-			animationSpeed: restOfPreferences.animationSpeed ?? undefined,
-			edgeScrollSpeed: restOfPreferences.edgeScrollSpeed ?? undefined,
-			colorScheme: restOfPreferences.colorScheme ?? undefined,
-			isSnapMode: restOfPreferences.isSnapMode ?? undefined,
-			isWrapMode: restOfPreferences.isWrapMode ?? undefined,
-			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? undefined,
-			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? undefined,
+			locale: restOfPreferences.locale ?? null,
+			animationSpeed: restOfPreferences.animationSpeed ?? null,
+			edgeScrollSpeed: restOfPreferences.edgeScrollSpeed ?? null,
+			colorScheme: restOfPreferences.colorScheme ?? null,
+			isSnapMode: restOfPreferences.isSnapMode ?? null,
+			isWrapMode: restOfPreferences.isWrapMode ?? null,
+			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? null,
+			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? null,
 		})
 		return { app, userId: opts.userId }
 	}

commit 314d4eab1f9aa2040e20843172af0cb9cfd3aa14
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Nov 20 09:22:59 2024 +0000

    Lazy replicator (#4926)
    
    - the pg replicator only stores data for the users who are currently
    active
    - even then it only stores the users' ids, along with any guest file ids
    they have access to.
    - each user DO fetches their replica directly from postgres, and syncs
    via messages from the pg replicator
    - user DOs keep their replica in memory rather than sqlite, since they
    are so small.
    
    still need to debug and stress test this, but it should be a lot more
    scalable than the current thing.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug with…

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 3005a60b7..eeadc5a38 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -270,12 +270,6 @@ export class TldrawApp {
 				...file,
 				shared: !file.shared,
 			})
-
-			// if it was shared, remove all shared links
-			// TODO: move this to the backend after read permissions are implemented
-			for (const fileState of this.getUserFileStates().filter((f) => f.fileId === fileId)) {
-				tx.file_state.delete(fileState)
-			}
 		})
 	}
 
@@ -398,34 +392,15 @@ export class TldrawApp {
 	 * @param fileId - The file id.
 	 */
 	async deleteOrForgetFile(fileId: string) {
-		// Stash these so that we can restore them later
-		let fileStates: TlaFileState[]
 		const file = this.getFile(fileId)
-		if (!file) return Result.err('no file with id ' + fileId)
 
-		if (file.ownerId === this.userId) {
-			// Optimistic update, remove file and file states
-			this.z.mutate((tx) => {
-				tx.file.delete(file)
-				// TODO(blah): other file states should be deleted by backend
-				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
-				for (const state of fileStates) {
-					if (state.fileId === fileId) {
-						tx.file_state.delete(state)
-					}
-				}
-			})
-		} else {
-			// If not the owner, just remove the file state
-			this.z.mutate((tx) => {
-				fileStates = this.getUserFileStates().filter((r) => r.fileId === fileId)
-				for (const state of fileStates) {
-					if (state.fileId === fileId) {
-						tx.file_state.delete(state)
-					}
-				}
-			})
-		}
+		// Optimistic update, remove file and file states
+		this.z.mutate((tx) => {
+			tx.file_state.delete({ fileId, userId: this.userId })
+			if (file?.ownerId === this.userId) {
+				tx.file.delete({ id: fileId })
+			}
+		})
 	}
 
 	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
@@ -531,6 +506,8 @@ export class TldrawApp {
 
 		const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
 		const app = new TldrawApp(opts.userId, opts.getToken)
+		// @ts-expect-error
+		window.app = app
 		await app.preload({
 			id: opts.userId,
 			name: opts.fullName,

commit a5744de7d48ed7ab99988a6e8ff0e7e4ccb97b40
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Nov 20 14:32:10 2024 +0000

    [botcom] fix sharing defaults (#4956)
    
    The 'shared by default' and 'edit mode by default' settings got
    clobbered during the backend refactor.
    
    ### Change type
    
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index eeadc5a38..1fa8ab9cf 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -230,8 +230,8 @@ export class TldrawApp {
 			name: '',
 			published: false,
 			publishedSlug: uniqueId(),
-			shared: false,
-			sharedLinkType: 'view',
+			shared: true,
+			sharedLinkType: 'edit',
 			thumbnail: '',
 			updatedAt: Date.now(),
 		}

commit 0a72b222845e11b46631140751c62adac0c93738
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Nov 22 12:44:23 2024 +0100

    Improve the names for files that have no name set (#4962)
    
    Show different time formats for files from different periods.
    
    ![CleanShot 2024-11-20 at 17 49
    26](https://github.com/user-attachments/assets/708951c2-f2f0-4425-b994-0d7d3b13eeb4)
    
    Feels like we have too many sections in the sidebar, should we pair them
    down?
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fixed a bug with…

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 1fa8ab9cf..575f26355 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -23,6 +23,8 @@ import {
 	objectMapKeys,
 	react,
 } from 'tldraw'
+import { getDateFormat } from '../utils/dates'
+import { createIntl } from './i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
@@ -250,7 +252,20 @@ export class TldrawApp {
 		}
 		if (!file) return ''
 		assert(typeof file !== 'string', 'ok')
-		return file.name.trim() || new Date(file.createdAt).toLocaleString('en-gb')
+
+		const name = file.name.trim()
+		if (name) {
+			return name
+		}
+
+		const intl = createIntl()
+		const createdAt = new Date(file.createdAt)
+		if (intl) {
+			const format = getDateFormat(createdAt)
+			return intl.formatDate(createdAt, format)
+		}
+		const locale = this.user$.get()?.locale
+		return new Date(createdAt).toLocaleString(locale ?? 'en-gb')
 	}
 
 	claimTemporaryFile(fileId: string) {

commit 73f6dccd86f2a06575be2e8c64920959adf5537a
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Nov 24 14:07:38 2024 +0000

    Add eslint rule for react-intl. (#4983)
    
    We want all of our files to use our wrapped version of react-intl. This
    _should_ fix auto imports resolving to react-int by mistake.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 575f26355..cebb6e736 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -24,7 +24,7 @@ import {
 	react,
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
-import { createIntl } from './i18n'
+import { createIntl } from '../utils/i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`

commit 68491f0ffc96f801d17620680b738173dec29e20
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Nov 24 21:14:33 2024 +0000

    Revert "Add eslint rule for react-intl." (#4985)
    
    Reverts tldraw/tldraw#4983

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index cebb6e736..575f26355 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -24,7 +24,7 @@ import {
 	react,
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
-import { createIntl } from '../utils/i18n'
+import { createIntl } from './i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`

commit bcec83df43974b4084e63289048fe526a6619991
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 25 09:28:16 2024 +0000

    [botcom] simplify replicator dispatch logic (#4965)
    
    This stuff was a little bit of a mess. I made it synchronous again and
    hopefully caught an extra edge case or two.
    
    - added a `isFileOwner` field to file_state, populated by triggers on
    both the file table and the file_state table.
    - used `isFileOwner` to avoid checking ownership while dispatching
    events in the replicator
    - simplified the event dispatching logic by moving it out into separate
    methods for each table, so it's easier to follow what's happening.
    - fixed the 'file deleting isn't working in prod' bug, that was to do
    with r2 complaining about things it doesn't complain about in dev mode.
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 575f26355..1e81d94ba 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -328,6 +328,7 @@ export class TldrawApp {
 					lastEditAt: null,
 					lastSessionState: null,
 					lastVisitAt: null,
+					isFileOwner: true,
 				})
 			}
 		})
@@ -458,6 +459,9 @@ export class TldrawApp {
 				lastEditAt: null,
 				lastSessionState: null,
 				lastVisitAt: null,
+				// doesn't really matter what this is because it is
+				// overwritten by postgres
+				isFileOwner: this.isFileOwner(fileId),
 			})
 		}
 		fileState = this.getFileState(fileId)

commit 85f7e12bb2e2f85e0071a9e2c2b83395995c501c
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Nov 25 11:02:36 2024 +0100

    Use tla user's color and pass it to the editor. (#4973)
    
    User's color was changing between reloads.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Login
    2. Check the color in the people menu.
    3. Reload.
    4. The color should not change.
    
    ### Release notes
    
    - User's color should now persist between sessions.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 1e81d94ba..1638e322d 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -18,6 +18,7 @@ import {
 	atom,
 	computed,
 	createTLUser,
+	defaultUserPreferences,
 	getUserPreferences,
 	objectMapFromEntries,
 	objectMapKeys,
@@ -523,7 +524,7 @@ export class TldrawApp {
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
 
-		const { id: _id, name: _name, color: _color, ...restOfPreferences } = getUserPreferences()
+		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
 		const app = new TldrawApp(opts.userId, opts.getToken)
 		// @ts-expect-error
 		window.app = app
@@ -531,7 +532,7 @@ export class TldrawApp {
 			id: opts.userId,
 			name: opts.fullName,
 			email: opts.email,
-			color: 'salmon',
+			color: color ?? defaultUserPreferences.color,
 			avatar: opts.avatar,
 			exportFormat: 'png',
 			exportTheme: 'light',

commit 97c326de08e1c0e6bd3f08596d958f28a0e25ec3
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Nov 25 11:37:50 2024 +0100

    Wait for the guest file to be loaded before showing an entry in the sidebar (#4977)
    
    ### Before
    
    
    https://github.com/user-attachments/assets/24e5bdaf-483f-4f39-a73f-fbd709293ef0
    
    ### After
    
    
    https://github.com/user-attachments/assets/46aa6e15-06c6-4f83-8c92-200af64da5c7
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - We only show the guest file in the sidebar when the file record is
    loaded. Otherwise we get this file name flickering since we don't have
    the file name when we just visit the shared link.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 1638e322d..fc88c54f7 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -185,6 +185,7 @@ export class TldrawApp {
 				continue
 			}
 			const file = myFiles[fileId]
+			if (!file) continue
 			const state = myStates[fileId]
 
 			nextRecentFileOrdering.push({

commit 5bcd5873e53853dbf0603292f2a3aadca23aa3db
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Nov 25 17:12:29 2024 +0000

    [botcom] Pre-launch design / UX pass (#4984)
    
    Are you ready to go? I'm ready to go! This PR does a few design and UX
    changes ahead of the launch.
    
    Logged out, root page
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 05 17"
    src="https://github.com/user-attachments/assets/b4b0dea7-5140-417e-b9fd-986a571eeaba">
    
    Logged out, published page
    
    <img width="1241" alt="image"
    src="https://github.com/user-attachments/assets/fb7435b4-9713-43c8-991d-e6db60f18237">
    
    Logged out, file page
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 05 59"
    src="https://github.com/user-attachments/assets/afebe371-8808-400a-bac8-d5055cf53698">
    
    Logged in, file page
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 01 05"
    src="https://github.com/user-attachments/assets/1da95e8d-e000-4fab-95c4-1beb58ea372c">
    
    Logged in, guest file
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 02 33"
    src="https://github.com/user-attachments/assets/2a5a3ff5-11e1-46db-af2d-7d3ac9eb3778">
    
    Logged in, published file
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 03 26"
    src="https://github.com/user-attachments/assets/d832775e-ac55-43a4-8f93-35e1793a92a7">
    
    
    ### General sidebar / editor
    - parts sidebar components into their own files
    - cleans up some weird props in sidebar items
    - fixes spacing in the "workspace header"
    - fixes spacing in the file editor top left
    - fix icon weight difference in file editor top left
    - set mobile sidebar width to max(220px, 100%-100px)
    - animate desktop sidebar open/close
    - move menu items into the file menu (except for app-level things)
    - adds sidebar items to menu for logged out users
    - adds sign in to menu for logged out users
    - adds shortcut (Cmd + \) to toggle sidebar on desktop
    
    <img width="1241" alt="Screenshot 2024-11-24 at 21 03 43"
    src="https://github.com/user-attachments/assets/5e32019b-ef7f-457a-9d76-c94710e8c832">
    
    <img width="577" alt="image"
    src="https://github.com/user-attachments/assets/426b718d-d788-4503-bcdb-d5d1ce269e92">
    
    
    ### Anon layout
    - redesign anonymous layout
    - remove share menu / export options from anon pages
    
    ### Publish menu
    - redesign share menu for published projects
    
    ### Guest file
    - adds a temporary "collaborator" in sidebar for guest files
    - fix a bug where a user could edit the name of a file they don't own
    
    ### Creating too many pages
    - adds 1s timeout for creating new files
    
    ### Published file
    - fix document name in published files
    
    ### Sidebar user link
    - moved editor-related preferences into the editor
    - extracted the theme and language (they appear in both menus)
    
    <img width="417" alt="image"
    src="https://github.com/user-attachments/assets/550dcbbe-7b3a-46e4-b29a-d1ceff313b11">
    
    ### useMsg
    
    Add a `useMsg` hook that calls `useIntl().formatMessage`.
    
    ### Playground
    - creates a very small playground route where we can view components in
    different states. I don't like committing to this kind of storybook
    style documentation, so let's just use this when needed.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index fc88c54f7..1ba3df1a6 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -25,7 +25,7 @@ import {
 	react,
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
-import { createIntl } from './i18n'
+import { createIntl } from '../utils/i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
@@ -252,7 +252,10 @@ export class TldrawApp {
 		if (typeof file === 'string') {
 			file = this.getFile(file)
 		}
-		if (!file) return ''
+		if (!file) {
+			// possibly a published file
+			return ''
+		}
 		assert(typeof file !== 'string', 'ok')
 
 		const name = file.name.trim()
@@ -363,7 +366,8 @@ export class TldrawApp {
 		})
 	}
 
-	getFile(fileId: string): TlaFile | null {
+	getFile(fileId?: string): TlaFile | null {
+		if (!fileId) return null
 		return this.getUserOwnFiles().find((f) => f.id === fileId) ?? null
 	}
 

commit d9448fa3621c301a2b3a5de9ee2e5b67e14ff3a4
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Nov 25 18:30:53 2024 +0100

    Soft deleting of files (#4992)
    
    Instead of deleting the files we now soft delete them. I kept the whole
    delete logic the same as before, which should allow us to delete the
    file from postgres which will trigger all other necessary file deletes.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Add soft deleting of files.
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 1ba3df1a6..89b2843e6 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -179,13 +179,13 @@ export class TldrawApp {
 		const nextRecentFileOrdering = []
 
 		for (const fileId of myFileIds) {
+			const file = myFiles[fileId]
+			if (!file) continue
 			const existing = this.lastRecentFileOrdering?.find((f) => f.fileId === fileId)
 			if (existing) {
 				nextRecentFileOrdering.push(existing)
 				continue
 			}
-			const file = myFiles[fileId]
-			if (!file) continue
 			const state = myStates[fileId]
 
 			nextRecentFileOrdering.push({
@@ -238,6 +238,7 @@ export class TldrawApp {
 			sharedLinkType: 'edit',
 			thumbnail: '',
 			updatedAt: Date.now(),
+			isDeleted: false,
 		}
 		if (typeof fileOrId === 'object') {
 			Object.assign(file, fileOrId)
@@ -420,7 +421,7 @@ export class TldrawApp {
 		this.z.mutate((tx) => {
 			tx.file_state.delete({ fileId, userId: this.userId })
 			if (file?.ownerId === this.userId) {
-				tx.file.delete({ id: fileId })
+				tx.file.update({ ...file, isDeleted: true })
 			}
 		})
 	}
@@ -458,7 +459,7 @@ export class TldrawApp {
 	async getOrCreateFileState(fileId: string) {
 		let fileState = this.getFileState(fileId)
 		if (!fileState) {
-			await this.z.mutate.file_state.create({
+			this.z.mutate.file_state.create({
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),

commit 97e22c78a866d7e7e8db10d6f513d363f914d22c
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Nov 26 12:00:00 2024 +0100

    Fix an issue when navigating back to a forgoten file did not restore it. (#4996)
    
    The issue was that recent files was still returning the forgotten file,
    which meant that we did not navigate to a new file. So when you then
    went back in the browser you landed on the same route which didn't rerun
    the logic to enter a file.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Open a shared file.
    2. Forget the file.
    3. Navigate back in the browser.
    4. The forgotten file should reappear.
    
    ### Release notes
    
    - Fixes an issue when navigating back to a forgotten file did not
    restore it.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 89b2843e6..c3b45271a 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -180,13 +180,13 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			if (!file) continue
+			const state = myStates[fileId]
+			if (!file || !state) continue
 			const existing = this.lastRecentFileOrdering?.find((f) => f.fileId === fileId)
 			if (existing) {
 				nextRecentFileOrdering.push(existing)
 				continue
 			}
-			const state = myStates[fileId]
 
 			nextRecentFileOrdering.push({
 				fileId,

commit 0230a65755bbfa835e8fbc30bc5ec46290305cf0
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Nov 26 12:31:16 2024 +0100

    Use partials when mutating (#4993)
    
    This moves away for sending the whole entity when doing updates and
    instead just sends the changes. Should prevent:
    - overwriting data (which has already hit PG, but has not reached the
    current user)
    - rejection of valid mutations (user might have some invalid optimistic
    updates and if we then do any other changes to those same entities then
    these later, possibly valid, mutations would get rejected due to that
    first change).
    - there's still [one case where we update the whole
    entity](https://github.com/tldraw/tldraw/blob/519f424459a980e423d6aad8a9f1a1184e99d4d1/apps/dotcom/client/src/tla/app/TldrawApp.ts#L148-L151),
    but it looks like that should maybe stay as is?
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Only send the changed columns when doing update mutations.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index c3b45271a..c04c81f12 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -2,6 +2,7 @@
 import {
 	CreateFilesResponseBody,
 	TlaFile,
+	TlaFilePartial,
 	TlaFileState,
 	TlaUser,
 	UserPreferencesKeys,
@@ -143,11 +144,14 @@ export class TldrawApp {
 		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
 			const user = this.getUser()
 
+			const nonNull = Object.fromEntries(
+				Object.entries(others).filter(([_, value]) => value !== null)
+			) as Partial<TLUserPreferences>
+
 			this.z.mutate((tx) => {
 				tx.user.update({
-					...user,
-					// TODO: remove nulls
-					...(others as TlaUser),
+					id: user.id,
+					...(nonNull as any),
 				})
 			})
 		},
@@ -288,7 +292,7 @@ export class TldrawApp {
 
 		this.z.mutate((tx) => {
 			tx.file.update({
-				...file,
+				id: fileId,
 				shared: !file.shared,
 			})
 		})
@@ -359,7 +363,7 @@ export class TldrawApp {
 		// Optimistic update
 		this.z.mutate((tx) => {
 			tx.file.update({
-				...file,
+				id: fileId,
 				name,
 				published: true,
 				lastPublished: Date.now(),
@@ -381,9 +385,9 @@ export class TldrawApp {
 		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
 	}
 
-	updateFile(fileId: string, cb: (file: TlaFile) => TlaFile) {
-		const file = this.requireFile(fileId)
-		this.z.mutate.file.update(cb(file))
+	updateFile(partial: TlaFilePartial) {
+		this.requireFile(partial.id)
+		this.z.mutate.file.update(partial)
 	}
 
 	/**
@@ -401,7 +405,7 @@ export class TldrawApp {
 		// Optimistic update
 		this.z.mutate((tx) => {
 			tx.file.update({
-				...file,
+				id: fileId,
 				published: false,
 			})
 		})
@@ -421,7 +425,7 @@ export class TldrawApp {
 		this.z.mutate((tx) => {
 			tx.file_state.delete({ fileId, userId: this.userId })
 			if (file?.ownerId === this.userId) {
-				tx.file.update({ ...file, isDeleted: true })
+				tx.file.update({ id: fileId, isDeleted: true })
 			}
 		})
 	}
@@ -434,15 +438,18 @@ export class TldrawApp {
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.z.mutate.file.update({ ...file, shared: false })
+			this.z.mutate.file.update({ id: fileId, shared: false })
 			return
 		}
-		this.z.mutate.file.update({ ...file, shared: true, sharedLinkType })
+		this.z.mutate.file.update({ id: fileId, shared: true, sharedLinkType })
 	}
 
-	updateUser(cb: (user: TlaUser) => TlaUser) {
+	updateUser(partial: Partial<TlaUser>) {
 		const user = this.getUser()
-		this.z.mutate.user.update(cb(user))
+		this.z.mutate.user.update({
+			id: user.id,
+			...partial,
+		})
 	}
 
 	updateUserExportPreferences(
@@ -450,10 +457,7 @@ export class TldrawApp {
 			Pick<TlaUser, 'exportFormat' | 'exportPadding' | 'exportBackground' | 'exportTheme'>
 		>
 	) {
-		this.updateUser((user) => ({
-			...user,
-			...exportPreferences,
-		}))
+		this.updateUser(exportPreferences)
 	}
 
 	async getOrCreateFileState(fileId: string) {
@@ -480,41 +484,37 @@ export class TldrawApp {
 		return this.getUserFileStates().find((f) => f.fileId === fileId)
 	}
 
-	updateFileState(fileId: string, cb: (fileState: TlaFileState) => TlaFileState) {
+	updateFileState(fileId: string, cb: (fileState: TlaFileState) => Partial<TlaFileState>) {
 		const fileState = this.getFileState(fileId)
 		if (!fileState) return
 		// remove relationship because zero complains
 		const { file: _, ...rest } = fileState
-		this.z.mutate.file_state.update(cb(rest))
+		this.z.mutate.file_state.update({ ...cb(rest), fileId, userId: fileState.userId })
 	}
 
 	async onFileEnter(fileId: string) {
 		await this.getOrCreateFileState(fileId)
 		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
 			firstVisitAt: fileState.firstVisitAt ?? Date.now(),
 			lastVisitAt: Date.now(),
 		}))
 	}
 
 	onFileEdit(fileId: string) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
+		this.updateFileState(fileId, () => ({
 			lastEditAt: Date.now(),
 		}))
 	}
 
 	onFileSessionStateUpdate(fileId: string, sessionState: TLSessionStateSnapshot) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
+		this.updateFileState(fileId, () => ({
 			lastSessionState: JSON.stringify(sessionState),
 			lastVisitAt: Date.now(),
 		}))
 	}
 
 	onFileExit(fileId: string) {
-		this.updateFileState(fileId, (fileState) => ({
-			...fileState,
+		this.updateFileState(fileId, () => ({
 			lastVisitAt: Date.now(),
 		}))
 	}

commit 1087156a4c091be9c65fefb0d811edee3cd815c1
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Nov 26 16:44:09 2024 +0100

    Improve mutation rejection toasts (#4999)
    
    Throttles them (3s). Uses different messages for different error codes.
    
    You can test this by setting `rateLimited` to `true` and sending
    different `ZErrorCodes`
    [here](https://github.com/tldraw/tldraw/blob/eb0cbe7e18aaee9f017de2e6c2ce360130cd2fe9/apps/dotcom/sync-worker/src/TLUserDurableObject.ts#L171-L188).
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index c04c81f12..6a2353094 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -6,8 +6,9 @@ import {
 	TlaFileState,
 	TlaUser,
 	UserPreferencesKeys,
+	ZErrorCode,
 } from '@tldraw/dotcom-shared'
-import { Result, assert, fetch, structuredClone, uniqueId } from '@tldraw/utils'
+import { Result, assert, fetch, structuredClone, throttle, uniqueId } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
 	Signal,
@@ -26,7 +27,7 @@ import {
 	react,
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
-import { createIntl } from '../utils/i18n'
+import { IntlShape, defineMessages } from '../utils/i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
@@ -68,6 +69,8 @@ export class TldrawApp {
 	}
 
 	toasts: TLUiToastsContextType | null = null
+	intl: IntlShape | null = null
+
 	private constructor(
 		public readonly userId: string,
 		getToken: () => Promise<string | null>
@@ -85,12 +88,7 @@ export class TldrawApp {
 			// schema,
 			// This is often easier to develop with if you're frequently changing
 			// the schema. Switch to 'idb' for local-persistence.
-			onMutationRejected: (errorCode) => {
-				this.toasts?.addToast({
-					title: 'That didn’t work',
-					description: `Error code: ${errorCode}`,
-				})
-			},
+			onMutationRejected: this.showMutationRejectionToast,
 		})
 		this.disposables.push(() => this.z.dispose())
 
@@ -124,6 +122,31 @@ export class TldrawApp {
 		await this.z.query.file.where('ownerId', this.userId).preload().complete
 	}
 
+	messages = defineMessages({
+		publish_failed: { defaultMessage: 'Unable to publish the file' },
+		unpublish_failed: { defaultMessage: 'Unable to unpublish the file' },
+		republish_failed: { defaultMessage: 'Unable to publish the changes' },
+		unknown_error: { defaultMessage: 'An unexpected error occurred' },
+		forbidden: {
+			defaultMessage: 'You do not have the necessary permissions to perform this action',
+		},
+		bad_request: { defaultMessage: 'Invalid request' },
+		rate_limit_exceeded: { defaultMessage: 'You have exceeded the rate limit' },
+		mutation_error_toast_title: { defaultMessage: "That didn't work" },
+	})
+
+	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
+		const descriptor = this.messages[errorCode]
+		// Looks like we don't get type safety here
+		if (!descriptor) {
+			console.error('Could not find a translation for this error code', errorCode)
+		}
+		this.toasts?.addToast({
+			title: this.intl?.formatMessage(this.messages.mutation_error_toast_title),
+			description: this.intl?.formatMessage(descriptor ?? this.messages.unknown_error),
+		})
+	}, 3000)
+
 	dispose() {
 		this.disposables.forEach((d) => d())
 		// this.store.dispose()
@@ -268,11 +291,10 @@ export class TldrawApp {
 			return name
 		}
 
-		const intl = createIntl()
 		const createdAt = new Date(file.createdAt)
-		if (intl) {
+		if (this.intl) {
 			const format = getDateFormat(createdAt)
-			return intl.formatDate(createdAt, format)
+			return this.intl.formatDate(createdAt, format)
 		}
 		const locale = this.user$.get()?.locale
 		return new Date(createdAt).toLocaleString(locale ?? 'en-gb')

commit 6f131fe14490e4958fea775e693e1b8cd49e66d6
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 26 15:50:50 2024 +0000

    [botcom] owner info in side bar (#4994)
    
    Appearance
    <img width="624" alt="image"
    src="https://github.com/user-attachments/assets/61f1b81d-d82c-4d2f-8a95-7bc6bb3792d9">
    Tooltip
    <img width="529" alt="Screenshot 2024-11-26 at 11 04 22"
    src="https://github.com/user-attachments/assets/96186118-9c24-409c-9a57-61d130f02a81">
    No avatar
    <img width="571" alt="image"
    src="https://github.com/user-attachments/assets/db95cd8b-a1e5-47dc-bb35-186370543c5f">
    
    No name
    <img width="614" alt="Screenshot 2024-11-26 at 11 09 00"
    src="https://github.com/user-attachments/assets/663eb29a-8e93-40a6-8809-d93157bebeed">
    
    I tried using the existing `TlaCollaborator` component in the hopes that
    we could consolidate with the people menu at some point, but it ended up
    looking like shit with the border on the avatar when the file is
    selected/hovered. Also not sure the 'first initial' style of avatar that
    we use in the people menu is appropriate here. It was feeling rabbit
    holey and I think it would take significant work to get that stuff all
    working nicely and this PR is not the place to do it. So I just removed
    the unused `TlaCollaborator` component for now.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 6a2353094..cf3da65e2 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -255,6 +255,9 @@ export class TldrawApp {
 		const file: TlaFile = {
 			id: typeof fileOrId === 'string' ? fileOrId : uniqueId(),
 			ownerId: this.userId,
+			// these two owner properties are overridden by postgres triggers
+			ownerAvatar: this.getUser().avatar,
+			ownerName: this.getUser().name,
 			isEmpty: true,
 			createdAt: Date.now(),
 			lastPublished: 0,

commit e9af0c349b54f7add4f540e7b097375244d39498
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Nov 27 11:48:39 2024 +0100

    Fix an issue with `firstVisitAt` not getting set (#5002)
    
    I noticed an issue with `firstVisitAt` not getting getting set when I
    was reviewing #4998. The problem was that we didn't set the
    `firstVisitAt` when we created a new file. We then didn't allow updating
    the `firstVisitAt` field, which meant that it never got populated.
    
    Since we don't allow changing `firstVisitAt` I could also simplify some
    other parts of mutating file state.
    
    File state gets created in two cases:
    - when we create a file we immediately also create the file state (this
    one now correctly sets `firstVisitAt`).
    - for guest files we call `onFileEnter` which in turn calls
    `getOrCreateFileState` which already correctly set the `firstVisitAt` in
    the insert mutation.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index cf3da65e2..efb60a198 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -509,39 +509,32 @@ export class TldrawApp {
 		return this.getUserFileStates().find((f) => f.fileId === fileId)
 	}
 
-	updateFileState(fileId: string, cb: (fileState: TlaFileState) => Partial<TlaFileState>) {
+	updateFileState(fileId: string, partial: Partial<TlaFileState>) {
 		const fileState = this.getFileState(fileId)
 		if (!fileState) return
-		// remove relationship because zero complains
-		const { file: _, ...rest } = fileState
-		this.z.mutate.file_state.update({ ...cb(rest), fileId, userId: fileState.userId })
+		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
 	async onFileEnter(fileId: string) {
 		await this.getOrCreateFileState(fileId)
-		this.updateFileState(fileId, (fileState) => ({
-			firstVisitAt: fileState.firstVisitAt ?? Date.now(),
+		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
-		}))
+		})
 	}
 
 	onFileEdit(fileId: string) {
-		this.updateFileState(fileId, () => ({
-			lastEditAt: Date.now(),
-		}))
+		this.updateFileState(fileId, { lastEditAt: Date.now() })
 	}
 
 	onFileSessionStateUpdate(fileId: string, sessionState: TLSessionStateSnapshot) {
-		this.updateFileState(fileId, () => ({
+		this.updateFileState(fileId, {
 			lastSessionState: JSON.stringify(sessionState),
 			lastVisitAt: Date.now(),
-		}))
+		})
 	}
 
 	onFileExit(fileId: string) {
-		this.updateFileState(fileId, () => ({
-			lastVisitAt: Date.now(),
-		}))
+		this.updateFileState(fileId, { lastVisitAt: Date.now() })
 	}
 
 	static async create(opts: {

commit 2d89d140631cba204155758ccb915e8ee1577638
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Nov 28 09:59:59 2024 +0100

    Fix an issue with drag and dropping the files (#5013)
    
    We got an error saying there was a bad request when drag and dropping
    files. This is because we wanted to create a file state as the file
    owner, but the file did not exist yet (which is not allowed, we only
    allow that for guest files). So we now also create a file together with
    the file state.
    
    
    ![image](https://github.com/user-attachments/assets/2bde9622-e511-4f84-ad08-b1d6dd54e3cc)
    
    I also noticed that the `createFile` function does not need to be async
    and also extracted document names from the files if we have them.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Drag some files to the sidebar.
    2. They should correctly appear (with the correct names if they have
    time) and you should not see any rejected mutation toasts (like the one
    above).

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index efb60a198..1c9df267a 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -12,6 +12,7 @@ import { Result, assert, fetch, structuredClone, throttle, uniqueId } from '@tld
 import pick from 'lodash.pick'
 import {
 	Signal,
+	TLDocument,
 	TLSessionStateSnapshot,
 	TLStoreSnapshot,
 	TLUiToastsContextType,
@@ -22,6 +23,7 @@ import {
 	createTLUser,
 	defaultUserPreferences,
 	getUserPreferences,
+	isDocument,
 	objectMapFromEntries,
 	objectMapKeys,
 	react,
@@ -245,9 +247,9 @@ export class TldrawApp {
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	async createFile(
+	createFile(
 		fileOrId?: string | Partial<TlaFile>
-	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
+	): Result<{ file: TlaFile }, 'max number of files reached'> {
 		if (!this.canCreateNewFile()) {
 			return Result.err('max number of files reached')
 		}
@@ -355,7 +357,19 @@ export class TldrawApp {
 
 		// Also create a file state record for the new file
 		this.z.mutate((tx) => {
-			for (const slug of response.slugs) {
+			for (let i = 0; i < response.slugs.length; i++) {
+				const slug = response.slugs[i]
+				const entries = Object.entries(snapshots[i].store)
+				const documentEntry = entries.find(([_, value]) => isDocument(value)) as
+					| [string, TLDocument]
+					| undefined
+				const name = documentEntry ? documentEntry[1].name : ''
+
+				const result = this.createFile({ id: slug, name })
+				if (!result.ok) {
+					console.error('Could not create file', result.error)
+					continue
+				}
 				tx.file_state.create({
 					userId: this.userId,
 					fileId: slug,

commit 9b421591c22539cd1cd6d3da7287e6d37713c2f6
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Nov 28 12:22:18 2024 +0100

    Fix the file name flashing with an old value (#5015)
    
    App provider is inside the intl provider, so we can just get the intl
    and pass it along.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 1c9df267a..e5acc96d9 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -71,11 +71,11 @@ export class TldrawApp {
 	}
 
 	toasts: TLUiToastsContextType | null = null
-	intl: IntlShape | null = null
 
 	private constructor(
 		public readonly userId: string,
-		getToken: () => Promise<string | null>
+		getToken: () => Promise<string | null>,
+		private intl: IntlShape
 	) {
 		const sessionId = uniqueId()
 		this.z = new Zero({
@@ -297,12 +297,8 @@ export class TldrawApp {
 		}
 
 		const createdAt = new Date(file.createdAt)
-		if (this.intl) {
-			const format = getDateFormat(createdAt)
-			return this.intl.formatDate(createdAt, format)
-		}
-		const locale = this.user$.get()?.locale
-		return new Date(createdAt).toLocaleString(locale ?? 'en-gb')
+		const format = getDateFormat(createdAt)
+		return this.intl.formatDate(createdAt, format)
 	}
 
 	claimTemporaryFile(fileId: string) {
@@ -557,13 +553,14 @@ export class TldrawApp {
 		email: string
 		avatar: string
 		getToken(): Promise<string | null>
+		intl: IntlShape
 	}) {
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
 
 		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
-		const app = new TldrawApp(opts.userId, opts.getToken)
+		const app = new TldrawApp(opts.userId, opts.getToken, opts.intl)
 		// @ts-expect-error
 		window.app = app
 		await app.preload({

commit 0bacaf109bfecc855b795bd672fc1fe6c9e19ec4
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Nov 29 12:09:46 2024 +0000

    [botcom] add protocol version  (#5024)
    
    This enables selective backwards compatibility, i.e. knowing which
    version of a client is running so we can accommodate them or force them
    to upgrade.
    
    Here's what the latter looks like
    <img width="973" alt="image"
    src="https://github.com/user-attachments/assets/c16d3795-d8fa-4d47-ac71-d9d4b68a9ed9">
    
    You can click 'later' and finish up any drawing stuff but you will get
    frequent toasts telling you to reload, and app mutations will not be
    applied even locally, until you do eventually refresh.
    
    Hopefully this should only ever be seen by people who leave their tabs
    running for months at a time. Not sure how we'll do this with zero.
    
    ### Change type
    
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index e5acc96d9..fc1d26431 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -7,6 +7,7 @@ import {
 	TlaUser,
 	UserPreferencesKeys,
 	ZErrorCode,
+	Z_PROTOCOL_VERSION,
 } from '@tldraw/dotcom-shared'
 import { Result, assert, fetch, structuredClone, throttle, uniqueId } from '@tldraw/utils'
 import pick from 'lodash.pick'
@@ -75,6 +76,7 @@ export class TldrawApp {
 	private constructor(
 		public readonly userId: string,
 		getToken: () => Promise<string | null>,
+		onClientTooOld: () => void,
 		private intl: IntlShape
 	) {
 		const sessionId = uniqueId()
@@ -82,15 +84,19 @@ export class TldrawApp {
 			// userID: userId,
 			// auth: encodedJWT,
 			getUri: async () => {
+				const params = new URLSearchParams({
+					sessionId,
+					protocolVersion: String(Z_PROTOCOL_VERSION),
+				})
 				const token = await getToken()
-				if (!token)
-					return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=no-token-found&sessionId=${sessionId}`
-				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?accessToken=${token}&sessionId=${sessionId}`
+				params.set('accessToken', token || 'no-token-found')
+				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?${params}`
 			},
 			// schema,
 			// This is often easier to develop with if you're frequently changing
 			// the schema. Switch to 'idb' for local-persistence.
 			onMutationRejected: this.showMutationRejectionToast,
+			onClientTooOld: () => onClientTooOld(),
 		})
 		this.disposables.push(() => this.z.dispose())
 
@@ -134,7 +140,10 @@ export class TldrawApp {
 		},
 		bad_request: { defaultMessage: 'Invalid request' },
 		rate_limit_exceeded: { defaultMessage: 'You have exceeded the rate limit' },
-		mutation_error_toast_title: { defaultMessage: "That didn't work" },
+		mutation_error_toast_title: { defaultMessage: 'Error' },
+		client_too_old: {
+			defaultMessage: 'Please refresh the page to get the latest version of tldraw',
+		},
 	})
 
 	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
@@ -553,6 +562,7 @@ export class TldrawApp {
 		email: string
 		avatar: string
 		getToken(): Promise<string | null>
+		onClientTooOld(): void
 		intl: IntlShape
 	}) {
 		// This is an issue: we may have a user record but not in the store.
@@ -560,7 +570,7 @@ export class TldrawApp {
 		// of the store... but we should probably identify that better.
 
 		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
-		const app = new TldrawApp(opts.userId, opts.getToken, opts.intl)
+		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld, opts.intl)
 		// @ts-expect-error
 		window.app = app
 		await app.preload({

commit dcd4d4f3d17123cb4d18ae8f99f62180f3b3aed6
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Dec 2 17:00:24 2024 +0000

    [botcom] Set document title from file name (#5042)
    
    This PR copies Chat GPT's behavior of replacing the `document.title`
    with the name of the current file.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index fc1d26431..36a6e2b88 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -290,7 +290,9 @@ export class TldrawApp {
 		return Result.ok({ file })
 	}
 
-	getFileName(file: TlaFile | string | null) {
+	getFileName(file: TlaFile | string | null, useDateFallback: false): string | undefined
+	getFileName(file: TlaFile | string | null, useDateFallback?: true): string
+	getFileName(file: TlaFile | string | null, useDateFallback = true) {
 		if (typeof file === 'string') {
 			file = this.getFile(file)
 		}
@@ -305,9 +307,13 @@ export class TldrawApp {
 			return name
 		}
 
-		const createdAt = new Date(file.createdAt)
-		const format = getDateFormat(createdAt)
-		return this.intl.formatDate(createdAt, format)
+		if (useDateFallback) {
+			const createdAt = new Date(file.createdAt)
+			const format = getDateFormat(createdAt)
+			return this.intl.formatDate(createdAt, format)
+		}
+
+		return
 	}
 
 	claimTemporaryFile(fileId: string) {

commit 3683601e879e4531acb39a92b3dffd4d92beb01d
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Dec 4 16:57:06 2024 +0000

    i18n: cleanup some missings strings; rework automation (#5068)
    
    just some translations updates. also, change the automation flow to
    create a PR once a week instead of trying to commit to main.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 36a6e2b88..2f825ffa6 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -131,18 +131,18 @@ export class TldrawApp {
 	}
 
 	messages = defineMessages({
-		publish_failed: { defaultMessage: 'Unable to publish the file' },
-		unpublish_failed: { defaultMessage: 'Unable to unpublish the file' },
-		republish_failed: { defaultMessage: 'Unable to publish the changes' },
-		unknown_error: { defaultMessage: 'An unexpected error occurred' },
+		publish_failed: { defaultMessage: 'Unable to publish the file.' },
+		unpublish_failed: { defaultMessage: 'Unable to unpublish the file.' },
+		republish_failed: { defaultMessage: 'Unable to publish the changes.' },
+		unknown_error: { defaultMessage: 'An unexpected error occurred.' },
 		forbidden: {
-			defaultMessage: 'You do not have the necessary permissions to perform this action',
+			defaultMessage: 'You do not have the necessary permissions to perform this action.',
 		},
-		bad_request: { defaultMessage: 'Invalid request' },
-		rate_limit_exceeded: { defaultMessage: 'You have exceeded the rate limit' },
+		bad_request: { defaultMessage: 'Invalid request.' },
+		rate_limit_exceeded: { defaultMessage: 'You have exceeded the rate limit.' },
 		mutation_error_toast_title: { defaultMessage: 'Error' },
 		client_too_old: {
-			defaultMessage: 'Please refresh the page to get the latest version of tldraw',
+			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
 		},
 	})
 

commit 4ecbef54a7fe82634fe682ed148165bc496b7b56
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Dec 6 13:52:44 2024 +0000

    [botcom] slurp local files on sign in (#5059)
    
    This PR replaces the temporary multiplayer room from the logged out root
    page with the previous local editor, and 'slurps' the data into a new
    room during the sign in flow.
    
    If something goes wrong the user sees this:
    <img width="541" alt="image"
    src="https://github.com/user-attachments/assets/92413d9a-a90c-43b6-b05d-4e0acdc7db30">
    
    follow up work:
    
    - [ ] e2e tests
    - [ ] add Terms and conditions checkbox to sign in
    
    I'll create tickets for these upon merging.
    
    
    ### Change type
    
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 2f825ffa6..8429b12d2 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -316,10 +316,13 @@ export class TldrawApp {
 		return
 	}
 
-	claimTemporaryFile(fileId: string) {
-		// TODO(david): check that you can't claim someone else's file (the db insert should fail)
-		// TODO(zero stuff): add table constraint
-		this.createFile(fileId)
+	_slurpFileId: string | null = null
+	slurpFile() {
+		const res = this.createFile()
+		if (res.ok) {
+			this._slurpFileId = res.value.file.id
+		}
+		return res
 	}
 
 	toggleFileShared(fileId: string) {

commit bbc8eb37ddd6b600e56253aa063a56ac5ed4c2c7
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Dec 9 10:27:32 2024 +0100

    Fix locale changes. (#5092)
    
    File names in the sidebar did not change when you changed the language.
    This fixes it.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create some files that don't have names set (they show file creation
    date).
    2. Change the language.
    3. It should update the filenames accordingly.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 8429b12d2..ac5a872a9 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -30,7 +30,7 @@ import {
 	react,
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
-import { IntlShape, defineMessages } from '../utils/i18n'
+import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
@@ -76,8 +76,7 @@ export class TldrawApp {
 	private constructor(
 		public readonly userId: string,
 		getToken: () => Promise<string | null>,
-		onClientTooOld: () => void,
-		private intl: IntlShape
+		onClientTooOld: () => void
 	) {
 		const sessionId = uniqueId()
 		this.z = new Zero({
@@ -153,8 +152,8 @@ export class TldrawApp {
 			console.error('Could not find a translation for this error code', errorCode)
 		}
 		this.toasts?.addToast({
-			title: this.intl?.formatMessage(this.messages.mutation_error_toast_title),
-			description: this.intl?.formatMessage(descriptor ?? this.messages.unknown_error),
+			title: this.getIntl().formatMessage(this.messages.mutation_error_toast_title),
+			description: this.getIntl().formatMessage(descriptor ?? this.messages.unknown_error),
 		})
 	}, 3000)
 
@@ -310,7 +309,7 @@ export class TldrawApp {
 		if (useDateFallback) {
 			const createdAt = new Date(file.createdAt)
 			const format = getDateFormat(createdAt)
-			return this.intl.formatDate(createdAt, format)
+			return this.getIntl().formatDate(createdAt, format)
 		}
 
 		return
@@ -572,14 +571,13 @@ export class TldrawApp {
 		avatar: string
 		getToken(): Promise<string | null>
 		onClientTooOld(): void
-		intl: IntlShape
 	}) {
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
 
 		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
-		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld, opts.intl)
+		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld)
 		// @ts-expect-error
 		window.app = app
 		await app.preload({
@@ -607,4 +605,16 @@ export class TldrawApp {
 		})
 		return { app, userId: opts.userId }
 	}
+
+	getIntl() {
+		const intl = createIntl()
+		if (intl) return intl
+		// intl should exists since IntlWrapper should create it before we get here, but let's use this just in case
+		setupCreateIntl({
+			defaultLocale: 'en',
+			locale: this.user$.get()?.locale ?? 'en',
+			messages: {},
+		})
+		return createIntl()!
+	}
 }

commit 2f6593e71b5f5a4ed1d7db92cd0bf6394db02cfa
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Dec 9 15:53:23 2024 +0000

    [botcom] delete old debug thing (#5102)
    
    oops
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index ac5a872a9..6e6424301 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -62,9 +62,6 @@ export class TldrawApp {
 		view.addListener((res: any) => {
 			val$.set(structuredClone(res) as any)
 		})
-		react('blah', () => {
-			val$.get()
-		})
 		this.disposables.push(() => {
 			view.destroy()
 		})

commit f59352ba12836cfa78aee8be4d1e6ac02b3193f0
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Dec 16 10:18:34 2024 +0000

    [botcom] Add pinned files (#5119)
    
    This PR adds a pinned files feature.
    
    <img width="747" alt="Screenshot 2024-12-14 at 14 52 32"
    src="https://github.com/user-attachments/assets/82924750-757d-441a-9062-97b920fa798b"
    />
    
    - A file_state tracks whether a user has pinned a file
    - A user may pin or unpin a file from the file menu
    - A user's pinned files are displayed in a section at the top of their
    recent files
    - The order of pinned files is determined by most recently-edited
    
    ### Change type
    
    - [x] `other`
    
    ### Test plan
    
    - [x] End to end tests

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 6e6424301..65f5e22f7 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -201,7 +201,11 @@ export class TldrawApp {
 		return this.fileStates$.get()
 	}
 
-	lastRecentFileOrdering = null as null | Array<{ fileId: string; date: number }>
+	lastRecentFileOrdering = null as null | Array<{
+		fileId: TlaFile['id']
+		isPinned: boolean
+		date: number
+	}>
 
 	@computed
 	getUserRecentFiles() {
@@ -210,26 +214,42 @@ export class TldrawApp {
 
 		const myFileIds = new Set<string>([...objectMapKeys(myFiles), ...objectMapKeys(myStates)])
 
-		const nextRecentFileOrdering = []
+		const nextRecentFileOrdering: {
+			fileId: TlaFile['id']
+			isPinned: boolean
+			date: number
+		}[] = []
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
 			const state = myStates[fileId]
 			if (!file || !state) continue
 			const existing = this.lastRecentFileOrdering?.find((f) => f.fileId === fileId)
-			if (existing) {
+			if (existing && existing.isPinned === state.isPinned) {
 				nextRecentFileOrdering.push(existing)
 				continue
 			}
 
 			nextRecentFileOrdering.push({
 				fileId,
-				date: state?.lastEditAt ?? state?.firstVisitAt ?? file?.createdAt ?? 0,
+				isPinned: state.isPinned ?? false,
+				date: state.lastEditAt ?? state.firstVisitAt ?? file.createdAt ?? 0,
 			})
 		}
 
+		// sort by date with most recent first
 		nextRecentFileOrdering.sort((a, b) => b.date - a.date)
+
+		// move pinned files to the top, stable sort
+		nextRecentFileOrdering.sort((a, b) => {
+			if (a.isPinned && !b.isPinned) return -1
+			if (!a.isPinned && b.isPinned) return 1
+			return 0
+		})
+
+		// stash the ordering for next time
 		this.lastRecentFileOrdering = nextRecentFileOrdering
+
 		return nextRecentFileOrdering
 	}
 
@@ -388,6 +408,7 @@ export class TldrawApp {
 					lastSessionState: null,
 					lastVisitAt: null,
 					isFileOwner: true,
+					isPinned: false,
 				})
 			}
 		})
@@ -471,7 +492,7 @@ export class TldrawApp {
 		const file = this.getFile(fileId)
 
 		// Optimistic update, remove file and file states
-		this.z.mutate((tx) => {
+		return this.z.mutate((tx) => {
 			tx.file_state.delete({ fileId, userId: this.userId })
 			if (file?.ownerId === this.userId) {
 				tx.file.update({ id: fileId, isDeleted: true })
@@ -479,6 +500,23 @@ export class TldrawApp {
 		})
 	}
 
+	/**
+	 * Pin a file (or unpin it if it's already pinned).
+	 *
+	 * @param fileId - The file id.
+	 */
+	async pinOrUnpinFile(fileId: string) {
+		const fileState = this.getFileState(fileId)
+
+		if (!fileState) return
+
+		return this.z.mutate.file_state.update({
+			fileId,
+			userId: this.userId,
+			isPinned: !fileState.isPinned,
+		})
+	}
+
 	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
 		const file = this.requireFile(fileId)
 
@@ -519,6 +557,7 @@ export class TldrawApp {
 				lastEditAt: null,
 				lastSessionState: null,
 				lastVisitAt: null,
+				isPinned: false,
 				// doesn't really matter what this is because it is
 				// overwritten by postgres
 				isFileOwner: this.isFileOwner(fileId),

commit 58beacd20b55f77f5b1e52c819158ddfcc7b9cc8
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 13 15:09:40 2025 +0000

    [botcom] Translation tweaks (#5184)
    
    This PR makes minor copy changes to the translations. Ready to
    translate!
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 65f5e22f7..eacda9abb 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -127,30 +127,49 @@ export class TldrawApp {
 	}
 
 	messages = defineMessages({
-		publish_failed: { defaultMessage: 'Unable to publish the file.' },
-		unpublish_failed: { defaultMessage: 'Unable to unpublish the file.' },
-		republish_failed: { defaultMessage: 'Unable to publish the changes.' },
-		unknown_error: { defaultMessage: 'An unexpected error occurred.' },
+		// toast title
+		mutation_error_toast_title: { defaultMessage: 'Error' },
+		// toast descriptions
+		publish_failed: {
+			defaultMessage: 'Unable to publish the file.',
+		},
+		unpublish_failed: {
+			defaultMessage: 'Unable to unpublish the file.',
+		},
+		republish_failed: {
+			defaultMessage: 'Unable to publish the changes.',
+		},
+		unknown_error: {
+			defaultMessage: 'An unexpected error occurred.',
+		},
 		forbidden: {
 			defaultMessage: 'You do not have the necessary permissions to perform this action.',
 		},
-		bad_request: { defaultMessage: 'Invalid request.' },
-		rate_limit_exceeded: { defaultMessage: 'You have exceeded the rate limit.' },
-		mutation_error_toast_title: { defaultMessage: 'Error' },
+		bad_request: {
+			defaultMessage: 'Invalid request.',
+		},
+		rate_limit_exceeded: {
+			defaultMessage: 'Rate limit exceeded, try again later.',
+		},
 		client_too_old: {
 			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
 		},
 	})
 
-	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
-		const descriptor = this.messages[errorCode]
-		// Looks like we don't get type safety here
-		if (!descriptor) {
-			console.error('Could not find a translation for this error code', errorCode)
+	getMessage(id: keyof typeof this.messages) {
+		let msg = this.messages[id]
+		if (!msg) {
+			console.error('Could not find a translation for this error code', id)
+			msg = this.messages.unknown_error
 		}
+		return msg
+	}
+
+	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
+		const descriptor = this.getMessage(errorCode)
 		this.toasts?.addToast({
 			title: this.getIntl().formatMessage(this.messages.mutation_error_toast_title),
-			description: this.getIntl().formatMessage(descriptor ?? this.messages.unknown_error),
+			description: this.getIntl().formatMessage(descriptor),
 		})
 	}, 3000)
 

commit bc462846819a33006558921b016a9e44c4a18596
Author: alex <alex@dytry.ch>
Date:   Thu Jan 16 15:19:59 2025 +0000

    Set up posthog (#5220)
    
    Gets our existing `trackEvent` infra set up to start sending events into
    posthog. This involves a cookie consent banner and cookie management
    dialog for logged-in users. For signed out users (or users who haven't
    opted into analytics) data is recorded anonymously.
    
    ### Change type
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index eacda9abb..0fcb29c28 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -648,6 +648,7 @@ export class TldrawApp {
 			createdAt: Date.now(),
 			updatedAt: Date.now(),
 			flags: '',
+			allowAnalyticsCookie: null,
 			...restOfPreferences,
 			locale: restOfPreferences.locale ?? null,
 			animationSpeed: restOfPreferences.animationSpeed ?? null,

commit c860b352eedb03d10b900e3ab45232447eb67918
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Jan 22 13:29:43 2025 +0000

    Focus file input on create/duplicate (#5253)
    
    Steve suggested this as a way to avoid having 'Untitled file's in the
    navbar and long lists of dates in the sidebar. And heck yeah it feels
    good.
    
    ![Kapture 2025-01-21 at 14 35
    41](https://github.com/user-attachments/assets/fbf18c2d-e625-4c1a-a542-16a5724b5b53)
    
    TODO:
    
    - [ ] add a couple of e2e tests for this.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 0fcb29c28..7a95e0262 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -154,6 +154,13 @@ export class TldrawApp {
 		client_too_old: {
 			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
 		},
+		max_files_title: {
+			defaultMessage: 'File limit reached',
+		},
+		max_files_description: {
+			defaultMessage:
+				'You have reached the maximum number of files. You need to delete old files before creating new ones.',
+		},
 	})
 
 	getMessage(id: keyof typeof this.messages) {
@@ -295,6 +302,11 @@ export class TldrawApp {
 		fileOrId?: string | Partial<TlaFile>
 	): Result<{ file: TlaFile }, 'max number of files reached'> {
 		if (!this.canCreateNewFile()) {
+			this.toasts?.addToast({
+				title: this.getIntl().formatMessage(this.messages.max_files_title),
+				description: this.getIntl().formatMessage(this.messages.max_files_description),
+				keepOpen: true,
+			})
 			return Result.err('max number of files reached')
 		}
 
@@ -307,7 +319,7 @@ export class TldrawApp {
 			isEmpty: true,
 			createdAt: Date.now(),
 			lastPublished: 0,
-			name: '',
+			name: this.getFallbackFileName(Date.now()),
 			published: false,
 			publishedSlug: uniqueId(),
 			shared: true,
@@ -325,6 +337,12 @@ export class TldrawApp {
 		return Result.ok({ file })
 	}
 
+	getFallbackFileName(time: number) {
+		const createdAt = new Date(time)
+		const format = getDateFormat(createdAt)
+		return this.getIntl().formatDate(createdAt, format)
+	}
+
 	getFileName(file: TlaFile | string | null, useDateFallback: false): string | undefined
 	getFileName(file: TlaFile | string | null, useDateFallback?: true): string
 	getFileName(file: TlaFile | string | null, useDateFallback = true) {
@@ -343,9 +361,7 @@ export class TldrawApp {
 		}
 
 		if (useDateFallback) {
-			const createdAt = new Date(file.createdAt)
-			const format = getDateFormat(createdAt)
-			return this.getIntl().formatDate(createdAt, format)
+			return this.getFallbackFileName(file.createdAt)
 		}
 
 		return
@@ -412,7 +428,7 @@ export class TldrawApp {
 				const documentEntry = entries.find(([_, value]) => isDocument(value)) as
 					| [string, TLDocument]
 					| undefined
-				const name = documentEntry ? documentEntry[1].name : ''
+				const name = documentEntry?.[1]?.name || undefined
 
 				const result = this.createFile({ id: slug, name })
 				if (!result.ok) {

commit 16f08007a19e63e3fab31265a8730a1578ecedf3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Jan 23 09:36:06 2025 +0000

    Welcome dialog for preview users (#5263)
    
    - for new users we show a welcome dialog that says
      - this is a preview
      - log out to get back to the old experience
    - (if they have content in indexeddb) would you like us to slurp your
    local data
    
    - add an option for dialogs to prevent clicking the background to
    dismiss
    - refactor the dialog/toasts system to not duplicate UI/context,
    allowing people to implement their own dialog/toast ui wherever they
    want. I think this is what steve originally wanted to do back when tla
    first landed. This was necessary to get a full-screen dialog with the
    useDialogs() hook and it just makes a lot more sense in general.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    - Breaking SDK Changes
      - TldrawUiToasts renamed to DefaultToasts
      - TldrawUiDialogs renamed to DefaultDialogs
    - New SDK stuff
      - Toasts overridable component added
      - Dialogs overridable component added

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 7a95e0262..a8c18a143 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -31,6 +31,7 @@ import {
 } from 'tldraw'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
+import { updateLocalSessionState } from '../utils/local-session-state'
 import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
@@ -113,7 +114,8 @@ export class TldrawApp {
 	async preload(initialUserData: TlaUser) {
 		await this.z.query.user.where('id', this.userId).preload().complete
 		if (!this.user$.get()) {
-			await this.z.mutate.user.create(initialUserData)
+			this.z.mutate.user.create(initialUserData)
+			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
 		}
 		await new Promise((resolve) => {
 			let unsub = () => {}

commit 2e2216721e3239c068f22e2a914f5536e66538c6
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Jan 31 13:05:49 2025 +0100

    Make sure that pinned files don't take precedence. (#5335)
    
    Pinned files always took precedence in the recent user's files. This
    meant that after returning to the app you'd always land on a pinned
    file.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Test plan
    
    1. Pin a file
    2. Switch to a different file and make some edits to it (seems like our
    recent files takes last edit time as the preferred way of determining
    the order).
    3. Go to the root route.
    4. You should land on the correct file.
    
    ### Release notes
    
    - Fix an issue with pinned files always taking precedence when returning
    to the app.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index a8c18a143..d41775344 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -268,13 +268,6 @@ export class TldrawApp {
 		// sort by date with most recent first
 		nextRecentFileOrdering.sort((a, b) => b.date - a.date)
 
-		// move pinned files to the top, stable sort
-		nextRecentFileOrdering.sort((a, b) => {
-			if (a.isPinned && !b.isPinned) return -1
-			if (!a.isPinned && b.isPinned) return 1
-			return 0
-		})
-
 		// stash the ordering for next time
 		this.lastRecentFileOrdering = nextRecentFileOrdering
 

commit 7d33670703347049eb73100fb1d347f2a6da8e30
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Feb 3 10:35:02 2025 +0100

    Don't allow setting file name to null. Fix drag and drop import. (#5344)
    
    This looks like the only place where the `null` file name error might
    have occurred. Hopefully this fixes it, will keep an eye out.
    
    Also found out that importing files by dragging them to the sidebar
    didn't work. This should fix it.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Fix an error with creating file's with null names.
    - Fix an error with dragging and dropping files to the sidebar.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index d41775344..5571e8747 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -325,6 +325,9 @@ export class TldrawApp {
 		}
 		if (typeof fileOrId === 'object') {
 			Object.assign(file, fileOrId)
+			if (!file.name) {
+				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
+			}
 		}
 
 		this.z.mutate.file.create(file)
@@ -423,7 +426,7 @@ export class TldrawApp {
 				const documentEntry = entries.find(([_, value]) => isDocument(value)) as
 					| [string, TLDocument]
 					| undefined
-				const name = documentEntry?.[1]?.name || undefined
+				const name = documentEntry?.[1]?.name || ''
 
 				const result = this.createFile({ id: slug, name })
 				if (!result.ok) {

commit 86aae29d7f4a3bfb258730c51f051c8889e20e2c
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Feb 5 09:01:10 2025 +0100

    Move to server side slurping. (#5348)
    
    This moves duplication and legacy room slurping to the backend:
    * It removes the the file open mode logic (no more setting it when
    navigating, no more sending search params to the backend).
    * We now insert a file into the db with an additional column called
    `createSource` which is in the form of `f/kZTr6Zdx6TClE6I4qExV4`. In
    this case this means duplication of an existing app file. For legacy
    files we'd similarly use `/r|ro|v|s/kZTr6Zdx6TClE6I4qExV4` to use that
    existing legacy file as a starting point.
    * Room DO then sees this column and reads the data from the appropriate
    source and initializes the room.
    * We now retry getting the file record from the db, because otherwise we
    could still end up with a "Not found" issue since the navigation might
    happen before the replicator tells the room DO about the file creation.
    * Assets will get re-uploaded with our existing
    `maybeAssociateFileAssets` logic, that makes sure all the assets are
    associated with the file.
    
    We had to do this because in some cases the file got created in the db,
    then an file update was dispatched to the replicator (due to the trigger
    we have on the file table), which incorrectly the set room DO (its
    document info was set to a non app file without the creation params). If
    this happened before the user navigation hit the worker it would mean
    that duplication as well as slurping legacy files end up in a "Not
    found" error, even though the file was correctly inserted into the db.
    
    ### Change type
    - [x] `improvement`
    
    ### Release notes
    
    - Move duplicating and legacy file slurping to the server.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 5571e8747..ce36a3eaf 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -322,6 +322,7 @@ export class TldrawApp {
 			thumbnail: '',
 			updatedAt: Date.now(),
 			isDeleted: false,
+			createSource: null,
 		}
 		if (typeof fileOrId === 'object') {
 			Object.assign(file, fileOrId)

commit 0aaab49ccdc7b9ba96bdf0251301eaa0893583fd
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Feb 5 09:30:53 2025 +0000

    Fix tldr file upload (#5350)
    
    This PR uploads the assets separately from the room data json blobs, to
    avoid OOM exceptions on the server. I also consolidated the upload
    lifecycle management.
    
    Unfortunately, the way it's currently set up, the images get duplicated
    on our backend because there's no way to assign the file ownership in
    postgres without the file row already existing, but making that happen
    with good UX is tricky. I looked into resolving it a number of ways but
    it was getting a bit yak shavey so I decided to ignore the duplication
    issue for now.
    
    I think the ideal UX would be:
    
    1. as soon as you drop the .tldr file onto the canvas we extract all the
    assets into indexeddb, upload the records to R2, and create a file row.
    3. we gradually upload the assets in the background as soon as we know
    the file rows are in the db.
    4. the files appear in the sidebar immediately, with loading spinners to
    indicate that they are still uploading. You can open them up and make
    edits and stuff while the uploading happens in the background
    
    which is what I tried to implement to begin with, but it was getting too
    heavy and I want to move on so I fell back to this.
    
    ### Change type
    
    - [x] `bugfix`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index ce36a3eaf..e00e53810 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,6 +1,7 @@
 // import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
 import {
 	CreateFilesResponseBody,
+	CreateSnapshotRequestBody,
 	TlaFile,
 	TlaFilePartial,
 	TlaFileState,
@@ -15,20 +16,22 @@ import {
 	Signal,
 	TLDocument,
 	TLSessionStateSnapshot,
-	TLStoreSnapshot,
 	TLUiToastsContextType,
 	TLUserPreferences,
 	assertExists,
 	atom,
 	computed,
+	createTLSchema,
 	createTLUser,
+	dataUrlToFile,
 	defaultUserPreferences,
 	getUserPreferences,
-	isDocument,
 	objectMapFromEntries,
 	objectMapKeys,
+	parseTldrawJsonFile,
 	react,
 } from 'tldraw'
+import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
 import { updateLocalSessionState } from '../utils/local-session-state'
@@ -54,7 +57,11 @@ export class TldrawApp {
 	private readonly files$: Signal<TlaFile[]>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
 
-	readonly disposables: (() => void)[] = []
+	private readonly abortController = new AbortController()
+	readonly disposables: (() => void)[] = [
+		() => this.abortController.abort(),
+		() => this.z.dispose(),
+	]
 
 	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
 		// fail if closed?
@@ -95,7 +102,6 @@ export class TldrawApp {
 			onMutationRejected: this.showMutationRejectionToast,
 			onClientTooOld: () => onClientTooOld(),
 		})
-		this.disposables.push(() => this.z.dispose())
 
 		this.user$ = this.signalizeQuery(
 			'user signal',
@@ -163,6 +169,15 @@ export class TldrawApp {
 			defaultMessage:
 				'You have reached the maximum number of files. You need to delete old files before creating new ones.',
 		},
+		uploadingTldrFiles: {
+			defaultMessage:
+				'{total, plural, one {Uploading .tldr file…} other {Uploading {uploaded} of {total} .tldr files…}}',
+		},
+		addingTldrFiles: {
+			// no need for pluralization, if there was only one file we navigated to it
+			// so there's no need to show a toast.
+			defaultMessage: 'Added {total} .tldr files.',
+		},
 	})
 
 	getMessage(id: keyof typeof this.messages) {
@@ -215,12 +230,6 @@ export class TldrawApp {
 		},
 	})
 
-	// getAll<T extends keyof Schema['tables']>(
-	// 	typeName: T
-	// ): SchemaToRow<Schema['tables'][T]>[] {
-	// 	return this.z.query[typeName].run()
-	// }
-
 	getUserOwnFiles() {
 		return this.files$.get()
 	}
@@ -389,67 +398,6 @@ export class TldrawApp {
 		})
 	}
 
-	/**
-	 * Create files from tldr files.
-	 *
-	 * @param snapshots - The snapshots to create files from.
-	 * @param token - The user's token.
-	 *
-	 * @returns The slugs of the created files.
-	 */
-	async createFilesFromTldrFiles(snapshots: TLStoreSnapshot[], token: string) {
-		const res = await fetch(TLDR_FILE_ENDPOINT, {
-			method: 'POST',
-			headers: {
-				'Content-Type': 'application/json',
-				Authorization: `Bearer ${token}`,
-			},
-			body: JSON.stringify({
-				// convert to the annoyingly similar format that the server expects
-				snapshots: snapshots.map((s) => ({
-					snapshot: s.store,
-					schema: s.schema,
-				})),
-			}),
-		})
-
-		const response = (await res.json()) as CreateFilesResponseBody
-
-		if (!res.ok || response.error) {
-			throw Error('could not create files')
-		}
-
-		// Also create a file state record for the new file
-		this.z.mutate((tx) => {
-			for (let i = 0; i < response.slugs.length; i++) {
-				const slug = response.slugs[i]
-				const entries = Object.entries(snapshots[i].store)
-				const documentEntry = entries.find(([_, value]) => isDocument(value)) as
-					| [string, TLDocument]
-					| undefined
-				const name = documentEntry?.[1]?.name || ''
-
-				const result = this.createFile({ id: slug, name })
-				if (!result.ok) {
-					console.error('Could not create file', result.error)
-					continue
-				}
-				tx.file_state.create({
-					userId: this.userId,
-					fileId: slug,
-					firstVisitAt: Date.now(),
-					lastEditAt: null,
-					lastSessionState: null,
-					lastVisitAt: null,
-					isFileOwner: true,
-					isPinned: false,
-				})
-			}
-		})
-
-		return { slugs: response.slugs }
-	}
-
 	/**
 	 * Publish a file or re-publish changes.
 	 *
@@ -688,4 +636,170 @@ export class TldrawApp {
 		})
 		return createIntl()!
 	}
+
+	async uploadTldrFiles(files: File[], onFirstFileUploaded?: (file: TlaFile) => void) {
+		const totalFiles = files.length
+		let uploadedFiles = 0
+		if (totalFiles === 0) return
+
+		// this is only approx since we upload the files in pieces and they are base64 encoded
+		// in the json blob, so this will usually be a big overestimate. But that's fine because
+		// if the upload finishes before the number hits 100% people are pleasantly surprised.
+		const approxTotalBytes = files.reduce((acc, f) => acc + f.size, 0)
+		let bytesUploaded = 0
+		const getApproxPercentage = () =>
+			Math.min(Math.round((bytesUploaded / approxTotalBytes) * 100), 100)
+		const updateProgress = () => updateToast({ description: `${getApproxPercentage()}%` })
+
+		// only bother showing the percentage if it's going to take a while
+
+		let uploadingToastId = undefined as undefined | string
+		let didFinishUploading = false
+
+		// give it a second before we show the toast, in case the upload is fast
+		setTimeout(() => {
+			if (didFinishUploading || this.abortController.signal.aborted) return
+			// if it's close to the end, don't show the progress toast
+			if (getApproxPercentage() > 50) return
+			uploadingToastId = this.toasts?.addToast({
+				severity: 'info',
+				title: this.getIntl().formatMessage(this.messages.uploadingTldrFiles, {
+					total: totalFiles,
+					uploaded: uploadedFiles,
+				}),
+
+				description: `${getApproxPercentage()}%`,
+				keepOpen: true,
+			})
+		}, 800)
+
+		const updateToast = (args: { title?: string; description?: string }) => {
+			if (!uploadingToastId) return
+			this.toasts?.toasts.update((toasts) =>
+				toasts.map((t) =>
+					t.id === uploadingToastId
+						? {
+								...t,
+								...args,
+							}
+						: t
+				)
+			)
+		}
+
+		for (const f of files) {
+			const res = await this.uploadTldrFile(f, (bytes) => {
+				bytesUploaded += bytes
+				updateProgress()
+			}).catch((e) => Result.err(e))
+			if (!res.ok) {
+				if (uploadingToastId) this.toasts?.removeToast(uploadingToastId)
+				this.toasts?.addToast({
+					severity: 'error',
+					title: this.getIntl().formatMessage(this.messages.unknown_error),
+					keepOpen: true,
+				})
+				console.error(res.error)
+				return
+			}
+
+			updateToast({
+				title: this.getIntl().formatMessage(this.messages.uploadingTldrFiles, {
+					total: totalFiles,
+					uploaded: ++uploadedFiles + 1,
+				}),
+			})
+
+			if (onFirstFileUploaded) {
+				onFirstFileUploaded(res.value.file)
+				onFirstFileUploaded = undefined
+			}
+		}
+		didFinishUploading = true
+
+		if (uploadingToastId) this.toasts?.removeToast(uploadingToastId)
+
+		if (totalFiles > 1) {
+			this.toasts?.addToast({
+				severity: 'success',
+				title: this.getIntl().formatMessage(this.messages.addingTldrFiles, {
+					total: files.length,
+				}),
+				keepOpen: true,
+			})
+		}
+	}
+
+	private async uploadTldrFile(
+		file: File,
+		onProgress?: (bytesUploadedSinceLastProgressUpdate: number) => void
+	) {
+		const json = await file.text()
+		const parseFileResult = parseTldrawJsonFile({
+			schema: createTLSchema(),
+			json,
+		})
+
+		if (!parseFileResult.ok) {
+			return Result.err('could not parse file')
+		}
+
+		const snapshot = parseFileResult.value.getStoreSnapshot()
+
+		for (const record of Object.values(snapshot.store)) {
+			if (
+				record.typeName !== 'asset' ||
+				record.type === 'bookmark' ||
+				!record.props.src?.startsWith('data:')
+			) {
+				snapshot.store[record.id] = record
+				continue
+			}
+			const src = record.props.src
+			const file = await dataUrlToFile(
+				src,
+				record.props.name,
+				record.props.mimeType ?? 'application/octet-stream'
+			)
+			// TODO: this creates duplicate versions of the assets because we'll re-upload them when the user opens
+			// the file to associate them with the file id. To avoid this we'd need a way to create the file row
+			// in postgres so we can do the association while uploading the first time. Or just tolerate foreign key
+			// constraints being violated for a moment.
+			const assetsStore = multiplayerAssetStore()
+			const { src: newSrc } = await assetsStore.upload(record, file, this.abortController.signal)
+			onProgress?.(file.size)
+			snapshot.store[record.id] = {
+				...record,
+				props: {
+					...record.props,
+					src: newSrc,
+				},
+			}
+		}
+		const body = JSON.stringify({
+			snapshots: [
+				{
+					schema: snapshot.schema,
+					snapshot: snapshot.store,
+				} satisfies CreateSnapshotRequestBody,
+			],
+		})
+
+		const res = await fetch(TLDR_FILE_ENDPOINT, { method: 'POST', body })
+		onProgress?.(body.length)
+		if (!res.ok) {
+			throw Error('could not upload file ' + (await res.text()))
+		}
+		const response = (await res.json()) as CreateFilesResponseBody
+		if (response.error) {
+			throw Error(response.message)
+		}
+		const id = response.slugs[0]
+		const name =
+			file.name?.replace(/\.tldr$/, '') ??
+			Object.values(snapshot.store).find((d): d is TLDocument => d.typeName === 'document')?.name ??
+			''
+
+		return this.createFile({ id, name })
+	}
 }

commit 5b59bb831941492e90fa59693acd6fc6fbf81d02
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Feb 5 11:35:12 2025 +0000

    add a captureException to catch file.name not being defined (#5353)
    
    couldn't figure out why file.name might be undefined here. might be a
    bug in the optimistic store. need to check what these files look like.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index e00e53810..8bb5e9d4b 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,4 +1,5 @@
 // import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
+import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
 	CreateSnapshotRequestBody,
@@ -363,7 +364,11 @@ export class TldrawApp {
 		}
 		assert(typeof file !== 'string', 'ok')
 
-		const name = file.name.trim()
+		if (typeof file.name === 'undefined') {
+			captureException(new Error('file name is undefined somehow: ' + JSON.stringify(file)))
+		}
+		// need a ? here because we were seeing issues on sentry where file.name was undefined
+		const name = file.name?.trim()
 		if (name) {
 			return name
 		}

commit 0ec8b1ea659bfd77812979bc9757fc7ebb632536
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Feb 5 11:57:13 2025 +0000

    make websocket bootstrap time much faster (#5351)
    
    This PR makes it return the user data early
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 8bb5e9d4b..5a2e19291 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -33,6 +33,7 @@ import {
 	react,
 } from 'tldraw'
 import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
+import { TLAppUiContextType } from '../utils/app-ui-events'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
 import { updateLocalSessionState } from '../utils/local-session-state'
@@ -82,7 +83,8 @@ export class TldrawApp {
 	private constructor(
 		public readonly userId: string,
 		getToken: () => Promise<string | null>,
-		onClientTooOld: () => void
+		onClientTooOld: () => void,
+		trackEvent: TLAppUiContextType
 	) {
 		const sessionId = uniqueId()
 		this.z = new Zero({
@@ -102,6 +104,7 @@ export class TldrawApp {
 			// the schema. Switch to 'idb' for local-persistence.
 			onMutationRejected: this.showMutationRejectionToast,
 			onClientTooOld: () => onClientTooOld(),
+			trackEvent,
 		})
 
 		this.user$ = this.signalizeQuery(
@@ -594,13 +597,14 @@ export class TldrawApp {
 		avatar: string
 		getToken(): Promise<string | null>
 		onClientTooOld(): void
+		trackEvent: TLAppUiContextType
 	}) {
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
 
 		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
-		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld)
+		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld, opts.trackEvent)
 		// @ts-expect-error
 		window.app = app
 		await app.preload({

commit fec1c4beec37c3595cfbbb210e89e86bbf0b1e96
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Feb 10 14:31:22 2025 +0100

    Remove file delete route (#5398)
    
    Leftovers from a past life? 😄
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    - Remove file delete route.

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 5a2e19291..7d83c07fd 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -41,8 +41,6 @@ import { Zero } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
-export const UNPUBLISH_ENDPOINT = `/api/app/unpublish`
-export const FILE_ENDPOINT = `/api/app/file`
 
 let appId = 0
 

commit c750a44a50895cb90e198539403f40a00579aff9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Feb 11 13:27:05 2025 +0000

    add create-user event (#5406)
    
    add create-user event
    
    
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 7d83c07fd..72c9caf87 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -120,8 +120,10 @@ export class TldrawApp {
 	}
 
 	async preload(initialUserData: TlaUser) {
+		let didCreate = false
 		await this.z.query.user.where('id', this.userId).preload().complete
 		if (!this.user$.get()) {
+			didCreate = true
 			this.z.mutate.user.create(initialUserData)
 			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
 		}
@@ -134,6 +136,7 @@ export class TldrawApp {
 		}
 		await this.z.query.file_state.where('userId', this.userId).preload().complete
 		await this.z.query.file.where('ownerId', this.userId).preload().complete
+		return didCreate
 	}
 
 	messages = defineMessages({
@@ -605,7 +608,7 @@ export class TldrawApp {
 		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld, opts.trackEvent)
 		// @ts-expect-error
 		window.app = app
-		await app.preload({
+		const didCreate = await app.preload({
 			id: opts.userId,
 			name: opts.fullName,
 			email: opts.email,
@@ -629,6 +632,9 @@ export class TldrawApp {
 			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? null,
 			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? null,
 		})
+		if (didCreate) {
+			opts.trackEvent('create-user', { source: 'app' })
+		}
 		return { app, userId: opts.userId }
 	}
 

commit e04872aba13e3a6480502c69827cf26940687dd6
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Feb 12 10:47:58 2025 +0000

    use correct domain for app socket connection (#5414)
    
    this was using the raw process.env.MULTIPLAYER_SERVER when it should
    have been using the MULTIPLAYER_SERVER const defined in our config file,
    which uses the local origin in staging and prod.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 72c9caf87..f5675d015 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -32,6 +32,7 @@ import {
 	parseTldrawJsonFile,
 	react,
 } from 'tldraw'
+import { MULTIPLAYER_SERVER } from '../../utils/config'
 import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
 import { TLAppUiContextType } from '../utils/app-ui-events'
 import { getDateFormat } from '../utils/dates'
@@ -95,7 +96,7 @@ export class TldrawApp {
 				})
 				const token = await getToken()
 				params.set('accessToken', token || 'no-token-found')
-				return `${process.env.MULTIPLAYER_SERVER}/api/app/${userId}/connect?${params}`
+				return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
 			},
 			// schema,
 			// This is often easier to develop with if you're frequently changing

commit 7087024ff8855e7ccc4cd4b677d29d73b6408612
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Feb 19 16:08:40 2025 +0100

    Add backend check for max files (#5448)
    
    Enforce the max files limit on the backend.
    
    ### Change type
    
    - [x] `improvement`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index f5675d015..892a76396 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -3,6 +3,7 @@ import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
 	CreateSnapshotRequestBody,
+	MAX_NUMBER_OF_FILES,
 	TlaFile,
 	TlaFilePartial,
 	TlaFileState,
@@ -47,7 +48,7 @@ let appId = 0
 
 export class TldrawApp {
 	config = {
-		maxNumberOfFiles: 100,
+		maxNumberOfFiles: MAX_NUMBER_OF_FILES,
 	}
 
 	readonly id = appId++
@@ -171,7 +172,7 @@ export class TldrawApp {
 		max_files_title: {
 			defaultMessage: 'File limit reached',
 		},
-		max_files_description: {
+		max_files_reached: {
 			defaultMessage:
 				'You have reached the maximum number of files. You need to delete old files before creating new ones.',
 		},
@@ -314,7 +315,7 @@ export class TldrawApp {
 		if (!this.canCreateNewFile()) {
 			this.toasts?.addToast({
 				title: this.getIntl().formatMessage(this.messages.max_files_title),
-				description: this.getIntl().formatMessage(this.messages.max_files_description),
+				description: this.getIntl().formatMessage(this.messages.max_files_reached),
 				keepOpen: true,
 			})
 			return Result.err('max number of files reached')

commit 29a715ba1170810aef1b2f1929f97a2c665df6d3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Feb 21 09:32:02 2025 +0000

    retry slurping document records if need be (#5460)
    
    There was a hole in the local file slurping logic where it would retry
    slurping assets but not the document records themselves. So if the user
    switched away from the slurped file before tlsync had a chance to finsih
    doing its thing, the data would seem to disappear.
    
    This patches that hole by using the `createSource` column to signify
    that an app file should be initialized by slurping from a local file,
    rather than an ephemeral property on the TldrawApp instance. That way
    when we open such a file we can check whether the
    document.meta.slurpPersistenceKey has been added, and if so it means the
    records slurp happened successfully.
    
    ### Change type
    
    - [x] `bugfix`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 892a76396..100ef731a 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -3,6 +3,7 @@ import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
 	CreateSnapshotRequestBody,
+	LOCAL_FILE_PREFIX,
 	MAX_NUMBER_OF_FILES,
 	TlaFile,
 	TlaFilePartial,
@@ -35,6 +36,7 @@ import {
 } from 'tldraw'
 import { MULTIPLAYER_SERVER } from '../../utils/config'
 import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
+import { getScratchPersistenceKey } from '../../utils/scratch-persistence-key'
 import { TLAppUiContextType } from '../utils/app-ui-events'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
@@ -386,13 +388,10 @@ export class TldrawApp {
 		return
 	}
 
-	_slurpFileId: string | null = null
 	slurpFile() {
-		const res = this.createFile()
-		if (res.ok) {
-			this._slurpFileId = res.value.file.id
-		}
-		return res
+		return this.createFile({
+			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
+		})
 	}
 
 	toggleFileShared(fileId: string) {

commit c83fea52c1367d5991569a24a19f47500645fb41
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Feb 28 08:57:04 2025 +0000

    no reboot user data on deploy (#5497)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 100ef731a..a7e583db7 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -268,8 +268,16 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			const state = myStates[fileId]
-			if (!file || !state) continue
+			let state = myStates[fileId]
+			if (!file) continue
+			if (!state && !file.isDeleted && file.ownerId === this.userId) {
+				// create a file state for this file
+				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
+				state = this.getOrCreateFileState(fileId)
+			} else if (!state) {
+				// if the file is deleted, we don't want to show it in the recent files
+				continue
+			}
 			const existing = this.lastRecentFileOrdering?.find((f) => f.fileId === fileId)
 			if (existing && existing.isPinned === state.isPinned) {
 				nextRecentFileOrdering.push(existing)
@@ -348,8 +356,19 @@ export class TldrawApp {
 				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
 			}
 		}
-
-		this.z.mutate.file.create(file)
+		this.z.mutate((tx) => {
+			tx.file.create(file)
+			tx.file_state.create({
+				isFileOwner: true,
+				fileId: file.id,
+				userId: this.userId,
+				firstVisitAt: null,
+				isPinned: false,
+				lastEditAt: null,
+				lastSessionState: null,
+				lastVisitAt: null,
+			})
+		})
 
 		return Result.ok({ file })
 	}
@@ -539,7 +558,7 @@ export class TldrawApp {
 		this.updateUser(exportPreferences)
 	}
 
-	async getOrCreateFileState(fileId: string) {
+	getOrCreateFileState(fileId: string) {
 		let fileState = this.getFileState(fileId)
 		if (!fileState) {
 			this.z.mutate.file_state.create({

commit 62dce36fb020a910710f8fc08bbc0208d1400169
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Mar 3 09:00:10 2025 +0100

    Fix guest files. (#5530)
    
    We did not correctly create file state when visiting guest files.
    
    ### Change type
    
    - [x] `bugfix`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index a7e583db7..468269813 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -589,8 +589,8 @@ export class TldrawApp {
 		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
-	async onFileEnter(fileId: string) {
-		await this.getOrCreateFileState(fileId)
+	onFileEnter(fileId: string) {
+		this.getOrCreateFileState(fileId)
 		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
 		})

commit 21002dc7ca29a9de51c6f24676ba5812958a8248
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Apr 1 13:26:45 2025 +0200

    Zero spike (#5551)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index 468269813..b09edcd29 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -1,4 +1,5 @@
 // import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
+import { Zero } from '@rocicorp/zero'
 import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
@@ -8,20 +9,28 @@ import {
 	TlaFile,
 	TlaFilePartial,
 	TlaFileState,
+	TlaSchema,
 	TlaUser,
 	UserPreferencesKeys,
-	ZErrorCode,
 	Z_PROTOCOL_VERSION,
+	schema as zeroSchema,
+	ZErrorCode,
 } from '@tldraw/dotcom-shared'
-import { Result, assert, fetch, structuredClone, throttle, uniqueId } from '@tldraw/utils'
+import {
+	assert,
+	fetch,
+	getFromLocalStorage,
+	promiseWithResolve,
+	Result,
+	setInLocalStorage,
+	structuredClone,
+	throttle,
+	uniqueId,
+} from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	Signal,
-	TLDocument,
-	TLSessionStateSnapshot,
-	TLUiToastsContextType,
-	TLUserPreferences,
 	assertExists,
+	Atom,
 	atom,
 	computed,
 	createTLSchema,
@@ -33,20 +42,34 @@ import {
 	objectMapKeys,
 	parseTldrawJsonFile,
 	react,
+	Signal,
+	TLDocument,
+	TLSessionStateSnapshot,
+	TLUiToastsContextType,
+	TLUserPreferences,
+	transact,
 } from 'tldraw'
-import { MULTIPLAYER_SERVER } from '../../utils/config'
+import { MULTIPLAYER_SERVER, ZERO_SERVER } from '../../utils/config'
 import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
 import { getScratchPersistenceKey } from '../../utils/scratch-persistence-key'
 import { TLAppUiContextType } from '../utils/app-ui-events'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
 import { updateLocalSessionState } from '../utils/local-session-state'
-import { Zero } from './zero-polyfill'
+import { Zero as ZeroPolyfill } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
 
 let appId = 0
+const useProperZero = getFromLocalStorage('useProperZero') === 'true'
+// eslint-disable-next-line no-console
+console.log('useProperZero', useProperZero)
+// @ts-expect-error
+window.zero = () => {
+	setInLocalStorage('useProperZero', String(!useProperZero))
+	location.reload()
+}
 
 export class TldrawApp {
 	config = {
@@ -55,24 +78,37 @@ export class TldrawApp {
 
 	readonly id = appId++
 
-	readonly z: Zero
+	readonly z: ZeroPolyfill | Zero<TlaSchema>
 
 	private readonly user$: Signal<TlaUser | undefined>
 	private readonly files$: Signal<TlaFile[]>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
 
 	private readonly abortController = new AbortController()
-	readonly disposables: (() => void)[] = [
-		() => this.abortController.abort(),
-		() => this.z.dispose(),
-	]
+	readonly disposables: (() => void)[] = [() => this.abortController.abort(), () => this.z.close()]
+
+	changes: Map<Atom<any, unknown>, any> = new Map()
+	changesFlushed = null as null | ReturnType<typeof promiseWithResolve>
 
 	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
 		// fail if closed?
 		const view = query.materialize()
 		const val$ = atom(name, view.data)
 		view.addListener((res: any) => {
-			val$.set(structuredClone(res) as any)
+			this.changes.set(val$, structuredClone(res))
+			if (!this.changesFlushed) {
+				this.changesFlushed = promiseWithResolve()
+			}
+			queueMicrotask(() => {
+				transact(() => {
+					this.changes.forEach((value, key) => {
+						key.set(value)
+					})
+					this.changes.clear()
+				})
+				this.changesFlushed?.resolve(undefined)
+				this.changesFlushed = null
+			})
 		})
 		this.disposables.push(() => {
 			view.destroy()
@@ -84,30 +120,42 @@ export class TldrawApp {
 
 	private constructor(
 		public readonly userId: string,
-		getToken: () => Promise<string | null>,
+		getToken: () => Promise<string | undefined>,
 		onClientTooOld: () => void,
 		trackEvent: TLAppUiContextType
 	) {
 		const sessionId = uniqueId()
-		this.z = new Zero({
-			// userID: userId,
-			// auth: encodedJWT,
-			getUri: async () => {
-				const params = new URLSearchParams({
-					sessionId,
-					protocolVersion: String(Z_PROTOCOL_VERSION),
+		this.z = useProperZero
+			? new Zero({
+					auth: getToken,
+					userID: userId,
+					schema: zeroSchema,
+					server: ZERO_SERVER,
+					onUpdateNeeded(reason) {
+						console.error('update needed', reason)
+						onClientTooOld()
+					},
+					kvStore: window.navigator.webdriver ? 'mem' : 'idb',
+				})
+			: new ZeroPolyfill({
+					// userID: userId,
+					// auth: encodedJWT,
+					getUri: async () => {
+						const params = new URLSearchParams({
+							sessionId,
+							protocolVersion: String(Z_PROTOCOL_VERSION),
+						})
+						const token = await getToken()
+						params.set('accessToken', token || 'no-token-found')
+						return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
+					},
+					// schema,
+					// This is often easier to develop with if you're frequently changing
+					// the schema. Switch to 'idb' for local-persistence.
+					onMutationRejected: this.showMutationRejectionToast,
+					onClientTooOld: () => onClientTooOld(),
+					trackEvent,
 				})
-				const token = await getToken()
-				params.set('accessToken', token || 'no-token-found')
-				return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
-			},
-			// schema,
-			// This is often easier to develop with if you're frequently changing
-			// the schema. Switch to 'idb' for local-persistence.
-			onMutationRejected: this.showMutationRejectionToast,
-			onClientTooOld: () => onClientTooOld(),
-			trackEvent,
-		})
 
 		this.user$ = this.signalizeQuery(
 			'user signal',
@@ -115,7 +163,7 @@ export class TldrawApp {
 		)
 		this.files$ = this.signalizeQuery(
 			'files signal',
-			this.z.query.file.where('ownerId', this.userId)
+			this.z.query.file.where('isDeleted', '=', false)
 		)
 		this.fileStates$ = this.signalizeQuery(
 			'file states signal',
@@ -126,9 +174,10 @@ export class TldrawApp {
 	async preload(initialUserData: TlaUser) {
 		let didCreate = false
 		await this.z.query.user.where('id', this.userId).preload().complete
+		await this.changesFlushed
 		if (!this.user$.get()) {
 			didCreate = true
-			this.z.mutate.user.create(initialUserData)
+			this.z.mutate.user.insert(initialUserData)
 			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
 		}
 		await new Promise((resolve) => {
@@ -230,7 +279,7 @@ export class TldrawApp {
 				Object.entries(others).filter(([_, value]) => value !== null)
 			) as Partial<TLUserPreferences>
 
-			this.z.mutate((tx) => {
+			this.z.mutateBatch((tx) => {
 				tx.user.update({
 					id: user.id,
 					...(nonNull as any),
@@ -268,13 +317,14 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			let state = myStates[fileId]
+			let state: (typeof myStates)[string] | undefined = myStates[fileId]
 			if (!file) continue
 			if (!state && !file.isDeleted && file.ownerId === this.userId) {
 				// create a file state for this file
 				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
-				state = this.getOrCreateFileState(fileId)
-			} else if (!state) {
+				state = this.fileStates$.get().find((fs) => fs.fileId === fileId)
+			}
+			if (!state) {
 				// if the file is deleted, we don't want to show it in the recent files
 				continue
 			}
@@ -356,9 +406,9 @@ export class TldrawApp {
 				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
 			}
 		}
-		this.z.mutate((tx) => {
-			tx.file.create(file)
-			tx.file_state.create({
+		this.z.mutateBatch((tx) => {
+			tx.file.upsert(file)
+			tx.file_state.upsert({
 				isFileOwner: true,
 				fileId: file.id,
 				userId: this.userId,
@@ -413,17 +463,20 @@ export class TldrawApp {
 		})
 	}
 
+	getFilePk(fileId: string) {
+		const file = this.getFile(fileId)
+		return { id: fileId, ownerId: file!.ownerId, publishedSlug: file!.publishedSlug }
+	}
+
 	toggleFileShared(fileId: string) {
 		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error('no file with id ' + fileId)
 
 		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
-		this.z.mutate((tx) => {
-			tx.file.update({
-				id: fileId,
-				shared: !file.shared,
-			})
+		this.updateFile({
+			id: fileId,
+			shared: !file.shared,
 		})
 	}
 
@@ -442,13 +495,11 @@ export class TldrawApp {
 		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.z.mutate((tx) => {
-			tx.file.update({
-				id: fileId,
-				name,
-				published: true,
-				lastPublished: Date.now(),
-			})
+		this.updateFile({
+			...this.getFilePk(fileId),
+			name,
+			published: true,
+			lastPublished: Date.now(),
 		})
 	}
 
@@ -468,7 +519,10 @@ export class TldrawApp {
 
 	updateFile(partial: TlaFilePartial) {
 		this.requireFile(partial.id)
-		this.z.mutate.file.update(partial)
+		this.z.mutate.file.update({
+			...this.getFilePk(partial.id),
+			...partial,
+		})
 	}
 
 	/**
@@ -484,11 +538,9 @@ export class TldrawApp {
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.z.mutate((tx) => {
-			tx.file.update({
-				id: fileId,
-				published: false,
-			})
+		this.updateFile({
+			id: fileId,
+			published: false,
 		})
 
 		return Result.ok('success')
@@ -503,10 +555,10 @@ export class TldrawApp {
 		const file = this.getFile(fileId)
 
 		// Optimistic update, remove file and file states
-		return this.z.mutate((tx) => {
+		return this.z.mutateBatch((tx) => {
 			tx.file_state.delete({ fileId, userId: this.userId })
 			if (file?.ownerId === this.userId) {
-				tx.file.update({ id: fileId, isDeleted: true })
+				tx.file.update({ ...this.getFilePk(fileId), isDeleted: true })
 			}
 		})
 	}
@@ -536,15 +588,15 @@ export class TldrawApp {
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.z.mutate.file.update({ id: fileId, shared: false })
+			this.updateFile({ id: fileId, shared: false })
 			return
 		}
-		this.z.mutate.file.update({ id: fileId, shared: true, sharedLinkType })
+		this.updateFile({ id: fileId, shared: true, sharedLinkType })
 	}
 
 	updateUser(partial: Partial<TlaUser>) {
 		const user = this.getUser()
-		this.z.mutate.user.update({
+		return this.z.mutate.user.update({
 			id: user.id,
 			...partial,
 		})
@@ -558,10 +610,11 @@ export class TldrawApp {
 		this.updateUser(exportPreferences)
 	}
 
-	getOrCreateFileState(fileId: string) {
-		let fileState = this.getFileState(fileId)
+	async createFileStateIfNotExists(fileId: string) {
+		await this.changesFlushed
+		const fileState = this.getFileState(fileId)
 		if (!fileState) {
-			this.z.mutate.file_state.create({
+			const fs: TlaFileState = {
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),
@@ -572,11 +625,9 @@ export class TldrawApp {
 				// doesn't really matter what this is because it is
 				// overwritten by postgres
 				isFileOwner: this.isFileOwner(fileId),
-			})
+			}
+			this.z.mutate.file_state.upsert(fs)
 		}
-		fileState = this.getFileState(fileId)
-		if (!fileState) throw Error('could not create file state')
-		return fileState
 	}
 
 	getFileState(fileId: string) {
@@ -589,8 +640,8 @@ export class TldrawApp {
 		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
-	onFileEnter(fileId: string) {
-		this.getOrCreateFileState(fileId)
+	async onFileEnter(fileId: string) {
+		await this.createFileStateIfNotExists(fileId)
 		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
 		})
@@ -616,7 +667,7 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		getToken(): Promise<string | null>
+		getToken(): Promise<string | undefined>
 		onClientTooOld(): void
 		trackEvent: TLAppUiContextType
 	}) {

commit 75f2bf1ab8f626f2407fd4a655eec079d771f214
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Apr 11 10:57:01 2025 +0100

    trying out zero custom mutators (#5814)
    
    ### Change type
    
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index b09edcd29..c3de64b33 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -3,12 +3,13 @@ import { Zero } from '@rocicorp/zero'
 import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
+	createMutators,
 	CreateSnapshotRequestBody,
 	LOCAL_FILE_PREFIX,
 	MAX_NUMBER_OF_FILES,
 	TlaFile,
-	TlaFilePartial,
 	TlaFileState,
+	TlaMutators,
 	TlaSchema,
 	TlaUser,
 	UserPreferencesKeys,
@@ -78,7 +79,7 @@ export class TldrawApp {
 
 	readonly id = appId++
 
-	readonly z: ZeroPolyfill | Zero<TlaSchema>
+	readonly z: ZeroPolyfill | Zero<TlaSchema, TlaMutators>
 
 	private readonly user$: Signal<TlaUser | undefined>
 	private readonly files$: Signal<TlaFile[]>
@@ -126,11 +127,12 @@ export class TldrawApp {
 	) {
 		const sessionId = uniqueId()
 		this.z = useProperZero
-			? new Zero({
+			? new Zero<TlaSchema, TlaMutators>({
 					auth: getToken,
 					userID: userId,
 					schema: zeroSchema,
 					server: ZERO_SERVER,
+					mutators: createMutators(userId),
 					onUpdateNeeded(reason) {
 						console.error('update needed', reason)
 						onClientTooOld()
@@ -138,7 +140,7 @@ export class TldrawApp {
 					kvStore: window.navigator.webdriver ? 'mem' : 'idb',
 				})
 			: new ZeroPolyfill({
-					// userID: userId,
+					userId,
 					// auth: encodedJWT,
 					getUri: async () => {
 						const params = new URLSearchParams({
@@ -159,7 +161,7 @@ export class TldrawApp {
 
 		this.user$ = this.signalizeQuery(
 			'user signal',
-			this.z.query.user.where('id', this.userId).one()
+			this.z.query.user.where('id', '=', this.userId).one()
 		)
 		this.files$ = this.signalizeQuery(
 			'files signal',
@@ -167,13 +169,13 @@ export class TldrawApp {
 		)
 		this.fileStates$ = this.signalizeQuery(
 			'file states signal',
-			this.z.query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
+			this.z.query.file_state.where('userId', '=', this.userId).related('file', (q: any) => q.one())
 		)
 	}
 
 	async preload(initialUserData: TlaUser) {
 		let didCreate = false
-		await this.z.query.user.where('id', this.userId).preload().complete
+		await this.z.query.user.where('id', '=', this.userId).preload().complete
 		await this.changesFlushed
 		if (!this.user$.get()) {
 			didCreate = true
@@ -187,8 +189,8 @@ export class TldrawApp {
 		if (!this.user$.get()) {
 			throw Error('could not create user')
 		}
-		await this.z.query.file_state.where('userId', this.userId).preload().complete
-		await this.z.query.file.where('ownerId', this.userId).preload().complete
+		await this.z.query.file_state.where('userId', '=', this.userId).preload().complete
+		await this.z.query.file.where('ownerId', '=', this.userId).preload().complete
 		return didCreate
 	}
 
@@ -279,11 +281,9 @@ export class TldrawApp {
 				Object.entries(others).filter(([_, value]) => value !== null)
 			) as Partial<TLUserPreferences>
 
-			this.z.mutateBatch((tx) => {
-				tx.user.update({
-					id: user.id,
-					...(nonNull as any),
-				})
+			this.z.mutate.user.update({
+				id: user.id,
+				...(nonNull as any),
 			})
 		},
 	})
@@ -369,15 +369,19 @@ export class TldrawApp {
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	createFile(
+	private showMaxFilesToast() {
+		this.toasts?.addToast({
+			title: this.getIntl().formatMessage(this.messages.max_files_title),
+			description: this.getIntl().formatMessage(this.messages.max_files_reached),
+			keepOpen: true,
+		})
+	}
+
+	async createFile(
 		fileOrId?: string | Partial<TlaFile>
-	): Result<{ file: TlaFile }, 'max number of files reached'> {
+	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
 		if (!this.canCreateNewFile()) {
-			this.toasts?.addToast({
-				title: this.getIntl().formatMessage(this.messages.max_files_title),
-				description: this.getIntl().formatMessage(this.messages.max_files_reached),
-				keepOpen: true,
-			})
+			this.showMaxFilesToast()
 			return Result.err('max number of files reached')
 		}
 
@@ -406,19 +410,23 @@ export class TldrawApp {
 				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
 			}
 		}
-		this.z.mutateBatch((tx) => {
-			tx.file.upsert(file)
-			tx.file_state.upsert({
-				isFileOwner: true,
-				fileId: file.id,
-				userId: this.userId,
-				firstVisitAt: null,
-				isPinned: false,
-				lastEditAt: null,
-				lastSessionState: null,
-				lastVisitAt: null,
-			})
-		})
+		const fileState = {
+			isFileOwner: true,
+			fileId: file.id,
+			userId: this.userId,
+			firstVisitAt: null,
+			isPinned: false,
+			lastEditAt: null,
+			lastSessionState: null,
+			lastVisitAt: null,
+		}
+		await this.z.mutate.file.insertWithFileState({ file, fileState })
+		// todo: add server error handling for real Zero
+		// .server.catch((res: { error: string; details: string }) => {
+		// 	if (res.details === ZErrorCode.max_files_reached) {
+		// 		this.showMaxFilesToast()
+		// 	}
+		// })
 
 		return Result.ok({ file })
 	}
@@ -457,8 +465,8 @@ export class TldrawApp {
 		return
 	}
 
-	slurpFile() {
-		return this.createFile({
+	async slurpFile() {
+		return await this.createFile({
 			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
 		})
 	}
@@ -474,7 +482,7 @@ export class TldrawApp {
 
 		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
-		this.updateFile({
+		this.z.mutate.file.update({
 			id: fileId,
 			shared: !file.shared,
 		})
@@ -495,8 +503,8 @@ export class TldrawApp {
 		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.updateFile({
-			...this.getFilePk(fileId),
+		this.z.mutate.file.update({
+			id: fileId,
 			name,
 			published: true,
 			lastPublished: Date.now(),
@@ -517,14 +525,6 @@ export class TldrawApp {
 		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
 	}
 
-	updateFile(partial: TlaFilePartial) {
-		this.requireFile(partial.id)
-		this.z.mutate.file.update({
-			...this.getFilePk(partial.id),
-			...partial,
-		})
-	}
-
 	/**
 	 * Unpublish a file.
 	 *
@@ -538,7 +538,7 @@ export class TldrawApp {
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.updateFile({
+		this.z.mutate.file.update({
 			id: fileId,
 			published: false,
 		})
@@ -553,14 +553,10 @@ export class TldrawApp {
 	 */
 	async deleteOrForgetFile(fileId: string) {
 		const file = this.getFile(fileId)
+		if (!file) return
 
 		// Optimistic update, remove file and file states
-		return this.z.mutateBatch((tx) => {
-			tx.file_state.delete({ fileId, userId: this.userId })
-			if (file?.ownerId === this.userId) {
-				tx.file.update({ ...this.getFilePk(fileId), isDeleted: true })
-			}
-		})
+		this.z.mutate.file.deleteOrForget(file)
 	}
 
 	/**
@@ -588,10 +584,10 @@ export class TldrawApp {
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.updateFile({ id: fileId, shared: false })
+			this.z.mutate.file.update({ id: fileId, shared: false })
 			return
 		}
-		this.updateFile({ id: fileId, shared: true, sharedLinkType })
+		this.z.mutate.file.update({ id: fileId, shared: true, sharedLinkType })
 	}
 
 	updateUser(partial: Partial<TlaUser>) {
@@ -626,7 +622,7 @@ export class TldrawApp {
 				// overwritten by postgres
 				isFileOwner: this.isFileOwner(fileId),
 			}
-			this.z.mutate.file_state.upsert(fs)
+			this.z.mutate.file_state.insert(fs)
 		}
 	}
 
@@ -640,6 +636,10 @@ export class TldrawApp {
 		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
+	updateFile(fileId: string, partial: Partial<TlaFile>) {
+		this.z.mutate.file.update({ id: fileId, ...partial })
+	}
+
 	async onFileEnter(fileId: string) {
 		await this.createFileStateIfNotExists(fileId)
 		this.updateFileState(fileId, {

commit bec6f90d283a46eb767708f5828c746f35ad885b
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Apr 17 15:22:50 2025 +0200

    Optimize query. (#5923)
    
    Our file permission logic caused zero to use some unoptimized queries
    that could take quite a while to load. This adds the suggested
    improvements from https://github.com/grgbkr/tldraw/pull/1
    
    ### Change type
    
    - [x] `improvement`

diff --git a/apps/dotcom/client/src/tla/app/TldrawApp.ts b/apps/dotcom/client/src/tla/app/TldrawApp.ts
index c3de64b33..e16623900 100644
--- a/apps/dotcom/client/src/tla/app/TldrawApp.ts
+++ b/apps/dotcom/client/src/tla/app/TldrawApp.ts
@@ -82,7 +82,6 @@ export class TldrawApp {
 	readonly z: ZeroPolyfill | Zero<TlaSchema, TlaMutators>
 
 	private readonly user$: Signal<TlaUser | undefined>
-	private readonly files$: Signal<TlaFile[]>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
 
 	private readonly abortController = new AbortController()
@@ -159,23 +158,23 @@ export class TldrawApp {
 					trackEvent,
 				})
 
-		this.user$ = this.signalizeQuery(
-			'user signal',
-			this.z.query.user.where('id', '=', this.userId).one()
-		)
-		this.files$ = this.signalizeQuery(
-			'files signal',
-			this.z.query.file.where('isDeleted', '=', false)
-		)
-		this.fileStates$ = this.signalizeQuery(
-			'file states signal',
-			this.z.query.file_state.where('userId', '=', this.userId).related('file', (q: any) => q.one())
-		)
+		this.user$ = this.signalizeQuery('user signal', this.userQuery())
+		this.fileStates$ = this.signalizeQuery('file states signal', this.fileStateQuery())
+	}
+
+	private userQuery() {
+		return this.z.query.user.where('id', '=', this.userId).one()
+	}
+
+	private fileStateQuery() {
+		return this.z.query.file_state
+			.where('userId', '=', this.userId)
+			.related('file', (q: any) => q.one())
 	}
 
 	async preload(initialUserData: TlaUser) {
 		let didCreate = false
-		await this.z.query.user.where('id', '=', this.userId).preload().complete
+		await this.userQuery().preload().complete
 		await this.changesFlushed
 		if (!this.user$.get()) {
 			didCreate = true
@@ -189,8 +188,7 @@ export class TldrawApp {
 		if (!this.user$.get()) {
 			throw Error('could not create user')
 		}
-		await this.z.query.file_state.where('userId', '=', this.userId).preload().complete
-		await this.z.query.file.where('ownerId', '=', this.userId).preload().complete
+		await this.fileStateQuery().preload().complete
 		return didCreate
 	}
 
@@ -289,7 +287,12 @@ export class TldrawApp {
 	})
 
 	getUserOwnFiles() {
-		return this.files$.get()
+		const fileStates = this.getUserFileStates()
+		const files: TlaFile[] = []
+		fileStates.forEach((f) => {
+			if (f.file) files.push(f.file)
+		})
+		return files
 	}
 
 	getUserFileStates() {
@@ -556,7 +559,7 @@ export class TldrawApp {
 		if (!file) return
 
 		// Optimistic update, remove file and file states
-		this.z.mutate.file.deleteOrForget(file)
+		await this.z.mutate.file.deleteOrForget(file)
 	}
 
 	/**

