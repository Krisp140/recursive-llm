# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a ‚Äúcore‚Äù library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we‚Äôve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
new file mode 100644
index 000000000..4c6c3fcb1
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -0,0 +1,1107 @@
+/* eslint-disable react-hooks/rules-of-hooks */
+import {
+	BaseBoxShapeUtil,
+	Box2d,
+	DefaultFontFamilies,
+	Editor,
+	PI,
+	PI2,
+	SVGContainer,
+	SvgExportContext,
+	TAU,
+	TLDefaultDashStyle,
+	TLGeoShape,
+	TLOnEditEndHandler,
+	TLOnResizeHandler,
+	TLShapeUtilCanvasSvgDef,
+	Vec2d,
+	VecLike,
+	geoShapeMigrations,
+	geoShapeProps,
+	getDefaultColorTheme,
+	getPolygonVertices,
+	linesIntersect,
+	pointInPolygon,
+} from '@tldraw/editor'
+
+import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { TextLabel } from '../shared/TextLabel'
+import {
+	FONT_FAMILIES,
+	LABEL_FONT_SIZES,
+	STROKE_SIZES,
+	TEXT_PROPS,
+} from '../shared/default-shape-constants'
+import {
+	getFillDefForCanvas,
+	getFillDefForExport,
+	getFontDefForExport,
+} from '../shared/defaultStyleDefs'
+import { getTextLabelSvgElement } from '../shared/getTextLabelSvgElement'
+import { getRoundedInkyPolygonPath, getRoundedPolygonPoints } from '../shared/polygon-helpers'
+import { useForceSolid } from '../shared/useForceSolid'
+import { cloudOutline, cloudSvgPath } from './cloudOutline'
+import { DashStyleCloud, DashStyleCloudSvg } from './components/DashStyleCloud'
+import { DashStyleEllipse, DashStyleEllipseSvg } from './components/DashStyleEllipse'
+import { DashStyleOval, DashStyleOvalSvg } from './components/DashStyleOval'
+import { DashStylePolygon, DashStylePolygonSvg } from './components/DashStylePolygon'
+import { DrawStyleCloud, DrawStyleCloudSvg } from './components/DrawStyleCloud'
+import { DrawStyleEllipseSvg, getEllipseIndicatorPath } from './components/DrawStyleEllipse'
+import { DrawStylePolygon, DrawStylePolygonSvg } from './components/DrawStylePolygon'
+import { SolidStyleCloud, SolidStyleCloudSvg } from './components/SolidStyleCloud'
+import { SolidStyleEllipse, SolidStyleEllipseSvg } from './components/SolidStyleEllipse'
+import {
+	SolidStyleOval,
+	SolidStyleOvalSvg,
+	getOvalIndicatorPath,
+} from './components/SolidStyleOval'
+import { SolidStylePolygon, SolidStylePolygonSvg } from './components/SolidStylePolygon'
+
+const LABEL_PADDING = 16
+const MIN_SIZE_WITH_LABEL = 17 * 3
+
+/** @public */
+export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
+	static override type = 'geo' as const
+	static override props = geoShapeProps
+	static override migrations = geoShapeMigrations
+
+	override canEdit = () => true
+
+	override getDefaultProps(): TLGeoShape['props'] {
+		return {
+			w: 100,
+			h: 100,
+			geo: 'rectangle',
+			color: 'black',
+			labelColor: 'black',
+			fill: 'none',
+			dash: 'draw',
+			size: 'm',
+			font: 'draw',
+			text: '',
+			align: 'middle',
+			verticalAlign: 'middle',
+			growY: 0,
+			url: '',
+		}
+	}
+
+	override hitTestLineSegment(shape: TLGeoShape, A: VecLike, B: VecLike): boolean {
+		const outline = this.editor.getOutline(shape)
+
+		// Check the outline
+		for (let i = 0; i < outline.length; i++) {
+			const C = outline[i]
+			const D = outline[(i + 1) % outline.length]
+			if (linesIntersect(A, B, C, D)) return true
+		}
+
+		// Also check lines, if any
+		const lines = getLines(shape.props, 0)
+		if (lines !== undefined) {
+			for (const [C, D] of lines) {
+				if (linesIntersect(A, B, C, D)) return true
+			}
+		}
+
+		return false
+	}
+
+	override hitTestPoint(shape: TLGeoShape, point: VecLike): boolean {
+		const outline = this.editor.getOutline(shape)
+
+		if (shape.props.fill === 'none') {
+			const zoomLevel = this.editor.zoomLevel
+			const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
+			// Check the outline
+			for (let i = 0; i < outline.length; i++) {
+				const C = outline[i]
+				const D = outline[(i + 1) % outline.length]
+				if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
+			}
+
+			// Also check lines, if any
+			const lines = getLines(shape.props, 1)
+			if (lines !== undefined) {
+				for (const [C, D] of lines) {
+					if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
+				}
+			}
+
+			return false
+		}
+
+		return pointInPolygon(point, outline)
+	}
+
+	override getBounds(shape: TLGeoShape) {
+		return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY)
+	}
+
+	override getCenter(shape: TLGeoShape) {
+		return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2)
+	}
+
+	override getOutline(shape: TLGeoShape) {
+		const w = Math.max(1, shape.props.w)
+		const h = Math.max(1, shape.props.h + shape.props.growY)
+		const cx = w / 2
+		const cy = h / 2
+
+		switch (shape.props.geo) {
+			case 'cloud': {
+				return cloudOutline(w, h, shape.id, shape.props.size)
+			}
+			case 'triangle': {
+				return [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)]
+			}
+			case 'diamond': {
+				return [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)]
+			}
+			case 'pentagon': {
+				return getPolygonVertices(w, h, 5)
+			}
+			case 'hexagon': {
+				return getPolygonVertices(w, h, 6)
+			}
+			case 'octagon': {
+				return getPolygonVertices(w, h, 8)
+			}
+			case 'ellipse': {
+				// Perimeter of the ellipse
+
+				const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2)
+				const p = PI * (cx + cy) * (1 + (3 * q) / (10 + Math.sqrt(4 - 3 * q)))
+
+				// Number of points
+				let len = Math.max(4, Math.ceil(p / 10))
+
+				// Round length to nearest multiple of 4
+				// In some cases, this stops the outline overlapping with the indicator
+				// (it doesn't prevent all cases though, eg: when the shape is on the edge of a group)
+				len = Math.ceil(len / 4) * 4
+
+				// Size of step
+				const step = PI2 / len
+
+				const a = Math.cos(step)
+				const b = Math.sin(step)
+
+				let sin = 0
+				let cos = 1
+				let ts = 0
+				let tc = 1
+
+				const points: Vec2d[] = Array(len)
+
+				for (let i = 0; i < len; i++) {
+					points[i] = new Vec2d(cx + cx * cos, cy + cy * sin)
+					ts = b * cos + a * sin
+					tc = a * cos - b * sin
+					sin = ts
+					cos = tc
+				}
+
+				return points
+			}
+			case 'oval': {
+				const len = 10
+				const points: Vec2d[] = Array(len * 2)
+
+				if (h > w) {
+					for (let i = 0; i < len; i++) {
+						const t1 = -PI + (PI * i) / (len - 2)
+						const t2 = (PI * i) / (len - 2)
+						points[i] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1))
+						points[i + len] = new Vec2d(cx + cx * Math.cos(t2), h - cx + cx * Math.sin(t2))
+					}
+				} else {
+					for (let i = 0; i < len; i++) {
+						const t1 = -TAU + (PI * i) / (len - 2)
+						const t2 = TAU + (PI * -i) / (len - 2)
+						points[i] = new Vec2d(w - cy + cy * Math.cos(t1), h - cy + cy * Math.sin(t1))
+						points[i + len] = new Vec2d(cy - cy * Math.cos(t2), h - cy + cy * Math.sin(t2))
+					}
+				}
+
+				return points
+			}
+			case 'star': {
+				// Most of this code is to offset the center, a 5 point star
+				// will need to be moved downward because from its center [0,0]
+				// it will have a bigger minY than maxY. This is because it'll
+				// have 2 points at the bottom.
+				const sides = 5
+				const step = PI2 / sides / 2
+				const rightMostIndex = Math.floor(sides / 4) * 2
+				const leftMostIndex = sides * 2 - rightMostIndex
+				const topMostIndex = 0
+				const bottomMostIndex = Math.floor(sides / 2) * 2
+				const maxX = (Math.cos(-TAU + rightMostIndex * step) * w) / 2
+				const minX = (Math.cos(-TAU + leftMostIndex * step) * w) / 2
+
+				const minY = (Math.sin(-TAU + topMostIndex * step) * h) / 2
+				const maxY = (Math.sin(-TAU + bottomMostIndex * step) * h) / 2
+				const diffX = w - Math.abs(maxX - minX)
+				const diffY = h - Math.abs(maxY - minY)
+				const offsetX = w / 2 + minX - (w / 2 - maxX)
+				const offsetY = h / 2 + minY - (h / 2 - maxY)
+
+				const ratio = 1
+				const cx = (w - offsetX) / 2
+				const cy = (h - offsetY) / 2
+				const ox = (w + diffX) / 2
+				const oy = (h + diffY) / 2
+				const ix = (ox * ratio) / 2
+				const iy = (oy * ratio) / 2
+
+				return Array.from(Array(sides * 2)).map((_, i) => {
+					const theta = -TAU + i * step
+					return new Vec2d(
+						cx + (i % 2 ? ix : ox) * Math.cos(theta),
+						cy + (i % 2 ? iy : oy) * Math.sin(theta)
+					)
+				})
+			}
+			case 'rhombus': {
+				const offset = Math.min(w * 0.38, h * 0.38)
+				return [new Vec2d(offset, 0), new Vec2d(w, 0), new Vec2d(w - offset, h), new Vec2d(0, h)]
+			}
+			case 'rhombus-2': {
+				const offset = Math.min(w * 0.38, h * 0.38)
+				return [new Vec2d(0, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(offset, h)]
+			}
+			case 'trapezoid': {
+				const offset = Math.min(w * 0.38, h * 0.38)
+				return [new Vec2d(offset, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(0, h)]
+			}
+			case 'arrow-right': {
+				const ox = Math.min(w, h) * 0.38
+				const oy = h * 0.16
+				return [
+					new Vec2d(0, oy),
+					new Vec2d(w - ox, oy),
+					new Vec2d(w - ox, 0),
+					new Vec2d(w, h / 2),
+					new Vec2d(w - ox, h),
+					new Vec2d(w - ox, h - oy),
+					new Vec2d(0, h - oy),
+				]
+			}
+			case 'arrow-left': {
+				const ox = Math.min(w, h) * 0.38
+				const oy = h * 0.16
+				return [
+					new Vec2d(ox, 0),
+					new Vec2d(ox, oy),
+					new Vec2d(w, oy),
+					new Vec2d(w, h - oy),
+					new Vec2d(ox, h - oy),
+					new Vec2d(ox, h),
+					new Vec2d(0, h / 2),
+				]
+			}
+			case 'arrow-up': {
+				const ox = w * 0.16
+				const oy = Math.min(w, h) * 0.38
+				return [
+					new Vec2d(w / 2, 0),
+					new Vec2d(w, oy),
+					new Vec2d(w - ox, oy),
+					new Vec2d(w - ox, h),
+					new Vec2d(ox, h),
+					new Vec2d(ox, oy),
+					new Vec2d(0, oy),
+				]
+			}
+			case 'arrow-down': {
+				const ox = w * 0.16
+				const oy = Math.min(w, h) * 0.38
+				return [
+					new Vec2d(ox, 0),
+					new Vec2d(w - ox, 0),
+					new Vec2d(w - ox, h - oy),
+					new Vec2d(w, h - oy),
+					new Vec2d(w / 2, h),
+					new Vec2d(0, h - oy),
+					new Vec2d(ox, h - oy),
+				]
+			}
+			case 'check-box':
+			case 'x-box':
+			case 'rectangle': {
+				return [new Vec2d(0, 0), new Vec2d(w, 0), new Vec2d(w, h), new Vec2d(0, h)]
+			}
+		}
+	}
+
+	override onEditEnd: TLOnEditEndHandler<TLGeoShape> = (shape) => {
+		const {
+			id,
+			type,
+			props: { text },
+		} = shape
+
+		if (text.trimEnd() !== shape.props.text) {
+			this.editor.updateShapes([
+				{
+					id,
+					type,
+					props: {
+						text: text.trimEnd(),
+					},
+				},
+			])
+		}
+	}
+
+	component(shape: TLGeoShape) {
+		const { id, type, props } = shape
+
+		const forceSolid = useForceSolid()
+		const strokeWidth = STROKE_SIZES[props.size]
+
+		const { w, color, labelColor, fill, dash, growY, font, align, verticalAlign, size, text } =
+			props
+
+		const getShape = () => {
+			const h = props.h + growY
+
+			switch (props.geo) {
+				case 'cloud': {
+					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+						return (
+							<SolidStyleCloud
+								color={color}
+								fill={fill}
+								strokeWidth={strokeWidth}
+								w={w}
+								h={h}
+								id={id}
+								size={size}
+							/>
+						)
+					} else if (dash === 'dashed' || dash === 'dotted') {
+						return (
+							<DashStyleCloud
+								color={color}
+								fill={fill}
+								strokeWidth={strokeWidth}
+								w={w}
+								h={h}
+								id={id}
+								size={size}
+								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+							/>
+						)
+					} else if (dash === 'draw') {
+						return (
+							<DrawStyleCloud
+								color={color}
+								fill={fill}
+								strokeWidth={strokeWidth}
+								w={w}
+								h={h}
+								id={id}
+								size={size}
+							/>
+						)
+					}
+
+					break
+				}
+				case 'ellipse': {
+					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+						return (
+							<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
+						)
+					} else if (dash === 'dashed' || dash === 'dotted') {
+						return (
+							<DashStyleEllipse
+								id={id}
+								strokeWidth={strokeWidth}
+								w={w}
+								h={h}
+								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								color={color}
+								fill={fill}
+							/>
+						)
+					} else if (dash === 'draw') {
+						return (
+							<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
+						)
+					}
+					break
+				}
+				case 'oval': {
+					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+						return (
+							<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
+						)
+					} else if (dash === 'dashed' || dash === 'dotted') {
+						return (
+							<DashStyleOval
+								id={id}
+								strokeWidth={strokeWidth}
+								w={w}
+								h={h}
+								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								color={color}
+								fill={fill}
+							/>
+						)
+					} else if (dash === 'draw') {
+						return (
+							<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
+						)
+					}
+					break
+				}
+				default: {
+					const outline = this.editor.getOutline(shape)
+					const lines = getLines(shape.props, strokeWidth)
+
+					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+						return (
+							<SolidStylePolygon
+								fill={fill}
+								color={color}
+								strokeWidth={strokeWidth}
+								outline={outline}
+								lines={lines}
+							/>
+						)
+					} else if (dash === 'dashed' || dash === 'dotted') {
+						return (
+							<DashStylePolygon
+								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								fill={fill}
+								color={color}
+								strokeWidth={strokeWidth}
+								outline={outline}
+								lines={lines}
+							/>
+						)
+					} else if (dash === 'draw') {
+						return (
+							<DrawStylePolygon
+								id={id}
+								fill={fill}
+								color={color}
+								strokeWidth={strokeWidth}
+								outline={outline}
+								lines={lines}
+							/>
+						)
+					}
+				}
+			}
+		}
+
+		return (
+			<>
+				<SVGContainer id={id}>{getShape()}</SVGContainer>
+				<TextLabel
+					id={id}
+					type={type}
+					font={font}
+					fill={fill}
+					size={size}
+					align={align}
+					verticalAlign={verticalAlign}
+					text={text}
+					labelColor={labelColor}
+					wrap
+				/>
+				{shape.props.url && (
+					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+				)}
+			</>
+		)
+	}
+
+	indicator(shape: TLGeoShape) {
+		const { id, props } = shape
+		const { w, size } = props
+		const h = props.h + props.growY
+
+		const forceSolid = useForceSolid()
+		const strokeWidth = STROKE_SIZES[size]
+
+		switch (props.geo) {
+			case 'ellipse': {
+				if (props.dash === 'draw' && !forceSolid) {
+					return <path d={getEllipseIndicatorPath(id, w, h, strokeWidth)} />
+				}
+
+				return <ellipse cx={w / 2} cy={h / 2} rx={w / 2} ry={h / 2} />
+			}
+			case 'oval': {
+				return <path d={getOvalIndicatorPath(w, h)} />
+			}
+			case 'cloud': {
+				return <path d={cloudSvgPath(w, h, id, size)} />
+			}
+
+			default: {
+				const outline = this.editor.getOutline(shape)
+				let path: string
+
+				if (props.dash === 'draw' && !forceSolid) {
+					const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
+					path = getRoundedInkyPolygonPath(polygonPoints)
+				} else {
+					path = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
+				}
+
+				const lines = getLines(shape.props, strokeWidth)
+
+				if (lines) {
+					for (const [A, B] of lines) {
+						path += `M${A.x},${A.y}L${B.x},${B.y}`
+					}
+				}
+
+				return <path d={path} />
+			}
+		}
+	}
+
+	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
+		const { id, props } = shape
+		const strokeWidth = STROKE_SIZES[props.size]
+		const theme = getDefaultColorTheme(this.editor)
+		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
+
+		let svgElm: SVGElement
+
+		switch (props.geo) {
+			case 'ellipse': {
+				switch (props.dash) {
+					case 'draw':
+						svgElm = DrawStyleEllipseSvg({
+							id,
+							w: props.w,
+							h: props.h,
+							color: props.color,
+							fill: props.fill,
+							strokeWidth,
+							theme,
+						})
+						break
+
+					case 'solid':
+						svgElm = SolidStyleEllipseSvg({
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							color: props.color,
+							fill: props.fill,
+							theme,
+						})
+						break
+
+					default:
+						svgElm = DashStyleEllipseSvg({
+							id,
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							dash: props.dash,
+							color: props.color,
+							fill: props.fill,
+							theme,
+						})
+						break
+				}
+				break
+			}
+
+			case 'oval': {
+				switch (props.dash) {
+					case 'draw':
+						svgElm = DashStyleOvalSvg({
+							id,
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							dash: props.dash,
+							color: props.color,
+							fill: props.fill,
+							theme,
+						})
+						break
+
+					case 'solid':
+						svgElm = SolidStyleOvalSvg({
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							color: props.color,
+							fill: props.fill,
+							theme,
+						})
+						break
+
+					default:
+						svgElm = DashStyleOvalSvg({
+							id,
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							dash: props.dash,
+							color: props.color,
+							fill: props.fill,
+							theme,
+						})
+				}
+				break
+			}
+
+			case 'cloud': {
+				switch (props.dash) {
+					case 'draw':
+						svgElm = DrawStyleCloudSvg({
+							id,
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							color: props.color,
+							fill: props.fill,
+							size: props.size,
+							theme,
+						})
+						break
+
+					case 'solid':
+						svgElm = SolidStyleCloudSvg({
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							color: props.color,
+							fill: props.fill,
+							size: props.size,
+							id,
+							theme,
+						})
+						break
+
+					default:
+						svgElm = DashStyleCloudSvg({
+							id,
+							strokeWidth,
+							w: props.w,
+							h: props.h,
+							dash: props.dash,
+							color: props.color,
+							fill: props.fill,
+							theme,
+							size: props.size,
+						})
+				}
+				break
+			}
+			default: {
+				const outline = this.editor.getOutline(shape)
+				const lines = getLines(shape.props, strokeWidth)
+
+				switch (props.dash) {
+					case 'draw':
+						svgElm = DrawStylePolygonSvg({
+							id,
+							fill: props.fill,
+							color: props.color,
+							strokeWidth,
+							outline,
+							lines,
+							theme,
+						})
+						break
+
+					case 'solid':
+						svgElm = SolidStylePolygonSvg({
+							fill: props.fill,
+							color: props.color,
+							strokeWidth,
+							outline,
+							lines,
+							theme,
+						})
+						break
+
+					default:
+						svgElm = DashStylePolygonSvg({
+							dash: props.dash,
+							fill: props.fill,
+							color: props.color,
+							strokeWidth,
+							outline,
+							lines,
+							theme,
+						})
+						break
+				}
+				break
+			}
+		}
+
+		if (props.text) {
+			const bounds = this.editor.getBounds(shape)
+
+			ctx.addExportDef(getFontDefForExport(shape.props.font))
+
+			const rootTextElm = getTextLabelSvgElement({
+				editor: this.editor,
+				shape,
+				font: DefaultFontFamilies[shape.props.font],
+				bounds,
+			})
+
+			const textElm = rootTextElm.cloneNode(true) as SVGTextElement
+			textElm.setAttribute('fill', theme[shape.props.labelColor].solid)
+			textElm.setAttribute('stroke', 'none')
+
+			const textBgEl = rootTextElm.cloneNode(true) as SVGTextElement
+			textBgEl.setAttribute('stroke-width', '2')
+			textBgEl.setAttribute('fill', theme.background)
+			textBgEl.setAttribute('stroke', theme.background)
+
+			const groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+			groupEl.append(textBgEl)
+			groupEl.append(textElm)
+
+			if (svgElm.nodeName === 'g') {
+				svgElm.appendChild(groupEl)
+				return svgElm
+			} else {
+				const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+				g.appendChild(svgElm)
+				g.appendChild(groupEl)
+				return g
+			}
+		}
+
+		return svgElm
+	}
+
+	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
+		return [getFillDefForCanvas()]
+	}
+
+	override onResize: TLOnResizeHandler<TLGeoShape> = (
+		shape,
+		{ initialBounds, handle, newPoint, scaleX, scaleY }
+	) => {
+		let w = initialBounds.width * scaleX
+		let h = initialBounds.height * scaleY
+		let overShrinkX = 0
+		let overShrinkY = 0
+
+		if (shape.props.text.trim()) {
+			let newW = Math.max(Math.abs(w), MIN_SIZE_WITH_LABEL)
+			let newH = Math.max(Math.abs(h), MIN_SIZE_WITH_LABEL)
+
+			if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {
+				newW = MIN_SIZE_WITH_LABEL
+			}
+
+			if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {
+				newH = MIN_SIZE_WITH_LABEL
+			}
+
+			const labelSize = getLabelSize(this.editor, {
+				...shape,
+				props: {
+					...shape.props,
+					w: newW,
+					h: newH,
+				},
+			})
+
+			const nextW = Math.max(Math.abs(w), labelSize.w) * Math.sign(w)
+			const nextH = Math.max(Math.abs(h), labelSize.h) * Math.sign(h)
+			overShrinkX = Math.abs(nextW) - Math.abs(w)
+			overShrinkY = Math.abs(nextH) - Math.abs(h)
+
+			w = nextW
+			h = nextH
+		}
+
+		const offset = new Vec2d(0, 0)
+
+		// x offsets
+
+		if (scaleX < 0) {
+			offset.x += w
+		}
+
+		if (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {
+			offset.x += scaleX < 0 ? overShrinkX : -overShrinkX
+		}
+
+		// y offsets
+
+		if (scaleY < 0) {
+			offset.y += h
+		}
+
+		if (handle === 'top' || handle === 'top_left' || handle === 'top_right') {
+			offset.y += scaleY < 0 ? overShrinkY : -overShrinkY
+		}
+
+		const { x, y } = offset.rot(shape.rotation).add(newPoint)
+
+		return {
+			x,
+			y,
+			props: {
+				w: Math.max(Math.abs(w), 1),
+				h: Math.max(Math.abs(h), 1),
+				growY: 0,
+			},
+		}
+	}
+
+	override onBeforeCreate = (shape: TLGeoShape) => {
+		if (!shape.props.text) {
+			if (shape.props.growY) {
+				// No text / some growY, set growY to 0
+				return {
+					...shape,
+					props: {
+						...shape.props,
+						growY: 0,
+					},
+				}
+			} else {
+				// No text / no growY, nothing to change
+				return
+			}
+		}
+
+		const prevHeight = shape.props.h
+		const nextHeight = getLabelSize(this.editor, shape).h
+
+		let growY: number | null = null
+
+		if (nextHeight > prevHeight) {
+			growY = nextHeight - prevHeight
+		} else {
+			if (shape.props.growY) {
+				growY = 0
+			}
+		}
+
+		if (growY !== null) {
+			return {
+				...shape,
+				props: {
+					...shape.props,
+					growY,
+				},
+			}
+		}
+	}
+
+	override onBeforeUpdate = (prev: TLGeoShape, next: TLGeoShape) => {
+		const prevText = prev.props.text.trimEnd()
+		const nextText = next.props.text.trimEnd()
+
+		if (
+			prevText === nextText &&
+			prev.props.font === next.props.font &&
+			prev.props.size === next.props.size
+		) {
+			return
+		}
+
+		if (prevText && !nextText) {
+			return {
+				...next,
+				props: {
+					...next.props,
+					growY: 0,
+				},
+			}
+		}
+
+		const prevWidth = prev.props.w
+		const prevHeight = prev.props.h
+		const nextSize = getLabelSize(this.editor, next)
+		const nextWidth = nextSize.w
+		const nextHeight = nextSize.h
+
+		// When entering the first character in a label (not pasting in multiple characters...)
+		if (!prevText && nextText && nextText.length === 1) {
+			let w = Math.max(prevWidth, nextWidth)
+			let h = Math.max(prevHeight, nextHeight)
+
+			// If both the width and height were less than the minimum size, make the shape square
+			if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {
+				w = Math.max(w, MIN_SIZE_WITH_LABEL)
+				h = Math.max(h, MIN_SIZE_WITH_LABEL)
+				w = Math.max(w, h)
+				h = Math.max(w, h)
+			}
+
+			// Don't set a growY‚Äîat least, not until we've implemented a growX property
+			return {
+				...next,
+				props: {
+					...next.props,
+					w,
+					h,
+					growY: 0,
+				},
+			}
+		}
+
+		let growY: number | null = null
+
+		if (nextHeight > prevHeight) {
+			growY = nextHeight - prevHeight
+		} else {
+			if (prev.props.growY) {
+				growY = 0
+			}
+		}
+
+		if (growY !== null) {
+			return {
+				...next,
+				props: {
+					...next.props,
+					growY,
+					w: Math.max(next.props.w, nextWidth),
+				},
+			}
+		}
+
+		if (nextWidth > prev.props.w) {
+			return {
+				...next,
+				props: {
+					...next.props,
+					w: nextWidth,
+				},
+			}
+		}
+	}
+
+	override onDoubleClick = (shape: TLGeoShape) => {
+		// Little easter egg: double-clicking a rectangle / checkbox while
+		// holding alt will toggle between check-box and rectangle
+		if (this.editor.inputs.altKey) {
+			switch (shape.props.geo) {
+				case 'rectangle': {
+					return {
+						...shape,
+						props: {
+							geo: 'check-box' as const,
+						},
+					}
+				}
+				case 'check-box': {
+					return {
+						...shape,
+						props: {
+							geo: 'rectangle' as const,
+						},
+					}
+				}
+			}
+		}
+
+		return
+	}
+}
+
+function getLabelSize(editor: Editor, shape: TLGeoShape) {
+	const text = shape.props.text.trimEnd()
+
+	if (!text) {
+		return { w: 0, h: 0 }
+	}
+
+	const minSize = editor.textMeasure.measureText('w', {
+		...TEXT_PROPS,
+		fontFamily: FONT_FAMILIES[shape.props.font],
+		fontSize: LABEL_FONT_SIZES[shape.props.size],
+		width: 'fit-content',
+		maxWidth: '100px',
+	})
+
+	// TODO: Can I get these from somewhere?
+	const sizes = {
+		s: 2,
+		m: 3.5,
+		l: 5,
+		xl: 10,
+	}
+
+	const size = editor.textMeasure.measureText(text, {
+		...TEXT_PROPS,
+		fontFamily: FONT_FAMILIES[shape.props.font],
+		fontSize: LABEL_FONT_SIZES[shape.props.size],
+		width: 'fit-content',
+		minWidth: minSize.w + 'px',
+		maxWidth:
+			Math.max(
+				// Guard because a DOM nodes can't be less 0
+				0,
+				// A 'w' width that we're setting as the min-width
+				Math.ceil(minSize.w + sizes[shape.props.size]),
+				// The actual text size
+				Math.ceil(shape.props.w - LABEL_PADDING * 2)
+			) + 'px',
+	})
+
+	return {
+		w: size.w + LABEL_PADDING * 2,
+		h: size.h + LABEL_PADDING * 2,
+	}
+}
+
+function getLines(props: TLGeoShape['props'], sw: number) {
+	switch (props.geo) {
+		case 'x-box': {
+			return getXBoxLines(props.w, props.h, sw, props.dash)
+		}
+		case 'check-box': {
+			return getCheckBoxLines(props.w, props.h)
+		}
+		default: {
+			return undefined
+		}
+	}
+}
+
+function getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle) {
+	const inset = dash === 'draw' ? 0.62 : 0
+
+	if (dash === 'dashed') {
+		return [
+			[new Vec2d(0, 0), new Vec2d(w / 2, h / 2)],
+			[new Vec2d(w, h), new Vec2d(w / 2, h / 2)],
+			[new Vec2d(0, h), new Vec2d(w / 2, h / 2)],
+			[new Vec2d(w, 0), new Vec2d(w / 2, h / 2)],
+		]
+	}
+
+	return [
+		[new Vec2d(sw * inset, sw * inset), new Vec2d(w - sw * inset, h - sw * inset)],
+		[new Vec2d(sw * inset, h - sw * inset), new Vec2d(w - sw * inset, sw * inset)],
+	]
+}
+
+function getCheckBoxLines(w: number, h: number) {
+	const size = Math.min(w, h) * 0.82
+	const ox = (w - size) / 2
+	const oy = (h - size) / 2
+	return [
+		[new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],
+		[new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)],
+	]
+}

commit 3e31ef2a7d01467ef92ca4f7aed13ee708db73ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 18 22:50:23 2023 +0100

    Remove helpers / extraneous API methods. (#1745)
    
    This PR removes several extraneous computed values from the editor. It
    adds some silly instance state onto the instance state record and
    unifies a few methods which were inconsistent. This is fit and finish
    work üßΩ
    
    ## Computed Values
    
    In general, where once we had a getter and setter for `isBlahMode`,
    which really masked either an `_isBlahMode` atom on the editor or
    `instanceState.isBlahMode`, these are merged into `instanceState`; they
    can be accessed / updated via `editor.instanceState` /
    `editor.updateInstanceState`.
    
    ## tldraw select tool specific things
    
    This PR also removes some tldraw specific state checks and creates new
    component overrides to allow us to include them in tldraw/tldraw.
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [tldraw] rename `useReadonly` to `useReadOnly`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isChangingStyle`
    - [editor] remove `Editor.isCoarsePointer`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isFocused`
    - [editor] remove `Editor.isGridMode`
    - [editor] remove `Editor.isPenMode`
    - [editor] remove `Editor.isReadOnly`
    - [editor] remove `Editor.isSnapMode`
    - [editor] remove `Editor.isToolLocked`
    - [editor] remove `Editor.locale`
    - [editor] rename `Editor.pageState` to `Editor.currentPageState`
    - [editor] add `Editor.pageStates`
    - [editor] add `Editor.setErasingIds`
    - [editor] add `Editor.setEditingId`
    - [editor] add several new component overrides

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 4c6c3fcb1..44e90ba98 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -572,7 +572,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
 		const { id, props } = shape
 		const strokeWidth = STROKE_SIZES[props.size]
-		const theme = getDefaultColorTheme(this.editor)
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		let svgElm: SVGElement

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape‚Äîbut not focusing its input‚Äîwhile editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 44e90ba98..7ad86aa41 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1,12 +1,17 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
-	Box2d,
 	DefaultFontFamilies,
 	Editor,
-	PI,
+	Ellipse2d,
+	Geometry2d,
+	Group2d,
 	PI2,
+	Polygon2d,
+	Polyline2d,
+	Rectangle2d,
 	SVGContainer,
+	Stadium2d,
 	SvgExportContext,
 	TAU,
 	TLDefaultDashStyle,
@@ -15,13 +20,10 @@ import {
 	TLOnResizeHandler,
 	TLShapeUtilCanvasSvgDef,
 	Vec2d,
-	VecLike,
 	geoShapeMigrations,
 	geoShapeProps,
 	getDefaultColorTheme,
 	getPolygonVertices,
-	linesIntersect,
-	pointInPolygon,
 } from '@tldraw/editor'
 
 import { HyperlinkButton } from '../shared/HyperlinkButton'
@@ -87,145 +89,75 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
-	override hitTestLineSegment(shape: TLGeoShape, A: VecLike, B: VecLike): boolean {
-		const outline = this.editor.getOutline(shape)
-
-		// Check the outline
-		for (let i = 0; i < outline.length; i++) {
-			const C = outline[i]
-			const D = outline[(i + 1) % outline.length]
-			if (linesIntersect(A, B, C, D)) return true
-		}
-
-		// Also check lines, if any
-		const lines = getLines(shape.props, 0)
-		if (lines !== undefined) {
-			for (const [C, D] of lines) {
-				if (linesIntersect(A, B, C, D)) return true
-			}
-		}
-
-		return false
-	}
-
-	override hitTestPoint(shape: TLGeoShape, point: VecLike): boolean {
-		const outline = this.editor.getOutline(shape)
-
-		if (shape.props.fill === 'none') {
-			const zoomLevel = this.editor.zoomLevel
-			const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
-			// Check the outline
-			for (let i = 0; i < outline.length; i++) {
-				const C = outline[i]
-				const D = outline[(i + 1) % outline.length]
-				if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
-			}
-
-			// Also check lines, if any
-			const lines = getLines(shape.props, 1)
-			if (lines !== undefined) {
-				for (const [C, D] of lines) {
-					if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
-				}
-			}
-
-			return false
-		}
-
-		return pointInPolygon(point, outline)
-	}
-
-	override getBounds(shape: TLGeoShape) {
-		return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY)
-	}
-
-	override getCenter(shape: TLGeoShape) {
-		return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2)
-	}
-
-	override getOutline(shape: TLGeoShape) {
+	override getGeometry(shape: TLGeoShape): Geometry2d {
 		const w = Math.max(1, shape.props.w)
 		const h = Math.max(1, shape.props.h + shape.props.growY)
 		const cx = w / 2
 		const cy = h / 2
 
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+		const isFilled = shape.props.fill !== 'none' // || shape.props.text.trim().length > 0
+
+		let body: Geometry2d
+
 		switch (shape.props.geo) {
 			case 'cloud': {
-				return cloudOutline(w, h, shape.id, shape.props.size)
+				body = new Polygon2d({
+					points: cloudOutline(w, h, shape.id, shape.props.size),
+					isFilled,
+				})
+				break
 			}
 			case 'triangle': {
-				return [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)]
+				body = new Polygon2d({
+					points: [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)],
+					isFilled,
+				})
+				break
 			}
 			case 'diamond': {
-				return [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)]
+				body = new Polygon2d({
+					points: [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)],
+					isFilled,
+				})
+				break
 			}
 			case 'pentagon': {
-				return getPolygonVertices(w, h, 5)
+				body = new Polygon2d({
+					points: getPolygonVertices(w, h, 5),
+					isFilled,
+				})
+				break
 			}
 			case 'hexagon': {
-				return getPolygonVertices(w, h, 6)
+				body = new Polygon2d({
+					points: getPolygonVertices(w, h, 6),
+					isFilled,
+				})
+				break
 			}
 			case 'octagon': {
-				return getPolygonVertices(w, h, 8)
+				body = new Polygon2d({
+					points: getPolygonVertices(w, h, 8),
+					isFilled,
+				})
+				break
 			}
 			case 'ellipse': {
-				// Perimeter of the ellipse
-
-				const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2)
-				const p = PI * (cx + cy) * (1 + (3 * q) / (10 + Math.sqrt(4 - 3 * q)))
-
-				// Number of points
-				let len = Math.max(4, Math.ceil(p / 10))
-
-				// Round length to nearest multiple of 4
-				// In some cases, this stops the outline overlapping with the indicator
-				// (it doesn't prevent all cases though, eg: when the shape is on the edge of a group)
-				len = Math.ceil(len / 4) * 4
-
-				// Size of step
-				const step = PI2 / len
-
-				const a = Math.cos(step)
-				const b = Math.sin(step)
-
-				let sin = 0
-				let cos = 1
-				let ts = 0
-				let tc = 1
-
-				const points: Vec2d[] = Array(len)
-
-				for (let i = 0; i < len; i++) {
-					points[i] = new Vec2d(cx + cx * cos, cy + cy * sin)
-					ts = b * cos + a * sin
-					tc = a * cos - b * sin
-					sin = ts
-					cos = tc
-				}
-
-				return points
+				body = new Ellipse2d({
+					width: w,
+					height: h,
+					isFilled,
+				})
+				break
 			}
 			case 'oval': {
-				const len = 10
-				const points: Vec2d[] = Array(len * 2)
-
-				if (h > w) {
-					for (let i = 0; i < len; i++) {
-						const t1 = -PI + (PI * i) / (len - 2)
-						const t2 = (PI * i) / (len - 2)
-						points[i] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1))
-						points[i + len] = new Vec2d(cx + cx * Math.cos(t2), h - cx + cx * Math.sin(t2))
-					}
-				} else {
-					for (let i = 0; i < len; i++) {
-						const t1 = -TAU + (PI * i) / (len - 2)
-						const t2 = TAU + (PI * -i) / (len - 2)
-						points[i] = new Vec2d(w - cy + cy * Math.cos(t1), h - cy + cy * Math.sin(t1))
-						points[i + len] = new Vec2d(cy - cy * Math.cos(t2), h - cy + cy * Math.sin(t2))
-					}
-				}
-
-				return points
+				body = new Stadium2d({
+					width: w,
+					height: h,
+					isFilled,
+				})
+				break
 			}
 			case 'star': {
 				// Most of this code is to offset the center, a 5 point star
@@ -256,84 +188,162 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const ix = (ox * ratio) / 2
 				const iy = (oy * ratio) / 2
 
-				return Array.from(Array(sides * 2)).map((_, i) => {
-					const theta = -TAU + i * step
-					return new Vec2d(
-						cx + (i % 2 ? ix : ox) * Math.cos(theta),
-						cy + (i % 2 ? iy : oy) * Math.sin(theta)
-					)
+				body = new Polygon2d({
+					points: Array.from(Array(sides * 2)).map((_, i) => {
+						const theta = -TAU + i * step
+						return new Vec2d(
+							cx + (i % 2 ? ix : ox) * Math.cos(theta),
+							cy + (i % 2 ? iy : oy) * Math.sin(theta)
+						)
+					}),
+					isFilled,
 				})
+				break
 			}
 			case 'rhombus': {
 				const offset = Math.min(w * 0.38, h * 0.38)
-				return [new Vec2d(offset, 0), new Vec2d(w, 0), new Vec2d(w - offset, h), new Vec2d(0, h)]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(offset, 0),
+						new Vec2d(w, 0),
+						new Vec2d(w - offset, h),
+						new Vec2d(0, h),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'rhombus-2': {
 				const offset = Math.min(w * 0.38, h * 0.38)
-				return [new Vec2d(0, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(offset, h)]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(0, 0),
+						new Vec2d(w - offset, 0),
+						new Vec2d(w, h),
+						new Vec2d(offset, h),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'trapezoid': {
 				const offset = Math.min(w * 0.38, h * 0.38)
-				return [new Vec2d(offset, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(0, h)]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(offset, 0),
+						new Vec2d(w - offset, 0),
+						new Vec2d(w, h),
+						new Vec2d(0, h),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'arrow-right': {
 				const ox = Math.min(w, h) * 0.38
 				const oy = h * 0.16
-				return [
-					new Vec2d(0, oy),
-					new Vec2d(w - ox, oy),
-					new Vec2d(w - ox, 0),
-					new Vec2d(w, h / 2),
-					new Vec2d(w - ox, h),
-					new Vec2d(w - ox, h - oy),
-					new Vec2d(0, h - oy),
-				]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(0, oy),
+						new Vec2d(w - ox, oy),
+						new Vec2d(w - ox, 0),
+						new Vec2d(w, h / 2),
+						new Vec2d(w - ox, h),
+						new Vec2d(w - ox, h - oy),
+						new Vec2d(0, h - oy),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'arrow-left': {
 				const ox = Math.min(w, h) * 0.38
 				const oy = h * 0.16
-				return [
-					new Vec2d(ox, 0),
-					new Vec2d(ox, oy),
-					new Vec2d(w, oy),
-					new Vec2d(w, h - oy),
-					new Vec2d(ox, h - oy),
-					new Vec2d(ox, h),
-					new Vec2d(0, h / 2),
-				]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(ox, 0),
+						new Vec2d(ox, oy),
+						new Vec2d(w, oy),
+						new Vec2d(w, h - oy),
+						new Vec2d(ox, h - oy),
+						new Vec2d(ox, h),
+						new Vec2d(0, h / 2),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'arrow-up': {
 				const ox = w * 0.16
 				const oy = Math.min(w, h) * 0.38
-				return [
-					new Vec2d(w / 2, 0),
-					new Vec2d(w, oy),
-					new Vec2d(w - ox, oy),
-					new Vec2d(w - ox, h),
-					new Vec2d(ox, h),
-					new Vec2d(ox, oy),
-					new Vec2d(0, oy),
-				]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(w / 2, 0),
+						new Vec2d(w, oy),
+						new Vec2d(w - ox, oy),
+						new Vec2d(w - ox, h),
+						new Vec2d(ox, h),
+						new Vec2d(ox, oy),
+						new Vec2d(0, oy),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'arrow-down': {
 				const ox = w * 0.16
 				const oy = Math.min(w, h) * 0.38
-				return [
-					new Vec2d(ox, 0),
-					new Vec2d(w - ox, 0),
-					new Vec2d(w - ox, h - oy),
-					new Vec2d(w, h - oy),
-					new Vec2d(w / 2, h),
-					new Vec2d(0, h - oy),
-					new Vec2d(ox, h - oy),
-				]
+				body = new Polygon2d({
+					points: [
+						new Vec2d(ox, 0),
+						new Vec2d(w - ox, 0),
+						new Vec2d(w - ox, h - oy),
+						new Vec2d(w, h - oy),
+						new Vec2d(w / 2, h),
+						new Vec2d(0, h - oy),
+						new Vec2d(ox, h - oy),
+					],
+					isFilled,
+				})
+				break
 			}
 			case 'check-box':
 			case 'x-box':
 			case 'rectangle': {
-				return [new Vec2d(0, 0), new Vec2d(w, 0), new Vec2d(w, h), new Vec2d(0, h)]
+				body = new Rectangle2d({
+					width: w,
+					height: h,
+					isFilled,
+					isSnappable: true,
+				})
+				break
 			}
 		}
+
+		// const labelSize = getLabelSize(this.editor, shape)
+		// const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
+		// const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8))))
+
+		const lines = getLines(shape.props, strokeWidth)
+		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
+
+		return new Group2d({
+			children: [
+				body,
+				// new Rectangle2d({
+				// 	x: w / 2 - labelWidth / 2,
+				// 	y: h / 2 - labelHeight / 2,
+				// 	width: labelWidth,
+				// 	height: labelHeight,
+				// 	isFilled: true,
+				// 	isSnappable: false,
+				// 	margin: 12,
+				// }),
+				...edges,
+			],
+			operation: 'union',
+			isSnappable: false,
+		})
 	}
 
 	override onEditEnd: TLOnEditEndHandler<TLGeoShape> = (shape) => {
@@ -460,7 +470,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					break
 				}
 				default: {
-					const outline = this.editor.getOutline(shape)
+					const geometry = this.editor.getGeometry(shape)
+					const outline =
+						geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 					const lines = getLines(shape.props, strokeWidth)
 
 					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
@@ -546,7 +558,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 
 			default: {
-				const outline = this.editor.getOutline(shape)
+				const geometry = this.editor.getGeometry(shape)
+				const outline =
+					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 				let path: string
 
 				if (props.dash === 'draw' && !forceSolid) {
@@ -704,7 +718,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				break
 			}
 			default: {
-				const outline = this.editor.getOutline(shape)
+				const geometry = this.editor.getGeometry(shape)
+				const outline =
+					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 				const lines = getLines(shape.props, strokeWidth)
 
 				switch (props.dash) {
@@ -748,7 +764,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 
 		if (props.text) {
-			const bounds = this.editor.getBounds(shape)
+			const bounds = this.editor.getGeometry(shape).bounds
 
 			ctx.addExportDef(getFontDefForExport(shape.props.font))
 

commit 18f5a1d9d2c3ff589cab76bd2afe18eb1162c50b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 27 18:18:44 2023 +0100

    remove useForceSolid effect for geo / line shapes (#1769)
    
    These shapes no longer use perfect freehand for their rendering, so we
    can drop the effect of `useForceSolid` for them.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Zoom out
    2. Draw style draw shapes should not change
    
    ### Release Notes
    
    - Remove the force solid switching for geo / line shapes

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 7ad86aa41..7ea6b9198 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1,4 +1,3 @@
-/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
 	DefaultFontFamilies,
@@ -41,7 +40,6 @@ import {
 } from '../shared/defaultStyleDefs'
 import { getTextLabelSvgElement } from '../shared/getTextLabelSvgElement'
 import { getRoundedInkyPolygonPath, getRoundedPolygonPoints } from '../shared/polygon-helpers'
-import { useForceSolid } from '../shared/useForceSolid'
 import { cloudOutline, cloudSvgPath } from './cloudOutline'
 import { DashStyleCloud, DashStyleCloudSvg } from './components/DashStyleCloud'
 import { DashStyleEllipse, DashStyleEllipseSvg } from './components/DashStyleEllipse'
@@ -369,7 +367,6 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	component(shape: TLGeoShape) {
 		const { id, type, props } = shape
 
-		const forceSolid = useForceSolid()
 		const strokeWidth = STROKE_SIZES[props.size]
 
 		const { w, color, labelColor, fill, dash, growY, font, align, verticalAlign, size, text } =
@@ -380,7 +377,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 			switch (props.geo) {
 				case 'cloud': {
-					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+					if (dash === 'solid') {
 						return (
 							<SolidStyleCloud
 								color={color}
@@ -402,7 +399,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 								h={h}
 								id={id}
 								size={size}
-								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								dash={dash}
 							/>
 						)
 					} else if (dash === 'draw') {
@@ -422,7 +419,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					break
 				}
 				case 'ellipse': {
-					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+					if (dash === 'solid') {
 						return (
 							<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
 						)
@@ -433,7 +430,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 								strokeWidth={strokeWidth}
 								w={w}
 								h={h}
-								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								dash={dash}
 								color={color}
 								fill={fill}
 							/>
@@ -446,7 +443,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					break
 				}
 				case 'oval': {
-					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+					if (dash === 'solid') {
 						return (
 							<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
 						)
@@ -457,7 +454,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 								strokeWidth={strokeWidth}
 								w={w}
 								h={h}
-								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								dash={dash}
 								color={color}
 								fill={fill}
 							/>
@@ -475,7 +472,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 					const lines = getLines(shape.props, strokeWidth)
 
-					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+					if (dash === 'solid') {
 						return (
 							<SolidStylePolygon
 								fill={fill}
@@ -488,7 +485,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					} else if (dash === 'dashed' || dash === 'dotted') {
 						return (
 							<DashStylePolygon
-								dash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}
+								dash={dash}
 								fill={fill}
 								color={color}
 								strokeWidth={strokeWidth}
@@ -539,12 +536,11 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const { w, size } = props
 		const h = props.h + props.growY
 
-		const forceSolid = useForceSolid()
 		const strokeWidth = STROKE_SIZES[size]
 
 		switch (props.geo) {
 			case 'ellipse': {
-				if (props.dash === 'draw' && !forceSolid) {
+				if (props.dash === 'draw') {
 					return <path d={getEllipseIndicatorPath(id, w, h, strokeWidth)} />
 				}
 
@@ -563,7 +559,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 				let path: string
 
-				if (props.dash === 'draw' && !forceSolid) {
+				if (props.dash === 'draw') {
 					const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
 					path = getRoundedInkyPolygonPath(polygonPoints)
 				} else {

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 7ea6b9198..702322b8c 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -467,7 +467,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					break
 				}
 				default: {
-					const geometry = this.editor.getGeometry(shape)
+					const geometry = this.editor.getShapeGeometry(shape)
 					const outline =
 						geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 					const lines = getLines(shape.props, strokeWidth)
@@ -554,7 +554,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 
 			default: {
-				const geometry = this.editor.getGeometry(shape)
+				const geometry = this.editor.getShapeGeometry(shape)
 				const outline =
 					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 				let path: string
@@ -714,7 +714,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				break
 			}
 			default: {
-				const geometry = this.editor.getGeometry(shape)
+				const geometry = this.editor.getShapeGeometry(shape)
 				const outline =
 					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
 				const lines = getLines(shape.props, strokeWidth)
@@ -760,7 +760,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 
 		if (props.text) {
-			const bounds = this.editor.getGeometry(shape).bounds
+			const bounds = this.editor.getShapeGeometry(shape).bounds
 
 			ctx.addExportDef(getFontDefForExport(shape.props.font))
 

commit 22329c51fcdb41111c7adf0fa4522cc675150738
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Aug 13 16:55:24 2023 +0100

    [improvement] More selection logic (#1806)
    
    This PR includes further UX improvements to selection.
    
    - clicking inside of a hollow shape will no longer select it on pointer
    up
    - clicking a shape's filled label will select it on pointer down
    - clicking a shape's empty label will select it on pointer up
    - clicking and dragging a selected arrow is now better limited to its
    body, not its bounds
    - arrows will no longer bind to labels
    
    ### Text labels
    
    A big change here relates to text labels. Previously, we had listeners
    set on the text label elements; I've removed these and we now check the
    actual label bounds geometry for a hit. For geo shapes, this geometry is
    now placed correctly based on the alignment / vertical alignment of the
    label.
    
    - Clicking on a label with text in it will select the shape on pointer
    down.
    - Clicking on an empty text label will select the shape on pointer up.
    
    ## Hollow shapes
    
    Previously, shapes with `fill: none` were also being selected on pointer
    up. I've removed that logic because it was producing wrong-feeling
    selections too often. We now select these shapes only when clicking on
    the label (as mentioned above) or when clicking on the edges of the
    shape. This is in line with the original behavior (currently on
    tldraw.com, prior to the earlier PR that updated selection logic).
    
    ## Arrows
    
    Arrows still hit the inside of hollow shapes, using the "smallest
    hovered" logic previously used for pointer-up selection on hollow
    shapes. They also now correctly do so while ignoring text labels.
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Test Plan
    
    1. try selecting geo shapes, nested geo shapes, arrows and shapes with
    labels or without labels
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 702322b8c..aca407c59 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -318,28 +318,35 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 		}
 
-		// const labelSize = getLabelSize(this.editor, shape)
-		// const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
-		// const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8))))
-
+		const labelSize = getLabelSize(this.editor, shape)
+		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
+		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8))))
 		const lines = getLines(shape.props, strokeWidth)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
 
 		return new Group2d({
 			children: [
 				body,
-				// new Rectangle2d({
-				// 	x: w / 2 - labelWidth / 2,
-				// 	y: h / 2 - labelHeight / 2,
-				// 	width: labelWidth,
-				// 	height: labelHeight,
-				// 	isFilled: true,
-				// 	isSnappable: false,
-				// 	margin: 12,
-				// }),
+				new Rectangle2d({
+					x:
+						shape.props.align === 'start'
+							? 0
+							: shape.props.align === 'end'
+							? w - labelWidth
+							: (w - labelWidth) / 2,
+					y:
+						shape.props.verticalAlign === 'start'
+							? 0
+							: shape.props.verticalAlign === 'end'
+							? h - labelHeight
+							: (h - labelHeight) / 2,
+					width: labelWidth,
+					height: labelHeight,
+					isFilled: true,
+					isSnappable: false,
+				}),
 				...edges,
 			],
-			operation: 'union',
 			isSnappable: false,
 		})
 	}

commit 9d8a0b0a8d926a329c4af7c2026fdf0a3f99d22d
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Sep 8 12:37:50 2023 +0100

    clamp x-box and check-box lines to stay within box at small scales (#1860)
    
    Closes [#2737](https://github.com/tldraw/brivate/issues/2737)
    
    For the checkbox and x-box the inner lines are inset slightly from the
    edges to account for the stroke width. Alas at tiny box sizes (the box
    is creates as w:1,h:1 during a drag-to-create interaction) this was
    ending up with the insets overflowing such that they left the box on the
    other side, creating miscalculations during the initial resizing.
    
    This PR clamps the positions of the x-box and checkbox inner lines so
    they don't escape the bounds of the box.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixes a regression introduced by the geometry refactor related to
    x-box and checkbox resizing.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index aca407c59..848856b66 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1109,9 +1109,18 @@ function getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle
 		]
 	}
 
+	const clampX = (x: number) => Math.max(0, Math.min(w, x))
+	const clampY = (y: number) => Math.max(0, Math.min(h, y))
+
 	return [
-		[new Vec2d(sw * inset, sw * inset), new Vec2d(w - sw * inset, h - sw * inset)],
-		[new Vec2d(sw * inset, h - sw * inset), new Vec2d(w - sw * inset, sw * inset)],
+		[
+			new Vec2d(clampX(sw * inset), clampY(sw * inset)),
+			new Vec2d(clampX(w - sw * inset), clampY(h - sw * inset)),
+		],
+		[
+			new Vec2d(clampX(sw * inset), clampY(h - sw * inset)),
+			new Vec2d(clampX(w - sw * inset), clampY(sw * inset)),
+		],
 	]
 }
 
@@ -1119,8 +1128,18 @@ function getCheckBoxLines(w: number, h: number) {
 	const size = Math.min(w, h) * 0.82
 	const ox = (w - size) / 2
 	const oy = (h - size) / 2
+
+	const clampX = (x: number) => Math.max(0, Math.min(w, x))
+	const clampY = (y: number) => Math.max(0, Math.min(h, y))
+
 	return [
-		[new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],
-		[new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)],
+		[
+			new Vec2d(clampX(ox + size * 0.25), clampY(oy + size * 0.52)),
+			new Vec2d(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
+		],
+		[
+			new Vec2d(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
+			new Vec2d(clampX(ox + size * 0.82), clampY(oy + size * 0.22)),
+		],
 	]
 }

commit beb9db8eb7aa38e8473ba48a3b4021fbba151d43
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Sep 18 15:59:27 2023 +0100

    Fix arrow handle snapping, snapping to text labels, selection of text labels (#1910)
    
    This PR:
    - adds `canSnap` as a property to handle and ignores snapping when
    dragging a handle that does not have `canSnap` set to true. Arrows no
    longer snap.
    - adds `isLabel` to Geometry2d
    - fixes selection on empty text labels
    - fixes vertices / snapping for empty text labels
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 848856b66..24566347b 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -321,6 +321,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const labelSize = getLabelSize(this.editor, shape)
 		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
 		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8))))
+
 		const lines = getLines(shape.props, strokeWidth)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
 
@@ -344,6 +345,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					height: labelHeight,
 					isFilled: true,
 					isSnappable: false,
+					isLabel: true,
 				}),
 				...edges,
 			],

commit 9e4dbd19013ccbae28a112929cf5e50474e5028f
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Sep 26 09:05:05 2023 -0500

    [fix] geo shape text label placement (#1927)
    
    This PR fixes the text label placement for geo shapes. (It also fixes
    the way an ellipse renders when set to dash or dotted).
    
    There's still the slightest offset of the text label's outline when you
    begin editing. Maybe we should keep the indicator instead?
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    Create a hexagon shape
    hit enter to type
    indicator is offset, text label is no longer offset
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 24566347b..49ae4da34 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -532,6 +532,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					text={text}
 					labelColor={labelColor}
 					wrap
+					bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
 				/>
 				{shape.props.url && (
 					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
@@ -813,10 +814,12 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 	override onResize: TLOnResizeHandler<TLGeoShape> = (
 		shape,
-		{ initialBounds, handle, newPoint, scaleX, scaleY }
+		{ handle, newPoint, scaleX, scaleY, initialShape }
 	) => {
-		let w = initialBounds.width * scaleX
-		let h = initialBounds.height * scaleY
+		// use the w/h from props here instead of the initialBounds here,
+		// since cloud shapes calculated bounds can differ from the props w/h.
+		let w = initialShape.props.w * scaleX
+		let h = (initialShape.props.h + initialShape.props.growY) * scaleY
 		let overShrinkX = 0
 		let overShrinkY = 0
 

commit f73bf9a7fea4ca6922b8effa10412fbb9f77c288
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Oct 2 12:30:53 2023 +0100

    Fix text-wrapping on Safari (#1980)
    
    Co-authored-by: Alex Alex@dytry.ch
    
    closes [#1978](https://github.com/tldraw/tldraw/issues/1978)
    
    Text was wrapping on Safari because the measure text div was rendered
    differently on different browsers. Interestingly, when forcing the
    text-measure div to be visible and on-screen in Chrome, the same
    text-wrapping behaviour was apparent. By setting white-space to 'pre'
    when width hasn't been set by the user, we can ensure that only line
    breaks the user has inputted are rendered by default on all browsers.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. On Safari
    2. Make a new text shape and start typing
    3. At a certain point the text starts to wrap without the width having
    been set
    
    
    ### Release Notes
    
    - Fix text wrapping differently on Safari and Chrome/Firefox
    
    Before/After
    
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/320171b4-61e0-4a41-b8d3-830bd90bea65">
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/b42d7156-0ce9-4894-9692-9338dc931b79">

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 49ae4da34..eb11c4405 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1053,7 +1053,7 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
 		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		width: 'fit-content',
+		width: null,
 		maxWidth: '100px',
 	})
 
@@ -1069,7 +1069,7 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
 		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		width: 'fit-content',
+		width: null,
 		minWidth: minSize.w + 'px',
 		maxWidth:
 			Math.max(

commit 92886e1f40670018589d2c14dced119e47f8e6d1
Author: alex <alex@dytry.ch>
Date:   Tue Oct 3 15:26:13 2023 +0100

    fix text in geo shapes not causing its container to grow (#2003)
    
    We got things sliggghhhtly wrong in #1980. That diff was attempting to
    fix a bug where the text measurement element would refuse to go above
    the viewport size in safari. This was most obvious in the case where
    there was no fixed width on a text shape, and that diff fixed that case,
    but it was also happening when a fixed width text shape was wider than
    viewport - which wasn't covered by that fix. It turned out that that fix
    also introduced a bug where shapes would no longer grow along the y-axis
    - in part because the relationship between `width`, `maxWidth`, and
    `minWidth` is very confusing.
    
    The one-liner fix is to just use `max-content` instead of `fit-content`
    - that way, the div ignores the size of its container. But I also
    cleared up the API for text measurement to remove the `width` property
    entirely in favour of `maxWidth`. I think this makes things much clearer
    and as far as I can tell doesn't affect anything.
    
    Closes #1998
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Create an arrow & geo shape with labels, plus a note and text shape
    2. Try to break text measurement - overflow the bounds, make very wide
    text, experiment with fixed/auto-size text, etc.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index eb11c4405..9c98db5f6 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1053,8 +1053,7 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
 		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		width: null,
-		maxWidth: '100px',
+		maxWidth: 100,
 	})
 
 	// TODO: Can I get these from somewhere?
@@ -1069,17 +1068,15 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
 		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		width: null,
 		minWidth: minSize.w + 'px',
-		maxWidth:
-			Math.max(
-				// Guard because a DOM nodes can't be less 0
-				0,
-				// A 'w' width that we're setting as the min-width
-				Math.ceil(minSize.w + sizes[shape.props.size]),
-				// The actual text size
-				Math.ceil(shape.props.w - LABEL_PADDING * 2)
-			) + 'px',
+		maxWidth: Math.max(
+			// Guard because a DOM nodes can't be less 0
+			0,
+			// A 'w' width that we're setting as the min-width
+			Math.ceil(minSize.w + sizes[shape.props.size]),
+			// The actual text size
+			Math.ceil(shape.props.w - LABEL_PADDING * 2)
+		),
 	})
 
 	return {

commit 421102282d735c6db7f80f032949ecc7bf6bfb66
Author: alex <alex@dytry.ch>
Date:   Tue Oct 10 13:58:28 2023 +0100

    Fix newlines in text geo shapes (#2059)
    
    Previously, entering a geo shape and adding a bunch of newlines wouldn't
    correctly update the shape's height. This fixes that.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    
    ### Test Plan
    
    1. Create a geo shape
    2. Enter text editing mode
    3. Spam the enter key
    4. See that the shape grows appropriately
    5. Exit editing and check that the trailing newlines have been deleted.
    
    - [ ] Unit Tests
    - [x] End to end tests
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 9c98db5f6..0aca51f9c 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -930,8 +930,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override onBeforeUpdate = (prev: TLGeoShape, next: TLGeoShape) => {
-		const prevText = prev.props.text.trimEnd()
-		const nextText = next.props.text.trimEnd()
+		const prevText = prev.props.text
+		const nextText = next.props.text
 
 		if (
 			prevText === nextText &&
@@ -1043,7 +1043,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 }
 
 function getLabelSize(editor: Editor, shape: TLGeoShape) {
-	const text = shape.props.text.trimEnd()
+	const text = shape.props.text
 
 	if (!text) {
 		return { w: 0, h: 0 }

commit 5719cc76c12c379d700e59912edb74127ded218e
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Tue Oct 31 13:34:23 2023 +0000

    [android] Fix text labels and link button getting misaligned (#2132)
    
    Fixes https://github.com/tldraw/tldraw/issues/2131
    
    Before:
    
    
    https://github.com/tldraw/tldraw/assets/15892272/c64d4ac5-6665-4c41-bf20-a5dbecdf4e1f
    
    After:
    
    ![2023-10-31 at 12 20 21 - Chocolate
    Dragonfly](https://github.com/tldraw/tldraw/assets/15892272/2b8ec620-8602-48ec-a0c1-e203b7eb1f38)
    
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. On android, make a geo shape.
    2. Add a text label to it.
    3. Add a link to it.
    4. Resize it.
    5. Make sure the label and link don't wiggle around.
    6. Repeat with a link on an image shape.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixed a bug where labels and links could lose alignment on android.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 0aca51f9c..316694c8a 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -5,6 +5,7 @@ import {
 	Ellipse2d,
 	Geometry2d,
 	Group2d,
+	HTMLContainer,
 	PI2,
 	Polygon2d,
 	Polyline2d,
@@ -521,22 +522,27 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		return (
 			<>
 				<SVGContainer id={id}>{getShape()}</SVGContainer>
-				<TextLabel
-					id={id}
-					type={type}
-					font={font}
-					fill={fill}
-					size={size}
-					align={align}
-					verticalAlign={verticalAlign}
-					text={text}
-					labelColor={labelColor}
-					wrap
-					bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
-				/>
-				{shape.props.url && (
-					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
-				)}
+				<HTMLContainer
+					id={shape.id}
+					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
+				>
+					<TextLabel
+						id={id}
+						type={type}
+						font={font}
+						fill={fill}
+						size={size}
+						align={align}
+						verticalAlign={verticalAlign}
+						text={text}
+						labelColor={labelColor}
+						wrap
+						bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
+					/>
+					{shape.props.url && (
+						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+					)}
+				</HTMLContainer>
 			</>
 		)
 	}

commit bc24c0cc15336f13aab5345720e7cb7bbeb3dfe3
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Tue Nov 7 14:52:19 2023 +0100

    Fix the problem with text not being correctly aligned in small geo shapes. (#2168)
    
    Seems like the `HTMLContainer` didn't have the correct size, so text
    label was positioned a bit further up than it should be.
    
    Fixes [#2156](https://github.com/tldraw/tldraw/issues/2156)
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Create a small geo shape
    2. Add some text to it. Test it with text that wraps to new lines.
    3. Make sure text is centred.
    
    
    ### Release Notes
    
    - Fixes position of Text labels in geo shapes.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 316694c8a..d4bcf23a9 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -524,7 +524,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				<SVGContainer id={id}>{getShape()}</SVGContainer>
 				<HTMLContainer
 					id={shape.id}
-					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
+					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h + props.growY }}
 				>
 					<TextLabel
 						id={id}

commit 6f872c796afd6cf538ce81d35c5a40dcccbe7013
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 11:57:43 2023 +0000

    No impure getters pt6 (#2218)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index d4bcf23a9..a97b475f2 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -540,7 +540,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
 					/>
 					{shape.props.url && (
-						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
 					)}
 				</HTMLContainer>
 			</>

commit d683cc09432197e89bddacf2b706b5eaad40e399
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 17:07:35 2023 +0000

    No impure getters pt9 (#2222)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index a97b475f2..ad6aaf955 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -598,7 +598,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
 		const { id, props } = shape
 		const strokeWidth = STROKE_SIZES[props.size]
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		let svgElm: SVGElement

commit 3f90fbf5b074618e71ee5cb19d5de383493d629e
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Dec 24 11:53:15 2023 +0000

    [fix] polygon bounds (#2378)
    
    This PR fixes the bounds calculation for polygons. It solves the bug
    reported here: https://github.com/tldraw/tldraw/issues/2309 . Note that
    this may produce visual changes for hexagons and other shapes.
    
    ![Kapture 2023-12-24 at 10 35
    13](https://github.com/tldraw/tldraw/assets/23072548/773e89ee-f8c3-4875-b942-30860b1cdf22)
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Create a hexagon shape with a label.
    2. The label should be correctly centered.
    
    ### Release Notes
    
    - Fixed a bug with the bounds calculation for polygons.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index ad6aaf955..485b9376d 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -20,6 +20,7 @@ import {
 	TLOnResizeHandler,
 	TLShapeUtilCanvasSvgDef,
 	Vec2d,
+	VecLike,
 	geoShapeMigrations,
 	geoShapeProps,
 	getDefaultColorTheme,
@@ -321,11 +322,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		const labelSize = getLabelSize(this.editor, shape)
 		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
-		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8))))
+		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8)))) // not sure if bug
 
 		const lines = getLines(shape.props, strokeWidth)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
 
+		// todo: use centroid for label position
+
 		return new Group2d({
 			children: [
 				body,
@@ -1151,3 +1154,19 @@ function getCheckBoxLines(w: number, h: number) {
 		],
 	]
 }
+
+/**
+ * Get the centroid of a regular polygon.
+ * @param points - The points that make up the polygon.
+ * @internal
+ */
+export function getCentroidOfRegularPolygon(points: VecLike[]) {
+	const len = points.length
+	let x = 0
+	let y = 0
+	for (let i = 0; i < len; i++) {
+		x += points[i].x
+		y += points[i].y
+	}
+	return new Vec2d(x / len, y / len)
+}

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 485b9376d..674927c1c 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -5,6 +5,7 @@ import {
 	Ellipse2d,
 	Geometry2d,
 	Group2d,
+	HALF_PI,
 	HTMLContainer,
 	PI2,
 	Polygon2d,
@@ -13,13 +14,12 @@ import {
 	SVGContainer,
 	Stadium2d,
 	SvgExportContext,
-	TAU,
 	TLDefaultDashStyle,
 	TLGeoShape,
 	TLOnEditEndHandler,
 	TLOnResizeHandler,
 	TLShapeUtilCanvasSvgDef,
-	Vec2d,
+	Vec,
 	VecLike,
 	geoShapeMigrations,
 	geoShapeProps,
@@ -110,14 +110,14 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 			case 'triangle': {
 				body = new Polygon2d({
-					points: [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)],
+					points: [new Vec(cx, 0), new Vec(w, h), new Vec(0, h)],
 					isFilled,
 				})
 				break
 			}
 			case 'diamond': {
 				body = new Polygon2d({
-					points: [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)],
+					points: [new Vec(cx, 0), new Vec(w, cy), new Vec(cx, h), new Vec(0, cy)],
 					isFilled,
 				})
 				break
@@ -170,11 +170,11 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const leftMostIndex = sides * 2 - rightMostIndex
 				const topMostIndex = 0
 				const bottomMostIndex = Math.floor(sides / 2) * 2
-				const maxX = (Math.cos(-TAU + rightMostIndex * step) * w) / 2
-				const minX = (Math.cos(-TAU + leftMostIndex * step) * w) / 2
+				const maxX = (Math.cos(-HALF_PI + rightMostIndex * step) * w) / 2
+				const minX = (Math.cos(-HALF_PI + leftMostIndex * step) * w) / 2
 
-				const minY = (Math.sin(-TAU + topMostIndex * step) * h) / 2
-				const maxY = (Math.sin(-TAU + bottomMostIndex * step) * h) / 2
+				const minY = (Math.sin(-HALF_PI + topMostIndex * step) * h) / 2
+				const maxY = (Math.sin(-HALF_PI + bottomMostIndex * step) * h) / 2
 				const diffX = w - Math.abs(maxX - minX)
 				const diffY = h - Math.abs(maxY - minY)
 				const offsetX = w / 2 + minX - (w / 2 - maxX)
@@ -190,8 +190,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 				body = new Polygon2d({
 					points: Array.from(Array(sides * 2)).map((_, i) => {
-						const theta = -TAU + i * step
-						return new Vec2d(
+						const theta = -HALF_PI + i * step
+						return new Vec(
 							cx + (i % 2 ? ix : ox) * Math.cos(theta),
 							cy + (i % 2 ? iy : oy) * Math.sin(theta)
 						)
@@ -203,12 +203,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			case 'rhombus': {
 				const offset = Math.min(w * 0.38, h * 0.38)
 				body = new Polygon2d({
-					points: [
-						new Vec2d(offset, 0),
-						new Vec2d(w, 0),
-						new Vec2d(w - offset, h),
-						new Vec2d(0, h),
-					],
+					points: [new Vec(offset, 0), new Vec(w, 0), new Vec(w - offset, h), new Vec(0, h)],
 					isFilled,
 				})
 				break
@@ -216,12 +211,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			case 'rhombus-2': {
 				const offset = Math.min(w * 0.38, h * 0.38)
 				body = new Polygon2d({
-					points: [
-						new Vec2d(0, 0),
-						new Vec2d(w - offset, 0),
-						new Vec2d(w, h),
-						new Vec2d(offset, h),
-					],
+					points: [new Vec(0, 0), new Vec(w - offset, 0), new Vec(w, h), new Vec(offset, h)],
 					isFilled,
 				})
 				break
@@ -229,12 +219,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			case 'trapezoid': {
 				const offset = Math.min(w * 0.38, h * 0.38)
 				body = new Polygon2d({
-					points: [
-						new Vec2d(offset, 0),
-						new Vec2d(w - offset, 0),
-						new Vec2d(w, h),
-						new Vec2d(0, h),
-					],
+					points: [new Vec(offset, 0), new Vec(w - offset, 0), new Vec(w, h), new Vec(0, h)],
 					isFilled,
 				})
 				break
@@ -244,13 +229,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const oy = h * 0.16
 				body = new Polygon2d({
 					points: [
-						new Vec2d(0, oy),
-						new Vec2d(w - ox, oy),
-						new Vec2d(w - ox, 0),
-						new Vec2d(w, h / 2),
-						new Vec2d(w - ox, h),
-						new Vec2d(w - ox, h - oy),
-						new Vec2d(0, h - oy),
+						new Vec(0, oy),
+						new Vec(w - ox, oy),
+						new Vec(w - ox, 0),
+						new Vec(w, h / 2),
+						new Vec(w - ox, h),
+						new Vec(w - ox, h - oy),
+						new Vec(0, h - oy),
 					],
 					isFilled,
 				})
@@ -261,13 +246,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const oy = h * 0.16
 				body = new Polygon2d({
 					points: [
-						new Vec2d(ox, 0),
-						new Vec2d(ox, oy),
-						new Vec2d(w, oy),
-						new Vec2d(w, h - oy),
-						new Vec2d(ox, h - oy),
-						new Vec2d(ox, h),
-						new Vec2d(0, h / 2),
+						new Vec(ox, 0),
+						new Vec(ox, oy),
+						new Vec(w, oy),
+						new Vec(w, h - oy),
+						new Vec(ox, h - oy),
+						new Vec(ox, h),
+						new Vec(0, h / 2),
 					],
 					isFilled,
 				})
@@ -278,13 +263,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const oy = Math.min(w, h) * 0.38
 				body = new Polygon2d({
 					points: [
-						new Vec2d(w / 2, 0),
-						new Vec2d(w, oy),
-						new Vec2d(w - ox, oy),
-						new Vec2d(w - ox, h),
-						new Vec2d(ox, h),
-						new Vec2d(ox, oy),
-						new Vec2d(0, oy),
+						new Vec(w / 2, 0),
+						new Vec(w, oy),
+						new Vec(w - ox, oy),
+						new Vec(w - ox, h),
+						new Vec(ox, h),
+						new Vec(ox, oy),
+						new Vec(0, oy),
 					],
 					isFilled,
 				})
@@ -295,13 +280,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				const oy = Math.min(w, h) * 0.38
 				body = new Polygon2d({
 					points: [
-						new Vec2d(ox, 0),
-						new Vec2d(w - ox, 0),
-						new Vec2d(w - ox, h - oy),
-						new Vec2d(w, h - oy),
-						new Vec2d(w / 2, h),
-						new Vec2d(0, h - oy),
-						new Vec2d(ox, h - oy),
+						new Vec(ox, 0),
+						new Vec(w - ox, 0),
+						new Vec(w - ox, h - oy),
+						new Vec(w, h - oy),
+						new Vec(w / 2, h),
+						new Vec(0, h - oy),
+						new Vec(ox, h - oy),
 					],
 					isFilled,
 				})
@@ -862,7 +847,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			h = nextH
 		}
 
-		const offset = new Vec2d(0, 0)
+		const offset = new Vec(0, 0)
 
 		// x offsets
 
@@ -1113,10 +1098,10 @@ function getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle
 
 	if (dash === 'dashed') {
 		return [
-			[new Vec2d(0, 0), new Vec2d(w / 2, h / 2)],
-			[new Vec2d(w, h), new Vec2d(w / 2, h / 2)],
-			[new Vec2d(0, h), new Vec2d(w / 2, h / 2)],
-			[new Vec2d(w, 0), new Vec2d(w / 2, h / 2)],
+			[new Vec(0, 0), new Vec(w / 2, h / 2)],
+			[new Vec(w, h), new Vec(w / 2, h / 2)],
+			[new Vec(0, h), new Vec(w / 2, h / 2)],
+			[new Vec(w, 0), new Vec(w / 2, h / 2)],
 		]
 	}
 
@@ -1125,12 +1110,12 @@ function getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle
 
 	return [
 		[
-			new Vec2d(clampX(sw * inset), clampY(sw * inset)),
-			new Vec2d(clampX(w - sw * inset), clampY(h - sw * inset)),
+			new Vec(clampX(sw * inset), clampY(sw * inset)),
+			new Vec(clampX(w - sw * inset), clampY(h - sw * inset)),
 		],
 		[
-			new Vec2d(clampX(sw * inset), clampY(h - sw * inset)),
-			new Vec2d(clampX(w - sw * inset), clampY(sw * inset)),
+			new Vec(clampX(sw * inset), clampY(h - sw * inset)),
+			new Vec(clampX(w - sw * inset), clampY(sw * inset)),
 		],
 	]
 }
@@ -1145,12 +1130,12 @@ function getCheckBoxLines(w: number, h: number) {
 
 	return [
 		[
-			new Vec2d(clampX(ox + size * 0.25), clampY(oy + size * 0.52)),
-			new Vec2d(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
+			new Vec(clampX(ox + size * 0.25), clampY(oy + size * 0.52)),
+			new Vec(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
 		],
 		[
-			new Vec2d(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
-			new Vec2d(clampX(ox + size * 0.82), clampY(oy + size * 0.22)),
+			new Vec(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
+			new Vec(clampX(ox + size * 0.82), clampY(oy + size * 0.22)),
 		],
 	]
 }
@@ -1168,5 +1153,5 @@ export function getCentroidOfRegularPolygon(points: VecLike[]) {
 		x += points[i].x
 		y += points[i].y
 	}
-	return new Vec2d(x / len, y / len)
+	return new Vec(x / len, y / len)
 }

commit 29044867dd2e49a3711e95c547fa9352e66720b9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 15 12:33:15 2024 +0000

    Add docs (#2470)
    
    This PR adds the docs app back into the tldraw monorepo.
    
    ## Deploying
    
    We'll want to update our deploy script to update the SOURCE_SHA to the
    newest release sha... and then deploy the docs pulling api.json files
    from that release. We _could_ update the docs on every push to main, but
    we don't have to unless something has changed. Right now there's no
    automated deployments from this repo.
    
    ## Side effects
    
    To make this one work, I needed to update the lock file. This might be
    ok (new year new lock file), and everything builds as expected, though
    we may want to spend some time with our scripts to be sure that things
    are all good.
    
    I also updated our prettier installation, which decided to add trailing
    commas to every generic type. Which is, I suppose, [correct
    behavior](https://github.com/prettier/prettier-vscode/issues/955)? But
    that caused diffs in every file, which is unfortunate.
    
    ### Change Type
    
    - [x] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 674927c1c..9025005dc 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -322,14 +322,14 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						shape.props.align === 'start'
 							? 0
 							: shape.props.align === 'end'
-							? w - labelWidth
-							: (w - labelWidth) / 2,
+								? w - labelWidth
+								: (w - labelWidth) / 2,
 					y:
 						shape.props.verticalAlign === 'start'
 							? 0
 							: shape.props.verticalAlign === 'end'
-							? h - labelHeight
-							: (h - labelHeight) / 2,
+								? h - labelHeight
+								: (h - labelHeight) / 2,
 					width: labelWidth,
 					height: labelHeight,
 					isFilled: true,

commit e6e4e7f6cbac1cb72c0f530dae703c657dc8b6bf
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Feb 5 17:54:02 2024 +0000

    [dx] use Biome instead of Prettier, part 2 (#2731)
    
    Biome seems to be MUCH faster than Prettier. Unfortunately, it
    introduces some formatting changes around the ternary operator, so we
    have to update files in the repo. To make revert easier if we need it,
    the change is split into two PRs. This PR introduces a Biome CI check
    and reformats all files accordingly.
    
    ## Change Type
    - [x] `minor` ‚Äî New feature

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 9025005dc..5633bc53f 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -322,14 +322,14 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						shape.props.align === 'start'
 							? 0
 							: shape.props.align === 'end'
-								? w - labelWidth
-								: (w - labelWidth) / 2,
+							  ? w - labelWidth
+							  : (w - labelWidth) / 2,
 					y:
 						shape.props.verticalAlign === 'start'
 							? 0
 							: shape.props.verticalAlign === 'end'
-								? h - labelHeight
-								: (h - labelHeight) / 2,
+							  ? h - labelHeight
+							  : (h - labelHeight) / 2,
 					width: labelWidth,
 					height: labelHeight,
 					isFilled: true,

commit 86cce6d161e2018f02fc4271bbcff803d07fa339
Author: Dan Groshev <git@dgroshev.com>
Date:   Wed Feb 7 16:02:22 2024 +0000

    Unbiome (#2776)
    
    Biome as it is now didn't work out for us üò¢
    
    Summary for posterity:
    
    * it IS much, much faster, fast enough to skip any sort of caching
    * we couldn't fully replace Prettier just yet. We use Prettier
    programmatically to format code in docs, and Biome's JS interface is
    officially alpha and [had legacy peer deps
    set](https://github.com/biomejs/biome/pull/1756) (which would fail our
    CI build as we don't allow installation warnings)
    * ternary formatting differs from Prettier, leading to a large diff
    https://github.com/biomejs/biome/issues/1661
    * import sorting differs from Prettier's
    `prettier-plugin-organize-imports`, making the diff even bigger
    * the deal breaker is a multi-second delay on saving large files (for us
    it's
    [Editor.ts](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/editor/Editor.ts))
    in VSCode when import sorting is enabled. There is a seemingly relevant
    Biome issue where I posted a small summary of our findings:
    https://github.com/biomejs/biome/issues/1569#issuecomment-1930411623
    
    Further actions:
    
    * reevaluate in a few months as Biome matures
    
    ### Change Type
    
    - [x] `internal` ‚Äî Any other changes that don't affect the published
    package

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 5633bc53f..9025005dc 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -322,14 +322,14 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						shape.props.align === 'start'
 							? 0
 							: shape.props.align === 'end'
-							  ? w - labelWidth
-							  : (w - labelWidth) / 2,
+								? w - labelWidth
+								: (w - labelWidth) / 2,
 					y:
 						shape.props.verticalAlign === 'start'
 							? 0
 							: shape.props.verticalAlign === 'end'
-							  ? h - labelHeight
-							  : (h - labelHeight) / 2,
+								? h - labelHeight
+								: (h - labelHeight) / 2,
 					width: labelWidth,
 					height: labelHeight,
 					isFilled: true,

commit 056481899c191de41c69d778c1a6d20dd139839b
Author: alex <alex@dytry.ch>
Date:   Thu Feb 8 17:08:57 2024 +0000

    Remove Geometry2d.isSnappable (#2768)
    
    `Geometry2d.isSnappable` isn't used. There's some intended behaviour
    here around making it so you can't snap handles to text labels, but it's
    not actually working.
    
    This is a breaking change, but given this property doesn't do anything I
    don't think it's likely to be heavily depended upon
    
    ### Change Type
    - [x] `major` ‚Äî Breaking change

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 9025005dc..3d02e939b 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -299,7 +299,6 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					width: w,
 					height: h,
 					isFilled,
-					isSnappable: true,
 				})
 				break
 			}
@@ -333,12 +332,10 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					width: labelWidth,
 					height: labelHeight,
 					isFilled: true,
-					isSnappable: false,
 					isLabel: true,
 				}),
 				...edges,
 			],
-			isSnappable: false,
 		})
 	}
 

commit 32f641c1d7d147b39afdd1935723a23cefe03422
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Tue Feb 13 14:46:55 2024 +0000

    emojis! üßë‚Äçüé® üé® ‚úèÔ∏è (#2814)
    
    everyone ‚ù§Ô∏è's emojis:
    https://dropbox.tech/application/dropbox-paper-emojis-and-exformation
    
    
    https://github.com/tldraw/tldraw/assets/469604/8f99f485-de98-44d1-93cb-6eb9c2d87d99
    
    
    
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Test Plan
    
    1. Test adding lots of emojis!
    
    ### Release Notes
    
    - Adds emoji picker to text fields.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 3d02e939b..017c81adb 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -32,6 +32,7 @@ import { TextLabel } from '../shared/TextLabel'
 import {
 	FONT_FAMILIES,
 	LABEL_FONT_SIZES,
+	LABEL_PADDING,
 	STROKE_SIZES,
 	TEXT_PROPS,
 } from '../shared/default-shape-constants'
@@ -59,7 +60,6 @@ import {
 } from './components/SolidStyleOval'
 import { SolidStylePolygon, SolidStylePolygonSvg } from './components/SolidStylePolygon'
 
-const LABEL_PADDING = 16
 const MIN_SIZE_WITH_LABEL = 17 * 3
 
 /** @public */

commit 5cf2fe9583ea90de4894c02cd9c6e31c169bb2f0
Author: Dan Groshev <git@dgroshev.com>
Date:   Tue Feb 13 14:59:59 2024 +0000

    Revert "emojis! üßë‚Äçüé® üé® ‚úèÔ∏è (#2814)" (#2822)
    
    Reverting accidental merge of #2814
    
    ### Change Type
    - [x] `internal` ‚Äî Any other changes that don't affect the published
    package

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 017c81adb..3d02e939b 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -32,7 +32,6 @@ import { TextLabel } from '../shared/TextLabel'
 import {
 	FONT_FAMILIES,
 	LABEL_FONT_SIZES,
-	LABEL_PADDING,
 	STROKE_SIZES,
 	TEXT_PROPS,
 } from '../shared/default-shape-constants'
@@ -60,6 +59,7 @@ import {
 } from './components/SolidStyleOval'
 import { SolidStylePolygon, SolidStylePolygonSvg } from './components/SolidStylePolygon'
 
+const LABEL_PADDING = 16
 const MIN_SIZE_WITH_LABEL = 17 * 3
 
 /** @public */

commit 31a2b2115f7f79215a2e4ba1d5842f3336862645
Author: alex <alex@dytry.ch>
Date:   Thu Feb 15 15:53:28 2024 +0000

    [Snapping 5/5] Better handle snapping for geo shapes (#2845)
    
    Currently, geo shapes have slightly janky handle-snapping: they snap to
    label geometry (even though its invisible) and because they extend from
    `BaseBoxShapeUtil` they snap to the corners of their bounding box (even
    if that's not where the actual shape is).
    
    With this PR, we no longer snap to labels, and we snap to the actual
    vertices of the geo shape rather than its bounding points.
    
    1. #2827
    2. #2831
    3. #2793
    4. #2841
    5. #2845 (you are here)
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    
    ### Test Plan
    - [x] Unit Tests
    
    ### Release Notes
    
    - You can now snap the handles of lines to the corners of rectangles,
    stars, triangles, etc.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 3d02e939b..c9d215222 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -7,6 +7,7 @@ import {
 	Group2d,
 	HALF_PI,
 	HTMLContainer,
+	HandleSnapGeometry,
 	PI2,
 	Polygon2d,
 	Polyline2d,
@@ -21,6 +22,7 @@ import {
 	TLShapeUtilCanvasSvgDef,
 	Vec,
 	VecLike,
+	exhaustiveSwitchError,
 	geoShapeMigrations,
 	geoShapeProps,
 	getDefaultColorTheme,
@@ -89,7 +91,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
-	override getGeometry(shape: TLGeoShape): Geometry2d {
+	override getGeometry(shape: TLGeoShape) {
 		const w = Math.max(1, shape.props.w)
 		const h = Math.max(1, shape.props.h + shape.props.growY)
 		const cx = w / 2
@@ -339,6 +341,39 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		})
 	}
 
+	override getHandleSnapGeometry(shape: TLGeoShape): HandleSnapGeometry {
+		const geometry = this.getGeometry(shape)
+		// we only want to snap handles to the outline of the shape - not to its label etc.
+		const outline = geometry.children[0]
+		switch (shape.props.geo) {
+			case 'arrow-down':
+			case 'arrow-left':
+			case 'arrow-right':
+			case 'arrow-up':
+			case 'check-box':
+			case 'diamond':
+			case 'hexagon':
+			case 'octagon':
+			case 'pentagon':
+			case 'rectangle':
+			case 'rhombus':
+			case 'rhombus-2':
+			case 'star':
+			case 'trapezoid':
+			case 'triangle':
+			case 'x-box':
+				// poly-line type shapes hand snap points for each vertex & the center
+				return { outline: outline, points: [...outline.getVertices(), geometry.bounds.center] }
+			case 'cloud':
+			case 'ellipse':
+			case 'oval':
+				// blobby shapes only have a snap point in their center
+				return { outline: outline, points: [geometry.bounds.center] }
+			default:
+				exhaustiveSwitchError(shape.props.geo)
+		}
+	}
+
 	override onEditEnd: TLOnEditEndHandler<TLGeoShape> = (shape) => {
 		const {
 			id,

commit 212eb88480bd66b5b2930768e1594f814b8da150
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Fri Feb 16 13:54:48 2024 +0000

    Add component for viewing an image of a snapshot  (#2804)
    
    This PR adds the `TldrawImage` component that displays a tldraw snapshot
    as an SVG image.
    
    ![2024-02-15 at 12 29 52 - Coral
    Cod](https://github.com/tldraw/tldraw/assets/15892272/14140e9e-7d6d-4dd3-88a3-86a6786325c5)
    
    ## Why
    
    We've seen requests for this kind of thing from users. eg: GitBook, and
    on discord:
    
    <img width="710" alt="image"
    src="https://github.com/tldraw/tldraw/assets/15892272/3d3a3e9d-66b9-42e7-81de-a70aa7165bdc">
    
    The component provides a way to do that.
    This PR also untangles various bits of editor state from image
    exporting, which makes it easier for library users to export images more
    agnostically. (ie: they can now export any shapes on any page in any
    theme. previously, they had to change the user's state to do that).
    
    ## What else
    
    - This PR also adds an **Image snapshot** example to demonstrate the new
    component.
    - We now pass an `isDarkMode` property to the `toSvg` method (inside the
    `ctx` argument). This means that `toSvg` doesn't have to rely on editor
    state anymore. I updated all our `toSvg` methods to use it.
    - See code comments for more info.
    
    ## Any issues?
    
    When you toggle to editing mode in the new example, text measurements
    are initially wrong (until you edit the size of a text shape). Click on
    the text shape to see how its indicator is wrong. Not sure why this is,
    or if it's even related. Does it ring a bell with anyone? If not, I'll
    take a closer look. (fixed, see comments --steve)
    
    ## Future work
    
    Now that we've untangled image exporting from editor state, we could
    expose some more helpful helpers for making this easier.
    
    Fixes tld-2122
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Open the **Image snapshot** example.
    2. Try editing the image, saving the image, and making sure the image
    updates.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Dev: Added the `TldrawImage` component.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index c9d215222..398c47f50 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -618,7 +618,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
 		const { id, props } = shape
 		const strokeWidth = STROKE_SIZES[props.size]
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
+		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		let svgElm: SVGElement

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 398c47f50..29c5c11be 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1,6 +1,5 @@
 import {
 	BaseBoxShapeUtil,
-	DefaultFontFamilies,
 	Editor,
 	Ellipse2d,
 	Geometry2d,
@@ -15,21 +14,19 @@ import {
 	SVGContainer,
 	Stadium2d,
 	SvgExportContext,
-	TLDefaultDashStyle,
 	TLGeoShape,
 	TLOnEditEndHandler,
 	TLOnResizeHandler,
 	TLShapeUtilCanvasSvgDef,
 	Vec,
-	VecLike,
 	exhaustiveSwitchError,
 	geoShapeMigrations,
 	geoShapeProps,
-	getDefaultColorTheme,
 	getPolygonVertices,
 } from '@tldraw/editor'
 
 import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { TextLabel } from '../shared/TextLabel'
 import {
 	FONT_FAMILIES,
@@ -42,24 +39,12 @@ import {
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
-import { getTextLabelSvgElement } from '../shared/getTextLabelSvgElement'
 import { getRoundedInkyPolygonPath, getRoundedPolygonPoints } from '../shared/polygon-helpers'
 import { cloudOutline, cloudSvgPath } from './cloudOutline'
-import { DashStyleCloud, DashStyleCloudSvg } from './components/DashStyleCloud'
-import { DashStyleEllipse, DashStyleEllipseSvg } from './components/DashStyleEllipse'
-import { DashStyleOval, DashStyleOvalSvg } from './components/DashStyleOval'
-import { DashStylePolygon, DashStylePolygonSvg } from './components/DashStylePolygon'
-import { DrawStyleCloud, DrawStyleCloudSvg } from './components/DrawStyleCloud'
-import { DrawStyleEllipseSvg, getEllipseIndicatorPath } from './components/DrawStyleEllipse'
-import { DrawStylePolygon, DrawStylePolygonSvg } from './components/DrawStylePolygon'
-import { SolidStyleCloud, SolidStyleCloudSvg } from './components/SolidStyleCloud'
-import { SolidStyleEllipse, SolidStyleEllipseSvg } from './components/SolidStyleEllipse'
-import {
-	SolidStyleOval,
-	SolidStyleOvalSvg,
-	getOvalIndicatorPath,
-} from './components/SolidStyleOval'
-import { SolidStylePolygon, SolidStylePolygonSvg } from './components/SolidStylePolygon'
+import { getEllipseIndicatorPath } from './components/DrawStyleEllipse'
+import { GeoShapeBody } from './components/GeoShapeBody'
+import { getOvalIndicatorPath } from './components/SolidStyleOval'
+import { getLines } from './getLines'
 
 const LABEL_PADDING = 16
 const MIN_SIZE_WITH_LABEL = 17 * 3
@@ -396,152 +381,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 	component(shape: TLGeoShape) {
 		const { id, type, props } = shape
-
-		const strokeWidth = STROKE_SIZES[props.size]
-
-		const { w, color, labelColor, fill, dash, growY, font, align, verticalAlign, size, text } =
-			props
-
-		const getShape = () => {
-			const h = props.h + growY
-
-			switch (props.geo) {
-				case 'cloud': {
-					if (dash === 'solid') {
-						return (
-							<SolidStyleCloud
-								color={color}
-								fill={fill}
-								strokeWidth={strokeWidth}
-								w={w}
-								h={h}
-								id={id}
-								size={size}
-							/>
-						)
-					} else if (dash === 'dashed' || dash === 'dotted') {
-						return (
-							<DashStyleCloud
-								color={color}
-								fill={fill}
-								strokeWidth={strokeWidth}
-								w={w}
-								h={h}
-								id={id}
-								size={size}
-								dash={dash}
-							/>
-						)
-					} else if (dash === 'draw') {
-						return (
-							<DrawStyleCloud
-								color={color}
-								fill={fill}
-								strokeWidth={strokeWidth}
-								w={w}
-								h={h}
-								id={id}
-								size={size}
-							/>
-						)
-					}
-
-					break
-				}
-				case 'ellipse': {
-					if (dash === 'solid') {
-						return (
-							<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
-						)
-					} else if (dash === 'dashed' || dash === 'dotted') {
-						return (
-							<DashStyleEllipse
-								id={id}
-								strokeWidth={strokeWidth}
-								w={w}
-								h={h}
-								dash={dash}
-								color={color}
-								fill={fill}
-							/>
-						)
-					} else if (dash === 'draw') {
-						return (
-							<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
-						)
-					}
-					break
-				}
-				case 'oval': {
-					if (dash === 'solid') {
-						return (
-							<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
-						)
-					} else if (dash === 'dashed' || dash === 'dotted') {
-						return (
-							<DashStyleOval
-								id={id}
-								strokeWidth={strokeWidth}
-								w={w}
-								h={h}
-								dash={dash}
-								color={color}
-								fill={fill}
-							/>
-						)
-					} else if (dash === 'draw') {
-						return (
-							<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />
-						)
-					}
-					break
-				}
-				default: {
-					const geometry = this.editor.getShapeGeometry(shape)
-					const outline =
-						geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
-					const lines = getLines(shape.props, strokeWidth)
-
-					if (dash === 'solid') {
-						return (
-							<SolidStylePolygon
-								fill={fill}
-								color={color}
-								strokeWidth={strokeWidth}
-								outline={outline}
-								lines={lines}
-							/>
-						)
-					} else if (dash === 'dashed' || dash === 'dotted') {
-						return (
-							<DashStylePolygon
-								dash={dash}
-								fill={fill}
-								color={color}
-								strokeWidth={strokeWidth}
-								outline={outline}
-								lines={lines}
-							/>
-						)
-					} else if (dash === 'draw') {
-						return (
-							<DrawStylePolygon
-								id={id}
-								fill={fill}
-								color={color}
-								strokeWidth={strokeWidth}
-								outline={outline}
-								lines={lines}
-							/>
-						)
-					}
-				}
-			}
-		}
+		const { labelColor, fill, font, align, verticalAlign, size, text } = props
 
 		return (
 			<>
-				<SVGContainer id={id}>{getShape()}</SVGContainer>
+				<SVGContainer id={id}>
+					<GeoShapeBody shape={shape} />
+				</SVGContainer>
 				<HTMLContainer
 					id={shape.id}
 					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h + props.growY }}
@@ -616,222 +462,33 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
-		const { id, props } = shape
-		const strokeWidth = STROKE_SIZES[props.size]
-		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
-		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
-
-		let svgElm: SVGElement
-
-		switch (props.geo) {
-			case 'ellipse': {
-				switch (props.dash) {
-					case 'draw':
-						svgElm = DrawStyleEllipseSvg({
-							id,
-							w: props.w,
-							h: props.h,
-							color: props.color,
-							fill: props.fill,
-							strokeWidth,
-							theme,
-						})
-						break
-
-					case 'solid':
-						svgElm = SolidStyleEllipseSvg({
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							color: props.color,
-							fill: props.fill,
-							theme,
-						})
-						break
-
-					default:
-						svgElm = DashStyleEllipseSvg({
-							id,
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							dash: props.dash,
-							color: props.color,
-							fill: props.fill,
-							theme,
-						})
-						break
-				}
-				break
-			}
-
-			case 'oval': {
-				switch (props.dash) {
-					case 'draw':
-						svgElm = DashStyleOvalSvg({
-							id,
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							dash: props.dash,
-							color: props.color,
-							fill: props.fill,
-							theme,
-						})
-						break
-
-					case 'solid':
-						svgElm = SolidStyleOvalSvg({
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							color: props.color,
-							fill: props.fill,
-							theme,
-						})
-						break
-
-					default:
-						svgElm = DashStyleOvalSvg({
-							id,
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							dash: props.dash,
-							color: props.color,
-							fill: props.fill,
-							theme,
-						})
-				}
-				break
-			}
-
-			case 'cloud': {
-				switch (props.dash) {
-					case 'draw':
-						svgElm = DrawStyleCloudSvg({
-							id,
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							color: props.color,
-							fill: props.fill,
-							size: props.size,
-							theme,
-						})
-						break
-
-					case 'solid':
-						svgElm = SolidStyleCloudSvg({
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							color: props.color,
-							fill: props.fill,
-							size: props.size,
-							id,
-							theme,
-						})
-						break
-
-					default:
-						svgElm = DashStyleCloudSvg({
-							id,
-							strokeWidth,
-							w: props.w,
-							h: props.h,
-							dash: props.dash,
-							color: props.color,
-							fill: props.fill,
-							theme,
-							size: props.size,
-						})
-				}
-				break
-			}
-			default: {
-				const geometry = this.editor.getShapeGeometry(shape)
-				const outline =
-					geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices
-				const lines = getLines(shape.props, strokeWidth)
-
-				switch (props.dash) {
-					case 'draw':
-						svgElm = DrawStylePolygonSvg({
-							id,
-							fill: props.fill,
-							color: props.color,
-							strokeWidth,
-							outline,
-							lines,
-							theme,
-						})
-						break
-
-					case 'solid':
-						svgElm = SolidStylePolygonSvg({
-							fill: props.fill,
-							color: props.color,
-							strokeWidth,
-							outline,
-							lines,
-							theme,
-						})
-						break
-
-					default:
-						svgElm = DashStylePolygonSvg({
-							dash: props.dash,
-							fill: props.fill,
-							color: props.color,
-							strokeWidth,
-							outline,
-							lines,
-							theme,
-						})
-						break
-				}
-				break
-			}
-		}
+		const { props } = shape
+		ctx.addExportDef(getFillDefForExport(shape.props.fill))
 
+		let textEl
 		if (props.text) {
-			const bounds = this.editor.getShapeGeometry(shape).bounds
-
 			ctx.addExportDef(getFontDefForExport(shape.props.font))
 
-			const rootTextElm = getTextLabelSvgElement({
-				editor: this.editor,
-				shape,
-				font: DefaultFontFamilies[shape.props.font],
-				bounds,
-			})
-
-			const textElm = rootTextElm.cloneNode(true) as SVGTextElement
-			textElm.setAttribute('fill', theme[shape.props.labelColor].solid)
-			textElm.setAttribute('stroke', 'none')
-
-			const textBgEl = rootTextElm.cloneNode(true) as SVGTextElement
-			textBgEl.setAttribute('stroke-width', '2')
-			textBgEl.setAttribute('fill', theme.background)
-			textBgEl.setAttribute('stroke', theme.background)
-
-			const groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-			groupEl.append(textBgEl)
-			groupEl.append(textElm)
-
-			if (svgElm.nodeName === 'g') {
-				svgElm.appendChild(groupEl)
-				return svgElm
-			} else {
-				const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-				g.appendChild(svgElm)
-				g.appendChild(groupEl)
-				return g
-			}
+			const bounds = this.editor.getShapeGeometry(shape).bounds
+			textEl = (
+				<SvgTextLabel
+					fontSize={LABEL_FONT_SIZES[props.size]}
+					font={props.font}
+					align={props.align}
+					verticalAlign={props.verticalAlign}
+					text={props.text}
+					labelColor={props.labelColor}
+					bounds={bounds}
+				/>
+			)
 		}
 
-		return svgElm
+		return (
+			<>
+				<GeoShapeBody shape={shape} />
+				{textEl}
+			</>
+		)
 	}
 
 	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
@@ -1110,80 +767,3 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		h: size.h + LABEL_PADDING * 2,
 	}
 }
-
-function getLines(props: TLGeoShape['props'], sw: number) {
-	switch (props.geo) {
-		case 'x-box': {
-			return getXBoxLines(props.w, props.h, sw, props.dash)
-		}
-		case 'check-box': {
-			return getCheckBoxLines(props.w, props.h)
-		}
-		default: {
-			return undefined
-		}
-	}
-}
-
-function getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle) {
-	const inset = dash === 'draw' ? 0.62 : 0
-
-	if (dash === 'dashed') {
-		return [
-			[new Vec(0, 0), new Vec(w / 2, h / 2)],
-			[new Vec(w, h), new Vec(w / 2, h / 2)],
-			[new Vec(0, h), new Vec(w / 2, h / 2)],
-			[new Vec(w, 0), new Vec(w / 2, h / 2)],
-		]
-	}
-
-	const clampX = (x: number) => Math.max(0, Math.min(w, x))
-	const clampY = (y: number) => Math.max(0, Math.min(h, y))
-
-	return [
-		[
-			new Vec(clampX(sw * inset), clampY(sw * inset)),
-			new Vec(clampX(w - sw * inset), clampY(h - sw * inset)),
-		],
-		[
-			new Vec(clampX(sw * inset), clampY(h - sw * inset)),
-			new Vec(clampX(w - sw * inset), clampY(sw * inset)),
-		],
-	]
-}
-
-function getCheckBoxLines(w: number, h: number) {
-	const size = Math.min(w, h) * 0.82
-	const ox = (w - size) / 2
-	const oy = (h - size) / 2
-
-	const clampX = (x: number) => Math.max(0, Math.min(w, x))
-	const clampY = (y: number) => Math.max(0, Math.min(h, y))
-
-	return [
-		[
-			new Vec(clampX(ox + size * 0.25), clampY(oy + size * 0.52)),
-			new Vec(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
-		],
-		[
-			new Vec(clampX(ox + size * 0.45), clampY(oy + size * 0.82)),
-			new Vec(clampX(ox + size * 0.82), clampY(oy + size * 0.22)),
-		],
-	]
-}
-
-/**
- * Get the centroid of a regular polygon.
- * @param points - The points that make up the polygon.
- * @internal
- */
-export function getCentroidOfRegularPolygon(points: VecLike[]) {
-	const len = points.length
-	let x = 0
-	let y = 0
-	for (let i = 0; i < len; i++) {
-		x += points[i].x
-		y += points[i].y
-	}
-	return new Vec(x / len, y / len)
-}

commit d76d53db95146c24d35caeca41c2f6d348dbcc06
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Wed Mar 27 09:33:48 2024 +0000

    textfields [1 of 3]: add text into speech bubble; also add rich text example (#3050)
    
    This is the first of three textfield changes. This starts with making
    the speech bubble actually have text. Also, it creates a TipTap example
    and how that would be wired up.
    
    üéµ this is dangerous, I walk through textfields so watch your head rock üéµ
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Release Notes
    
    - Refactor textfields be composable/swappable.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 29c5c11be..9a703574a 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -31,6 +31,7 @@ import { TextLabel } from '../shared/TextLabel'
 import {
 	FONT_FAMILIES,
 	LABEL_FONT_SIZES,
+	LABEL_PADDING,
 	STROKE_SIZES,
 	TEXT_PROPS,
 } from '../shared/default-shape-constants'
@@ -46,7 +47,6 @@ import { GeoShapeBody } from './components/GeoShapeBody'
 import { getOvalIndicatorPath } from './components/SolidStyleOval'
 import { getLines } from './getLines'
 
-const LABEL_PADDING = 16
 const MIN_SIZE_WITH_LABEL = 17 * 3
 
 /** @public */
@@ -396,8 +396,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						id={id}
 						type={type}
 						font={font}
+						fontSize={LABEL_FONT_SIZES[size]}
+						lineHeight={TEXT_PROPS.lineHeight}
 						fill={fill}
-						size={size}
 						align={align}
 						verticalAlign={verticalAlign}
 						text={text}

commit 41b5fffa2ef17ff852c1efc227a5ad5c37dc5c7a
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Thu Mar 28 10:49:29 2024 +0100

    Decrease the number of elements by 3. (#3283)
    
    When geo shape has no url or text we don't show the html container
    containing the label and link. This results in 3 fewer dom nodes per
    empty geo shape (going from 7 to 4). Similarly for an arrow without the
    text label we go from 13 to 10.
    
    First paint experience with 2000 empty rectangle shapes
    Before: 1.5-1.6s
    After: 1.2-1.3s
    
    2000 rectangles shapes with text is similar between the two, around
    3.6s.
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [x] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know
    
    ### Release Notes
    
    - Reduce the number of rendered dom nodes for geo shapes and arrows
    without text.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 9a703574a..a02786fde 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -383,33 +383,42 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const { id, type, props } = shape
 		const { labelColor, fill, font, align, verticalAlign, size, text } = props
 
+		const isEditing = this.editor.getEditingShapeId() === id
+		const showHtmlContainer = isEditing || shape.props.url || shape.props.text
+
 		return (
 			<>
 				<SVGContainer id={id}>
 					<GeoShapeBody shape={shape} />
 				</SVGContainer>
-				<HTMLContainer
-					id={shape.id}
-					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h + props.growY }}
-				>
-					<TextLabel
-						id={id}
-						type={type}
-						font={font}
-						fontSize={LABEL_FONT_SIZES[size]}
-						lineHeight={TEXT_PROPS.lineHeight}
-						fill={fill}
-						align={align}
-						verticalAlign={verticalAlign}
-						text={text}
-						labelColor={labelColor}
-						wrap
-						bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
-					/>
-					{shape.props.url && (
-						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
-					)}
-				</HTMLContainer>
+				{showHtmlContainer && (
+					<HTMLContainer
+						id={shape.id}
+						style={{
+							overflow: 'hidden',
+							width: shape.props.w,
+							height: shape.props.h + props.growY,
+						}}
+					>
+						<TextLabel
+							id={id}
+							type={type}
+							font={font}
+							fontSize={LABEL_FONT_SIZES[size]}
+							lineHeight={TEXT_PROPS.lineHeight}
+							fill={fill}
+							align={align}
+							verticalAlign={verticalAlign}
+							text={text}
+							labelColor={labelColor}
+							wrap
+							bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
+						/>
+						{shape.props.url && (
+							<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
+						)}
+					</HTMLContainer>
+				)}
 			</>
 		)
 	}

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime ƒåuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index a02786fde..b249c3531 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1,3 +1,4 @@
+/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
 	Editor,
@@ -22,10 +23,12 @@ import {
 	exhaustiveSwitchError,
 	geoShapeMigrations,
 	geoShapeProps,
+	getDefaultColorTheme,
 	getPolygonVertices,
 } from '@tldraw/editor'
 
 import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { useDefaultColorTheme } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { TextLabel } from '../shared/TextLabel'
 import {
@@ -292,8 +295,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 
 		const labelSize = getLabelSize(this.editor, shape)
-		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(32, Math.max(1, w - 8))))
-		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(32, Math.max(1, w - 8)))) // not sure if bug
+		const minWidth = Math.min(100, w / 2)
+		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(minWidth, Math.max(1, w - 8))))
+		const minHeight = Math.min(
+			LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
+			h / 2
+		)
+		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(minHeight, Math.max(1, w - 8)))) // not sure if bug
 
 		const lines = getLines(shape.props, strokeWidth)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
@@ -381,10 +389,11 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 	component(shape: TLGeoShape) {
 		const { id, type, props } = shape
-		const { labelColor, fill, font, align, verticalAlign, size, text } = props
-
-		const isEditing = this.editor.getEditingShapeId() === id
-		const showHtmlContainer = isEditing || shape.props.url || shape.props.text
+		const { fill, font, align, verticalAlign, size, text } = props
+		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
+		const theme = useDefaultColorTheme()
+		const isEditingAnything = this.editor.getEditingShapeId() !== null
+		const showHtmlContainer = isEditingAnything || shape.props.text
 
 		return (
 			<>
@@ -410,15 +419,16 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							align={align}
 							verticalAlign={verticalAlign}
 							text={text}
-							labelColor={labelColor}
+							isSelected={isSelected}
+							labelColor={theme[props.labelColor].solid}
+							disableTab
 							wrap
-							bounds={props.geo === 'cloud' ? this.getGeometry(shape).bounds : undefined}
 						/>
-						{shape.props.url && (
-							<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
-						)}
 					</HTMLContainer>
 				)}
+				{shape.props.url && (
+					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
+				)}
 			</>
 		)
 	}
@@ -478,6 +488,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		let textEl
 		if (props.text) {
 			ctx.addExportDef(getFontDefForExport(shape.props.font))
+			const theme = getDefaultColorTheme(ctx)
 
 			const bounds = this.editor.getShapeGeometry(shape).bounds
 			textEl = (
@@ -487,7 +498,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					align={props.align}
 					verticalAlign={props.verticalAlign}
 					text={props.text}
-					labelColor={props.labelColor}
+					labelColor={theme[props.labelColor].solid}
 					bounds={bounds}
 				/>
 			)
@@ -761,7 +772,7 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
 		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		minWidth: minSize.w + 'px',
+		minWidth: minSize.w,
 		maxWidth: Math.max(
 			// Guard because a DOM nodes can't be less 0
 			0,

commit 34ad856873d1749698b75fd1b45ba7906fd92f40
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Wed Apr 17 12:11:08 2024 +0100

    textfields: nix disableTab option; make TextShapes have custom Tab behavior as intended (#3506)
    
    We shouldn't be making this something you have to negate everytime you
    use `useEditableText`. The TextShape can just have its custom behavior
    since that's the intended usecase. (although I think that Tab there
    doesn't do much anyway, but whatevs)
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [ ] `improvement` ‚Äî Improving existing features
    - [x] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index b249c3531..e9e884d0e 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -421,7 +421,6 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							text={text}
 							isSelected={isSelected}
 							labelColor={theme[props.labelColor].solid}
-							disableTab
 							wrap
 						/>
 					</HTMLContainer>

commit f754bebc322119f5a7abb7fd59c7f2356e8c3b93
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Wed Apr 17 15:01:12 2024 +0100

    geo: fix double unique id on DOM (#3514)
    
    Minor thing, but there's two nodes with the same ID. I got rid of the
    one on the HTMLContainer, either one seems fine to remove though
    ¬Ø\\_(„ÉÑ)_/¬Ø
    
    <img width="546" alt="Screenshot 2024-04-17 at 14 53 32"
    src="https://github.com/tldraw/tldraw/assets/469604/5c4acdef-842c-4c4a-b9fd-504e23837efe">
    
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [x] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [ ] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index e9e884d0e..420811938 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -402,7 +402,6 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				</SVGContainer>
 				{showHtmlContainer && (
 					<HTMLContainer
-						id={shape.id}
 						style={{
 							overflow: 'hidden',
 							width: shape.props.w,

commit ef44d71ee2a83bb3d6d61cac7717c4254941019d
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri May 24 14:04:28 2024 +0100

    Add heart geo shape (#3787)
    
    This PR adds a heart geo shape. ‚ù§Ô∏è
    
    It also:
    - adds `toSvgPathData` to geometry2d
    - uses geometry2d in places where previously we recalculated things like
    perimeter of ellipse
    - flattens geo shape util components
    
    - [x] Calculate the path length for the DashStyleHeart
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Release Notes
    
    - Adds a heart shape to the geo shape set.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 420811938..746dd77e1 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -43,11 +43,16 @@ import {
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
-import { getRoundedInkyPolygonPath, getRoundedPolygonPoints } from '../shared/polygon-helpers'
-import { cloudOutline, cloudSvgPath } from './cloudOutline'
-import { getEllipseIndicatorPath } from './components/DrawStyleEllipse'
 import { GeoShapeBody } from './components/GeoShapeBody'
-import { getOvalIndicatorPath } from './components/SolidStyleOval'
+import {
+	cloudOutline,
+	getCloudPath,
+	getEllipseDrawIndicatorPath,
+	getHeartParts,
+	getHeartPath,
+	getRoundedInkyPolygonPath,
+	getRoundedPolygonPoints,
+} from './geo-shape-helpers'
 import { getLines } from './getLines'
 
 const MIN_SIZE_WITH_LABEL = 17 * 3
@@ -292,6 +297,23 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				})
 				break
 			}
+			case 'heart': {
+				// kind of expensive (creating the primitives to create a different primitive) but hearts are rare and beautiful things
+				const parts = getHeartParts(w, h)
+				const points = parts.reduce<Vec[]>((acc, part) => {
+					acc.push(...part.vertices)
+					return acc
+				}, [])
+
+				body = new Polygon2d({
+					points,
+					isFilled,
+				})
+				break
+			}
+			default: {
+				exhaustiveSwitchError(shape.props.geo)
+			}
 		}
 
 		const labelSize = getLabelSize(this.editor, shape)
@@ -359,6 +381,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				return { outline: outline, points: [...outline.getVertices(), geometry.bounds.center] }
 			case 'cloud':
 			case 'ellipse':
+			case 'heart':
 			case 'oval':
 				// blobby shapes only have a snap point in their center
 				return { outline: outline, points: [geometry.bounds.center] }
@@ -438,19 +461,24 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		const strokeWidth = STROKE_SIZES[size]
 
+		const geometry = this.editor.getShapeGeometry(shape)
+
 		switch (props.geo) {
 			case 'ellipse': {
 				if (props.dash === 'draw') {
-					return <path d={getEllipseIndicatorPath(id, w, h, strokeWidth)} />
+					return <path d={getEllipseDrawIndicatorPath(id, w, h, strokeWidth)} />
 				}
 
-				return <ellipse cx={w / 2} cy={h / 2} rx={w / 2} ry={h / 2} />
+				return <path d={geometry.getSvgPathData(true)} />
+			}
+			case 'heart': {
+				return <path d={getHeartPath(w, h)} />
 			}
 			case 'oval': {
-				return <path d={getOvalIndicatorPath(w, h)} />
+				return <path d={geometry.getSvgPathData(true)} />
 			}
 			case 'cloud': {
-				return <path d={cloudSvgPath(w, h, id, size)} />
+				return <path d={getCloudPath(w, h, id, size)} />
 			}
 
 			default: {

commit ac149c1014fb5f0539d7c55f0f10ce2a05a23f74
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jun 16 19:58:13 2024 +0300

    Dynamic size mode + fill fill (#3835)
    
    This PR adds a user preference for "dynamic size mode" where the scale
    of shapes (text size, stroke width) is relative to the current zoom
    level. This means that the stroke width in screen pixels (or text size
    in screen pixels) is identical regardless of zoom level.
    
    ![Kapture 2024-05-27 at 05 23
    21](https://github.com/tldraw/tldraw/assets/23072548/f247ecce-bfcd-4f85-b7a5-d7677b38e4d8)
    
    - [x] Draw shape
    - [x] Text shape
    - [x] Highlighter shape
    - [x] Geo shape
    - [x] Arrow shape
    - [x] Note shape
    - [x] Line shape
    
    Embed shape?
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Test Plan
    
    1. Use the tools.
    2. Change zoom
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - Adds a dynamic size user preferences.
    - Removes double click to reset scale on text shapes.
    - Removes double click to reset autosize on text shapes.
    
    ---------
    
    Co-authored-by: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 746dd77e1..f95604491 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -1,6 +1,7 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
+	Box,
 	Editor,
 	Ellipse2d,
 	Geometry2d,
@@ -28,7 +29,6 @@ import {
 } from '@tldraw/editor'
 
 import { HyperlinkButton } from '../shared/HyperlinkButton'
-import { useDefaultColorTheme } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { TextLabel } from '../shared/TextLabel'
 import {
@@ -43,6 +43,7 @@ import {
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
+import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { GeoShapeBody } from './components/GeoShapeBody'
 import {
 	cloudOutline,
@@ -81,6 +82,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			verticalAlign: 'middle',
 			growY: 0,
 			url: '',
+			scale: 1,
 		}
 	}
 
@@ -90,7 +92,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const cx = w / 2
 		const cy = h / 2
 
-		const strokeWidth = STROKE_SIZES[shape.props.size]
+		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 		const isFilled = shape.props.fill !== 'none' // || shape.props.text.trim().length > 0
 
 		let body: Geometry2d
@@ -318,12 +320,16 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		const labelSize = getLabelSize(this.editor, shape)
 		const minWidth = Math.min(100, w / 2)
-		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(minWidth, Math.max(1, w - 8))))
 		const minHeight = Math.min(
-			LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
+			LABEL_FONT_SIZES[shape.props.size] * shape.props.scale * TEXT_PROPS.lineHeight +
+				LABEL_PADDING * 2,
 			h / 2
 		)
-		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(minHeight, Math.max(1, w - 8)))) // not sure if bug
+
+		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(minWidth, Math.max(1, w - 8))))
+		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(minHeight, Math.max(1, w - 8))))
+
+		// not sure if bug
 
 		const lines = getLines(shape.props, strokeWidth)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
@@ -421,7 +427,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		return (
 			<>
 				<SVGContainer id={id}>
-					<GeoShapeBody shape={shape} />
+					<GeoShapeBody shape={shape} shouldScale={true} />
 				</SVGContainer>
 				{showHtmlContainer && (
 					<HTMLContainer
@@ -435,8 +441,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							id={id}
 							type={type}
 							font={font}
-							fontSize={LABEL_FONT_SIZES[size]}
+							fontSize={LABEL_FONT_SIZES[size] * shape.props.scale}
 							lineHeight={TEXT_PROPS.lineHeight}
+							padding={16 * shape.props.scale}
 							fill={fill}
 							align={align}
 							verticalAlign={verticalAlign}
@@ -488,7 +495,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				let path: string
 
 				if (props.dash === 'draw') {
-					const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
+					const polygonPoints = getRoundedPolygonPoints(
+						id,
+						outline,
+						0,
+						strokeWidth * 2 * shape.props.scale,
+						1
+					)
 					path = getRoundedInkyPolygonPath(polygonPoints)
 				} else {
 					path = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
@@ -508,15 +521,24 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
-		const { props } = shape
-		ctx.addExportDef(getFillDefForExport(shape.props.fill))
+		// We need to scale the shape to 1x for export
+		const newShape = {
+			...shape,
+			props: {
+				...shape.props,
+				w: shape.props.w / shape.props.scale,
+				h: shape.props.h / shape.props.scale,
+			},
+		}
+		const props = newShape.props
+		ctx.addExportDef(getFillDefForExport(props.fill))
 
 		let textEl
 		if (props.text) {
-			ctx.addExportDef(getFontDefForExport(shape.props.font))
+			ctx.addExportDef(getFontDefForExport(props.font))
 			const theme = getDefaultColorTheme(ctx)
 
-			const bounds = this.editor.getShapeGeometry(shape).bounds
+			const bounds = new Box(0, 0, props.w, props.h + props.growY)
 			textEl = (
 				<SvgTextLabel
 					fontSize={LABEL_FONT_SIZES[props.size]}
@@ -526,13 +548,14 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 					text={props.text}
 					labelColor={theme[props.labelColor].solid}
 					bounds={bounds}
+					padding={16}
 				/>
 			)
 		}
 
 		return (
 			<>
-				<GeoShapeBody shape={shape} />
+				<GeoShapeBody shouldScale={false} shape={newShape} />
 				{textEl}
 			</>
 		)
@@ -782,8 +805,8 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 	const minSize = editor.textMeasure.measureText('w', {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
-		fontSize: LABEL_FONT_SIZES[shape.props.size],
-		maxWidth: 100,
+		fontSize: LABEL_FONT_SIZES[shape.props.size] * shape.props.scale,
+		maxWidth: 100, // ?
 	})
 
 	// TODO: Can I get these from somewhere?
@@ -797,7 +820,7 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 	const size = editor.textMeasure.measureText(text, {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[shape.props.font],
-		fontSize: LABEL_FONT_SIZES[shape.props.size],
+		fontSize: LABEL_FONT_SIZES[shape.props.size] * shape.props.scale,
 		minWidth: minSize.w,
 		maxWidth: Math.max(
 			// Guard because a DOM nodes can't be less 0

commit a7fac3bcc4cd920b235bb776f56fa87a7af6d4ad
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 11 12:14:19 2024 +0100

    Use shape scale for geo shape min size (#4140)
    
    This PR fixes a bug where a shape created with dynamic size would
    preserve the origin
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Test plan
    
    1. Turn on dynamic size
    2. Zoom in
    3. Create a text shape
    4. Give a label
    5. Try to resize the shape to be narrow
    
    ### Release notes
    
    - Fixed a bug with the minimum size on dynamically scaled text shapes

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index f95604491..3c70e078d 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -92,7 +92,6 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const cx = w / 2
 		const cy = h / 2
 
-		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 		const isFilled = shape.props.fill !== 'none' // || shape.props.text.trim().length > 0
 
 		let body: Geometry2d
@@ -318,20 +317,28 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 		}
 
-		const labelSize = getLabelSize(this.editor, shape)
-		const minWidth = Math.min(100, w / 2)
-		const minHeight = Math.min(
-			LABEL_FONT_SIZES[shape.props.size] * shape.props.scale * TEXT_PROPS.lineHeight +
-				LABEL_PADDING * 2,
-			h / 2
+		const unscaledlabelSize = getUnscaledLabelSize(this.editor, shape)
+		// unscaled w and h
+		const unscaledW = w / shape.props.scale
+		const unscaledH = h / shape.props.scale
+		const unscaledminWidth = Math.min(100, unscaledW / 2)
+		const unscaledMinHeight = Math.min(
+			LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
+			unscaledH / 2
 		)
 
-		const labelWidth = Math.min(w, Math.max(labelSize.w, Math.min(minWidth, Math.max(1, w - 8))))
-		const labelHeight = Math.min(h, Math.max(labelSize.h, Math.min(minHeight, Math.max(1, w - 8))))
+		const unscaledLabelWidth = Math.min(
+			unscaledW,
+			Math.max(unscaledlabelSize.w, Math.min(unscaledminWidth, Math.max(1, unscaledW - 8)))
+		)
+		const unscaledLabelHeight = Math.min(
+			unscaledH,
+			Math.max(unscaledlabelSize.h, Math.min(unscaledMinHeight, Math.max(1, unscaledH - 8)))
+		)
 
 		// not sure if bug
 
-		const lines = getLines(shape.props, strokeWidth)
+		const lines = getLines(shape.props, STROKE_SIZES[shape.props.size] * shape.props.scale)
 		const edges = lines ? lines.map((line) => new Polyline2d({ points: line })) : []
 
 		// todo: use centroid for label position
@@ -344,16 +351,16 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						shape.props.align === 'start'
 							? 0
 							: shape.props.align === 'end'
-								? w - labelWidth
-								: (w - labelWidth) / 2,
+								? (unscaledW - unscaledLabelWidth) * shape.props.scale
+								: ((unscaledW - unscaledLabelWidth) / 2) * shape.props.scale,
 					y:
 						shape.props.verticalAlign === 'start'
 							? 0
 							: shape.props.verticalAlign === 'end'
-								? h - labelHeight
-								: (h - labelHeight) / 2,
-					width: labelWidth,
-					height: labelHeight,
+								? (unscaledH - unscaledLabelHeight) * shape.props.scale
+								: ((unscaledH - unscaledLabelHeight) / 2) * shape.props.scale,
+					width: unscaledLabelWidth * shape.props.scale,
+					height: unscaledLabelHeight * shape.props.scale,
 					isFilled: true,
 					isLabel: true,
 				}),
@@ -443,7 +450,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							font={font}
 							fontSize={LABEL_FONT_SIZES[size] * shape.props.scale}
 							lineHeight={TEXT_PROPS.lineHeight}
-							padding={16 * shape.props.scale}
+							padding={LABEL_PADDING * shape.props.scale}
 							fill={fill}
 							align={align}
 							verticalAlign={verticalAlign}
@@ -569,49 +576,52 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		shape,
 		{ handle, newPoint, scaleX, scaleY, initialShape }
 	) => {
+		const unscaledInitialW = initialShape.props.w / initialShape.props.scale
+		const unscaledInitialH = initialShape.props.h / initialShape.props.scale
+		const unscaledGrowY = initialShape.props.growY / initialShape.props.scale
 		// use the w/h from props here instead of the initialBounds here,
 		// since cloud shapes calculated bounds can differ from the props w/h.
-		let w = initialShape.props.w * scaleX
-		let h = (initialShape.props.h + initialShape.props.growY) * scaleY
+		let unscaledW = unscaledInitialW * scaleX
+		let unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY
 		let overShrinkX = 0
 		let overShrinkY = 0
 
-		if (shape.props.text.trim()) {
-			let newW = Math.max(Math.abs(w), MIN_SIZE_WITH_LABEL)
-			let newH = Math.max(Math.abs(h), MIN_SIZE_WITH_LABEL)
+		const min = MIN_SIZE_WITH_LABEL
 
-			if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {
-				newW = MIN_SIZE_WITH_LABEL
-			}
+		if (shape.props.text.trim()) {
+			let newW = Math.max(Math.abs(unscaledW), min)
+			let newH = Math.max(Math.abs(unscaledH), min)
 
-			if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {
-				newH = MIN_SIZE_WITH_LABEL
-			}
+			if (newW < min && newH === min) newW = min
+			if (newW === min && newH < min) newH = min
 
-			const labelSize = getLabelSize(this.editor, {
+			const unscaledLabelSize = getUnscaledLabelSize(this.editor, {
 				...shape,
 				props: {
 					...shape.props,
-					w: newW,
-					h: newH,
+					w: newW * shape.props.scale,
+					h: newH * shape.props.scale,
 				},
 			})
 
-			const nextW = Math.max(Math.abs(w), labelSize.w) * Math.sign(w)
-			const nextH = Math.max(Math.abs(h), labelSize.h) * Math.sign(h)
-			overShrinkX = Math.abs(nextW) - Math.abs(w)
-			overShrinkY = Math.abs(nextH) - Math.abs(h)
+			const nextW = Math.max(Math.abs(unscaledW), unscaledLabelSize.w) * Math.sign(unscaledW)
+			const nextH = Math.max(Math.abs(unscaledH), unscaledLabelSize.h) * Math.sign(unscaledH)
+			overShrinkX = Math.abs(nextW) - Math.abs(unscaledW)
+			overShrinkY = Math.abs(nextH) - Math.abs(unscaledH)
 
-			w = nextW
-			h = nextH
+			unscaledW = nextW
+			unscaledH = nextH
 		}
 
+		const scaledW = unscaledW * shape.props.scale
+		const scaledH = unscaledH * shape.props.scale
+
 		const offset = new Vec(0, 0)
 
 		// x offsets
 
 		if (scaleX < 0) {
-			offset.x += w
+			offset.x += scaledW
 		}
 
 		if (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {
@@ -621,7 +631,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		// y offsets
 
 		if (scaleY < 0) {
-			offset.y += h
+			offset.y += scaledH
 		}
 
 		if (handle === 'top' || handle === 'top_left' || handle === 'top_right') {
@@ -634,8 +644,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			x,
 			y,
 			props: {
-				w: Math.max(Math.abs(w), 1),
-				h: Math.max(Math.abs(h), 1),
+				w: Math.max(Math.abs(scaledW), 1),
+				h: Math.max(Math.abs(scaledH), 1),
 				growY: 0,
 			},
 		}
@@ -658,13 +668,13 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 		}
 
-		const prevHeight = shape.props.h
-		const nextHeight = getLabelSize(this.editor, shape).h
+		const unscaledPrevHeight = shape.props.h / shape.props.scale
+		const unscaledNextHeight = getUnscaledLabelSize(this.editor, shape).h
 
 		let growY: number | null = null
 
-		if (nextHeight > prevHeight) {
-			growY = nextHeight - prevHeight
+		if (unscaledNextHeight > unscaledPrevHeight) {
+			growY = unscaledNextHeight - unscaledPrevHeight
 		} else {
 			if (shape.props.growY) {
 				growY = 0
@@ -676,7 +686,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				...shape,
 				props: {
 					...shape.props,
-					growY,
+					// scale the growY
+					growY: growY * shape.props.scale,
 				},
 			}
 		}
@@ -686,6 +697,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const prevText = prev.props.text
 		const nextText = next.props.text
 
+		// No change to text, font, or size, no need to update update
 		if (
 			prevText === nextText &&
 			prev.props.font === next.props.font &&
@@ -694,6 +706,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			return
 		}
 
+		// If we got rid of the text, cancel out any growY from the prev text
 		if (prevText && !nextText) {
 			return {
 				...next,
@@ -704,23 +717,27 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			}
 		}
 
-		const prevWidth = prev.props.w
-		const prevHeight = prev.props.h
-		const nextSize = getLabelSize(this.editor, next)
-		const nextWidth = nextSize.w
-		const nextHeight = nextSize.h
+		// Get the prev width and height in unscaled values
+		const unscaledPrevWidth = prev.props.w / prev.props.scale
+		const unscaledPrevHeight = prev.props.h / prev.props.scale
+		const unscaledPrevGrowY = prev.props.growY / prev.props.scale
+
+		// Get the next width and height in unscaled values
+		const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next)
 
 		// When entering the first character in a label (not pasting in multiple characters...)
 		if (!prevText && nextText && nextText.length === 1) {
-			let w = Math.max(prevWidth, nextWidth)
-			let h = Math.max(prevHeight, nextHeight)
+			let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w)
+			let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h)
+
+			const min = MIN_SIZE_WITH_LABEL
 
 			// If both the width and height were less than the minimum size, make the shape square
-			if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {
-				w = Math.max(w, MIN_SIZE_WITH_LABEL)
-				h = Math.max(h, MIN_SIZE_WITH_LABEL)
-				w = Math.max(w, h)
-				h = Math.max(w, h)
+			if (unscaledPrevWidth < min && unscaledPrevHeight < min) {
+				unscaledW = Math.max(unscaledW, min)
+				unscaledH = Math.max(unscaledH, min)
+				unscaledW = Math.max(unscaledW, unscaledH)
+				unscaledH = Math.max(unscaledW, unscaledH)
 			}
 
 			// Don't set a growY‚Äîat least, not until we've implemented a growX property
@@ -728,8 +745,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				...next,
 				props: {
 					...next.props,
-					w,
-					h,
+					// Scale the results
+					w: unscaledW * next.props.scale,
+					h: unscaledH * next.props.scale,
 					growY: 0,
 				},
 			}
@@ -737,34 +755,39 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		let growY: number | null = null
 
-		if (nextHeight > prevHeight) {
-			growY = nextHeight - prevHeight
+		if (unscaledNextLabelSize.h > unscaledPrevHeight) {
+			growY = unscaledNextLabelSize.h - unscaledPrevHeight
 		} else {
-			if (prev.props.growY) {
+			if (unscaledPrevGrowY) {
 				growY = 0
 			}
 		}
 
 		if (growY !== null) {
+			const unscaledNextWidth = next.props.w / next.props.scale
 			return {
 				...next,
 				props: {
 					...next.props,
-					growY,
-					w: Math.max(next.props.w, nextWidth),
+					// Scale the results
+					growY: growY * next.props.scale,
+					w: Math.max(unscaledNextWidth, unscaledNextLabelSize.w) * next.props.scale,
 				},
 			}
 		}
 
-		if (nextWidth > prev.props.w) {
+		if (unscaledNextLabelSize.w > unscaledPrevWidth) {
 			return {
 				...next,
 				props: {
 					...next.props,
-					w: nextWidth,
+					// Scale the results
+					w: unscaledNextLabelSize.w * next.props.scale,
 				},
 			}
 		}
+
+		// otherwise, no update needed
 	}
 
 	override onDoubleClick = (shape: TLGeoShape) => {
@@ -795,8 +818,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 }
 
-function getLabelSize(editor: Editor, shape: TLGeoShape) {
-	const text = shape.props.text
+function getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {
+	const { text, font, size, w } = shape.props
 
 	if (!text) {
 		return { w: 0, h: 0 }
@@ -804,8 +827,8 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 
 	const minSize = editor.textMeasure.measureText('w', {
 		...TEXT_PROPS,
-		fontFamily: FONT_FAMILIES[shape.props.font],
-		fontSize: LABEL_FONT_SIZES[shape.props.size] * shape.props.scale,
+		fontFamily: FONT_FAMILIES[font],
+		fontSize: LABEL_FONT_SIZES[size],
 		maxWidth: 100, // ?
 	})
 
@@ -817,23 +840,23 @@ function getLabelSize(editor: Editor, shape: TLGeoShape) {
 		xl: 10,
 	}
 
-	const size = editor.textMeasure.measureText(text, {
+	const textSize = editor.textMeasure.measureText(text, {
 		...TEXT_PROPS,
-		fontFamily: FONT_FAMILIES[shape.props.font],
-		fontSize: LABEL_FONT_SIZES[shape.props.size] * shape.props.scale,
+		fontFamily: FONT_FAMILIES[font],
+		fontSize: LABEL_FONT_SIZES[size],
 		minWidth: minSize.w,
 		maxWidth: Math.max(
 			// Guard because a DOM nodes can't be less 0
 			0,
 			// A 'w' width that we're setting as the min-width
-			Math.ceil(minSize.w + sizes[shape.props.size]),
+			Math.ceil(minSize.w + sizes[size]),
 			// The actual text size
-			Math.ceil(shape.props.w - LABEL_PADDING * 2)
+			Math.ceil(w / shape.props.scale - LABEL_PADDING * 2)
 		),
 	})
 
 	return {
-		w: size.w + LABEL_PADDING * 2,
-		h: size.h + LABEL_PADDING * 2,
+		w: textSize.w + LABEL_PADDING * 2,
+		h: textSize.h + LABEL_PADDING * 2,
 	}
 }

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 3c70e078d..5f22157f8 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -17,8 +17,7 @@ import {
 	Stadium2d,
 	SvgExportContext,
 	TLGeoShape,
-	TLOnEditEndHandler,
-	TLOnResizeHandler,
+	TLResizeInfo,
 	TLShapeUtilCanvasSvgDef,
 	Vec,
 	exhaustiveSwitchError,
@@ -64,7 +63,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	static override props = geoShapeProps
 	static override migrations = geoShapeMigrations
 
-	override canEdit = () => true
+	override canEdit() {
+		return true
+	}
 
 	override getDefaultProps(): TLGeoShape['props'] {
 		return {
@@ -403,7 +404,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
-	override onEditEnd: TLOnEditEndHandler<TLGeoShape> = (shape) => {
+	override onEditEnd(shape: TLGeoShape) {
 		const {
 			id,
 			type,
@@ -572,10 +573,10 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		return [getFillDefForCanvas()]
 	}
 
-	override onResize: TLOnResizeHandler<TLGeoShape> = (
-		shape,
-		{ handle, newPoint, scaleX, scaleY, initialShape }
-	) => {
+	override onResize(
+		shape: TLGeoShape,
+		{ handle, newPoint, scaleX, scaleY, initialShape }: TLResizeInfo<TLGeoShape>
+	) {
 		const unscaledInitialW = initialShape.props.w / initialShape.props.scale
 		const unscaledInitialH = initialShape.props.h / initialShape.props.scale
 		const unscaledGrowY = initialShape.props.growY / initialShape.props.scale
@@ -651,7 +652,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
-	override onBeforeCreate = (shape: TLGeoShape) => {
+	override onBeforeCreate(shape: TLGeoShape) {
 		if (!shape.props.text) {
 			if (shape.props.growY) {
 				// No text / some growY, set growY to 0
@@ -693,7 +694,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
-	override onBeforeUpdate = (prev: TLGeoShape, next: TLGeoShape) => {
+	override onBeforeUpdate(prev: TLGeoShape, next: TLGeoShape) {
 		const prevText = prev.props.text
 		const nextText = next.props.text
 
@@ -790,7 +791,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		// otherwise, no update needed
 	}
 
-	override onDoubleClick = (shape: TLGeoShape) => {
+	override onDoubleClick(shape: TLGeoShape) {
 		// Little easter egg: double-clicking a rectangle / checkbox while
 		// holding alt will toggle between check-box and rectangle
 		if (this.editor.inputs.altKey) {

commit 306c5c0204cfc3ed838b5f3378219a410d32b458
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Mon Jul 29 15:58:59 2024 +0100

    draw: fix dotted line rendering when zoomed out (#4261)
    
    Fixes https://github.com/tldraw/tldraw/issues/1995
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Draw: fix dotted line shape rendering when zoomed out greatly.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 5f22157f8..f9d807060 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -25,6 +25,7 @@ import {
 	geoShapeProps,
 	getDefaultColorTheme,
 	getPolygonVertices,
+	useValue,
 } from '@tldraw/editor'
 
 import { HyperlinkButton } from '../shared/HyperlinkButton'
@@ -427,15 +428,23 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	component(shape: TLGeoShape) {
 		const { id, type, props } = shape
 		const { fill, font, align, verticalAlign, size, text } = props
-		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 		const theme = useDefaultColorTheme()
-		const isEditingAnything = this.editor.getEditingShapeId() !== null
+		const { editor } = this
+		const isSelected = shape.id === editor.getOnlySelectedShapeId()
+		const isEditingAnything = editor.getEditingShapeId() !== null
 		const showHtmlContainer = isEditingAnything || shape.props.text
+		const isForceSolid = useValue(
+			'force solid',
+			() => {
+				return editor.getZoomLevel() < 0.2
+			},
+			[editor]
+		)
 
 		return (
 			<>
 				<SVGContainer id={id}>
-					<GeoShapeBody shape={shape} shouldScale={true} />
+					<GeoShapeBody shape={shape} shouldScale={true} forceSolid={isForceSolid} />
 				</SVGContainer>
 				{showHtmlContainer && (
 					<HTMLContainer
@@ -563,7 +572,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		return (
 			<>
-				<GeoShapeBody shouldScale={false} shape={newShape} />
+				<GeoShapeBody shouldScale={false} shape={newShape} forceSolid={false} />
 				{textEl}
 			</>
 		)

commit e0f36407d9b8297ed77e5507c52b88949cdfc745
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Thu Aug 1 16:47:01 2024 +0200

    [Feature, Example] Text search example and `getText` API (#4306)
    
    Motivated by #3495
    
    An example of how to add custom search via`‚åò+f` keyboard shortcuts. This
    also adds `getText` method to `ShapeUtil`, which allows the users to
    query the shapes for text.
    
    Down the line we could choose to add something like `getShapesWithText`
    to the editor and maybe even add some UI to dotcom. For now, let's just
    expose the API.
    
    
    https://github.com/user-attachments/assets/5631301c-a02a-4b66-8dbf-09571e67a46c
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Adds `getText` to the `ShapeUtil` api so that we can allow searching
    for text in a nicely extensible way.
    - Adds an example of how to add text search.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index f9d807060..b770814ee 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -405,6 +405,10 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 	}
 
+	override getText(shape: TLGeoShape) {
+		return shape.props.text
+	}
+
 	override onEditEnd(shape: TLGeoShape) {
 		const {
 			id,

commit 46fec0b2ee8230c3f943e8f26ffaacf45aa21f17
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Sat Aug 3 13:06:02 2024 +0100

    Interpolation: draw/highlight points, discrete props (#4241)
    
    Draw shapes and highlighter shape points now animate between states.
    
    ![2024-07-22 at 13 44 45 - Teal
    Sparrow](https://github.com/user-attachments/assets/92de6f2c-7b84-415e-b81b-94264a1341d9)
    
    There is some repetition of logic between the function that animates
    draw points and the one that animates lines. However, I felt that the
    structure of draw shapes and lines is different enough that generalising
    the function would add complexity and sacrifice readability, and didn't
    seem worth it just to remove a small amount of repetition. Very happy to
    change that should anyone disagree.
    
    Image shape crop property animates to the new position
    
    ![2024-07-22 at 15 39 30 - Purple
    Cattle](https://github.com/user-attachments/assets/fb108a48-6ed0-4f49-a232-fa806c78aa97)
    
    
    Discrete props (props that don't have continuous values to animate
    along) now change in the middle of the animation. It's likely that
    continuous animation will be happening at the same time, making the
    change in the middle of that movement helps smooth over the abruptness
    of that change.
    
    This is what it looks like if they change at the start:
    
    ![2024-07-18 at 13 11 32 - Amaranth
    Primate](https://github.com/user-attachments/assets/50570507-0b0a-4f61-a710-a180b7ddb00f)
    
    
    This is what it looks like when the props change halfway:
    
    ![2024-07-18 at 13 12 40 - Teal
    Gerbil](https://github.com/user-attachments/assets/48a28e62-901a-45db-8d30-4a5a18b5960f)
    
    
    The text usually changes at the halfway mark, but if there's no text to
    begin with, then any text in the end shape is streamed in:
    
    ![2024-07-18 at 15 18 34 - Tan
    Catshark](https://github.com/user-attachments/assets/ed59122c-7f52-4f57-94d5-9382ff8d62b1)
    
    Question: Do we want tests for this?
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Animate a shape between different states
    2. It should change its discrete props at the midway point of the
    animation, and animate smoothly for continuous values such as dimension
    or position.
    
    ### Release notes
    
    - Added getInterpolated props method for all shapes, including draw and
    highlighter.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index b770814ee..e2b3e6d2f 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -17,6 +17,7 @@ import {
 	Stadium2d,
 	SvgExportContext,
 	TLGeoShape,
+	TLGeoShapeProps,
 	TLResizeInfo,
 	TLShapeUtilCanvasSvgDef,
 	Vec,
@@ -25,6 +26,7 @@ import {
 	geoShapeProps,
 	getDefaultColorTheme,
 	getPolygonVertices,
+	lerp,
 	useValue,
 } from '@tldraw/editor'
 
@@ -830,6 +832,18 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		return
 	}
+	override getInterpolatedProps(
+		startShape: TLGeoShape,
+		endShape: TLGeoShape,
+		t: number
+	): TLGeoShapeProps {
+		return {
+			...(t > 0.5 ? endShape.props : startShape.props),
+			w: lerp(startShape.props.w, endShape.props.w, t),
+			h: lerp(startShape.props.h, endShape.props.h, t),
+			scale: lerp(startShape.props.scale, endShape.props.scale, t),
+		}
+	}
 }
 
 function getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {

commit 3f12d7cd220ca221206e1e350efe5d9fc1ab7d01
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Aug 13 14:25:33 2024 +0100

    Fix cloud rendering with dynamic scale (#4380)
    
    Before
    
    ![Kapture 2024-08-13 at 14 16
    54](https://github.com/user-attachments/assets/b800c6e0-d807-42cb-ae50-3c8e1238e322)
    
    
    After
    
    ![Kapture 2024-08-13 at 14 19
    05](https://github.com/user-attachments/assets/76bb94f0-27b4-41a7-bd85-bcb765da214e)
    
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    
    ### Release notes
    
    - Fixed cloud rendering in 'dynamic size' mode

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index e2b3e6d2f..1b556963e 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -103,7 +103,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		switch (shape.props.geo) {
 			case 'cloud': {
 				body = new Polygon2d({
-					points: cloudOutline(w, h, shape.id, shape.props.size),
+					points: cloudOutline(w, h, shape.id, shape.props.size, shape.props.scale),
 					isFilled,
 				})
 				break
@@ -508,7 +508,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 				return <path d={geometry.getSvgPathData(true)} />
 			}
 			case 'cloud': {
-				return <path d={getCloudPath(w, h, id, size)} />
+				return <path d={getCloudPath(w, h, id, size, shape.props.scale)} />
 			}
 
 			default: {

commit 870fc6728f6db63eca03ab1fcb82dceaff3bbcf5
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Aug 29 10:43:13 2024 +0100

    Fix rendering perf regression (#4433)
    
    Fixes
    https://discord.com/channels/859816885297741824/1277974515565203517/1277974515565203517
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Fixed a perf issue that caused shapes to rerender too often.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 1b556963e..4623e7500 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -436,7 +436,11 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const { fill, font, align, verticalAlign, size, text } = props
 		const theme = useDefaultColorTheme()
 		const { editor } = this
-		const isSelected = shape.id === editor.getOnlySelectedShapeId()
+		const isOnlySelected = useValue(
+			'isGeoOnlySelected',
+			() => shape.id === editor.getOnlySelectedShapeId(),
+			[]
+		)
 		const isEditingAnything = editor.getEditingShapeId() !== null
 		const showHtmlContainer = isEditingAnything || shape.props.text
 		const isForceSolid = useValue(
@@ -471,7 +475,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							align={align}
 							verticalAlign={verticalAlign}
 							text={text}
-							isSelected={isSelected}
+							isSelected={isOnlySelected}
 							labelColor={theme[props.labelColor].solid}
 							wrap
 						/>

commit d5f4c1d05bb834ab5623d19d418e31e4ab5afa66
Author: alex <alex@dytry.ch>
Date:   Wed Oct 9 15:55:15 2024 +0100

    make sure DOM IDs are globally unique (#4694)
    
    There are a lot of places where we currently derive a DOM ID from a
    shape ID. This works fine (ish) on tldraw.com, but doesn't work for a
    lot of developer use-cases: if there are multiple tldraw instances or
    exports happening, for example. This is because the DOM expects IDs to
    be globally unique. If there are multiple elements with the same ID in
    the dom, only the first is ever used. This can cause issues if e.g.
    
    1. i have a shape with a clip-path determined by the shape ID
    2. i export that shape and add the resulting SVG to the dom. now, there
    are two clip paths with the same ID, but they're the same
    3. I change the shape - and now, the ID is referring to the export, so i
    get weird rendering issues.
    
    This diff attempts to resolve this issue and prevent it from happening
    again by introducing a new `SafeId` type, and helpers for generating and
    working with `SafeId`s. in tldraw, jsx using the `id` attribute will now
    result in a type error if the value isn't a safe ID. This doesn't affect
    library consumers writing JSX.
    
    As part of this, I've removed the ID that were added to certain shapes.
    Instead, all shapes now have a `data-shape-id` attribute on their
    wrapper.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Exports and other tldraw instances no longer can affect how each other
    are rendered
    - **BREAKING:** the `id` attribute that was present on some shapes in
    the dom has been removed. there's now a data-shape-id attribute on every
    shape wrapper instead though.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 4623e7500..b91b53312 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -453,7 +453,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		return (
 			<>
-				<SVGContainer id={id}>
+				<SVGContainer>
 					<GeoShapeBody shape={shape} shouldScale={true} forceSolid={isForceSolid} />
 				</SVGContainer>
 				{showHtmlContainer && (
@@ -465,7 +465,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						}}
 					>
 						<TextLabel
-							id={id}
+							shapeId={id}
 							type={type}
 							font={font}
 							fontSize={LABEL_FONT_SIZES[size] * shape.props.scale}

commit 29d7ecaa7c0d2bc67190f20efd5c1ba47305ce14
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Sat Oct 12 16:12:12 2024 +0100

    lod: memoize media assets so that zoom level doesn't re-render constantly (#4659)
    
    Related to a discussion on Discord:
    https://discord.com/channels/859816885297741824/1290992999186169898/1291681011758792756
    
    This works to memoize the rendering of the core part of the image/video
    react components b/c the `useValue` hook inside `useAsset` is called so
    often. If there's a better way to do this @SomeHats I'm all ears!
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improve performance of image/video rendering.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index b91b53312..bd8d6e93a 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -481,9 +481,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 						/>
 					</HTMLContainer>
 				)}
-				{shape.props.url && (
-					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
-				)}
+				{shape.props.url && <HyperlinkButton url={shape.props.url} />}
 			</>
 		)
 	}

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists‚Üîheaders, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster ‚Äî I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool ‚Äî can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index bd8d6e93a..1bca84209 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -16,6 +16,7 @@ import {
 	SVGContainer,
 	Stadium2d,
 	SvgExportContext,
+	TLFontFace,
 	TLGeoShape,
 	TLGeoShapeProps,
 	TLResizeInfo,
@@ -25,14 +26,20 @@ import {
 	geoShapeMigrations,
 	geoShapeProps,
 	getDefaultColorTheme,
+	getFontsFromRichText,
 	getPolygonVertices,
 	lerp,
+	toRichText,
 	useValue,
 } from '@tldraw/editor'
 
+import isEqual from 'lodash.isequal'
+import {
+	renderHtmlFromRichTextForMeasurement,
+	renderPlaintextFromRichText,
+} from '../../utils/text/richText'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
-import { SvgTextLabel } from '../shared/SvgTextLabel'
-import { TextLabel } from '../shared/TextLabel'
+import { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'
 import {
 	FONT_FAMILIES,
 	LABEL_FONT_SIZES,
@@ -40,11 +47,7 @@ import {
 	STROKE_SIZES,
 	TEXT_PROPS,
 } from '../shared/default-shape-constants'
-import {
-	getFillDefForCanvas,
-	getFillDefForExport,
-	getFontDefForExport,
-} from '../shared/defaultStyleDefs'
+import { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { GeoShapeBody } from './components/GeoShapeBody'
 import {
@@ -81,12 +84,12 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			dash: 'draw',
 			size: 'm',
 			font: 'draw',
-			text: '',
 			align: 'middle',
 			verticalAlign: 'middle',
 			growY: 0,
 			url: '',
 			scale: 1,
+			richText: toRichText(''),
 		}
 	}
 
@@ -96,7 +99,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const cx = w / 2
 		const cy = h / 2
 
-		const isFilled = shape.props.fill !== 'none' // || shape.props.text.trim().length > 0
+		const isFilled = shape.props.fill !== 'none'
 
 		let body: Geometry2d
 
@@ -408,32 +411,20 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override getText(shape: TLGeoShape) {
-		return shape.props.text
+		return renderPlaintextFromRichText(this.editor, shape.props.richText)
 	}
 
-	override onEditEnd(shape: TLGeoShape) {
-		const {
-			id,
-			type,
-			props: { text },
-		} = shape
-
-		if (text.trimEnd() !== shape.props.text) {
-			this.editor.updateShapes([
-				{
-					id,
-					type,
-					props: {
-						text: text.trimEnd(),
-					},
-				},
-			])
-		}
+	override getFontFaces(shape: TLGeoShape): TLFontFace[] {
+		return getFontsFromRichText(this.editor, shape.props.richText, {
+			family: `tldraw_${shape.props.font}`,
+			weight: 'normal',
+			style: 'normal',
+		})
 	}
 
 	component(shape: TLGeoShape) {
 		const { id, type, props } = shape
-		const { fill, font, align, verticalAlign, size, text } = props
+		const { fill, font, align, verticalAlign, size, richText } = props
 		const theme = useDefaultColorTheme()
 		const { editor } = this
 		const isOnlySelected = useValue(
@@ -442,7 +433,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			[]
 		)
 		const isEditingAnything = editor.getEditingShapeId() !== null
-		const showHtmlContainer = isEditingAnything || shape.props.text
+		const plaintext = renderPlaintextFromRichText(this.editor, shape.props.richText)
+		const showHtmlContainer = isEditingAnything || !!plaintext.length
 		const isForceSolid = useValue(
 			'force solid',
 			() => {
@@ -464,7 +456,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							height: shape.props.h + props.growY,
 						}}
 					>
-						<TextLabel
+						<RichTextLabel
 							shapeId={id}
 							type={type}
 							font={font}
@@ -474,7 +466,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 							fill={fill}
 							align={align}
 							verticalAlign={verticalAlign}
-							text={text}
+							richText={richText}
 							isSelected={isOnlySelected}
 							labelColor={theme[props.labelColor].solid}
 							wrap
@@ -559,21 +551,19 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		ctx.addExportDef(getFillDefForExport(props.fill))
 
 		let textEl
-		if (props.text) {
-			ctx.addExportDef(getFontDefForExport(props.font))
+		if (renderPlaintextFromRichText(this.editor, props.richText)) {
 			const theme = getDefaultColorTheme(ctx)
-
 			const bounds = new Box(0, 0, props.w, props.h + props.growY)
 			textEl = (
-				<SvgTextLabel
+				<RichTextSVG
 					fontSize={LABEL_FONT_SIZES[props.size]}
 					font={props.font}
 					align={props.align}
 					verticalAlign={props.verticalAlign}
-					text={props.text}
+					richText={props.richText}
 					labelColor={theme[props.labelColor].solid}
 					bounds={bounds}
-					padding={16}
+					padding={LABEL_PADDING * shape.props.scale}
 				/>
 			)
 		}
@@ -606,7 +596,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		const min = MIN_SIZE_WITH_LABEL
 
-		if (shape.props.text.trim()) {
+		if (renderPlaintextFromRichText(this.editor, shape.props.richText)) {
 			let newW = Math.max(Math.abs(unscaledW), min)
 			let newH = Math.max(Math.abs(unscaledH), min)
 
@@ -670,7 +660,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override onBeforeCreate(shape: TLGeoShape) {
-		if (!shape.props.text) {
+		if (!renderPlaintextFromRichText(this.editor, shape.props.richText)) {
 			if (shape.props.growY) {
 				// No text / some growY, set growY to 0
 				return {
@@ -712,12 +702,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override onBeforeUpdate(prev: TLGeoShape, next: TLGeoShape) {
-		const prevText = prev.props.text
-		const nextText = next.props.text
-
 		// No change to text, font, or size, no need to update update
 		if (
-			prevText === nextText &&
+			isEqual(prev.props.richText, next.props.richText) &&
 			prev.props.font === next.props.font &&
 			prev.props.size === next.props.size
 		) {
@@ -725,7 +712,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 
 		// If we got rid of the text, cancel out any growY from the prev text
-		if (prevText && !nextText) {
+		const prevPlaintext = renderPlaintextFromRichText(this.editor, prev.props.richText)
+		const nextPlaintext = renderPlaintextFromRichText(this.editor, next.props.richText)
+		if (prevPlaintext && !nextPlaintext) {
 			return {
 				...next,
 				props: {
@@ -744,7 +733,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next)
 
 		// When entering the first character in a label (not pasting in multiple characters...)
-		if (!prevText && nextText && nextText.length === 1) {
+		if (!prevPlaintext && nextPlaintext && nextPlaintext.length === 1) {
 			let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w)
 			let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h)
 
@@ -849,9 +838,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 }
 
 function getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {
-	const { text, font, size, w } = shape.props
+	const { richText, font, size, w } = shape.props
 
-	if (!text) {
+	if (!richText || !renderPlaintextFromRichText(editor, richText)) {
 		return { w: 0, h: 0 }
 	}
 
@@ -870,7 +859,8 @@ function getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {
 		xl: 10,
 	}
 
-	const textSize = editor.textMeasure.measureText(text, {
+	const html = renderHtmlFromRichTextForMeasurement(editor, richText)
+	const textSize = editor.textMeasure.measureHtml(html, {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[font],
 		fontSize: LABEL_FONT_SIZES[size],

commit 3758de89732a9b38e18f60cf887e83a1ccc0d483
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Mar 15 13:21:03 2025 +0000

    [Fix] indicators hideAll / showAll (#5654)
    
    This PR adds `showAll` and `hideAll` props to the `TLShapeIndicators`
    component.
    
    ## Context
    
    As an optimization, we mount indicators for all shapes and hide or show
    them dynamically using CSS. This is faster than mounting or unmounting
    them dynamically.
    
    There are certain states where we want to hide all of the indicators. We
    allow customization of this logic by overriding a the `ShapeIndicators`
    component. In tldraw's `ShapeIndicators` component override, we check to
    see if we're in one of the select tool's "hide the indicators" states
    and return `null` instead of the default indicators component.
    
    However, this means the indicators are unmounted and remounted whenever
    they're hidden or shown; and on larger projects, this can be a
    performance hit.
    
    ## Solution
    
    This PR provides `hideAll` and `showAll` props to the ShapeIndicators
    component so that we can allow parent components to control visibility
    in a more performant way.
    
    ### For later
    
    It would be good to move _all_ of the "hide indicators when in these
    states" logic out of the DefaultIndicators component, though this would
    be a breaking change.
    
    ### Change type
    
    - [x] `bugfix`
    - [] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improved performance on large projects when hiding / showing shape
    indicators.
    - Added `hideAll` and `showAll` props to the `ShapeIndicators` component
    props

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 1bca84209..97280e498 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -430,18 +430,12 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const isOnlySelected = useValue(
 			'isGeoOnlySelected',
 			() => shape.id === editor.getOnlySelectedShapeId(),
-			[]
+			[editor]
 		)
 		const isEditingAnything = editor.getEditingShapeId() !== null
 		const plaintext = renderPlaintextFromRichText(this.editor, shape.props.richText)
 		const showHtmlContainer = isEditingAnything || !!plaintext.length
-		const isForceSolid = useValue(
-			'force solid',
-			() => {
-				return editor.getZoomLevel() < 0.2
-			},
-			[editor]
-		)
+		const isForceSolid = useValue('force solid', () => editor.getZoomLevel() < 0.2, [editor])
 
 		return (
 			<>

commit f0072703bfd4beb7af22ec1eb2058a7473d8fdde
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Mar 19 12:57:24 2025 +0000

    [Fix] Rich text perf issue (#5658)
    
    This PR improves the performance of the app with regard to text.
    
    
    https://github.com/user-attachments/assets/3c468587-0cc1-4e72-8979-61fe14f6a0dc
    
    The `renderPlaintextFromRichText` method is slow. It depends on TipTap's
    `getText` method. This parses the rich text and flattens it to plain
    text. As usual, we can improve performance by:
    
    1. making `renderPlaintextFromRichText` faster
    2. not calling `renderPlaintextFromRichText`
    
    ## Making it faster
    
    We can make it faster by using a weak cache so that we don't need to
    re-flatten text if we've flattened it before. We can also make it faster
    by skipping the flatten if the text content is empty. This can be done
    very quickly without using `getText`.
    
    ## Avoiding it entirely
    
    It turns out that most of the places where we call
    `renderPlaintextFromRichText` are checks against empty text, meaning we
    don't need to call `renderPlaintextFromRichText` at all. In these cases
    we _just_ check whether the text is empty and continue based on that
    result.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improved performance related to rich text.
    
    ---------
    
    Co-authored-by: Mime ƒåuvalo <mimecuvalo@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 97280e498..81dfd293b 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -35,6 +35,7 @@ import {
 
 import isEqual from 'lodash.isequal'
 import {
+	isEmptyRichText,
 	renderHtmlFromRichTextForMeasurement,
 	renderPlaintextFromRichText,
 } from '../../utils/text/richText'
@@ -433,8 +434,8 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			[editor]
 		)
 		const isEditingAnything = editor.getEditingShapeId() !== null
-		const plaintext = renderPlaintextFromRichText(this.editor, shape.props.richText)
-		const showHtmlContainer = isEditingAnything || !!plaintext.length
+		const isEmpty = isEmptyRichText(shape.props.richText)
+		const showHtmlContainer = isEditingAnything || !isEmpty
 		const isForceSolid = useValue('force solid', () => editor.getZoomLevel() < 0.2, [editor])
 
 		return (
@@ -545,7 +546,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		ctx.addExportDef(getFillDefForExport(props.fill))
 
 		let textEl
-		if (renderPlaintextFromRichText(this.editor, props.richText)) {
+		if (!isEmptyRichText(props.richText)) {
 			const theme = getDefaultColorTheme(ctx)
 			const bounds = new Box(0, 0, props.w, props.h + props.growY)
 			textEl = (
@@ -590,7 +591,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 
 		const min = MIN_SIZE_WITH_LABEL
 
-		if (renderPlaintextFromRichText(this.editor, shape.props.richText)) {
+		if (!isEmptyRichText(shape.props.richText)) {
 			let newW = Math.max(Math.abs(unscaledW), min)
 			let newH = Math.max(Math.abs(unscaledH), min)
 
@@ -654,7 +655,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 	}
 
 	override onBeforeCreate(shape: TLGeoShape) {
-		if (!renderPlaintextFromRichText(this.editor, shape.props.richText)) {
+		if (isEmptyRichText(shape.props.richText)) {
 			if (shape.props.growY) {
 				// No text / some growY, set growY to 0
 				return {
@@ -706,9 +707,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		}
 
 		// If we got rid of the text, cancel out any growY from the prev text
-		const prevPlaintext = renderPlaintextFromRichText(this.editor, prev.props.richText)
-		const nextPlaintext = renderPlaintextFromRichText(this.editor, next.props.richText)
-		if (prevPlaintext && !nextPlaintext) {
+		const wasEmpty = isEmptyRichText(prev.props.richText)
+		const isEmpty = isEmptyRichText(next.props.richText)
+		if (!wasEmpty && isEmpty) {
 			return {
 				...next,
 				props: {
@@ -727,7 +728,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 		const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next)
 
 		// When entering the first character in a label (not pasting in multiple characters...)
-		if (!prevPlaintext && nextPlaintext && nextPlaintext.length === 1) {
+		if (wasEmpty && !isEmpty && renderPlaintextFromRichText(this.editor, next.props.richText)) {
 			let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w)
 			let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h)
 
@@ -834,7 +835,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 function getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {
 	const { richText, font, size, w } = shape.props
 
-	if (!richText || !renderPlaintextFromRichText(editor, richText)) {
+	if (!richText || isEmptyRichText(richText)) {
 		return { w: 0, h: 0 }
 	}
 

commit 26d0418ecfdc9a9c2bfb255105240ae84d95ea4b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Mar 24 12:15:21 2025 +0000

    When editing a text shape, don't mount the text editor for non-editing empty shapes unless they're hovered (#5734)
    
    This PR improves text editing.
    
    ## The bug
    
    Previously, we would mount all of the text editors for all of the
    text-editable shapes when the user began editing any text-editable
    shape. For large projects this would block the main thread as all of
    those text editors were mounted. Even on my Very Fast Laptop this would
    introduce ~200-500ms of lag between when I press "Enter" to begin
    editing a shape and when the app would begin responding to my key
    strokes. This often dropped the first letter of whatever I was typing.
    
    ## The fix
    
    We now mount the text editor for a shape if it's:
    - editing; or
    - has text; or
    - is hovered
    
    If a shape is neither of those, then we don't mount the text editor
    until the user hovers the shape. From a user perspective, the
    interactions are identical to what they were before.
    
    ## Proof
    
    Before: (starting to edit a shape with ~1000 empty shapes on the page)
    
    <img width="1334" alt="image"
    src="https://github.com/user-attachments/assets/820908a2-21f0-4a3e-a5b9-5083e4ef6d66"
    />
    
    After:
    
    There's nothing to see, we don't drop any frames.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create many empty shapes
    2. Begin editing any shape.
    
    ### Release notes
    
    - Fixed a bug causing a performance delay when editing text.
    
    ---------
    
    Co-authored-by: Mime ƒåuvalo <mimecuvalo@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 81dfd293b..864c932d5 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -50,6 +50,7 @@ import {
 } from '../shared/default-shape-constants'
 import { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
+import { useIsReadyForEditing } from '../shared/useEditablePlainText'
 import { GeoShapeBody } from './components/GeoShapeBody'
 import {
 	cloudOutline,
@@ -433,9 +434,9 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			() => shape.id === editor.getOnlySelectedShapeId(),
 			[editor]
 		)
-		const isEditingAnything = editor.getEditingShapeId() !== null
+		const isReadyForEditing = useIsReadyForEditing(editor, shape.id)
 		const isEmpty = isEmptyRichText(shape.props.richText)
-		const showHtmlContainer = isEditingAnything || !isEmpty
+		const showHtmlContainer = isReadyForEditing || !isEmpty
 		const isForceSolid = useValue('force solid', () => editor.getZoomLevel() < 0.2, [editor])
 
 		return (

commit 3e2ed74b5e86028fc8b858893821ce2ba1f64c3f
Author: alex <alex@dytry.ch>
Date:   Thu Apr 3 14:15:59 2025 +0100

    Geometry2d Improvements (#5754)
    
    This diff adds a number of `Geometry2d` improvements back-ported from my
    work on elbow arrows.
    
    1. Intersection helpers. We have hit tests, distance to, nearest point
    etc. on geometry, but no intersections. This diff adds support for
    `Geometry2d.intersectLineSegment` and `Geometry2d.intersectCircle`. We
    previously were using these downstream in kind of a hack way, but having
    them directly on the geometry and able to play nicer with groups etc. is
    very helpful.
    2. Transformation. `Geometry2d.transform` allows you to efficiently
    transform a geometry by some matrix. Where possible, we avoid
    transforming every single point and instead forward the methods to the
    original untransformed geometry. This also allows for some efficiency
    gains by e.g. caching geometries in page space. For now, I've only
    ported some really obvious / simple use-cases over to using this, but
    there are many parts of the code that could now be simplified by
    switching to transformed geometries.
    3. Filters. Almost all geometry methods do some sort of filtering - e.g.
    to ignore labels, etc. Sometimes this was hard-coded, sometimes method
    accepted an optional boolean `includeFilters` parameter. Now, all
    methods than can have filters applied accept a filters argument which
    determines which parts do/don't get included in the shape. New here (&
    motivating this change) is a new way of designating parts of a group as
    "internal" geometry - e.g. the lines within a geo shape that we might
    not want to partake in arrow binding.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    - It's now easier to work with `Geometry2d` objects, with methods for
    intersections, transforming geometries, and filtering.

diff --git a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
index 864c932d5..5089354de 100644
--- a/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx
@@ -400,7 +400,7 @@ export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
 			case 'triangle':
 			case 'x-box':
 				// poly-line type shapes hand snap points for each vertex & the center
-				return { outline: outline, points: [...outline.getVertices(), geometry.bounds.center] }
+				return { outline: outline, points: [...outline.vertices, geometry.bounds.center] }
 			case 'cloud':
 			case 'ellipse':
 			case 'heart':

