# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/index/struct_payload_index.rs

commit 9fc12658da93b983db844b2f0e957a5d3041a6b9
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Nov 15 22:49:24 2020 +0100

    number field index

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
new file mode 100644
index 000000000..5908fb3ab
--- /dev/null
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -0,0 +1,29 @@
+use crate::index::index::{PayloadIndex};
+use crate::types::Filter;
+use std::sync::Arc;
+use atomic_refcell::AtomicRefCell;
+use crate::payload_storage::payload_storage::ConditionChecker;
+use crate::index::field_index::EstimationResult;
+
+
+struct StructPayloadIndex {
+    condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>
+}
+
+impl StructPayloadIndex {
+    fn total_points(&self) -> usize {
+        unimplemented!()
+    }
+}
+
+
+impl PayloadIndex for StructPayloadIndex {
+    fn estimate_cardinality(&self, query: &Filter) -> EstimationResult {
+        unimplemented!()
+    }
+
+    fn query_points(&self, query: &Filter) -> Vec<usize> {
+        unimplemented!()
+    }
+}
+

commit e5d7ac7721f16360e71d4358b5e524c65e0a9b87
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat Nov 21 00:47:19 2020 +0100

    extend payload storage interface + start functions for creating struct index

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 5908fb3ab..f0615ce7c 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,16 +1,63 @@
 use crate::index::index::{PayloadIndex};
-use crate::types::Filter;
+use crate::types::{Filter, PayloadKeyType};
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
-use crate::payload_storage::payload_storage::ConditionChecker;
-use crate::index::field_index::EstimationResult;
+use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::index::field_index::{Estimation, FieldIndex};
+use std::path::{Path, PathBuf};
+use std::collections::HashMap;
+use std::fs::File;
+use std::io::Error;
+use crate::entry::entry_point::{OperationResult, OperationError};
 
+type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
 struct StructPayloadIndex {
-    condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>
+    condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+    field_indexes: IndexesMap,
+    path: PathBuf,
 }
 
 impl StructPayloadIndex {
+    pub fn open(condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+                path: &Path,
+    ) -> Self {
+        let file = File::open(path);
+        let field_indexes: IndexesMap = match file {
+            Ok(file_reader) => serde_cbor::from_reader(file_reader).unwrap(),
+            Err(_) => Default::default()
+        };
+
+        StructPayloadIndex {
+            condition_checker,
+            field_indexes,
+            path: path.to_owned(),
+        }
+    }
+
+    pub fn build(
+        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+        path: &Path,
+    ) -> OperationResult<Self> {
+        let mut field_indexes: IndexesMap = Default::default();
+
+        // ToDo: implement build indexes
+
+        Ok(StructPayloadIndex {
+            condition_checker,
+            field_indexes,
+            path: path.to_owned(),
+        })
+    }
+
+    fn save(&self) -> OperationResult<()> {
+        let file = File::create(self.path.as_path())?;
+        serde_cbor::to_writer(file, &self.field_indexes)
+            .map_err(| err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
+        Ok(())
+    }
+
     fn total_points(&self) -> usize {
         unimplemented!()
     }
@@ -18,7 +65,7 @@ impl StructPayloadIndex {
 
 
 impl PayloadIndex for StructPayloadIndex {
-    fn estimate_cardinality(&self, query: &Filter) -> EstimationResult {
+    fn estimate_cardinality(&self, query: &Filter) -> Estimation {
         unimplemented!()
     }
 

commit cb9f41a0dfbf1368118b89f3ccb0f511be4a62c9
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Nov 22 00:14:05 2020 +0100

    implement payload index builder + column index for keywords and integers

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index f0615ce7c..bbe215de7 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,5 +1,5 @@
 use crate::index::index::{PayloadIndex};
-use crate::types::{Filter, PayloadKeyType};
+use crate::types::{Filter, PayloadKeyType, PayloadSchema};
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
@@ -9,6 +9,8 @@ use std::collections::HashMap;
 use std::fs::File;
 use std::io::Error;
 use crate::entry::entry_point::{OperationResult, OperationError};
+use crate::index::field_index::index_builder::{IndexBuilderTypes, IndexBuilder};
+use crate::index::field_index::numeric_index::PersistedNumericIndex;
 
 type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
@@ -42,7 +44,45 @@ impl StructPayloadIndex {
     ) -> OperationResult<Self> {
         let mut field_indexes: IndexesMap = Default::default();
 
-        // ToDo: implement build indexes
+        let payload_ref = payload.borrow();
+        let schema = payload_ref.schema();
+
+        let mut builders: HashMap<_, _> = schema
+            .into_iter()
+            .map(|(field, schema_type)| {
+                let builder = match schema_type {
+                    PayloadSchema::Keyword => IndexBuilderTypes::Keyword(IndexBuilder::new()),
+                    PayloadSchema::Integer => IndexBuilderTypes::Integer(IndexBuilder::new()),
+                    PayloadSchema::Float => IndexBuilderTypes::Float(IndexBuilder::new()),
+                    PayloadSchema::Geo => IndexBuilderTypes::Geo(IndexBuilder::new())
+                };
+                return (field, builder);
+            }).collect();
+
+        for point_id in payload_ref.iter_ids() {
+            let point_payload = payload_ref.payload(point_id);
+            for (key, value) in point_payload.iter() {
+                builders.get_mut(key).unwrap().add(point_id, value)
+            }
+        }
+
+        for (key, builder) in builders.iter() {
+            let mut indexes: Vec<FieldIndex> = vec![];
+            match builder {
+                IndexBuilderTypes::Float(builder) => {
+                    indexes.push(FieldIndex::FloatIndex(builder.into()))
+                }
+                IndexBuilderTypes::Integer(builder) => {
+                    indexes.push(FieldIndex::IntIndex(builder.into()));
+                    indexes.push(FieldIndex::IntMapIndex(builder.into()));
+                }
+                IndexBuilderTypes::Keyword(builder) => {
+                    indexes.push(FieldIndex::KeywordIndex(builder.into()));
+                }
+                IndexBuilderTypes::Geo(builder) => {}
+            }
+            field_indexes.insert(key.to_owned(), indexes);
+        }
 
         Ok(StructPayloadIndex {
             condition_checker,
@@ -54,7 +94,7 @@ impl StructPayloadIndex {
     fn save(&self) -> OperationResult<()> {
         let file = File::create(self.path.as_path())?;
         serde_cbor::to_writer(file, &self.field_indexes)
-            .map_err(| err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
+            .map_err(|err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
         Ok(())
     }
 

commit c3fe44364380b342fd74e1a40f2c6b846c8d76ab
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 24 08:32:40 2021 +0100

    WIP

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index bbe215de7..2e680ae62 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,94 +1,172 @@
 use crate::index::index::{PayloadIndex};
-use crate::types::{Filter, PayloadKeyType, PayloadSchema};
+use crate::types::{Filter, PayloadKeyType, PayloadSchemaType, PayloadType};
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::index::field_index::{Estimation, FieldIndex};
+use crate::index::field_index::{CardinalityEstimation, FieldIndex};
 use std::path::{Path, PathBuf};
 use std::collections::HashMap;
-use std::fs::File;
+use std::fs::{File, create_dir_all};
 use std::io::Error;
 use crate::entry::entry_point::{OperationResult, OperationError};
 use crate::index::field_index::index_builder::{IndexBuilderTypes, IndexBuilder};
 use crate::index::field_index::numeric_index::PersistedNumericIndex;
+use uuid::Builder;
+use crate::index::field_index::field_index::PayloadFieldIndexBuilder;
+use crate::index::field_index::index_selector::index_selector;
+use crate::index::payload_config::PayloadConfig;
+
+pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
 type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
 struct StructPayloadIndex {
     condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+    payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
     field_indexes: IndexesMap,
+    config: PayloadConfig,
     path: PathBuf,
 }
 
 impl StructPayloadIndex {
+    fn config_path(&self) -> PathBuf {
+        PayloadConfig::get_config_path(&self.path)
+    }
+
+    fn save_config(&self) -> OperationResult<()> {
+        let config_path = self.config_path();
+        self.config.save(&config_path)
+    }
+
+    fn get_field_index_dir(path: &Path) -> PathBuf {
+        path.join(PAYLOAD_FIELD_INDEX_PATH)
+    }
+
+    fn get_field_index_path(path: &Path, field: &PayloadKeyType) -> PathBuf {
+        Self::get_field_index_dir(path).join(format!("{}.idx", field))
+    }
+
+    fn save_field_index(&self, field: &PayloadKeyType) -> OperationResult<()> {
+        let field_index_dir = Self::get_field_index_dir(&self.path);
+        let field_index_path = Self::get_field_index_path(&self.path, field);
+        create_dir_all(field_index_dir)?;
+
+        match self.field_indexes.get(field) {
+            None => {}
+            Some(indexes) => {
+                let file = File::create(field_index_path.as_path())?;
+                serde_cbor::to_writer(file, indexes)
+                    .map_err(|err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
+            }
+        }
+        Ok(())
+    }
+
+    fn load_field_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+        let field_index_path = Self::get_field_index_path(&self.path, field);
+        let file = File::open(field_index_path)?;
+        let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file)
+            .map_err(|err| OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) })?;
+        self.field_indexes.insert(field.clone(), field_indexes);
+
+        Ok(())
+    }
+
+    fn load_all_fields(&mut self) -> OperationResult<()> {
+        let field_iterator = self.config.indexed_fields.iter();
+        for field in field_iterator {
+            self.load_field_index(field)?;
+        }
+        Ok(())
+    }
+
+
     pub fn open(condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+                payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
                 path: &Path,
-    ) -> Self {
+    ) -> OperationResult<Self> {
+        let config_path = PayloadConfig::get_config_path(path);
+        let config = PayloadConfig::load(&config_path)?;
+
         let file = File::open(path);
         let field_indexes: IndexesMap = match file {
             Ok(file_reader) => serde_cbor::from_reader(file_reader).unwrap(),
             Err(_) => Default::default()
         };
 
-        StructPayloadIndex {
+        let index = StructPayloadIndex {
             condition_checker,
+            payload,
             field_indexes,
+            config,
             path: path.to_owned(),
-        }
-    }
+        };
 
-    pub fn build(
-        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
-        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-        path: &Path,
-    ) -> OperationResult<Self> {
-        let mut field_indexes: IndexesMap = Default::default();
+        Ok(index)
+    }
 
-        let payload_ref = payload.borrow();
+    pub fn build_field_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+        let payload_ref = self.payload.borrow();
         let schema = payload_ref.schema();
 
-        let mut builders: HashMap<_, _> = schema
-            .into_iter()
-            .map(|(field, schema_type)| {
-                let builder = match schema_type {
-                    PayloadSchema::Keyword => IndexBuilderTypes::Keyword(IndexBuilder::new()),
-                    PayloadSchema::Integer => IndexBuilderTypes::Integer(IndexBuilder::new()),
-                    PayloadSchema::Float => IndexBuilderTypes::Float(IndexBuilder::new()),
-                    PayloadSchema::Geo => IndexBuilderTypes::Geo(IndexBuilder::new())
-                };
-                return (field, builder);
-            }).collect();
+        let field_type_opt = schema.get(field);
+
+        if field_type_opt.is_none() {
+            // There is not data to index
+            return Ok(());
+        }
+
+        let field_type = field_type_opt.unwrap();
+
+        let mut builders = index_selector(field_type);
+
+        let mut field_indexes: IndexesMap = Default::default();
 
         for point_id in payload_ref.iter_ids() {
             let point_payload = payload_ref.payload(point_id);
-            for (key, value) in point_payload.iter() {
-                builders.get_mut(key).unwrap().add(point_id, value)
+            let field_value_opt = point_payload.get(field);
+            match field_value_opt {
+                None => {}
+                Some(field_value) => {
+                    for builder in builders.iter_mut() {
+                        builder.add(point_id, field_value)
+                    }
+                }
             }
         }
 
-        for (key, builder) in builders.iter() {
-            let mut indexes: Vec<FieldIndex> = vec![];
-            match builder {
-                IndexBuilderTypes::Float(builder) => {
-                    indexes.push(FieldIndex::FloatIndex(builder.into()))
-                }
-                IndexBuilderTypes::Integer(builder) => {
-                    indexes.push(FieldIndex::IntIndex(builder.into()));
-                    indexes.push(FieldIndex::IntMapIndex(builder.into()));
-                }
-                IndexBuilderTypes::Keyword(builder) => {
-                    indexes.push(FieldIndex::KeywordIndex(builder.into()));
-                }
-                IndexBuilderTypes::Geo(builder) => {}
-            }
-            field_indexes.insert(key.to_owned(), indexes);
+        self.field_indexes.insert(
+            field.clone(),
+            builders.iter_mut().map(|builder| builder.build()).collect(),
+        );
+
+        self.save_field_index(field)
+    }
+
+    fn build_all_fields(&mut self) -> OperationResult<()> {
+        for field in self.config.indexed_fields.iter() {
+            self.build_field_index(field)?;
         }
+        Ok(())
+    }
 
-        Ok(StructPayloadIndex {
+    pub fn new(
+        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+        path: &Path,
+        config: Option<PayloadConfig>,
+    ) -> OperationResult<Self> {
+        create_dir_all(path)?;
+        let payload_config = config.unwrap_or_default();
+        let mut payload_index = Self {
             condition_checker,
-            field_indexes,
+            payload,
+            field_indexes: Default::default(),
+            config: payload_config,
             path: path.to_owned(),
-        })
+        };
+
+        Ok(payload_index)
     }
 
     fn save(&self) -> OperationResult<()> {
@@ -105,7 +183,19 @@ impl StructPayloadIndex {
 
 
 impl PayloadIndex for StructPayloadIndex {
-    fn estimate_cardinality(&self, query: &Filter) -> Estimation {
+    fn indexed_fields(&self) -> Vec<PayloadKeyType> {
+        unimplemented!()
+    }
+
+    fn mark_indexed(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+        unimplemented!()
+    }
+
+    fn drop_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+        unimplemented!()
+    }
+
+    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
         unimplemented!()
     }
 

commit 4f798062bd6ea890bce74731fa9725558eac4b5c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Feb 28 01:06:11 2021 +0100

    WIP: payload save and load

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2e680ae62..900ef161d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -6,7 +6,7 @@ use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
 use crate::index::field_index::{CardinalityEstimation, FieldIndex};
 use std::path::{Path, PathBuf};
 use std::collections::HashMap;
-use std::fs::{File, create_dir_all};
+use std::fs::{File, create_dir_all, remove_file};
 use std::io::Error;
 use crate::entry::entry_point::{OperationResult, OperationError};
 use crate::index::field_index::index_builder::{IndexBuilderTypes, IndexBuilder};
@@ -15,6 +15,8 @@ use uuid::Builder;
 use crate::index::field_index::field_index::PayloadFieldIndexBuilder;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::payload_config::PayloadConfig;
+use itertools::Itertools;
+use log::debug;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -62,21 +64,24 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    fn load_field_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+    fn load_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
+
         let field_index_path = Self::get_field_index_path(&self.path, field);
+        debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());
         let file = File::open(field_index_path)?;
         let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file)
             .map_err(|err| OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) })?;
-        self.field_indexes.insert(field.clone(), field_indexes);
 
-        Ok(())
+        Ok(field_indexes)
     }
 
     fn load_all_fields(&mut self) -> OperationResult<()> {
-        let field_iterator = self.config.indexed_fields.iter();
-        for field in field_iterator {
-            self.load_field_index(field)?;
+        let mut field_indexes: IndexesMap = Default::default();
+        for field in self.config.indexed_fields.iter() {
+            let field_index = self.load_field_index(field)?;
+            field_indexes.insert(field.clone(), field_index);
         }
+        self.field_indexes = field_indexes;
         Ok(())
     }
 
@@ -88,24 +93,20 @@ impl StructPayloadIndex {
         let config_path = PayloadConfig::get_config_path(path);
         let config = PayloadConfig::load(&config_path)?;
 
-        let file = File::open(path);
-        let field_indexes: IndexesMap = match file {
-            Ok(file_reader) => serde_cbor::from_reader(file_reader).unwrap(),
-            Err(_) => Default::default()
-        };
-
-        let index = StructPayloadIndex {
+        let mut index = StructPayloadIndex {
             condition_checker,
             payload,
-            field_indexes,
+            field_indexes: Default::default(),
             config,
             path: path.to_owned(),
         };
 
+        index.load_all_fields()?;
+
         Ok(index)
     }
 
-    pub fn build_field_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+    pub fn build_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
         let payload_ref = self.payload.borrow();
         let schema = payload_ref.schema();
 
@@ -113,15 +114,13 @@ impl StructPayloadIndex {
 
         if field_type_opt.is_none() {
             // There is not data to index
-            return Ok(());
+            return Ok(vec![]);
         }
 
         let field_type = field_type_opt.unwrap();
 
         let mut builders = index_selector(field_type);
 
-        let mut field_indexes: IndexesMap = Default::default();
-
         for point_id in payload_ref.iter_ids() {
             let point_payload = payload_ref.payload(point_id);
             let field_value_opt = point_payload.get(field);
@@ -135,21 +134,41 @@ impl StructPayloadIndex {
             }
         }
 
-        self.field_indexes.insert(
-            field.clone(),
-            builders.iter_mut().map(|builder| builder.build()).collect(),
-        );
+        let field_indexes = builders.iter_mut().map(|builder| builder.build()).collect_vec();
 
-        self.save_field_index(field)
+        Ok(field_indexes)
     }
 
     fn build_all_fields(&mut self) -> OperationResult<()> {
+        let mut field_indexes: IndexesMap = Default::default();
+        for field in self.config.indexed_fields.iter() {
+            let field_index = self.build_field_index(field)?;
+            field_indexes.insert(field.clone(), field_index);
+        }
+        self.field_indexes = field_indexes;
         for field in self.config.indexed_fields.iter() {
-            self.build_field_index(field)?;
+            self.save_field_index(field)?;
         }
         Ok(())
     }
 
+    fn build_and_save(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+        if !self.config.indexed_fields.contains(field) {
+            self.config.indexed_fields.push(field.clone());
+            self.save_config()?;
+        }
+
+        let field_indexes = self.build_field_index(field)?;
+        self.field_indexes.insert(
+            field.clone(),
+            field_indexes
+        );
+
+        self.save_field_index(field)?;
+
+        Ok(())
+    }
+
     pub fn new(
         condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
         payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
@@ -166,6 +185,8 @@ impl StructPayloadIndex {
             path: path.to_owned(),
         };
 
+        payload_index.build_all_fields()?;
+
         Ok(payload_index)
     }
 
@@ -184,15 +205,30 @@ impl StructPayloadIndex {
 
 impl PayloadIndex for StructPayloadIndex {
     fn indexed_fields(&self) -> Vec<PayloadKeyType> {
-        unimplemented!()
+        self.config.indexed_fields.clone()
     }
 
     fn mark_indexed(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
-        unimplemented!()
+        if !self.config.indexed_fields.contains(field) {
+            self.config.indexed_fields.push(field.clone());
+            self.save_config()?;
+            self.build_and_save(field)?;
+        }
+        Ok(())
     }
 
     fn drop_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
-        unimplemented!()
+        self.config.indexed_fields = self.config.indexed_fields.iter().cloned().filter(|x| x != field).collect();
+        self.save_config()?;
+        self.field_indexes.remove(field);
+
+        let field_index_path = Self::get_field_index_path(&self.path, field);
+
+        if field_index_path.exists() {
+            remove_file(&field_index_path)?;
+        }
+
+        Ok(())
     }
 
     fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
@@ -204,3 +240,16 @@ impl PayloadIndex for StructPayloadIndex {
     }
 }
 
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use tempdir::TempDir;
+    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
+
+    #[test]
+    fn test_index_save_and_load() {
+        let dir = TempDir::new("storage_dir").unwrap();
+        let mut storage = SimplePayloadStorage::open(dir.path()).unwrap();
+
+    }
+}
\ No newline at end of file

commit 0dd48e0acb734786fb539aeae344a546dd37cff0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 1 19:17:51 2021 +0100

    WIP: should, must and must_not estimators

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 900ef161d..942d67e99 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,33 +1,35 @@
-use crate::index::index::{PayloadIndex};
-use crate::types::{Filter, PayloadKeyType, PayloadSchemaType, PayloadType};
-use std::sync::Arc;
-use atomic_refcell::AtomicRefCell;
-use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::index::field_index::{CardinalityEstimation, FieldIndex};
-use std::path::{Path, PathBuf};
 use std::collections::HashMap;
-use std::fs::{File, create_dir_all, remove_file};
+use std::fs::{create_dir_all, File, remove_file};
 use std::io::Error;
-use crate::entry::entry_point::{OperationResult, OperationError};
-use crate::index::field_index::index_builder::{IndexBuilderTypes, IndexBuilder};
-use crate::index::field_index::numeric_index::PersistedNumericIndex;
+use std::path::{Path, PathBuf};
+use std::sync::Arc;
+
+use atomic_refcell::AtomicRefCell;
+use itertools::Itertools;
+use log::debug;
 use uuid::Builder;
-use crate::index::field_index::field_index::PayloadFieldIndexBuilder;
+
+use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::index::field_index::CardinalityEstimation;
+use crate::index::field_index::field_index::{FieldIndex, PayloadFieldIndexBuilder};
 use crate::index::field_index::index_selector::index_selector;
+use crate::index::field_index::numeric_index::PersistedNumericIndex;
+use crate::index::index::PayloadIndex;
 use crate::index::payload_config::PayloadConfig;
-use itertools::Itertools;
-use log::debug;
+use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::types::{Filter, PayloadKeyType, PayloadSchemaType, PayloadType};
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
 type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
-struct StructPayloadIndex {
+pub struct StructPayloadIndex {
     condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
     payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
     field_indexes: IndexesMap,
     config: PayloadConfig,
     path: PathBuf,
+    total_points: usize,
 }
 
 impl StructPayloadIndex {
@@ -65,7 +67,6 @@ impl StructPayloadIndex {
     }
 
     fn load_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
-
         let field_index_path = Self::get_field_index_path(&self.path, field);
         debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());
         let file = File::open(field_index_path)?;
@@ -89,6 +90,7 @@ impl StructPayloadIndex {
     pub fn open(condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
                 payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
                 path: &Path,
+                total_points: usize,
     ) -> OperationResult<Self> {
         let config_path = PayloadConfig::get_config_path(path);
         let config = PayloadConfig::load(&config_path)?;
@@ -99,6 +101,7 @@ impl StructPayloadIndex {
             field_indexes: Default::default(),
             config,
             path: path.to_owned(),
+            total_points,
         };
 
         index.load_all_fields()?;
@@ -161,7 +164,7 @@ impl StructPayloadIndex {
         let field_indexes = self.build_field_index(field)?;
         self.field_indexes.insert(
             field.clone(),
-            field_indexes
+            field_indexes,
         );
 
         self.save_field_index(field)?;
@@ -174,6 +177,7 @@ impl StructPayloadIndex {
         payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
         path: &Path,
         config: Option<PayloadConfig>,
+        total_points: usize,
     ) -> OperationResult<Self> {
         create_dir_all(path)?;
         let payload_config = config.unwrap_or_default();
@@ -183,6 +187,7 @@ impl StructPayloadIndex {
             field_indexes: Default::default(),
             config: payload_config,
             path: path.to_owned(),
+            total_points,
         };
 
         payload_index.build_all_fields()?;
@@ -197,8 +202,8 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    fn total_points(&self) -> usize {
-        unimplemented!()
+    pub fn total_points(&self) -> usize {
+        self.total_points
     }
 }
 
@@ -231,10 +236,6 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
-        unimplemented!()
-    }
-
     fn query_points(&self, query: &Filter) -> Vec<usize> {
         unimplemented!()
     }
@@ -242,14 +243,15 @@ impl PayloadIndex for StructPayloadIndex {
 
 #[cfg(test)]
 mod tests {
-    use super::*;
     use tempdir::TempDir;
+
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 
+    use super::*;
+
     #[test]
     fn test_index_save_and_load() {
         let dir = TempDir::new("storage_dir").unwrap();
         let mut storage = SimplePayloadStorage::open(dir.path()).unwrap();
-
     }
 }
\ No newline at end of file

commit fe44c4e00eefa60bbb11e49beab5c6fc584314b8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 2 19:06:10 2021 +0100

    WIP: FieldCondition

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 942d67e99..d0b5962df 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,23 +1,20 @@
 use std::collections::HashMap;
 use std::fs::{create_dir_all, File, remove_file};
-use std::io::Error;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use itertools::Itertools;
 use log::debug;
-use uuid::Builder;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::index::field_index::CardinalityEstimation;
-use crate::index::field_index::field_index::{FieldIndex, PayloadFieldIndexBuilder};
+use crate::index::field_index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::field_index::index_selector::index_selector;
-use crate::index::field_index::numeric_index::PersistedNumericIndex;
 use crate::index::index::PayloadIndex;
 use crate::index::payload_config::PayloadConfig;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::types::{Filter, PayloadKeyType, PayloadSchemaType, PayloadType};
+use crate::types::{Filter, PayloadKeyType, FieldCondition};
+use crate::index::field_index::CardinalityEstimation;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -33,6 +30,20 @@ pub struct StructPayloadIndex {
 }
 
 impl StructPayloadIndex {
+
+    pub fn estimate_field_condition(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+        self.field_indexes.get(&condition.key).and_then(|indexes| {
+            let mut result_estimation: Option<CardinalityEstimation> = None;
+            for index in indexes {
+                result_estimation = index.estimate_cardinality(condition);
+                if result_estimation.is_some() {
+                    break
+                }
+            }
+            result_estimation
+        })
+    }
+
     fn config_path(&self) -> PathBuf {
         PayloadConfig::get_config_path(&self.path)
     }

commit c50482d53f80dbaebd3556bb25eae47443aeffaf
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 8 01:00:27 2021 +0100

    WIP: query_points in struct payload index

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index d0b5962df..52eed4702 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,4 +1,4 @@
-use std::collections::HashMap;
+use std::collections::{HashMap, HashSet};
 use std::fs::{create_dir_all, File, remove_file};
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -13,8 +13,12 @@ use crate::index::field_index::index_selector::index_selector;
 use crate::index::index::PayloadIndex;
 use crate::index::payload_config::PayloadConfig;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::types::{Filter, PayloadKeyType, FieldCondition};
-use crate::index::field_index::CardinalityEstimation;
+use crate::types::{Filter, PayloadKeyType, FieldCondition, Condition, PointOffsetType};
+use crate::index::field_index::{CardinalityEstimation, PrimaryCondition};
+use crate::index::query_estimator::estimate_filter;
+use crate::vector_storage::vector_storage::VectorStorage;
+use std::iter::FromIterator;
+use crate::id_mapper::id_mapper::IdMapper;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -22,7 +26,9 @@ type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
 pub struct StructPayloadIndex {
     condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+    vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
     payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+    id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
     field_indexes: IndexesMap,
     config: PayloadConfig,
     path: PathBuf,
@@ -30,20 +36,33 @@ pub struct StructPayloadIndex {
 }
 
 impl StructPayloadIndex {
-
     pub fn estimate_field_condition(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
         self.field_indexes.get(&condition.key).and_then(|indexes| {
             let mut result_estimation: Option<CardinalityEstimation> = None;
             for index in indexes {
                 result_estimation = index.estimate_cardinality(condition);
                 if result_estimation.is_some() {
-                    break
+                    break;
                 }
             }
             result_estimation
         })
     }
 
+    fn query_field(&self, field_condition: &FieldCondition) -> Option<Box<dyn Iterator<Item=PointOffsetType> + '_>> {
+        let indexes = self.field_indexes
+            .get(&field_condition.key)
+            .and_then(|indexes|
+                indexes
+                    .iter()
+                    .map(|field_index| field_index.filter(field_condition))
+                    .skip_while(|filter_iter| filter_iter.is_none())
+                    .next()
+                    .map(|filter_iter| filter_iter.unwrap())
+            );
+        indexes
+    }
+
     fn config_path(&self) -> PathBuf {
         PayloadConfig::get_config_path(&self.path)
     }
@@ -99,7 +118,9 @@ impl StructPayloadIndex {
 
 
     pub fn open(condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+                vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
                 payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+                id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
                 path: &Path,
                 total_points: usize,
     ) -> OperationResult<Self> {
@@ -108,7 +129,9 @@ impl StructPayloadIndex {
 
         let mut index = StructPayloadIndex {
             condition_checker,
+            vector_storage,
             payload,
+            id_mapper,
             field_indexes: Default::default(),
             config,
             path: path.to_owned(),
@@ -185,7 +208,9 @@ impl StructPayloadIndex {
 
     pub fn new(
         condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+        vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
         payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
         path: &Path,
         config: Option<PayloadConfig>,
         total_points: usize,
@@ -194,7 +219,9 @@ impl StructPayloadIndex {
         let payload_config = config.unwrap_or_default();
         let mut payload_index = Self {
             condition_checker,
+            vector_storage,
             payload,
+            id_mapper,
             field_indexes: Default::default(),
             config: payload_config,
             path: path.to_owned(),
@@ -247,8 +274,69 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn query_points(&self, query: &Filter) -> Vec<usize> {
-        unimplemented!()
+    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
+        let total = self.total_points();
+
+        let estimator = |condition: &Condition| {
+            match condition {
+                Condition::Filter(_) => panic!("Unexpected branching"),
+                Condition::HasId(ids) => {
+                    let id_mapper_ref = self.id_mapper.borrow();
+                    let mapped_ids: HashSet<PointOffsetType> = ids.iter()
+                        .filter_map(|external_id| id_mapper_ref.internal_id(*external_id))
+                        .collect();
+                    let num_ids = mapped_ids.len();
+                    CardinalityEstimation {
+                        primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
+                        min: 0,
+                        exp: num_ids,
+                        max: num_ids,
+                    }
+                }
+                Condition::Field(field_condition) => self
+                    .estimate_field_condition(field_condition)
+                    .unwrap_or(CardinalityEstimation {
+                        primary_clauses: vec![],
+                        min: 0,
+                        exp: self.total_points() / 2,
+                        max: self.total_points(),
+                    }),
+            }
+        };
+
+        estimate_filter(&estimator, query, total)
+    }
+
+    fn query_points(&self, query: &Filter) -> Box<dyn Iterator<Item=PointOffsetType> + '_> {
+        // Assume query is already estimated to be small enough so we can iterate over all matched ids
+        let query_cardinality = self.estimate_cardinality(query);
+        let condition_checker = self.condition_checker.borrow();
+        let vector_storage_ref = self.vector_storage.borrow();
+        let full_scan_iterator = vector_storage_ref.iter_ids(); // Should not be used if filter restricted by indexed fields
+        return if query_cardinality.primary_clauses.is_empty() {
+            // Worst case: query expected to return few matches, but index can't be used
+            let matched_points = full_scan_iterator
+                .filter(|i| condition_checker.check(*i, query))
+                .collect_vec();
+
+            Box::new(matched_points.into_iter())
+        } else {
+            // CPU-optimized strategy here: points are made unique before applying other filters.
+            let preselected: HashSet<PointOffsetType> = query_cardinality.primary_clauses.iter()
+                .map(|clause| {
+                    match clause {
+                        PrimaryCondition::Condition(field_condition) => self.query_field(field_condition)
+                            .unwrap_or(vector_storage_ref.iter_ids() /* index is not built */),
+                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned())
+                    }
+                })
+                .flat_map(|x| x)
+                .collect();
+            let  matched_points = preselected.into_iter()
+                .filter(|i| condition_checker.check(*i, query))
+                .collect_vec();
+            Box::new(matched_points.into_iter())
+        };
     }
 }
 
@@ -265,4 +353,10 @@ mod tests {
         let dir = TempDir::new("storage_dir").unwrap();
         let mut storage = SimplePayloadStorage::open(dir.path()).unwrap();
     }
+
+    // #[test]
+    // fn test_flat_map() {
+    //     let a = vec![vec![1,2,3], vec![4,5,6], vec![7,7,7]];
+    //     a.iter().flat_map(|x| x.iter()).for_each(|x| println!("{}", x))
+    // }
 }
\ No newline at end of file

commit 5dd3c1935ece9810c5fb8d347022100aabfb2005
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Mar 14 01:01:53 2021 +0100

    WIP: struct payload index texts

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 52eed4702..ac2e607f3 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -32,7 +32,6 @@ pub struct StructPayloadIndex {
     field_indexes: IndexesMap,
     config: PayloadConfig,
     path: PathBuf,
-    total_points: usize,
 }
 
 impl StructPayloadIndex {
@@ -122,10 +121,13 @@ impl StructPayloadIndex {
                 payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
                 id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
                 path: &Path,
-                total_points: usize,
     ) -> OperationResult<Self> {
         let config_path = PayloadConfig::get_config_path(path);
-        let config = PayloadConfig::load(&config_path)?;
+        let config = if config_path.exists() {
+            PayloadConfig::load(&config_path)?
+        } else {
+            PayloadConfig::default()
+        };
 
         let mut index = StructPayloadIndex {
             condition_checker,
@@ -134,10 +136,14 @@ impl StructPayloadIndex {
             id_mapper,
             field_indexes: Default::default(),
             config,
-            path: path.to_owned(),
-            total_points,
+            path: path.to_owned()
         };
 
+        if !index.config_path().exists() {
+            // Save default config
+            index.save_config()?
+        }
+
         index.load_all_fields()?;
 
         Ok(index)
@@ -206,33 +212,6 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    pub fn new(
-        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
-        vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
-        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
-        path: &Path,
-        config: Option<PayloadConfig>,
-        total_points: usize,
-    ) -> OperationResult<Self> {
-        create_dir_all(path)?;
-        let payload_config = config.unwrap_or_default();
-        let mut payload_index = Self {
-            condition_checker,
-            vector_storage,
-            payload,
-            id_mapper,
-            field_indexes: Default::default(),
-            config: payload_config,
-            path: path.to_owned(),
-            total_points,
-        };
-
-        payload_index.build_all_fields()?;
-
-        Ok(payload_index)
-    }
-
     fn save(&self) -> OperationResult<()> {
         let file = File::create(self.path.as_path())?;
         serde_cbor::to_writer(file, &self.field_indexes)
@@ -241,7 +220,7 @@ impl StructPayloadIndex {
     }
 
     pub fn total_points(&self) -> usize {
-        self.total_points
+        self.vector_storage.borrow().vector_count()
     }
 }
 
@@ -332,31 +311,10 @@ impl PayloadIndex for StructPayloadIndex {
                 })
                 .flat_map(|x| x)
                 .collect();
-            let  matched_points = preselected.into_iter()
+            let matched_points = preselected.into_iter()
                 .filter(|i| condition_checker.check(*i, query))
                 .collect_vec();
             Box::new(matched_points.into_iter())
         };
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use tempdir::TempDir;
-
-    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-
-    use super::*;
-
-    #[test]
-    fn test_index_save_and_load() {
-        let dir = TempDir::new("storage_dir").unwrap();
-        let mut storage = SimplePayloadStorage::open(dir.path()).unwrap();
-    }
-
-    // #[test]
-    // fn test_flat_map() {
-    //     let a = vec![vec![1,2,3], vec![4,5,6], vec![7,7,7]];
-    //     a.iter().flat_map(|x| x.iter()).for_each(|x| println!("{}", x))
-    // }
-}
\ No newline at end of file

commit cd2acd5dac4807334fccb5df8650a4a8fdcfa0b4
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Mar 14 17:55:50 2021 +0100

    test for cardinality estimation

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index ac2e607f3..57af881ba 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -17,7 +17,6 @@ use crate::types::{Filter, PayloadKeyType, FieldCondition, Condition, PointOffse
 use crate::index::field_index::{CardinalityEstimation, PrimaryCondition};
 use crate::index::query_estimator::estimate_filter;
 use crate::vector_storage::vector_storage::VectorStorage;
-use std::iter::FromIterator;
 use crate::id_mapper::id_mapper::IdMapper;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
@@ -122,6 +121,7 @@ impl StructPayloadIndex {
                 id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
                 path: &Path,
     ) -> OperationResult<Self> {
+        create_dir_all(path)?;
         let config_path = PayloadConfig::get_config_path(path);
         let config = if config_path.exists() {
             PayloadConfig::load(&config_path)?
@@ -182,19 +182,6 @@ impl StructPayloadIndex {
         Ok(field_indexes)
     }
 
-    fn build_all_fields(&mut self) -> OperationResult<()> {
-        let mut field_indexes: IndexesMap = Default::default();
-        for field in self.config.indexed_fields.iter() {
-            let field_index = self.build_field_index(field)?;
-            field_indexes.insert(field.clone(), field_index);
-        }
-        self.field_indexes = field_indexes;
-        for field in self.config.indexed_fields.iter() {
-            self.save_field_index(field)?;
-        }
-        Ok(())
-    }
-
     fn build_and_save(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
         if !self.config.indexed_fields.contains(field) {
             self.config.indexed_fields.push(field.clone());
@@ -212,13 +199,6 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    fn save(&self) -> OperationResult<()> {
-        let file = File::create(self.path.as_path())?;
-        serde_cbor::to_writer(file, &self.field_indexes)
-            .map_err(|err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
-        Ok(())
-    }
-
     pub fn total_points(&self) -> usize {
         self.vector_storage.borrow().vector_count()
     }
@@ -230,7 +210,7 @@ impl PayloadIndex for StructPayloadIndex {
         self.config.indexed_fields.clone()
     }
 
-    fn mark_indexed(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+    fn set_indexed(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
         if !self.config.indexed_fields.contains(field) {
             self.config.indexed_fields.push(field.clone());
             self.save_config()?;
@@ -267,19 +247,14 @@ impl PayloadIndex for StructPayloadIndex {
                     let num_ids = mapped_ids.len();
                     CardinalityEstimation {
                         primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
-                        min: 0,
+                        min: num_ids,
                         exp: num_ids,
                         max: num_ids,
                     }
                 }
                 Condition::Field(field_condition) => self
                     .estimate_field_condition(field_condition)
-                    .unwrap_or(CardinalityEstimation {
-                        primary_clauses: vec![],
-                        min: 0,
-                        exp: self.total_points() / 2,
-                        max: self.total_points(),
-                    }),
+                    .unwrap_or(CardinalityEstimation::unknown(self.total_points())),
             }
         };
 

commit 725c33aab2758093511f04bd41c82659134d20f8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 16 21:13:22 2021 +0100

    endpoint option to manage indexes

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 57af881ba..f0d98931b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -94,20 +94,27 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    fn load_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
+    fn load_or_build_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
         let field_index_path = Self::get_field_index_path(&self.path, field);
-        debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());
-        let file = File::open(field_index_path)?;
-        let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file)
-            .map_err(|err| OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) })?;
+        if field_index_path.exists() {
+            debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());
+            let file = File::open(field_index_path)?;
+            let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file)
+                .map_err(|err| OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) })?;
 
-        Ok(field_indexes)
+            Ok(field_indexes)
+        } else {
+            debug!("Index for field `{}` not found in {}, building now", field, field_index_path.to_str().unwrap());
+            let res = self.build_field_index(field)?;
+            self.save_field_index(field)?;
+            Ok(res)
+        }
     }
 
     fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
         for field in self.config.indexed_fields.iter() {
-            let field_index = self.load_field_index(field)?;
+            let field_index = self.load_or_build_field_index(field)?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;

commit 46ba12a198a2c83c78ed04d23c78f131ed6bb41a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Mar 31 01:28:00 2021 +0200

    update readme + change filter structure

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index f0d98931b..2142a2a81 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -246,9 +246,9 @@ impl PayloadIndex for StructPayloadIndex {
         let estimator = |condition: &Condition| {
             match condition {
                 Condition::Filter(_) => panic!("Unexpected branching"),
-                Condition::HasId(ids) => {
+                Condition::HasId(has_id) => {
                     let id_mapper_ref = self.id_mapper.borrow();
-                    let mapped_ids: HashSet<PointOffsetType> = ids.iter()
+                    let mapped_ids: HashSet<PointOffsetType> = has_id.has_id.iter()
                         .filter_map(|external_id| id_mapper_ref.internal_id(*external_id))
                         .collect();
                     let num_ids = mapped_ids.len();

commit 3616631300ab6d2b2a2cefb002ff567448710e06
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun May 30 17:14:42 2021 +0200

    Filtrable hnsw (#26)
    
    * raw points scorer
    
    * raw point scorer for memmap storage
    
    * search interface prepare
    
    * graph binary saving + store PointOffsetId as u32
    
    * WIP: entry points
    
    * connect new link method
    
    * update libs + search layer method + visited list + search context + update rust
    
    * implement Euclid metric + always use MinHeap for priority queue
    
    * small refactor
    
    * search for 0 level entry
    
    * update visited pool to be lock free and thread safe
    
    * use ef_construct from graph layer struct + limit visited links to M
    
    * add metric pre-processing before on vector upsert
    
    * old hnsw heuristic
    
    * save hnsw graph for export
    
    * search method + tests
    
    * small fixes
    
    * add benchmark and profiler
    
    * build time optimizations
    
    * use SeaHash
    
    * remove unsed benchmark
    
    * merge hnsw graph function
    
    * WIP:HNSW index build function
    
    * HNSW build_index with additional indexing
    
    * refactor fixtures
    
    * graph save and load test
    
    * test and fixes for filterable HNSW
    
    * enable hnsw index for query planning
    
    * fix cardinality estimation tests + remove query planner as class
    
    * small refactor
    
    * store full copy of collection settings with collection + allow partial override on creation #16
    
    * API for updating collection parameters #16
    
    * refactor: move collection error -> types
    
    * report collection status in info API #17
    
    * update OpenAPI Schema

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2142a2a81..ba79a5ae2 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -14,10 +14,11 @@ use crate::index::index::PayloadIndex;
 use crate::index::payload_config::PayloadConfig;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
 use crate::types::{Filter, PayloadKeyType, FieldCondition, Condition, PointOffsetType};
-use crate::index::field_index::{CardinalityEstimation, PrimaryCondition};
-use crate::index::query_estimator::estimate_filter;
+use crate::index::field_index::{CardinalityEstimation, PrimaryCondition, PayloadBlockCondition};
+use crate::index::query_estimator::{estimate_filter};
 use crate::vector_storage::vector_storage::VectorStorage;
 use crate::id_mapper::id_mapper::IdMapper;
+use crate::index::visited_pool::VisitedPool;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -31,6 +32,7 @@ pub struct StructPayloadIndex {
     field_indexes: IndexesMap,
     config: PayloadConfig,
     path: PathBuf,
+    visited_pool: VisitedPool,
 }
 
 impl StructPayloadIndex {
@@ -143,7 +145,8 @@ impl StructPayloadIndex {
             id_mapper,
             field_indexes: Default::default(),
             config,
-            path: path.to_owned()
+            path: path.to_owned(),
+            visited_pool: Default::default(),
         };
 
         if !index.config_path().exists() {
@@ -241,7 +244,7 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
-        let total = self.total_points();
+        let total_points = self.total_points();
 
         let estimator = |condition: &Condition| {
             match condition {
@@ -265,16 +268,30 @@ impl PayloadIndex for StructPayloadIndex {
             }
         };
 
-        estimate_filter(&estimator, query, total)
+        estimate_filter(&estimator, query, total_points)
     }
 
-    fn query_points(&self, query: &Filter) -> Box<dyn Iterator<Item=PointOffsetType> + '_> {
+    fn payload_blocks(&self, threshold: usize) -> Box<dyn Iterator<Item=PayloadBlockCondition> + '_> {
+        let iter = self.field_indexes
+            .iter()
+            .map(move |(key, indexes)| {
+                indexes
+                    .iter()
+                    .map(move |field_index| field_index.payload_blocks(threshold, key.clone()))
+                    .flatten()
+            }).flatten();
+
+        Box::new(iter)
+    }
+
+    fn query_points<'a>(&'a self, query: &'a Filter) -> Box<dyn Iterator<Item=PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
-        let query_cardinality = self.estimate_cardinality(query);
-        let condition_checker = self.condition_checker.borrow();
         let vector_storage_ref = self.vector_storage.borrow();
-        let full_scan_iterator = vector_storage_ref.iter_ids(); // Should not be used if filter restricted by indexed fields
+        let condition_checker = self.condition_checker.borrow();
+
+        let query_cardinality = self.estimate_cardinality(query);
         return if query_cardinality.primary_clauses.is_empty() {
+            let full_scan_iterator = vector_storage_ref.iter_ids();
             // Worst case: query expected to return few matches, but index can't be used
             let matched_points = full_scan_iterator
                 .filter(|i| condition_checker.check(*i, query))
@@ -283,7 +300,10 @@ impl PayloadIndex for StructPayloadIndex {
             Box::new(matched_points.into_iter())
         } else {
             // CPU-optimized strategy here: points are made unique before applying other filters.
-            let preselected: HashSet<PointOffsetType> = query_cardinality.primary_clauses.iter()
+            // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
+            let mut visited_list = self.visited_pool.get(vector_storage_ref.total_vector_count());
+
+            let preselected: Vec<PointOffsetType> = query_cardinality.primary_clauses.iter()
                 .map(|clause| {
                     match clause {
                         PrimaryCondition::Condition(field_condition) => self.query_field(field_condition)
@@ -291,12 +311,16 @@ impl PayloadIndex for StructPayloadIndex {
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned())
                     }
                 })
-                .flat_map(|x| x)
+                .flatten()
+                .filter(|id| !visited_list.check_and_update_visited(*id))
+                .filter(move |i| condition_checker.check(*i, query))
                 .collect();
-            let matched_points = preselected.into_iter()
-                .filter(|i| condition_checker.check(*i, query))
-                .collect_vec();
-            Box::new(matched_points.into_iter())
+
+            self.visited_pool.return_back(visited_list);
+
+            let matched_points_iter = preselected.into_iter();
+            Box::new(matched_points_iter)
         };
     }
+
 }

commit cfc5beeac72aa041b8775b8cd425f8f7935105db
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 13 22:31:09 2021 +0200

    add payload schema to collection info + indexing fixes

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index ba79a5ae2..c87d449ec 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -271,17 +271,17 @@ impl PayloadIndex for StructPayloadIndex {
         estimate_filter(&estimator, query, total_points)
     }
 
-    fn payload_blocks(&self, threshold: usize) -> Box<dyn Iterator<Item=PayloadBlockCondition> + '_> {
-        let iter = self.field_indexes
-            .iter()
-            .map(move |(key, indexes)| {
-                indexes
+    fn payload_blocks(&self, field: &PayloadKeyType, threshold: usize) -> Box<dyn Iterator<Item=PayloadBlockCondition> + '_> {
+        match self.field_indexes.get(field) {
+            None => Box::new(vec![].into_iter()),
+            Some(indexes) => {
+                let field_clone = field.clone();
+                Box::new(indexes
                     .iter()
-                    .map(move |field_index| field_index.payload_blocks(threshold, key.clone()))
-                    .flatten()
-            }).flatten();
-
-        Box::new(iter)
+                    .map(move |field_index| field_index.payload_blocks(threshold, field_clone.clone()))
+                    .flatten())
+            }
+        }
     }
 
     fn query_points<'a>(&'a self, query: &'a Filter) -> Box<dyn Iterator<Item=PointOffsetType> + 'a> {

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index c87d449ec..dc950f1dc 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,5 +1,5 @@
 use std::collections::{HashMap, HashSet};
-use std::fs::{create_dir_all, File, remove_file};
+use std::fs::{create_dir_all, remove_file, File};
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
@@ -8,17 +8,17 @@ use itertools::Itertools;
 use log::debug;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::id_mapper::id_mapper::IdMapper;
 use crate::index::field_index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::field_index::index_selector::index_selector;
+use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
 use crate::index::index::PayloadIndex;
 use crate::index::payload_config::PayloadConfig;
+use crate::index::query_estimator::estimate_filter;
+use crate::index::visited_pool::VisitedPool;
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::types::{Filter, PayloadKeyType, FieldCondition, Condition, PointOffsetType};
-use crate::index::field_index::{CardinalityEstimation, PrimaryCondition, PayloadBlockCondition};
-use crate::index::query_estimator::{estimate_filter};
+use crate::types::{Condition, FieldCondition, Filter, PayloadKeyType, PointOffsetType};
 use crate::vector_storage::vector_storage::VectorStorage;
-use crate::id_mapper::id_mapper::IdMapper;
-use crate::index::visited_pool::VisitedPool;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -36,7 +36,10 @@ pub struct StructPayloadIndex {
 }
 
 impl StructPayloadIndex {
-    pub fn estimate_field_condition(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    pub fn estimate_field_condition(
+        &self,
+        condition: &FieldCondition,
+    ) -> Option<CardinalityEstimation> {
         self.field_indexes.get(&condition.key).and_then(|indexes| {
             let mut result_estimation: Option<CardinalityEstimation> = None;
             for index in indexes {
@@ -49,17 +52,21 @@ impl StructPayloadIndex {
         })
     }
 
-    fn query_field(&self, field_condition: &FieldCondition) -> Option<Box<dyn Iterator<Item=PointOffsetType> + '_>> {
-        let indexes = self.field_indexes
+    fn query_field(
+        &self,
+        field_condition: &FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>> {
+        let indexes = self
+            .field_indexes
             .get(&field_condition.key)
-            .and_then(|indexes|
+            .and_then(|indexes| {
                 indexes
                     .iter()
                     .map(|field_index| field_index.filter(field_condition))
                     .skip_while(|filter_iter| filter_iter.is_none())
                     .next()
                     .map(|filter_iter| filter_iter.unwrap())
-            );
+            });
         indexes
     }
 
@@ -89,24 +96,40 @@ impl StructPayloadIndex {
             None => {}
             Some(indexes) => {
                 let file = File::create(field_index_path.as_path())?;
-                serde_cbor::to_writer(file, indexes)
-                    .map_err(|err| OperationError::ServiceError { description: format!("Unable to save index: {:?}", err) })?;
+                serde_cbor::to_writer(file, indexes).map_err(|err| {
+                    OperationError::ServiceError {
+                        description: format!("Unable to save index: {:?}", err),
+                    }
+                })?;
             }
         }
         Ok(())
     }
 
-    fn load_or_build_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
+    fn load_or_build_field_index(
+        &self,
+        field: &PayloadKeyType,
+    ) -> OperationResult<Vec<FieldIndex>> {
         let field_index_path = Self::get_field_index_path(&self.path, field);
         if field_index_path.exists() {
-            debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());
+            debug!(
+                "Loading field `{}` index from {}",
+                field,
+                field_index_path.to_str().unwrap()
+            );
             let file = File::open(field_index_path)?;
-            let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file)
-                .map_err(|err| OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) })?;
+            let field_indexes: Vec<FieldIndex> =
+                serde_cbor::from_reader(file).map_err(|err| OperationError::ServiceError {
+                    description: format!("Unable to load index: {:?}", err),
+                })?;
 
             Ok(field_indexes)
         } else {
-            debug!("Index for field `{}` not found in {}, building now", field, field_index_path.to_str().unwrap());
+            debug!(
+                "Index for field `{}` not found in {}, building now",
+                field,
+                field_index_path.to_str().unwrap()
+            );
             let res = self.build_field_index(field)?;
             self.save_field_index(field)?;
             Ok(res)
@@ -123,12 +146,12 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-
-    pub fn open(condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
-                vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
-                payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-                id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
-                path: &Path,
+    pub fn open(
+        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+        vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
+        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
+        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+        path: &Path,
     ) -> OperationResult<Self> {
         create_dir_all(path)?;
         let config_path = PayloadConfig::get_config_path(path);
@@ -187,7 +210,10 @@ impl StructPayloadIndex {
             }
         }
 
-        let field_indexes = builders.iter_mut().map(|builder| builder.build()).collect_vec();
+        let field_indexes = builders
+            .iter_mut()
+            .map(|builder| builder.build())
+            .collect_vec();
 
         Ok(field_indexes)
     }
@@ -199,10 +225,7 @@ impl StructPayloadIndex {
         }
 
         let field_indexes = self.build_field_index(field)?;
-        self.field_indexes.insert(
-            field.clone(),
-            field_indexes,
-        );
+        self.field_indexes.insert(field.clone(), field_indexes);
 
         self.save_field_index(field)?;
 
@@ -214,7 +237,6 @@ impl StructPayloadIndex {
     }
 }
 
-
 impl PayloadIndex for StructPayloadIndex {
     fn indexed_fields(&self) -> Vec<PayloadKeyType> {
         self.config.indexed_fields.clone()
@@ -230,7 +252,13 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn drop_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
-        self.config.indexed_fields = self.config.indexed_fields.iter().cloned().filter(|x| x != field).collect();
+        self.config.indexed_fields = self
+            .config
+            .indexed_fields
+            .iter()
+            .cloned()
+            .filter(|x| x != field)
+            .collect();
         self.save_config()?;
         self.field_indexes.remove(field);
 
@@ -246,45 +274,56 @@ impl PayloadIndex for StructPayloadIndex {
     fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
         let total_points = self.total_points();
 
-        let estimator = |condition: &Condition| {
-            match condition {
-                Condition::Filter(_) => panic!("Unexpected branching"),
-                Condition::HasId(has_id) => {
-                    let id_mapper_ref = self.id_mapper.borrow();
-                    let mapped_ids: HashSet<PointOffsetType> = has_id.has_id.iter()
-                        .filter_map(|external_id| id_mapper_ref.internal_id(*external_id))
-                        .collect();
-                    let num_ids = mapped_ids.len();
-                    CardinalityEstimation {
-                        primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
-                        min: num_ids,
-                        exp: num_ids,
-                        max: num_ids,
-                    }
+        let estimator = |condition: &Condition| match condition {
+            Condition::Filter(_) => panic!("Unexpected branching"),
+            Condition::HasId(has_id) => {
+                let id_mapper_ref = self.id_mapper.borrow();
+                let mapped_ids: HashSet<PointOffsetType> = has_id
+                    .has_id
+                    .iter()
+                    .filter_map(|external_id| id_mapper_ref.internal_id(*external_id))
+                    .collect();
+                let num_ids = mapped_ids.len();
+                CardinalityEstimation {
+                    primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
+                    min: num_ids,
+                    exp: num_ids,
+                    max: num_ids,
                 }
-                Condition::Field(field_condition) => self
-                    .estimate_field_condition(field_condition)
-                    .unwrap_or(CardinalityEstimation::unknown(self.total_points())),
             }
+            Condition::Field(field_condition) => self
+                .estimate_field_condition(field_condition)
+                .unwrap_or(CardinalityEstimation::unknown(self.total_points())),
         };
 
         estimate_filter(&estimator, query, total_points)
     }
 
-    fn payload_blocks(&self, field: &PayloadKeyType, threshold: usize) -> Box<dyn Iterator<Item=PayloadBlockCondition> + '_> {
+    fn payload_blocks(
+        &self,
+        field: &PayloadKeyType,
+        threshold: usize,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         match self.field_indexes.get(field) {
             None => Box::new(vec![].into_iter()),
             Some(indexes) => {
                 let field_clone = field.clone();
-                Box::new(indexes
-                    .iter()
-                    .map(move |field_index| field_index.payload_blocks(threshold, field_clone.clone()))
-                    .flatten())
+                Box::new(
+                    indexes
+                        .iter()
+                        .map(move |field_index| {
+                            field_index.payload_blocks(threshold, field_clone.clone())
+                        })
+                        .flatten(),
+                )
             }
         }
     }
 
-    fn query_points<'a>(&'a self, query: &'a Filter) -> Box<dyn Iterator<Item=PointOffsetType> + 'a> {
+    fn query_points<'a>(
+        &'a self,
+        query: &'a Filter,
+    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
         let vector_storage_ref = self.vector_storage.borrow();
         let condition_checker = self.condition_checker.borrow();
@@ -301,14 +340,19 @@ impl PayloadIndex for StructPayloadIndex {
         } else {
             // CPU-optimized strategy here: points are made unique before applying other filters.
             // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self.visited_pool.get(vector_storage_ref.total_vector_count());
+            let mut visited_list = self
+                .visited_pool
+                .get(vector_storage_ref.total_vector_count());
 
-            let preselected: Vec<PointOffsetType> = query_cardinality.primary_clauses.iter()
+            let preselected: Vec<PointOffsetType> = query_cardinality
+                .primary_clauses
+                .iter()
                 .map(|clause| {
                     match clause {
-                        PrimaryCondition::Condition(field_condition) => self.query_field(field_condition)
+                        PrimaryCondition::Condition(field_condition) => self
+                            .query_field(field_condition)
                             .unwrap_or(vector_storage_ref.iter_ids() /* index is not built */),
-                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned())
+                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned()),
                     }
                 })
                 .flatten()
@@ -322,5 +366,4 @@ impl PayloadIndex for StructPayloadIndex {
             Box::new(matched_points_iter)
         };
     }
-
 }

commit 0e1a6e17507d56e7f6a7f764e7fa56a494753d4d
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 16:51:54 2021 +0100

    [Clippy] Fix a range of warnings (#52)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index dc950f1dc..72b5a502b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -63,8 +63,7 @@ impl StructPayloadIndex {
                 indexes
                     .iter()
                     .map(|field_index| field_index.filter(field_condition))
-                    .skip_while(|filter_iter| filter_iter.is_none())
-                    .next()
+                    .find(|filter_iter| filter_iter.is_some())
                     .map(|filter_iter| filter_iter.unwrap())
             });
         indexes
@@ -293,7 +292,7 @@ impl PayloadIndex for StructPayloadIndex {
             }
             Condition::Field(field_condition) => self
                 .estimate_field_condition(field_condition)
-                .unwrap_or(CardinalityEstimation::unknown(self.total_points())),
+                .unwrap_or_else(|| CardinalityEstimation::unknown(self.total_points())),
         };
 
         estimate_filter(&estimator, query, total_points)
@@ -349,9 +348,11 @@ impl PayloadIndex for StructPayloadIndex {
                 .iter()
                 .map(|clause| {
                     match clause {
-                        PrimaryCondition::Condition(field_condition) => self
-                            .query_field(field_condition)
-                            .unwrap_or(vector_storage_ref.iter_ids() /* index is not built */),
+                        PrimaryCondition::Condition(field_condition) => {
+                            self.query_field(field_condition).unwrap_or_else(
+                                || vector_storage_ref.iter_ids(), /* index is not built */
+                            )
+                        }
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned()),
                     }
                 })

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 72b5a502b..c635896b9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -8,17 +8,19 @@ use itertools::Itertools;
 use log::debug;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::id_mapper::id_mapper::IdMapper;
-use crate::index::field_index::field_index::{FieldIndex, PayloadFieldIndex};
+use crate::id_mapper::IdMapper;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
-use crate::index::index::PayloadIndex;
+use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::visited_pool::VisitedPool;
-use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::types::{Condition, FieldCondition, Filter, PayloadKeyType, PointOffsetType};
-use crate::vector_storage::vector_storage::VectorStorage;
+use crate::index::PayloadIndex;
+use crate::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::types::{
+    Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PointOffsetType,
+};
+use crate::vector_storage::VectorStorage;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -82,11 +84,11 @@ impl StructPayloadIndex {
         path.join(PAYLOAD_FIELD_INDEX_PATH)
     }
 
-    fn get_field_index_path(path: &Path, field: &PayloadKeyType) -> PathBuf {
+    fn get_field_index_path(path: &Path, field: PayloadKeyTypeRef) -> PathBuf {
         Self::get_field_index_dir(path).join(format!("{}.idx", field))
     }
 
-    fn save_field_index(&self, field: &PayloadKeyType) -> OperationResult<()> {
+    fn save_field_index(&self, field: PayloadKeyTypeRef) -> OperationResult<()> {
         let field_index_dir = Self::get_field_index_dir(&self.path);
         let field_index_path = Self::get_field_index_path(&self.path, field);
         create_dir_all(field_index_dir)?;
@@ -107,7 +109,7 @@ impl StructPayloadIndex {
 
     fn load_or_build_field_index(
         &self,
-        field: &PayloadKeyType,
+        field: PayloadKeyTypeRef,
     ) -> OperationResult<Vec<FieldIndex>> {
         let field_index_path = Self::get_field_index_path(&self.path, field);
         if field_index_path.exists() {
@@ -181,7 +183,7 @@ impl StructPayloadIndex {
         Ok(index)
     }
 
-    pub fn build_field_index(&self, field: &PayloadKeyType) -> OperationResult<Vec<FieldIndex>> {
+    pub fn build_field_index(&self, field: PayloadKeyTypeRef) -> OperationResult<Vec<FieldIndex>> {
         let payload_ref = self.payload.borrow();
         let schema = payload_ref.schema();
 
@@ -217,14 +219,14 @@ impl StructPayloadIndex {
         Ok(field_indexes)
     }
 
-    fn build_and_save(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
-        if !self.config.indexed_fields.contains(field) {
-            self.config.indexed_fields.push(field.clone());
+    fn build_and_save(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
+        if !self.config.indexed_fields.iter().any(|x| x == field) {
+            self.config.indexed_fields.push(field.into());
             self.save_config()?;
         }
 
         let field_indexes = self.build_field_index(field)?;
-        self.field_indexes.insert(field.clone(), field_indexes);
+        self.field_indexes.insert(field.into(), field_indexes);
 
         self.save_field_index(field)?;
 
@@ -241,16 +243,16 @@ impl PayloadIndex for StructPayloadIndex {
         self.config.indexed_fields.clone()
     }
 
-    fn set_indexed(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
-        if !self.config.indexed_fields.contains(field) {
-            self.config.indexed_fields.push(field.clone());
+    fn set_indexed(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
+        if !self.config.indexed_fields.iter().any(|x| x == field) {
+            self.config.indexed_fields.push(field.into());
             self.save_config()?;
             self.build_and_save(field)?;
         }
         Ok(())
     }
 
-    fn drop_index(&mut self, field: &PayloadKeyType) -> OperationResult<()> {
+    fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
         self.config.indexed_fields = self
             .config
             .indexed_fields
@@ -300,13 +302,13 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn payload_blocks(
         &self,
-        field: &PayloadKeyType,
+        field: PayloadKeyTypeRef,
         threshold: usize,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         match self.field_indexes.get(field) {
             None => Box::new(vec![].into_iter()),
             Some(indexes) => {
-                let field_clone = field.clone();
+                let field_clone = field.to_owned();
                 Box::new(
                     indexes
                         .iter()

commit 0bd0a1da427db9af97887a865c63a3977333dfc0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jul 30 23:49:02 2021 +0200

    fix new clippy suggestions

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index c635896b9..c10cf4976 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -345,6 +345,7 @@ impl PayloadIndex for StructPayloadIndex {
                 .visited_pool
                 .get(vector_storage_ref.total_vector_count());
 
+            #[allow(clippy::needless_collect)]
             let preselected: Vec<PointOffsetType> = query_cardinality
                 .primary_clauses
                 .iter()

commit f3e8194310af69b13f67317556aa8cae77712536
Author: Alexander Galibey <48586936+galibey@users.noreply.github.com>
Date:   Tue Aug 3 11:35:55 2021 +0300

    Remove AtomicRefCell wrapper for condition checker (#84)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index c10cf4976..17518bf2a 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -27,7 +27,7 @@ pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
 pub struct StructPayloadIndex {
-    condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+    condition_checker: Arc<dyn ConditionChecker>,
     vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
     payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
     id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
@@ -148,7 +148,7 @@ impl StructPayloadIndex {
     }
 
     pub fn open(
-        condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,
+        condition_checker: Arc<dyn ConditionChecker>,
         vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
         payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
         id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
@@ -327,14 +327,13 @@ impl PayloadIndex for StructPayloadIndex {
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
         let vector_storage_ref = self.vector_storage.borrow();
-        let condition_checker = self.condition_checker.borrow();
 
         let query_cardinality = self.estimate_cardinality(query);
         return if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator = vector_storage_ref.iter_ids();
             // Worst case: query expected to return few matches, but index can't be used
             let matched_points = full_scan_iterator
-                .filter(|i| condition_checker.check(*i, query))
+                .filter(|i| self.condition_checker.check(*i, query))
                 .collect_vec();
 
             Box::new(matched_points.into_iter())
@@ -361,7 +360,7 @@ impl PayloadIndex for StructPayloadIndex {
                 })
                 .flatten()
                 .filter(|id| !visited_list.check_and_update_visited(*id))
-                .filter(move |i| condition_checker.check(*i, query))
+                .filter(move |i| self.condition_checker.check(*i, query))
                 .collect();
 
             self.visited_pool.return_back(visited_list);

commit bf3d8c25753188b4ca5e69a13c7f26e3c383f05b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Oct 24 18:10:39 2021 +0200

    data consistency fixes and updates (#112)
    
    * update segment version after completed update only
    
    * more stable updates: check pre-existing points on update, fail recovery, WAL proper ack. check_unprocessed_points WIP
    
    * switch to async channel
    
    * perform update operations in a separate thread (#111)
    
    * perform update operations in a separate thread
    
    * ordered sending update signal
    
    * locate a segment merging versioning bug
    
    * rename id_mapper -> id_tracker
    
    * per-record versioning
    
    * clippy fixes
    
    * cargo fmt
    
    * rm limit of open files
    
    * fail recovery test
    
    * cargo fmt
    
    * wait for worker stops befor dropping the runtime

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 17518bf2a..256baf32e 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -8,7 +8,7 @@ use itertools::Itertools;
 use log::debug;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::id_mapper::IdMapper;
+use crate::id_tracker::IdTracker;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
 use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
@@ -30,7 +30,7 @@ pub struct StructPayloadIndex {
     condition_checker: Arc<dyn ConditionChecker>,
     vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
     payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-    id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+    id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
     field_indexes: IndexesMap,
     config: PayloadConfig,
     path: PathBuf,
@@ -151,7 +151,7 @@ impl StructPayloadIndex {
         condition_checker: Arc<dyn ConditionChecker>,
         vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
         payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+        id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
         path: &Path,
     ) -> OperationResult<Self> {
         create_dir_all(path)?;
@@ -166,7 +166,7 @@ impl StructPayloadIndex {
             condition_checker,
             vector_storage,
             payload,
-            id_mapper,
+            id_tracker,
             field_indexes: Default::default(),
             config,
             path: path.to_owned(),
@@ -278,11 +278,11 @@ impl PayloadIndex for StructPayloadIndex {
         let estimator = |condition: &Condition| match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
             Condition::HasId(has_id) => {
-                let id_mapper_ref = self.id_mapper.borrow();
+                let id_tracker_ref = self.id_tracker.borrow();
                 let mapped_ids: HashSet<PointOffsetType> = has_id
                     .has_id
                     .iter()
-                    .filter_map(|external_id| id_mapper_ref.internal_id(*external_id))
+                    .filter_map(|external_id| id_tracker_ref.internal_id(*external_id))
                     .collect();
                 let num_ids = mapped_ids.len();
                 CardinalityEstimation {

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 256baf32e..f2cc8544d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -96,7 +96,7 @@ impl StructPayloadIndex {
         match self.field_indexes.get(field) {
             None => {}
             Some(indexes) => {
-                let file = File::create(field_index_path.as_path())?;
+                let file = File::create(&field_index_path)?;
                 serde_cbor::to_writer(file, indexes).map_err(|err| {
                     OperationError::ServiceError {
                         description: format!("Unable to save index: {:?}", err),
@@ -139,7 +139,7 @@ impl StructPayloadIndex {
 
     fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
-        for field in self.config.indexed_fields.iter() {
+        for field in &self.config.indexed_fields {
             let field_index = self.load_or_build_field_index(field)?;
             field_indexes.insert(field.clone(), field_index);
         }
@@ -204,7 +204,7 @@ impl StructPayloadIndex {
             match field_value_opt {
                 None => {}
                 Some(field_value) => {
-                    for builder in builders.iter_mut() {
+                    for builder in &mut builders {
                         builder.add(point_id, field_value)
                     }
                 }
@@ -309,14 +309,9 @@ impl PayloadIndex for StructPayloadIndex {
             None => Box::new(vec![].into_iter()),
             Some(indexes) => {
                 let field_clone = field.to_owned();
-                Box::new(
-                    indexes
-                        .iter()
-                        .map(move |field_index| {
-                            field_index.payload_blocks(threshold, field_clone.clone())
-                        })
-                        .flatten(),
-                )
+                Box::new(indexes.iter().flat_map(move |field_index| {
+                    field_index.payload_blocks(threshold, field_clone.clone())
+                }))
             }
         }
     }
@@ -348,7 +343,7 @@ impl PayloadIndex for StructPayloadIndex {
             let preselected: Vec<PointOffsetType> = query_cardinality
                 .primary_clauses
                 .iter()
-                .map(|clause| {
+                .flat_map(|clause| {
                     match clause {
                         PrimaryCondition::Condition(field_condition) => {
                             self.query_field(field_condition).unwrap_or_else(
@@ -358,9 +353,8 @@ impl PayloadIndex for StructPayloadIndex {
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned()),
                     }
                 })
-                .flatten()
-                .filter(|id| !visited_list.check_and_update_visited(*id))
-                .filter(move |i| self.condition_checker.check(*i, query))
+                .filter(|&id| !visited_list.check_and_update_visited(id))
+                .filter(move |&i| self.condition_checker.check(i, query))
                 .collect();
 
             self.visited_pool.return_back(visited_list);

commit 617b97d3f7faee4c44913c3adf68935f4e47c47b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Dec 9 11:06:25 2021 +0100

    add comments for segment entitites (#136)
    
    * add comments for segment entitites
    
    * fmt
    
    * cargo fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index f2cc8544d..96d790e22 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -26,13 +26,17 @@ pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
 type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
+/// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
     condition_checker: Arc<dyn ConditionChecker>,
     vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
+    /// Payload storage
     payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
     id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
+    /// Indexes, associated with fields
     field_indexes: IndexesMap,
     config: PayloadConfig,
+    /// Root of index persistence dir
     path: PathBuf,
     visited_pool: VisitedPool,
 }
@@ -300,22 +304,6 @@ impl PayloadIndex for StructPayloadIndex {
         estimate_filter(&estimator, query, total_points)
     }
 
-    fn payload_blocks(
-        &self,
-        field: PayloadKeyTypeRef,
-        threshold: usize,
-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
-        match self.field_indexes.get(field) {
-            None => Box::new(vec![].into_iter()),
-            Some(indexes) => {
-                let field_clone = field.to_owned();
-                Box::new(indexes.iter().flat_map(move |field_index| {
-                    field_index.payload_blocks(threshold, field_clone.clone())
-                }))
-            }
-        }
-    }
-
     fn query_points<'a>(
         &'a self,
         query: &'a Filter,
@@ -363,4 +351,20 @@ impl PayloadIndex for StructPayloadIndex {
             Box::new(matched_points_iter)
         };
     }
+
+    fn payload_blocks(
+        &self,
+        field: PayloadKeyTypeRef,
+        threshold: usize,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+        match self.field_indexes.get(field) {
+            None => Box::new(vec![].into_iter()),
+            Some(indexes) => {
+                let field_clone = field.to_owned();
+                Box::new(indexes.iter().flat_map(move |field_index| {
+                    field_index.payload_blocks(threshold, field_clone.clone())
+                }))
+            }
+        }
+    }
 }

commit 57fa65072f0b742662a9be5ef7f6840cddf5c6e1
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:36 2022 +0400

    use copied instead of cloned (#174)
    
    * use copied instead of cloned
    
    https://rust-lang.github.io/rust-clippy/master/index.html#cloned_instead_of_copied
    
    * use copied instead of cloned

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 96d790e22..fe399f2ad 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -338,7 +338,7 @@ impl PayloadIndex for StructPayloadIndex {
                                 || vector_storage_ref.iter_ids(), /* index is not built */
                             )
                         }
-                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().cloned()),
+                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
                     }
                 })
                 .filter(|&id| !visited_list.check_and_update_visited(id))

commit 298685102c3979b47793ac2c57f0e263a5697346
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:46 2022 +0400

    add missing commas (#173)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index fe399f2ad..dbc949499 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -179,7 +179,7 @@ impl StructPayloadIndex {
 
         if !index.config_path().exists() {
             // Save default config
-            index.save_config()?
+            index.save_config()?;
         }
 
         index.load_all_fields()?;
@@ -209,7 +209,7 @@ impl StructPayloadIndex {
                 None => {}
                 Some(field_value) => {
                     for builder in &mut builders {
-                        builder.add(point_id, field_value)
+                        builder.add(point_id, field_value);
                     }
                 }
             }

commit ee461ce0a6cc031e8289bc7a238bb2e807e85b20
Author: Prokudin Alexander <prok20@inbox.ru>
Date:   Tue Jan 18 01:33:26 2022 +0300

    Extend clippy to workspace and fix some warnings (#199)
    
    * Fix clippy in linting workflow
    
    * Add toolchain override flag
    
    * Add components to toolchain installation explicitly
    
    * Add --workspace flag to clippy to check all packages
    
    * Remove unnecessary clones
    
    * remove redundant .clone() calls
    
    * fix wrong arguments order in tests (typo)
    
    * Fix vec! macro usage in test
    
    * Correct redundant assert! usages
    
    * Provide a quick fix for 'unused' test function lint
    
    * fix unsound Send + Sync
    
    * fix clippy complains
    
    * fmt
    
    * fix clippy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index dbc949499..9adb33921 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -8,7 +8,7 @@ use itertools::Itertools;
 use log::debug;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::id_tracker::IdTracker;
+use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
 use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
@@ -16,11 +16,11 @@ use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
-use crate::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::payload_storage::{ConditionCheckerSS, PayloadStorageSS};
 use crate::types::{
     Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PointOffsetType,
 };
-use crate::vector_storage::VectorStorage;
+use crate::vector_storage::VectorStorageSS;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -28,11 +28,11 @@ type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
-    condition_checker: Arc<dyn ConditionChecker>,
-    vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
+    condition_checker: Arc<ConditionCheckerSS>,
+    vector_storage: Arc<AtomicRefCell<VectorStorageSS>>,
     /// Payload storage
-    payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-    id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
+    payload: Arc<AtomicRefCell<PayloadStorageSS>>,
+    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Indexes, associated with fields
     field_indexes: IndexesMap,
     config: PayloadConfig,
@@ -152,10 +152,10 @@ impl StructPayloadIndex {
     }
 
     pub fn open(
-        condition_checker: Arc<dyn ConditionChecker>,
-        vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,
-        payload: Arc<AtomicRefCell<dyn PayloadStorage>>,
-        id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
+        condition_checker: Arc<ConditionCheckerSS>,
+        vector_storage: Arc<AtomicRefCell<VectorStorageSS>>,
+        payload: Arc<AtomicRefCell<PayloadStorageSS>>,
+        id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
         path: &Path,
     ) -> OperationResult<Self> {
         create_dir_all(path)?;

commit e45379e4384062e92ee1c9be82c250047464c9ef
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 16 09:59:11 2022 +0100

    Better optimizer error reporting + small bug fixes (#316)
    
    * optimizer error reporting, decouple data removing, optimizator fix
    
    * fmt
    
    * fmt + clippy
    
    * update openapi

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 9adb33921..90541aec9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -102,9 +102,7 @@ impl StructPayloadIndex {
             Some(indexes) => {
                 let file = File::create(&field_index_path)?;
                 serde_cbor::to_writer(file, indexes).map_err(|err| {
-                    OperationError::ServiceError {
-                        description: format!("Unable to save index: {:?}", err),
-                    }
+                    OperationError::service_error(&format!("Unable to save index: {:?}", err))
                 })?;
             }
         }
@@ -123,10 +121,9 @@ impl StructPayloadIndex {
                 field_index_path.to_str().unwrap()
             );
             let file = File::open(field_index_path)?;
-            let field_indexes: Vec<FieldIndex> =
-                serde_cbor::from_reader(file).map_err(|err| OperationError::ServiceError {
-                    description: format!("Unable to load index: {:?}", err),
-                })?;
+            let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file).map_err(|err| {
+                OperationError::service_error(&format!("Unable to load index: {:?}", err))
+            })?;
 
             Ok(field_indexes)
         } else {

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 90541aec9..1fb8851f0 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -18,7 +18,8 @@ use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::{ConditionCheckerSS, PayloadStorageSS};
 use crate::types::{
-    Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PointOffsetType,
+    Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
+    PointOffsetType,
 };
 use crate::vector_storage::VectorStorageSS;
 
@@ -112,6 +113,7 @@ impl StructPayloadIndex {
     fn load_or_build_field_index(
         &self,
         field: PayloadKeyTypeRef,
+        payload_type: PayloadSchemaType,
     ) -> OperationResult<Vec<FieldIndex>> {
         let field_index_path = Self::get_field_index_path(&self.path, field);
         if field_index_path.exists() {
@@ -132,7 +134,7 @@ impl StructPayloadIndex {
                 field,
                 field_index_path.to_str().unwrap()
             );
-            let res = self.build_field_index(field)?;
+            let res = self.build_field_index(field, payload_type)?;
             self.save_field_index(field)?;
             Ok(res)
         }
@@ -140,8 +142,8 @@ impl StructPayloadIndex {
 
     fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
-        for field in &self.config.indexed_fields {
-            let field_index = self.load_or_build_field_index(field)?;
+        for (field, payload_type) in &self.config.indexed_fields {
+            let field_index = self.load_or_build_field_index(field, payload_type.to_owned())?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;
@@ -184,30 +186,20 @@ impl StructPayloadIndex {
         Ok(index)
     }
 
-    pub fn build_field_index(&self, field: PayloadKeyTypeRef) -> OperationResult<Vec<FieldIndex>> {
-        let payload_ref = self.payload.borrow();
-        let schema = payload_ref.schema();
-
-        let field_type_opt = schema.get(field);
-
-        if field_type_opt.is_none() {
-            // There is not data to index
-            return Ok(vec![]);
-        }
-
-        let field_type = field_type_opt.unwrap();
-
-        let mut builders = index_selector(field_type);
-
-        for point_id in payload_ref.iter_ids() {
-            let point_payload = payload_ref.payload(point_id);
-            let field_value_opt = point_payload.get(field);
-            match field_value_opt {
-                None => {}
-                Some(field_value) => {
-                    for builder in &mut builders {
-                        builder.add(point_id, field_value);
-                    }
+    pub fn build_field_index(
+        &self,
+        field: PayloadKeyTypeRef,
+        field_type: PayloadSchemaType,
+    ) -> OperationResult<Vec<FieldIndex>> {
+        let payload_storage = self.payload.borrow();
+
+        let mut builders = index_selector(&field_type);
+        for point_id in payload_storage.iter_ids() {
+            let point_payload = payload_storage.payload(point_id);
+            let field_value_opt = point_payload.get_value(field);
+            if let Some(field_value) = field_value_opt {
+                for builder in &mut builders {
+                    builder.add(point_id, field_value);
                 }
             }
         }
@@ -220,13 +212,12 @@ impl StructPayloadIndex {
         Ok(field_indexes)
     }
 
-    fn build_and_save(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
-        if !self.config.indexed_fields.iter().any(|x| x == field) {
-            self.config.indexed_fields.push(field.into());
-            self.save_config()?;
-        }
-
-        let field_indexes = self.build_field_index(field)?;
+    fn build_and_save(
+        &mut self,
+        field: PayloadKeyTypeRef,
+        payload_type: PayloadSchemaType,
+    ) -> OperationResult<()> {
+        let field_indexes = self.build_field_index(field, payload_type)?;
         self.field_indexes.insert(field.into(), field_indexes);
 
         self.save_field_index(field)?;
@@ -240,27 +231,30 @@ impl StructPayloadIndex {
 }
 
 impl PayloadIndex for StructPayloadIndex {
-    fn indexed_fields(&self) -> Vec<PayloadKeyType> {
+    fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadSchemaType> {
         self.config.indexed_fields.clone()
     }
 
-    fn set_indexed(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
-        if !self.config.indexed_fields.iter().any(|x| x == field) {
-            self.config.indexed_fields.push(field.into());
+    fn set_indexed(
+        &mut self,
+        field: PayloadKeyTypeRef,
+        payload_type: PayloadSchemaType,
+    ) -> OperationResult<()> {
+        if self
+            .config
+            .indexed_fields
+            .insert(field.to_owned(), payload_type)
+            .is_none()
+        {
             self.save_config()?;
-            self.build_and_save(field)?;
+            self.build_and_save(field, payload_type)?;
         }
+
         Ok(())
     }
 
     fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
-        self.config.indexed_fields = self
-            .config
-            .indexed_fields
-            .iter()
-            .cloned()
-            .filter(|x| x != field)
-            .collect();
+        self.config.indexed_fields.remove(field);
         self.save_config()?;
         self.field_indexes.remove(field);
 

commit c29c9a46d46c22d3210e61cc3a111747ace31fb1
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Thu Mar 31 08:57:18 2022 -0300

    [json storage] Filtering context (#413)
    
    * [WIP] add a basic filtering context scaffold
    
    * add PlainFilterContext and StructFilterContext

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 1fb8851f0..8e24d1bc4 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -16,7 +16,7 @@ use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
-use crate::payload_storage::{ConditionCheckerSS, PayloadStorageSS};
+use crate::payload_storage::{ConditionCheckerSS, FilterContext, PayloadStorageSS};
 use crate::types::{
     Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
     PointOffsetType,
@@ -343,6 +343,13 @@ impl PayloadIndex for StructPayloadIndex {
         };
     }
 
+    fn filter_context<'a>(&'a self, filter: &'a Filter) -> Box<dyn FilterContext + 'a> {
+        Box::new(StructFilterContext {
+            filter,
+            condition_checker: self.condition_checker.clone(),
+        })
+    }
+
     fn payload_blocks(
         &self,
         field: PayloadKeyTypeRef,
@@ -359,3 +366,14 @@ impl PayloadIndex for StructPayloadIndex {
         }
     }
 }
+
+pub struct StructFilterContext<'a> {
+    condition_checker: Arc<ConditionCheckerSS>,
+    filter: &'a Filter,
+}
+
+impl<'a> FilterContext for StructFilterContext<'a> {
+    fn check(&self, point_id: PointOffsetType) -> bool {
+        self.condition_checker.check(point_id, self.filter)
+    }
+}

commit b07428f62011602b78567225026633592df4cc3c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Apr 3 16:55:51 2022 +0200

    Is empty condition (#423)
    
    * is-empty condition
    
    * fmt
    
    * better assert
    
    * fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 8e24d1bc4..678d599ce 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -18,8 +18,8 @@ use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::{ConditionCheckerSS, FilterContext, PayloadStorageSS};
 use crate::types::{
-    Condition, FieldCondition, Filter, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
-    PointOffsetType,
+    Condition, FieldCondition, Filter, IsEmptyCondition, PayloadKeyType, PayloadKeyTypeRef,
+    PayloadSchemaType, PointOffsetType,
 };
 use crate::vector_storage::VectorStorageSS;
 
@@ -272,6 +272,33 @@ impl PayloadIndex for StructPayloadIndex {
 
         let estimator = |condition: &Condition| match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
+            Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
+                let total_points = self.total_points();
+
+                let mut indexed_points = 0;
+                if let Some(field_indexes) = self.field_indexes.get(&field.key) {
+                    for index in field_indexes {
+                        indexed_points = indexed_points.max(index.count_indexed_points())
+                    }
+                    CardinalityEstimation {
+                        primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
+                            is_empty: field.to_owned(),
+                        })],
+                        min: 0, // It is possible, that some non-empty payloads are not indexed
+                        exp: total_points.saturating_sub(indexed_points), // Expect field type consistency
+                        max: total_points.saturating_sub(indexed_points),
+                    }
+                } else {
+                    CardinalityEstimation {
+                        primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
+                            is_empty: field.to_owned(),
+                        })],
+                        min: 0,
+                        exp: total_points / 2,
+                        max: total_points,
+                    }
+                }
+            }
             Condition::HasId(has_id) => {
                 let id_tracker_ref = self.id_tracker.borrow();
                 let mapped_ids: HashSet<PointOffsetType> = has_id
@@ -319,7 +346,7 @@ impl PayloadIndex for StructPayloadIndex {
                 .get(vector_storage_ref.total_vector_count());
 
             #[allow(clippy::needless_collect)]
-            let preselected: Vec<PointOffsetType> = query_cardinality
+                let preselected: Vec<PointOffsetType> = query_cardinality
                 .primary_clauses
                 .iter()
                 .flat_map(|clause| {
@@ -330,6 +357,7 @@ impl PayloadIndex for StructPayloadIndex {
                             )
                         }
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
+                        PrimaryCondition::IsEmpty(_) => vector_storage_ref.iter_ids() /* there are no fast index for IsEmpty */
                     }
                 })
                 .filter(|&id| !visited_list.check_and_update_visited(id))

commit ef67a2ec59180ca599b0c61cc957c45a56454410
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:43:02 2022 +0200

    Condition search benchmark (#435)
    
    * decouple payload index and vector storage
    
    * wip: test fixtures
    
    * conditional search benchmark
    
    * fmt
    
    * use arc iterator for filtered queries
    
    * fmt
    
    * enable all benches
    
    * fix warn
    
    * upd tests
    
    * fmt
    
    * Update lib/segment/src/fixtures/payload_context_fixture.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 678d599ce..a033c7bfc 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -3,11 +3,13 @@ use std::fs::{create_dir_all, remove_file, File};
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use atomic_refcell::AtomicRefCell;
 use itertools::Itertools;
 use log::debug;
 
 use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::id_tracker::points_iterator::PointsIteratorSS;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
@@ -21,7 +23,6 @@ use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, PayloadKeyType, PayloadKeyTypeRef,
     PayloadSchemaType, PointOffsetType,
 };
-use crate::vector_storage::VectorStorageSS;
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
@@ -30,7 +31,7 @@ type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
     condition_checker: Arc<ConditionCheckerSS>,
-    vector_storage: Arc<AtomicRefCell<VectorStorageSS>>,
+    points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
     /// Payload storage
     payload: Arc<AtomicRefCell<PayloadStorageSS>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
@@ -152,7 +153,7 @@ impl StructPayloadIndex {
 
     pub fn open(
         condition_checker: Arc<ConditionCheckerSS>,
-        vector_storage: Arc<AtomicRefCell<VectorStorageSS>>,
+        points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
         payload: Arc<AtomicRefCell<PayloadStorageSS>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
         path: &Path,
@@ -167,7 +168,7 @@ impl StructPayloadIndex {
 
         let mut index = StructPayloadIndex {
             condition_checker,
-            vector_storage,
+            points_iterator,
             payload,
             id_tracker,
             field_indexes: Default::default(),
@@ -226,7 +227,7 @@ impl StructPayloadIndex {
     }
 
     pub fn total_points(&self) -> usize {
-        self.vector_storage.borrow().vector_count()
+        self.points_iterator.borrow().points_count()
     }
 }
 
@@ -327,23 +328,25 @@ impl PayloadIndex for StructPayloadIndex {
         query: &'a Filter,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
-        let vector_storage_ref = self.vector_storage.borrow();
 
         let query_cardinality = self.estimate_cardinality(query);
         return if query_cardinality.primary_clauses.is_empty() {
-            let full_scan_iterator = vector_storage_ref.iter_ids();
+            let full_scan_iterator =
+                ArcAtomicRefCellIterator::new(self.points_iterator.clone(), |points_iterator| {
+                    points_iterator.iter_ids()
+                });
+
             // Worst case: query expected to return few matches, but index can't be used
-            let matched_points = full_scan_iterator
-                .filter(|i| self.condition_checker.check(*i, query))
-                .collect_vec();
+            let matched_points =
+                full_scan_iterator.filter(|i| self.condition_checker.check(*i, query));
 
-            Box::new(matched_points.into_iter())
+            Box::new(matched_points)
         } else {
+            let points_iterator_ref = self.points_iterator.borrow();
+
             // CPU-optimized strategy here: points are made unique before applying other filters.
             // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self
-                .visited_pool
-                .get(vector_storage_ref.total_vector_count());
+            let mut visited_list = self.visited_pool.get(points_iterator_ref.max_id() as usize);
 
             #[allow(clippy::needless_collect)]
                 let preselected: Vec<PointOffsetType> = query_cardinality
@@ -353,11 +356,11 @@ impl PayloadIndex for StructPayloadIndex {
                     match clause {
                         PrimaryCondition::Condition(field_condition) => {
                             self.query_field(field_condition).unwrap_or_else(
-                                || vector_storage_ref.iter_ids(), /* index is not built */
+                                || points_iterator_ref.iter_ids(), /* index is not built */
                             )
                         }
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
-                        PrimaryCondition::IsEmpty(_) => vector_storage_ref.iter_ids() /* there are no fast index for IsEmpty */
+                        PrimaryCondition::IsEmpty(_) => points_iterator_ref.iter_ids() /* there are no fast index for IsEmpty */
                     }
                 })
                 .filter(|&id| !visited_list.check_and_update_visited(id))

commit f7d52244a72bf0f49a662c05a8562d726260b906
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:48:07 2022 +0200

    Column oriented filter context (#456)
    
    * [WIP] column oriented filter context
    
    * suggestion
    
    * [WIP] fix lifetimes and add more checkers
    
    * refactor and externd struct filter context
    
    * fmt
    
    * add type alias for the condition checker
    
    * fmt
    
    Co-authored-by: gabriel velo <gabriel.velo@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a033c7bfc..1f4400b30 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -16,6 +16,7 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, Pr
 use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
+use crate::index::struct_filter_context::{IndexesMap, StructFilterContext};
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::{ConditionCheckerSS, FilterContext, PayloadStorageSS};
@@ -26,8 +27,6 @@ use crate::types::{
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
-type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;
-
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
     condition_checker: Arc<ConditionCheckerSS>,
@@ -375,10 +374,12 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn filter_context<'a>(&'a self, filter: &'a Filter) -> Box<dyn FilterContext + 'a> {
-        Box::new(StructFilterContext {
+        Box::new(StructFilterContext::new(
+            self.condition_checker.clone(),
             filter,
-            condition_checker: self.condition_checker.clone(),
-        })
+            &self.field_indexes,
+            self.estimate_cardinality(filter),
+        ))
     }
 
     fn payload_blocks(
@@ -397,14 +398,3 @@ impl PayloadIndex for StructPayloadIndex {
         }
     }
 }
-
-pub struct StructFilterContext<'a> {
-    condition_checker: Arc<ConditionCheckerSS>,
-    filter: &'a Filter,
-}
-
-impl<'a> FilterContext for StructFilterContext<'a> {
-    fn check(&self, point_id: PointOffsetType) -> bool {
-        self.condition_checker.check(point_id, self.filter)
-    }
-}

commit bc6df8bd12327ea3a88aecf94a0a2a26b3b70506
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 19 16:04:55 2022 +0200

    Better use of column index (#461)
    
    * fmt
    
    * remove redundent condition checker
    
    * remove condition_checker from test
    
    * fmt
    
    * enum_dispatch for payload storage
    
    * rm unused imports
    
    * fmt
    
    * replace enum_dispatch with manual stuff
    
    * fmt
    
    * filter optiizer
    
    * cargo fix
    
    * fmt
    
    * refactor callback approach to payload checking
    
    * cargo fix
    
    * cargo fix
    
    * fix
    
    * fmt
    
    * more filtering condition random fixture types
    
    * clippy
    
    * fmt
    
    * restore lost value counts test
    
    * Update lib/segment/src/index/query_optimization/optimized_filter.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 1f4400b30..485fc09c9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,6 +1,8 @@
 use std::collections::{HashMap, HashSet};
 use std::fs::{create_dir_all, remove_file, File};
+use std::ops::Deref;
 use std::path::{Path, PathBuf};
+
 use std::sync::Arc;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
@@ -16,10 +18,13 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, Pr
 use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
-use crate::index::struct_filter_context::{IndexesMap, StructFilterContext};
+use crate::index::query_optimization::optimizer::IndexesMap;
+use crate::index::query_optimization::payload_provider::PayloadProvider;
+use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
-use crate::payload_storage::{ConditionCheckerSS, FilterContext, PayloadStorageSS};
+use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
+use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, PayloadKeyType, PayloadKeyTypeRef,
     PayloadSchemaType, PointOffsetType,
@@ -29,10 +34,9 @@ pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
-    condition_checker: Arc<ConditionCheckerSS>,
     points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
     /// Payload storage
-    payload: Arc<AtomicRefCell<PayloadStorageSS>>,
+    payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Indexes, associated with fields
     field_indexes: IndexesMap,
@@ -151,9 +155,8 @@ impl StructPayloadIndex {
     }
 
     pub fn open(
-        condition_checker: Arc<ConditionCheckerSS>,
         points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
-        payload: Arc<AtomicRefCell<PayloadStorageSS>>,
+        payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
         path: &Path,
     ) -> OperationResult<Self> {
@@ -166,7 +169,6 @@ impl StructPayloadIndex {
         };
 
         let mut index = StructPayloadIndex {
-            condition_checker,
             points_iterator,
             payload,
             id_tracker,
@@ -228,49 +230,23 @@ impl StructPayloadIndex {
     pub fn total_points(&self) -> usize {
         self.points_iterator.borrow().points_count()
     }
-}
-
-impl PayloadIndex for StructPayloadIndex {
-    fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadSchemaType> {
-        self.config.indexed_fields.clone()
-    }
 
-    fn set_indexed(
-        &mut self,
-        field: PayloadKeyTypeRef,
-        payload_type: PayloadSchemaType,
-    ) -> OperationResult<()> {
-        if self
-            .config
-            .indexed_fields
-            .insert(field.to_owned(), payload_type)
-            .is_none()
-        {
-            self.save_config()?;
-            self.build_and_save(field, payload_type)?;
-        }
-
-        Ok(())
-    }
-
-    fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
-        self.config.indexed_fields.remove(field);
-        self.save_config()?;
-        self.field_indexes.remove(field);
-
-        let field_index_path = Self::get_field_index_path(&self.path, field);
-
-        if field_index_path.exists() {
-            remove_file(&field_index_path)?;
-        }
-
-        Ok(())
+    fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
+        let estimator = |condition: &Condition| self.condition_cardinality(condition);
+        let id_tracker = self.id_tracker.borrow();
+        let payload_provider = PayloadProvider::new(self.payload.clone());
+        StructFilterContext::new(
+            filter,
+            id_tracker.deref(),
+            payload_provider,
+            &self.field_indexes,
+            &estimator,
+            self.total_points(),
+        )
     }
 
-    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
-        let total_points = self.total_points();
-
-        let estimator = |condition: &Condition| match condition {
+    fn condition_cardinality(&self, condition: &Condition) -> CardinalityEstimation {
+        match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
                 let total_points = self.total_points();
@@ -317,7 +293,51 @@ impl PayloadIndex for StructPayloadIndex {
             Condition::Field(field_condition) => self
                 .estimate_field_condition(field_condition)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.total_points())),
-        };
+        }
+    }
+}
+
+impl PayloadIndex for StructPayloadIndex {
+    fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadSchemaType> {
+        self.config.indexed_fields.clone()
+    }
+
+    fn set_indexed(
+        &mut self,
+        field: PayloadKeyTypeRef,
+        payload_type: PayloadSchemaType,
+    ) -> OperationResult<()> {
+        if self
+            .config
+            .indexed_fields
+            .insert(field.to_owned(), payload_type)
+            .is_none()
+        {
+            self.save_config()?;
+            self.build_and_save(field, payload_type)?;
+        }
+
+        Ok(())
+    }
+
+    fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
+        self.config.indexed_fields.remove(field);
+        self.save_config()?;
+        self.field_indexes.remove(field);
+
+        let field_index_path = Self::get_field_index_path(&self.path, field);
+
+        if field_index_path.exists() {
+            remove_file(&field_index_path)?;
+        }
+
+        Ok(())
+    }
+
+    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
+        let total_points = self.total_points();
+
+        let estimator = |condition: &Condition| self.condition_cardinality(condition);
 
         estimate_filter(&estimator, query, total_points)
     }
@@ -335,13 +355,15 @@ impl PayloadIndex for StructPayloadIndex {
                     points_iterator.iter_ids()
                 });
 
+            let struct_filtered_context = self.struct_filtered_context(query);
             // Worst case: query expected to return few matches, but index can't be used
             let matched_points =
-                full_scan_iterator.filter(|i| self.condition_checker.check(*i, query));
+                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
 
             Box::new(matched_points)
         } else {
             let points_iterator_ref = self.points_iterator.borrow();
+            let struct_filtered_context = self.struct_filtered_context(query);
 
             // CPU-optimized strategy here: points are made unique before applying other filters.
             // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
@@ -363,7 +385,7 @@ impl PayloadIndex for StructPayloadIndex {
                     }
                 })
                 .filter(|&id| !visited_list.check_and_update_visited(id))
-                .filter(move |&i| self.condition_checker.check(i, query))
+                .filter(move |&i| struct_filtered_context.check(i))
                 .collect();
 
             self.visited_pool.return_back(visited_list);
@@ -374,12 +396,7 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn filter_context<'a>(&'a self, filter: &'a Filter) -> Box<dyn FilterContext + 'a> {
-        Box::new(StructFilterContext::new(
-            self.condition_checker.clone(),
-            filter,
-            &self.field_indexes,
-            self.estimate_cardinality(filter),
-        ))
+        Box::new(self.struct_filtered_context(filter))
     }
 
     fn payload_blocks(

commit 1b458780eb196ebbbd7fb1f6c5d85ce3b15adb64
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 1 17:23:34 2022 +0200

    On disk payload storage (#634)
    
    * implement on-disk payload storage
    
    * fmt + clippy
    
    * config param for on-disk payload storage
    
    * upd openapi definitions
    
    * add integration test with on-disk payload
    
    * fix clippy
    
    * review fixes
    
    * fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 485fc09c9..3dca1cd6d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -24,7 +24,7 @@ use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
-use crate::payload_storage::{FilterContext, PayloadStorage};
+use crate::payload_storage::FilterContext;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, PayloadKeyType, PayloadKeyTypeRef,
     PayloadSchemaType, PointOffsetType,
@@ -196,15 +196,15 @@ impl StructPayloadIndex {
         let payload_storage = self.payload.borrow();
 
         let mut builders = index_selector(&field_type);
-        for point_id in payload_storage.iter_ids() {
-            let point_payload = payload_storage.payload(point_id);
+        payload_storage.iter(|point_id, point_payload| {
             let field_value_opt = point_payload.get_value(field);
             if let Some(field_value) = field_value_opt {
                 for builder in &mut builders {
                     builder.add(point_id, field_value);
                 }
             }
-        }
+            true
+        })?;
 
         let field_indexes = builders
             .iter_mut()

commit c15981092ac33c7dde9541ab4a2df558e6abe4e6
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Jun 6 12:14:20 2022 -0300

    [WIP] [real-time index] Implement payloadstorage for structpayloadindex (#642)
    
    * [real-time index] Extend FieldIndex enum and StructPayloadIndex with method from PayloadStorage
    
    * [real-time index] add missing remove_point methods
    
    * [real-time index] add new index to FieldIndex enum
    
    * fix compile
    
    * are you happy fmt
    
    * merge load and remove
    
    * fix test generics
    
    * decrement points count
    
    * remove from histogram
    
    * simplify histogram usage
    
    * [real-time index] remove old tests and fix clippy warnings
    
    * histogram: method to derive range by size (#657)
    
    * [real-time index] add histogram based payload_blocks implementation.
    
    * payload blocks
    
    * fmt
    
    * clippy
    
    * [real-time index] refactor Segment to use PayloadIndex instead of PayloadStorage.
    
    * fix tests
    
    * fmt
    
    * clippy
    
    * rename indexes
    
    * remove redundent params
    
    * add struct payload deletion test + fix delete payload in map index
    
    * remove payload threshold
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 3dca1cd6d..4851d37a4 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,21 +1,23 @@
 use std::collections::{HashMap, HashSet};
-use std::fs::{create_dir_all, remove_file, File};
+use std::fs::{create_dir_all, remove_file};
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 
 use std::sync::Arc;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
+use crate::common::rocksdb_operations::open_db_with_existing_cf;
 use atomic_refcell::AtomicRefCell;
-use itertools::Itertools;
 use log::debug;
+use rocksdb::DB;
+use schemars::_serde_json::Value;
 
-use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::entry::entry_point::OperationResult;
 use crate::id_tracker::points_iterator::PointsIteratorSS;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
+use crate::index::field_index::FieldIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
-use crate::index::field_index::{FieldIndex, PayloadFieldIndex};
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::optimizer::IndexesMap;
@@ -24,10 +26,10 @@ use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
-use crate::payload_storage::FilterContext;
+use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::types::{
-    Condition, FieldCondition, Filter, IsEmptyCondition, PayloadKeyType, PayloadKeyTypeRef,
-    PayloadSchemaType, PointOffsetType,
+    infer_value_type, Condition, FieldCondition, Filter, IsEmptyCondition, Payload, PayloadKeyType,
+    PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
@@ -39,11 +41,12 @@ pub struct StructPayloadIndex {
     payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Indexes, associated with fields
-    field_indexes: IndexesMap,
+    pub field_indexes: IndexesMap,
     config: PayloadConfig,
     /// Root of index persistence dir
     path: PathBuf,
     visited_pool: VisitedPool,
+    db: Arc<AtomicRefCell<DB>>,
 }
 
 impl StructPayloadIndex {
@@ -97,61 +100,37 @@ impl StructPayloadIndex {
         Self::get_field_index_dir(path).join(format!("{}.idx", field))
     }
 
-    fn save_field_index(&self, field: PayloadKeyTypeRef) -> OperationResult<()> {
-        let field_index_dir = Self::get_field_index_dir(&self.path);
-        let field_index_path = Self::get_field_index_path(&self.path, field);
-        create_dir_all(field_index_dir)?;
+    fn load_all_fields(&mut self) -> OperationResult<()> {
+        let mut field_indexes: IndexesMap = Default::default();
 
-        match self.field_indexes.get(field) {
-            None => {}
-            Some(indexes) => {
-                let file = File::create(&field_index_path)?;
-                serde_cbor::to_writer(file, indexes).map_err(|err| {
-                    OperationError::service_error(&format!("Unable to save index: {:?}", err))
-                })?;
-            }
+        for (field, payload_type) in &self.config.indexed_fields {
+            let field_index = self.load_from_db(field, payload_type.to_owned())?;
+            field_indexes.insert(field.clone(), field_index);
         }
+        self.field_indexes = field_indexes;
         Ok(())
     }
 
-    fn load_or_build_field_index(
+    fn load_from_db(
         &self,
         field: PayloadKeyTypeRef,
         payload_type: PayloadSchemaType,
     ) -> OperationResult<Vec<FieldIndex>> {
-        let field_index_path = Self::get_field_index_path(&self.path, field);
-        if field_index_path.exists() {
-            debug!(
-                "Loading field `{}` index from {}",
-                field,
-                field_index_path.to_str().unwrap()
-            );
-            let file = File::open(field_index_path)?;
-            let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file).map_err(|err| {
-                OperationError::service_error(&format!("Unable to load index: {:?}", err))
-            })?;
-
-            Ok(field_indexes)
-        } else {
-            debug!(
-                "Index for field `{}` not found in {}, building now",
-                field,
-                field_index_path.to_str().unwrap()
-            );
-            let res = self.build_field_index(field, payload_type)?;
-            self.save_field_index(field)?;
-            Ok(res)
-        }
-    }
+        let mut indexes = index_selector(field, &payload_type, self.db.clone());
 
-    fn load_all_fields(&mut self) -> OperationResult<()> {
-        let mut field_indexes: IndexesMap = Default::default();
-        for (field, payload_type) in &self.config.indexed_fields {
-            let field_index = self.load_or_build_field_index(field, payload_type.to_owned())?;
-            field_indexes.insert(field.clone(), field_index);
+        let mut is_loaded = true;
+        for ref mut index in indexes.iter_mut() {
+            if !index.load()? {
+                is_loaded = false;
+                break;
+            }
         }
-        self.field_indexes = field_indexes;
-        Ok(())
+        if !is_loaded {
+            debug!("Index for `{field}` was not loaded. Building...");
+            indexes = self.build_field_indexes(field, payload_type)?;
+        }
+
+        Ok(indexes)
     }
 
     pub fn open(
@@ -168,6 +147,8 @@ impl StructPayloadIndex {
             PayloadConfig::default()
         };
 
+        let db = open_db_with_existing_cf(path)?;
+
         let mut index = StructPayloadIndex {
             points_iterator,
             payload,
@@ -176,6 +157,7 @@ impl StructPayloadIndex {
             config,
             path: path.to_owned(),
             visited_pool: Default::default(),
+            db,
         };
 
         if !index.config_path().exists() {
@@ -188,29 +170,26 @@ impl StructPayloadIndex {
         Ok(index)
     }
 
-    pub fn build_field_index(
+    pub fn build_field_indexes(
         &self,
         field: PayloadKeyTypeRef,
         field_type: PayloadSchemaType,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
+        let mut field_indexes = index_selector(field, &field_type, self.db.clone());
+        for index in &field_indexes {
+            index.recreate()?;
+        }
 
-        let mut builders = index_selector(&field_type);
         payload_storage.iter(|point_id, point_payload| {
             let field_value_opt = point_payload.get_value(field);
             if let Some(field_value) = field_value_opt {
-                for builder in &mut builders {
-                    builder.add(point_id, field_value);
+                for field_index in field_indexes.iter_mut() {
+                    field_index.add_point(point_id, field_value)?;
                 }
             }
-            true
+            Ok(true)
         })?;
-
-        let field_indexes = builders
-            .iter_mut()
-            .map(|builder| builder.build())
-            .collect_vec();
-
         Ok(field_indexes)
     }
 
@@ -219,11 +198,8 @@ impl StructPayloadIndex {
         field: PayloadKeyTypeRef,
         payload_type: PayloadSchemaType,
     ) -> OperationResult<()> {
-        let field_indexes = self.build_field_index(field, payload_type)?;
+        let field_indexes = self.build_field_indexes(field, payload_type)?;
         self.field_indexes.insert(field.into(), field_indexes);
-
-        self.save_field_index(field)?;
-
         Ok(())
     }
 
@@ -414,4 +390,76 @@ impl PayloadIndex for StructPayloadIndex {
             }
         }
     }
+
+    fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
+        for (field, field_index) in &mut self.field_indexes {
+            match payload.get_value(field) {
+                Some(field_value) => {
+                    for index in field_index {
+                        index.add_point(point_id, field_value)?;
+                    }
+                }
+                None => {}
+            }
+        }
+        self.payload.borrow_mut().assign(point_id, payload)
+    }
+
+    fn payload(&self, point_id: PointOffsetType) -> OperationResult<Payload> {
+        self.payload.borrow().payload(point_id)
+    }
+
+    fn delete(
+        &mut self,
+        point_id: PointOffsetType,
+        key: PayloadKeyTypeRef,
+    ) -> OperationResult<Option<Value>> {
+        if let Some(indexes) = self.field_indexes.get_mut(key) {
+            for index in indexes {
+                index.remove_point(point_id)?;
+            }
+        }
+        self.payload.borrow_mut().delete(point_id, key)
+    }
+
+    fn drop(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {
+        for (_, field_indexes) in self.field_indexes.iter_mut() {
+            for index in field_indexes {
+                index.remove_point(point_id)?;
+            }
+        }
+        self.payload.borrow_mut().drop(point_id)
+    }
+
+    fn wipe(&mut self) -> OperationResult<()> {
+        self.payload.borrow_mut().wipe()?;
+        for (_, field_indexes) in self.field_indexes.iter_mut() {
+            for index in field_indexes.drain(..) {
+                index.clear()?;
+            }
+        }
+        self.load_all_fields()
+    }
+
+    fn flush(&self) -> OperationResult<()> {
+        for field_indexes in self.field_indexes.values() {
+            for index in field_indexes {
+                index.flush()?;
+            }
+        }
+        self.payload.borrow().flush()
+    }
+
+    fn infer_payload_type(
+        &self,
+        key: PayloadKeyTypeRef,
+    ) -> OperationResult<Option<PayloadSchemaType>> {
+        let mut schema = None;
+        self.payload.borrow().iter(|_id, payload| {
+            let field_value = payload.get_value(key);
+            schema = field_value.and_then(infer_value_type);
+            Ok(false)
+        })?;
+        Ok(schema)
+    }
 }

commit 850e937c2a883e87622b43b3603be9ee1aaf02af
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jun 27 15:17:09 2022 +0200

    Storage points tracking refactoring (#750)
    
    * segment refactoring
    
    * rm points iterator
    
    * fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 4851d37a4..7895ff0e9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -13,7 +13,6 @@ use rocksdb::DB;
 use schemars::_serde_json::Value;
 
 use crate::entry::entry_point::OperationResult;
-use crate::id_tracker::points_iterator::PointsIteratorSS;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::FieldIndex;
@@ -36,7 +35,6 @@ pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
-    points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
     /// Payload storage
     payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
@@ -134,7 +132,6 @@ impl StructPayloadIndex {
     }
 
     pub fn open(
-        points_iterator: Arc<AtomicRefCell<PointsIteratorSS>>,
         payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
         path: &Path,
@@ -150,7 +147,6 @@ impl StructPayloadIndex {
         let db = open_db_with_existing_cf(path)?;
 
         let mut index = StructPayloadIndex {
-            points_iterator,
             payload,
             id_tracker,
             field_indexes: Default::default(),
@@ -204,7 +200,7 @@ impl StructPayloadIndex {
     }
 
     pub fn total_points(&self) -> usize {
-        self.points_iterator.borrow().points_count()
+        self.id_tracker.borrow().points_count()
     }
 
     fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
@@ -327,7 +323,7 @@ impl PayloadIndex for StructPayloadIndex {
         let query_cardinality = self.estimate_cardinality(query);
         return if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator =
-                ArcAtomicRefCellIterator::new(self.points_iterator.clone(), |points_iterator| {
+                ArcAtomicRefCellIterator::new(self.id_tracker.clone(), |points_iterator| {
                     points_iterator.iter_ids()
                 });
 
@@ -338,12 +334,14 @@ impl PayloadIndex for StructPayloadIndex {
 
             Box::new(matched_points)
         } else {
-            let points_iterator_ref = self.points_iterator.borrow();
+            let points_iterator_ref = self.id_tracker.borrow();
             let struct_filtered_context = self.struct_filtered_context(query);
 
             // CPU-optimized strategy here: points are made unique before applying other filters.
             // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self.visited_pool.get(points_iterator_ref.max_id() as usize);
+            let mut visited_list = self
+                .visited_pool
+                .get(points_iterator_ref.max_id() as usize + 1);
 
             #[allow(clippy::needless_collect)]
                 let preselected: Vec<PointOffsetType> = query_cardinality

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 7895ff0e9..fadf8762b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -2,21 +2,21 @@ use std::collections::{HashMap, HashSet};
 use std::fs::{create_dir_all, remove_file};
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
-
 use std::sync::Arc;
 
-use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
-use crate::common::rocksdb_operations::open_db_with_existing_cf;
 use atomic_refcell::AtomicRefCell;
 use log::debug;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
+use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
+use crate::common::rocksdb_operations::open_db_with_existing_cf;
 use crate::entry::entry_point::OperationResult;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
-use crate::index::field_index::FieldIndex;
-use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition, PrimaryCondition};
+use crate::index::field_index::{
+    CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
+};
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::optimizer::IndexesMap;

commit 42e930ab8f2fbda080511d5f4fc1092ee70e8c88
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Jul 22 19:27:07 2022 +0400

    Segment telemetry (#814)
    
    * segment telemetry
    
    * anonymize trait
    
    * fix build
    
    * are you happy fmt
    
    * anonimyze implementations
    
    * sliding window avg (#826)
    
    * Actix web telemetry (#828)
    
    * actix web telemetry
    
    * small as move
    
    * use tokio mutex instead of std
    
    * add comments
    
    * are you happy fmt
    
    * use u16 as http status code
    
    * telemetry structs rename
    
    * fix build
    
    * using parking lot mutex
    
    * telemetry web api (#842)
    
    * telemetry web api
    
    * telemetry openapi (#843)
    
    * use async mutex for telemetry collector
    
    * use tokio mutex for telemetry collector
    
    * are you happy fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index fadf8762b..a2661fbed 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -26,6 +26,7 @@ use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
+use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_value_type, Condition, FieldCondition, Filter, IsEmptyCondition, Payload, PayloadKeyType,
     PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
@@ -267,6 +268,18 @@ impl StructPayloadIndex {
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.total_points())),
         }
     }
+
+    pub fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {
+        self.field_indexes
+            .iter()
+            .flat_map(|(_, field)| -> Vec<PayloadIndexTelemetry> {
+                field
+                    .iter()
+                    .map(|field| field.get_telemetry_data())
+                    .collect()
+            })
+            .collect()
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {

commit 38c8097fc8a6a843df73025b21e3fe71257bb2fc
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Aug 12 09:38:31 2022 +0200

    Clippy next (#941)
    
    * Clippy derive_partial_eq_without_eq
    
    * Clippy  explicit_auto_deref
    
    * Clippy single_match
    
    * Clippy manual_find_map
    
    * Clippy unnecessary_to_owned
    
    * Clippy derive_partial_eq_without_eq
    
    * Clippy get_first

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a2661fbed..c317fe20f 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -76,8 +76,7 @@ impl StructPayloadIndex {
                 indexes
                     .iter()
                     .map(|field_index| field_index.filter(field_condition))
-                    .find(|filter_iter| filter_iter.is_some())
-                    .map(|filter_iter| filter_iter.unwrap())
+                    .find_map(|filter_iter| filter_iter)
             });
         indexes
     }
@@ -404,13 +403,10 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
         for (field, field_index) in &mut self.field_indexes {
-            match payload.get_value(field) {
-                Some(field_value) => {
-                    for index in field_index {
-                        index.add_point(point_id, field_value)?;
-                    }
+            if let Some(field_value) = payload.get_value(field) {
+                for index in field_index {
+                    index.add_point(point_id, field_value)?;
                 }
-                None => {}
             }
         }
         self.payload.borrow_mut().assign(point_id, payload)

commit f357bd5d9bc8cdc05915111419894d4f25512d83
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 15 13:47:52 2022 +0400

    Allow to flush segment in separate thread (#927)
    
    * allow to flush segment in separate thread
    
    * flush as separate function (#928)
    
    * flush as separate function
    
    * review suggestion
    
    * reduce locks during vector scoring
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * don't run background flush twice
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * increase flush interval
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * are you happy fmt
    
    * test background flush
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index c317fe20f..e3a39e22d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -6,11 +6,13 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use log::debug;
+use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::rocksdb_operations::open_db_with_existing_cf;
+use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
@@ -45,7 +47,7 @@ pub struct StructPayloadIndex {
     /// Root of index persistence dir
     path: PathBuf,
     visited_pool: VisitedPool,
-    db: Arc<AtomicRefCell<DB>>,
+    db: Arc<RwLock<DB>>,
 }
 
 impl StructPayloadIndex {
@@ -448,13 +450,20 @@ impl PayloadIndex for StructPayloadIndex {
         self.load_all_fields()
     }
 
-    fn flush(&self) -> OperationResult<()> {
+    fn flusher(&self) -> Flusher {
+        let mut flushers = Vec::new();
         for field_indexes in self.field_indexes.values() {
             for index in field_indexes {
-                index.flush()?;
+                flushers.push(index.flusher());
             }
         }
-        self.payload.borrow().flush()
+        flushers.push(self.payload.borrow().flusher());
+        Box::new(move || {
+            for flusher in flushers {
+                flusher()?
+            }
+            Ok(())
+        })
     }
 
     fn infer_payload_type(
@@ -462,7 +471,7 @@ impl PayloadIndex for StructPayloadIndex {
         key: PayloadKeyTypeRef,
     ) -> OperationResult<Option<PayloadSchemaType>> {
         let mut schema = None;
-        self.payload.borrow().iter(|_id, payload| {
+        self.payload.borrow().iter(|_id, payload: &Payload| {
             let field_value = payload.get_value(key);
             schema = field_value.and_then(infer_value_type);
             Ok(false)

commit f9fb0777a0fa67f3b297140493a3c71a4ef42064
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 22 10:41:08 2022 +0300

    Wrap rocksdb column usages (#951)
    
    * wrap rocksdb column usages
    
    * remove obsolete comments
    
    * are you happy clippy

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index e3a39e22d..4630ee79e 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -11,9 +11,9 @@ use rocksdb::DB;
 use schemars::_serde_json::Value;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
-use crate::common::rocksdb_operations::open_db_with_existing_cf;
+use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::Flusher;
-use crate::entry::entry_point::OperationResult;
+use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{
@@ -146,7 +146,9 @@ impl StructPayloadIndex {
             PayloadConfig::default()
         };
 
-        let db = open_db_with_existing_cf(path)?;
+        let db = open_db_with_existing_cf(path).map_err(|err| {
+            OperationError::service_error(&format!("RocksDB open error: {}", err))
+        })?;
 
         let mut index = StructPayloadIndex {
             payload,

commit b9eee55a9fb6d53572622f62756a80e62484009e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Sep 1 12:50:12 2022 +0200

    Full text search (#963)
    
    * allow additional params for payload field index
    
    * fmt
    
    * wip: full text index building
    
    * fmt
    
    * text search request
    
    * text search request
    
    * full text index persitance and loading
    
    * fmt
    
    * enable fts index in mapping
    
    * clippy
    
    * fix tests + add integration test
    
    * review fixes: extend payload index test
    
    * revert incedental change

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 4630ee79e..b16244451 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -30,8 +30,8 @@ use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    infer_value_type, Condition, FieldCondition, Filter, IsEmptyCondition, Payload, PayloadKeyType,
-    PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
+    infer_value_type, Condition, FieldCondition, Filter, IsEmptyCondition, Payload,
+    PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
@@ -103,8 +103,8 @@ impl StructPayloadIndex {
     fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
 
-        for (field, payload_type) in &self.config.indexed_fields {
-            let field_index = self.load_from_db(field, payload_type.to_owned())?;
+        for (field, payload_schema) in &self.config.indexed_fields {
+            let field_index = self.load_from_db(field, payload_schema.to_owned())?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;
@@ -114,9 +114,9 @@ impl StructPayloadIndex {
     fn load_from_db(
         &self,
         field: PayloadKeyTypeRef,
-        payload_type: PayloadSchemaType,
+        payload_schema: PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
-        let mut indexes = index_selector(field, &payload_type, self.db.clone());
+        let mut indexes = index_selector(field, &payload_schema, self.db.clone());
 
         let mut is_loaded = true;
         for ref mut index in indexes.iter_mut() {
@@ -127,7 +127,7 @@ impl StructPayloadIndex {
         }
         if !is_loaded {
             debug!("Index for `{field}` was not loaded. Building...");
-            indexes = self.build_field_indexes(field, payload_type)?;
+            indexes = self.build_field_indexes(field, payload_schema)?;
         }
 
         Ok(indexes)
@@ -173,10 +173,10 @@ impl StructPayloadIndex {
     pub fn build_field_indexes(
         &self,
         field: PayloadKeyTypeRef,
-        field_type: PayloadSchemaType,
+        payload_schema: PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
-        let mut field_indexes = index_selector(field, &field_type, self.db.clone());
+        let mut field_indexes = index_selector(field, &payload_schema, self.db.clone());
         for index in &field_indexes {
             index.recreate()?;
         }
@@ -196,9 +196,9 @@ impl StructPayloadIndex {
     fn build_and_save(
         &mut self,
         field: PayloadKeyTypeRef,
-        payload_type: PayloadSchemaType,
+        payload_schema: PayloadFieldSchema,
     ) -> OperationResult<()> {
-        let field_indexes = self.build_field_indexes(field, payload_type)?;
+        let field_indexes = self.build_field_indexes(field, payload_schema)?;
         self.field_indexes.insert(field.into(), field_indexes);
         Ok(())
     }
@@ -286,23 +286,23 @@ impl StructPayloadIndex {
 }
 
 impl PayloadIndex for StructPayloadIndex {
-    fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadSchemaType> {
+    fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadFieldSchema> {
         self.config.indexed_fields.clone()
     }
 
     fn set_indexed(
         &mut self,
         field: PayloadKeyTypeRef,
-        payload_type: PayloadSchemaType,
+        payload_schema: PayloadFieldSchema,
     ) -> OperationResult<()> {
         if self
             .config
             .indexed_fields
-            .insert(field.to_owned(), payload_type)
+            .insert(field.to_owned(), payload_schema.clone())
             .is_none()
         {
             self.save_config()?;
-            self.build_and_save(field, payload_type)?;
+            self.build_and_save(field, payload_schema)?;
         }
 
         Ok(())

commit 516dcd7020e2f54d91ecdda87e08333b17d85574
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Oct 23 02:48:55 2022 +0400

    Telemetry level of detail (#1049)
    
    * telemetry level of detail
    
    * rename duration aggregator
    
    * are you happy fmt
    
    * move total searches sum
    
    * separate levels
    
    * optional bucket size
    
    * search telemetry improvements
    
    * separate web telemetry into methods
    
    * tonic telemetry methods
    
    * merge optimizations
    
    * are you happy fmt
    
    * better rounding
    
    * qdrant configs on level 1
    
    * provide collection params
    
    * add peers count
    
    * collection points count
    
    * update openapi
    
    * use pattern in actix telemetry
    
    * are you happy fmt
    
    * merge dev
    
    * are you happy fmt
    
    * fix merge conflicts
    
    * update openapi
    
    * fix build
    
    * are you happy fmt
    
    * add exact searches statistics
    
    * process replica set
    
    * update openapi
    
    * fix wrong name
    
    * fix naming
    
    * fix unwrap
    
    * review
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index b16244451..072217a6d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -275,10 +275,10 @@ impl StructPayloadIndex {
     pub fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {
         self.field_indexes
             .iter()
-            .flat_map(|(_, field)| -> Vec<PayloadIndexTelemetry> {
+            .flat_map(|(name, field)| -> Vec<PayloadIndexTelemetry> {
                 field
                     .iter()
-                    .map(|field| field.get_telemetry_data())
+                    .map(|field| field.get_telemetry_data().set_name(name.to_string()))
                     .collect()
             })
             .collect()

commit 21754ef2efc039f61979ad2c45d614540c5d44ef
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 24 09:43:02 2022 +0200

    report indexed payload points in info api + other fixes (#1164)
    
    * report indexed payload points in info api + other fixes
    
    * rollback debug changes
    
    * clippy
    
    * clippy

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 072217a6d..cff70e3e1 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -385,6 +385,19 @@ impl PayloadIndex for StructPayloadIndex {
         };
     }
 
+    fn indexed_points(&self, field: PayloadKeyTypeRef) -> usize {
+        self.field_indexes.get(field).map_or(0, |indexes| {
+            // Assume that multiple field indexes are applied to the same data type,
+            // so the points indexed with those indexes are the same.
+            // We will return minimal number as a worst case, to highlight possible errors in the index early.
+            indexes
+                .iter()
+                .map(|index| index.count_indexed_points())
+                .min()
+                .unwrap_or(0)
+        })
+    }
+
     fn filter_context<'a>(&'a self, filter: &'a Filter) -> Box<dyn FilterContext + 'a> {
         Box::new(self.struct_filtered_context(filter))
     }

commit bcb52f9aee210d02a10eb250ab3e602d29e17313
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Dec 25 22:36:31 2022 +0100

    Id mapper inconsistency (#1302)
    
    * always flush wal
    
    * always flush wal fix
    
    * always flush wal fmt
    
    * flush wal during background flush
    
    * async wal flush
    
    * use id-tracker internal id for next-id instead of vector storage
    
    * add flush order and recovery comment
    
    fix merge bug
    
    * longer timeout in test

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index cff70e3e1..a1001250a 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -355,9 +355,7 @@ impl PayloadIndex for StructPayloadIndex {
 
             // CPU-optimized strategy here: points are made unique before applying other filters.
             // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self
-                .visited_pool
-                .get(points_iterator_ref.max_id() as usize + 1);
+            let mut visited_list = self.visited_pool.get(points_iterator_ref.internal_size());
 
             #[allow(clippy::needless_collect)]
                 let preselected: Vec<PointOffsetType> = query_cardinality

commit 6eca194f71bc20ca3e945560d47414eb10c14874
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 13 11:44:42 2023 +0100

    Fix segment snapshotting (#1321) (#1334)
    
    * WIP: Fix `Segment::take_snapshot`
    
    TODO:
    - This commit, probably, breaks snapshotting of segments with memmapped vector storage
    - `ProxySegment::take_snapshot` seems to potentially similar bug
    
    * WIP: Fix `Segment::take_snapshot`
    
    - Fix snapshotting of `StructPayloadIndex`
    - Fix snapshotting of segments with memmapped vector storage
    - Temporarily break `ProxySegment::take_snapshot`
    
    * Fix `ProxySegment::take_snapshot`
    
    * Remove `copy_segment_directory` test
    
    * nitpicking
    
    * clippy fixes
    
    * use OperationError::service_error
    
    * Cleanup `TinyMap` trait bounds and derive `Debug`
    
    * Fix `test_snapshot` test
    
    - Derive `Debug` for `NamedVectors`
    
    * Move utility functions from `segment.rs` to `utils` module
    
    * Contextualize `segment::utils::fs::move_all` a bit more carefully
    
    * Fix a typo
    
    * add backward compatibility with old snapshot formats
    
    * fmt
    
    * add snapshot for compatibility test
    
    * git lfs is a piece of shit
    
    * Nitpicking
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a1001250a..d898cd451 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -146,9 +146,8 @@ impl StructPayloadIndex {
             PayloadConfig::default()
         };
 
-        let db = open_db_with_existing_cf(path).map_err(|err| {
-            OperationError::service_error(&format!("RocksDB open error: {}", err))
-        })?;
+        let db = open_db_with_existing_cf(path)
+            .map_err(|err| OperationError::service_error(format!("RocksDB open error: {}", err)))?;
 
         let mut index = StructPayloadIndex {
             payload,
@@ -283,6 +282,13 @@ impl StructPayloadIndex {
             })
             .collect()
     }
+
+    pub fn restore_database_snapshot(
+        snapshot_path: &Path,
+        segment_path: &Path,
+    ) -> OperationResult<()> {
+        crate::rocksdb_backup::restore(snapshot_path, &segment_path.join("payload_index"))
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {
@@ -491,4 +497,12 @@ impl PayloadIndex for StructPayloadIndex {
         })?;
         Ok(schema)
     }
+
+    fn take_database_snapshot(&self, path: &Path) -> OperationResult<()> {
+        crate::rocksdb_backup::create(&self.db.read(), path)
+    }
+
+    fn files(&self) -> Vec<PathBuf> {
+        vec![self.config_path()]
+    }
 }

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index d898cd451..1e2468e4b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -97,7 +97,7 @@ impl StructPayloadIndex {
     }
 
     fn get_field_index_path(path: &Path, field: PayloadKeyTypeRef) -> PathBuf {
-        Self::get_field_index_dir(path).join(format!("{}.idx", field))
+        Self::get_field_index_dir(path).join(format!("{field}.idx"))
     }
 
     fn load_all_fields(&mut self) -> OperationResult<()> {
@@ -147,7 +147,7 @@ impl StructPayloadIndex {
         };
 
         let db = open_db_with_existing_cf(path)
-            .map_err(|err| OperationError::service_error(format!("RocksDB open error: {}", err)))?;
+            .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;
 
         let mut index = StructPayloadIndex {
             payload,

commit 3ad2e86e5ec314145e806c4def21a96632e3d298
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Feb 17 17:41:28 2023 +0100

    Access payload key through nested Array (#1465)
    
    * Access payload key through nested Array
    
    * support removal through array index
    
    * propagate type changes
    
    * fmt
    
    * avoid allocating Vec of one element

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 1e2468e4b..583cbe3cb 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -181,7 +181,8 @@ impl StructPayloadIndex {
         }
 
         payload_storage.iter(|point_id, point_payload| {
-            let field_value_opt = point_payload.get_value(field);
+            // TODO handle more than first value
+            let field_value_opt = point_payload.get_value(field).first().cloned();
             if let Some(field_value) = field_value_opt {
                 for field_index in field_indexes.iter_mut() {
                     field_index.add_point(point_id, field_value)?;
@@ -424,7 +425,8 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
         for (field, field_index) in &mut self.field_indexes {
-            if let Some(field_value) = payload.get_value(field) {
+            // TODO handle more than first value
+            if let Some(field_value) = payload.get_value(field).first() {
                 for index in field_index {
                     index.add_point(point_id, field_value)?;
                 }
@@ -441,7 +443,7 @@ impl PayloadIndex for StructPayloadIndex {
         &mut self,
         point_id: PointOffsetType,
         key: PayloadKeyTypeRef,
-    ) -> OperationResult<Option<Value>> {
+    ) -> OperationResult<Vec<Value>> {
         if let Some(indexes) = self.field_indexes.get_mut(key) {
             for index in indexes {
                 index.remove_point(point_id)?;
@@ -491,7 +493,8 @@ impl PayloadIndex for StructPayloadIndex {
     ) -> OperationResult<Option<PayloadSchemaType>> {
         let mut schema = None;
         self.payload.borrow().iter(|_id, payload: &Payload| {
-            let field_value = payload.get_value(key);
+            // TODO handle more than first value
+            let field_value: Option<_> = payload.get_value(key).first().cloned();
             schema = field_value.and_then(infer_value_type);
             Ok(false)
         })?;

commit 3d8b5131bd54079a534f840eaf0f69e570a68517
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Feb 23 15:57:12 2023 +0100

    Nested payload filters (#1487)
    
    * Nested payload filters
    
    * close ToDo + add parsing of multuiple array values
    
    * fmt
    
    * improve testing nested arrays
    
    * fix NumericIndex to accumulate points_to_values mapping
    
    * revert numberic index + strict array field access
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 583cbe3cb..7d1c03612 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,6 +12,7 @@ use schemars::_serde_json::Value;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
+use crate::common::utils::MultiValue;
 use crate::common::Flusher;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::IdTrackerSS;
@@ -30,8 +31,9 @@ use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    infer_value_type, Condition, FieldCondition, Filter, IsEmptyCondition, Payload,
-    PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
+    infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
+    IsEmptyCondition, Payload, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef,
+    PayloadSchemaType, PointOffsetType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
@@ -181,12 +183,9 @@ impl StructPayloadIndex {
         }
 
         payload_storage.iter(|point_id, point_payload| {
-            // TODO handle more than first value
-            let field_value_opt = point_payload.get_value(field).first().cloned();
-            if let Some(field_value) = field_value_opt {
-                for field_index in field_indexes.iter_mut() {
-                    field_index.add_point(point_id, field_value)?;
-                }
+            let field_value = &point_payload.get_value(field);
+            for field_index in field_indexes.iter_mut() {
+                field_index.add_point(point_id, field_value)?;
             }
             Ok(true)
         })?;
@@ -425,11 +424,9 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
         for (field, field_index) in &mut self.field_indexes {
-            // TODO handle more than first value
-            if let Some(field_value) = payload.get_value(field).first() {
-                for index in field_index {
-                    index.add_point(point_id, field_value)?;
-                }
+            let field_value = &payload.get_value(field);
+            for index in field_index {
+                index.add_point(point_id, field_value)?;
             }
         }
         self.payload.borrow_mut().assign(point_id, payload)
@@ -493,9 +490,13 @@ impl PayloadIndex for StructPayloadIndex {
     ) -> OperationResult<Option<PayloadSchemaType>> {
         let mut schema = None;
         self.payload.borrow().iter(|_id, payload: &Payload| {
-            // TODO handle more than first value
-            let field_value: Option<_> = payload.get_value(key).first().cloned();
-            schema = field_value.and_then(infer_value_type);
+            let field_value = payload.get_value(key);
+            match field_value {
+                MultiValue::Single(field_value) => schema = field_value.and_then(infer_value_type),
+                MultiValue::Multiple(fields_values) => {
+                    schema = infer_collection_value_type(fields_values)
+                }
+            }
             Ok(false)
         })?;
         Ok(schema)

commit 2ddce557b247226dc0c4872d50851aebb95ec562
Author: Ibrahim M. Akrab <ibrahim.m.akrab@gmail.com>
Date:   Sat Apr 1 20:46:50 2023 +0200

    add `isNull` condition for payload filtering (#1617)
    
    * add minimal working is_null filter
    
    * add is_null condition to grpc api (backward compatible)
    
    * add unit tests is_null and is_empty conditions
    
    * add is_null to  points.proto file
    
    * add some failing OpenAPI tests
    
    * fix a failing test due to change in collection data
    
    * refactor MultiValue's check for is_null
    
    * fix is_empty condition not picking up "key":[]
    
    * remove duplicate OpenAPI integration test
    
    * reuse same variable in condition checker tests
    
    * update grpc docs
    
    * fix is_null cardinality estimation to match is_empty
    
    * update openapi specs
    
    * remove unused debug statements
    
    * add new test points to original test_collection
    
    * fix failing tests according to newly added points
    
    * add the `"key":[null]` test_case

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 7d1c03612..b250589af 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -32,8 +32,8 @@ use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
-    IsEmptyCondition, Payload, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef,
-    PayloadSchemaType, PointOffsetType,
+    IsEmptyCondition, IsNullCondition, Payload, PayloadFieldSchema, PayloadKeyType,
+    PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
@@ -250,6 +250,33 @@ impl StructPayloadIndex {
                     }
                 }
             }
+            Condition::IsNull(IsNullCondition { is_null: field }) => {
+                let total_points = self.total_points();
+
+                let mut indexed_points = 0;
+                if let Some(field_indexes) = self.field_indexes.get(&field.key) {
+                    for index in field_indexes {
+                        indexed_points = indexed_points.max(index.count_indexed_points())
+                    }
+                    CardinalityEstimation {
+                        primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
+                            is_null: field.to_owned(),
+                        })],
+                        min: 0,
+                        exp: total_points.saturating_sub(indexed_points),
+                        max: total_points.saturating_sub(indexed_points),
+                    }
+                } else {
+                    CardinalityEstimation {
+                        primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
+                            is_null: field.to_owned(),
+                        })],
+                        min: 0,
+                        exp: total_points / 2,
+                        max: total_points,
+                    }
+                }
+            }
             Condition::HasId(has_id) => {
                 let id_tracker_ref = self.id_tracker.borrow();
                 let mapped_ids: HashSet<PointOffsetType> = has_id
@@ -375,7 +402,8 @@ impl PayloadIndex for StructPayloadIndex {
                             )
                         }
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
-                        PrimaryCondition::IsEmpty(_) => points_iterator_ref.iter_ids() /* there are no fast index for IsEmpty */
+                        PrimaryCondition::IsEmpty(_) => points_iterator_ref.iter_ids(), /* there are no fast index for IsEmpty */
+                        PrimaryCondition::IsNull(_) => points_iterator_ref.iter_ids(),  /* no fast index for IsNull too */
                     }
                 })
                 .filter(|&id| !visited_list.check_and_update_visited(id))

commit 7edf599d73cd65b47476be72009684451b7533a9
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Apr 25 14:31:04 2023 +0200

    Make query planner aware of deleted points and vectors (#1757)
    
    * Exclude deleted vectors from HNSW graph building stage
    
    * When estimating query cardinality, use available points as baseline
    
    We should not use the total number of points in a segment, because a
    portion of it may be soft deleted. Instead, we use the available
    (non-deleted) points as baseline.
    
    * Add plain search check to unfiltered HNSW search due to deleted points
    
    * Cardinality sampling on available points, ignore deleted named vectors
    
    * Estimate available vectors in query planner, now consider deleted points
    
    In the query planner, we want to know the number of available points as
    accurately as possible. This isn't possible because we only know the
    number of deletions and vectors can be deleted in two places: as point
    or as vector. These deletions may overlap. This now estimates the number
    of deleted vectors based on the segment state. It assumes that point and
    vector deletions have an overlap of 20%. This is an arbitrary
    percentage, but reflects an almost-worst scenario.
    
    This improves because the number of deleted points wasn't considered at
    all before.
    
    * Remove unused function from trait
    
    * Fix bench compilation error
    
    * Fix typo in docs
    
    * Base whether to do plain search in HNSW upon full scan threshold
    
    * Remove index threshold from HNSW config, only use full scan threshold
    
    * Simplify timer aggregator assignment in HNSW search
    
    * Remove vector storage type from cardinality function parameters
    
    * Propagate point deletes to all its vectors
    
    * Check for deleted vectors first, this makes early return possible
    
    Since point deletes are now propagated to vectors, deleted points are
    included in vector deletions. Because of that we can check if the vector
    is deleted first so we can return early and skip the point deletion
    check.
    
    For integrity we also check if the point is deleted, if the vector was
    not. That is because it may happen that point deletions are not properly
    propagated to vectors.
    
    * Don't use arbitrary vector count estimation, use vector count directly
    
    Before we had to estimate the number of vectors (for a named vector)
    because vectors could be deleted as point or vector. Point deletes are
    now propagated to vector deletes, that means we can simply use the
    deleted vector count which is now much more accurate.
    
    * When sampling IDs, check deleted vecs before deleted points
    
    * On segment consistency check, delete vectors for deleted points
    
    * Fix vector delete state not being kept when updating storage from other
    
    * Fix segment builder skipping deleted vectors breaking offsets
    
    * update segment to handle optional vectors + add test (#1781)
    
    * update segment to handle optional vectors + add test
    
    * Only update stored record when deleting if it wasn't deleted already
    
    * Reformat comment
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Fix missed vector name test, these are now marked as deleted
    
    * upd test
    
    * upd test
    
    * Update consensus test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index b250589af..9ebb368ca 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -355,22 +355,25 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
-        let total_points = self.total_points();
-
+    fn estimate_cardinality(
+        &self,
+        query: &Filter,
+        available_points: Option<usize>,
+    ) -> CardinalityEstimation {
         let estimator = |condition: &Condition| self.condition_cardinality(condition);
-
-        estimate_filter(&estimator, query, total_points)
+        let available_points = available_points.unwrap_or_else(|| self.total_points());
+        estimate_filter(&estimator, query, available_points)
     }
 
     fn query_points<'a>(
         &'a self,
         query: &'a Filter,
+        available_points: Option<usize>,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
 
-        let query_cardinality = self.estimate_cardinality(query);
-        return if query_cardinality.primary_clauses.is_empty() {
+        let query_cardinality = self.estimate_cardinality(query, available_points);
+        if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator =
                 ArcAtomicRefCellIterator::new(self.id_tracker.clone(), |points_iterator| {
                     points_iterator.iter_ids()
@@ -414,7 +417,7 @@ impl PayloadIndex for StructPayloadIndex {
 
             let matched_points_iter = preselected.into_iter();
             Box::new(matched_points_iter)
-        };
+        }
     }
 
     fn indexed_points(&self, field: PayloadKeyTypeRef) -> usize {

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Vise <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 9ebb368ca..2efbed68b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -202,8 +202,11 @@ impl StructPayloadIndex {
         Ok(())
     }
 
-    pub fn total_points(&self) -> usize {
-        self.id_tracker.borrow().points_count()
+    /// Number of available points
+    ///
+    /// - excludes soft deleted points
+    pub fn available_point_count(&self) -> usize {
+        self.id_tracker.borrow().available_point_count()
     }
 
     fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
@@ -216,7 +219,7 @@ impl StructPayloadIndex {
             payload_provider,
             &self.field_indexes,
             &estimator,
-            self.total_points(),
+            self.available_point_count(),
         )
     }
 
@@ -224,7 +227,7 @@ impl StructPayloadIndex {
         match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
-                let total_points = self.total_points();
+                let available_points = self.available_point_count();
 
                 let mut indexed_points = 0;
                 if let Some(field_indexes) = self.field_indexes.get(&field.key) {
@@ -236,8 +239,8 @@ impl StructPayloadIndex {
                             is_empty: field.to_owned(),
                         })],
                         min: 0, // It is possible, that some non-empty payloads are not indexed
-                        exp: total_points.saturating_sub(indexed_points), // Expect field type consistency
-                        max: total_points.saturating_sub(indexed_points),
+                        exp: available_points.saturating_sub(indexed_points), // Expect field type consistency
+                        max: available_points.saturating_sub(indexed_points),
                     }
                 } else {
                     CardinalityEstimation {
@@ -245,13 +248,13 @@ impl StructPayloadIndex {
                             is_empty: field.to_owned(),
                         })],
                         min: 0,
-                        exp: total_points / 2,
-                        max: total_points,
+                        exp: available_points / 2,
+                        max: available_points,
                     }
                 }
             }
             Condition::IsNull(IsNullCondition { is_null: field }) => {
-                let total_points = self.total_points();
+                let available_points = self.available_point_count();
 
                 let mut indexed_points = 0;
                 if let Some(field_indexes) = self.field_indexes.get(&field.key) {
@@ -263,8 +266,8 @@ impl StructPayloadIndex {
                             is_null: field.to_owned(),
                         })],
                         min: 0,
-                        exp: total_points.saturating_sub(indexed_points),
-                        max: total_points.saturating_sub(indexed_points),
+                        exp: available_points.saturating_sub(indexed_points),
+                        max: available_points.saturating_sub(indexed_points),
                     }
                 } else {
                     CardinalityEstimation {
@@ -272,8 +275,8 @@ impl StructPayloadIndex {
                             is_null: field.to_owned(),
                         })],
                         min: 0,
-                        exp: total_points / 2,
-                        max: total_points,
+                        exp: available_points / 2,
+                        max: available_points,
                     }
                 }
             }
@@ -294,7 +297,7 @@ impl StructPayloadIndex {
             }
             Condition::Field(field_condition) => self
                 .estimate_field_condition(field_condition)
-                .unwrap_or_else(|| CardinalityEstimation::unknown(self.total_points())),
+                .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
         }
     }
 
@@ -361,7 +364,7 @@ impl PayloadIndex for StructPayloadIndex {
         available_points: Option<usize>,
     ) -> CardinalityEstimation {
         let estimator = |condition: &Condition| self.condition_cardinality(condition);
-        let available_points = available_points.unwrap_or_else(|| self.total_points());
+        let available_points = available_points.unwrap_or_else(|| self.available_point_count());
         estimate_filter(&estimator, query, available_points)
     }
 
@@ -390,8 +393,10 @@ impl PayloadIndex for StructPayloadIndex {
             let struct_filtered_context = self.struct_filtered_context(query);
 
             // CPU-optimized strategy here: points are made unique before applying other filters.
-            // ToDo: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self.visited_pool.get(points_iterator_ref.internal_size());
+            // TODO: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
+            let mut visited_list = self
+                .visited_pool
+                .get(points_iterator_ref.total_point_count());
 
             #[allow(clippy::needless_collect)]
                 let preselected: Vec<PointOffsetType> = query_cardinality

commit d32574fdd20b1e49074e5a615b64a0baf0615c32
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat Apr 29 10:04:39 2023 +0200

    undo vector-related changes in estimate_cardinality (#1806)
    
    * undo vector-related changes in estimate_cardinality
    
    * fix adjust_to_available_vectors

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2efbed68b..a202cfeb6 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -358,24 +358,21 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn estimate_cardinality(
-        &self,
-        query: &Filter,
-        available_points: Option<usize>,
-    ) -> CardinalityEstimation {
+    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
+        let available_points = self.available_point_count();
         let estimator = |condition: &Condition| self.condition_cardinality(condition);
-        let available_points = available_points.unwrap_or_else(|| self.available_point_count());
+
         estimate_filter(&estimator, query, available_points)
     }
 
     fn query_points<'a>(
         &'a self,
         query: &'a Filter,
-        available_points: Option<usize>,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
 
-        let query_cardinality = self.estimate_cardinality(query, available_points);
+        let query_cardinality = self.estimate_cardinality(query);
+
         if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator =
                 ArcAtomicRefCellIterator::new(self.id_tracker.clone(), |points_iterator| {

commit b11729e77b81f0e2fb1e10a8256232d8ad3077d3
Author: Jesse <github@jessebakker.com>
Date:   Mon May 8 17:02:29 2023 +0200

    Add caching of docker layers in CI (#1856)
    
    * Add caching of docker layers in CI
    
    Build required docker images for CI in a workflow step using buildkit's
    gha cache type. This will populate the local layer cache from github
    actions' cache. Builds in subsequent CI steps will be nearly instant,
    because all layers can be reused.
    
    * add minor change to see if build time is any faster
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a202cfeb6..014ae6062 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -42,6 +42,7 @@ pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
 pub struct StructPayloadIndex {
     /// Payload storage
     payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
+    /// Used for `has_id` condition and estimating cardinality
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Indexes, associated with fields
     pub field_indexes: IndexesMap,

commit 12ef2847f69a9664905e5e25a57a2d8b4f8cb36f
Author: Jesse <github@jessebakker.com>
Date:   Mon May 8 20:39:59 2023 +0200

    Custom build profile for CI docker builds (#1859)
    
    * Use custom build profile for docker builds
    
    * trigger ci
    
    * change source code to trigger ci with rebuild one more time
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 014ae6062..3c9a0c125 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -49,6 +49,7 @@ pub struct StructPayloadIndex {
     config: PayloadConfig,
     /// Root of index persistence dir
     path: PathBuf,
+    /// Used to select unique point ids
     visited_pool: VisitedPool,
     db: Arc<RwLock<DB>>,
 }

commit 0f0c213c2a94ee387a40e5309c3ae15e0e2c7c96
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed May 10 14:20:12 2023 +0200

    Nested object filter (#1602)
    
    * nested object filter
    
    * code review
    
    * add support for must_not in nested
    
    * extract functions
    
    * support and test must_not in SimpleConditionChecker
    
    * add index matching unit test (to be continued)
    
    * remove extra clone
    
    * test with should
    
    * WIP: Nested object filter suggestions (#1855)
    
    * switch to bitvec
    
    * fix clippy
    
    * more tests
    
    * fmt
    
    * fix some tests
    
    * add test with text
    
    * support for nested should
    
    * do not rely on indexes for nested queries & fix test
    
    * use index to make index-aware checks in nested payload
    
    * fix value-count tests
    
    * re-fa-cto-ring
    
    * fmt
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 3c9a0c125..61121a3f3 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,7 +12,7 @@ use schemars::_serde_json::Value;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
-use crate::common::utils::MultiValue;
+use crate::common::utils::{IndexesMap, JsonPathPayload, MultiValue};
 use crate::common::Flusher;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::IdTrackerSS;
@@ -22,7 +22,6 @@ use crate::index::field_index::{
 };
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
-use crate::index::query_optimization::optimizer::IndexesMap;
 use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
@@ -32,7 +31,7 @@ use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
-    IsEmptyCondition, IsNullCondition, Payload, PayloadFieldSchema, PayloadKeyType,
+    IsEmptyCondition, IsNullCondition, Payload, PayloadField, PayloadFieldSchema, PayloadKeyType,
     PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
 };
 
@@ -58,11 +57,18 @@ impl StructPayloadIndex {
     pub fn estimate_field_condition(
         &self,
         condition: &FieldCondition,
+        nested_path: Option<&JsonPathPayload>,
     ) -> Option<CardinalityEstimation> {
-        self.field_indexes.get(&condition.key).and_then(|indexes| {
+        let full_path = JsonPathPayload::extend_or_new(nested_path, &condition.key);
+        self.field_indexes.get(&full_path.path).and_then(|indexes| {
+            // rewrite condition with fullpath to enable cardinality estimation
+            let full_path_condition = FieldCondition {
+                key: full_path.path,
+                ..condition.clone()
+            };
             let mut result_estimation: Option<CardinalityEstimation> = None;
             for index in indexes {
-                result_estimation = index.estimate_cardinality(condition);
+                result_estimation = index.estimate_cardinality(&full_path_condition);
                 if result_estimation.is_some() {
                     break;
                 }
@@ -212,7 +218,7 @@ impl StructPayloadIndex {
     }
 
     fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
-        let estimator = |condition: &Condition| self.condition_cardinality(condition);
+        let estimator = |condition: &Condition| self.condition_cardinality(condition, None);
         let id_tracker = self.id_tracker.borrow();
         let payload_provider = PayloadProvider::new(self.payload.clone());
         StructFilterContext::new(
@@ -225,20 +231,31 @@ impl StructPayloadIndex {
         )
     }
 
-    fn condition_cardinality(&self, condition: &Condition) -> CardinalityEstimation {
+    fn condition_cardinality(
+        &self,
+        condition: &Condition,
+        nested_path: Option<&JsonPathPayload>,
+    ) -> CardinalityEstimation {
         match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
+            Condition::Nested(nested) => {
+                // propagate complete nested path in case of multiple nested layers
+                let full_path = JsonPathPayload::extend_or_new(nested_path, &nested.array_key());
+                self.estimate_nested_cardinality(nested.filter(), &full_path)
+            }
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
                 let available_points = self.available_point_count();
+                let full_path = JsonPathPayload::extend_or_new(nested_path, &field.key);
+                let full_path = full_path.path;
 
                 let mut indexed_points = 0;
-                if let Some(field_indexes) = self.field_indexes.get(&field.key) {
+                if let Some(field_indexes) = self.field_indexes.get(&full_path) {
                     for index in field_indexes {
                         indexed_points = indexed_points.max(index.count_indexed_points())
                     }
                     CardinalityEstimation {
                         primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
-                            is_empty: field.to_owned(),
+                            is_empty: PayloadField { key: full_path },
                         })],
                         min: 0, // It is possible, that some non-empty payloads are not indexed
                         exp: available_points.saturating_sub(indexed_points), // Expect field type consistency
@@ -247,7 +264,7 @@ impl StructPayloadIndex {
                 } else {
                     CardinalityEstimation {
                         primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
-                            is_empty: field.to_owned(),
+                            is_empty: PayloadField { key: full_path },
                         })],
                         min: 0,
                         exp: available_points / 2,
@@ -257,15 +274,17 @@ impl StructPayloadIndex {
             }
             Condition::IsNull(IsNullCondition { is_null: field }) => {
                 let available_points = self.available_point_count();
+                let full_path = JsonPathPayload::extend_or_new(nested_path, &field.key);
+                let full_path = full_path.path;
 
                 let mut indexed_points = 0;
-                if let Some(field_indexes) = self.field_indexes.get(&field.key) {
+                if let Some(field_indexes) = self.field_indexes.get(&full_path) {
                     for index in field_indexes {
                         indexed_points = indexed_points.max(index.count_indexed_points())
                     }
                     CardinalityEstimation {
                         primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
-                            is_null: field.to_owned(),
+                            is_null: PayloadField { key: full_path },
                         })],
                         min: 0,
                         exp: available_points.saturating_sub(indexed_points),
@@ -274,7 +293,7 @@ impl StructPayloadIndex {
                 } else {
                     CardinalityEstimation {
                         primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
-                            is_null: field.to_owned(),
+                            is_null: PayloadField { key: full_path },
                         })],
                         min: 0,
                         exp: available_points / 2,
@@ -298,7 +317,7 @@ impl StructPayloadIndex {
                 }
             }
             Condition::Field(field_condition) => self
-                .estimate_field_condition(field_condition)
+                .estimate_field_condition(field_condition, nested_path)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
         }
     }
@@ -362,8 +381,18 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
         let available_points = self.available_point_count();
-        let estimator = |condition: &Condition| self.condition_cardinality(condition);
+        let estimator = |condition: &Condition| self.condition_cardinality(condition, None);
+        estimate_filter(&estimator, query, available_points)
+    }
 
+    fn estimate_nested_cardinality(
+        &self,
+        query: &Filter,
+        nested_path: &JsonPathPayload,
+    ) -> CardinalityEstimation {
+        let available_points = self.available_point_count();
+        let estimator =
+            |condition: &Condition| self.condition_cardinality(condition, Some(nested_path));
         estimate_filter(&estimator, query, available_points)
     }
 

commit 82814e82532ab281dcb991f5ec93f7a7e1be8b73
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 22 10:05:42 2023 +0200

    always save config after operation is done (#1936)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 61121a3f3..83579c93d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,5 +1,5 @@
 use std::collections::{HashMap, HashSet};
-use std::fs::{create_dir_all, remove_file};
+use std::fs::create_dir_all;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -102,14 +102,6 @@ impl StructPayloadIndex {
         self.config.save(&config_path)
     }
 
-    fn get_field_index_dir(path: &Path) -> PathBuf {
-        path.join(PAYLOAD_FIELD_INDEX_PATH)
-    }
-
-    fn get_field_index_path(path: &Path, field: PayloadKeyTypeRef) -> PathBuf {
-        Self::get_field_index_dir(path).join(format!("{field}.idx"))
-    }
-
     fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
 
@@ -358,8 +350,8 @@ impl PayloadIndex for StructPayloadIndex {
             .insert(field.to_owned(), payload_schema.clone())
             .is_none()
         {
-            self.save_config()?;
             self.build_and_save(field, payload_schema)?;
+            self.save_config()?;
         }
 
         Ok(())
@@ -367,15 +359,15 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
         self.config.indexed_fields.remove(field);
-        self.save_config()?;
-        self.field_indexes.remove(field);
-
-        let field_index_path = Self::get_field_index_path(&self.path, field);
+        let removed_indexes = self.field_indexes.remove(field);
 
-        if field_index_path.exists() {
-            remove_file(&field_index_path)?;
+        if let Some(indexes) = removed_indexes {
+            for index in indexes {
+                index.clear()?;
+            }
         }
 
+        self.save_config()?;
         Ok(())
     }
 

commit 2e5e0292cceb8fa23e8952568892029bf7a6a16e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 22 20:08:12 2023 +0200

    Rewrite nested filters again (#1935)
    
    * working nested filters
    
    * rm unused file
    
    * add comment example
    
    * todo
    
    * remove nester checkers
    
    * Box recursive generic Fn types
    
    * Box recursive generic Fn types [2/2]
    
    * Add optional ID tracker to check_payload, remove boxed closure (#1939)
    
    * Add optional ID tracker to check_payload, remove boxed closure
    
    * Replace some match with or_else
    
    * Some nested filter improvements (#1940)
    
    * Replace starts_with/substring with strip_prefix
    
    * Transform for-if-let-check-return into any iterator
    
    * Transform for-if-return into any iterator
    
    * Add comment to describe why check_payload has no ID tracker
    
    See: https://github.com/qdrant/qdrant/pull/1935#discussion_r1200437675
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * fix clippy
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Vise <tim+github@visee.me>
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 83579c93d..cd7270846 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -31,8 +31,8 @@ use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
-    IsEmptyCondition, IsNullCondition, Payload, PayloadField, PayloadFieldSchema, PayloadKeyType,
-    PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
+    IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
+    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";

commit f5dfeeff4c4baf35045bc6904d88076f2e58d094
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 22 20:32:35 2023 +0200

    Fixes for group-by (#1938)
    
    * fix payload seletor
    
    * clippy
    
    * except cardinality estimation
    
    * implement match except iterator and api
    
    * use except instead of must-not + test
    
    * Fix doc error
    
    * Update lib/collection/src/grouping/group_by.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/vector_storage/mod.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/collection/src/grouping/group_by.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update lib/segment/src/index/field_index/map_index.rs [skip ci]
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * fix: `except_on` and `match_on` now produce `Vec<Condition>`s
    
    * Apply suggestions from code review (lib/segment/src/index/field_index/map_index.rs)
    
    * fix: reset review suggestion
    
    * Remove unnecessary move
    
    * Use Rust idiomatic map_else rather than match-none-false
    
    * is-null -> is-empty
    
    * de-comment drop_collection
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Vise <tim+github@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index cd7270846..bfe993622 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -77,10 +77,10 @@ impl StructPayloadIndex {
         })
     }
 
-    fn query_field(
-        &self,
-        field_condition: &FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>> {
+    fn query_field<'a>(
+        &'a self,
+        field_condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         let indexes = self
             .field_indexes
             .get(&field_condition.key)

commit ab7ab03a327aab401f11e858bb8df400e52b809d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jun 9 00:05:00 2023 +0200

    Fix batch request with duplicated filter (#2051)
    
    * fix double usage of iterator
    
    * tests

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index bfe993622..4719830a9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -388,10 +388,7 @@ impl PayloadIndex for StructPayloadIndex {
         estimate_filter(&estimator, query, available_points)
     }
 
-    fn query_points<'a>(
-        &'a self,
-        query: &'a Filter,
-    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {
+    fn query_points(&self, query: &Filter) -> Vec<PointOffsetType> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
 
         let query_cardinality = self.estimate_cardinality(query);
@@ -407,7 +404,7 @@ impl PayloadIndex for StructPayloadIndex {
             let matched_points =
                 full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
 
-            Box::new(matched_points)
+            matched_points.collect()
         } else {
             let points_iterator_ref = self.id_tracker.borrow();
             let struct_filtered_context = self.struct_filtered_context(query);
@@ -418,8 +415,7 @@ impl PayloadIndex for StructPayloadIndex {
                 .visited_pool
                 .get(points_iterator_ref.total_point_count());
 
-            #[allow(clippy::needless_collect)]
-                let preselected: Vec<PointOffsetType> = query_cardinality
+            let preselected: Vec<PointOffsetType> = query_cardinality
                 .primary_clauses
                 .iter()
                 .flat_map(|clause| {
@@ -440,8 +436,7 @@ impl PayloadIndex for StructPayloadIndex {
 
             self.visited_pool.return_back(visited_list);
 
-            let matched_points_iter = preselected.into_iter();
-            Box::new(matched_points_iter)
+            preselected
         }
     }
 

commit 7044bf8e038d9676378d93dac484e1c2bacc0ffe
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jul 10 11:24:14 2023 +0200

    Fix set payload index to handle type change (#2235)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 4719830a9..e3cb90b7d 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -344,15 +344,19 @@ impl PayloadIndex for StructPayloadIndex {
         field: PayloadKeyTypeRef,
         payload_schema: PayloadFieldSchema,
     ) -> OperationResult<()> {
-        if self
+        if let Some(prev_schema) = self
             .config
             .indexed_fields
             .insert(field.to_owned(), payload_schema.clone())
-            .is_none()
         {
-            self.build_and_save(field, payload_schema)?;
-            self.save_config()?;
+            // the field is already indexed with the same schema
+            // no need to rebuild index and to save the config
+            if prev_schema == payload_schema {
+                return Ok(());
+            }
         }
+        self.build_and_save(field, payload_schema)?;
+        self.save_config()?;
 
         Ok(())
     }

commit 8ef51525235655112ab08adac644455d86a3d608
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Sep 4 15:24:52 2023 +0200

    immutable map index integration (#2524)
    
    * immutable map index integration
    
    * remove wipe
    
    * fix unit tests
    
    * get appendable flag from config
    
    * minor refactoring
    
    * fix chunked mmap appendable flag
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index e3cb90b7d..e495a0445 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -102,11 +102,11 @@ impl StructPayloadIndex {
         self.config.save(&config_path)
     }
 
-    fn load_all_fields(&mut self) -> OperationResult<()> {
+    fn load_all_fields(&mut self, is_appendable: bool) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
 
         for (field, payload_schema) in &self.config.indexed_fields {
-            let field_index = self.load_from_db(field, payload_schema.to_owned())?;
+            let field_index = self.load_from_db(field, payload_schema.to_owned(), is_appendable)?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;
@@ -117,8 +117,9 @@ impl StructPayloadIndex {
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: PayloadFieldSchema,
+        is_appendable: bool,
     ) -> OperationResult<Vec<FieldIndex>> {
-        let mut indexes = index_selector(field, &payload_schema, self.db.clone());
+        let mut indexes = index_selector(field, &payload_schema, self.db.clone(), is_appendable);
 
         let mut is_loaded = true;
         for ref mut index in indexes.iter_mut() {
@@ -129,6 +130,7 @@ impl StructPayloadIndex {
         }
         if !is_loaded {
             debug!("Index for `{field}` was not loaded. Building...");
+            // todo(ivan): decide what to do with indexes, which were not loaded
             indexes = self.build_field_indexes(field, payload_schema)?;
         }
 
@@ -139,6 +141,7 @@ impl StructPayloadIndex {
         payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
         path: &Path,
+        is_appendable: bool,
     ) -> OperationResult<Self> {
         create_dir_all(path)?;
         let config_path = PayloadConfig::get_config_path(path);
@@ -166,7 +169,7 @@ impl StructPayloadIndex {
             index.save_config()?;
         }
 
-        index.load_all_fields()?;
+        index.load_all_fields(is_appendable)?;
 
         Ok(index)
     }
@@ -177,7 +180,7 @@ impl StructPayloadIndex {
         payload_schema: PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
-        let mut field_indexes = index_selector(field, &payload_schema, self.db.clone());
+        let mut field_indexes = index_selector(field, &payload_schema, self.db.clone(), true);
         for index in &field_indexes {
             index.recreate()?;
         }
@@ -513,16 +516,6 @@ impl PayloadIndex for StructPayloadIndex {
         self.payload.borrow_mut().drop(point_id)
     }
 
-    fn wipe(&mut self) -> OperationResult<()> {
-        self.payload.borrow_mut().wipe()?;
-        for (_, field_indexes) in self.field_indexes.iter_mut() {
-            for index in field_indexes.drain(..) {
-                index.clear()?;
-            }
-        }
-        self.load_all_fields()
-    }
-
     fn flusher(&self) -> Flusher {
         let mut flushers = Vec::new();
         for field_indexes in self.field_indexes.values() {

commit 1611deaf034a8ec219b4aab80abe31200bb8fc15
Author: Eugene Tolbakov <ev.tolbakov@gmail.com>
Date:   Mon Sep 25 14:10:45 2023 +0100

    Refactor: replace expect with ServiceError, remove repetive code (#2701)
    
    * Refactor: replace expect with ServiceError, remove repetive code
    
    * chore: remove unnecessary code
    
    * chore: apply cr suggestions
    
    * chore: apply clippy recommendations
    
    * Improve constructing errors
    
    * Improve test assertions
    
    * fix: replace max_regions assertion with operation error
    
    * fix: adjust according to CR
    
    * chore: replace Option with OperationResult for estimate_cardinality
    
    * chore: replace Option with OperationResult for filter
    
    * Better handling of transforming none into an error
    
    * Replace for loop with simple iterator, simply other iterator
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index e495a0445..42416a6fe 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -66,14 +66,10 @@ impl StructPayloadIndex {
                 key: full_path.path,
                 ..condition.clone()
             };
-            let mut result_estimation: Option<CardinalityEstimation> = None;
-            for index in indexes {
-                result_estimation = index.estimate_cardinality(&full_path_condition);
-                if result_estimation.is_some() {
-                    break;
-                }
-            }
-            result_estimation
+
+            indexes
+                .iter()
+                .find_map(|index| index.estimate_cardinality(&full_path_condition).ok())
         })
     }
 
@@ -87,8 +83,7 @@ impl StructPayloadIndex {
             .and_then(|indexes| {
                 indexes
                     .iter()
-                    .map(|field_index| field_index.filter(field_condition))
-                    .find_map(|filter_iter| filter_iter)
+                    .find_map(|field_index| field_index.filter(field_condition).ok())
             });
         indexes
     }

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 42416a6fe..e2620abe8 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -5,6 +5,7 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::types::PointOffsetType;
 use log::debug;
 use parking_lot::RwLock;
 use rocksdb::DB;
@@ -32,7 +33,7 @@ use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
     IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
-    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, PointOffsetType,
+    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
 };
 
 pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index e2620abe8..6c3580ebc 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,10 +12,10 @@ use rocksdb::DB;
 use schemars::_serde_json::Value;
 
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::{IndexesMap, JsonPathPayload, MultiValue};
 use crate::common::Flusher;
-use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{

commit 2421624c1764a68d47a097c6384a878383b79537
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Oct 30 18:02:52 2023 +0100

    Return visited list by drop (#2801)
    
    * return visited list by drop
    
    * review remarks

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 6c3580ebc..0f45e9f96 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -436,9 +436,6 @@ impl PayloadIndex for StructPayloadIndex {
                 .filter(|&id| !visited_list.check_and_update_visited(id))
                 .filter(move |&i| struct_filtered_context.check(i))
                 .collect();
-
-            self.visited_pool.return_back(visited_list);
-
             preselected
         }
     }

commit 6632ba002cd7f9d1f175ef74cde08f2f9df62933
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Dec 19 17:10:19 2023 +0000

    fix missing indexing values on set-payload operation (#3251)
    
    * fix missing indexing values on set-payload operation
    
    * Update function documentation, use conventional warning
    
    * Don't deep match statements
    
    * test: Update of payload on already indexed payload should work (#3253)
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Kumar Shivendu <kshivendu1@gmail.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 0f45e9f96..daa0a65c0 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -475,9 +475,11 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
         for (field, field_index) in &mut self.field_indexes {
-            let field_value = &payload.get_value(field);
-            for index in field_index {
-                index.add_point(point_id, field_value)?;
+            let field_value_opt = &payload.get_value_opt(field);
+            if let Some(field_value) = field_value_opt {
+                for index in field_index {
+                    index.add_point(point_id, field_value)?;
+                }
             }
         }
         self.payload.borrow_mut().assign(point_id, payload)

commit 87b541bb41560adf4609190cc0a7c1ed1da6e2f3
Author: shylock <tcath2s@gmail.com>
Date:   Thu Feb 15 22:15:05 2024 +0800

    Feat/set payload by key (#3548)
    
    * Support set by key in low level.
    
    * Rename key field.
    
    * Format.
    
    * Pass key.
    
    * Format.
    
    * Test.
    
    * Clippy.
    
    * Fix ci lint.
    
    * Check grpc consistency.
    
    * Update openapi.
    
    * Fix empty key test case.
    
    * Support array index.
    
    * Format.
    
    * Add test for non exists key.
    
    * Clippy fix.
    
    * Add idempotence test.
    
    * Update index by updated payload.
    
    * Add ut for utils.
    
    * Add ut for 1 level key.
    
    * Fix ut.
    
    * Support no exits key.
    
    * Fix test result.
    
    * Fix after rebase
    
    * handle wildcart insertion into non-existing array
    
    * avoid double read of payload during update
    
    * fix missing removing data from index in case if set_payload removes indexed field
    
    ---------
    
    Co-authored-by: Shylock Hg <shylock@DESKTOP-40I855A>
    Co-authored-by: Albert Safin <xzfcpw@gmail.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index daa0a65c0..3e2734c0c 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -473,16 +473,34 @@ impl PayloadIndex for StructPayloadIndex {
         }
     }
 
-    fn assign(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
+    fn assign(
+        &mut self,
+        point_id: PointOffsetType,
+        payload: &Payload,
+        key: &Option<String>,
+    ) -> OperationResult<()> {
+        if let Some(key) = key {
+            self.payload
+                .borrow_mut()
+                .assign_by_key(point_id, payload, key)?;
+        } else {
+            self.payload.borrow_mut().assign(point_id, payload)?;
+        };
+
+        let updated_payload = self.payload(point_id)?;
         for (field, field_index) in &mut self.field_indexes {
-            let field_value_opt = &payload.get_value_opt(field);
-            if let Some(field_value) = field_value_opt {
+            let field_value_opt = updated_payload.get_value_opt(field);
+            if let Some(field_value) = &field_value_opt {
                 for index in field_index {
                     index.add_point(point_id, field_value)?;
                 }
+            } else {
+                for index in field_index {
+                    index.remove_point(point_id)?;
+                }
             }
         }
-        self.payload.borrow_mut().assign(point_id, payload)
+        Ok(())
     }
 
     fn payload(&self, point_id: PointOffsetType) -> OperationResult<Payload> {

commit 395a19f2c1fc0266406f23bda3c6f77434188c7a
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Feb 20 23:07:15 2024 +0000

    Use SmallVec instead of MultiValue (#3639)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 3e2734c0c..229b2c651 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -14,7 +14,7 @@ use schemars::_serde_json::Value;
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
-use crate::common::utils::{IndexesMap, JsonPathPayload, MultiValue};
+use crate::common::utils::{IndexesMap, JsonPathPayload};
 use crate::common::Flusher;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
@@ -552,12 +552,11 @@ impl PayloadIndex for StructPayloadIndex {
         let mut schema = None;
         self.payload.borrow().iter(|_id, payload: &Payload| {
             let field_value = payload.get_value(key);
-            match field_value {
-                MultiValue::Single(field_value) => schema = field_value.and_then(infer_value_type),
-                MultiValue::Multiple(fields_values) => {
-                    schema = infer_collection_value_type(fields_values)
-                }
-            }
+            schema = match field_value.as_slice() {
+                [] => None,
+                [single] => infer_value_type(single),
+                multiple => infer_collection_value_type(multiple.iter().copied()),
+            };
             Ok(false)
         })?;
         Ok(schema)

commit 5b13369e1c90de01cf9d7a0b13a84cab731f757c
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Feb 22 10:39:54 2024 +0000

    Drop PayloadContainer::get_value_opt (#3666)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 229b2c651..120f0790c 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -489,10 +489,10 @@ impl PayloadIndex for StructPayloadIndex {
 
         let updated_payload = self.payload(point_id)?;
         for (field, field_index) in &mut self.field_indexes {
-            let field_value_opt = updated_payload.get_value_opt(field);
-            if let Some(field_value) = &field_value_opt {
+            let field_value = updated_payload.get_value(field);
+            if !field_value.is_empty() {
                 for index in field_index {
-                    index.add_point(point_id, field_value)?;
+                    index.add_point(point_id, &field_value)?;
                 }
             } else {
                 for index in field_index {

commit 3beb4e3b4ff4b3f9585337f4e5b0826a14e247b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Feb 23 14:38:40 2024 +0000

    Introduce JsonPathString (#3674)
    
    * Introduce JsonPathString
    
    * Fix fomatting

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 120f0790c..a9ae09f12 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -14,7 +14,7 @@ use schemars::_serde_json::Value;
 use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
-use crate::common::utils::{IndexesMap, JsonPathPayload};
+use crate::common::utils::IndexesMap;
 use crate::common::Flusher;
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::index_selector::index_selector;
@@ -27,6 +27,7 @@ use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
+use crate::json_path::{JsonPath, JsonPathInterface as _};
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
@@ -58,13 +59,13 @@ impl StructPayloadIndex {
     pub fn estimate_field_condition(
         &self,
         condition: &FieldCondition,
-        nested_path: Option<&JsonPathPayload>,
+        nested_path: Option<&JsonPath>,
     ) -> Option<CardinalityEstimation> {
-        let full_path = JsonPathPayload::extend_or_new(nested_path, &condition.key);
-        self.field_indexes.get(&full_path.path).and_then(|indexes| {
+        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
+        self.field_indexes.get(&full_path).and_then(|indexes| {
             // rewrite condition with fullpath to enable cardinality estimation
             let full_path_condition = FieldCondition {
-                key: full_path.path,
+                key: full_path,
                 ..condition.clone()
             };
 
@@ -197,7 +198,7 @@ impl StructPayloadIndex {
         payload_schema: PayloadFieldSchema,
     ) -> OperationResult<()> {
         let field_indexes = self.build_field_indexes(field, payload_schema)?;
-        self.field_indexes.insert(field.into(), field_indexes);
+        self.field_indexes.insert(field.clone(), field_indexes);
         Ok(())
     }
 
@@ -225,19 +226,18 @@ impl StructPayloadIndex {
     fn condition_cardinality(
         &self,
         condition: &Condition,
-        nested_path: Option<&JsonPathPayload>,
+        nested_path: Option<&JsonPath>,
     ) -> CardinalityEstimation {
         match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
             Condition::Nested(nested) => {
                 // propagate complete nested path in case of multiple nested layers
-                let full_path = JsonPathPayload::extend_or_new(nested_path, &nested.array_key());
+                let full_path = JsonPath::extend_or_new(nested_path, &nested.array_key());
                 self.estimate_nested_cardinality(nested.filter(), &full_path)
             }
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
                 let available_points = self.available_point_count();
-                let full_path = JsonPathPayload::extend_or_new(nested_path, &field.key);
-                let full_path = full_path.path;
+                let full_path = JsonPath::extend_or_new(nested_path, &field.key);
 
                 let mut indexed_points = 0;
                 if let Some(field_indexes) = self.field_indexes.get(&full_path) {
@@ -265,8 +265,7 @@ impl StructPayloadIndex {
             }
             Condition::IsNull(IsNullCondition { is_null: field }) => {
                 let available_points = self.available_point_count();
-                let full_path = JsonPathPayload::extend_or_new(nested_path, &field.key);
-                let full_path = full_path.path;
+                let full_path = JsonPath::extend_or_new(nested_path, &field.key);
 
                 let mut indexed_points = 0;
                 if let Some(field_indexes) = self.field_indexes.get(&full_path) {
@@ -383,7 +382,7 @@ impl PayloadIndex for StructPayloadIndex {
     fn estimate_nested_cardinality(
         &self,
         query: &Filter,
-        nested_path: &JsonPathPayload,
+        nested_path: &JsonPath,
     ) -> CardinalityEstimation {
         let available_points = self.available_point_count();
         let estimator =
@@ -477,7 +476,7 @@ impl PayloadIndex for StructPayloadIndex {
         &mut self,
         point_id: PointOffsetType,
         payload: &Payload,
-        key: &Option<String>,
+        key: &Option<JsonPath>,
     ) -> OperationResult<()> {
         if let Some(key) = key {
             self.payload

commit ea59ff6577076769620599fe8d3bd500c8d5eae0
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Feb 29 16:09:39 2024 +0000

    Use new safe_to_set/safe_to_remove functions (#3722)
    
    * Switch to JsonPathV2
    
    * Use new safe_to_set/safe_to_remove functions, fix PayloadIndex::assign
    
    * minor review fixes
    
    * Rename and inverse
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a9ae09f12..cbe785560 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -488,6 +488,9 @@ impl PayloadIndex for StructPayloadIndex {
 
         let updated_payload = self.payload(point_id)?;
         for (field, field_index) in &mut self.field_indexes {
+            if !field.is_affected_by_value_set(&payload.0, key.as_ref()) {
+                continue;
+            }
             let field_value = updated_payload.get_value(field);
             if !field_value.is_empty() {
                 for index in field_index {

commit a08b82777cd628c660b3a2f2da007fadbef7ac70
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Mar 5 00:55:58 2024 +0300

    remove ArcAtomicRefCellIterator (#3770)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index cbe785560..b695b3caf 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -11,7 +11,6 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
-use crate::common::arc_atomic_ref_cell_iterator::ArcAtomicRefCellIterator;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
@@ -396,10 +395,8 @@ impl PayloadIndex for StructPayloadIndex {
         let query_cardinality = self.estimate_cardinality(query);
 
         if query_cardinality.primary_clauses.is_empty() {
-            let full_scan_iterator =
-                ArcAtomicRefCellIterator::new(self.id_tracker.clone(), |points_iterator| {
-                    points_iterator.iter_ids()
-                });
+            let id_tracker = self.id_tracker.borrow();
+            let full_scan_iterator = id_tracker.iter_ids();
 
             let struct_filtered_context = self.struct_filtered_context(query);
             // Worst case: query expected to return few matches, but index can't be used

commit ed4e2fd10679953e9424688d5eb135eb0ab263bd
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Jun 19 12:14:26 2024 +0200

    Rework `CommitHashRing` consensus message into `CommitRead`/`CommitWrite`/`Finish` (#4417)
    
    * Refactor `CommitHashRing` into `CommitRead`/`CommitWrite`/`Finish`
    
    * Add `Resharding` filter condition
    
    * Filter "resharded" points from search, scroll by, count and retrieve request results
    
    * fixup! Refactor `CommitHashRing` into `CommitRead`/`CommitWrite`/`Finish`
    
    `cargo clippy --fix`
    
    * Apply suggestions from code review
    
    * fixup! Filter "resharded" points from search, scroll by, count and retrieve request results
    
    Add `Condition::is_local_only` method
    
    * fixup! Add `Resharding` filter condition
    
    * fixup! Filter "resharded" points from search, scroll by, count and retrieve request results
    
    Clarified a few `TODO`s
    
    * Fix clippy suggestions
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index b695b3caf..f90da0b59 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -305,9 +305,14 @@ impl StructPayloadIndex {
                     max: num_ids,
                 }
             }
+
             Condition::Field(field_condition) => self
                 .estimate_field_condition(field_condition, nested_path)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
+
+            Condition::Resharding(cond) => {
+                cond.estimate_cardinality(self.id_tracker.borrow().available_point_count())
+            }
         }
     }
 

commit a06d20fb58a70f369c3a3b40178b726a291e6423
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 8 07:51:59 2024 +0000

    Remove dead code (#4623)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index f90da0b59..9368151a9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -36,8 +36,6 @@ use crate::types::{
     PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
 };
 
-pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";
-
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 pub struct StructPayloadIndex {
     /// Payload storage

commit 54c0d94f5ab76ca80a69b7d60dfedf7d7e2b32c2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Jul 9 14:19:42 2024 +0200

    Derive/implement `fmt::Debug` for `Segment` (#4632)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 9368151a9..b7c126a25 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -37,6 +37,7 @@ use crate::types::{
 };
 
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
+#[derive(Debug)]
 pub struct StructPayloadIndex {
     /// Payload storage
     payload: Arc<AtomicRefCell<PayloadStorageEnum>>,

commit 4fdf7152f0977adc07bdf9258109ed8600c13f9f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jul 11 04:06:40 2024 +0000

    Drop JsonPathString (#4621)
    
    * drop some code
    
    * Drop JsonPathString
    
    * Fix test_remove_key
    
    Drop failing tests:
    - Deleting array indices is not idempotent, so we don't support it.
    - Empty JSONPath is not supported.
    
    * Make json_path::path() non-generic
    
    * Remove references to JsonPathV2
    
    * Drop JsonPathInterface
    
    * Move json_path::v2 code into json_path
    
    * Drop validate_not_empty
    
    * Drop JsonPath::head() as being unused
    
    * Replace path() with JsonPath::new()
    
    * Restore comments
    
    * Move tests to json_path
    
    * Use json() consistently in tests
    
    * Replace many into calls with Into trait
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index b7c126a25..d47b2bdc9 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -26,7 +26,7 @@ use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
 use crate::index::PayloadIndex;
-use crate::json_path::{JsonPath, JsonPathInterface as _};
+use crate::json_path::JsonPath;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
@@ -343,8 +343,10 @@ impl PayloadIndex for StructPayloadIndex {
     fn set_indexed(
         &mut self,
         field: PayloadKeyTypeRef,
-        payload_schema: PayloadFieldSchema,
+        payload_schema: impl Into<PayloadFieldSchema>,
     ) -> OperationResult<()> {
+        let payload_schema = payload_schema.into();
+
         if let Some(prev_schema) = self
             .config
             .indexed_fields

commit f7ad76d7ecfa445c4954b2efa5a4b58b3f73b7fa
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 15 10:19:31 2024 +0200

    Fix full payload update (#4663)
    
    * refactor assign_all payload to avoid double change of payload storage
    
    * fmt
    
    * implement assign_all for payload sotrage

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index d47b2bdc9..e476f1796 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -333,6 +333,15 @@ impl StructPayloadIndex {
     ) -> OperationResult<()> {
         crate::rocksdb_backup::restore(snapshot_path, &segment_path.join("payload_index"))
     }
+
+    fn clear_index_for_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
+        for (_, field_indexes) in self.field_indexes.iter_mut() {
+            for index in field_indexes {
+                index.remove_point(point_id)?;
+            }
+        }
+        Ok(())
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {
@@ -475,6 +484,24 @@ impl PayloadIndex for StructPayloadIndex {
         }
     }
 
+    fn assign_all(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
+        self.payload.borrow_mut().assign_all(point_id, payload)?;
+
+        for (field, field_index) in &mut self.field_indexes {
+            let field_value = payload.get_value(field);
+            if !field_value.is_empty() {
+                for index in field_index {
+                    index.add_point(point_id, &field_value)?;
+                }
+            } else {
+                for index in field_index {
+                    index.remove_point(point_id)?;
+                }
+            }
+        }
+        Ok(())
+    }
+
     fn assign(
         &mut self,
         point_id: PointOffsetType,
@@ -526,11 +553,7 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn drop(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {
-        for (_, field_indexes) in self.field_indexes.iter_mut() {
-            for index in field_indexes {
-                index.remove_point(point_id)?;
-            }
-        }
+        self.clear_index_for_point(point_id)?;
         self.payload.borrow_mut().drop(point_id)
     }
 

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index e476f1796..1de487691 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -342,6 +342,9 @@ impl StructPayloadIndex {
         }
         Ok(())
     }
+    pub fn config(&self) -> &PayloadConfig {
+        &self.config
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {

commit f35f512605437d671bb81eec83a24a6d3509bc13
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 10:19:23 2024 +0000

    Introduce FieldIndexBuilder (#4717)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 1de487691..bcbf0be31 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -11,6 +11,8 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
+use super::field_index::index_selector::index_builder_selector;
+use super::field_index::FieldIndexBuilderTrait as _;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
@@ -175,19 +177,23 @@ impl StructPayloadIndex {
         payload_schema: PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
-        let mut field_indexes = index_selector(field, &payload_schema, self.db.clone(), true);
-        for index in &field_indexes {
-            index.recreate()?;
+        let mut builders = index_builder_selector(field, &payload_schema, self.db.clone());
+        for index in &mut builders {
+            index.init()?;
         }
 
         payload_storage.iter(|point_id, point_payload| {
             let field_value = &point_payload.get_value(field);
-            for field_index in field_indexes.iter_mut() {
-                field_index.add_point(point_id, field_value)?;
+            for builder in builders.iter_mut() {
+                builder.add_point(point_id, field_value)?;
             }
             Ok(true)
         })?;
-        Ok(field_indexes)
+
+        builders
+            .into_iter()
+            .map(|builder| builder.finalize())
+            .collect()
     }
 
     fn build_and_save(

commit ab714cdfecc3f70f330ecdc0d262b39fe6440be7
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Thu Jul 25 16:05:12 2024 -0400

    Use option in `filter` and `estimate_cardinality` (#4747)
    
    * chore: filter returns option
    
    * chore: make estimate_cardinality return Option
    
    * better comment

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index bcbf0be31..2b33e910e 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -71,7 +71,7 @@ impl StructPayloadIndex {
 
             indexes
                 .iter()
-                .find_map(|index| index.estimate_cardinality(&full_path_condition).ok())
+                .find_map(|index| index.estimate_cardinality(&full_path_condition))
         })
     }
 
@@ -85,7 +85,7 @@ impl StructPayloadIndex {
             .and_then(|indexes| {
                 indexes
                     .iter()
-                    .find_map(|field_index| field_index.filter(field_condition).ok())
+                    .find_map(|field_index| field_index.filter(field_condition))
             });
         indexes
     }

commit eb679ff097c79aba3f11b0f0b01d307d2e163d0c
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Tue Jul 30 13:18:19 2024 -0400

    Facets in segment (#4753)
    
    * faceting in segment
    
    * Add segment integration test
    
    * nits
    
    * count from filtered stream, not value->points map directly
    
    * drop AtomicRef from fn signature
    
    * count only unique values per point
    
    * use entry in hashmap
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2b33e910e..91d99dacb 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -6,6 +6,7 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
+use itertools::Either;
 use log::debug;
 use parking_lot::RwLock;
 use rocksdb::DB;
@@ -213,7 +214,7 @@ impl StructPayloadIndex {
         self.id_tracker.borrow().available_point_count()
     }
 
-    fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
+    pub fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
         let estimator = |condition: &Condition| self.condition_cardinality(condition, None);
         let id_tracker = self.id_tracker.borrow();
         let payload_provider = PayloadProvider::new(self.payload.clone());
@@ -351,6 +352,49 @@ impl StructPayloadIndex {
     pub fn config(&self) -> &PayloadConfig {
         &self.config
     }
+
+    pub fn iter_filtered_points<'a>(
+        &'a self,
+        filter: &'a Filter,
+        id_tracker: &'a IdTrackerSS,
+        query_cardinality: &'a CardinalityEstimation,
+    ) -> impl Iterator<Item = PointOffsetType> + 'a {
+        if query_cardinality.primary_clauses.is_empty() {
+            let full_scan_iterator = id_tracker.iter_ids();
+
+            let struct_filtered_context = self.struct_filtered_context(filter);
+            // Worst case: query expected to return few matches, but index can't be used
+            let matched_points =
+                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
+
+            Either::Left(matched_points)
+        } else {
+            let struct_filtered_context = self.struct_filtered_context(filter);
+
+            // CPU-optimized strategy here: points are made unique before applying other filters.
+            let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
+
+            let iter = query_cardinality
+                .primary_clauses
+                .iter()
+                .flat_map(|clause| {
+                    match clause {
+                        PrimaryCondition::Condition(field_condition) => {
+                            self.query_field(field_condition).unwrap_or_else(
+                                || id_tracker.iter_ids(), /* index is not built */
+                            )
+                        }
+                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
+                        PrimaryCondition::IsEmpty(_) => id_tracker.iter_ids(), /* there are no fast index for IsEmpty */
+                        PrimaryCondition::IsNull(_) => id_tracker.iter_ids(),  /* no fast index for IsNull too */
+                    }
+                })
+                .filter(move |&id| !visited_list.check_and_update_visited(id))
+                .filter(move |&i| struct_filtered_context.check(i));
+
+            Either::Right(iter)
+        }
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {
@@ -415,49 +459,10 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn query_points(&self, query: &Filter) -> Vec<PointOffsetType> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
-
         let query_cardinality = self.estimate_cardinality(query);
-
-        if query_cardinality.primary_clauses.is_empty() {
-            let id_tracker = self.id_tracker.borrow();
-            let full_scan_iterator = id_tracker.iter_ids();
-
-            let struct_filtered_context = self.struct_filtered_context(query);
-            // Worst case: query expected to return few matches, but index can't be used
-            let matched_points =
-                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
-
-            matched_points.collect()
-        } else {
-            let points_iterator_ref = self.id_tracker.borrow();
-            let struct_filtered_context = self.struct_filtered_context(query);
-
-            // CPU-optimized strategy here: points are made unique before applying other filters.
-            // TODO: Implement iterator which holds the `visited_pool` and borrowed `vector_storage_ref` to prevent `preselected` array creation
-            let mut visited_list = self
-                .visited_pool
-                .get(points_iterator_ref.total_point_count());
-
-            let preselected: Vec<PointOffsetType> = query_cardinality
-                .primary_clauses
-                .iter()
-                .flat_map(|clause| {
-                    match clause {
-                        PrimaryCondition::Condition(field_condition) => {
-                            self.query_field(field_condition).unwrap_or_else(
-                                || points_iterator_ref.iter_ids(), /* index is not built */
-                            )
-                        }
-                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
-                        PrimaryCondition::IsEmpty(_) => points_iterator_ref.iter_ids(), /* there are no fast index for IsEmpty */
-                        PrimaryCondition::IsNull(_) => points_iterator_ref.iter_ids(),  /* no fast index for IsNull too */
-                    }
-                })
-                .filter(|&id| !visited_list.check_and_update_visited(id))
-                .filter(move |&i| struct_filtered_context.check(i))
-                .collect();
-            preselected
-        }
+        let id_tracker = self.id_tracker.borrow();
+        self.iter_filtered_points(query, &*id_tracker, &query_cardinality)
+            .collect()
     }
 
     fn indexed_points(&self, field: PayloadKeyTypeRef) -> usize {

commit 0c23f81e52a62f3a37816a3bdafdc7f82e062d90
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Aug 2 13:48:45 2024 +0200

    Refactor resharding filter (#4799)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 91d99dacb..400cf908f 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -316,7 +316,7 @@ impl StructPayloadIndex {
                 .estimate_field_condition(field_condition, nested_path)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
 
-            Condition::Resharding(cond) => {
+            Condition::CustomIdChecker(cond) => {
                 cond.estimate_cardinality(self.id_tracker.borrow().available_point_count())
             }
         }

commit 7ea8e1ec7d378739ae8a6bf524daf31df2bb5b87
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 19:45:14 2024 +0000

    Integrate map/numeric mmap indices (#4809)
    
    * Extend FieldIndexBuilder with mmap indices
    
    * Introduce PayloadFieldIndex::files()
    
    * Create and delete index dirs
    
    * Update index_selector and index_builder_selector

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 400cf908f..5377e6497 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,14 +12,15 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
-use super::field_index::index_selector::index_builder_selector;
+use super::field_index::index_selector::{
+    IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
+};
 use super::field_index::FieldIndexBuilderTrait as _;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
 use crate::common::Flusher;
 use crate::id_tracker::IdTrackerSS;
-use crate::index::field_index::index_selector::index_selector;
 use crate::index::field_index::{
     CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
 };
@@ -54,6 +55,7 @@ pub struct StructPayloadIndex {
     /// Used to select unique point ids
     visited_pool: VisitedPool,
     db: Arc<RwLock<DB>>,
+    is_appendable: bool,
 }
 
 impl StructPayloadIndex {
@@ -100,11 +102,11 @@ impl StructPayloadIndex {
         self.config.save(&config_path)
     }
 
-    fn load_all_fields(&mut self, is_appendable: bool) -> OperationResult<()> {
+    fn load_all_fields(&mut self) -> OperationResult<()> {
         let mut field_indexes: IndexesMap = Default::default();
 
         for (field, payload_schema) in &self.config.indexed_fields {
-            let field_index = self.load_from_db(field, payload_schema.to_owned(), is_appendable)?;
+            let field_index = self.load_from_db(field, payload_schema.to_owned())?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;
@@ -115,9 +117,10 @@ impl StructPayloadIndex {
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: PayloadFieldSchema,
-        is_appendable: bool,
     ) -> OperationResult<Vec<FieldIndex>> {
-        let mut indexes = index_selector(field, &payload_schema, self.db.clone(), is_appendable);
+        let mut indexes = self
+            .selector(&payload_schema)
+            .new_index(field, &payload_schema)?;
 
         let mut is_loaded = true;
         for ref mut index in indexes.iter_mut() {
@@ -160,6 +163,7 @@ impl StructPayloadIndex {
             path: path.to_owned(),
             visited_pool: Default::default(),
             db,
+            is_appendable,
         };
 
         if !index.config_path().exists() {
@@ -167,7 +171,7 @@ impl StructPayloadIndex {
             index.save_config()?;
         }
 
-        index.load_all_fields(is_appendable)?;
+        index.load_all_fields()?;
 
         Ok(index)
     }
@@ -178,7 +182,10 @@ impl StructPayloadIndex {
         payload_schema: PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
-        let mut builders = index_builder_selector(field, &payload_schema, self.db.clone());
+        let mut builders = self
+            .selector(&payload_schema)
+            .index_builder(field, &payload_schema)?;
+
         for index in &mut builders {
             index.init()?;
         }
@@ -395,6 +402,17 @@ impl StructPayloadIndex {
             Either::Right(iter)
         }
     }
+
+    fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {
+        if !self.is_appendable && payload_schema.is_on_disk() {
+            IndexSelector::OnDisk(IndexSelectorOnDisk { dir: &self.path })
+        } else {
+            IndexSelector::RocksDb(IndexSelectorRocksDb {
+                db: &self.db,
+                is_appendable: self.is_appendable,
+            })
+        }
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {

commit d1b48a0f98b4efc479658274385fa559fabad5c8
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Aug 7 15:40:10 2024 +0200

    fix mmap field index snapshot (#4847)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 5377e6497..565bdb795 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -627,6 +627,12 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        vec![self.config_path()]
+        let mut files = self
+            .field_indexes
+            .values()
+            .flat_map(|indexes| indexes.iter().flat_map(|index| index.files().into_iter()))
+            .collect::<Vec<PathBuf>>();
+        files.push(self.config_path());
+        files
     }
 }

commit 3185dd23c50f02e8f38c10839ff622fc2bd3a072
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Mon Aug 19 23:21:17 2024 -0400

    Exact facet mode (#4878)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 565bdb795..b1cbc4475 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -15,7 +15,7 @@ use schemars::_serde_json::Value;
 use super::field_index::index_selector::{
     IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
 };
-use super::field_index::FieldIndexBuilderTrait as _;
+use super::field_index::{FacetIndex, FieldIndexBuilderTrait as _};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
@@ -413,6 +413,15 @@ impl StructPayloadIndex {
             })
         }
     }
+
+    pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndex> {
+        self.field_indexes
+            .get(key)
+            .and_then(|index| index.iter().find_map(|index| index.as_facet_index()))
+            .ok_or_else(|| OperationError::MissingMapIndexForFacet {
+                key: key.to_string(),
+            })
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {

commit 96158c6f27c8a5d4366ecb88118f1808a6dd642f
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Fri Aug 23 08:30:45 2024 -0400

    fix: Non-blocking payload index building (#4941)
    
    * separate index creation into build and apply
    
    * check version in Segment impl of `build_field_index`
    
    * add wait to issues test
    
    * fix consensus tests

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index b1cbc4475..6fe1fee77 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -106,7 +106,7 @@ impl StructPayloadIndex {
         let mut field_indexes: IndexesMap = Default::default();
 
         for (field, payload_schema) in &self.config.indexed_fields {
-            let field_index = self.load_from_db(field, payload_schema.to_owned())?;
+            let field_index = self.load_from_db(field, payload_schema)?;
             field_indexes.insert(field.clone(), field_index);
         }
         self.field_indexes = field_indexes;
@@ -116,11 +116,11 @@ impl StructPayloadIndex {
     fn load_from_db(
         &self,
         field: PayloadKeyTypeRef,
-        payload_schema: PayloadFieldSchema,
+        payload_schema: &PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let mut indexes = self
-            .selector(&payload_schema)
-            .new_index(field, &payload_schema)?;
+            .selector(payload_schema)
+            .new_index(field, payload_schema)?;
 
         let mut is_loaded = true;
         for ref mut index in indexes.iter_mut() {
@@ -179,12 +179,12 @@ impl StructPayloadIndex {
     pub fn build_field_indexes(
         &self,
         field: PayloadKeyTypeRef,
-        payload_schema: PayloadFieldSchema,
+        payload_schema: &PayloadFieldSchema,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
         let mut builders = self
-            .selector(&payload_schema)
-            .index_builder(field, &payload_schema)?;
+            .selector(payload_schema)
+            .index_builder(field, payload_schema)?;
 
         for index in &mut builders {
             index.init()?;
@@ -204,16 +204,6 @@ impl StructPayloadIndex {
             .collect()
     }
 
-    fn build_and_save(
-        &mut self,
-        field: PayloadKeyTypeRef,
-        payload_schema: PayloadFieldSchema,
-    ) -> OperationResult<()> {
-        let field_indexes = self.build_field_indexes(field, payload_schema)?;
-        self.field_indexes.insert(field.clone(), field_indexes);
-        Ok(())
-    }
-
     /// Number of available points
     ///
     /// - excludes soft deleted points
@@ -429,25 +419,34 @@ impl PayloadIndex for StructPayloadIndex {
         self.config.indexed_fields.clone()
     }
 
-    fn set_indexed(
-        &mut self,
+    fn build_index(
+        &self,
         field: PayloadKeyTypeRef,
-        payload_schema: impl Into<PayloadFieldSchema>,
-    ) -> OperationResult<()> {
-        let payload_schema = payload_schema.into();
-
-        if let Some(prev_schema) = self
-            .config
-            .indexed_fields
-            .insert(field.to_owned(), payload_schema.clone())
-        {
+        payload_schema: &PayloadFieldSchema,
+    ) -> OperationResult<Option<Vec<FieldIndex>>> {
+        if let Some(prev_schema) = self.config.indexed_fields.get(field) {
             // the field is already indexed with the same schema
             // no need to rebuild index and to save the config
             if prev_schema == payload_schema {
-                return Ok(());
+                return Ok(None);
             }
         }
-        self.build_and_save(field, payload_schema)?;
+
+        let indexes = self.build_field_indexes(field, payload_schema)?;
+
+        Ok(Some(indexes))
+    }
+
+    fn apply_index(
+        &mut self,
+        field: PayloadKeyType,
+        payload_schema: PayloadFieldSchema,
+        field_index: Vec<FieldIndex>,
+    ) -> OperationResult<()> {
+        self.field_indexes.insert(field.clone(), field_index);
+
+        self.config.indexed_fields.insert(field, payload_schema);
+
         self.save_config()?;
 
         Ok(())

commit 4b429214cc3feeede5d5ab2912fad76523219c4e
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Tue Aug 27 11:30:57 2024 -0400

    Integer and UUID facets (#4946)
    
    * move FacetIndex into facet_index.rs
    
    * add support for integer facets
    
    * add support for uuid facets
    
    * use separate internal structure
    
    * rename FacetValue::Keyword into FacetValue::String in REST
    
    * fix after rebase

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 6fe1fee77..ef29f3d83 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,10 +12,11 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
+use super::field_index::facet_index::FacetIndex;
 use super::field_index::index_selector::{
     IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
 };
-use super::field_index::{FacetIndex, FieldIndexBuilderTrait as _};
+use super::field_index::FieldIndexBuilderTrait as _;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;

commit e9bdbbb4c540e81ba94a969dce826b3fc71b36b2
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Thu Aug 29 05:16:43 2024 -0400

    Refactor condition converter, use uuid index there too (#4977)
    
    * refactor condition converter, use uuid index here too
    
    * re-disable index for values_count
    
    * clippy

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index ef29f3d83..46a73d06f 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -357,18 +357,17 @@ impl StructPayloadIndex {
         id_tracker: &'a IdTrackerSS,
         query_cardinality: &'a CardinalityEstimation,
     ) -> impl Iterator<Item = PointOffsetType> + 'a {
+        let struct_filtered_context = self.struct_filtered_context(filter);
+
         if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator = id_tracker.iter_ids();
 
-            let struct_filtered_context = self.struct_filtered_context(filter);
             // Worst case: query expected to return few matches, but index can't be used
             let matched_points =
                 full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
 
             Either::Left(matched_points)
         } else {
-            let struct_filtered_context = self.struct_filtered_context(filter);
-
             // CPU-optimized strategy here: points are made unique before applying other filters.
             let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
 

commit 4f59f72c02e6b62f027c88888831c1bf60f24019
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 16 12:42:11 2024 +0200

    Rename payload storage operations for consistency (#5087)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 46a73d06f..6c2792cec 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -524,8 +524,12 @@ impl PayloadIndex for StructPayloadIndex {
         }
     }
 
-    fn assign_all(&mut self, point_id: PointOffsetType, payload: &Payload) -> OperationResult<()> {
-        self.payload.borrow_mut().assign_all(point_id, payload)?;
+    fn overwrite_payload(
+        &mut self,
+        point_id: PointOffsetType,
+        payload: &Payload,
+    ) -> OperationResult<()> {
+        self.payload.borrow_mut().overwrite(point_id, payload)?;
 
         for (field, field_index) in &mut self.field_indexes {
             let field_value = payload.get_value(field);
@@ -542,7 +546,7 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn assign(
+    fn set_payload(
         &mut self,
         point_id: PointOffsetType,
         payload: &Payload,
@@ -551,12 +555,12 @@ impl PayloadIndex for StructPayloadIndex {
         if let Some(key) = key {
             self.payload
                 .borrow_mut()
-                .assign_by_key(point_id, payload, key)?;
+                .set_by_key(point_id, payload, key)?;
         } else {
-            self.payload.borrow_mut().assign(point_id, payload)?;
+            self.payload.borrow_mut().set(point_id, payload)?;
         };
 
-        let updated_payload = self.payload(point_id)?;
+        let updated_payload = self.get_payload(point_id)?;
         for (field, field_index) in &mut self.field_indexes {
             if !field.is_affected_by_value_set(&payload.0, key.as_ref()) {
                 continue;
@@ -575,11 +579,11 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn payload(&self, point_id: PointOffsetType) -> OperationResult<Payload> {
-        self.payload.borrow().payload(point_id)
+    fn get_payload(&self, point_id: PointOffsetType) -> OperationResult<Payload> {
+        self.payload.borrow().get(point_id)
     }
 
-    fn delete(
+    fn delete_payload(
         &mut self,
         point_id: PointOffsetType,
         key: PayloadKeyTypeRef,
@@ -592,9 +596,9 @@ impl PayloadIndex for StructPayloadIndex {
         self.payload.borrow_mut().delete(point_id, key)
     }
 
-    fn drop(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {
+    fn clear_payload(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {
         self.clear_index_for_point(point_id)?;
-        self.payload.borrow_mut().drop(point_id)
+        self.payload.borrow_mut().clear(point_id)
     }
 
     fn flusher(&self) -> Flusher {

commit bcf05d9e231d55f0c4317081c36d3ebc0a2de8c8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Oct 25 18:47:03 2024 +0200

    HasVector filtering condition (#5303)
    
    * include vector storage into struct vector index
    
    * implement has_vector
    
    * generate schemas
    
    * refactor query filter optimizer so avoid too many function arguments
    
    * test + fix for sparse vectors
    
    * Update lib/segment/src/index/struct_payload_index.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * Update lib/segment/src/index/query_optimization/optimizer.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * fmt
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 6c2792cec..9915cc93e 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,6 +1,5 @@
 use std::collections::{HashMap, HashSet};
 use std::fs::create_dir_all;
-use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
@@ -38,8 +37,9 @@ use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
     IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
-    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
+    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, VectorName,
 };
+use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 #[derive(Debug)]
@@ -47,7 +47,9 @@ pub struct StructPayloadIndex {
     /// Payload storage
     payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
     /// Used for `has_id` condition and estimating cardinality
-    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    pub(super) id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    /// Vector storages for each field, used for `has_vector` condition
+    pub(super) vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
     /// Indexes, associated with fields
     pub field_indexes: IndexesMap,
     config: PayloadConfig,
@@ -142,6 +144,7 @@ impl StructPayloadIndex {
     pub fn open(
         payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+        vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
         path: &Path,
         is_appendable: bool,
     ) -> OperationResult<Self> {
@@ -159,6 +162,7 @@ impl StructPayloadIndex {
         let mut index = StructPayloadIndex {
             payload,
             id_tracker,
+            vector_storages,
             field_indexes: Default::default(),
             config,
             path: path.to_owned(),
@@ -213,20 +217,15 @@ impl StructPayloadIndex {
     }
 
     pub fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
-        let estimator = |condition: &Condition| self.condition_cardinality(condition, None);
-        let id_tracker = self.id_tracker.borrow();
         let payload_provider = PayloadProvider::new(self.payload.clone());
-        StructFilterContext::new(
-            filter,
-            id_tracker.deref(),
-            payload_provider,
-            &self.field_indexes,
-            &estimator,
-            self.available_point_count(),
-        )
+
+        let (optimized_filter, _) =
+            self.optimize_filter(filter, payload_provider, self.available_point_count());
+
+        StructFilterContext::new(optimized_filter)
     }
 
-    fn condition_cardinality(
+    pub(super) fn condition_cardinality(
         &self,
         condition: &Condition,
         nested_path: Option<&JsonPath>,
@@ -309,7 +308,17 @@ impl StructPayloadIndex {
                     max: num_ids,
                 }
             }
-
+            Condition::HasVector(has_vectors) => {
+                if let Some(vector_storage) = self.vector_storages.get(&has_vectors.has_vector) {
+                    let vector_storage = vector_storage.borrow();
+                    let vectors = vector_storage.available_vector_count();
+                    CardinalityEstimation::exact(vectors).with_primary_clause(
+                        PrimaryCondition::HasVector(has_vectors.has_vector.clone()),
+                    )
+                } else {
+                    CardinalityEstimation::exact(0)
+                }
+            }
             Condition::Field(field_condition) => self
                 .estimate_field_condition(field_condition, nested_path)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
@@ -384,6 +393,7 @@ impl StructPayloadIndex {
                         PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
                         PrimaryCondition::IsEmpty(_) => id_tracker.iter_ids(), /* there are no fast index for IsEmpty */
                         PrimaryCondition::IsNull(_) => id_tracker.iter_ids(),  /* no fast index for IsNull too */
+                        PrimaryCondition::HasVector(_) => id_tracker.iter_ids(), /* no fast index for HasVector */
                     }
                 })
                 .filter(move |&id| !visited_list.check_and_update_visited(id))

commit c573f2f0a23e86cd1be27d67d17fa486a3ff9adf
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Fri Dec 6 17:29:19 2024 -0600

    Mmap bool index (#5526)
    
    * add `MmapBitSlice::extend` helper
    
    * mmap bool index implementation
    
    * unit test both implementations
    
    * switch to `DynamicMmapFlags`
    
    * tidy up
    
    * recalculate `indexed_count` on load
    
    * grow bitslice aligned to the mmap page size
    
    * ergonomic get_slice_for
    
    * fix for growing mmap
    
    * use more `get_slice_for()`

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 9915cc93e..9cef81656 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -468,7 +468,7 @@ impl PayloadIndex for StructPayloadIndex {
 
         if let Some(indexes) = removed_indexes {
             for index in indexes {
-                index.clear()?;
+                index.cleanup()?;
             }
         }
 

commit 681506cea7bd6bf7ae80114775f39580ee8392e8
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Mon Dec 16 23:35:10 2024 +0000

    Integrate mmap bool index (#5571)
    
    * add on_disk option for bool index
    
    * test that all files are covered
    
    * generate openapi and docs
    
    * clippy
    
    * remove `populate` changes
    
    * use `walkdir` crate
    
    * Apply clippy suggestions
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 9cef81656..8316f4dae 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -404,7 +404,8 @@ impl StructPayloadIndex {
     }
 
     fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {
-        if !self.is_appendable && payload_schema.is_on_disk() {
+        let is_immutable_segment = !self.is_appendable;
+        if payload_schema.is_on_disk() && (is_immutable_segment || payload_schema.is_mutable()) {
             IndexSelector::OnDisk(IndexSelectorOnDisk { dir: &self.path })
         } else {
             IndexSelector::RocksDb(IndexSelectorRocksDb {

commit 97e3f4c824a98a3621b7d48cf3e70a2f5dc7ad3c
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Dec 18 05:53:01 2024 -0300

    Introduce facet index trait (#5673)
    
    * introduce facet index trait
    
    * clippy
    
    * fix simple bool index's `get_point_values`

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 8316f4dae..065987c85 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -11,7 +11,7 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
-use super::field_index::facet_index::FacetIndex;
+use super::field_index::facet_index::FacetIndexEnum;
 use super::field_index::index_selector::{
     IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
 };
@@ -415,7 +415,7 @@ impl StructPayloadIndex {
         }
     }
 
-    pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndex> {
+    pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndexEnum> {
         self.field_indexes
             .get(key)
             .and_then(|index| index.iter().find_map(|index| index.as_facet_index()))

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 065987c85..88a9809a5 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -4,6 +4,7 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use itertools::Either;
 use log::debug;
@@ -571,7 +572,9 @@ impl PayloadIndex for StructPayloadIndex {
             self.payload.borrow_mut().set(point_id, payload)?;
         };
 
-        let updated_payload = self.get_payload(point_id)?;
+        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Implement!!
+
+        let updated_payload = self.get_payload(point_id, &hw_counter)?;
         for (field, field_index) in &mut self.field_indexes {
             if !field.is_affected_by_value_set(&payload.0, key.as_ref()) {
                 continue;
@@ -590,8 +593,12 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn get_payload(&self, point_id: PointOffsetType) -> OperationResult<Payload> {
-        self.payload.borrow().get(point_id)
+    fn get_payload(
+        &self,
+        point_id: PointOffsetType,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<Payload> {
+        self.payload.borrow().get_measured(point_id, hw_counter)
     }
 
     fn delete_payload(

commit b0eb8d3431b19ed8beaeb1ceee7872d07d620314
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 10:58:25 2025 +0100

    Io measurement rename functions (#5816)
    
    * replace _measured functions with original name
    
    * Rename more functions

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 88a9809a5..5566e7c04 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -563,18 +563,19 @@ impl PayloadIndex for StructPayloadIndex {
         point_id: PointOffsetType,
         payload: &Payload,
         key: &Option<JsonPath>,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
         if let Some(key) = key {
             self.payload
                 .borrow_mut()
-                .set_by_key(point_id, payload, key)?;
+                .set_by_key(point_id, payload, key, hw_counter)?;
         } else {
-            self.payload.borrow_mut().set(point_id, payload)?;
+            self.payload
+                .borrow_mut()
+                .set(point_id, payload, hw_counter)?;
         };
 
-        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Implement!!
-
-        let updated_payload = self.get_payload(point_id, &hw_counter)?;
+        let updated_payload = self.get_payload(point_id, hw_counter)?;
         for (field, field_index) in &mut self.field_indexes {
             if !field.is_affected_by_value_set(&payload.0, key.as_ref()) {
                 continue;
@@ -598,20 +599,21 @@ impl PayloadIndex for StructPayloadIndex {
         point_id: PointOffsetType,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Payload> {
-        self.payload.borrow().get_measured(point_id, hw_counter)
+        self.payload.borrow().get(point_id, hw_counter)
     }
 
     fn delete_payload(
         &mut self,
         point_id: PointOffsetType,
         key: PayloadKeyTypeRef,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Vec<Value>> {
         if let Some(indexes) = self.field_indexes.get_mut(key) {
             for index in indexes {
                 index.remove_point(point_id)?;
             }
         }
-        self.payload.borrow_mut().delete(point_id, key)
+        self.payload.borrow_mut().delete(point_id, key, hw_counter)
     }
 
     fn clear_payload(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {

commit c815a1bd43fb326ad2c100b72e9d916b1f3b616e
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 12:23:47 2025 +0100

    Implement more IO measurements for PayloadStorage (#5822)
    
    * Finish io measurement for payload storage
    
    * Remove done TODOs
    
    * review remarks
    
    * make signature of `wipe()` consistent
    
    * Remove hardware_counter from tracker.rs and make interfaces consistent
    
    * Add hw_counter to payloads update_storage function from dev

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 5566e7c04..a49bdf8e6 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -540,9 +540,13 @@ impl PayloadIndex for StructPayloadIndex {
         &mut self,
         point_id: PointOffsetType,
         payload: &Payload,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
-        self.payload.borrow_mut().overwrite(point_id, payload)?;
+        self.payload
+            .borrow_mut()
+            .overwrite(point_id, payload, hw_counter)?;
 
+        // TODO(io_measurement): Maybe add measurements to index here too.
         for (field, field_index) in &mut self.field_indexes {
             let field_value = payload.get_value(field);
             if !field_value.is_empty() {
@@ -616,9 +620,13 @@ impl PayloadIndex for StructPayloadIndex {
         self.payload.borrow_mut().delete(point_id, key, hw_counter)
     }
 
-    fn clear_payload(&mut self, point_id: PointOffsetType) -> OperationResult<Option<Payload>> {
+    fn clear_payload(
+        &mut self,
+        point_id: PointOffsetType,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<Option<Payload>> {
         self.clear_index_for_point(point_id)?;
-        self.payload.borrow_mut().clear(point_id)
+        self.payload.borrow_mut().clear(point_id, hw_counter)
     }
 
     fn flusher(&self) -> Flusher {

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a49bdf8e6..2455dd033 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -38,7 +38,7 @@ use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
     IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
-    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, VectorName,
+    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, VectorNameBuf,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
@@ -50,7 +50,7 @@ pub struct StructPayloadIndex {
     /// Used for `has_id` condition and estimating cardinality
     pub(super) id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Vector storages for each field, used for `has_vector` condition
-    pub(super) vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
+    pub(super) vector_storages: HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,
     /// Indexes, associated with fields
     pub field_indexes: IndexesMap,
     config: PayloadConfig,
@@ -145,7 +145,7 @@ impl StructPayloadIndex {
     pub fn open(
         payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-        vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
+        vector_storages: HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,
         path: &Path,
         is_appendable: bool,
     ) -> OperationResult<Self> {

commit 97743b1b625d42f73955ecb32d54ca34ea3a5cb7
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jan 24 16:33:44 2025 +0100

    Propagate hardware counter for more functions (#5844)
    
    * Propagate hardware counter for more functions
    
    * Minor improvements
    
    * use vector_query_contexts hardware_counter

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2455dd033..0fc91fad6 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -217,11 +217,19 @@ impl StructPayloadIndex {
         self.id_tracker.borrow().available_point_count()
     }
 
-    pub fn struct_filtered_context<'a>(&'a self, filter: &'a Filter) -> StructFilterContext<'a> {
+    pub fn struct_filtered_context<'a>(
+        &'a self,
+        filter: &'a Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> StructFilterContext<'a> {
         let payload_provider = PayloadProvider::new(self.payload.clone());
 
-        let (optimized_filter, _) =
-            self.optimize_filter(filter, payload_provider, self.available_point_count());
+        let (optimized_filter, _) = self.optimize_filter(
+            filter,
+            payload_provider,
+            self.available_point_count(),
+            hw_counter,
+        );
 
         StructFilterContext::new(optimized_filter)
     }
@@ -366,8 +374,9 @@ impl StructPayloadIndex {
         filter: &'a Filter,
         id_tracker: &'a IdTrackerSS,
         query_cardinality: &'a CardinalityEstimation,
+        hw_counter: &HardwareCounterCell,
     ) -> impl Iterator<Item = PointOffsetType> + 'a {
-        let struct_filtered_context = self.struct_filtered_context(filter);
+        let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
 
         if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator = id_tracker.iter_ids();
@@ -495,11 +504,15 @@ impl PayloadIndex for StructPayloadIndex {
         estimate_filter(&estimator, query, available_points)
     }
 
-    fn query_points(&self, query: &Filter) -> Vec<PointOffsetType> {
+    fn query_points(
+        &self,
+        query: &Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> Vec<PointOffsetType> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
         let query_cardinality = self.estimate_cardinality(query);
         let id_tracker = self.id_tracker.borrow();
-        self.iter_filtered_points(query, &*id_tracker, &query_cardinality)
+        self.iter_filtered_points(query, &*id_tracker, &query_cardinality, hw_counter)
             .collect()
     }
 
@@ -516,8 +529,12 @@ impl PayloadIndex for StructPayloadIndex {
         })
     }
 
-    fn filter_context<'a>(&'a self, filter: &'a Filter) -> Box<dyn FilterContext + 'a> {
-        Box::new(self.struct_filtered_context(filter))
+    fn filter_context<'a>(
+        &'a self,
+        filter: &'a Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> Box<dyn FilterContext + 'a> {
+        Box::new(self.struct_filtered_context(filter, hw_counter))
     }
 
     fn payload_blocks(

commit 212e229b83b7899df162ade3f328511c8a4c534e
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Fri Feb 14 11:34:22 2025 -0300

    Merge pull request #5965
    
    * begin extracting variable values
    
    * extract geo point
    
    * add extractor tests
    
    * move TODO comment
    
    * simplify fn
    
    * rename extract -> retrieve
    
    * add hw counters
    
    * use plain serde_json::Value as output
    
    * clippy
    
    * use from notation

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 0fc91fad6..a3179f128 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -46,7 +46,7 @@ use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 #[derive(Debug)]
 pub struct StructPayloadIndex {
     /// Payload storage
-    payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
+    pub(super) payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
     /// Used for `has_id` condition and estimating cardinality
     pub(super) id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     /// Vector storages for each field, used for `has_vector` condition

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a3179f128..213340da8 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -12,16 +12,17 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use schemars::_serde_json::Value;
 
+use super::field_index::FieldIndexBuilderTrait as _;
 use super::field_index::facet_index::FacetIndexEnum;
 use super::field_index::index_selector::{
     IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
 };
-use super::field_index::FieldIndexBuilderTrait as _;
+use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
-use crate::common::Flusher;
 use crate::id_tracker::IdTrackerSS;
+use crate::index::PayloadIndex;
 use crate::index::field_index::{
     CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
 };
@@ -30,15 +31,14 @@ use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
-use crate::index::PayloadIndex;
 use crate::json_path::JsonPath;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
-    IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
-    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, VectorNameBuf,
+    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, Payload,
+    PayloadContainer, PayloadField, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef,
+    PayloadSchemaType, VectorNameBuf, infer_collection_value_type, infer_value_type,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 

commit 706b1a31665ee4a2e44a0a20845bb8065b0dbc28
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 4 13:19:50 2025 +0100

    IsEmpty/IsNull index (#6088)
    
    * create initial strucutres
    
    * clippy
    
    * start field-query refactoring
    
    * start field-query refactoring (2/N)
    
    * start field-query refactoring (3/N): duplicate is_empty/null condiftions as field condition
    
    * start field-query refactoring (4/N): re-instate is_empty fallback in case new index is not built yet
    
    * filter for is_empty/is_null
    
    * implement add/remove point
    
    * upd schema
    
    * open and create of null-index
    
    * create null-index
    
    * fix test
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * unit test for null-index
    
    * more unit tests
    
    * add openapi tests
    
    * fmt
    
    * fix for integartion tests
    
    * rabbit review fix
    
    * make [null] non-empty
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 213340da8..09609db8b 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -37,8 +37,8 @@ use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, Payload,
-    PayloadContainer, PayloadField, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef,
-    PayloadSchemaType, VectorNameBuf, infer_collection_value_type, infer_value_type,
+    PayloadContainer, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
+    VectorNameBuf, infer_collection_value_type, infer_value_type,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
@@ -84,17 +84,19 @@ impl StructPayloadIndex {
 
     fn query_field<'a>(
         &'a self,
-        field_condition: &'a FieldCondition,
+        condition: &'a PrimaryCondition,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        let indexes = self
-            .field_indexes
-            .get(&field_condition.key)
-            .and_then(|indexes| {
-                indexes
+        match condition {
+            PrimaryCondition::Condition(field_condition) => {
+                let field_key = &field_condition.key;
+                let field_indexes = self.field_indexes.get(field_key)?;
+                field_indexes
                     .iter()
                     .find_map(|field_index| field_index.filter(field_condition))
-            });
-        indexes
+            }
+            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
+            PrimaryCondition::HasVector(_) => None,
+        }
     }
 
     fn config_path(&self) -> PathBuf {
@@ -248,59 +250,17 @@ impl StructPayloadIndex {
             }
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
                 let available_points = self.available_point_count();
-                let full_path = JsonPath::extend_or_new(nested_path, &field.key);
-
-                let mut indexed_points = 0;
-                if let Some(field_indexes) = self.field_indexes.get(&full_path) {
-                    for index in field_indexes {
-                        indexed_points = indexed_points.max(index.count_indexed_points())
-                    }
-                    CardinalityEstimation {
-                        primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
-                            is_empty: PayloadField { key: full_path },
-                        })],
-                        min: 0, // It is possible, that some non-empty payloads are not indexed
-                        exp: available_points.saturating_sub(indexed_points), // Expect field type consistency
-                        max: available_points.saturating_sub(indexed_points),
-                    }
-                } else {
-                    CardinalityEstimation {
-                        primary_clauses: vec![PrimaryCondition::IsEmpty(IsEmptyCondition {
-                            is_empty: PayloadField { key: full_path },
-                        })],
-                        min: 0,
-                        exp: available_points / 2,
-                        max: available_points,
-                    }
-                }
+                let condition = FieldCondition::new_is_empty(field.key.clone());
+
+                self.estimate_field_condition(&condition, nested_path)
+                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
             }
             Condition::IsNull(IsNullCondition { is_null: field }) => {
                 let available_points = self.available_point_count();
-                let full_path = JsonPath::extend_or_new(nested_path, &field.key);
-
-                let mut indexed_points = 0;
-                if let Some(field_indexes) = self.field_indexes.get(&full_path) {
-                    for index in field_indexes {
-                        indexed_points = indexed_points.max(index.count_indexed_points())
-                    }
-                    CardinalityEstimation {
-                        primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
-                            is_null: PayloadField { key: full_path },
-                        })],
-                        min: 0,
-                        exp: available_points.saturating_sub(indexed_points),
-                        max: available_points.saturating_sub(indexed_points),
-                    }
-                } else {
-                    CardinalityEstimation {
-                        primary_clauses: vec![PrimaryCondition::IsNull(IsNullCondition {
-                            is_null: PayloadField { key: full_path },
-                        })],
-                        min: 0,
-                        exp: available_points / 2,
-                        max: available_points,
-                    }
-                }
+                let condition = FieldCondition::new_is_null(field.key.clone());
+
+                self.estimate_field_condition(&condition, nested_path)
+                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
             }
             Condition::HasId(has_id) => {
                 let id_tracker_ref = self.id_tracker.borrow();
@@ -394,17 +354,8 @@ impl StructPayloadIndex {
                 .primary_clauses
                 .iter()
                 .flat_map(|clause| {
-                    match clause {
-                        PrimaryCondition::Condition(field_condition) => {
-                            self.query_field(field_condition).unwrap_or_else(
-                                || id_tracker.iter_ids(), /* index is not built */
-                            )
-                        }
-                        PrimaryCondition::Ids(ids) => Box::new(ids.iter().copied()),
-                        PrimaryCondition::IsEmpty(_) => id_tracker.iter_ids(), /* there are no fast index for IsEmpty */
-                        PrimaryCondition::IsNull(_) => id_tracker.iter_ids(),  /* no fast index for IsNull too */
-                        PrimaryCondition::HasVector(_) => id_tracker.iter_ids(), /* no fast index for HasVector */
-                    }
+                    self.query_field(clause)
+                        .unwrap_or_else(|| id_tracker.iter_ids() /* index is not built */)
                 })
                 .filter(move |&id| !visited_list.check_and_update_visited(id))
                 .filter(move |&i| struct_filtered_context.check(i));

commit 6d53bd91845ee56bb252c08716fdf46d883c48aa
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Mar 12 14:31:48 2025 +0100

    IO read measurements for most Payload indices (#5951)
    
    * Add payload index filtering IO measurements for some indices
    
    * Add payload index metric to api and telemetry
    
    * Also account for index access overhead
    
    * Review remarks
    
    * Anonymize new HardwareUsage field
    
    * Fix tests

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 09609db8b..0310a85a5 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -4,6 +4,7 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use itertools::Either;
@@ -85,6 +86,7 @@ impl StructPayloadIndex {
     fn query_field<'a>(
         &'a self,
         condition: &'a PrimaryCondition,
+        hw_counter: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match condition {
             PrimaryCondition::Condition(field_condition) => {
@@ -92,7 +94,7 @@ impl StructPayloadIndex {
                 let field_indexes = self.field_indexes.get(field_key)?;
                 field_indexes
                     .iter()
-                    .find_map(|field_index| field_index.filter(field_condition))
+                    .find_map(|field_index| field_index.filter(field_condition, hw_counter.clone()))
             }
             PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
             PrimaryCondition::HasVector(_) => None,
@@ -350,11 +352,12 @@ impl StructPayloadIndex {
             // CPU-optimized strategy here: points are made unique before applying other filters.
             let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
 
+            let hw_acc = hw_counter.new_accumulator();
             let iter = query_cardinality
                 .primary_clauses
                 .iter()
-                .flat_map(|clause| {
-                    self.query_field(clause)
+                .flat_map(move |clause| {
+                    self.query_field(clause, hw_acc.clone())
                         .unwrap_or_else(|| id_tracker.iter_ids() /* index is not built */)
                 })
                 .filter(move |&id| !visited_list.check_and_update_visited(id))

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 0310a85a5..0b9291c57 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -4,7 +4,6 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
-use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use itertools::Either;
@@ -68,6 +67,7 @@ impl StructPayloadIndex {
         &self,
         condition: &FieldCondition,
         nested_path: Option<&JsonPath>,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<CardinalityEstimation> {
         let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
         self.field_indexes.get(&full_path).and_then(|indexes| {
@@ -79,14 +79,14 @@ impl StructPayloadIndex {
 
             indexes
                 .iter()
-                .find_map(|index| index.estimate_cardinality(&full_path_condition))
+                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
         })
     }
 
     fn query_field<'a>(
         &'a self,
         condition: &'a PrimaryCondition,
-        hw_counter: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match condition {
             PrimaryCondition::Condition(field_condition) => {
@@ -94,7 +94,7 @@ impl StructPayloadIndex {
                 let field_indexes = self.field_indexes.get(field_key)?;
                 field_indexes
                     .iter()
-                    .find_map(|field_index| field_index.filter(field_condition, hw_counter.clone()))
+                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
             }
             PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
             PrimaryCondition::HasVector(_) => None,
@@ -242,26 +242,27 @@ impl StructPayloadIndex {
         &self,
         condition: &Condition,
         nested_path: Option<&JsonPath>,
+        hw_counter: &HardwareCounterCell,
     ) -> CardinalityEstimation {
         match condition {
             Condition::Filter(_) => panic!("Unexpected branching"),
             Condition::Nested(nested) => {
                 // propagate complete nested path in case of multiple nested layers
                 let full_path = JsonPath::extend_or_new(nested_path, &nested.array_key());
-                self.estimate_nested_cardinality(nested.filter(), &full_path)
+                self.estimate_nested_cardinality(nested.filter(), &full_path, hw_counter)
             }
             Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
                 let available_points = self.available_point_count();
                 let condition = FieldCondition::new_is_empty(field.key.clone());
 
-                self.estimate_field_condition(&condition, nested_path)
+                self.estimate_field_condition(&condition, nested_path, hw_counter)
                     .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
             }
             Condition::IsNull(IsNullCondition { is_null: field }) => {
                 let available_points = self.available_point_count();
                 let condition = FieldCondition::new_is_null(field.key.clone());
 
-                self.estimate_field_condition(&condition, nested_path)
+                self.estimate_field_condition(&condition, nested_path, hw_counter)
                     .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
             }
             Condition::HasId(has_id) => {
@@ -291,7 +292,7 @@ impl StructPayloadIndex {
                 }
             }
             Condition::Field(field_condition) => self
-                .estimate_field_condition(field_condition, nested_path)
+                .estimate_field_condition(field_condition, nested_path, hw_counter)
                 .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
 
             Condition::CustomIdChecker(cond) => {
@@ -336,7 +337,7 @@ impl StructPayloadIndex {
         filter: &'a Filter,
         id_tracker: &'a IdTrackerSS,
         query_cardinality: &'a CardinalityEstimation,
-        hw_counter: &HardwareCounterCell,
+        hw_counter: &'a HardwareCounterCell,
     ) -> impl Iterator<Item = PointOffsetType> + 'a {
         let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
 
@@ -352,12 +353,11 @@ impl StructPayloadIndex {
             // CPU-optimized strategy here: points are made unique before applying other filters.
             let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
 
-            let hw_acc = hw_counter.new_accumulator();
             let iter = query_cardinality
                 .primary_clauses
                 .iter()
                 .flat_map(move |clause| {
-                    self.query_field(clause, hw_acc.clone())
+                    self.query_field(clause, hw_counter)
                         .unwrap_or_else(|| id_tracker.iter_ids() /* index is not built */)
                 })
                 .filter(move |&id| !visited_list.check_and_update_visited(id))
@@ -441,9 +441,14 @@ impl PayloadIndex for StructPayloadIndex {
         Ok(())
     }
 
-    fn estimate_cardinality(&self, query: &Filter) -> CardinalityEstimation {
+    fn estimate_cardinality(
+        &self,
+        query: &Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> CardinalityEstimation {
         let available_points = self.available_point_count();
-        let estimator = |condition: &Condition| self.condition_cardinality(condition, None);
+        let estimator =
+            |condition: &Condition| self.condition_cardinality(condition, None, hw_counter);
         estimate_filter(&estimator, query, available_points)
     }
 
@@ -451,10 +456,12 @@ impl PayloadIndex for StructPayloadIndex {
         &self,
         query: &Filter,
         nested_path: &JsonPath,
+        hw_counter: &HardwareCounterCell,
     ) -> CardinalityEstimation {
         let available_points = self.available_point_count();
-        let estimator =
-            |condition: &Condition| self.condition_cardinality(condition, Some(nested_path));
+        let estimator = |condition: &Condition| {
+            self.condition_cardinality(condition, Some(nested_path), hw_counter)
+        };
         estimate_filter(&estimator, query, available_points)
     }
 
@@ -464,7 +471,7 @@ impl PayloadIndex for StructPayloadIndex {
         hw_counter: &HardwareCounterCell,
     ) -> Vec<PointOffsetType> {
         // Assume query is already estimated to be small enough so we can iterate over all matched ids
-        let query_cardinality = self.estimate_cardinality(query);
+        let query_cardinality = self.estimate_cardinality(query, hw_counter);
         let id_tracker = self.id_tracker.borrow();
         self.iter_filtered_points(query, &*id_tracker, &query_cardinality, hw_counter)
             .collect()

commit 13f0a87c80cd25a85bac907c7eee53f8c55f048e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 17 20:38:54 2025 +0100

    Mmap in-ram payload indexes without RocksDB (#6148)
    
    * refactor IndexSelector to support mmap with populate
    
    * specify populate flag DynamicMmapFlags
    
    * replace db+flag with enum StorageType
    
    * fix flag
    
    * disable by default
    
    * clippy
    
    * remove outdated comment
    
    * remove comment
    
    * Update lib/segment/src/index/field_index/bool_index/mmap_bool_index.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 0b9291c57..41245c0de 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -14,9 +14,7 @@ use schemars::_serde_json::Value;
 
 use super::field_index::FieldIndexBuilderTrait as _;
 use super::field_index::facet_index::FacetIndexEnum;
-use super::field_index::index_selector::{
-    IndexSelector, IndexSelectorOnDisk, IndexSelectorRocksDb,
-};
+use super::field_index::index_selector::{IndexSelector, IndexSelectorMmap, IndexSelectorRocksDb};
 use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
@@ -42,6 +40,13 @@ use crate::types::{
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
+#[derive(Debug)]
+enum StorageType {
+    Appendable(Arc<RwLock<DB>>),
+    NonAppendableRocksDb(Arc<RwLock<DB>>),
+    NonAppendable,
+}
+
 /// `PayloadIndex` implementation, which actually uses index structures for providing faster search
 #[derive(Debug)]
 pub struct StructPayloadIndex {
@@ -58,8 +63,7 @@ pub struct StructPayloadIndex {
     path: PathBuf,
     /// Used to select unique point ids
     visited_pool: VisitedPool,
-    db: Arc<RwLock<DB>>,
-    is_appendable: bool,
+    storage_type: StorageType,
 }
 
 impl StructPayloadIndex {
@@ -158,11 +162,30 @@ impl StructPayloadIndex {
         let config = if config_path.exists() {
             PayloadConfig::load(&config_path)?
         } else {
+            // ToDo(mmap-paylaod-index): uncomment before minor release
+            // let mut new_config = PayloadConfig::default();
+            // if !is_appendable {
+            //     new_config.skip_rocksdb = Some(true);
+            // }
+            // new_config
             PayloadConfig::default()
         };
 
-        let db = open_db_with_existing_cf(path)
-            .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;
+        let skip_rocksdb = config.skip_rocksdb.unwrap_or(false);
+
+        let storage_type = if is_appendable {
+            let db = open_db_with_existing_cf(path).map_err(|err| {
+                OperationError::service_error(format!("RocksDB open error: {err}"))
+            })?;
+            StorageType::Appendable(db)
+        } else if skip_rocksdb {
+            StorageType::NonAppendable
+        } else {
+            let db = open_db_with_existing_cf(path).map_err(|err| {
+                OperationError::service_error(format!("RocksDB open error: {err}"))
+            })?;
+            StorageType::NonAppendableRocksDb(db)
+        };
 
         let mut index = StructPayloadIndex {
             payload,
@@ -172,8 +195,7 @@ impl StructPayloadIndex {
             config,
             path: path.to_owned(),
             visited_pool: Default::default(),
-            db,
-            is_appendable,
+            storage_type,
         };
 
         if !index.config_path().exists() {
@@ -367,15 +389,23 @@ impl StructPayloadIndex {
         }
     }
 
+    /// Select which type of PayloadIndex to use for the field
     fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {
-        let is_immutable_segment = !self.is_appendable;
-        if payload_schema.is_on_disk() && (is_immutable_segment || payload_schema.is_mutable()) {
-            IndexSelector::OnDisk(IndexSelectorOnDisk { dir: &self.path })
-        } else {
-            IndexSelector::RocksDb(IndexSelectorRocksDb {
-                db: &self.db,
-                is_appendable: self.is_appendable,
-            })
+        let is_on_disk = payload_schema.is_on_disk();
+
+        match &self.storage_type {
+            StorageType::Appendable(db) => IndexSelector::RocksDb(IndexSelectorRocksDb {
+                db,
+                is_appendable: true,
+            }),
+            StorageType::NonAppendableRocksDb(db) => IndexSelector::RocksDb(IndexSelectorRocksDb {
+                db,
+                is_appendable: false,
+            }),
+            StorageType::NonAppendable => IndexSelector::Mmap(IndexSelectorMmap {
+                dir: &self.path,
+                is_on_disk,
+            }),
         }
     }
 
@@ -641,7 +671,17 @@ impl PayloadIndex for StructPayloadIndex {
     }
 
     fn take_database_snapshot(&self, path: &Path) -> OperationResult<()> {
-        crate::rocksdb_backup::create(&self.db.read(), path)
+        match &self.storage_type {
+            StorageType::Appendable(db) => {
+                let db_guard = db.read();
+                crate::rocksdb_backup::create(&db_guard, path)
+            }
+            StorageType::NonAppendableRocksDb(db) => {
+                let db_guard = db.read();
+                crate::rocksdb_backup::create(&db_guard, path)
+            }
+            StorageType::NonAppendable => Ok(()),
+        }
     }
 
     fn files(&self) -> Vec<PathBuf> {

commit 6df1879e283644708f769ce67e01ffad7f1ea1ac
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 18 12:07:38 2025 +0100

    fix loading of on-disk payload indexes (#6191)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 41245c0de..2cae19db7 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -398,10 +398,20 @@ impl StructPayloadIndex {
                 db,
                 is_appendable: true,
             }),
-            StorageType::NonAppendableRocksDb(db) => IndexSelector::RocksDb(IndexSelectorRocksDb {
-                db,
-                is_appendable: false,
-            }),
+            StorageType::NonAppendableRocksDb(db) => {
+                // legacy logic: we keep rocksdb, but load mmap indexes
+                if is_on_disk {
+                    IndexSelector::Mmap(IndexSelectorMmap {
+                        dir: &self.path,
+                        is_on_disk,
+                    })
+                } else {
+                    IndexSelector::RocksDb(IndexSelectorRocksDb {
+                        db,
+                        is_appendable: false,
+                    })
+                }
+            }
             StorageType::NonAppendable => IndexSelector::Mmap(IndexSelectorMmap {
                 dir: &self.path,
                 is_on_disk,

commit 7726126e5b73424e07216c135465ab8e7e665c56
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Mar 21 11:30:14 2025 +0100

    (Potentially) Fix missing CF on flush on payload index change (#6214)
    
    * Handle missing CF on the payload index flush level
    
    * move error handling on the payload field level, so other fields are not skipped if one fails to flush
    
    * Merge nested match statement
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2cae19db7..2e118e547 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -657,7 +657,23 @@ impl PayloadIndex for StructPayloadIndex {
         flushers.push(self.payload.borrow().flusher());
         Box::new(move || {
             for flusher in flushers {
-                flusher()?
+                match flusher() {
+                    Ok(_) => {}
+                    Err(OperationError::RocksDbColumnFamilyNotFound { name }) => {
+                        // It is possible, that the index was removed during the flush by user or another thread.
+                        // In this case, non-existing column family is not an error, but an expected behavior.
+
+                        // Still we want to log this event, for potential debugging.
+                        log::warn!(
+                            "Flush: RocksDB cf_handle error: Cannot find column family {name}. Assume index is removed.",
+                        );
+                    }
+                    Err(err) => {
+                        return Err(OperationError::service_error(format!(
+                            "Failed to flush payload_index: {err}"
+                        )));
+                    }
+                }
             }
             Ok(())
         })

commit 126d4f839a57200ef60f45f976119a28ba946721
Author: Tim Vise <tim+github@visee.me>
Date:   Sat Mar 22 11:01:24 2025 +0100

    Add feature flag to skip RocksDB in immutable payload indices (#6226)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 2e118e547..ab69d9bd3 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -5,6 +5,7 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::flags::feature_flags;
 use common::types::PointOffsetType;
 use itertools::Either;
 use log::debug;
@@ -162,13 +163,11 @@ impl StructPayloadIndex {
         let config = if config_path.exists() {
             PayloadConfig::load(&config_path)?
         } else {
-            // ToDo(mmap-paylaod-index): uncomment before minor release
-            // let mut new_config = PayloadConfig::default();
-            // if !is_appendable {
-            //     new_config.skip_rocksdb = Some(true);
-            // }
-            // new_config
-            PayloadConfig::default()
+            let mut new_config = PayloadConfig::default();
+            if feature_flags().payload_index_skip_rocksdb && !is_appendable {
+                new_config.skip_rocksdb = Some(true);
+            }
+            new_config
         };
 
         let skip_rocksdb = config.skip_rocksdb.unwrap_or(false);

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index ab69d9bd3..75893d186 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -5,6 +5,7 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::counter::iterator_hw_measurement::HwMeasurementIteratorExt;
 use common::flags::feature_flags;
 use common::types::PointOffsetType;
 use itertools::Either;
@@ -145,7 +146,11 @@ impl StructPayloadIndex {
         if !is_loaded {
             debug!("Index for `{field}` was not loaded. Building...");
             // todo(ivan): decide what to do with indexes, which were not loaded
-            indexes = self.build_field_indexes(field, payload_schema)?;
+            indexes = self.build_field_indexes(
+                field,
+                payload_schema,
+                &HardwareCounterCell::disposable(), // Internal operation.
+            )?;
         }
 
         Ok(indexes)
@@ -211,6 +216,7 @@ impl StructPayloadIndex {
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: &PayloadFieldSchema,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Vec<FieldIndex>> {
         let payload_storage = self.payload.borrow();
         let mut builders = self
@@ -224,7 +230,7 @@ impl StructPayloadIndex {
         payload_storage.iter(|point_id, point_payload| {
             let field_value = &point_payload.get_value(field);
             for builder in builders.iter_mut() {
-                builder.add_point(point_id, field_value)?;
+                builder.add_point(point_id, field_value, hw_counter)?;
             }
             Ok(true)
         })?;
@@ -378,8 +384,14 @@ impl StructPayloadIndex {
                 .primary_clauses
                 .iter()
                 .flat_map(move |clause| {
-                    self.query_field(clause, hw_counter)
-                        .unwrap_or_else(|| id_tracker.iter_ids() /* index is not built */)
+                    self.query_field(clause, hw_counter).unwrap_or_else(|| {
+                        // index is not built
+                        Box::new(id_tracker.iter_ids().measure_hw_with_cell(
+                            hw_counter,
+                            size_of::<PointOffsetType>(),
+                            |i| i.cpu_counter(),
+                        ))
+                    })
                 })
                 .filter(move |&id| !visited_list.check_and_update_visited(id))
                 .filter(move |&i| struct_filtered_context.check(i));
@@ -437,6 +449,7 @@ impl PayloadIndex for StructPayloadIndex {
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: &PayloadFieldSchema,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Option<Vec<FieldIndex>>> {
         if let Some(prev_schema) = self.config.indexed_fields.get(field) {
             // the field is already indexed with the same schema
@@ -446,7 +459,7 @@ impl PayloadIndex for StructPayloadIndex {
             }
         }
 
-        let indexes = self.build_field_indexes(field, payload_schema)?;
+        let indexes = self.build_field_indexes(field, payload_schema, hw_counter)?;
 
         Ok(Some(indexes))
     }
@@ -563,12 +576,11 @@ impl PayloadIndex for StructPayloadIndex {
             .borrow_mut()
             .overwrite(point_id, payload, hw_counter)?;
 
-        // TODO(io_measurement): Maybe add measurements to index here too.
         for (field, field_index) in &mut self.field_indexes {
             let field_value = payload.get_value(field);
             if !field_value.is_empty() {
                 for index in field_index {
-                    index.add_point(point_id, &field_value)?;
+                    index.add_point(point_id, &field_value, hw_counter)?;
                 }
             } else {
                 for index in field_index {
@@ -604,7 +616,7 @@ impl PayloadIndex for StructPayloadIndex {
             let field_value = updated_payload.get_value(field);
             if !field_value.is_empty() {
                 for index in field_index {
-                    index.add_point(point_id, &field_value)?;
+                    index.add_point(point_id, &field_value, hw_counter)?;
                 }
             } else {
                 for index in field_index {

commit a8c7a034ce525a01b63199b28454c985bf71477b
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Mar 25 17:38:36 2025 +0100

    Measure Payload IO reads on index creation (#6252)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 75893d186..a6f1759bb 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -227,13 +227,16 @@ impl StructPayloadIndex {
             index.init()?;
         }
 
-        payload_storage.iter(|point_id, point_payload| {
-            let field_value = &point_payload.get_value(field);
-            for builder in builders.iter_mut() {
-                builder.add_point(point_id, field_value, hw_counter)?;
-            }
-            Ok(true)
-        })?;
+        payload_storage.iter(
+            |point_id, point_payload| {
+                let field_value = &point_payload.get_value(field);
+                for builder in builders.iter_mut() {
+                    builder.add_point(point_id, field_value, hw_counter)?;
+                }
+                Ok(true)
+            },
+            hw_counter,
+        )?;
 
         builders
             .into_iter()
@@ -693,17 +696,21 @@ impl PayloadIndex for StructPayloadIndex {
     fn infer_payload_type(
         &self,
         key: PayloadKeyTypeRef,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Option<PayloadSchemaType>> {
         let mut schema = None;
-        self.payload.borrow().iter(|_id, payload: &Payload| {
-            let field_value = payload.get_value(key);
-            schema = match field_value.as_slice() {
-                [] => None,
-                [single] => infer_value_type(single),
-                multiple => infer_collection_value_type(multiple.iter().copied()),
-            };
-            Ok(false)
-        })?;
+        self.payload.borrow().iter(
+            |_id, payload: &Payload| {
+                let field_value = payload.get_value(key);
+                schema = match field_value.as_slice() {
+                    [] => None,
+                    [single] => infer_value_type(single),
+                    multiple => infer_collection_value_type(multiple.iter().copied()),
+                };
+                Ok(false)
+            },
+            hw_counter,
+        )?;
         Ok(schema)
     }
 

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index a6f1759bb..07c28d5ac 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -441,6 +441,35 @@ impl StructPayloadIndex {
                 key: key.to_string(),
             })
     }
+
+    pub fn populate(&self) -> OperationResult<()> {
+        for (_, field_indexes) in self.field_indexes.iter() {
+            for index in field_indexes {
+                index.populate()?;
+            }
+        }
+        Ok(())
+    }
+
+    pub fn clear_cache(&self) -> OperationResult<()> {
+        for (_, field_indexes) in self.field_indexes.iter() {
+            for index in field_indexes {
+                index.clear_cache()?;
+            }
+        }
+        Ok(())
+    }
+
+    pub fn clear_cache_if_on_disk(&self) -> OperationResult<()> {
+        for (_, field_indexes) in self.field_indexes.iter() {
+            for index in field_indexes {
+                if index.is_on_disk() {
+                    index.clear_cache()?;
+                }
+            }
+        }
+        Ok(())
+    }
 }
 
 impl PayloadIndex for StructPayloadIndex {

commit e59d395d80ade92eef58c220adb576548e5e21a7
Author: Tim Vise <tim+github@visee.me>
Date:   Thu Apr 17 23:11:35 2025 +0200

    Use ahash for maps/sets holding point IDs, offsets or similar (#6388)

diff --git a/lib/segment/src/index/struct_payload_index.rs b/lib/segment/src/index/struct_payload_index.rs
index 07c28d5ac..6ee60c2a2 100644
--- a/lib/segment/src/index/struct_payload_index.rs
+++ b/lib/segment/src/index/struct_payload_index.rs
@@ -1,8 +1,9 @@
-use std::collections::{HashMap, HashSet};
+use std::collections::HashMap;
 use std::fs::create_dir_all;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use ahash::AHashSet;
 use atomic_refcell::AtomicRefCell;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::counter::iterator_hw_measurement::HwMeasurementIteratorExt;
@@ -297,7 +298,7 @@ impl StructPayloadIndex {
             }
             Condition::HasId(has_id) => {
                 let id_tracker_ref = self.id_tracker.borrow();
-                let mapped_ids: HashSet<PointOffsetType> = has_id
+                let mapped_ids: AHashSet<PointOffsetType> = has_id
                     .has_id
                     .iter()
                     .filter_map(|external_id| id_tracker_ref.internal_id(*external_id))

