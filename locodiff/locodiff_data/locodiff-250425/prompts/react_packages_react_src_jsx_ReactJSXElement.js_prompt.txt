# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react/src/jsx/ReactJSXElement.js

commit 90f8fe6f5509cab7d6d280b4ed17181697f394e9
Author: Luna Ruan <luna@fb.com>
Date:   Tue Mar 17 13:22:19 2020 -0700

    add jsx-runtime and jsx-dev-runtime (#18299)
    
    This PR adds the jsx-runtime and jsx-dev-runtime modules for the JSX Babel Plugin. WWW still relies on jsx/jsxs/jsxDEV from the "react" module, so once we refactor the code to point to the runtime modules we will remove jsx/jsxs/jsxDEV from the "react" module.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
new file mode 100644
index 0000000000..86c4597a1f
--- /dev/null
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -0,0 +1,345 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import getComponentName from 'shared/getComponentName';
+import ReactSharedInternals from 'shared/ReactSharedInternals';
+
+import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
+
+const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
+
+const hasOwnProperty = Object.prototype.hasOwnProperty;
+
+const RESERVED_PROPS = {
+  key: true,
+  ref: true,
+  __self: true,
+  __source: true,
+};
+
+let specialPropKeyWarningShown;
+let specialPropRefWarningShown;
+let didWarnAboutStringRefs;
+
+if (__DEV__) {
+  didWarnAboutStringRefs = {};
+}
+
+function hasValidRef(config) {
+  if (__DEV__) {
+    if (hasOwnProperty.call(config, 'ref')) {
+      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
+      if (getter && getter.isReactWarning) {
+        return false;
+      }
+    }
+  }
+  return config.ref !== undefined;
+}
+
+function hasValidKey(config) {
+  if (__DEV__) {
+    if (hasOwnProperty.call(config, 'key')) {
+      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
+      }
+    }
+  }
+  return config.key !== undefined;
+}
+
+function warnIfStringRefCannotBeAutoConverted(config) {
+  if (__DEV__) {
+    if (
+      typeof config.ref === 'string' &&
+      ReactCurrentOwner.current &&
+      config.__self &&
+      ReactCurrentOwner.current.stateNode !== config.__self
+    ) {
+      const componentName = getComponentName(ReactCurrentOwner.current.type);
+
+      if (!didWarnAboutStringRefs[componentName]) {
+        console.error(
+          'Component "%s" contains the string ref "%s". ' +
+            'Support for string refs will be removed in a future major release. ' +
+            'This case cannot be automatically converted to an arrow function. ' +
+            'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
+            'Learn more about using refs safely here: ' +
+            'https://fb.me/react-strict-mode-string-ref',
+          getComponentName(ReactCurrentOwner.current.type),
+          config.ref,
+        );
+        didWarnAboutStringRefs[componentName] = true;
+      }
+    }
+  }
+}
+
+function defineKeyPropWarningGetter(props, displayName) {
+  if (__DEV__) {
+    const warnAboutAccessingKey = function() {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error(
+          '%s: `key` is not a prop. Trying to access it will result ' +
+            'in `undefined` being returned. If you need to access the same ' +
+            'value within the child component, you should pass it as a different ' +
+            'prop. (https://fb.me/react-special-props)',
+          displayName,
+        );
+      }
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true,
+    });
+  }
+}
+
+function defineRefPropWarningGetter(props, displayName) {
+  if (__DEV__) {
+    const warnAboutAccessingRef = function() {
+      if (!specialPropRefWarningShown) {
+        specialPropRefWarningShown = true;
+        console.error(
+          '%s: `ref` is not a prop. Trying to access it will result ' +
+            'in `undefined` being returned. If you need to access the same ' +
+            'value within the child component, you should pass it as a different ' +
+            'prop. (https://fb.me/react-special-props)',
+          displayName,
+        );
+      }
+    };
+    warnAboutAccessingRef.isReactWarning = true;
+    Object.defineProperty(props, 'ref', {
+      get: warnAboutAccessingRef,
+      configurable: true,
+    });
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+const ReactElement = function(type, key, ref, self, source, owner, props) {
+  const element = {
+    // This tag allows us to uniquely identify this as a React Element
+    $$typeof: REACT_ELEMENT_TYPE,
+
+    // Built-in properties that belong on the element
+    type: type,
+    key: key,
+    ref: ref,
+    props: props,
+
+    // Record the component responsible for creating this element.
+    _owner: owner,
+  };
+
+  if (__DEV__) {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: false,
+    });
+    // self and source are DEV only properties.
+    Object.defineProperty(element, '_self', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: self,
+    });
+    // Two elements created in two different places should be considered
+    // equal for testing purposes and therefore we hide it from enumeration.
+    Object.defineProperty(element, '_source', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: source,
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+
+  return element;
+};
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
+export function jsx(type, config, maybeKey) {
+  let propName;
+
+  // Reserved names are extracted
+  const props = {};
+
+  let key = null;
+  let ref = null;
+
+  // Currently, key can be spread in as a prop. This causes a potential
+  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+  // but as an intermediary step, we will use jsxDEV for everything except
+  // <div {...props} key="Hi" />, because we aren't currently able to tell if
+  // key is explicitly declared to be undefined or not.
+  if (maybeKey !== undefined) {
+    key = '' + maybeKey;
+  }
+
+  if (hasValidKey(config)) {
+    key = '' + config.key;
+  }
+
+  if (hasValidRef(config)) {
+    ref = config.ref;
+  }
+
+  // Remaining properties are added to a new props object
+  for (propName in config) {
+    if (
+      hasOwnProperty.call(config, propName) &&
+      !RESERVED_PROPS.hasOwnProperty(propName)
+    ) {
+      props[propName] = config[propName];
+    }
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    const defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+  }
+
+  return ReactElement(
+    type,
+    key,
+    ref,
+    undefined,
+    undefined,
+    ReactCurrentOwner.current,
+    props,
+  );
+}
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
+export function jsxDEV(type, config, maybeKey, source, self) {
+  if (__DEV__) {
+    let propName;
+
+    // Reserved names are extracted
+    const props = {};
+
+    let key = null;
+    let ref = null;
+
+    // Currently, key can be spread in as a prop. This causes a potential
+    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+    // but as an intermediary step, we will use jsxDEV for everything except
+    // <div {...props} key="Hi" />, because we aren't currently able to tell if
+    // key is explicitly declared to be undefined or not.
+    if (maybeKey !== undefined) {
+      key = '' + maybeKey;
+    }
+
+    if (hasValidKey(config)) {
+      key = '' + config.key;
+    }
+
+    if (hasValidRef(config)) {
+      ref = config.ref;
+      warnIfStringRefCannotBeAutoConverted(config);
+    }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (
+        hasOwnProperty.call(config, propName) &&
+        !RESERVED_PROPS.hasOwnProperty(propName)
+      ) {
+        props[propName] = config[propName];
+      }
+    }
+
+    // Resolve default props
+    if (type && type.defaultProps) {
+      const defaultProps = type.defaultProps;
+      for (propName in defaultProps) {
+        if (props[propName] === undefined) {
+          props[propName] = defaultProps[propName];
+        }
+      }
+    }
+
+    if (key || ref) {
+      const displayName =
+        typeof type === 'function'
+          ? type.displayName || type.name || 'Unknown'
+          : type;
+      if (key) {
+        defineKeyPropWarningGetter(props, displayName);
+      }
+      if (ref) {
+        defineRefPropWarningGetter(props, displayName);
+      }
+    }
+
+    return ReactElement(
+      type,
+      key,
+      ref,
+      self,
+      source,
+      ReactCurrentOwner.current,
+      props,
+    );
+  }
+}

commit 7c1478680f94eda01517469d1fcfa70e14bfcb05
Author: Luna Ruan <luna@fb.com>
Date:   Thu Mar 19 23:47:53 2020 -0700

    fix string ref cannot be auto converted warning for React.jsxDEV (#18354)
    
    The string ref cannot be auto converted warning was using the wrong _self. This diff fixes this so it is now using the correct __self

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 86c4597a1f..f76c92fb88 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -53,13 +53,13 @@ function hasValidKey(config) {
   return config.key !== undefined;
 }
 
-function warnIfStringRefCannotBeAutoConverted(config) {
+function warnIfStringRefCannotBeAutoConverted(config, self) {
   if (__DEV__) {
     if (
       typeof config.ref === 'string' &&
       ReactCurrentOwner.current &&
-      config.__self &&
-      ReactCurrentOwner.current.stateNode !== config.__self
+      self &&
+      ReactCurrentOwner.current.stateNode !== self
     ) {
       const componentName = getComponentName(ReactCurrentOwner.current.type);
 
@@ -296,7 +296,7 @@ export function jsxDEV(type, config, maybeKey, source, self) {
 
     if (hasValidRef(config)) {
       ref = config.ref;
-      warnIfStringRefCannotBeAutoConverted(config);
+      warnIfStringRefCannotBeAutoConverted(config, self);
     }
 
     // Remaining properties are added to a new props object

commit 702fad4b1b48ac8f626ed3f35e8f86f5ea728084
Author: CY Lim <5622951+cylim@users.noreply.github.com>
Date:   Mon Aug 17 20:25:50 2020 +0800

    refactor fb.me redirect link to reactjs.org/link (#19598)
    
    * refactor fb.me url to reactjs.org/link
    
    * Update ESLintRuleExhaustiveDeps-test.js
    
    * Update ReactDOMServerIntegrationUntrustedURL-test.internal.js
    
    * Update createReactClassIntegration-test.js
    
    * Update ReactDOMServerIntegrationUntrustedURL-test.internal.js
    
    Co-authored-by: Dan Abramov <dan.abramov@gmail.com>

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index f76c92fb88..c4c02c7418 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -70,7 +70,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
             'This case cannot be automatically converted to an arrow function. ' +
             'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
             'Learn more about using refs safely here: ' +
-            'https://fb.me/react-strict-mode-string-ref',
+            'https://reactjs.org/link/strict-mode-string-ref',
           getComponentName(ReactCurrentOwner.current.type),
           config.ref,
         );
@@ -89,7 +89,7 @@ function defineKeyPropWarningGetter(props, displayName) {
           '%s: `key` is not a prop. Trying to access it will result ' +
             'in `undefined` being returned. If you need to access the same ' +
             'value within the child component, you should pass it as a different ' +
-            'prop. (https://fb.me/react-special-props)',
+            'prop. (https://reactjs.org/link/special-props)',
           displayName,
         );
       }
@@ -111,7 +111,7 @@ function defineRefPropWarningGetter(props, displayName) {
           '%s: `ref` is not a prop. Trying to access it will result ' +
             'in `undefined` being returned. If you need to access the same ' +
             'value within the child component, you should pass it as a different ' +
-            'prop. (https://fb.me/react-special-props)',
+            'prop. (https://reactjs.org/link/special-props)',
           displayName,
         );
       }

commit 7df65725ba7826508e0f3c0f1c6f088efdbecfca
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Fri Mar 5 16:02:02 2021 -0500

    Split getComponentName into getComponentNameFromFiber and getComponentNameFromType (#20940)
    
    Split getComponentName into getComponentNameFromFiber and getComponentNameFromType

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index c4c02c7418..ccf2c6e2a4 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-import getComponentName from 'shared/getComponentName';
+import getComponentNameFromType from 'shared/getComponentNameFromType';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
@@ -61,7 +61,9 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
       self &&
       ReactCurrentOwner.current.stateNode !== self
     ) {
-      const componentName = getComponentName(ReactCurrentOwner.current.type);
+      const componentName = getComponentNameFromType(
+        ReactCurrentOwner.current.type,
+      );
 
       if (!didWarnAboutStringRefs[componentName]) {
         console.error(
@@ -71,7 +73,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
             'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
             'Learn more about using refs safely here: ' +
             'https://reactjs.org/link/strict-mode-string-ref',
-          getComponentName(ReactCurrentOwner.current.type),
+          getComponentNameFromType(ReactCurrentOwner.current.type),
           config.ref,
         );
         didWarnAboutStringRefs[componentName] = true;

commit 2c9fef32db5c9a342a1a60c34217ffc9ae087fbb
Author: Behnam Mohammadi <itten@live.com>
Date:   Thu Apr 1 20:35:10 2021 +0430

    Remove redundant initial of hasOwnProperty (#21134)
    
    * remove redundant initial of hasOwnProperty
    
    * remove redundant initial of hasOwnProperty part 2
    
    * remove redundant initial of hasOwnProperty part 3

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index ccf2c6e2a4..e87a969712 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -7,13 +7,11 @@
 
 import getComponentNameFromType from 'shared/getComponentNameFromType';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
-
+import hasOwnProperty from 'shared/hasOwnProperty';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 
-const hasOwnProperty = Object.prototype.hasOwnProperty;
-
 const RESERVED_PROPS = {
   key: true,
   ref: true,

commit c88fb49d37fd01024e0a254a37b7810d107bdd1d
Author: Justin Grant <justingrant@users.noreply.github.com>
Date:   Mon Sep 27 10:05:07 2021 -0700

    Improve DEV errors if string coercion throws (Temporal.*, Symbol, etc.) (#22064)
    
    * Revise ESLint rules for string coercion
    
    Currently, react uses `'' + value` to coerce mixed values to strings.
    This code will throw for Temporal objects or symbols.
    
    To make string-coercion safer and to improve user-facing error messages,
    This commit adds a new ESLint rule called `safe-string-coercion`.
    
    This rule has two modes: a production mode and a non-production mode.
    * If the `isProductionUserAppCode` option is true, then `'' + value`
      coercions are allowed (because they're faster, although they may
      throw) and `String(value)` coercions are disallowed. Exception:
      when building error messages or running DEV-only code in prod
      files, `String()` should be used because it won't throw.
    * If the `isProductionUserAppCode` option is false, then `'' + value`
      coercions are disallowed (because they may throw, and in non-prod
      code it's not worth the risk) and `String(value)` are allowed.
    
    Production mode is used for all files which will be bundled with
    developers' userland apps. Non-prod mode is used for all other React
    code: tests, DEV blocks, devtools extension, etc.
    
    In production mode, in addiiton to flagging `String(value)` calls,
    the rule will also flag `'' + value` or `value + ''` coercions that may
    throw. The rule is smart enough to silence itself in the following
    "will never throw" cases:
    * When the coercion is wrapped in a `typeof` test that restricts to safe
      (non-symbol, non-object) types. Example:
        if (typeof value === 'string' || typeof value === 'number') {
          thisWontReport('' + value);
        }
    * When what's being coerced is a unary function result, because unary
       functions never return an object or a symbol.
    * When the coerced value is a commonly-used numeric identifier:
      `i`, `idx`, or `lineNumber`.
    * When the statement immeidately before the coercion is a DEV-only
      call to a function from shared/CheckStringCoercion.js. This call is a
      no-op in production, but in DEV it will show a console error
      explaining the problem, then will throw right after a long explanatory
      code comment so that debugger users will have an idea what's going on.
      The check function call must be in the following format:
        if (__DEV__) {
          checkXxxxxStringCoercion(value);
        };
    
    Manually disabling the rule is usually not necessary because almost all
    prod use of the `'' + value` pattern falls into one of the categories
    above. But in the rare cases where the rule isn't smart enough to detect
    safe usage (e.g. when a coercion is inside a nested ternary operator),
    manually disabling the rule will be needed.
    
    The rule should also be manually disabled in prod error handling code
    where `String(value)` should be used for coercions, because it'd be
    bad to throw while building an error message or stack trace!
    
    The prod and non-prod modes have differentiated error messages to
    explain how to do a proper coercion in that mode.
    
    If a production check call is needed but is missing or incorrect
    (e.g. not in a DEV block or not immediately before the coercion), then
    a context-sensitive error message will be reported so that developers
    can figure out what's wrong and how to fix the problem.
    
    Because string coercions are now handled by the `safe-string-coercion`
    rule, the `no-primitive-constructor` rule no longer flags `String()`
    usage. It still flags `new String(value)` because that usage is almost
    always a bug.
    
    * Add DEV-only string coercion check functions
    
    This commit adds DEV-only functions to check whether coercing
    values to strings using the `'' + value` pattern will throw. If it will
    throw, these functions will:
    1. Display a console error with a friendly error message describing
       the problem and the developer can fix it.
    2. Perform the coercion, which will throw. Right before the line where
       the throwing happens, there's a long code comment that will help
       debugger users (or others looking at the exception call stack) figure
       out what happened and how to fix the problem.
    
    One of these check functions should be called before all string coercion
    of user-provided values, except when the the coercion is guaranteed not
    to throw, e.g.
    * if inside a typeof check like `if (typeof value === 'string')`
    * if coercing the result of a unary function like `+value` or `value++`
    * if coercing a variable named in a whitelist of numeric identifiers:
      `i`, `idx`, or `lineNumber`.
    
    The new `safe-string-coercion` internal ESLint rule enforces that
    these check functions are called when they are required.
    
    Only use these check functions in production code that will be bundled
    with user apps.  For non-prod code (and for production error-handling
    code), use `String(value)` instead which may be a little slower but will
    never throw.
    
    * Add failing tests for string coercion
    
    Added failing tests to verify:
    * That input, select, and textarea elements with value and defaultValue
      set to Temporal-like objects which will throw when coerced to string
      using the `'' + value` pattern.
    * That text elements will throw for Temporal-like objects
    * That dangerouslySetInnerHTML will *not* throw for Temporal-like
      objects because this value is not cast to a string before passing to
      the DOM.
    * That keys that are Temporal-like objects will throw
    
    All tests above validate the friendly error messages thrown.
    
    * Use `String(value)` for coercion in non-prod files
    
    This commit switches non-production code from `'' + value` (which
    throws for Temporal objects and symbols) to instead use `String(value)`
    which won't throw for these or other future plus-phobic types.
    
    "Non-produciton code" includes anything not bundled into user apps:
    * Tests and test utilities. Note that I didn't change legacy React
      test fixtures because I assumed it was good for those files to
      act just like old React, including coercion behavior.
    * Build scripts
    * Dev tools package - In addition to switching to `String`, I also
      removed special-case code for coercing symbols which is now
      unnecessary.
    
    * Add DEV-only string coercion checks to prod files
    
    This commit adds DEV-only function calls to to check if string coercion
    using `'' + value` will throw, which it will if the value is a Temporal
    object or a symbol because those types can't be added with `+`.
    
    If it will throw, then in DEV these checks will show a console error
    to help the user undertsand what went wrong and how to fix the
    problem. After emitting the console error, the check functions will
    retry the coercion which will throw with a call stack that's easy (or
    at least easier!) to troubleshoot because the exception happens right
    after a long comment explaining the issue. So whether the user is in
    a debugger, looking at the browser console, or viewing the in-browser
    DEV call stack, it should be easy to understand and fix the problem.
    
    In most cases, the safe-string-coercion ESLint rule is smart enough to
    detect when a coercion is safe. But in rare cases (e.g. when a coercion
    is inside a ternary) this rule will have to be manually disabled.
    
    This commit also switches error-handling code to use `String(value)`
    for coercion, because it's bad to crash when you're trying to build
    an error message or a call stack!  Because `String()` is usually
    disallowed by the `safe-string-coercion` ESLint rule in production
    code, the rule must be disabled when `String()` is used.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index e87a969712..af7085f7e2 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -9,6 +9,7 @@ import getComponentNameFromType from 'shared/getComponentNameFromType';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import hasOwnProperty from 'shared/hasOwnProperty';
 import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
+import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 
@@ -222,10 +223,16 @@ export function jsx(type, config, maybeKey) {
   // <div {...props} key="Hi" />, because we aren't currently able to tell if
   // key is explicitly declared to be undefined or not.
   if (maybeKey !== undefined) {
+    if (__DEV__) {
+      checkKeyStringCoercion(maybeKey);
+    }
     key = '' + maybeKey;
   }
 
   if (hasValidKey(config)) {
+    if (__DEV__) {
+      checkKeyStringCoercion(config.key);
+    }
     key = '' + config.key;
   }
 
@@ -287,10 +294,16 @@ export function jsxDEV(type, config, maybeKey, source, self) {
     // <div {...props} key="Hi" />, because we aren't currently able to tell if
     // key is explicitly declared to be undefined or not.
     if (maybeKey !== undefined) {
+      if (__DEV__) {
+        checkKeyStringCoercion(maybeKey);
+      }
       key = '' + maybeKey;
     }
 
     if (hasValidKey(config)) {
+      if (__DEV__) {
+        checkKeyStringCoercion(config.key);
+      }
       key = '' + config.key;
     }
 

commit 4c016e7aafb17657c143e14093c6013a2d805ae0
Author: zhangrenyang <zhang_renyang@126.com>
Date:   Sat Oct 1 05:50:08 2022 +0800

    Refactor: use  property shorthand (#25366)

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index af7085f7e2..091dad23f4 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -151,10 +151,10 @@ const ReactElement = function(type, key, ref, self, source, owner, props) {
     $$typeof: REACT_ELEMENT_TYPE,
 
     // Built-in properties that belong on the element
-    type: type,
-    key: key,
-    ref: ref,
-    props: props,
+    type,
+    key,
+    ref,
+    props,
 
     // Record the component responsible for creating this element.
     _owner: owner,

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 091dad23f4..47d9cec8f3 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 47d9cec8f3..97c12bff5b 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -83,7 +83,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
 
 function defineKeyPropWarningGetter(props, displayName) {
   if (__DEV__) {
-    const warnAboutAccessingKey = function() {
+    const warnAboutAccessingKey = function () {
       if (!specialPropKeyWarningShown) {
         specialPropKeyWarningShown = true;
         console.error(
@@ -105,7 +105,7 @@ function defineKeyPropWarningGetter(props, displayName) {
 
 function defineRefPropWarningGetter(props, displayName) {
   if (__DEV__) {
-    const warnAboutAccessingRef = function() {
+    const warnAboutAccessingRef = function () {
       if (!specialPropRefWarningShown) {
         specialPropRefWarningShown = true;
         console.error(
@@ -145,7 +145,7 @@ function defineRefPropWarningGetter(props, displayName) {
  * indicating filename, line number, and/or other information.
  * @internal
  */
-const ReactElement = function(type, key, ref, self, source, owner, props) {
+const ReactElement = function (type, key, ref, self, source, owner, props) {
   const element = {
     // This tag allows us to uniquely identify this as a React Element
     $$typeof: REACT_ELEMENT_TYPE,

commit d310d654a7c7aab6c8213da84ef36dfba82711b0
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 14 21:00:22 2023 -0400

    Avoid meta programming to initialize functions in module scope  (#26388)
    
    I'm trying to get rid of all meta programming in the module scope so
    that closure can do a better job figuring out cyclic dependencies and
    ability to reorder.
    
    This is converting a lot of the patterns that assign functions
    conditionally to using function declarations instead.
    
    ```
    let fn;
    if (__DEV__) {
      fn = function() {
        ...
      };
    }
    ```
    ->
    ```
    function fn() {
      if (__DEV__) {
        ...
      }
    }
    ```

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 97c12bff5b..e2d8fe0af4 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -145,7 +145,7 @@ function defineRefPropWarningGetter(props, displayName) {
  * indicating filename, line number, and/or other information.
  * @internal
  */
-const ReactElement = function (type, key, ref, self, source, owner, props) {
+function ReactElement(type, key, ref, self, source, owner, props) {
   const element = {
     // This tag allows us to uniquely identify this as a React Element
     $$typeof: REACT_ELEMENT_TYPE,
@@ -199,7 +199,7 @@ const ReactElement = function (type, key, ref, self, source, owner, props) {
   }
 
   return element;
-};
+}
 
 /**
  * https://github.com/reactjs/rfcs/pull/107

commit 1beb94133a93a433669a893aef02dd5afec07394
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 6 18:56:18 2024 -0500

    jsx(): Inline reserved prop checks (#28262)
    
    The JSX runtime (both the new one and the classic createElement runtime)
    check for reserved props like `key` and `ref` by doing a lookup in a
    plain object map with `hasOwnProperty`.
    
    There are only a few reserved props so this inlines the checks instead.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index e2d8fe0af4..849d2e1604 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -13,13 +13,6 @@ import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 
-const RESERVED_PROPS = {
-  key: true,
-  ref: true,
-  __self: true,
-  __source: true,
-};
-
 let specialPropKeyWarningShown;
 let specialPropRefWarningShown;
 let didWarnAboutStringRefs;
@@ -244,7 +237,12 @@ export function jsx(type, config, maybeKey) {
   for (propName in config) {
     if (
       hasOwnProperty.call(config, propName) &&
-      !RESERVED_PROPS.hasOwnProperty(propName)
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // TODO: These will no longer be reserved in the next major
+      propName !== 'ref' &&
+      propName !== '__self' &&
+      propName !== '__source'
     ) {
       props[propName] = config[propName];
     }
@@ -316,7 +314,12 @@ export function jsxDEV(type, config, maybeKey, source, self) {
     for (propName in config) {
       if (
         hasOwnProperty.call(config, propName) &&
-        !RESERVED_PROPS.hasOwnProperty(propName)
+        // Skip over reserved prop names
+        propName !== 'key' &&
+        // TODO: These will no longer be reserved in the next major
+        propName !== 'ref' &&
+        propName !== '__self' &&
+        propName !== '__source'
       ) {
         props[propName] = config[propName];
       }

commit 91caa96e4261704d42333f5e02ba32d870379fc4
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 6 20:03:02 2024 -0500

    jsx(): Treat __self and __source as normal props (#28257)
    
    These used to be reserved props because the classic React.createElement
    runtime passed this data as props, whereas the jsxDEV() runtime passes
    them as separate arguments.
    
    This brings us incrementally closer to being able to pass the props
    object directly through to React instead of cloning a subset into a new
    object.
    
    The React.createElement runtime is unaffected.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 849d2e1604..bc3691e4a9 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -239,10 +239,8 @@ export function jsx(type, config, maybeKey) {
       hasOwnProperty.call(config, propName) &&
       // Skip over reserved prop names
       propName !== 'key' &&
-      // TODO: These will no longer be reserved in the next major
-      propName !== 'ref' &&
-      propName !== '__self' &&
-      propName !== '__source'
+      // TODO: `ref` will no longer be reserved in the next major
+      propName !== 'ref'
     ) {
       props[propName] = config[propName];
     }
@@ -316,10 +314,8 @@ export function jsxDEV(type, config, maybeKey, source, self) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        // TODO: These will no longer be reserved in the next major
-        propName !== 'ref' &&
-        propName !== '__self' &&
-        propName !== '__source'
+        // TODO: `ref` will no longer be reserved in the next major
+        propName !== 'ref'
       ) {
         props[propName] = config[propName];
       }

commit 37d901e2b81e12d40df7012c6f8681b8272d2555
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Feb 7 13:38:00 2024 -0800

    Remove __self and __source location from elements (#28265)
    
    Along with all the places using it like the `_debugSource` on Fiber.
    This still lets them be passed into `createElement` (and JSX dev
    runtime) since those can still be used in existing already compiled code
    and we don't want that to start spreading to DOM attributes.
    
    We used to have a DEV mode that compiles the source location of JSX into
    the compiled output. This was nice because we could get the actual call
    site of the JSX (instead of just somewhere in the component). It had a
    bunch of issues though:
    
    - It only works with JSX.
    - The way this source location is compiled is different in all the
    pipelines along the way. It relies on this transform being first and the
    source location we want to extract but it doesn't get preserved along
    source maps and don't have a way to be connected to the source hosted by
    the source maps. Ideally it should just use the mechanism other source
    maps use.
    - Since it's expensive it only works in DEV so if it's used for
    component stacks it would vary between dev and prod.
    - It only captures the callsite of the JSX and not the stack between the
    component and that callsite. In the happy case it's in the component but
    not always.
    
    Instead, we have another zero-cost trick to extract the call site of
    each component lazily only if it's needed. This ensures that component
    stacks are the same in DEV and PROD. At the cost of worse line number
    information.
    
    The better way to get the JSX call site would be to get it from `new
    Error()` or `console.createTask()` inside the JSX runtime which can
    capture the whole stack in a consistent way with other source mappings.
    We might explore that in the future.
    
    This removes source location info from React DevTools and React Native
    Inspector. The "jump to source code" feature or inspection can be made
    lazy instead by invoking the lazy component stack frame generation. That
    way it can be made to work in prod too. The filtering based on file path
    is a bit trickier.
    
    When redesigned this UI should ideally also account for more than one
    stack frame.
    
    With this change the DEV only Babel transforms are effectively
    deprecated since they're not necessary for anything.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index bc3691e4a9..e2ad636e03 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -170,21 +170,6 @@ function ReactElement(type, key, ref, self, source, owner, props) {
       writable: true,
       value: false,
     });
-    // self and source are DEV only properties.
-    Object.defineProperty(element, '_self', {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: self,
-    });
-    // Two elements created in two different places should be considered
-    // equal for testing purposes and therefore we hide it from enumeration.
-    Object.defineProperty(element, '_source', {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: source,
-    });
     if (Object.freeze) {
       Object.freeze(element.props);
       Object.freeze(element);

commit b229f540e2da91370611945f9875e00a96196df6
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 8 08:01:32 2024 -0800

    [Flight] Emit debug info for a Server Component (#28272)
    
    This adds a new DEV-only row type `D` for DebugInfo. If we see this in
    prod, that's an error. It can contain extra debug information about the
    Server Components (or Promises) that were compiled away during the
    server render. It's DEV-only since this can contain sensitive
    information (similar to errors) and since it'll be a lot of data, but
    it's worth using the same stream for simplicity rather than a
    side-channel.
    
    In this first pass it's just the Server Component's name but I'll keep
    adding more debug info to the stream, and it won't always just be a
    Server Component's stack frame.
    
    Each row can get more debug rows data streaming in as it resolves and
    renders multiple server components in a row.
    
    The data structure is just a side-channel and it would be perfectly fine
    to ignore the D rows and it would behave the same as prod. With this
    data structure though the data is associated with the row ID / chunk, so
    you can't have inline meta data. This means that an inline Server
    Component that doesn't get an ID otherwise will need to be outlined. The
    way I outline Server Components is using a direct reference where it's
    synchronous though so on the client side it behaves the same (i.e.
    there's no lazy wrapper in this case).
    
    In most cases the `_debugInfo` is on the Promises that we yield and we
    also expose this on the `React.Lazy` wrappers. In the case where it's a
    synchronous render it might attach this data to Elements or Arrays
    (fragments) too.
    
    In a future PR I'll wire this information up with Fiber to stash it in
    the Fiber data structures so that DevTools can pick it up. This property
    and the information in it is not limited to Server Components. The name
    of the property that we look for probably shouldn't be `_debugInfo`
    since it's semi-public. Should consider the name we use for that.
    
    If it's a synchronous render that returns a string or number (text node)
    then we don't have anywhere to attach them to. We could add a
    `React.Lazy` wrapper for those but I chose to prioritize keeping the
    data structure untouched. Can be useful if you use Server Components to
    render data instead of React Nodes.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index e2ad636e03..b5fae759e0 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -170,6 +170,13 @@ function ReactElement(type, key, ref, self, source, owner, props) {
       writable: true,
       value: false,
     });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null,
+    });
     if (Object.freeze) {
       Object.freeze(element.props);
       Object.freeze(element);

commit ec160f32c28ccab798c73ecccbb36ce121e1640e
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 19 22:14:29 2024 -0500

    Combine ReactJSXElementValidator with main module (#28317)
    
    There are too many layers to the JSX runtime implementation. I think
    basically everything should be implemented in a single file, so that's
    what I'm going to do.
    
    As a first step, this deletes ReactJSXElementValidator and moves all the
    code into ReactJSXElement. I can already see how this will help us
    remove more indirections in the future.
    
    Next I'm going to do start moving the `createElement` runtime into this
    module as well, since there's a lot of duplicated code.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index b5fae759e0..d955dcf132 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -8,10 +8,23 @@
 import getComponentNameFromType from 'shared/getComponentNameFromType';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import hasOwnProperty from 'shared/hasOwnProperty';
-import {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';
+import {
+  getIteratorFn,
+  REACT_ELEMENT_TYPE,
+  REACT_FORWARD_REF_TYPE,
+  REACT_MEMO_TYPE,
+  REACT_FRAGMENT_TYPE,
+} from 'shared/ReactSymbols';
 import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
+import isValidElementType from 'shared/isValidElementType';
+import isArray from 'shared/isArray';
+import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
+import checkPropTypes from 'shared/checkPropTypes';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
+const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+
+const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 
 let specialPropKeyWarningShown;
 let specialPropRefWarningShown;
@@ -192,7 +205,7 @@ function ReactElement(type, key, ref, self, source, owner, props) {
  * @param {object} props
  * @param {string} key
  */
-export function jsx(type, config, maybeKey) {
+export function jsxProd(type, config, maybeKey) {
   let propName;
 
   // Reserved names are extracted
@@ -259,14 +272,157 @@ export function jsx(type, config, maybeKey) {
   );
 }
 
+// While `jsxDEV` should never be called when running in production, we do
+// support `jsx` and `jsxs` when running in development. This supports the case
+// where a third-party dependency ships code that was compiled for production;
+// we want to still provide warnings in development.
+//
+// So these functions are the _dev_ implementations of the _production_
+// API signatures.
+//
+// Since these functions are dev-only, it's ok to add an indirection here. They
+// only exist to provide different versions of `isStaticChildren`. (We shouldn't
+// use this pattern for the prod versions, though, because it will add an call
+// frame.)
+export function jsxProdSignatureRunningInDevWithDynamicChildren(
+  type,
+  config,
+  maybeKey,
+  source,
+  self,
+) {
+  if (__DEV__) {
+    const isStaticChildren = false;
+    return jsxDEV(type, config, maybeKey, isStaticChildren, source, self);
+  }
+}
+
+export function jsxProdSignatureRunningInDevWithStaticChildren(
+  type,
+  config,
+  maybeKey,
+  source,
+  self,
+) {
+  if (__DEV__) {
+    const isStaticChildren = true;
+    return jsxDEV(type, config, maybeKey, isStaticChildren, source, self);
+  }
+}
+
+const didWarnAboutKeySpread = {};
+
 /**
  * https://github.com/reactjs/rfcs/pull/107
  * @param {*} type
  * @param {object} props
  * @param {string} key
  */
-export function jsxDEV(type, config, maybeKey, source, self) {
+export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
   if (__DEV__) {
+    if (!isValidElementType(type)) {
+      // This is an invalid element type.
+      //
+      // We warn in this case but don't throw. We expect the element creation to
+      // succeed and there will likely be errors in render.
+      let info = '';
+      if (
+        type === undefined ||
+        (typeof type === 'object' &&
+          type !== null &&
+          Object.keys(type).length === 0)
+      ) {
+        info +=
+          ' You likely forgot to export your component from the file ' +
+          "it's defined in, or you might have mixed up default and named imports.";
+      }
+
+      const sourceInfo = getSourceInfoErrorAddendum(source);
+      if (sourceInfo) {
+        info += sourceInfo;
+      } else {
+        info += getDeclarationErrorAddendum();
+      }
+
+      let typeString;
+      if (type === null) {
+        typeString = 'null';
+      } else if (isArray(type)) {
+        typeString = 'array';
+      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
+        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;
+        info =
+          ' Did you accidentally export a JSX literal instead of a component?';
+      } else {
+        typeString = typeof type;
+      }
+
+      console.error(
+        'React.jsx: type is invalid -- expected a string (for ' +
+          'built-in components) or a class/function (for composite ' +
+          'components) but got: %s.%s',
+        typeString,
+        info,
+      );
+    } else {
+      // This is a valid element type.
+
+      // Skip key warning if the type isn't valid since our key validation logic
+      // doesn't expect a non-string/function type and can throw confusing
+      // errors. We don't want exception behavior to differ between dev and
+      // prod. (Rendering will throw with a helpful message and as soon as the
+      // type is fixed, the key warnings will appear.)
+      const children = config.children;
+      if (children !== undefined) {
+        if (isStaticChildren) {
+          if (isArray(children)) {
+            for (let i = 0; i < children.length; i++) {
+              validateChildKeys(children[i], type);
+            }
+
+            if (Object.freeze) {
+              Object.freeze(children);
+            }
+          } else {
+            console.error(
+              'React.jsx: Static children should always be an array. ' +
+                'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +
+                'Use the Babel transform instead.',
+            );
+          }
+        } else {
+          validateChildKeys(children, type);
+        }
+      }
+    }
+
+    // Warn about key spread regardless of whether the type is valid.
+    if (hasOwnProperty.call(config, 'key')) {
+      const componentName = getComponentNameFromType(type);
+      const keys = Object.keys(config).filter(k => k !== 'key');
+      const beforeExample =
+        keys.length > 0
+          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'
+          : '{key: someKey}';
+      if (!didWarnAboutKeySpread[componentName + beforeExample]) {
+        const afterExample =
+          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
+        console.error(
+          'A props object containing a "key" prop is being spread into JSX:\n' +
+            '  let props = %s;\n' +
+            '  <%s {...props} />\n' +
+            'React keys must be passed directly to JSX without using spread:\n' +
+            '  let props = %s;\n' +
+            '  <%s key={someKey} {...props} />',
+          beforeExample,
+          componentName,
+          afterExample,
+          componentName,
+        );
+        didWarnAboutKeySpread[componentName + beforeExample] = true;
+      }
+    }
+
     let propName;
 
     // Reserved names are extracted
@@ -336,7 +492,7 @@ export function jsxDEV(type, config, maybeKey, source, self) {
       }
     }
 
-    return ReactElement(
+    const element = ReactElement(
       type,
       key,
       ref,
@@ -345,5 +501,266 @@ export function jsxDEV(type, config, maybeKey, source, self) {
       ReactCurrentOwner.current,
       props,
     );
+
+    if (type === REACT_FRAGMENT_TYPE) {
+      validateFragmentProps(element);
+    } else {
+      validatePropTypes(element);
+    }
+
+    return element;
+  }
+}
+
+function getDeclarationErrorAddendum() {
+  if (__DEV__) {
+    if (ReactCurrentOwner.current) {
+      const name = getComponentNameFromType(ReactCurrentOwner.current.type);
+      if (name) {
+        return '\n\nCheck the render method of `' + name + '`.';
+      }
+    }
+    return '';
+  }
+}
+
+function getSourceInfoErrorAddendum(source) {
+  if (__DEV__) {
+    if (source !== undefined) {
+      const fileName = source.fileName.replace(/^.*[\\\/]/, '');
+      const lineNumber = source.lineNumber;
+      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
+    }
+    return '';
+  }
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  if (__DEV__) {
+    if (typeof node !== 'object' || !node) {
+      return;
+    }
+    if (node.$$typeof === REACT_CLIENT_REFERENCE) {
+      // This is a reference to a client component so it's unknown.
+    } else if (isArray(node)) {
+      for (let i = 0; i < node.length; i++) {
+        const child = node[i];
+        if (isValidElement(child)) {
+          validateExplicitKey(child, parentType);
+        }
+      }
+    } else if (isValidElement(node)) {
+      // This element was passed in a valid location.
+      if (node._store) {
+        node._store.validated = true;
+      }
+    } else {
+      const iteratorFn = getIteratorFn(node);
+      if (typeof iteratorFn === 'function') {
+        // Entry iterators used to provide implicit keys,
+        // but now we print a separate warning for them later.
+        if (iteratorFn !== node.entries) {
+          const iterator = iteratorFn.call(node);
+          let step;
+          while (!(step = iterator.next()).done) {
+            if (isValidElement(step.value)) {
+              validateExplicitKey(step.value, parentType);
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+export function isValidElement(object) {
+  if (__DEV__) {
+    return (
+      typeof object === 'object' &&
+      object !== null &&
+      object.$$typeof === REACT_ELEMENT_TYPE
+    );
+  }
+}
+
+const ownerHasKeyUseWarning = {};
+
+/**
+ * Warn if the element doesn't have an explicit key assigned to it.
+ * This element is in an array. The array could grow and shrink or be
+ * reordered. All children that haven't already been validated are required to
+ * have a "key" property assigned to it. Error statuses are cached so a warning
+ * will only be shown once.
+ *
+ * @internal
+ * @param {ReactElement} element Element that requires a key.
+ * @param {*} parentType element's parent's type.
+ */
+function validateExplicitKey(element, parentType) {
+  if (__DEV__) {
+    if (!element._store || element._store.validated || element.key != null) {
+      return;
+    }
+    element._store.validated = true;
+
+    const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
+    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
+      return;
+    }
+    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
+
+    // Usually the current owner is the offender, but if it accepts children as a
+    // property, it may be the creator of the child that's responsible for
+    // assigning it a key.
+    let childOwner = '';
+    if (
+      element &&
+      element._owner &&
+      element._owner !== ReactCurrentOwner.current
+    ) {
+      // Give the component that originally created this child.
+      childOwner = ` It was passed a child from ${getComponentNameFromType(
+        element._owner.type,
+      )}.`;
+    }
+
+    setCurrentlyValidatingElement(element);
+    console.error(
+      'Each child in a list should have a unique "key" prop.' +
+        '%s%s See https://reactjs.org/link/warning-keys for more information.',
+      currentComponentErrorInfo,
+      childOwner,
+    );
+    setCurrentlyValidatingElement(null);
+  }
+}
+
+function setCurrentlyValidatingElement(element) {
+  if (__DEV__) {
+    if (element) {
+      const owner = element._owner;
+      const stack = describeUnknownElementTypeFrameInDEV(
+        element.type,
+        owner ? owner.type : null,
+      );
+      ReactDebugCurrentFrame.setExtraStackFrame(stack);
+    } else {
+      ReactDebugCurrentFrame.setExtraStackFrame(null);
+    }
+  }
+}
+
+function getCurrentComponentErrorInfo(parentType) {
+  if (__DEV__) {
+    let info = getDeclarationErrorAddendum();
+
+    if (!info) {
+      const parentName = getComponentNameFromType(parentType);
+      if (parentName) {
+        info = `\n\nCheck the top-level render call using <${parentName}>.`;
+      }
+    }
+    return info;
+  }
+}
+
+/**
+ * Given a fragment, validate that it can only be provided with fragment props
+ * @param {ReactElement} fragment
+ */
+function validateFragmentProps(fragment) {
+  if (__DEV__) {
+    const keys = Object.keys(fragment.props);
+    for (let i = 0; i < keys.length; i++) {
+      const key = keys[i];
+      if (key !== 'children' && key !== 'key') {
+        setCurrentlyValidatingElement(fragment);
+        console.error(
+          'Invalid prop `%s` supplied to `React.Fragment`. ' +
+            'React.Fragment can only have `key` and `children` props.',
+          key,
+        );
+        setCurrentlyValidatingElement(null);
+        break;
+      }
+    }
+
+    if (fragment.ref !== null) {
+      setCurrentlyValidatingElement(fragment);
+      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');
+      setCurrentlyValidatingElement(null);
+    }
+  }
+}
+
+let propTypesMisspellWarningShown = false;
+
+/**
+ * Given an element, validate that its props follow the propTypes definition,
+ * provided by the type.
+ *
+ * @param {ReactElement} element
+ */
+function validatePropTypes(element) {
+  if (__DEV__) {
+    const type = element.type;
+    if (type === null || type === undefined || typeof type === 'string') {
+      return;
+    }
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      return;
+    }
+    let propTypes;
+    if (typeof type === 'function') {
+      propTypes = type.propTypes;
+    } else if (
+      typeof type === 'object' &&
+      (type.$$typeof === REACT_FORWARD_REF_TYPE ||
+        // Note: Memo only checks outer props here.
+        // Inner props are checked in the reconciler.
+        type.$$typeof === REACT_MEMO_TYPE)
+    ) {
+      propTypes = type.propTypes;
+    } else {
+      return;
+    }
+    if (propTypes) {
+      // Intentionally inside to avoid triggering lazy initializers:
+      const name = getComponentNameFromType(type);
+      checkPropTypes(propTypes, element.props, 'prop', name, element);
+    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
+      propTypesMisspellWarningShown = true;
+      // Intentionally inside to avoid triggering lazy initializers:
+      const name = getComponentNameFromType(type);
+      console.error(
+        'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
+        name || 'Unknown',
+      );
+    }
+    if (
+      typeof type.getDefaultProps === 'function' &&
+      !type.getDefaultProps.isReactClassApproved
+    ) {
+      console.error(
+        'getDefaultProps is only used on classic React.createClass ' +
+          'definitions. Use a static property named `defaultProps` instead.',
+      );
+    }
   }
 }

commit 5fb2c93f3924ba980444da5698f60651b5ef0689
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 19 22:45:18 2024 -0500

    Combine createElement and JSX modules (#28320)
    
    Depends on:
    
    - #28317
    
    ---
    
    There's a ton of overlap between the createElement implementation and
    the JSX implementation, so I combined them into a single module.
    
    In the actual build output, the shared code between JSX and
    createElement will get duplicated anyway, because react/jsx-runtime and
    react (where createElement lives) are separate, flat build artifacts.
    
    So this is more about code organization — with a few key exceptions, the
    implementations of createElement and jsx are highly coupled.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index d955dcf132..4e54696329 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -8,6 +8,7 @@
 import getComponentNameFromType from 'shared/getComponentNameFromType';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import hasOwnProperty from 'shared/hasOwnProperty';
+import assign from 'shared/assign';
 import {
   getIteratorFn,
   REACT_ELEMENT_TYPE,
@@ -512,6 +513,331 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
   }
 }
 
+/**
+ * Create and return a new ReactElement of the given type.
+ * See https://reactjs.org/docs/react-api.html#createelement
+ */
+export function createElement(type, config, children) {
+  if (__DEV__) {
+    if (!isValidElementType(type)) {
+      // This is an invalid element type.
+      //
+      // We warn in this case but don't throw. We expect the element creation to
+      // succeed and there will likely be errors in render.
+      let info = '';
+      if (
+        type === undefined ||
+        (typeof type === 'object' &&
+          type !== null &&
+          Object.keys(type).length === 0)
+      ) {
+        info +=
+          ' You likely forgot to export your component from the file ' +
+          "it's defined in, or you might have mixed up default and named imports.";
+      }
+
+      const sourceInfo = getSourceInfoErrorAddendumForProps(config);
+      if (sourceInfo) {
+        info += sourceInfo;
+      } else {
+        info += getDeclarationErrorAddendum();
+      }
+
+      let typeString;
+      if (type === null) {
+        typeString = 'null';
+      } else if (isArray(type)) {
+        typeString = 'array';
+      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
+        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;
+        info =
+          ' Did you accidentally export a JSX literal instead of a component?';
+      } else {
+        typeString = typeof type;
+      }
+
+      console.error(
+        'React.createElement: type is invalid -- expected a string (for ' +
+          'built-in components) or a class/function (for composite ' +
+          'components) but got: %s.%s',
+        typeString,
+        info,
+      );
+    } else {
+      // This is a valid element type.
+
+      // Skip key warning if the type isn't valid since our key validation logic
+      // doesn't expect a non-string/function type and can throw confusing
+      // errors. We don't want exception behavior to differ between dev and
+      // prod. (Rendering will throw with a helpful message and as soon as the
+      // type is fixed, the key warnings will appear.)
+      for (let i = 2; i < arguments.length; i++) {
+        validateChildKeys(arguments[i], type);
+      }
+    }
+
+    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.
+  }
+
+  let propName;
+
+  // Reserved names are extracted
+  const props = {};
+
+  let key = null;
+  let ref = null;
+
+  if (config != null) {
+    if (hasValidRef(config)) {
+      ref = config.ref;
+
+      if (__DEV__) {
+        warnIfStringRefCannotBeAutoConverted(config, config.__self);
+      }
+    }
+    if (hasValidKey(config)) {
+      if (__DEV__) {
+        checkKeyStringCoercion(config.key);
+      }
+      key = '' + config.key;
+    }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (
+        hasOwnProperty.call(config, propName) &&
+        // Skip over reserved prop names
+        propName !== 'key' &&
+        // TODO: `ref` will no longer be reserved in the next major
+        propName !== 'ref' &&
+        // ...and maybe these, too, though we currently rely on them for
+        // warnings and debug information in dev. Need to decide if we're OK
+        // with dropping them. In the jsx() runtime it's not an issue because
+        // the data gets passed as separate arguments instead of props, but
+        // it would be nice to stop relying on them entirely so we can drop
+        // them from the internal Fiber field.
+        propName !== '__self' &&
+        propName !== '__source'
+      ) {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    if (__DEV__) {
+      if (Object.freeze) {
+        Object.freeze(childArray);
+      }
+    }
+    props.children = childArray;
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    const defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+  }
+  if (__DEV__) {
+    if (key || ref) {
+      const displayName =
+        typeof type === 'function'
+          ? type.displayName || type.name || 'Unknown'
+          : type;
+      if (key) {
+        defineKeyPropWarningGetter(props, displayName);
+      }
+      if (ref) {
+        defineRefPropWarningGetter(props, displayName);
+      }
+    }
+  }
+
+  const element = ReactElement(
+    type,
+    key,
+    ref,
+    undefined,
+    undefined,
+    ReactCurrentOwner.current,
+    props,
+  );
+
+  if (type === REACT_FRAGMENT_TYPE) {
+    validateFragmentProps(element);
+  } else {
+    validatePropTypes(element);
+  }
+
+  return element;
+}
+
+let didWarnAboutDeprecatedCreateFactory = false;
+
+/**
+ * Return a function that produces ReactElements of a given type.
+ * See https://reactjs.org/docs/react-api.html#createfactory
+ */
+export function createFactory(type) {
+  const factory = createElement.bind(null, type);
+  // Expose the type on the factory and the prototype so that it can be
+  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
+  // This should not be named `constructor` since this may not be the function
+  // that created the element, and it may not even be a constructor.
+  // Legacy hook: remove it
+  factory.type = type;
+
+  if (__DEV__) {
+    if (!didWarnAboutDeprecatedCreateFactory) {
+      didWarnAboutDeprecatedCreateFactory = true;
+      console.warn(
+        'React.createFactory() is deprecated and will be removed in ' +
+          'a future major release. Consider using JSX ' +
+          'or use React.createElement() directly instead.',
+      );
+    }
+    // Legacy hook: remove it
+    Object.defineProperty(factory, 'type', {
+      enumerable: false,
+      get: function () {
+        console.warn(
+          'Factory.type is deprecated. Access the class directly ' +
+            'before passing it to createFactory.',
+        );
+        Object.defineProperty(this, 'type', {
+          value: type,
+        });
+        return type;
+      },
+    });
+  }
+
+  return factory;
+}
+
+export function cloneAndReplaceKey(oldElement, newKey) {
+  return ReactElement(
+    oldElement.type,
+    newKey,
+    oldElement.ref,
+    undefined,
+    undefined,
+    oldElement._owner,
+    oldElement.props,
+  );
+}
+
+/**
+ * Clone and return a new ReactElement using element as the starting point.
+ * See https://reactjs.org/docs/react-api.html#cloneelement
+ */
+export function cloneElement(element, config, children) {
+  if (element === null || element === undefined) {
+    throw new Error(
+      `React.cloneElement(...): The argument must be a React element, but you passed ${element}.`,
+    );
+  }
+
+  let propName;
+
+  // Original props are copied
+  const props = assign({}, element.props);
+
+  // Reserved names are extracted
+  let key = element.key;
+  let ref = element.ref;
+
+  // Owner will be preserved, unless ref is overridden
+  let owner = element._owner;
+
+  if (config != null) {
+    if (hasValidRef(config)) {
+      // Silently steal the ref from the parent.
+      ref = config.ref;
+      owner = ReactCurrentOwner.current;
+    }
+    if (hasValidKey(config)) {
+      if (__DEV__) {
+        checkKeyStringCoercion(config.key);
+      }
+      key = '' + config.key;
+    }
+
+    // Remaining properties override existing props
+    let defaultProps;
+    if (element.type && element.type.defaultProps) {
+      defaultProps = element.type.defaultProps;
+    }
+    for (propName in config) {
+      if (
+        hasOwnProperty.call(config, propName) &&
+        // Skip over reserved prop names
+        propName !== 'key' &&
+        // TODO: `ref` will no longer be reserved in the next major
+        propName !== 'ref' &&
+        // ...and maybe these, too, though we currently rely on them for
+        // warnings and debug information in dev. Need to decide if we're OK
+        // with dropping them. In the jsx() runtime it's not an issue because
+        // the data gets passed as separate arguments instead of props, but
+        // it would be nice to stop relying on them entirely so we can drop
+        // them from the internal Fiber field.
+        propName !== '__self' &&
+        propName !== '__source'
+      ) {
+        if (config[propName] === undefined && defaultProps !== undefined) {
+          // Resolve default props
+          props[propName] = defaultProps[propName];
+        } else {
+          props[propName] = config[propName];
+        }
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+
+  const clonedElement = ReactElement(
+    element.type,
+    key,
+    ref,
+    undefined,
+    undefined,
+    owner,
+    props,
+  );
+
+  for (let i = 2; i < arguments.length; i++) {
+    validateChildKeys(arguments[i], clonedElement.type);
+  }
+  validatePropTypes(clonedElement);
+
+  return clonedElement;
+}
+
 function getDeclarationErrorAddendum() {
   if (__DEV__) {
     if (ReactCurrentOwner.current) {
@@ -524,6 +850,13 @@ function getDeclarationErrorAddendum() {
   }
 }
 
+function getSourceInfoErrorAddendumForProps(elementProps) {
+  if (elementProps !== null && elementProps !== undefined) {
+    return getSourceInfoErrorAddendum(elementProps.__source);
+  }
+  return '';
+}
+
 function getSourceInfoErrorAddendum(source) {
   if (__DEV__) {
     if (source !== undefined) {
@@ -590,13 +923,11 @@ function validateChildKeys(node, parentType) {
  * @final
  */
 export function isValidElement(object) {
-  if (__DEV__) {
-    return (
-      typeof object === 'object' &&
-      object !== null &&
-      object.$$typeof === REACT_ELEMENT_TYPE
-    );
-  }
+  return (
+    typeof object === 'object' &&
+    object !== null &&
+    object.$$typeof === REACT_ELEMENT_TYPE
+  );
 }
 
 const ownerHasKeyUseWarning = {};

commit fa2f82addc7c817892c482792f56a35277e8b75a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 20 14:17:41 2024 -0500

    Pass ref as normal prop (#28348)
    
    Depends on:
    
    - #28317
    - #28320
    
    ---
    
    Changes the behavior of the JSX runtime to pass through `ref` as a
    normal prop, rather than plucking it from the props object and storing
    on the element.
    
    This is a breaking change since it changes the type of the receiving
    component. However, most code is unaffected since it's unlikely that a
    component would have attempted to access a `ref` prop, since it was not
    possible to get a reference to one.
    
    `forwardRef` _will_ still pluck `ref` from the props object, though,
    since it's extremely common for users to spread the props object onto
    the inner component and pass `ref` as a differently named prop. This is
    for maximum compatibility with existing code — the real impact of this
    change is that `forwardRef` is no longer required.
    
    Currently, refs are resolved during child reconciliation and stored on
    the fiber. As a result of this change, we can move ref resolution to
    happen only much later, and only for components that actually use them.
    Then we can remove the `ref` field from the Fiber type. I have not yet
    done that in this step, though.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 4e54696329..dded86e3e7 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -21,6 +21,7 @@ import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
 import checkPropTypes from 'shared/checkPropTypes';
+import {enableRefAsProp} from 'shared/ReactFeatureFlags';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
@@ -30,9 +31,11 @@ const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 let specialPropKeyWarningShown;
 let specialPropRefWarningShown;
 let didWarnAboutStringRefs;
+let didWarnAboutElementRef;
 
 if (__DEV__) {
   didWarnAboutStringRefs = {};
+  didWarnAboutElementRef = {};
 }
 
 function hasValidRef(config) {
@@ -111,24 +114,45 @@ function defineKeyPropWarningGetter(props, displayName) {
 }
 
 function defineRefPropWarningGetter(props, displayName) {
+  if (!enableRefAsProp) {
+    if (__DEV__) {
+      const warnAboutAccessingRef = function () {
+        if (!specialPropRefWarningShown) {
+          specialPropRefWarningShown = true;
+          console.error(
+            '%s: `ref` is not a prop. Trying to access it will result ' +
+              'in `undefined` being returned. If you need to access the same ' +
+              'value within the child component, you should pass it as a different ' +
+              'prop. (https://reactjs.org/link/special-props)',
+            displayName,
+          );
+        }
+      };
+      warnAboutAccessingRef.isReactWarning = true;
+      Object.defineProperty(props, 'ref', {
+        get: warnAboutAccessingRef,
+        configurable: true,
+      });
+    }
+  }
+}
+
+function elementRefGetterWithDeprecationWarning() {
   if (__DEV__) {
-    const warnAboutAccessingRef = function () {
-      if (!specialPropRefWarningShown) {
-        specialPropRefWarningShown = true;
-        console.error(
-          '%s: `ref` is not a prop. Trying to access it will result ' +
-            'in `undefined` being returned. If you need to access the same ' +
-            'value within the child component, you should pass it as a different ' +
-            'prop. (https://reactjs.org/link/special-props)',
-          displayName,
-        );
-      }
-    };
-    warnAboutAccessingRef.isReactWarning = true;
-    Object.defineProperty(props, 'ref', {
-      get: warnAboutAccessingRef,
-      configurable: true,
-    });
+    const componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error(
+        'Accessing element.ref is no longer supported. ref is now a ' +
+          'regular prop. It will be removed from the JSX Element ' +
+          'type in a future release.',
+      );
+    }
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    const refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
   }
 }
 
@@ -152,20 +176,85 @@ function defineRefPropWarningGetter(props, displayName) {
  * indicating filename, line number, and/or other information.
  * @internal
  */
-function ReactElement(type, key, ref, self, source, owner, props) {
-  const element = {
-    // This tag allows us to uniquely identify this as a React Element
-    $$typeof: REACT_ELEMENT_TYPE,
+function ReactElement(type, key, _ref, self, source, owner, props) {
+  let ref;
+  if (enableRefAsProp) {
+    // When enableRefAsProp is on, ignore whatever was passed as the ref
+    // argument and treat `props.ref` as the source of truth. The only thing we
+    // use this for is `element.ref`, which will log a deprecation warning on
+    // access. In the next release, we can remove `element.ref` as well as the
+    // `ref` argument.
+    const refProp = props.ref;
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    ref = refProp !== undefined ? refProp : null;
+  } else {
+    ref = _ref;
+  }
 
-    // Built-in properties that belong on the element
-    type,
-    key,
-    ref,
-    props,
+  let element;
+  if (__DEV__ && enableRefAsProp) {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+
+      // Built-in properties that belong on the element
+      type,
+      key,
 
-    // Record the component responsible for creating this element.
-    _owner: owner,
-  };
+      props,
+
+      // Record the component responsible for creating this element.
+      _owner: owner,
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning,
+      });
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        value: null,
+      });
+    }
+  } else {
+    // In prod, `ref` is a regular property. It will be removed in a
+    // future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+
+      props,
+
+      // Record the component responsible for creating this element.
+      _owner: owner,
+    };
+  }
 
   if (__DEV__) {
     // The validation flag is currently mutative. We put it on
@@ -236,7 +325,9 @@ export function jsxProd(type, config, maybeKey) {
   }
 
   if (hasValidRef(config)) {
-    ref = config.ref;
+    if (!enableRefAsProp) {
+      ref = config.ref;
+    }
   }
 
   // Remaining properties are added to a new props object
@@ -245,8 +336,7 @@ export function jsxProd(type, config, maybeKey) {
       hasOwnProperty.call(config, propName) &&
       // Skip over reserved prop names
       propName !== 'key' &&
-      // TODO: `ref` will no longer be reserved in the next major
-      propName !== 'ref'
+      (enableRefAsProp || propName !== 'ref')
     ) {
       props[propName] = config[propName];
     }
@@ -453,7 +543,9 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
     }
 
     if (hasValidRef(config)) {
-      ref = config.ref;
+      if (!enableRefAsProp) {
+        ref = config.ref;
+      }
       warnIfStringRefCannotBeAutoConverted(config, self);
     }
 
@@ -463,8 +555,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        // TODO: `ref` will no longer be reserved in the next major
-        propName !== 'ref'
+        (enableRefAsProp || propName !== 'ref')
       ) {
         props[propName] = config[propName];
       }
@@ -480,7 +571,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       }
     }
 
-    if (key || ref) {
+    if (key || (!enableRefAsProp && ref)) {
       const displayName =
         typeof type === 'function'
           ? type.displayName || type.name || 'Unknown'
@@ -488,7 +579,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       if (key) {
         defineKeyPropWarningGetter(props, displayName);
       }
-      if (ref) {
+      if (!enableRefAsProp && ref) {
         defineRefPropWarningGetter(props, displayName);
       }
     }
@@ -589,7 +680,9 @@ export function createElement(type, config, children) {
 
   if (config != null) {
     if (hasValidRef(config)) {
-      ref = config.ref;
+      if (!enableRefAsProp) {
+        ref = config.ref;
+      }
 
       if (__DEV__) {
         warnIfStringRefCannotBeAutoConverted(config, config.__self);
@@ -608,14 +701,11 @@ export function createElement(type, config, children) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        // TODO: `ref` will no longer be reserved in the next major
-        propName !== 'ref' &&
-        // ...and maybe these, too, though we currently rely on them for
-        // warnings and debug information in dev. Need to decide if we're OK
-        // with dropping them. In the jsx() runtime it's not an issue because
-        // the data gets passed as separate arguments instead of props, but
-        // it would be nice to stop relying on them entirely so we can drop
-        // them from the internal Fiber field.
+        (enableRefAsProp || propName !== 'ref') &&
+        // Even though we don't use these anymore in the runtime, we don't want
+        // them to appear as props, so in createElement we filter them out.
+        // We don't have to do this in the jsx() runtime because the jsx()
+        // transform never passed these as props; it used separate arguments.
         propName !== '__self' &&
         propName !== '__source'
       ) {
@@ -652,7 +742,7 @@ export function createElement(type, config, children) {
     }
   }
   if (__DEV__) {
-    if (key || ref) {
+    if (key || (!enableRefAsProp && ref)) {
       const displayName =
         typeof type === 'function'
           ? type.displayName || type.name || 'Unknown'
@@ -660,7 +750,7 @@ export function createElement(type, config, children) {
       if (key) {
         defineKeyPropWarningGetter(props, displayName);
       }
-      if (ref) {
+      if (!enableRefAsProp && ref) {
         defineRefPropWarningGetter(props, displayName);
       }
     }
@@ -732,7 +822,9 @@ export function cloneAndReplaceKey(oldElement, newKey) {
   return ReactElement(
     oldElement.type,
     newKey,
-    oldElement.ref,
+    // When enableRefAsProp is on, this argument is ignored. This check only
+    // exists to avoid the `ref` access warning.
+    enableRefAsProp ? null : oldElement.ref,
     undefined,
     undefined,
     oldElement._owner,
@@ -758,15 +850,17 @@ export function cloneElement(element, config, children) {
 
   // Reserved names are extracted
   let key = element.key;
-  let ref = element.ref;
+  let ref = enableRefAsProp ? null : element.ref;
 
   // Owner will be preserved, unless ref is overridden
   let owner = element._owner;
 
   if (config != null) {
     if (hasValidRef(config)) {
-      // Silently steal the ref from the parent.
-      ref = config.ref;
+      if (!enableRefAsProp) {
+        // Silently steal the ref from the parent.
+        ref = config.ref;
+      }
       owner = ReactCurrentOwner.current;
     }
     if (hasValidKey(config)) {
@@ -786,8 +880,7 @@ export function cloneElement(element, config, children) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        // TODO: `ref` will no longer be reserved in the next major
-        propName !== 'ref' &&
+        (enableRefAsProp || propName !== 'ref') &&
         // ...and maybe these, too, though we currently rely on them for
         // warnings and debug information in dev. Need to decide if we're OK
         // with dropping them. In the jsx() runtime it's not an issue because
@@ -795,7 +888,11 @@ export function cloneElement(element, config, children) {
         // it would be nice to stop relying on them entirely so we can drop
         // them from the internal Fiber field.
         propName !== '__self' &&
-        propName !== '__source'
+        propName !== '__source' &&
+        // Undefined `ref` is ignored by cloneElement. We treat it the same as
+        // if the property were missing. This is mostly for
+        // backwards compatibility.
+        !(enableRefAsProp && propName === 'ref' && config.ref === undefined)
       ) {
         if (config[propName] === undefined && defaultProps !== undefined) {
           // Resolve default props
@@ -1016,6 +1113,7 @@ function getCurrentComponentErrorInfo(parentType) {
  * @param {ReactElement} fragment
  */
 function validateFragmentProps(fragment) {
+  // TODO: Move this to render phase instead of at element creation.
   if (__DEV__) {
     const keys = Object.keys(fragment.props);
     for (let i = 0; i < keys.length; i++) {
@@ -1032,7 +1130,7 @@ function validateFragmentProps(fragment) {
       }
     }
 
-    if (fragment.ref !== null) {
+    if (!enableRefAsProp && fragment.ref !== null) {
       setCurrentlyValidatingElement(fragment);
       console.error('Invalid attribute `ref` supplied to `React.Fragment`.');
       setCurrentlyValidatingElement(null);

commit 353ecd05160a318a3f75260ee7906fd12e05cb9d
Author: dan <dan.abramov@me.com>
Date:   Wed Feb 21 11:15:51 2024 +0000

    Remove JSX propTypes validation (#28328)
    
    This removes the remaining `propTypes` validation calls, making
    declaring `propTypes` a no-op. In other words, React itself will no
    longer validate the `propTypes` that you declare on your components.
    
    In general, our recommendation is to use static type checking (e.g.
    TypeScript). If you'd like to still run propTypes checks, you can do so
    manually, same as you'd do outside React:
    
    ```js
    import checkPropTypes from 'prop-types/checkPropTypes';
    
    function Button(props) {
      checkPropTypes(Button.propTypes, prop, 'prop', Button.name)
      // ...
    }
    ```
    
    This could be automated as a Babel plugin if you want to keep these
    checks implicit. (We will not be providing such a plugin, but someone in
    community might be interested in building or maintaining one.)

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index dded86e3e7..59e7b6e5e3 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -12,15 +12,12 @@ import assign from 'shared/assign';
 import {
   getIteratorFn,
   REACT_ELEMENT_TYPE,
-  REACT_FORWARD_REF_TYPE,
-  REACT_MEMO_TYPE,
   REACT_FRAGMENT_TYPE,
 } from 'shared/ReactSymbols';
 import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
-import checkPropTypes from 'shared/checkPropTypes';
 import {enableRefAsProp} from 'shared/ReactFeatureFlags';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
@@ -596,8 +593,6 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
 
     if (type === REACT_FRAGMENT_TYPE) {
       validateFragmentProps(element);
-    } else {
-      validatePropTypes(element);
     }
 
     return element;
@@ -768,8 +763,6 @@ export function createElement(type, config, children) {
 
   if (type === REACT_FRAGMENT_TYPE) {
     validateFragmentProps(element);
-  } else {
-    validatePropTypes(element);
   }
 
   return element;
@@ -930,7 +923,6 @@ export function cloneElement(element, config, children) {
   for (let i = 2; i < arguments.length; i++) {
     validateChildKeys(arguments[i], clonedElement.type);
   }
-  validatePropTypes(clonedElement);
 
   return clonedElement;
 }
@@ -1137,59 +1129,3 @@ function validateFragmentProps(fragment) {
     }
   }
 }
-
-let propTypesMisspellWarningShown = false;
-
-/**
- * Given an element, validate that its props follow the propTypes definition,
- * provided by the type.
- *
- * @param {ReactElement} element
- */
-function validatePropTypes(element) {
-  if (__DEV__) {
-    const type = element.type;
-    if (type === null || type === undefined || typeof type === 'string') {
-      return;
-    }
-    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
-      return;
-    }
-    let propTypes;
-    if (typeof type === 'function') {
-      propTypes = type.propTypes;
-    } else if (
-      typeof type === 'object' &&
-      (type.$$typeof === REACT_FORWARD_REF_TYPE ||
-        // Note: Memo only checks outer props here.
-        // Inner props are checked in the reconciler.
-        type.$$typeof === REACT_MEMO_TYPE)
-    ) {
-      propTypes = type.propTypes;
-    } else {
-      return;
-    }
-    if (propTypes) {
-      // Intentionally inside to avoid triggering lazy initializers:
-      const name = getComponentNameFromType(type);
-      checkPropTypes(propTypes, element.props, 'prop', name, element);
-    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
-      propTypesMisspellWarningShown = true;
-      // Intentionally inside to avoid triggering lazy initializers:
-      const name = getComponentNameFromType(type);
-      console.error(
-        'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
-        name || 'Unknown',
-      );
-    }
-    if (
-      typeof type.getDefaultProps === 'function' &&
-      !type.getDefaultProps.isReactClassApproved
-    ) {
-      console.error(
-        'getDefaultProps is only used on classic React.createClass ' +
-          'definitions. Use a static property named `defaultProps` instead.',
-      );
-    }
-  }
-}

commit d579e7748218920331252b0528850943d5e2dd31
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Feb 23 15:16:54 2024 -0500

    Remove method name prefix from warnings and errors (#28432)
    
    This pattern is a petpeeve of mine. I don't consider this best practice
    and so most don't have these prefixes. Very inconsistent.
    
    At best this is useless and noisey that you have to parse because the
    information is also in the stack trace.
    
    At worse these are misleading because they're highlighting something
    internal (like validateDOMNesting) which even suggests an internal bug.
    Even the ones public to React aren't necessarily what you called because
    you might be calling a wrapper around it.
    
    That would be properly reflected in a stack trace - which can also
    properly ignore list so that the first stack you see is your callsite,
    
    Which might be like `render()` in react-testing-library rather than
    `createRoot()` for example.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 59e7b6e5e3..9aa3fbf1ea 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -832,7 +832,7 @@ export function cloneAndReplaceKey(oldElement, newKey) {
 export function cloneElement(element, config, children) {
   if (element === null || element === undefined) {
     throw new Error(
-      `React.cloneElement(...): The argument must be a React element, but you passed ${element}.`,
+      `The argument must be a React element, but you passed ${element}.`,
     );
   }
 

commit 16d3f7833d25b1ea026add83dd109601b60f138e
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Feb 23 16:52:00 2024 -0500

    Delete use of `source` in JSX runtime (#28433)
    
    Only remaining place it was being used was in a warning message.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 9aa3fbf1ea..7022bfb87e 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -425,13 +425,6 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
           "it's defined in, or you might have mixed up default and named imports.";
       }
 
-      const sourceInfo = getSourceInfoErrorAddendum(source);
-      if (sourceInfo) {
-        info += sourceInfo;
-      } else {
-        info += getDeclarationErrorAddendum();
-      }
-
       let typeString;
       if (type === null) {
         typeString = 'null';
@@ -622,13 +615,6 @@ export function createElement(type, config, children) {
           "it's defined in, or you might have mixed up default and named imports.";
       }
 
-      const sourceInfo = getSourceInfoErrorAddendumForProps(config);
-      if (sourceInfo) {
-        info += sourceInfo;
-      } else {
-        info += getDeclarationErrorAddendum();
-      }
-
       let typeString;
       if (type === null) {
         typeString = 'null';
@@ -939,24 +925,6 @@ function getDeclarationErrorAddendum() {
   }
 }
 
-function getSourceInfoErrorAddendumForProps(elementProps) {
-  if (elementProps !== null && elementProps !== undefined) {
-    return getSourceInfoErrorAddendum(elementProps.__source);
-  }
-  return '';
-}
-
-function getSourceInfoErrorAddendum(source) {
-  if (__DEV__) {
-    if (source !== undefined) {
-      const fileName = source.fileName.replace(/^.*[\\\/]/, '');
-      const lineNumber = source.lineNumber;
-      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
-    }
-    return '';
-  }
-}
-
 /**
  * Ensure that every element either is passed in a static location, in an
  * array with an explicit keys property defined, or in an object literal

commit c9798954e26a2354a951cc65607f2901a45bf035
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 27 11:43:04 2024 -0500

    Remove string refs (behind flag)  (#28322)
    
    Depends on:
    
    - https://github.com/facebook/react/pull/28398
    
    ---
    
    This removes string refs, which has been deprecated in Strict Mode for
    seven years.
    
    I've left them behind a flag for Meta, but in open source this fully
    removes the feature.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 7022bfb87e..7ca9a43b15 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -18,7 +18,7 @@ import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
-import {enableRefAsProp} from 'shared/ReactFeatureFlags';
+import {enableRefAsProp, disableStringRefs} from 'shared/ReactFeatureFlags';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
@@ -62,6 +62,7 @@ function hasValidKey(config) {
 function warnIfStringRefCannotBeAutoConverted(config, self) {
   if (__DEV__) {
     if (
+      !disableStringRefs &&
       typeof config.ref === 'string' &&
       ReactCurrentOwner.current &&
       self &&
@@ -536,7 +537,9 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       if (!enableRefAsProp) {
         ref = config.ref;
       }
-      warnIfStringRefCannotBeAutoConverted(config, self);
+      if (!disableStringRefs) {
+        warnIfStringRefCannotBeAutoConverted(config, self);
+      }
     }
 
     // Remaining properties are added to a new props object
@@ -665,7 +668,7 @@ export function createElement(type, config, children) {
         ref = config.ref;
       }
 
-      if (__DEV__) {
+      if (__DEV__ && !disableStringRefs) {
         warnIfStringRefCannotBeAutoConverted(config, config.__self);
       }
     }

commit 1940cb27b260c2eab79c76763d1151ba18353ff8
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Mar 3 17:34:33 2024 -0500

    Update /link URLs to react.dev (#28477)
    
    Depends on https://github.com/reactjs/react.dev/pull/6670 [merged]

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 7ca9a43b15..bf455995aa 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -79,7 +79,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
             'This case cannot be automatically converted to an arrow function. ' +
             'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
             'Learn more about using refs safely here: ' +
-            'https://reactjs.org/link/strict-mode-string-ref',
+            'https://react.dev/link/strict-mode-string-ref',
           getComponentNameFromType(ReactCurrentOwner.current.type),
           config.ref,
         );
@@ -98,7 +98,7 @@ function defineKeyPropWarningGetter(props, displayName) {
           '%s: `key` is not a prop. Trying to access it will result ' +
             'in `undefined` being returned. If you need to access the same ' +
             'value within the child component, you should pass it as a different ' +
-            'prop. (https://reactjs.org/link/special-props)',
+            'prop. (https://react.dev/link/special-props)',
           displayName,
         );
       }
@@ -121,7 +121,7 @@ function defineRefPropWarningGetter(props, displayName) {
             '%s: `ref` is not a prop. Trying to access it will result ' +
               'in `undefined` being returned. If you need to access the same ' +
               'value within the child component, you should pass it as a different ' +
-              'prop. (https://reactjs.org/link/special-props)',
+              'prop. (https://react.dev/link/special-props)',
             displayName,
           );
         }
@@ -1034,7 +1034,7 @@ function validateExplicitKey(element, parentType) {
     setCurrentlyValidatingElement(element);
     console.error(
       'Each child in a list should have a unique "key" prop.' +
-        '%s%s See https://reactjs.org/link/warning-keys for more information.',
+        '%s%s See https://react.dev/link/warning-keys for more information.',
       currentComponentErrorInfo,
       childOwner,
     );

commit dbfbfb3312db019183ef92fd2ef110cc7d807e80
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 26 17:25:53 2024 -0400

    Update error messages (#28652)
    
    ## Overview
    
    The error messages that say:
    
    > ReactDOM.hydrate is no longer supported in React 18
    
    Don't make sense in the React 19 release. Instead, they should say:
    
    > ReactDOM.hydrate was removed in React 19.
    
    For legacy mode, they should say:
    
    > ReactDOM.hydrate has not been supported since React 18.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index bf455995aa..e85e2cfc87 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -141,7 +141,7 @@ function elementRefGetterWithDeprecationWarning() {
     if (!didWarnAboutElementRef[componentName]) {
       didWarnAboutElementRef[componentName] = true;
       console.error(
-        'Accessing element.ref is no longer supported. ref is now a ' +
+        'Accessing element.ref was removed in React 19. ref is now a ' +
           'regular prop. It will be removed from the JSX Element ' +
           'type in a future release.',
       );

commit 2aed507a76a0b1524426c398897cbe47d80c51e5
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Mar 29 16:29:48 2024 -0400

    Remove React.createFactory (#27798)
    
    `React.createFactory` has been long deprecated. This removes it for the
    next release.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index e85e2cfc87..3a0027c2b6 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -757,49 +757,6 @@ export function createElement(type, config, children) {
   return element;
 }
 
-let didWarnAboutDeprecatedCreateFactory = false;
-
-/**
- * Return a function that produces ReactElements of a given type.
- * See https://reactjs.org/docs/react-api.html#createfactory
- */
-export function createFactory(type) {
-  const factory = createElement.bind(null, type);
-  // Expose the type on the factory and the prototype so that it can be
-  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
-  // This should not be named `constructor` since this may not be the function
-  // that created the element, and it may not even be a constructor.
-  // Legacy hook: remove it
-  factory.type = type;
-
-  if (__DEV__) {
-    if (!didWarnAboutDeprecatedCreateFactory) {
-      didWarnAboutDeprecatedCreateFactory = true;
-      console.warn(
-        'React.createFactory() is deprecated and will be removed in ' +
-          'a future major release. Consider using JSX ' +
-          'or use React.createElement() directly instead.',
-      );
-    }
-    // Legacy hook: remove it
-    Object.defineProperty(factory, 'type', {
-      enumerable: false,
-      get: function () {
-        console.warn(
-          'Factory.type is deprecated. Access the class directly ' +
-            'before passing it to createFactory.',
-        );
-        Object.defineProperty(this, 'type', {
-          value: type,
-        });
-        return type;
-      },
-    });
-  }
-
-  return factory;
-}
-
 export function cloneAndReplaceKey(oldElement, newKey) {
   return ReactElement(
     oldElement.type,

commit 48b4ecc9012638ed51b275aad24b2086b8215e32
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Apr 4 10:59:19 2024 -0400

    Remove defaultProps support (except for classes)  (#28733)
    
    This removes defaultProps support for all component types except for
    classes. We've chosen to continue supporting defaultProps for classes
    because lots of older code relies on it, and unlike function components,
    (which can use default params), there's no straightforward alternative.
    
    By implication, it also removes support for setting defaultProps on
    `React.lazy` wrapper. So this will not work:
    
    ```js
    const MyClassComponent = React.lazy(() => import('./MyClassComponent'));
    // MyClassComponent is not actually a class; it's a lazy wrapper. So
    // defaultProps does not work.
    MyClassComponent.defaultProps = { foo: 'bar' };
    ```
    
    However, if you set the default props on the class itself, then it's
    fine.
    
    For classes, this change also moves where defaultProps are resolved.
    Previously, defaultProps were resolved by the JSX runtime. This change
    is only observable if you introspect a JSX element, which is relatively
    rare but does happen.
    
    In other words, previously `<ClassWithDefaultProp />.props.aDefaultProp`
    would resolve to the default prop value, but now it does not.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 3a0027c2b6..ffee6e1379 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -18,7 +18,11 @@ import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
-import {enableRefAsProp, disableStringRefs} from 'shared/ReactFeatureFlags';
+import {
+  enableRefAsProp,
+  disableStringRefs,
+  disableDefaultPropsExceptForClasses,
+} from 'shared/ReactFeatureFlags';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
@@ -340,12 +344,14 @@ export function jsxProd(type, config, maybeKey) {
     }
   }
 
-  // Resolve default props
-  if (type && type.defaultProps) {
-    const defaultProps = type.defaultProps;
-    for (propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
+  if (!disableDefaultPropsExceptForClasses) {
+    // Resolve default props
+    if (type && type.defaultProps) {
+      const defaultProps = type.defaultProps;
+      for (propName in defaultProps) {
+        if (props[propName] === undefined) {
+          props[propName] = defaultProps[propName];
+        }
       }
     }
   }
@@ -554,12 +560,14 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       }
     }
 
-    // Resolve default props
-    if (type && type.defaultProps) {
-      const defaultProps = type.defaultProps;
-      for (propName in defaultProps) {
-        if (props[propName] === undefined) {
-          props[propName] = defaultProps[propName];
+    if (!disableDefaultPropsExceptForClasses) {
+      // Resolve default props
+      if (type && type.defaultProps) {
+        const defaultProps = type.defaultProps;
+        for (propName in defaultProps) {
+          if (props[propName] === undefined) {
+            props[propName] = defaultProps[propName];
+          }
         }
       }
     }
@@ -811,7 +819,11 @@ export function cloneElement(element, config, children) {
 
     // Remaining properties override existing props
     let defaultProps;
-    if (element.type && element.type.defaultProps) {
+    if (
+      !disableDefaultPropsExceptForClasses &&
+      element.type &&
+      element.type.defaultProps
+    ) {
       defaultProps = element.type.defaultProps;
     }
     for (propName in config) {
@@ -833,7 +845,11 @@ export function cloneElement(element, config, children) {
         // backwards compatibility.
         !(enableRefAsProp && propName === 'ref' && config.ref === undefined)
       ) {
-        if (config[propName] === undefined && defaultProps !== undefined) {
+        if (
+          !disableDefaultPropsExceptForClasses &&
+          config[propName] === undefined &&
+          defaultProps !== undefined
+        ) {
           // Resolve default props
           props[propName] = defaultProps[propName];
         } else {

commit fd0da3eef1e23b7dd5071fef21de414da8e5038e
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Apr 4 11:20:15 2024 -0400

    Remove _owner field from JSX elements in prod if string refs are disabled (#28739)
    
    In prod, the `_owner` field is only used for string refs so if we have
    string refs disabled, we don't need this field. In fact, that's one of
    the big benefits of deprecating them.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index ffee6e1379..d20c1d4a25 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -239,6 +239,19 @@ function ReactElement(type, key, _ref, self, source, owner, props) {
         value: null,
       });
     }
+  } else if (!__DEV__ && disableStringRefs) {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+
+      props,
+    };
   } else {
     // In prod, `ref` is a regular property. It will be removed in a
     // future release.
@@ -774,7 +787,7 @@ export function cloneAndReplaceKey(oldElement, newKey) {
     enableRefAsProp ? null : oldElement.ref,
     undefined,
     undefined,
-    oldElement._owner,
+    !__DEV__ && disableStringRefs ? undefined : oldElement._owner,
     oldElement.props,
   );
 }
@@ -800,7 +813,7 @@ export function cloneElement(element, config, children) {
   let ref = enableRefAsProp ? null : element.ref;
 
   // Owner will be preserved, unless ref is overridden
-  let owner = element._owner;
+  let owner = !__DEV__ && disableStringRefs ? undefined : element._owner;
 
   if (config != null) {
     if (hasValidRef(config)) {

commit e3ebcd54b98a4f8f5a9f7e63982fa75578b648ed
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 5 10:53:11 2024 -0400

    Move string ref coercion to JSX runtime (#28473)
    
    Based on:
    
    - #28464
    
    ---
    
    This moves the entire string ref implementation out Fiber and into the
    JSX runtime. The string is converted to a callback ref during element
    creation. This is a subtle change in behavior, because it will have
    already been converted to a callback ref if you access element.prop.ref
    or element.ref. But this is only for Meta, because string refs are
    disabled entirely in open source. And if it leads to an issue in
    practice, the solution is to switch to a different ref type, which Meta
    is going to do regardless.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index d20c1d4a25..6727626b4e 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -23,6 +23,9 @@ import {
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
 } from 'shared/ReactFeatureFlags';
+import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
+import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
+import getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';
 
 const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
@@ -342,6 +345,9 @@ export function jsxProd(type, config, maybeKey) {
   if (hasValidRef(config)) {
     if (!enableRefAsProp) {
       ref = config.ref;
+      if (!disableStringRefs) {
+        ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+      }
     }
   }
 
@@ -353,7 +359,15 @@ export function jsxProd(type, config, maybeKey) {
       propName !== 'key' &&
       (enableRefAsProp || propName !== 'ref')
     ) {
-      props[propName] = config[propName];
+      if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+        props.ref = coerceStringRef(
+          config[propName],
+          ReactCurrentOwner.current,
+          type,
+        );
+      } else {
+        props[propName] = config[propName];
+      }
     }
   }
 
@@ -555,6 +569,9 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
     if (hasValidRef(config)) {
       if (!enableRefAsProp) {
         ref = config.ref;
+        if (!disableStringRefs) {
+          ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+        }
       }
       if (!disableStringRefs) {
         warnIfStringRefCannotBeAutoConverted(config, self);
@@ -569,7 +586,15 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
         propName !== 'key' &&
         (enableRefAsProp || propName !== 'ref')
       ) {
-        props[propName] = config[propName];
+        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+          props.ref = coerceStringRef(
+            config[propName],
+            ReactCurrentOwner.current,
+            type,
+          );
+        } else {
+          props[propName] = config[propName];
+        }
       }
     }
 
@@ -687,6 +712,9 @@ export function createElement(type, config, children) {
     if (hasValidRef(config)) {
       if (!enableRefAsProp) {
         ref = config.ref;
+        if (!disableStringRefs) {
+          ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+        }
       }
 
       if (__DEV__ && !disableStringRefs) {
@@ -714,7 +742,15 @@ export function createElement(type, config, children) {
         propName !== '__self' &&
         propName !== '__source'
       ) {
-        props[propName] = config[propName];
+        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+          props.ref = coerceStringRef(
+            config[propName],
+            ReactCurrentOwner.current,
+            type,
+          );
+        } else {
+          props[propName] = config[propName];
+        }
       }
     }
   }
@@ -820,6 +856,9 @@ export function cloneElement(element, config, children) {
       if (!enableRefAsProp) {
         // Silently steal the ref from the parent.
         ref = config.ref;
+        if (!disableStringRefs) {
+          ref = coerceStringRef(ref, owner, element.type);
+        }
       }
       owner = ReactCurrentOwner.current;
     }
@@ -866,7 +905,11 @@ export function cloneElement(element, config, children) {
           // Resolve default props
           props[propName] = defaultProps[propName];
         } else {
-          props[propName] = config[propName];
+          if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+            props.ref = coerceStringRef(config[propName], owner, element.type);
+          } else {
+            props[propName] = config[propName];
+          }
         }
       }
     }
@@ -1086,3 +1129,89 @@ function validateFragmentProps(fragment) {
     }
   }
 }
+
+function coerceStringRef(mixedRef, owner, type) {
+  if (disableStringRefs) {
+    return mixedRef;
+  }
+
+  let stringRef;
+  if (typeof mixedRef === 'string') {
+    stringRef = mixedRef;
+  } else {
+    if (typeof mixedRef === 'number' || typeof mixedRef === 'boolean') {
+      if (__DEV__) {
+        checkPropStringCoercion(mixedRef, 'ref');
+      }
+      stringRef = '' + mixedRef;
+    } else {
+      return mixedRef;
+    }
+  }
+
+  return stringRefAsCallbackRef.bind(null, stringRef, type, owner);
+}
+
+function stringRefAsCallbackRef(stringRef, type, owner, value) {
+  if (disableStringRefs) {
+    return;
+  }
+  if (!owner) {
+    throw new Error(
+      `Element ref was specified as a string (${stringRef}) but no owner was set. This could happen for one of` +
+        ' the following reasons:\n' +
+        '1. You may be adding a ref to a function component\n' +
+        "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
+        '3. You have multiple copies of React loaded\n' +
+        'See https://react.dev/link/refs-must-have-owner for more information.',
+    );
+  }
+  if (owner.tag !== ClassComponent) {
+    throw new Error(
+      'Function components cannot have string refs. ' +
+        'We recommend using useRef() instead. ' +
+        'Learn more about using refs safely here: ' +
+        'https://react.dev/link/strict-mode-string-ref',
+    );
+  }
+
+  if (__DEV__) {
+    if (
+      // Will already warn with "Function components cannot be given refs"
+      !(typeof type === 'function' && !isReactClass(type))
+    ) {
+      const componentName = getComponentNameFromFiber(owner) || 'Component';
+      if (!didWarnAboutStringRefs[componentName]) {
+        console.error(
+          'Component "%s" contains the string ref "%s". Support for string refs ' +
+            'will be removed in a future major release. We recommend using ' +
+            'useRef() or createRef() instead. ' +
+            'Learn more about using refs safely here: ' +
+            'https://react.dev/link/strict-mode-string-ref',
+          componentName,
+          stringRef,
+        );
+        didWarnAboutStringRefs[componentName] = true;
+      }
+    }
+  }
+
+  const inst = owner.stateNode;
+  if (!inst) {
+    throw new Error(
+      `Missing owner for string ref ${stringRef}. This error is likely caused by a ` +
+        'bug in React. Please file an issue.',
+    );
+  }
+
+  const refs = inst.refs;
+  if (value === null) {
+    delete refs[stringRef];
+  } else {
+    refs[stringRef] = value;
+  }
+}
+
+function isReactClass(type) {
+  return type.prototype && type.prototype.isReactComponent;
+}

commit f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Apr 5 12:48:52 2024 -0400

    Track Owner for Server Components in DEV (#28753)
    
    This implements the concept of a DEV-only "owner" for Server Components.
    The owner concept isn't really super useful. We barely use it anymore,
    but we do have it as a concept in DevTools in a couple of cases so this
    adds it for parity. However, this is mainly interesting because it could
    be used to wire up future owner-based stacks.
    
    I do this by outlining the DebugInfo for a Server Component
    (ReactComponentInfo). Then I just rely on Flight deduping to refer to
    that. I refer to the same thing by referential equality so that we can
    associate a Server Component parent in DebugInfo with an owner.
    
    If you suspend and replay a Server Component, we have to restore the
    same owner. To do that, I did a little ugly hack and stashed it on the
    thenable state object. Felt unnecessarily complicated to add a stateful
    wrapper for this one dev-only case.
    
    The owner could really be anything since it could be coming from a
    different implementation. Because this is the first time we have an
    owner other than Fiber, I have to fix up a bunch of places that assumes
    Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
    Fiber for now.
    
    This also doesn't actually add it to DevTools / RN Inspector yet. I just
    ignore them there for now.
    
    Because Server Components can be async the owner isn't tracked after an
    await. We need per-component AsyncLocalStorage for that. This can be
    done in a follow up.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 6727626b4e..d52355b184 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -1051,13 +1051,17 @@ function validateExplicitKey(element, parentType) {
     let childOwner = '';
     if (
       element &&
-      element._owner &&
+      element._owner != null &&
       element._owner !== ReactCurrentOwner.current
     ) {
+      let ownerName = null;
+      if (typeof element._owner.tag === 'number') {
+        ownerName = getComponentNameFromType(element._owner.type);
+      } else if (typeof element._owner.name === 'string') {
+        ownerName = element._owner.name;
+      }
       // Give the component that originally created this child.
-      childOwner = ` It was passed a child from ${getComponentNameFromType(
-        element._owner.type,
-      )}.`;
+      childOwner = ` It was passed a child from ${ownerName}.`;
     }
 
     setCurrentlyValidatingElement(element);

commit d1547defe34cee6326a61059148afc83228d8ecf
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 5 13:25:24 2024 -0400

    Fast JSX: Don't clone props object (#28768)
    
    (Unless "key" is spread onto the element.)
    
    Historically, the JSX runtime clones the props object that is passed in.
    We've done this for two reasons.
    
    One reason is that there are certain prop names that are reserved by
    React, like `key` and (before React 19) `ref`. These are not actual
    props and are not observable by the target component; React uses them
    internally but removes them from the props object before passing them to
    userspace.
    
    The second reason is that the classic JSX runtime, `createElement`, is
    both a compiler target _and_ a public API that can be called manually.
    Therefore, we can't assume that the props object that is passed into
    `createElement` won't be mutated by userspace code after it is passed
    in.
    
    However, the new JSX runtime, `jsx`, is not a public API — it's solely a
    compiler target, and the compiler _will_ always pass a fresh, inline
    object. So the only reason to clone the props is if a reserved prop name
    is used.
    
    In React 19, `ref` is no longer a reserved prop name, and `key` will
    only appear in the props object if it is spread onto the element.
    (Because if `key` is statically defined, the compiler will pass it as a
    separate argument to the `jsx` function.) So the only remaining reason
    to clone the props object is if `key` is spread onto the element, which
    is a rare case, and also triggers a warning in development.
    
    In a future release, we will not remove a spread key from the props
    object. (But we'll still warn.) We'll always pass the object straight
    through.
    
    The expected impact is much faster JSX element creation, which in many
    apps is a significant slice of the overall runtime cost of rendering.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index d52355b184..03e46d6d95 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -314,11 +314,6 @@ function ReactElement(type, key, _ref, self, source, owner, props) {
  * @param {string} key
  */
 export function jsxProd(type, config, maybeKey) {
-  let propName;
-
-  // Reserved names are extracted
-  const props = {};
-
   let key = null;
   let ref = null;
 
@@ -351,22 +346,39 @@ export function jsxProd(type, config, maybeKey) {
     }
   }
 
-  // Remaining properties are added to a new props object
-  for (propName in config) {
-    if (
-      hasOwnProperty.call(config, propName) &&
-      // Skip over reserved prop names
-      propName !== 'key' &&
-      (enableRefAsProp || propName !== 'ref')
-    ) {
-      if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
-        props.ref = coerceStringRef(
-          config[propName],
-          ReactCurrentOwner.current,
-          type,
-        );
-      } else {
-        props[propName] = config[propName];
+  let props;
+  if (enableRefAsProp && disableStringRefs && !('key' in config)) {
+    // If key was not spread in, we can reuse the original props object. This
+    // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+    // target and the compiler always passes a new object. For `createElement`,
+    // we can't assume a new object is passed every time because it can be
+    // called manually.
+    //
+    // Spreading key is a warning in dev. In a future release, we will not
+    // remove a spread key from the props object. (But we'll still warn.) We'll
+    // always pass the object straight through.
+    props = config;
+  } else {
+    // We need to remove reserved props (key, prop, ref). Create a fresh props
+    // object and copy over all the non-reserved props. We don't use `delete`
+    // because in V8 it will deopt the object to dictionary mode.
+    props = {};
+    for (const propName in config) {
+      if (
+        hasOwnProperty.call(config, propName) &&
+        // Skip over reserved prop names
+        propName !== 'key' &&
+        (enableRefAsProp || propName !== 'ref')
+      ) {
+        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+          props.ref = coerceStringRef(
+            config[propName],
+            ReactCurrentOwner.current,
+            type,
+          );
+        } else {
+          props[propName] = config[propName];
+        }
       }
     }
   }
@@ -375,7 +387,7 @@ export function jsxProd(type, config, maybeKey) {
     // Resolve default props
     if (type && type.defaultProps) {
       const defaultProps = type.defaultProps;
-      for (propName in defaultProps) {
+      for (const propName in defaultProps) {
         if (props[propName] === undefined) {
           props[propName] = defaultProps[propName];
         }
@@ -538,11 +550,6 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       }
     }
 
-    let propName;
-
-    // Reserved names are extracted
-    const props = {};
-
     let key = null;
     let ref = null;
 
@@ -578,22 +585,39 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       }
     }
 
-    // Remaining properties are added to a new props object
-    for (propName in config) {
-      if (
-        hasOwnProperty.call(config, propName) &&
-        // Skip over reserved prop names
-        propName !== 'key' &&
-        (enableRefAsProp || propName !== 'ref')
-      ) {
-        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
-          props.ref = coerceStringRef(
-            config[propName],
-            ReactCurrentOwner.current,
-            type,
-          );
-        } else {
-          props[propName] = config[propName];
+    let props;
+    if (enableRefAsProp && disableStringRefs && !('key' in config)) {
+      // If key was not spread in, we can reuse the original props object. This
+      // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+      // target and the compiler always passes a new object. For `createElement`,
+      // we can't assume a new object is passed every time because it can be
+      // called manually.
+      //
+      // Spreading key is a warning in dev. In a future release, we will not
+      // remove a spread key from the props object. (But we'll still warn.) We'll
+      // always pass the object straight through.
+      props = config;
+    } else {
+      // We need to remove reserved props (key, prop, ref). Create a fresh props
+      // object and copy over all the non-reserved props. We don't use `delete`
+      // because in V8 it will deopt the object to dictionary mode.
+      props = {};
+      for (const propName in config) {
+        if (
+          hasOwnProperty.call(config, propName) &&
+          // Skip over reserved prop names
+          propName !== 'key' &&
+          (enableRefAsProp || propName !== 'ref')
+        ) {
+          if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+            props.ref = coerceStringRef(
+              config[propName],
+              ReactCurrentOwner.current,
+              type,
+            );
+          } else {
+            props[propName] = config[propName];
+          }
         }
       }
     }
@@ -602,7 +626,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       // Resolve default props
       if (type && type.defaultProps) {
         const defaultProps = type.defaultProps;
-        for (propName in defaultProps) {
+        for (const propName in defaultProps) {
           if (props[propName] === undefined) {
             props[propName] = defaultProps[propName];
           }

commit 0b3b8a6a354b90fe76a9d82bb34487e5d2f71203
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Apr 8 11:12:40 2024 -0400

    jsx: Remove unnecessary hasOwnProperty check (#28775)
    
    Follow up to #28768.
    
    The modern JSX runtime (`jsx`) does not need to check if each prop is a
    direct property with `hasOwnProperty` because the compiler always passes
    a plain object.
    
    I'll leave the check in the old JSX runtime (`createElement`) since that
    one can be called manually with any kind of object, and if there were
    old user code that relied on this for some reason, it would be using
    that runtime.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 03e46d6d95..bca50c2540 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -364,12 +364,8 @@ export function jsxProd(type, config, maybeKey) {
     // because in V8 it will deopt the object to dictionary mode.
     props = {};
     for (const propName in config) {
-      if (
-        hasOwnProperty.call(config, propName) &&
-        // Skip over reserved prop names
-        propName !== 'key' &&
-        (enableRefAsProp || propName !== 'ref')
-      ) {
+      // Skip over reserved prop names
+      if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
         if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
           props.ref = coerceStringRef(
             config[propName],
@@ -603,12 +599,8 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       // because in V8 it will deopt the object to dictionary mode.
       props = {};
       for (const propName in config) {
-        if (
-          hasOwnProperty.call(config, propName) &&
-          // Skip over reserved prop names
-          propName !== 'key' &&
-          (enableRefAsProp || propName !== 'ref')
-        ) {
+        // Skip over reserved prop names
+        if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
           if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
             props.ref = coerceStringRef(
               config[propName],

commit d50323eb845c5fde0d720cae888bf35dedd05506
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Apr 8 19:23:23 2024 -0400

    Flatten ReactSharedInternals (#28783)
    
    This is similar to #28771 but for isomorphic. We need a make over for
    these dispatchers anyway so this is the first step. Also helps flush out
    some internals usage that will break anyway.
    
    It flattens the inner mutable objects onto the ReactSharedInternals.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index bca50c2540..b429db3326 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -27,9 +27,6 @@ import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
 import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
 import getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';
 
-const ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
-const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
-
 const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 
 let specialPropKeyWarningShown;
@@ -71,12 +68,12 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
     if (
       !disableStringRefs &&
       typeof config.ref === 'string' &&
-      ReactCurrentOwner.current &&
+      ReactSharedInternals.owner &&
       self &&
-      ReactCurrentOwner.current.stateNode !== self
+      ReactSharedInternals.owner.stateNode !== self
     ) {
       const componentName = getComponentNameFromType(
-        ReactCurrentOwner.current.type,
+        ReactSharedInternals.owner.type,
       );
 
       if (!didWarnAboutStringRefs[componentName]) {
@@ -87,7 +84,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
             'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
             'Learn more about using refs safely here: ' +
             'https://react.dev/link/strict-mode-string-ref',
-          getComponentNameFromType(ReactCurrentOwner.current.type),
+          getComponentNameFromType(ReactSharedInternals.owner.type),
           config.ref,
         );
         didWarnAboutStringRefs[componentName] = true;
@@ -341,7 +338,7 @@ export function jsxProd(type, config, maybeKey) {
     if (!enableRefAsProp) {
       ref = config.ref;
       if (!disableStringRefs) {
-        ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+        ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
       }
     }
   }
@@ -369,7 +366,7 @@ export function jsxProd(type, config, maybeKey) {
         if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
           props.ref = coerceStringRef(
             config[propName],
-            ReactCurrentOwner.current,
+            ReactSharedInternals.owner,
             type,
           );
         } else {
@@ -397,7 +394,7 @@ export function jsxProd(type, config, maybeKey) {
     ref,
     undefined,
     undefined,
-    ReactCurrentOwner.current,
+    ReactSharedInternals.owner,
     props,
   );
 }
@@ -573,7 +570,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       if (!enableRefAsProp) {
         ref = config.ref;
         if (!disableStringRefs) {
-          ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+          ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
         }
       }
       if (!disableStringRefs) {
@@ -604,7 +601,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
           if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
             props.ref = coerceStringRef(
               config[propName],
-              ReactCurrentOwner.current,
+              ReactSharedInternals.owner,
               type,
             );
           } else {
@@ -645,7 +642,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       ref,
       self,
       source,
-      ReactCurrentOwner.current,
+      ReactSharedInternals.owner,
       props,
     );
 
@@ -729,7 +726,7 @@ export function createElement(type, config, children) {
       if (!enableRefAsProp) {
         ref = config.ref;
         if (!disableStringRefs) {
-          ref = coerceStringRef(ref, ReactCurrentOwner.current, type);
+          ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
         }
       }
 
@@ -761,7 +758,7 @@ export function createElement(type, config, children) {
         if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
           props.ref = coerceStringRef(
             config[propName],
-            ReactCurrentOwner.current,
+            ReactSharedInternals.owner,
             type,
           );
         } else {
@@ -819,7 +816,7 @@ export function createElement(type, config, children) {
     ref,
     undefined,
     undefined,
-    ReactCurrentOwner.current,
+    ReactSharedInternals.owner,
     props,
   );
 
@@ -876,7 +873,7 @@ export function cloneElement(element, config, children) {
           ref = coerceStringRef(ref, owner, element.type);
         }
       }
-      owner = ReactCurrentOwner.current;
+      owner = ReactSharedInternals.owner;
     }
     if (hasValidKey(config)) {
       if (__DEV__) {
@@ -963,8 +960,8 @@ export function cloneElement(element, config, children) {
 
 function getDeclarationErrorAddendum() {
   if (__DEV__) {
-    if (ReactCurrentOwner.current) {
-      const name = getComponentNameFromType(ReactCurrentOwner.current.type);
+    if (ReactSharedInternals.owner) {
+      const name = getComponentNameFromType(ReactSharedInternals.owner.type);
       if (name) {
         return '\n\nCheck the render method of `' + name + '`.';
       }
@@ -1068,7 +1065,7 @@ function validateExplicitKey(element, parentType) {
     if (
       element &&
       element._owner != null &&
-      element._owner !== ReactCurrentOwner.current
+      element._owner !== ReactSharedInternals.owner
     ) {
       let ownerName = null;
       if (typeof element._owner.tag === 'number') {
@@ -1099,9 +1096,9 @@ function setCurrentlyValidatingElement(element) {
         element.type,
         owner ? owner.type : null,
       );
-      ReactDebugCurrentFrame.setExtraStackFrame(stack);
+      ReactSharedInternals.setExtraStackFrame(stack);
     } else {
-      ReactDebugCurrentFrame.setExtraStackFrame(null);
+      ReactSharedInternals.setExtraStackFrame(null);
     }
   }
 }

commit 7f5d25e23e82adef262493794010385f1955f0b6
Author: Joseph Savona <joesavona@fb.com>
Date:   Tue Apr 9 13:43:49 2024 -0700

    Fix cloneElement using string ref w no owner (#28797)
    
    Fix for an issue introduced in #28473 where cloneElement() with a string
    ref fails due to lack of an owner. We should use the current owner in
    this case.
    
    ---------
    
    Co-authored-by: Rick Hanlon <rickhanlonii@fb.com>

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index b429db3326..d7b70e0f39 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -866,6 +866,7 @@ export function cloneElement(element, config, children) {
 
   if (config != null) {
     if (hasValidRef(config)) {
+      owner = ReactSharedInternals.owner;
       if (!enableRefAsProp) {
         // Silently steal the ref from the parent.
         ref = config.ref;
@@ -873,7 +874,6 @@ export function cloneElement(element, config, children) {
           ref = coerceStringRef(ref, owner, element.type);
         }
       }
-      owner = ReactSharedInternals.owner;
     }
     if (hasValidKey(config)) {
       if (__DEV__) {

commit ed3c65caf042f75fe2fdc2a5e568a9624c6175fb
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 9 17:13:19 2024 -0400

    Warn if outdated JSX transform is detected (#28781)
    
    We want to warn if we detect that an app is using an outdated JSX
    transform. We can't just warn if `createElement` is called because we
    still support `createElement` when it's called manually. We only want to
    warn if `createElement` is output by the compiler.
    
    The heuristic is to check for a `__self` prop, which is an optional,
    internal prop that older transforms used to pass to `createElement` for
    better debugging in development mode.
    
    If `__self` is present, we `console.warn` once with advice to upgrade to
    the modern JSX transform. Subsequent elements will not warn.
    
    There's a special case we have to account for: when a static "key" prop
    is defined _after_ a spread, the modern JSX transform outputs
    `createElement` instead of `jsx`. (This is because with `jsx`, a spread
    key always takes precedence over a static key, regardless of the order,
    whereas `createElement` respects the order.) To avoid a false positive
    warning, we skip the warning whenever a `key` prop is present.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index d7b70e0f39..2b9955fcc5 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -33,6 +33,7 @@ let specialPropKeyWarningShown;
 let specialPropRefWarningShown;
 let didWarnAboutStringRefs;
 let didWarnAboutElementRef;
+let didWarnAboutOldJSXRuntime;
 
 if (__DEV__) {
   didWarnAboutStringRefs = {};
@@ -722,6 +723,28 @@ export function createElement(type, config, children) {
   let ref = null;
 
   if (config != null) {
+    if (__DEV__) {
+      if (
+        !didWarnAboutOldJSXRuntime &&
+        '__self' in config &&
+        // Do not assume this is the result of an oudated JSX transform if key
+        // is present, because the modern JSX transform sometimes outputs
+        // createElement to preserve precedence between a static key and a
+        // spread key. To avoid false positive warnings, we never warn if
+        // there's a key.
+        !('key' in config)
+      ) {
+        didWarnAboutOldJSXRuntime = true;
+        console.warn(
+          'Your app (or one of its dependencies) is using an outdated JSX ' +
+            'transform. Update to the modern JSX transform for ' +
+            'faster performance: ' +
+            // TODO: Create a short link for this
+            'https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html',
+        );
+      }
+    }
+
     if (hasValidRef(config)) {
       if (!enableRefAsProp) {
         ref = config.ref;

commit 435415962371adc69e6a7211f7c65a5d72fc609c
Author: Jack Pope <jackpope1@gmail.com>
Date:   Thu Apr 11 15:30:37 2024 -0400

    Backwards compatibility for string refs on WWW (#28826)
    
    Seeing errors with undefined string ref values when trying to sync
    https://github.com/facebook/react/pull/28473
    
    Added a test that reproduces the failing pattern.
    
    @acdlite pushed
    https://github.com/facebook/react/pull/28826/commits/a786481ae5702f1966ecdb62f3667f3d72966e78
    with fix
    
    ---------
    
    Co-authored-by: Jack Pope <jackpope@meta.com>
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 2b9955fcc5..48feb83cdd 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -1189,7 +1189,15 @@ function coerceStringRef(mixedRef, owner, type) {
     }
   }
 
-  return stringRefAsCallbackRef.bind(null, stringRef, type, owner);
+  const callback = stringRefAsCallbackRef.bind(null, stringRef, type, owner);
+  // This is used to check whether two callback refs conceptually represent
+  // the same string ref, and can therefore be reused by the reconciler. Needed
+  // for backwards compatibility with old Meta code that relies on string refs
+  // not being reattached on every render.
+  callback.__stringRef = stringRef;
+  callback.__type = type;
+  callback.__owner = owner;
+  return callback;
 }
 
 function stringRefAsCallbackRef(stringRef, type, owner, value) {

commit 368202181e772d411b2445930aea1edd9428b09b
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sun Apr 21 12:51:45 2024 -0400

    Warn for Child Iterator of all types but allow Generator Components (#28853)
    
    This doesn't change production behavior. We always render Iterables to
    our best effort in prod even if they're Iterators.
    
    But this does change the DEV warnings which indicates which are valid
    patterns to use.
    
    It's a footgun to use an Iterator as a prop when you pass between
    components because if an intermediate component rerenders without its
    parent, React won't be able to iterate it again to reconcile and any
    mappers won't be able to re-apply. This is actually typically not a
    problem when passed only to React host components but as a pattern it's
    a problem for composability.
    
    We used to warn only for Generators - i.e. Iterators returned from
    Generator functions. This adds a warning for Iterators created by other
    means too (e.g. Flight or the native Iterator utils). The heuristic is
    to check whether the Iterator is the same as the Iterable because that
    means it's not possible to get new iterators out of it. This case used
    to just yield non-sense like empty sets in DEV but not in prod.
    
    However, a new realization is that when the Component itself is a
    Generator Function, it's not actually a problem. That's because the
    React Element itself works as an Iterable since we can ask for new
    generators by calling the function again. So this adds a special case to
    allow the Generator returned from a Generator Function's direct child.
    The principle is “don’t pass iterators around” but in this case there is
    no iterator floating around because it’s between React and the JS VM.
    
    Also see #28849 for context on AsyncIterables.
    
    Related to this, but Hooks should ideally be banned in these for the
    same reason they're banned in Async Functions.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 48feb83cdd..36185639e6 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -1028,10 +1028,12 @@ function validateChildKeys(node, parentType) {
         // but now we print a separate warning for them later.
         if (iteratorFn !== node.entries) {
           const iterator = iteratorFn.call(node);
-          let step;
-          while (!(step = iterator.next()).done) {
-            if (isValidElement(step.value)) {
-              validateExplicitKey(step.value, parentType);
+          if (iterator !== node) {
+            let step;
+            while (!(step = iterator.next()).done) {
+              if (isValidElement(step.value)) {
+                validateExplicitKey(step.value, parentType);
+              }
             }
           }
         }

commit 3b551c82844bcfde51f0febb8e42c1a0d777df2c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Apr 22 12:39:56 2024 -0400

    Rename the react.element symbol to react.transitional.element (#28813)
    
    We have changed the shape (and the runtime) of React Elements. To help
    avoid precompiled or inlined JSX having subtle breakages or deopting
    hidden classes, I renamed the symbol so that we can early error if
    private implementation details are used or mismatching versions are
    used.
    
    Why "transitional"? Well, because this is not the last time we'll change
    the shape. This is just a stepping stone to removing the `ref` field on
    the elements in the next version so we'll likely have to do it again.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 36185639e6..9fea14ae5c 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -162,7 +162,7 @@ function elementRefGetterWithDeprecationWarning() {
 /**
  * Factory method to create a new React element. This no longer adheres to
  * the class pattern, so do not use new to call it. Also, instanceof check
- * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
  * if something is a React Element.
  *
  * @param {*} type

commit 6f6e375fce9d0700434f863f70f0e2e5ea180426
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 24 09:32:11 2024 -0400

    Create short link for jsx warning (#28899)
    
    Short link created in https://github.com/reactjs/react.dev/pull/6772

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 9fea14ae5c..81f5048920 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -738,9 +738,7 @@ export function createElement(type, config, children) {
         console.warn(
           'Your app (or one of its dependencies) is using an outdated JSX ' +
             'transform. Update to the modern JSX transform for ' +
-            'faster performance: ' +
-            // TODO: Create a short link for this
-            'https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html',
+            'faster performance: https://react.dev/link/new-jsx-transform',
         );
       }
     }

commit 94eed63c49d989861ae7cd62e111de6d717f0a10
Author: Josh Story <story@hey.com>
Date:   Thu Apr 25 10:40:40 2024 -0700

    (Land #28798) Move Current Owner (and Cache) to an Async Dispatcher (#28912)
    
    Rebasing and landing https://github.com/facebook/react/pull/28798
    
    This PR was approved already but held back to give time for the sync.
    Rebased and landing here without pushing to seb's remote to avoid
    possibility of lost updates
    
    ---------
    
    Co-authored-by: Sebastian Markbage <sebastian@calyptus.eu>

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 81f5048920..d8452a2e36 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -29,6 +29,17 @@ import getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFrom
 
 const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 
+function getOwner() {
+  if (__DEV__ || !disableStringRefs) {
+    const dispatcher = ReactSharedInternals.A;
+    if (dispatcher === null) {
+      return null;
+    }
+    return dispatcher.getOwner();
+  }
+  return null;
+}
+
 let specialPropKeyWarningShown;
 let specialPropRefWarningShown;
 let didWarnAboutStringRefs;
@@ -66,16 +77,15 @@ function hasValidKey(config) {
 
 function warnIfStringRefCannotBeAutoConverted(config, self) {
   if (__DEV__) {
+    let owner;
     if (
       !disableStringRefs &&
       typeof config.ref === 'string' &&
-      ReactSharedInternals.owner &&
+      (owner = getOwner()) &&
       self &&
-      ReactSharedInternals.owner.stateNode !== self
+      owner.stateNode !== self
     ) {
-      const componentName = getComponentNameFromType(
-        ReactSharedInternals.owner.type,
-      );
+      const componentName = getComponentNameFromType(owner.type);
 
       if (!didWarnAboutStringRefs[componentName]) {
         console.error(
@@ -85,7 +95,7 @@ function warnIfStringRefCannotBeAutoConverted(config, self) {
             'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
             'Learn more about using refs safely here: ' +
             'https://react.dev/link/strict-mode-string-ref',
-          getComponentNameFromType(ReactSharedInternals.owner.type),
+          getComponentNameFromType(owner.type),
           config.ref,
         );
         didWarnAboutStringRefs[componentName] = true;
@@ -339,7 +349,7 @@ export function jsxProd(type, config, maybeKey) {
     if (!enableRefAsProp) {
       ref = config.ref;
       if (!disableStringRefs) {
-        ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
+        ref = coerceStringRef(ref, getOwner(), type);
       }
     }
   }
@@ -365,11 +375,7 @@ export function jsxProd(type, config, maybeKey) {
       // Skip over reserved prop names
       if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
         if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
-          props.ref = coerceStringRef(
-            config[propName],
-            ReactSharedInternals.owner,
-            type,
-          );
+          props.ref = coerceStringRef(config[propName], getOwner(), type);
         } else {
           props[propName] = config[propName];
         }
@@ -389,15 +395,7 @@ export function jsxProd(type, config, maybeKey) {
     }
   }
 
-  return ReactElement(
-    type,
-    key,
-    ref,
-    undefined,
-    undefined,
-    ReactSharedInternals.owner,
-    props,
-  );
+  return ReactElement(type, key, ref, undefined, undefined, getOwner(), props);
 }
 
 // While `jsxDEV` should never be called when running in production, we do
@@ -571,7 +569,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       if (!enableRefAsProp) {
         ref = config.ref;
         if (!disableStringRefs) {
-          ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
+          ref = coerceStringRef(ref, getOwner(), type);
         }
       }
       if (!disableStringRefs) {
@@ -600,11 +598,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
         // Skip over reserved prop names
         if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
           if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
-            props.ref = coerceStringRef(
-              config[propName],
-              ReactSharedInternals.owner,
-              type,
-            );
+            props.ref = coerceStringRef(config[propName], getOwner(), type);
           } else {
             props[propName] = config[propName];
           }
@@ -643,7 +637,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       ref,
       self,
       source,
-      ReactSharedInternals.owner,
+      getOwner(),
       props,
     );
 
@@ -747,7 +741,7 @@ export function createElement(type, config, children) {
       if (!enableRefAsProp) {
         ref = config.ref;
         if (!disableStringRefs) {
-          ref = coerceStringRef(ref, ReactSharedInternals.owner, type);
+          ref = coerceStringRef(ref, getOwner(), type);
         }
       }
 
@@ -777,11 +771,7 @@ export function createElement(type, config, children) {
         propName !== '__source'
       ) {
         if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
-          props.ref = coerceStringRef(
-            config[propName],
-            ReactSharedInternals.owner,
-            type,
-          );
+          props.ref = coerceStringRef(config[propName], getOwner(), type);
         } else {
           props[propName] = config[propName];
         }
@@ -837,7 +827,7 @@ export function createElement(type, config, children) {
     ref,
     undefined,
     undefined,
-    ReactSharedInternals.owner,
+    getOwner(),
     props,
   );
 
@@ -887,7 +877,7 @@ export function cloneElement(element, config, children) {
 
   if (config != null) {
     if (hasValidRef(config)) {
-      owner = ReactSharedInternals.owner;
+      owner = __DEV__ || !disableStringRefs ? getOwner() : undefined;
       if (!enableRefAsProp) {
         // Silently steal the ref from the parent.
         ref = config.ref;
@@ -981,8 +971,9 @@ export function cloneElement(element, config, children) {
 
 function getDeclarationErrorAddendum() {
   if (__DEV__) {
-    if (ReactSharedInternals.owner) {
-      const name = getComponentNameFromType(ReactSharedInternals.owner.type);
+    const owner = getOwner();
+    if (owner) {
+      const name = getComponentNameFromType(owner.type);
       if (name) {
         return '\n\nCheck the render method of `' + name + '`.';
       }
@@ -1085,11 +1076,7 @@ function validateExplicitKey(element, parentType) {
     // property, it may be the creator of the child that's responsible for
     // assigning it a key.
     let childOwner = '';
-    if (
-      element &&
-      element._owner != null &&
-      element._owner !== ReactSharedInternals.owner
-    ) {
+    if (element && element._owner != null && element._owner !== getOwner()) {
       let ownerName = null;
       if (typeof element._owner.tag === 'number') {
         ownerName = getComponentNameFromType(element._owner.type);

commit 1beb73de0f7c3261a0de37620453b102caaa6236
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri May 3 10:47:13 2024 -0400

    Add flag to test fast jsx (#28816)
    
    Following #28768, add a path to testing Fast JSX on www.
    
    We want to measure the impact of Fast JSX and enable a path to testing
    before string refs are completely removed in www (which is a work in
    progress).
    
    Without `disableStringRefs`, we need to copy any object with a `ref` key
    so we can pass it through `coerceStringRef()` and copy it into the
    object. This de-opt path is what is gated behind
    `enableFastJSXWithStringRefs`.
    
    The additional checks should have no perf impact in OSS as the flags
    remain true there and the build output is not changed. For www, I've
    benchmarked the addition of the boolean checks with values cached at
    module scope. There is no significant change observed from our
    benchmarks and any latency will apply to test and control branches
    evenly. This added experiment complexity is temporary. We should be able
    to clean it up, along with the flag checks for `enableRefAsProp` and
    `disableStringRefs` shortly.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index d8452a2e36..fad4d42bcc 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -22,6 +22,7 @@ import {
   enableRefAsProp,
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
+  enableFastJSX,
 } from 'shared/ReactFeatureFlags';
 import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
 import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
@@ -51,6 +52,10 @@ if (__DEV__) {
   didWarnAboutElementRef = {};
 }
 
+const enableFastJSXWithStringRefs = enableFastJSX && enableRefAsProp;
+const enableFastJSXWithoutStringRefs =
+  enableFastJSXWithStringRefs && disableStringRefs;
+
 function hasValidRef(config) {
   if (__DEV__) {
     if (hasOwnProperty.call(config, 'ref')) {
@@ -355,7 +360,11 @@ export function jsxProd(type, config, maybeKey) {
   }
 
   let props;
-  if (enableRefAsProp && disableStringRefs && !('key' in config)) {
+  if (
+    (enableFastJSXWithoutStringRefs ||
+      (enableFastJSXWithStringRefs && !('ref' in config))) &&
+    !('key' in config)
+  ) {
     // If key was not spread in, we can reuse the original props object. This
     // only works for `jsx`, not `createElement`, because `jsx` is a compiler
     // target and the compiler always passes a new object. For `createElement`,
@@ -578,7 +587,11 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
     }
 
     let props;
-    if (enableRefAsProp && disableStringRefs && !('key' in config)) {
+    if (
+      (enableFastJSXWithoutStringRefs ||
+        (enableFastJSXWithStringRefs && !('ref' in config))) &&
+      !('key' in config)
+    ) {
       // If key was not spread in, we can reuse the original props object. This
       // only works for `jsx`, not `createElement`, because `jsx` is a compiler
       // target and the compiler always passes a new object. For `createElement`,

commit 151cce37401dc2ff609701119d61a17d92fce4ab
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu May 9 12:23:05 2024 -0400

    Track Stack of JSX Calls (#29032)
    
    This is the first step to experimenting with a new type of stack traces
    behind the `enableOwnerStacks` flag - in DEV only.
    
    The idea is to generate stacks that are more like if the JSX was a
    direct call even though it's actually a lazy call. Not only can you see
    which exact JSX call line number generated the erroring component but if
    that's inside an abstraction function, which function called that
    function and if it's a component, which component generated that
    component. For this to make sense it really need to be the "owner" stack
    rather than the parent stack like we do for other component stacks. On
    one hand it has more precise information but on the other hand it also
    loses context. For most types of problems the owner stack is the most
    useful though since it tells you which component rendered this
    component.
    
    The problem with the platform in its current state is that there's two
    ways to deal with stacks:
    
    1) `new Error().stack`
    2) `console.createTask()`
    
    The nice thing about `new Error().stack` is that we can extract the
    frames and piece them together in whatever way we want. That is great
    for constructing custom UIs like error dialogs. Unfortunately, we can't
    take custom stacks and set them in the native UIs like Chrome DevTools.
    
    The nice thing about `console.createTask()` is that the resulting stacks
    are natively integrated into the Chrome DevTools in the console and the
    breakpoint debugger. They also automatically follow source mapping and
    ignoreLists. The downside is that there's no way to extract the async
    stack outside the native UI itself so this information cannot be used
    for custom UIs like errors dialogs. It also means we can't collect this
    on the server and then pass it to the client for server components.
    
    The solution here is that we use both techniques and collect both an
    `Error` object and a `Task` object for every JSX call.
    
    The main concern about this approach is the performance so that's the
    main thing to test. It's certainly too slow for production but it might
    also be too slow even for DEV.
    
    This first PR doesn't actually use the stacks yet. It just collects them
    as the first step. The next step is to start utilizing this information
    in error printing etc.
    
    For RSC we pass the stack along across over the wire. This can be
    concatenated on the client following the owner path to create an owner
    stack leading back into the server. We'll later use this information to
    restore fake frames on the client for native integration. Since this
    information quickly gets pretty heavy if we include all frames, we strip
    out the top frame. We also strip out everything below the functions that
    call into user space in the Flight runtime. To do this we need to figure
    out the frames that represents calling out into user space. The
    resulting stack is typically just the one frame inside the owner
    component's JSX callsite. I also eagerly strip out things we expect to
    be ignoreList:ed anyway - such as `node_modules` and Node.js internals.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index fad4d42bcc..f799fd7b16 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -13,6 +13,7 @@ import {
   getIteratorFn,
   REACT_ELEMENT_TYPE,
   REACT_FRAGMENT_TYPE,
+  REACT_LAZY_TYPE,
 } from 'shared/ReactSymbols';
 import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 import isValidElementType from 'shared/isValidElementType';
@@ -23,6 +24,7 @@ import {
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
   enableFastJSX,
+  enableOwnerStacks,
 } from 'shared/ReactFeatureFlags';
 import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
 import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
@@ -30,6 +32,34 @@ import getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFrom
 
 const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 
+const createTask =
+  // eslint-disable-next-line react-internal/no-production-logging
+  __DEV__ && enableOwnerStacks && console.createTask
+    ? // eslint-disable-next-line react-internal/no-production-logging
+      console.createTask
+    : () => null;
+
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (
+    typeof type === 'object' &&
+    type !== null &&
+    type.$$typeof === REACT_LAZY_TYPE
+  ) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    const name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+
 function getOwner() {
   if (__DEV__ || !disableStringRefs) {
     const dispatcher = ReactSharedInternals.A;
@@ -194,7 +224,17 @@ function elementRefGetterWithDeprecationWarning() {
  * indicating filename, line number, and/or other information.
  * @internal
  */
-function ReactElement(type, key, _ref, self, source, owner, props) {
+function ReactElement(
+  type,
+  key,
+  _ref,
+  self,
+  source,
+  owner,
+  props,
+  debugStack,
+  debugTask,
+) {
   let ref;
   if (enableRefAsProp) {
     // When enableRefAsProp is on, ignore whatever was passed as the ref
@@ -311,6 +351,20 @@ function ReactElement(type, key, _ref, self, source, owner, props) {
       writable: true,
       value: null,
     });
+    if (enableOwnerStacks) {
+      Object.defineProperty(element, '_debugStack', {
+        configurable: false,
+        enumerable: false,
+        writable: true,
+        value: debugStack,
+      });
+      Object.defineProperty(element, '_debugTask', {
+        configurable: false,
+        enumerable: false,
+        writable: true,
+        value: debugTask,
+      });
+    }
     if (Object.freeze) {
       Object.freeze(element.props);
       Object.freeze(element);
@@ -404,7 +458,17 @@ export function jsxProd(type, config, maybeKey) {
     }
   }
 
-  return ReactElement(type, key, ref, undefined, undefined, getOwner(), props);
+  return ReactElement(
+    type,
+    key,
+    ref,
+    undefined,
+    undefined,
+    getOwner(),
+    props,
+    undefined,
+    undefined,
+  );
 }
 
 // While `jsxDEV` should never be called when running in production, we do
@@ -652,6 +716,8 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       source,
       getOwner(),
       props,
+      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
+      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
     );
 
     if (type === REACT_FRAGMENT_TYPE) {
@@ -842,6 +908,8 @@ export function createElement(type, config, children) {
     undefined,
     getOwner(),
     props,
+    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
+    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
   );
 
   if (type === REACT_FRAGMENT_TYPE) {
@@ -862,6 +930,8 @@ export function cloneAndReplaceKey(oldElement, newKey) {
     undefined,
     !__DEV__ && disableStringRefs ? undefined : oldElement._owner,
     oldElement.props,
+    __DEV__ && enableOwnerStacks ? oldElement._debugStack : undefined,
+    __DEV__ && enableOwnerStacks ? oldElement._debugTask : undefined,
   );
 }
 
@@ -973,6 +1043,8 @@ export function cloneElement(element, config, children) {
     undefined,
     owner,
     props,
+    __DEV__ && enableOwnerStacks ? element._debugStack : undefined,
+    __DEV__ && enableOwnerStacks ? element._debugTask : undefined,
   );
 
   for (let i = 2; i < arguments.length; i++) {

commit 84239da896fd7395a667ab1e7ef1ef338a32de8f
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu May 23 12:48:57 2024 -0400

    Move createElement/JSX Warnings into the Renderer (#29088)
    
    This is necessary to simplify the component stack handling to make way
    for owner stacks. It also solves some hacks that we used to have but
    don't quite make sense. It also solves the problem where things like key
    warnings get silenced in RSC because they get deduped. It also surfaces
    areas where we were missing key warnings to begin with.
    
    Almost every type of warning is issued from the renderer. React Elements
    are really not anything special themselves. They're just lazily invoked
    functions and its really the renderer that determines there semantics.
    
    We have three types of warnings that previously fired in
    JSX/createElement:
    
    - Fragment props validation.
    - Type validation.
    - Key warning.
    
    It's nice to be able to do some validation in the JSX/createElement
    because it has a more specific stack frame at the callsite. However,
    that's the case for every type of component and validation. That's the
    whole point of enableOwnerStacks. It's also not sufficient to do it in
    JSX/createElement so we also have validation in the renderers too. So
    this validation is really just an eager validation but also happens
    again later.
    
    The problem with these is that we don't really know what types are valid
    until we get to the renderer. Additionally, by placing it in the
    isomorphic code it becomes harder to do deduping of warnings in a way
    that makes sense for that renderer. It also means we can't reuse logic
    for managing stacks etc.
    
    Fragment props validation really should just be part of the renderer
    like any other component type. This also matters once we add Fragment
    refs and other fragment features. So I moved this into Fiber. However,
    since some Fragments don't have Fibers, I do the validation in
    ChildFiber instead of beginWork where it would normally happen.
    
    For `type` validation we already do validation when rendering. By
    leaving it to the renderer we don't have to hard code an extra list.
    This list also varies by context. E.g. class components aren't allowed
    in RSC but client references are but we don't have an isomorphic way to
    identify client references because they're defined by the host config so
    the current logic is flawed anyway. I kept the early validation for now
    without the `enableOwnerStacks` since it does provide a nicer stack
    frame but with that flag on it'll be handled with nice stacks anyway. I
    normalized some of the errors to ensure tests pass.
    
    For `key` validation it's the same principle. The mechanism for the
    heuristic is still the same - if it passes statically through a parent
    JSX/createElement call then it's considered validated. We already did
    print the error later from the renderer so this also disables the early
    log in the `enableOwnerStacks` flag.
    
    I also added logging to Fizz so that key warnings can print in SSR logs.
    
    Flight is a bit more complex. For elements that end up on the client we
    just pass the `validated` flag along to the client and let the client
    renderer print the error once rendered. For server components we log the
    error from Flight with the server component as the owner on the stack
    which will allow us to print the right stack for context. The factoring
    of this is a little tricky because we only want to warn if it's in an
    array parent but we want to log the error later to get the right debug
    info.
    
    Fiber/Fizz has a similar factoring problem that causes us to create a
    fake Fiber for the owner which means the logs won't be associated with
    the right place in DevTools.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index f799fd7b16..f76a84f899 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -342,7 +342,7 @@ function ReactElement(
       configurable: false,
       enumerable: false,
       writable: true,
-      value: false,
+      value: 0,
     });
     // debugInfo contains Server Component debug information.
     Object.defineProperty(element, '_debugInfo', {
@@ -708,7 +708,7 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       }
     }
 
-    const element = ReactElement(
+    return ReactElement(
       type,
       key,
       ref,
@@ -719,12 +719,6 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
       __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
     );
-
-    if (type === REACT_FRAGMENT_TYPE) {
-      validateFragmentProps(element);
-    }
-
-    return element;
   }
 }
 
@@ -734,7 +728,12 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
  */
 export function createElement(type, config, children) {
   if (__DEV__) {
-    if (!isValidElementType(type)) {
+    if (!enableOwnerStacks && !isValidElementType(type)) {
+      // This is just an optimistic check that provides a better stack trace before
+      // owner stacks. It's really up to the renderer if it's a valid element type.
+      // When owner stacks are enabled, we instead warn in the renderer and it'll
+      // have the stack trace of the JSX element anyway.
+      //
       // This is an invalid element type.
       //
       // We warn in this case but don't throw. We expect the element creation to
@@ -900,7 +899,7 @@ export function createElement(type, config, children) {
     }
   }
 
-  const element = ReactElement(
+  return ReactElement(
     type,
     key,
     ref,
@@ -911,12 +910,6 @@ export function createElement(type, config, children) {
     __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
     __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
   );
-
-  if (type === REACT_FRAGMENT_TYPE) {
-    validateFragmentProps(element);
-  }
-
-  return element;
 }
 
 export function cloneAndReplaceKey(oldElement, newKey) {
@@ -1054,19 +1047,6 @@ export function cloneElement(element, config, children) {
   return clonedElement;
 }
 
-function getDeclarationErrorAddendum() {
-  if (__DEV__) {
-    const owner = getOwner();
-    if (owner) {
-      const name = getComponentNameFromType(owner.type);
-      if (name) {
-        return '\n\nCheck the render method of `' + name + '`.';
-      }
-    }
-    return '';
-  }
-}
-
 /**
  * Ensure that every element either is passed in a static location, in an
  * array with an explicit keys property defined, or in an object literal
@@ -1093,7 +1073,7 @@ function validateChildKeys(node, parentType) {
     } else if (isValidElement(node)) {
       // This element was passed in a valid location.
       if (node._store) {
-        node._store.validated = true;
+        node._store.validated = 1;
       }
     } else {
       const iteratorFn = getIteratorFn(node);
@@ -1145,11 +1125,15 @@ const ownerHasKeyUseWarning = {};
  * @param {*} parentType element's parent's type.
  */
 function validateExplicitKey(element, parentType) {
+  if (enableOwnerStacks) {
+    // Skip. Will verify in renderer instead.
+    return;
+  }
   if (__DEV__) {
     if (!element._store || element._store.validated || element.key != null) {
       return;
     }
-    element._store.validated = true;
+    element._store.validated = 1;
 
     const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
     if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
@@ -1172,36 +1156,40 @@ function validateExplicitKey(element, parentType) {
       childOwner = ` It was passed a child from ${ownerName}.`;
     }
 
-    setCurrentlyValidatingElement(element);
+    const prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
+    ReactSharedInternals.getCurrentStack = function () {
+      const owner = element._owner;
+      // Add an extra top frame while an element is being validated
+      let stack = describeUnknownElementTypeFrameInDEV(
+        element.type,
+        owner ? owner.type : null,
+      );
+      // Delegate to the injected renderer-specific implementation
+      if (prevGetCurrentStack) {
+        stack += prevGetCurrentStack() || '';
+      }
+      return stack;
+    };
     console.error(
       'Each child in a list should have a unique "key" prop.' +
         '%s%s See https://react.dev/link/warning-keys for more information.',
       currentComponentErrorInfo,
       childOwner,
     );
-    setCurrentlyValidatingElement(null);
-  }
-}
-
-function setCurrentlyValidatingElement(element) {
-  if (__DEV__) {
-    if (element) {
-      const owner = element._owner;
-      const stack = describeUnknownElementTypeFrameInDEV(
-        element.type,
-        owner ? owner.type : null,
-      );
-      ReactSharedInternals.setExtraStackFrame(stack);
-    } else {
-      ReactSharedInternals.setExtraStackFrame(null);
-    }
+    ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
   }
 }
 
 function getCurrentComponentErrorInfo(parentType) {
   if (__DEV__) {
-    let info = getDeclarationErrorAddendum();
-
+    let info = '';
+    const owner = getOwner();
+    if (owner) {
+      const name = getComponentNameFromType(owner.type);
+      if (name) {
+        info = '\n\nCheck the render method of `' + name + '`.';
+      }
+    }
     if (!info) {
       const parentName = getComponentNameFromType(parentType);
       if (parentName) {
@@ -1212,36 +1200,6 @@ function getCurrentComponentErrorInfo(parentType) {
   }
 }
 
-/**
- * Given a fragment, validate that it can only be provided with fragment props
- * @param {ReactElement} fragment
- */
-function validateFragmentProps(fragment) {
-  // TODO: Move this to render phase instead of at element creation.
-  if (__DEV__) {
-    const keys = Object.keys(fragment.props);
-    for (let i = 0; i < keys.length; i++) {
-      const key = keys[i];
-      if (key !== 'children' && key !== 'key') {
-        setCurrentlyValidatingElement(fragment);
-        console.error(
-          'Invalid prop `%s` supplied to `React.Fragment`. ' +
-            'React.Fragment can only have `key` and `children` props.',
-          key,
-        );
-        setCurrentlyValidatingElement(null);
-        break;
-      }
-    }
-
-    if (!enableRefAsProp && fragment.ref !== null) {
-      setCurrentlyValidatingElement(fragment);
-      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');
-      setCurrentlyValidatingElement(null);
-    }
-  }
-}
-
 function coerceStringRef(mixedRef, owner, type) {
   if (disableStringRefs) {
     return mixedRef;

commit d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat May 25 11:58:17 2024 -0400

    [Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)
    
    This one should be fully behind the `enableOwnerStacks` flag.
    
    Instead of printing the parent Component stack all the way to the root,
    this now prints the owner stack of every JSX callsite. It also includes
    intermediate callsites between the Component and the JSX call so it has
    potentially more frames. Mainly it provides the line number of the JSX
    callsite. In terms of the number of components is a subset of the parent
    component stack so it's less information in that regard. This is usually
    better since it's more focused on components that might affect the
    output but if it's contextual based on rendering it's still good to have
    parent stack. Therefore, I still use the parent stack when printing DOM
    nesting warnings but I plan on switching that format to a diff view
    format instead (Next.js already reformats the parent stack like this).
    
    __Follow ups__
    
    - Server Components show up in the owner stack for client logs but logs
    done by Server Components don't yet get their owner stack printed as
    they're replayed. They're also not yet printed in the server logs of the
    RSC server.
    
    - Server Component stack frames are formatted as the server and added to
    the end but this might be a different format than the browser. E.g. if
    server is running V8 and browser is running JSC or vice versa. Ideally
    we can reformat them in terms of the client formatting.
    
    - This doesn't yet update Fizz or DevTools. Those will be follow ups.
    Fizz still prints parent stacks in the server side logs. The stacks
    added to user space `console.error` calls by DevTools still get the
    parent stacks instead.
    
    - It also doesn't yet expose these to user space so there's no way to
    get them inside `onCaughtError` for example or inside a custom
    `console.error` override.
    
    - In another follow up I'll use `console.createTask` instead and
    completely remove these stacks if it's available.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index f76a84f899..a5a9880b05 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -492,7 +492,16 @@ export function jsxProdSignatureRunningInDevWithDynamicChildren(
 ) {
   if (__DEV__) {
     const isStaticChildren = false;
-    return jsxDEV(type, config, maybeKey, isStaticChildren, source, self);
+    return jsxDEVImpl(
+      type,
+      config,
+      maybeKey,
+      isStaticChildren,
+      source,
+      self,
+      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
+      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+    );
   }
 }
 
@@ -505,7 +514,16 @@ export function jsxProdSignatureRunningInDevWithStaticChildren(
 ) {
   if (__DEV__) {
     const isStaticChildren = true;
-    return jsxDEV(type, config, maybeKey, isStaticChildren, source, self);
+    return jsxDEVImpl(
+      type,
+      config,
+      maybeKey,
+      isStaticChildren,
+      source,
+      self,
+      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
+      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+    );
   }
 }
 
@@ -518,6 +536,28 @@ const didWarnAboutKeySpread = {};
  * @param {string} key
  */
 export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
+  return jsxDEVImpl(
+    type,
+    config,
+    maybeKey,
+    isStaticChildren,
+    source,
+    self,
+    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
+    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+  );
+}
+
+function jsxDEVImpl(
+  type,
+  config,
+  maybeKey,
+  isStaticChildren,
+  source,
+  self,
+  debugStack,
+  debugTask,
+) {
   if (__DEV__) {
     if (!isValidElementType(type)) {
       // This is an invalid element type.
@@ -716,8 +756,8 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
       source,
       getOwner(),
       props,
-      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
-      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+      debugStack,
+      debugTask,
     );
   }
 }

commit 72644ef2f2ec7a274f79f6b32320d62757521329
Author: Timothy Yung <yungsters@meta.com>
Date:   Thu May 30 07:25:48 2024 -0700

    Fix `key` Warning for Flattened Positional Children (#29662)
    
    ## Summary
    
    https://github.com/facebook/react/pull/29088 introduced a regression
    triggering this warning when rendering flattened positional children:
    
    > Each child in a list should have a unique "key" prop.
    
    The specific scenario that triggers this is when rendering multiple
    positional children (which do not require unique `key` props) after
    flattening them with one of the `React.Children` utilities (e.g.
    `React.Children.toArray`).
    
    The refactored logic in `React.Children` incorrectly drops the
    `element._store.validated` property in `__DEV__`. This diff fixes the
    bug and introduces a unit test to prevent future regressions.
    
    ## How did you test this change?
    
    ```
    $ yarn test ReactChildren-test.js
    ```

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index a5a9880b05..0f8b9f397d 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -953,7 +953,7 @@ export function createElement(type, config, children) {
 }
 
 export function cloneAndReplaceKey(oldElement, newKey) {
-  return ReactElement(
+  const clonedElement = ReactElement(
     oldElement.type,
     newKey,
     // When enableRefAsProp is on, this argument is ignored. This check only
@@ -966,6 +966,11 @@ export function cloneAndReplaceKey(oldElement, newKey) {
     __DEV__ && enableOwnerStacks ? oldElement._debugStack : undefined,
     __DEV__ && enableOwnerStacks ? oldElement._debugTask : undefined,
   );
+  if (__DEV__) {
+    // The cloned element should inherit the original element's key validation.
+    clonedElement._store.validated = oldElement._store.validated;
+  }
+  return clonedElement;
 }
 
 /**

commit e02baf6c92833a0d45a77fb2e741676f393c24f7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Jun 27 18:10:09 2024 +0200

    Warn for invalid type in renderer with the correct RSC stack (#30102)
    
    This is all behind the `enableOwnerStacks` flag.
    
    This is a follow up to #29088. In that I moved type validation into the
    renderer since that's the one that knows what types are allowed.
    However, I only removed it from `React.createElement` and not the JSX
    which was an oversight.
    
    However, I also noticed that for invalid types we don't have the right
    stack trace for throws because we're not yet inside the JSX element that
    itself is invalid. We should use its stack for the stack trace. That's
    the reason it's enough to just use the throw now because we can get a
    good stack trace from the owner stack. This is fixed by creating a fake
    Throw Fiber that gets assigned the right stack.
    
    Additionally, I noticed that for certain invalid types like the most
    common one `undefined` we error in Flight so a missing import in RSC
    leads to a generic error. Instead of erroring on the Flight side we
    should just let anything that's not a Server Component through to the
    client and then let the Client renderer determine whether it's a valid
    type or not. Since we now have owner stacks through the server too, this
    will still be able to provide a good stack trace on the client that
    points to the server in that case.
    
    <img width="571" alt="Screenshot 2024-06-25 at 6 46 35 PM"
    src="https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4">
    
    To get the best stack you have to expand the little icon and the regular
    stack is noisy [due to this Chrome
    bug](https://issues.chromium.org/issues/345248263) which makes it a
    little harder to find but once that's fixed it might be easier.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 0f8b9f397d..1652b1e2ed 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -559,9 +559,14 @@ function jsxDEVImpl(
   debugTask,
 ) {
   if (__DEV__) {
-    if (!isValidElementType(type)) {
+    if (!enableOwnerStacks && !isValidElementType(type)) {
       // This is an invalid element type.
       //
+      // We warn here so that we can get better stack traces but with enableOwnerStacks
+      // enabled we don't need this because we get good stacks if we error in the
+      // renderer anyway. The renderer is the only one that knows what types are valid
+      // for this particular renderer so we let it error there instead.
+      //
       // We warn in this case but don't throw. We expect the element creation to
       // succeed and there will likely be errors in render.
       let info = '';
@@ -604,6 +609,9 @@ function jsxDEVImpl(
       // errors. We don't want exception behavior to differ between dev and
       // prod. (Rendering will throw with a helpful message and as soon as the
       // type is fixed, the key warnings will appear.)
+      // When enableOwnerStacks is on, we no longer need the type here so this
+      // comment is no longer true. Which is why we can run this even for invalid
+      // types.
       const children = config.children;
       if (children !== undefined) {
         if (isStaticChildren) {
@@ -1103,6 +1111,17 @@ export function cloneElement(element, config, children) {
  */
 function validateChildKeys(node, parentType) {
   if (__DEV__) {
+    if (enableOwnerStacks) {
+      // When owner stacks is enabled no warnings happens. All we do is
+      // mark elements as being in a valid static child position so they
+      // don't need keys.
+      if (isValidElement(node)) {
+        if (node._store) {
+          node._store.validated = 1;
+        }
+      }
+      return;
+    }
     if (typeof node !== 'object' || !node) {
       return;
     }

commit d025ddd3b954dfc52ad7e6a036913946a8ca2644
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jul 22 11:50:35 2024 -0400

    Set enableFastJSX flag to true (#30343)
    
    When these to diffs are landed, we can merge this
    
    - [x] D59772879
    - [x] D59773043

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 1652b1e2ed..a0de9c8e14 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -23,7 +23,6 @@ import {
   enableRefAsProp,
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
-  enableFastJSX,
   enableOwnerStacks,
 } from 'shared/ReactFeatureFlags';
 import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
@@ -82,9 +81,7 @@ if (__DEV__) {
   didWarnAboutElementRef = {};
 }
 
-const enableFastJSXWithStringRefs = enableFastJSX && enableRefAsProp;
-const enableFastJSXWithoutStringRefs =
-  enableFastJSXWithStringRefs && disableStringRefs;
+const enableFastJSXWithoutStringRefs = enableRefAsProp && disableStringRefs;
 
 function hasValidRef(config) {
   if (__DEV__) {
@@ -416,7 +413,7 @@ export function jsxProd(type, config, maybeKey) {
   let props;
   if (
     (enableFastJSXWithoutStringRefs ||
-      (enableFastJSXWithStringRefs && !('ref' in config))) &&
+      (enableRefAsProp && !('ref' in config))) &&
     !('key' in config)
   ) {
     // If key was not spread in, we can reuse the original props object. This
@@ -701,7 +698,7 @@ function jsxDEVImpl(
     let props;
     if (
       (enableFastJSXWithoutStringRefs ||
-        (enableFastJSXWithStringRefs && !('ref' in config))) &&
+        (enableRefAsProp && !('ref' in config))) &&
       !('key' in config)
     ) {
       // If key was not spread in, we can reuse the original props object. This

commit 5636fad840942cfea80301d91e931a50c6370d19
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Oct 10 18:12:47 2024 -0400

    [string-refs] log string ref from prod (#31161)
    
    If passed as a feature flag, this calls the configured function when a
    string ref is used even from prod code to find the last usages.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index a0de9c8e14..893806def2 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -24,6 +24,7 @@ import {
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
   enableOwnerStacks,
+  enableLogStringRefsProd,
 } from 'shared/ReactFeatureFlags';
 import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
 import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
@@ -76,7 +77,7 @@ let didWarnAboutStringRefs;
 let didWarnAboutElementRef;
 let didWarnAboutOldJSXRuntime;
 
-if (__DEV__) {
+if (__DEV__ || enableLogStringRefsProd) {
   didWarnAboutStringRefs = {};
   didWarnAboutElementRef = {};
 }
@@ -1314,22 +1315,27 @@ function stringRefAsCallbackRef(stringRef, type, owner, value) {
     );
   }
 
-  if (__DEV__) {
+  if (__DEV__ || enableLogStringRefsProd) {
     if (
       // Will already warn with "Function components cannot be given refs"
       !(typeof type === 'function' && !isReactClass(type))
     ) {
       const componentName = getComponentNameFromFiber(owner) || 'Component';
       if (!didWarnAboutStringRefs[componentName]) {
-        console.error(
-          'Component "%s" contains the string ref "%s". Support for string refs ' +
-            'will be removed in a future major release. We recommend using ' +
-            'useRef() or createRef() instead. ' +
-            'Learn more about using refs safely here: ' +
-            'https://react.dev/link/strict-mode-string-ref',
-          componentName,
-          stringRef,
-        );
+        if (enableLogStringRefsProd) {
+          enableLogStringRefsProd(componentName, stringRef);
+        }
+        if (__DEV__) {
+          console.error(
+            'Component "%s" contains the string ref "%s". Support for string refs ' +
+              'will be removed in a future major release. We recommend using ' +
+              'useRef() or createRef() instead. ' +
+              'Learn more about using refs safely here: ' +
+              'https://react.dev/link/strict-mode-string-ref',
+            componentName,
+            stringRef,
+          );
+        }
         didWarnAboutStringRefs[componentName] = true;
       }
     }

commit 07aa494432e97f63fca9faf2fad6f76fead31063
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Nov 4 14:30:58 2024 -0500

    Remove enableRefAsProp feature flag (#30346)
    
    The flag is fully rolled out.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 893806def2..1d1848e341 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -20,7 +20,6 @@ import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
 import {
-  enableRefAsProp,
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
   enableOwnerStacks,
@@ -72,7 +71,6 @@ function getOwner() {
 }
 
 let specialPropKeyWarningShown;
-let specialPropRefWarningShown;
 let didWarnAboutStringRefs;
 let didWarnAboutElementRef;
 let didWarnAboutOldJSXRuntime;
@@ -82,7 +80,7 @@ if (__DEV__ || enableLogStringRefsProd) {
   didWarnAboutElementRef = {};
 }
 
-const enableFastJSXWithoutStringRefs = enableRefAsProp && disableStringRefs;
+const enableFastJSXWithoutStringRefs = disableStringRefs;
 
 function hasValidRef(config) {
   if (__DEV__) {
@@ -159,30 +157,6 @@ function defineKeyPropWarningGetter(props, displayName) {
   }
 }
 
-function defineRefPropWarningGetter(props, displayName) {
-  if (!enableRefAsProp) {
-    if (__DEV__) {
-      const warnAboutAccessingRef = function () {
-        if (!specialPropRefWarningShown) {
-          specialPropRefWarningShown = true;
-          console.error(
-            '%s: `ref` is not a prop. Trying to access it will result ' +
-              'in `undefined` being returned. If you need to access the same ' +
-              'value within the child component, you should pass it as a different ' +
-              'prop. (https://react.dev/link/special-props)',
-            displayName,
-          );
-        }
-      };
-      warnAboutAccessingRef.isReactWarning = true;
-      Object.defineProperty(props, 'ref', {
-        get: warnAboutAccessingRef,
-        configurable: true,
-      });
-    }
-  }
-}
-
 function elementRefGetterWithDeprecationWarning() {
   if (__DEV__) {
     const componentName = getComponentNameFromType(this.type);
@@ -225,7 +199,6 @@ function elementRefGetterWithDeprecationWarning() {
 function ReactElement(
   type,
   key,
-  _ref,
   self,
   source,
   owner,
@@ -233,24 +206,18 @@ function ReactElement(
   debugStack,
   debugTask,
 ) {
-  let ref;
-  if (enableRefAsProp) {
-    // When enableRefAsProp is on, ignore whatever was passed as the ref
-    // argument and treat `props.ref` as the source of truth. The only thing we
-    // use this for is `element.ref`, which will log a deprecation warning on
-    // access. In the next release, we can remove `element.ref` as well as the
-    // `ref` argument.
-    const refProp = props.ref;
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
 
-    // An undefined `element.ref` is coerced to `null` for
-    // backwards compatibility.
-    ref = refProp !== undefined ? refProp : null;
-  } else {
-    ref = _ref;
-  }
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
 
   let element;
-  if (__DEV__ && enableRefAsProp) {
+  if (__DEV__) {
     // In dev, make `ref` a non-enumerable property with a warning. It's non-
     // enumerable so that test matchers and serializers don't access it and
     // trigger the warning.
@@ -380,7 +347,6 @@ function ReactElement(
  */
 export function jsxProd(type, config, maybeKey) {
   let key = null;
-  let ref = null;
 
   // Currently, key can be spread in as a prop. This causes a potential
   // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
@@ -402,19 +368,9 @@ export function jsxProd(type, config, maybeKey) {
     key = '' + config.key;
   }
 
-  if (hasValidRef(config)) {
-    if (!enableRefAsProp) {
-      ref = config.ref;
-      if (!disableStringRefs) {
-        ref = coerceStringRef(ref, getOwner(), type);
-      }
-    }
-  }
-
   let props;
   if (
-    (enableFastJSXWithoutStringRefs ||
-      (enableRefAsProp && !('ref' in config))) &&
+    (enableFastJSXWithoutStringRefs || !('ref' in config)) &&
     !('key' in config)
   ) {
     // If key was not spread in, we can reuse the original props object. This
@@ -434,8 +390,8 @@ export function jsxProd(type, config, maybeKey) {
     props = {};
     for (const propName in config) {
       // Skip over reserved prop names
-      if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
-        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+      if (propName !== 'key') {
+        if (!disableStringRefs && propName === 'ref') {
           props.ref = coerceStringRef(config[propName], getOwner(), type);
         } else {
           props[propName] = config[propName];
@@ -459,7 +415,6 @@ export function jsxProd(type, config, maybeKey) {
   return ReactElement(
     type,
     key,
-    ref,
     undefined,
     undefined,
     getOwner(),
@@ -662,7 +617,6 @@ function jsxDEVImpl(
     }
 
     let key = null;
-    let ref = null;
 
     // Currently, key can be spread in as a prop. This causes a potential
     // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
@@ -684,22 +638,15 @@ function jsxDEVImpl(
       key = '' + config.key;
     }
 
-    if (hasValidRef(config)) {
-      if (!enableRefAsProp) {
-        ref = config.ref;
-        if (!disableStringRefs) {
-          ref = coerceStringRef(ref, getOwner(), type);
-        }
-      }
-      if (!disableStringRefs) {
+    if (!disableStringRefs) {
+      if (hasValidRef(config)) {
         warnIfStringRefCannotBeAutoConverted(config, self);
       }
     }
 
     let props;
     if (
-      (enableFastJSXWithoutStringRefs ||
-        (enableRefAsProp && !('ref' in config))) &&
+      (enableFastJSXWithoutStringRefs || !('ref' in config)) &&
       !('key' in config)
     ) {
       // If key was not spread in, we can reuse the original props object. This
@@ -719,8 +666,8 @@ function jsxDEVImpl(
       props = {};
       for (const propName in config) {
         // Skip over reserved prop names
-        if (propName !== 'key' && (enableRefAsProp || propName !== 'ref')) {
-          if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+        if (propName !== 'key') {
+          if (!disableStringRefs && propName === 'ref') {
             props.ref = coerceStringRef(config[propName], getOwner(), type);
           } else {
             props[propName] = config[propName];
@@ -741,23 +688,17 @@ function jsxDEVImpl(
       }
     }
 
-    if (key || (!enableRefAsProp && ref)) {
+    if (key) {
       const displayName =
         typeof type === 'function'
           ? type.displayName || type.name || 'Unknown'
           : type;
-      if (key) {
-        defineKeyPropWarningGetter(props, displayName);
-      }
-      if (!enableRefAsProp && ref) {
-        defineRefPropWarningGetter(props, displayName);
-      }
+      defineKeyPropWarningGetter(props, displayName);
     }
 
     return ReactElement(
       type,
       key,
-      ref,
       self,
       source,
       getOwner(),
@@ -838,7 +779,6 @@ export function createElement(type, config, children) {
   const props = {};
 
   let key = null;
-  let ref = null;
 
   if (config != null) {
     if (__DEV__) {
@@ -861,15 +801,8 @@ export function createElement(type, config, children) {
       }
     }
 
-    if (hasValidRef(config)) {
-      if (!enableRefAsProp) {
-        ref = config.ref;
-        if (!disableStringRefs) {
-          ref = coerceStringRef(ref, getOwner(), type);
-        }
-      }
-
-      if (__DEV__ && !disableStringRefs) {
+    if (__DEV__ && !disableStringRefs) {
+      if (hasValidRef(config)) {
         warnIfStringRefCannotBeAutoConverted(config, config.__self);
       }
     }
@@ -886,7 +819,6 @@ export function createElement(type, config, children) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        (enableRefAsProp || propName !== 'ref') &&
         // Even though we don't use these anymore in the runtime, we don't want
         // them to appear as props, so in createElement we filter them out.
         // We don't have to do this in the jsx() runtime because the jsx()
@@ -894,7 +826,7 @@ export function createElement(type, config, children) {
         propName !== '__self' &&
         propName !== '__source'
       ) {
-        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+        if (!disableStringRefs && propName === 'ref') {
           props.ref = coerceStringRef(config[propName], getOwner(), type);
         } else {
           props[propName] = config[propName];
@@ -931,24 +863,18 @@ export function createElement(type, config, children) {
     }
   }
   if (__DEV__) {
-    if (key || (!enableRefAsProp && ref)) {
+    if (key) {
       const displayName =
         typeof type === 'function'
           ? type.displayName || type.name || 'Unknown'
           : type;
-      if (key) {
-        defineKeyPropWarningGetter(props, displayName);
-      }
-      if (!enableRefAsProp && ref) {
-        defineRefPropWarningGetter(props, displayName);
-      }
+      defineKeyPropWarningGetter(props, displayName);
     }
   }
 
   return ReactElement(
     type,
     key,
-    ref,
     undefined,
     undefined,
     getOwner(),
@@ -962,9 +888,6 @@ export function cloneAndReplaceKey(oldElement, newKey) {
   const clonedElement = ReactElement(
     oldElement.type,
     newKey,
-    // When enableRefAsProp is on, this argument is ignored. This check only
-    // exists to avoid the `ref` access warning.
-    enableRefAsProp ? null : oldElement.ref,
     undefined,
     undefined,
     !__DEV__ && disableStringRefs ? undefined : oldElement._owner,
@@ -997,7 +920,6 @@ export function cloneElement(element, config, children) {
 
   // Reserved names are extracted
   let key = element.key;
-  let ref = enableRefAsProp ? null : element.ref;
 
   // Owner will be preserved, unless ref is overridden
   let owner = !__DEV__ && disableStringRefs ? undefined : element._owner;
@@ -1005,13 +927,6 @@ export function cloneElement(element, config, children) {
   if (config != null) {
     if (hasValidRef(config)) {
       owner = __DEV__ || !disableStringRefs ? getOwner() : undefined;
-      if (!enableRefAsProp) {
-        // Silently steal the ref from the parent.
-        ref = config.ref;
-        if (!disableStringRefs) {
-          ref = coerceStringRef(ref, owner, element.type);
-        }
-      }
     }
     if (hasValidKey(config)) {
       if (__DEV__) {
@@ -1034,7 +949,6 @@ export function cloneElement(element, config, children) {
         hasOwnProperty.call(config, propName) &&
         // Skip over reserved prop names
         propName !== 'key' &&
-        (enableRefAsProp || propName !== 'ref') &&
         // ...and maybe these, too, though we currently rely on them for
         // warnings and debug information in dev. Need to decide if we're OK
         // with dropping them. In the jsx() runtime it's not an issue because
@@ -1046,7 +960,7 @@ export function cloneElement(element, config, children) {
         // Undefined `ref` is ignored by cloneElement. We treat it the same as
         // if the property were missing. This is mostly for
         // backwards compatibility.
-        !(enableRefAsProp && propName === 'ref' && config.ref === undefined)
+        !(propName === 'ref' && config.ref === undefined)
       ) {
         if (
           !disableDefaultPropsExceptForClasses &&
@@ -1056,7 +970,7 @@ export function cloneElement(element, config, children) {
           // Resolve default props
           props[propName] = defaultProps[propName];
         } else {
-          if (enableRefAsProp && !disableStringRefs && propName === 'ref') {
+          if (!disableStringRefs && propName === 'ref') {
             props.ref = coerceStringRef(config[propName], owner, element.type);
           } else {
             props[propName] = config[propName];
@@ -1082,7 +996,6 @@ export function cloneElement(element, config, children) {
   const clonedElement = ReactElement(
     element.type,
     key,
-    ref,
     undefined,
     undefined,
     owner,

commit d1f04722d617600cc6cd96dcebc1c2ef7affc904
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Nov 6 09:00:49 2024 -0500

    [string-refs] remove enableLogStringRefsProd flag (#31414)
    
    We no longer need this production logging.

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 1d1848e341..3722638ad9 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -23,7 +23,6 @@ import {
   disableStringRefs,
   disableDefaultPropsExceptForClasses,
   enableOwnerStacks,
-  enableLogStringRefsProd,
 } from 'shared/ReactFeatureFlags';
 import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
 import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
@@ -75,7 +74,7 @@ let didWarnAboutStringRefs;
 let didWarnAboutElementRef;
 let didWarnAboutOldJSXRuntime;
 
-if (__DEV__ || enableLogStringRefsProd) {
+if (__DEV__) {
   didWarnAboutStringRefs = {};
   didWarnAboutElementRef = {};
 }
@@ -1228,16 +1227,13 @@ function stringRefAsCallbackRef(stringRef, type, owner, value) {
     );
   }
 
-  if (__DEV__ || enableLogStringRefsProd) {
+  if (__DEV__) {
     if (
       // Will already warn with "Function components cannot be given refs"
       !(typeof type === 'function' && !isReactClass(type))
     ) {
       const componentName = getComponentNameFromFiber(owner) || 'Component';
       if (!didWarnAboutStringRefs[componentName]) {
-        if (enableLogStringRefsProd) {
-          enableLogStringRefsProd(componentName, stringRef);
-        }
         if (__DEV__) {
           console.error(
             'Component "%s" contains the string ref "%s". Support for string refs ' +

commit e1378902bbb322aa1fe1953780f4b2b5f80d26b1
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Nov 6 14:00:10 2024 -0500

    [string-refs] cleanup string ref code (#31443)

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 3722638ad9..e0a689ec24 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -20,13 +20,9 @@ import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
 import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
 import {
-  disableStringRefs,
   disableDefaultPropsExceptForClasses,
   enableOwnerStacks,
 } from 'shared/ReactFeatureFlags';
-import {checkPropStringCoercion} from 'shared/CheckStringCoercion';
-import {ClassComponent} from 'react-reconciler/src/ReactWorkTags';
-import getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';
 
 const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
 
@@ -59,7 +55,7 @@ function getTaskName(type) {
 }
 
 function getOwner() {
-  if (__DEV__ || !disableStringRefs) {
+  if (__DEV__) {
     const dispatcher = ReactSharedInternals.A;
     if (dispatcher === null) {
       return null;
@@ -70,17 +66,13 @@ function getOwner() {
 }
 
 let specialPropKeyWarningShown;
-let didWarnAboutStringRefs;
 let didWarnAboutElementRef;
 let didWarnAboutOldJSXRuntime;
 
 if (__DEV__) {
-  didWarnAboutStringRefs = {};
   didWarnAboutElementRef = {};
 }
 
-const enableFastJSXWithoutStringRefs = disableStringRefs;
-
 function hasValidRef(config) {
   if (__DEV__) {
     if (hasOwnProperty.call(config, 'ref')) {
@@ -105,35 +97,6 @@ function hasValidKey(config) {
   return config.key !== undefined;
 }
 
-function warnIfStringRefCannotBeAutoConverted(config, self) {
-  if (__DEV__) {
-    let owner;
-    if (
-      !disableStringRefs &&
-      typeof config.ref === 'string' &&
-      (owner = getOwner()) &&
-      self &&
-      owner.stateNode !== self
-    ) {
-      const componentName = getComponentNameFromType(owner.type);
-
-      if (!didWarnAboutStringRefs[componentName]) {
-        console.error(
-          'Component "%s" contains the string ref "%s". ' +
-            'Support for string refs will be removed in a future major release. ' +
-            'This case cannot be automatically converted to an arrow function. ' +
-            'We ask you to manually fix this case by using useRef() or createRef() instead. ' +
-            'Learn more about using refs safely here: ' +
-            'https://react.dev/link/strict-mode-string-ref',
-          getComponentNameFromType(owner.type),
-          config.ref,
-        );
-        didWarnAboutStringRefs[componentName] = true;
-      }
-    }
-  }
-}
-
 function defineKeyPropWarningGetter(props, displayName) {
   if (__DEV__) {
     const warnAboutAccessingKey = function () {
@@ -259,22 +222,8 @@ function ReactElement(
         value: null,
       });
     }
-  } else if (!__DEV__ && disableStringRefs) {
-    // In prod, `ref` is a regular property and _owner doesn't exist.
-    element = {
-      // This tag allows us to uniquely identify this as a React Element
-      $$typeof: REACT_ELEMENT_TYPE,
-
-      // Built-in properties that belong on the element
-      type,
-      key,
-      ref,
-
-      props,
-    };
   } else {
-    // In prod, `ref` is a regular property. It will be removed in a
-    // future release.
+    // In prod, `ref` is a regular property and _owner doesn't exist.
     element = {
       // This tag allows us to uniquely identify this as a React Element
       $$typeof: REACT_ELEMENT_TYPE,
@@ -285,9 +234,6 @@ function ReactElement(
       ref,
 
       props,
-
-      // Record the component responsible for creating this element.
-      _owner: owner,
     };
   }
 
@@ -368,10 +314,7 @@ export function jsxProd(type, config, maybeKey) {
   }
 
   let props;
-  if (
-    (enableFastJSXWithoutStringRefs || !('ref' in config)) &&
-    !('key' in config)
-  ) {
+  if (!('key' in config)) {
     // If key was not spread in, we can reuse the original props object. This
     // only works for `jsx`, not `createElement`, because `jsx` is a compiler
     // target and the compiler always passes a new object. For `createElement`,
@@ -390,11 +333,7 @@ export function jsxProd(type, config, maybeKey) {
     for (const propName in config) {
       // Skip over reserved prop names
       if (propName !== 'key') {
-        if (!disableStringRefs && propName === 'ref') {
-          props.ref = coerceStringRef(config[propName], getOwner(), type);
-        } else {
-          props[propName] = config[propName];
-        }
+        props[propName] = config[propName];
       }
     }
   }
@@ -637,17 +576,8 @@ function jsxDEVImpl(
       key = '' + config.key;
     }
 
-    if (!disableStringRefs) {
-      if (hasValidRef(config)) {
-        warnIfStringRefCannotBeAutoConverted(config, self);
-      }
-    }
-
     let props;
-    if (
-      (enableFastJSXWithoutStringRefs || !('ref' in config)) &&
-      !('key' in config)
-    ) {
+    if (!('key' in config)) {
       // If key was not spread in, we can reuse the original props object. This
       // only works for `jsx`, not `createElement`, because `jsx` is a compiler
       // target and the compiler always passes a new object. For `createElement`,
@@ -666,11 +596,7 @@ function jsxDEVImpl(
       for (const propName in config) {
         // Skip over reserved prop names
         if (propName !== 'key') {
-          if (!disableStringRefs && propName === 'ref') {
-            props.ref = coerceStringRef(config[propName], getOwner(), type);
-          } else {
-            props[propName] = config[propName];
-          }
+          props[propName] = config[propName];
         }
       }
     }
@@ -800,11 +726,6 @@ export function createElement(type, config, children) {
       }
     }
 
-    if (__DEV__ && !disableStringRefs) {
-      if (hasValidRef(config)) {
-        warnIfStringRefCannotBeAutoConverted(config, config.__self);
-      }
-    }
     if (hasValidKey(config)) {
       if (__DEV__) {
         checkKeyStringCoercion(config.key);
@@ -825,11 +746,7 @@ export function createElement(type, config, children) {
         propName !== '__self' &&
         propName !== '__source'
       ) {
-        if (!disableStringRefs && propName === 'ref') {
-          props.ref = coerceStringRef(config[propName], getOwner(), type);
-        } else {
-          props[propName] = config[propName];
-        }
+        props[propName] = config[propName];
       }
     }
   }
@@ -889,7 +806,7 @@ export function cloneAndReplaceKey(oldElement, newKey) {
     newKey,
     undefined,
     undefined,
-    !__DEV__ && disableStringRefs ? undefined : oldElement._owner,
+    !__DEV__ ? undefined : oldElement._owner,
     oldElement.props,
     __DEV__ && enableOwnerStacks ? oldElement._debugStack : undefined,
     __DEV__ && enableOwnerStacks ? oldElement._debugTask : undefined,
@@ -921,11 +838,11 @@ export function cloneElement(element, config, children) {
   let key = element.key;
 
   // Owner will be preserved, unless ref is overridden
-  let owner = !__DEV__ && disableStringRefs ? undefined : element._owner;
+  let owner = !__DEV__ ? undefined : element._owner;
 
   if (config != null) {
     if (hasValidRef(config)) {
-      owner = __DEV__ || !disableStringRefs ? getOwner() : undefined;
+      owner = __DEV__ ? getOwner() : undefined;
     }
     if (hasValidKey(config)) {
       if (__DEV__) {
@@ -969,11 +886,7 @@ export function cloneElement(element, config, children) {
           // Resolve default props
           props[propName] = defaultProps[propName];
         } else {
-          if (!disableStringRefs && propName === 'ref') {
-            props.ref = coerceStringRef(config[propName], owner, element.type);
-          } else {
-            props[propName] = config[propName];
-          }
+          props[propName] = config[propName];
         }
       }
     }
@@ -1173,99 +1086,3 @@ function getCurrentComponentErrorInfo(parentType) {
     return info;
   }
 }
-
-function coerceStringRef(mixedRef, owner, type) {
-  if (disableStringRefs) {
-    return mixedRef;
-  }
-
-  let stringRef;
-  if (typeof mixedRef === 'string') {
-    stringRef = mixedRef;
-  } else {
-    if (typeof mixedRef === 'number' || typeof mixedRef === 'boolean') {
-      if (__DEV__) {
-        checkPropStringCoercion(mixedRef, 'ref');
-      }
-      stringRef = '' + mixedRef;
-    } else {
-      return mixedRef;
-    }
-  }
-
-  const callback = stringRefAsCallbackRef.bind(null, stringRef, type, owner);
-  // This is used to check whether two callback refs conceptually represent
-  // the same string ref, and can therefore be reused by the reconciler. Needed
-  // for backwards compatibility with old Meta code that relies on string refs
-  // not being reattached on every render.
-  callback.__stringRef = stringRef;
-  callback.__type = type;
-  callback.__owner = owner;
-  return callback;
-}
-
-function stringRefAsCallbackRef(stringRef, type, owner, value) {
-  if (disableStringRefs) {
-    return;
-  }
-  if (!owner) {
-    throw new Error(
-      `Element ref was specified as a string (${stringRef}) but no owner was set. This could happen for one of` +
-        ' the following reasons:\n' +
-        '1. You may be adding a ref to a function component\n' +
-        "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
-        '3. You have multiple copies of React loaded\n' +
-        'See https://react.dev/link/refs-must-have-owner for more information.',
-    );
-  }
-  if (owner.tag !== ClassComponent) {
-    throw new Error(
-      'Function components cannot have string refs. ' +
-        'We recommend using useRef() instead. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-string-ref',
-    );
-  }
-
-  if (__DEV__) {
-    if (
-      // Will already warn with "Function components cannot be given refs"
-      !(typeof type === 'function' && !isReactClass(type))
-    ) {
-      const componentName = getComponentNameFromFiber(owner) || 'Component';
-      if (!didWarnAboutStringRefs[componentName]) {
-        if (__DEV__) {
-          console.error(
-            'Component "%s" contains the string ref "%s". Support for string refs ' +
-              'will be removed in a future major release. We recommend using ' +
-              'useRef() or createRef() instead. ' +
-              'Learn more about using refs safely here: ' +
-              'https://react.dev/link/strict-mode-string-ref',
-            componentName,
-            stringRef,
-          );
-        }
-        didWarnAboutStringRefs[componentName] = true;
-      }
-    }
-  }
-
-  const inst = owner.stateNode;
-  if (!inst) {
-    throw new Error(
-      `Missing owner for string ref ${stringRef}. This error is likely caused by a ` +
-        'bug in React. Please file an issue.',
-    );
-  }
-
-  const refs = inst.refs;
-  if (value === null) {
-    delete refs[stringRef];
-  } else {
-    refs[stringRef] = value;
-  }
-}
-
-function isReactClass(type) {
-  return type.prototype && type.prototype.isReactComponent;
-}

commit 9ff42a8798863c995523e284142b47e3cdfaee80
Author: Timothy Yung <yungsters@meta.com>
Date:   Thu Jan 30 22:59:45 2025 -0800

    Permit non-`DEV` Elements in `React.Children` w/ `DEV` (#32117)

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index e0a689ec24..5edcb333ea 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -813,7 +813,9 @@ export function cloneAndReplaceKey(oldElement, newKey) {
   );
   if (__DEV__) {
     // The cloned element should inherit the original element's key validation.
-    clonedElement._store.validated = oldElement._store.validated;
+    if (oldElement._store) {
+      clonedElement._store.validated = oldElement._store.validated;
+    }
   }
   return clonedElement;
 }

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 5edcb333ea..0f5fb1cd43 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -10,25 +10,17 @@ import ReactSharedInternals from 'shared/ReactSharedInternals';
 import hasOwnProperty from 'shared/hasOwnProperty';
 import assign from 'shared/assign';
 import {
-  getIteratorFn,
   REACT_ELEMENT_TYPE,
   REACT_FRAGMENT_TYPE,
   REACT_LAZY_TYPE,
 } from 'shared/ReactSymbols';
 import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
-import isValidElementType from 'shared/isValidElementType';
 import isArray from 'shared/isArray';
-import {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';
-import {
-  disableDefaultPropsExceptForClasses,
-  enableOwnerStacks,
-} from 'shared/ReactFeatureFlags';
-
-const REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+import {disableDefaultPropsExceptForClasses} from 'shared/ReactFeatureFlags';
 
 const createTask =
   // eslint-disable-next-line react-internal/no-production-logging
-  __DEV__ && enableOwnerStacks && console.createTask
+  __DEV__ && console.createTask
     ? // eslint-disable-next-line react-internal/no-production-logging
       console.createTask
     : () => null;
@@ -261,20 +253,18 @@ function ReactElement(
       writable: true,
       value: null,
     });
-    if (enableOwnerStacks) {
-      Object.defineProperty(element, '_debugStack', {
-        configurable: false,
-        enumerable: false,
-        writable: true,
-        value: debugStack,
-      });
-      Object.defineProperty(element, '_debugTask', {
-        configurable: false,
-        enumerable: false,
-        writable: true,
-        value: debugTask,
-      });
-    }
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack,
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask,
+    });
     if (Object.freeze) {
       Object.freeze(element.props);
       Object.freeze(element);
@@ -390,8 +380,8 @@ export function jsxProdSignatureRunningInDevWithDynamicChildren(
       isStaticChildren,
       source,
       self,
-      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
-      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+      __DEV__ && Error('react-stack-top-frame'),
+      __DEV__ && createTask(getTaskName(type)),
     );
   }
 }
@@ -412,8 +402,8 @@ export function jsxProdSignatureRunningInDevWithStaticChildren(
       isStaticChildren,
       source,
       self,
-      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
-      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+      __DEV__ && Error('react-stack-top-frame'),
+      __DEV__ && createTask(getTaskName(type)),
     );
   }
 }
@@ -434,8 +424,8 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
     isStaticChildren,
     source,
     self,
-    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
-    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+    __DEV__ && Error('react-stack-top-frame'),
+    __DEV__ && createTask(getTaskName(type)),
   );
 }
 
@@ -450,80 +440,37 @@ function jsxDEVImpl(
   debugTask,
 ) {
   if (__DEV__) {
-    if (!enableOwnerStacks && !isValidElementType(type)) {
-      // This is an invalid element type.
-      //
-      // We warn here so that we can get better stack traces but with enableOwnerStacks
-      // enabled we don't need this because we get good stacks if we error in the
-      // renderer anyway. The renderer is the only one that knows what types are valid
-      // for this particular renderer so we let it error there instead.
-      //
-      // We warn in this case but don't throw. We expect the element creation to
-      // succeed and there will likely be errors in render.
-      let info = '';
-      if (
-        type === undefined ||
-        (typeof type === 'object' &&
-          type !== null &&
-          Object.keys(type).length === 0)
-      ) {
-        info +=
-          ' You likely forgot to export your component from the file ' +
-          "it's defined in, or you might have mixed up default and named imports.";
-      }
-
-      let typeString;
-      if (type === null) {
-        typeString = 'null';
-      } else if (isArray(type)) {
-        typeString = 'array';
-      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
-        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;
-        info =
-          ' Did you accidentally export a JSX literal instead of a component?';
-      } else {
-        typeString = typeof type;
-      }
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    // With owner stacks, we no longer need the type here so this comment is
+    // no longer true. Which is why we can run this even for invalid types.
+    const children = config.children;
+    if (children !== undefined) {
+      if (isStaticChildren) {
+        if (isArray(children)) {
+          for (let i = 0; i < children.length; i++) {
+            validateChildKeys(children[i], type);
+          }
 
-      console.error(
-        'React.jsx: type is invalid -- expected a string (for ' +
-          'built-in components) or a class/function (for composite ' +
-          'components) but got: %s.%s',
-        typeString,
-        info,
-      );
-    } else {
-      // This is a valid element type.
-
-      // Skip key warning if the type isn't valid since our key validation logic
-      // doesn't expect a non-string/function type and can throw confusing
-      // errors. We don't want exception behavior to differ between dev and
-      // prod. (Rendering will throw with a helpful message and as soon as the
-      // type is fixed, the key warnings will appear.)
-      // When enableOwnerStacks is on, we no longer need the type here so this
-      // comment is no longer true. Which is why we can run this even for invalid
-      // types.
-      const children = config.children;
-      if (children !== undefined) {
-        if (isStaticChildren) {
-          if (isArray(children)) {
-            for (let i = 0; i < children.length; i++) {
-              validateChildKeys(children[i], type);
-            }
-
-            if (Object.freeze) {
-              Object.freeze(children);
-            }
-          } else {
-            console.error(
-              'React.jsx: Static children should always be an array. ' +
-                'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +
-                'Use the Babel transform instead.',
-            );
+          if (Object.freeze) {
+            Object.freeze(children);
           }
         } else {
-          validateChildKeys(children, type);
+          console.error(
+            'React.jsx: Static children should always be an array. ' +
+              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +
+              'Use the Babel transform instead.',
+          );
         }
+      } else {
+        validateChildKeys(children, type);
       }
     }
 
@@ -640,59 +587,17 @@ function jsxDEVImpl(
  */
 export function createElement(type, config, children) {
   if (__DEV__) {
-    if (!enableOwnerStacks && !isValidElementType(type)) {
-      // This is just an optimistic check that provides a better stack trace before
-      // owner stacks. It's really up to the renderer if it's a valid element type.
-      // When owner stacks are enabled, we instead warn in the renderer and it'll
-      // have the stack trace of the JSX element anyway.
-      //
-      // This is an invalid element type.
-      //
-      // We warn in this case but don't throw. We expect the element creation to
-      // succeed and there will likely be errors in render.
-      let info = '';
-      if (
-        type === undefined ||
-        (typeof type === 'object' &&
-          type !== null &&
-          Object.keys(type).length === 0)
-      ) {
-        info +=
-          ' You likely forgot to export your component from the file ' +
-          "it's defined in, or you might have mixed up default and named imports.";
-      }
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
 
-      let typeString;
-      if (type === null) {
-        typeString = 'null';
-      } else if (isArray(type)) {
-        typeString = 'array';
-      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
-        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;
-        info =
-          ' Did you accidentally export a JSX literal instead of a component?';
-      } else {
-        typeString = typeof type;
-      }
-
-      console.error(
-        'React.createElement: type is invalid -- expected a string (for ' +
-          'built-in components) or a class/function (for composite ' +
-          'components) but got: %s.%s',
-        typeString,
-        info,
-      );
-    } else {
-      // This is a valid element type.
-
-      // Skip key warning if the type isn't valid since our key validation logic
-      // doesn't expect a non-string/function type and can throw confusing
-      // errors. We don't want exception behavior to differ between dev and
-      // prod. (Rendering will throw with a helpful message and as soon as the
-      // type is fixed, the key warnings will appear.)
-      for (let i = 2; i < arguments.length; i++) {
-        validateChildKeys(arguments[i], type);
-      }
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    for (let i = 2; i < arguments.length; i++) {
+      validateChildKeys(arguments[i], type);
     }
 
     // Unlike the jsx() runtime, createElement() doesn't warn about key spread.
@@ -795,8 +700,8 @@ export function createElement(type, config, children) {
     undefined,
     getOwner(),
     props,
-    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,
-    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,
+    __DEV__ && Error('react-stack-top-frame'),
+    __DEV__ && createTask(getTaskName(type)),
   );
 }
 
@@ -808,8 +713,8 @@ export function cloneAndReplaceKey(oldElement, newKey) {
     undefined,
     !__DEV__ ? undefined : oldElement._owner,
     oldElement.props,
-    __DEV__ && enableOwnerStacks ? oldElement._debugStack : undefined,
-    __DEV__ && enableOwnerStacks ? oldElement._debugTask : undefined,
+    __DEV__ && oldElement._debugStack,
+    __DEV__ && oldElement._debugTask,
   );
   if (__DEV__) {
     // The cloned element should inherit the original element's key validation.
@@ -914,8 +819,8 @@ export function cloneElement(element, config, children) {
     undefined,
     owner,
     props,
-    __DEV__ && enableOwnerStacks ? element._debugStack : undefined,
-    __DEV__ && enableOwnerStacks ? element._debugTask : undefined,
+    __DEV__ && element._debugStack,
+    __DEV__ && element._debugTask,
   );
 
   for (let i = 2; i < arguments.length; i++) {
@@ -936,51 +841,13 @@ export function cloneElement(element, config, children) {
  */
 function validateChildKeys(node, parentType) {
   if (__DEV__) {
-    if (enableOwnerStacks) {
-      // When owner stacks is enabled no warnings happens. All we do is
-      // mark elements as being in a valid static child position so they
-      // don't need keys.
-      if (isValidElement(node)) {
-        if (node._store) {
-          node._store.validated = 1;
-        }
-      }
-      return;
-    }
-    if (typeof node !== 'object' || !node) {
-      return;
-    }
-    if (node.$$typeof === REACT_CLIENT_REFERENCE) {
-      // This is a reference to a client component so it's unknown.
-    } else if (isArray(node)) {
-      for (let i = 0; i < node.length; i++) {
-        const child = node[i];
-        if (isValidElement(child)) {
-          validateExplicitKey(child, parentType);
-        }
-      }
-    } else if (isValidElement(node)) {
-      // This element was passed in a valid location.
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
       if (node._store) {
         node._store.validated = 1;
       }
-    } else {
-      const iteratorFn = getIteratorFn(node);
-      if (typeof iteratorFn === 'function') {
-        // Entry iterators used to provide implicit keys,
-        // but now we print a separate warning for them later.
-        if (iteratorFn !== node.entries) {
-          const iterator = iteratorFn.call(node);
-          if (iterator !== node) {
-            let step;
-            while (!(step = iterator.next()).done) {
-              if (isValidElement(step.value)) {
-                validateExplicitKey(step.value, parentType);
-              }
-            }
-          }
-        }
-      }
     }
   }
 }
@@ -999,92 +866,3 @@ export function isValidElement(object) {
     object.$$typeof === REACT_ELEMENT_TYPE
   );
 }
-
-const ownerHasKeyUseWarning = {};
-
-/**
- * Warn if the element doesn't have an explicit key assigned to it.
- * This element is in an array. The array could grow and shrink or be
- * reordered. All children that haven't already been validated are required to
- * have a "key" property assigned to it. Error statuses are cached so a warning
- * will only be shown once.
- *
- * @internal
- * @param {ReactElement} element Element that requires a key.
- * @param {*} parentType element's parent's type.
- */
-function validateExplicitKey(element, parentType) {
-  if (enableOwnerStacks) {
-    // Skip. Will verify in renderer instead.
-    return;
-  }
-  if (__DEV__) {
-    if (!element._store || element._store.validated || element.key != null) {
-      return;
-    }
-    element._store.validated = 1;
-
-    const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
-    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
-      return;
-    }
-    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
-
-    // Usually the current owner is the offender, but if it accepts children as a
-    // property, it may be the creator of the child that's responsible for
-    // assigning it a key.
-    let childOwner = '';
-    if (element && element._owner != null && element._owner !== getOwner()) {
-      let ownerName = null;
-      if (typeof element._owner.tag === 'number') {
-        ownerName = getComponentNameFromType(element._owner.type);
-      } else if (typeof element._owner.name === 'string') {
-        ownerName = element._owner.name;
-      }
-      // Give the component that originally created this child.
-      childOwner = ` It was passed a child from ${ownerName}.`;
-    }
-
-    const prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
-    ReactSharedInternals.getCurrentStack = function () {
-      const owner = element._owner;
-      // Add an extra top frame while an element is being validated
-      let stack = describeUnknownElementTypeFrameInDEV(
-        element.type,
-        owner ? owner.type : null,
-      );
-      // Delegate to the injected renderer-specific implementation
-      if (prevGetCurrentStack) {
-        stack += prevGetCurrentStack() || '';
-      }
-      return stack;
-    };
-    console.error(
-      'Each child in a list should have a unique "key" prop.' +
-        '%s%s See https://react.dev/link/warning-keys for more information.',
-      currentComponentErrorInfo,
-      childOwner,
-    );
-    ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
-  }
-}
-
-function getCurrentComponentErrorInfo(parentType) {
-  if (__DEV__) {
-    let info = '';
-    const owner = getOwner();
-    if (owner) {
-      const name = getComponentNameFromType(owner.type);
-      if (name) {
-        info = '\n\nCheck the render method of `' + name + '`.';
-      }
-    }
-    if (!info) {
-      const parentName = getComponentNameFromType(parentType);
-      if (parentName) {
-        info = `\n\nCheck the top-level render call using <${parentName}>.`;
-      }
-    }
-    return info;
-  }
-}

commit 4a9df08157f001c01b078d259748512211233dcf
Author: Sebastian "Sebbie" Silbermann <sebastian.silbermann@vercel.com>
Date:   Sun Mar 23 15:47:03 2025 -0700

    Stop creating Owner Stacks if many have been created recently (#32529)
    
    Co-authored-by: Jack Pope <jackpope1@gmail.com>

diff --git a/packages/react/src/jsx/ReactJSXElement.js b/packages/react/src/jsx/ReactJSXElement.js
index 0f5fb1cd43..a20378a93c 100644
--- a/packages/react/src/jsx/ReactJSXElement.js
+++ b/packages/react/src/jsx/ReactJSXElement.js
@@ -16,7 +16,10 @@ import {
 } from 'shared/ReactSymbols';
 import {checkKeyStringCoercion} from 'shared/CheckStringCoercion';
 import isArray from 'shared/isArray';
-import {disableDefaultPropsExceptForClasses} from 'shared/ReactFeatureFlags';
+import {
+  disableDefaultPropsExceptForClasses,
+  ownerStackLimit,
+} from 'shared/ReactFeatureFlags';
 
 const createTask =
   // eslint-disable-next-line react-internal/no-production-logging
@@ -57,12 +60,32 @@ function getOwner() {
   return null;
 }
 
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return (() => Error('react-stack-top-frame'))();
+}
+const createFakeCallStack = {
+  'react-stack-bottom-frame': function (callStackForError) {
+    return callStackForError();
+  },
+};
+
 let specialPropKeyWarningShown;
 let didWarnAboutElementRef;
 let didWarnAboutOldJSXRuntime;
+let unknownOwnerDebugStack;
+let unknownOwnerDebugTask;
 
 if (__DEV__) {
   didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack['react-stack-bottom-frame'].bind(
+    createFakeCallStack,
+    UnknownOwner,
+  )();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
 }
 
 function hasValidRef(config) {
@@ -373,6 +396,9 @@ export function jsxProdSignatureRunningInDevWithDynamicChildren(
 ) {
   if (__DEV__) {
     const isStaticChildren = false;
+    const trackActualOwner =
+      __DEV__ &&
+      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
     return jsxDEVImpl(
       type,
       config,
@@ -380,8 +406,14 @@ export function jsxProdSignatureRunningInDevWithDynamicChildren(
       isStaticChildren,
       source,
       self,
-      __DEV__ && Error('react-stack-top-frame'),
-      __DEV__ && createTask(getTaskName(type)),
+      __DEV__ &&
+        (trackActualOwner
+          ? Error('react-stack-top-frame')
+          : unknownOwnerDebugStack),
+      __DEV__ &&
+        (trackActualOwner
+          ? createTask(getTaskName(type))
+          : unknownOwnerDebugTask),
     );
   }
 }
@@ -395,6 +427,9 @@ export function jsxProdSignatureRunningInDevWithStaticChildren(
 ) {
   if (__DEV__) {
     const isStaticChildren = true;
+    const trackActualOwner =
+      __DEV__ &&
+      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
     return jsxDEVImpl(
       type,
       config,
@@ -402,8 +437,14 @@ export function jsxProdSignatureRunningInDevWithStaticChildren(
       isStaticChildren,
       source,
       self,
-      __DEV__ && Error('react-stack-top-frame'),
-      __DEV__ && createTask(getTaskName(type)),
+      __DEV__ &&
+        (trackActualOwner
+          ? Error('react-stack-top-frame')
+          : unknownOwnerDebugStack),
+      __DEV__ &&
+        (trackActualOwner
+          ? createTask(getTaskName(type))
+          : unknownOwnerDebugTask),
     );
   }
 }
@@ -417,6 +458,9 @@ const didWarnAboutKeySpread = {};
  * @param {string} key
  */
 export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
+  const trackActualOwner =
+    __DEV__ &&
+    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
   return jsxDEVImpl(
     type,
     config,
@@ -424,8 +468,14 @@ export function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {
     isStaticChildren,
     source,
     self,
-    __DEV__ && Error('react-stack-top-frame'),
-    __DEV__ && createTask(getTaskName(type)),
+    __DEV__ &&
+      (trackActualOwner
+        ? Error('react-stack-top-frame')
+        : unknownOwnerDebugStack),
+    __DEV__ &&
+      (trackActualOwner
+        ? createTask(getTaskName(type))
+        : unknownOwnerDebugTask),
   );
 }
 
@@ -692,7 +742,9 @@ export function createElement(type, config, children) {
       defineKeyPropWarningGetter(props, displayName);
     }
   }
-
+  const trackActualOwner =
+    __DEV__ &&
+    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
   return ReactElement(
     type,
     key,
@@ -700,8 +752,14 @@ export function createElement(type, config, children) {
     undefined,
     getOwner(),
     props,
-    __DEV__ && Error('react-stack-top-frame'),
-    __DEV__ && createTask(getTaskName(type)),
+    __DEV__ &&
+      (trackActualOwner
+        ? Error('react-stack-top-frame')
+        : unknownOwnerDebugStack),
+    __DEV__ &&
+      (trackActualOwner
+        ? createTask(getTaskName(type))
+        : unknownOwnerDebugTask),
   );
 }
 

