# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/terminal/sgr.zig

commit 5743d2a232655285bb0e3859d7cf41ae68f60cff
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 11 21:40:54 2022 -0700

    terminal sgr attribute parsing

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
new file mode 100644
index 00000000..8724828f
--- /dev/null
+++ b/src/terminal/sgr.zig
@@ -0,0 +1,113 @@
+//! SGR (Select Graphic Rendition) attribute parsing and types.
+
+const std = @import("std");
+const testing = std.testing;
+
+/// Attribute type for SGR
+pub const Attribute = union(enum) {
+    /// Unset all attributes
+    unset: void,
+
+    /// Unknown attribute, the raw CSI command parameters are here.
+    unknown: []const u16,
+
+    /// Set foreground color as RGB values.
+    direct_color_fg: RGB,
+
+    /// Set background color as RGB values.
+    direct_color_bg: RGB,
+
+    pub const RGB = struct {
+        r: u8,
+        g: u8,
+        b: u8,
+    };
+};
+
+/// Parse a set of parameters to a SGR command into an attribute.
+pub fn parse(params: []const u16) Attribute {
+    // No parameters means unset
+    if (params.len == 0) return .{ .unset = {} };
+
+    switch (params[0]) {
+        0 => if (params.len == 1) return .{ .unset = {} },
+
+        38 => if ((params.len == 5 or params.len == 6) and params[1] == 2) {
+            // In the 6-len form, ignore the 3rd param.
+            const rgb = params[params.len - 3 .. params.len];
+
+            // We use @truncate because the value should be 0 to 255. If
+            // it isn't, the behavior is undefined so we just... truncate it.
+            return .{
+                .direct_color_fg = .{
+                    .r = @truncate(u8, rgb[0]),
+                    .g = @truncate(u8, rgb[1]),
+                    .b = @truncate(u8, rgb[2]),
+                },
+            };
+        },
+
+        48 => if ((params.len == 5 or params.len == 6) and params[1] == 2) {
+            // In the 6-len form, ignore the 3rd param.
+            const rgb = params[params.len - 3 .. params.len];
+
+            // We use @truncate because the value should be 0 to 255. If
+            // it isn't, the behavior is undefined so we just... truncate it.
+            return .{
+                .direct_color_bg = .{
+                    .r = @truncate(u8, rgb[0]),
+                    .g = @truncate(u8, rgb[1]),
+                    .b = @truncate(u8, rgb[2]),
+                },
+            };
+        },
+
+        else => {},
+    }
+
+    return .{ .unknown = params };
+}
+
+test "sgr: parse" {
+    try testing.expect(parse(&[_]u16{}) == .unset);
+    try testing.expect(parse(&[_]u16{0}) == .unset);
+    try testing.expect(parse(&[_]u16{ 0, 1 }) == .unknown);
+
+    {
+        const v = parse(&[_]u16{ 38, 2, 40, 44, 52 });
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
+    }
+
+    {
+        const v = parse(&[_]u16{ 38, 2, 22, 40, 44, 52 });
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
+    }
+
+    try testing.expect(parse(&[_]u16{ 38, 2, 44, 52 }) == .unknown);
+    try testing.expect(parse(&[_]u16{ 38, 2, 22, 22, 40, 44, 52 }) == .unknown);
+
+    {
+        const v = parse(&[_]u16{ 48, 2, 40, 44, 52 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
+    }
+
+    {
+        const v = parse(&[_]u16{ 48, 2, 22, 40, 44, 52 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
+    }
+
+    try testing.expect(parse(&[_]u16{ 48, 2, 44, 52 }) == .unknown);
+    try testing.expect(parse(&[_]u16{ 48, 2, 22, 22, 40, 44, 52 }) == .unknown);
+}

commit 8400b683c49dbbd52bf98bf397dd47583270867b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 12 16:20:30 2022 -0700

    sgr parsing can parse multiple

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 8724828f..f5c82647 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -24,90 +24,105 @@ pub const Attribute = union(enum) {
     };
 };
 
-/// Parse a set of parameters to a SGR command into an attribute.
-pub fn parse(params: []const u16) Attribute {
-    // No parameters means unset
-    if (params.len == 0) return .{ .unset = {} };
-
-    switch (params[0]) {
-        0 => if (params.len == 1) return .{ .unset = {} },
-
-        38 => if ((params.len == 5 or params.len == 6) and params[1] == 2) {
-            // In the 6-len form, ignore the 3rd param.
-            const rgb = params[params.len - 3 .. params.len];
-
-            // We use @truncate because the value should be 0 to 255. If
-            // it isn't, the behavior is undefined so we just... truncate it.
-            return .{
-                .direct_color_fg = .{
-                    .r = @truncate(u8, rgb[0]),
-                    .g = @truncate(u8, rgb[1]),
-                    .b = @truncate(u8, rgb[2]),
-                },
-            };
-        },
-
-        48 => if ((params.len == 5 or params.len == 6) and params[1] == 2) {
-            // In the 6-len form, ignore the 3rd param.
-            const rgb = params[params.len - 3 .. params.len];
-
-            // We use @truncate because the value should be 0 to 255. If
-            // it isn't, the behavior is undefined so we just... truncate it.
-            return .{
-                .direct_color_bg = .{
-                    .r = @truncate(u8, rgb[0]),
-                    .g = @truncate(u8, rgb[1]),
-                    .b = @truncate(u8, rgb[2]),
-                },
-            };
-        },
-
-        else => {},
+/// Parser parses the attributes from a list of SGR parameters.
+pub const Parser = struct {
+    params: []const u16,
+    idx: usize = 0,
+
+    /// Next returns the next attribute or null if there are no more attributes.
+    pub fn next(self: *Parser) ?Attribute {
+        if (self.idx > self.params.len) return null;
+
+        // Implicitly means unset
+        if (self.params.len == 0) {
+            self.idx += 1;
+            return Attribute{ .unset = {} };
+        }
+
+        const slice = self.params[self.idx..self.params.len];
+        self.idx += 1;
+
+        // Our last one will have an idx be the last value.
+        if (slice.len == 0) return null;
+
+        switch (slice[0]) {
+            0 => return Attribute{ .unset = {} },
+
+            38 => if (slice.len >= 5 and slice[1] == 2) {
+                self.idx += 4;
+
+                // In the 6-len form, ignore the 3rd param.
+                const rgb = slice[2..5];
+
+                // We use @truncate because the value should be 0 to 255. If
+                // it isn't, the behavior is undefined so we just... truncate it.
+                return Attribute{
+                    .direct_color_fg = .{
+                        .r = @truncate(u8, rgb[0]),
+                        .g = @truncate(u8, rgb[1]),
+                        .b = @truncate(u8, rgb[2]),
+                    },
+                };
+            },
+
+            48 => if (slice.len >= 5 and slice[1] == 2) {
+                self.idx += 4;
+
+                // In the 6-len form, ignore the 3rd param.
+                const rgb = slice[2..5];
+
+                // We use @truncate because the value should be 0 to 255. If
+                // it isn't, the behavior is undefined so we just... truncate it.
+                return Attribute{
+                    .direct_color_bg = .{
+                        .r = @truncate(u8, rgb[0]),
+                        .g = @truncate(u8, rgb[1]),
+                        .b = @truncate(u8, rgb[2]),
+                    },
+                };
+            },
+
+            else => {},
+        }
+
+        return Attribute{ .unknown = slice };
     }
+};
 
-    return .{ .unknown = params };
+fn testParse(params: []const u16) Attribute {
+    var p: Parser = .{ .params = params };
+    return p.next().?;
 }
 
-test "sgr: parse" {
-    try testing.expect(parse(&[_]u16{}) == .unset);
-    try testing.expect(parse(&[_]u16{0}) == .unset);
-    try testing.expect(parse(&[_]u16{ 0, 1 }) == .unknown);
-
-    {
-        const v = parse(&[_]u16{ 38, 2, 40, 44, 52 });
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
-    }
+test "sgr: Parser" {
+    try testing.expect(testParse(&[_]u16{}) == .unset);
+    try testing.expect(testParse(&[_]u16{0}) == .unset);
 
     {
-        const v = parse(&[_]u16{ 38, 2, 22, 40, 44, 52 });
+        const v = testParse(&[_]u16{ 38, 2, 40, 44, 52 });
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
         try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
         try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
     }
 
-    try testing.expect(parse(&[_]u16{ 38, 2, 44, 52 }) == .unknown);
-    try testing.expect(parse(&[_]u16{ 38, 2, 22, 22, 40, 44, 52 }) == .unknown);
+    try testing.expect(testParse(&[_]u16{ 38, 2, 44, 52 }) == .unknown);
 
     {
-        const v = parse(&[_]u16{ 48, 2, 40, 44, 52 });
+        const v = testParse(&[_]u16{ 48, 2, 40, 44, 52 });
         try testing.expect(v == .direct_color_bg);
         try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
         try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
         try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
     }
 
-    {
-        const v = parse(&[_]u16{ 48, 2, 22, 40, 44, 52 });
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
-    }
+    try testing.expect(testParse(&[_]u16{ 48, 2, 44, 52 }) == .unknown);
+}
 
-    try testing.expect(parse(&[_]u16{ 48, 2, 44, 52 }) == .unknown);
-    try testing.expect(parse(&[_]u16{ 48, 2, 22, 22, 40, 44, 52 }) == .unknown);
+test "sgr: Parser multiple" {
+    var p: Parser = .{ .params = &[_]u16{ 0, 38, 2, 40, 44, 52 } };
+    try testing.expect(p.next().? == .unset);
+    try testing.expect(p.next().? == .direct_color_fg);
+    try testing.expect(p.next() == null);
+    try testing.expect(p.next() == null);
 }

commit 043e29b885d37f01ff383bfcb68085b112c68729
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 20:47:30 2022 -0700

    sgr parse bold and 256 fg/bg

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index f5c82647..4c82c829 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -11,12 +11,21 @@ pub const Attribute = union(enum) {
     /// Unknown attribute, the raw CSI command parameters are here.
     unknown: []const u16,
 
+    /// Bold the text.
+    bold: void,
+
     /// Set foreground color as RGB values.
     direct_color_fg: RGB,
 
     /// Set background color as RGB values.
     direct_color_bg: RGB,
 
+    /// Set background color as 256-color palette.
+    @"256_bg": u8,
+
+    /// Set foreground color as 256-color palette.
+    @"256_fg": u8,
+
     pub const RGB = struct {
         r: u8,
         g: u8,
@@ -48,6 +57,8 @@ pub const Parser = struct {
         switch (slice[0]) {
             0 => return Attribute{ .unset = {} },
 
+            1 => return Attribute{ .bold = {} },
+
             38 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 
@@ -63,6 +74,11 @@ pub const Parser = struct {
                         .b = @truncate(u8, rgb[2]),
                     },
                 };
+            } else if (slice.len >= 2 and slice[1] == 5) {
+                self.idx += 2;
+                return Attribute{
+                    .@"256_fg" = @truncate(u8, slice[2]),
+                };
             },
 
             48 => if (slice.len >= 5 and slice[1] == 2) {
@@ -80,6 +96,11 @@ pub const Parser = struct {
                         .b = @truncate(u8, rgb[2]),
                     },
                 };
+            } else if (slice.len >= 2 and slice[1] == 5) {
+                self.idx += 2;
+                return Attribute{
+                    .@"256_bg" = @truncate(u8, slice[2]),
+                };
             },
 
             else => {},
@@ -126,3 +147,14 @@ test "sgr: Parser multiple" {
     try testing.expect(p.next() == null);
     try testing.expect(p.next() == null);
 }
+
+test "sgr: bold" {
+    const v = testParse(&[_]u16{1});
+    try testing.expect(v == .bold);
+}
+
+test "sgr: 256 color" {
+    var p: Parser = .{ .params = &[_]u16{ 38, 5, 161, 48, 5, 236 } };
+    try testing.expect(p.next().? == .@"256_fg");
+    try testing.expect(p.next().? == .@"256_bg");
+}

commit 69365b944cea5fde0cbb92084e115f8e1b0cf8f2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 21:29:06 2022 -0700

    implement named 8 colors sgr

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 4c82c829..46d62a15 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -2,6 +2,7 @@
 
 const std = @import("std");
 const testing = std.testing;
+const color = @import("color.zig");
 
 /// Attribute type for SGR
 pub const Attribute = union(enum) {
@@ -20,6 +21,10 @@ pub const Attribute = union(enum) {
     /// Set background color as RGB values.
     direct_color_bg: RGB,
 
+    /// Set the background/foreground as a named color attribute.
+    @"8_bg": color.Name,
+    @"8_fg": color.Name,
+
     /// Set background color as 256-color palette.
     @"256_bg": u8,
 
@@ -59,6 +64,10 @@ pub const Parser = struct {
 
             1 => return Attribute{ .bold = {} },
 
+            30...37 => return Attribute{
+                .@"8_fg" = @intToEnum(color.Name, slice[0] - 30),
+            },
+
             38 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 
@@ -81,6 +90,10 @@ pub const Parser = struct {
                 };
             },
 
+            40...47 => return Attribute{
+                .@"8_bg" = @intToEnum(color.Name, slice[0] - 32),
+            },
+
             48 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 
@@ -153,6 +166,22 @@ test "sgr: bold" {
     try testing.expect(v == .bold);
 }
 
+test "sgr: 8 color" {
+    var p: Parser = .{ .params = &[_]u16{ 31, 43 } };
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .@"8_fg");
+        try testing.expect(v.@"8_fg" == .red);
+    }
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .@"8_bg");
+        try testing.expect(v.@"8_bg" == .bright_yellow);
+    }
+}
+
 test "sgr: 256 color" {
     var p: Parser = .{ .params = &[_]u16{ 38, 5, 161, 48, 5, 236 } };
     try testing.expect(p.next().? == .@"256_fg");

commit 29f88968e95609f7075508b138e89a26a502ec96
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 21:29:49 2022 -0700

    mistake calculated background

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 46d62a15..374eba79 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -91,7 +91,7 @@ pub const Parser = struct {
             },
 
             40...47 => return Attribute{
-                .@"8_bg" = @intToEnum(color.Name, slice[0] - 32),
+                .@"8_bg" = @intToEnum(color.Name, slice[0] - 40),
             },
 
             48 => if (slice.len >= 5 and slice[1] == 2) {
@@ -178,7 +178,7 @@ test "sgr: 8 color" {
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_bg");
-        try testing.expect(v.@"8_bg" == .bright_yellow);
+        try testing.expect(v.@"8_bg" == .yellow);
     }
 }
 

commit 16d4648cf6c9f6baa864cbad11bbde6ceba43e14
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 21:32:00 2022 -0700

    implement bright fg/bg

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 374eba79..cdd15265 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -25,6 +25,10 @@ pub const Attribute = union(enum) {
     @"8_bg": color.Name,
     @"8_fg": color.Name,
 
+    /// Set the background/foreground as a named bright color attribute.
+    @"8_bright_bg": color.Name,
+    @"8_bright_fg": color.Name,
+
     /// Set background color as 256-color palette.
     @"256_bg": u8,
 
@@ -116,6 +120,14 @@ pub const Parser = struct {
                 };
             },
 
+            90...97 => return Attribute{
+                .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 90),
+            },
+
+            100...107 => return Attribute{
+                .@"8_bright_bg" = @intToEnum(color.Name, slice[0] - 92),
+            },
+
             else => {},
         }
 
@@ -167,7 +179,7 @@ test "sgr: bold" {
 }
 
 test "sgr: 8 color" {
-    var p: Parser = .{ .params = &[_]u16{ 31, 43 } };
+    var p: Parser = .{ .params = &[_]u16{ 31, 43, 103 } };
 
     {
         const v = p.next().?;
@@ -180,6 +192,12 @@ test "sgr: 8 color" {
         try testing.expect(v == .@"8_bg");
         try testing.expect(v.@"8_bg" == .yellow);
     }
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .@"8_bright_bg");
+        try testing.expect(v.@"8_bright_bg" == .bright_yellow);
+    }
 }
 
 test "sgr: 256 color" {

commit e325ea1616e166fe91f325a0034aa47cd230c480
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 26 17:37:08 2022 -0700

    parse more SGR attrs

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index cdd15265..b85c87fc 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -15,6 +15,15 @@ pub const Attribute = union(enum) {
     /// Bold the text.
     bold: void,
 
+    /// Underline the text
+    underline: void,
+
+    /// Blink the text
+    blink: void,
+
+    /// Invert fg/bg colors.
+    inverse: void,
+
     /// Set foreground color as RGB values.
     direct_color_fg: RGB,
 
@@ -68,6 +77,12 @@ pub const Parser = struct {
 
             1 => return Attribute{ .bold = {} },
 
+            4 => return Attribute{ .underline = {} },
+
+            5 => return Attribute{ .blink = {} },
+
+            7 => return Attribute{ .inverse = {} },
+
             30...37 => return Attribute{
                 .@"8_fg" = @intToEnum(color.Name, slice[0] - 30),
             },
@@ -178,6 +193,11 @@ test "sgr: bold" {
     try testing.expect(v == .bold);
 }
 
+test "sgr: inverse" {
+    const v = testParse(&[_]u16{7});
+    try testing.expect(v == .inverse);
+}
+
 test "sgr: 8 color" {
     var p: Parser = .{ .params = &[_]u16{ 31, 43, 103 } };
 

commit 28acd99d7dc98f4a6c0efb6fb4bc23ce67cb6ec9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jul 26 09:37:52 2022 -0700

    reset inverse attribute

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index b85c87fc..26d8541e 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -23,6 +23,7 @@ pub const Attribute = union(enum) {
 
     /// Invert fg/bg colors.
     inverse: void,
+    reset_inverse: void,
 
     /// Set foreground color as RGB values.
     direct_color_fg: RGB,
@@ -83,6 +84,8 @@ pub const Parser = struct {
 
             7 => return Attribute{ .inverse = {} },
 
+            27 => return Attribute{ .reset_inverse = {} },
+
             30...37 => return Attribute{
                 .@"8_fg" = @intToEnum(color.Name, slice[0] - 30),
             },
@@ -194,8 +197,15 @@ test "sgr: bold" {
 }
 
 test "sgr: inverse" {
-    const v = testParse(&[_]u16{7});
-    try testing.expect(v == .inverse);
+    {
+        const v = testParse(&[_]u16{7});
+        try testing.expect(v == .inverse);
+    }
+
+    {
+        const v = testParse(&[_]u16{27});
+        try testing.expect(v == .reset_inverse);
+    }
 }
 
 test "sgr: 8 color" {

commit a1130095f877c10b520e6ddf86b627b2c6015eea
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 26 09:27:51 2022 -0700

    note charsets are TODO

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 26d8541e..d2e41d31 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -10,7 +10,13 @@ pub const Attribute = union(enum) {
     unset: void,
 
     /// Unknown attribute, the raw CSI command parameters are here.
-    unknown: []const u16,
+    unknown: struct {
+        /// Full is the full SGR input.
+        full: []const u16,
+
+        /// Partial is the remaining, where we got hung up.
+        partial: []const u16,
+    },
 
     /// Bold the text.
     bold: void,
@@ -149,7 +155,7 @@ pub const Parser = struct {
             else => {},
         }
 
-        return Attribute{ .unknown = slice };
+        return Attribute{ .unknown = .{ .full = self.params, .partial = slice } };
     }
 };
 

commit 4ffd5cd9941d8e55f980ee51907141dc72b2fd71
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 26 09:56:17 2022 -0700

    SGR 39/49 (reset fg/bg, respectively)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index d2e41d31..0aa1b9b1 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -41,6 +41,10 @@ pub const Attribute = union(enum) {
     @"8_bg": color.Name,
     @"8_fg": color.Name,
 
+    /// Reset the fg/bg to their default values.
+    reset_fg: void,
+    reset_bg: void,
+
     /// Set the background/foreground as a named bright color attribute.
     @"8_bright_bg": color.Name,
     @"8_bright_fg": color.Name,
@@ -118,6 +122,8 @@ pub const Parser = struct {
                 };
             },
 
+            39 => return Attribute{ .reset_fg = {} },
+
             40...47 => return Attribute{
                 .@"8_bg" = @intToEnum(color.Name, slice[0] - 40),
             },
@@ -144,6 +150,8 @@ pub const Parser = struct {
                 };
             },
 
+            49 => return Attribute{ .reset_bg = {} },
+
             90...97 => return Attribute{
                 .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 90),
             },

commit dc6fc5c1c3289006de7c621cd30f0be4a7e5250f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 26 11:13:34 2022 -0700

    implement faint colors (SGR 2)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 0aa1b9b1..5c852e4e 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -21,6 +21,9 @@ pub const Attribute = union(enum) {
     /// Bold the text.
     bold: void,
 
+    /// Faint/dim text.
+    faint: void,
+
     /// Underline the text
     underline: void,
 
@@ -88,6 +91,8 @@ pub const Parser = struct {
 
             1 => return Attribute{ .bold = {} },
 
+            2 => return Attribute{ .faint = {} },
+
             4 => return Attribute{ .underline = {} },
 
             5 => return Attribute{ .blink = {} },

commit 8ff98446a9da7b723716fca4ad55685ddb29eb81
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 27 10:55:10 2022 -0700

    sgr parsing bright colors now sets color properly

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 5c852e4e..6d03bb66 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -158,7 +158,8 @@ pub const Parser = struct {
             49 => return Attribute{ .reset_bg = {} },
 
             90...97 => return Attribute{
-                .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 90),
+                // 82 instead of 90 to offset to "bright" colors
+                .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 82),
             },
 
             100...107 => return Attribute{
@@ -228,7 +229,7 @@ test "sgr: inverse" {
 }
 
 test "sgr: 8 color" {
-    var p: Parser = .{ .params = &[_]u16{ 31, 43, 103 } };
+    var p: Parser = .{ .params = &[_]u16{ 31, 43, 90, 103 } };
 
     {
         const v = p.next().?;
@@ -242,6 +243,12 @@ test "sgr: 8 color" {
         try testing.expect(v.@"8_bg" == .yellow);
     }
 
+    {
+        const v = p.next().?;
+        try testing.expect(v == .@"8_bright_fg");
+        try testing.expect(v.@"8_bright_fg" == .bright_black);
+    }
+
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_bright_bg");

commit b18309187e7acfd7a489004f90308424d2c28b7f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 6 15:03:19 2022 -0700

    Strikethrough (#19)
    
    Not as straightforward as it sounds, but not hard either:
    
    * Read OS/2 sfnt tables from TrueType fonts
    * Calculate strikethrough position/thickness (prefer font-advertised if possible, calculate if not)
    * Plumb the SGR code through the terminal state -- does not increase cell memory size
    * Modify the shader to support it
    
    The shaders are getting pretty nasty after this... there's tons of room for improvement. I chose to follow the existing shader style for this to keep it straightforward but will likely soon refactor the shaders.

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 6d03bb66..950cbf32 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -34,6 +34,10 @@ pub const Attribute = union(enum) {
     inverse: void,
     reset_inverse: void,
 
+    /// Strikethrough the text.
+    strikethrough: void,
+    reset_strikethrough: void,
+
     /// Set foreground color as RGB values.
     direct_color_fg: RGB,
 
@@ -99,8 +103,12 @@ pub const Parser = struct {
 
             7 => return Attribute{ .inverse = {} },
 
+            9 => return Attribute{ .strikethrough = {} },
+
             27 => return Attribute{ .reset_inverse = {} },
 
+            29 => return Attribute{ .reset_strikethrough = {} },
+
             30...37 => return Attribute{
                 .@"8_fg" = @intToEnum(color.Name, slice[0] - 30),
             },
@@ -228,6 +236,18 @@ test "sgr: inverse" {
     }
 }
 
+test "sgr: strikethrough" {
+    {
+        const v = testParse(&[_]u16{9});
+        try testing.expect(v == .strikethrough);
+    }
+
+    {
+        const v = testParse(&[_]u16{29});
+        try testing.expect(v == .reset_strikethrough);
+    }
+}
+
 test "sgr: 8 color" {
     var p: Parser = .{ .params = &[_]u16{ 31, 43, 90, 103 } };
 

commit c1a9184ebdfecdbd19f21326ad778daa64389379
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 7 14:04:40 2022 -0800

    sgr: parse italic (render not implemented)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 950cbf32..38f0d139 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -21,6 +21,9 @@ pub const Attribute = union(enum) {
     /// Bold the text.
     bold: void,
 
+    /// Italic text.
+    italic: void,
+
     /// Faint/dim text.
     faint: void,
 
@@ -97,6 +100,8 @@ pub const Parser = struct {
 
             2 => return Attribute{ .faint = {} },
 
+            3 => return Attribute{ .italic = {} },
+
             4 => return Attribute{ .underline = {} },
 
             5 => return Attribute{ .blink = {} },
@@ -224,6 +229,11 @@ test "sgr: bold" {
     try testing.expect(v == .bold);
 }
 
+test "sgr: italic" {
+    const v = testParse(&[_]u16{3});
+    try testing.expect(v == .italic);
+}
+
 test "sgr: inverse" {
     {
         const v = testParse(&[_]u16{7});

commit feccd550c37d754419d9524bab5ba0351b92e058
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 13 21:54:26 2022 -0800

    implement many more reset sgr attributes

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 38f0d139..83569409 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -20,18 +20,23 @@ pub const Attribute = union(enum) {
 
     /// Bold the text.
     bold: void,
+    reset_bold: void,
 
     /// Italic text.
     italic: void,
+    reset_italic: void,
 
     /// Faint/dim text.
+    /// Note: reset faint is the same SGR code as reset bold
     faint: void,
 
     /// Underline the text
     underline: void,
+    reset_underline: void,
 
     /// Blink the text
     blink: void,
+    reset_blink: void,
 
     /// Invert fg/bg colors.
     inverse: void,
@@ -106,10 +111,20 @@ pub const Parser = struct {
 
             5 => return Attribute{ .blink = {} },
 
+            6 => return Attribute{ .blink = {} },
+
             7 => return Attribute{ .inverse = {} },
 
             9 => return Attribute{ .strikethrough = {} },
 
+            22 => return Attribute{ .reset_bold = {} },
+
+            23 => return Attribute{ .reset_italic = {} },
+
+            24 => return Attribute{ .reset_underline = {} },
+
+            25 => return Attribute{ .reset_blink = {} },
+
             27 => return Attribute{ .reset_inverse = {} },
 
             29 => return Attribute{ .reset_strikethrough = {} },
@@ -225,13 +240,56 @@ test "sgr: Parser multiple" {
 }
 
 test "sgr: bold" {
-    const v = testParse(&[_]u16{1});
-    try testing.expect(v == .bold);
+    {
+        const v = testParse(&[_]u16{1});
+        try testing.expect(v == .bold);
+    }
+
+    {
+        const v = testParse(&[_]u16{22});
+        try testing.expect(v == .reset_bold);
+    }
 }
 
 test "sgr: italic" {
-    const v = testParse(&[_]u16{3});
-    try testing.expect(v == .italic);
+    {
+        const v = testParse(&[_]u16{3});
+        try testing.expect(v == .italic);
+    }
+
+    {
+        const v = testParse(&[_]u16{23});
+        try testing.expect(v == .reset_italic);
+    }
+}
+
+test "sgr: underline" {
+    {
+        const v = testParse(&[_]u16{4});
+        try testing.expect(v == .underline);
+    }
+
+    {
+        const v = testParse(&[_]u16{24});
+        try testing.expect(v == .reset_underline);
+    }
+}
+
+test "sgr: blink" {
+    {
+        const v = testParse(&[_]u16{5});
+        try testing.expect(v == .blink);
+    }
+
+    {
+        const v = testParse(&[_]u16{6});
+        try testing.expect(v == .blink);
+    }
+
+    {
+        const v = testParse(&[_]u16{25});
+        try testing.expect(v == .reset_blink);
+    }
 }
 
 test "sgr: inverse" {

commit 584149121dd34a87f1755983a16a903336582bcb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 23 09:10:19 2022 -0800

    use enum for underline styles

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 83569409..8d031c4a 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -31,7 +31,7 @@ pub const Attribute = union(enum) {
     faint: void,
 
     /// Underline the text
-    underline: void,
+    underline: Underline,
     reset_underline: void,
 
     /// Blink the text
@@ -75,6 +75,15 @@ pub const Attribute = union(enum) {
         g: u8,
         b: u8,
     };
+
+    pub const Underline = enum(u3) {
+        none = 0,
+        single = 1,
+        double = 2,
+        curly = 3,
+        dotted = 4,
+        dashed = 5,
+    };
 };
 
 /// Parser parses the attributes from a list of SGR parameters.
@@ -107,7 +116,7 @@ pub const Parser = struct {
 
             3 => return Attribute{ .italic = {} },
 
-            4 => return Attribute{ .underline = {} },
+            4 => return Attribute{ .underline = .single },
 
             5 => return Attribute{ .blink = {} },
 

commit d7fe6a1c47880efe989aa3c3f601e7447de469cf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:30:02 2022 -0800

    fix sgr parsing for underline styles

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 8d031c4a..16620e82 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -91,6 +91,9 @@ pub const Parser = struct {
     params: []const u16,
     idx: usize = 0,
 
+    /// True if the separator is a colon
+    colon: bool = false,
+
     /// Next returns the next attribute or null if there are no more attributes.
     pub fn next(self: *Parser) ?Attribute {
         if (self.idx > self.params.len) return null;
@@ -116,7 +119,35 @@ pub const Parser = struct {
 
             3 => return Attribute{ .italic = {} },
 
-            4 => return Attribute{ .underline = .single },
+            4 => blk: {
+                if (self.colon) {
+                    switch (slice.len) {
+                        // 0 is unreachable because we're here and we read
+                        // an element to get here.
+                        0 => unreachable,
+
+                        // 1 is unreachable because we can't have a colon
+                        // separator if there are no separators.
+                        1 => unreachable,
+
+                        // 2 means we have a specific underline style.
+                        2 => {
+                            self.idx += 1;
+                            switch (slice[1]) {
+                                0 => return Attribute{ .reset_underline = {} },
+                                1 => return Attribute{ .underline = .single },
+                                2 => return Attribute{ .underline = .double },
+                                else => break :blk,
+                            }
+                        },
+
+                        // Colon-separated must only be 2.
+                        else => break :blk,
+                    }
+                }
+
+                return Attribute{ .underline = .single };
+            },
 
             5 => return Attribute{ .blink = {} },
 
@@ -215,6 +246,11 @@ fn testParse(params: []const u16) Attribute {
     return p.next().?;
 }
 
+fn testParseColon(params: []const u16) Attribute {
+    var p: Parser = .{ .params = params, .colon = true };
+    return p.next().?;
+}
+
 test "sgr: Parser" {
     try testing.expect(testParse(&[_]u16{}) == .unset);
     try testing.expect(testParse(&[_]u16{0}) == .unset);
@@ -284,6 +320,25 @@ test "sgr: underline" {
     }
 }
 
+test "sgr: underline styles" {
+    {
+        const v = testParseColon(&[_]u16{ 4, 2 });
+        try testing.expect(v == .underline);
+        try testing.expect(v.underline == .double);
+    }
+
+    {
+        const v = testParseColon(&[_]u16{ 4, 0 });
+        try testing.expect(v == .reset_underline);
+    }
+
+    {
+        const v = testParseColon(&[_]u16{ 4, 1 });
+        try testing.expect(v == .underline);
+        try testing.expect(v.underline == .single);
+    }
+}
+
 test "sgr: blink" {
     {
         const v = testParse(&[_]u16{5});

commit 5045e51b99cff8c8091279059e3f1992e075fc76
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:30:49 2022 -0800

    unknown underline styles render a single underline

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 16620e82..895d5bbe 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -137,7 +137,10 @@ pub const Parser = struct {
                                 0 => return Attribute{ .reset_underline = {} },
                                 1 => return Attribute{ .underline = .single },
                                 2 => return Attribute{ .underline = .double },
-                                else => break :blk,
+
+                                // For unknown underline styles, just render
+                                // a single underline.
+                                else => return Attribute{ .underline = .single },
                             }
                         },
 

commit c2d08c30713aab1e28f19f2f62a47799cee88bc3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:39:12 2022 -0800

    terminal: parse all underline styles

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 895d5bbe..a68eed90 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -137,6 +137,8 @@ pub const Parser = struct {
                                 0 => return Attribute{ .reset_underline = {} },
                                 1 => return Attribute{ .underline = .single },
                                 2 => return Attribute{ .underline = .double },
+                                4 => return Attribute{ .underline = .dotted },
+                                5 => return Attribute{ .underline = .dashed },
 
                                 // For unknown underline styles, just render
                                 // a single underline.
@@ -340,6 +342,18 @@ test "sgr: underline styles" {
         try testing.expect(v == .underline);
         try testing.expect(v.underline == .single);
     }
+
+    {
+        const v = testParseColon(&[_]u16{ 4, 4 });
+        try testing.expect(v == .underline);
+        try testing.expect(v.underline == .dotted);
+    }
+
+    {
+        const v = testParseColon(&[_]u16{ 4, 5 });
+        try testing.expect(v == .underline);
+        try testing.expect(v.underline == .dashed);
+    }
 }
 
 test "sgr: blink" {

commit bfc657395ac0373cf1d93c7ba75d04ee19b4932a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 16:11:15 2022 -0800

    curly underlines

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index a68eed90..eda08ac8 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -137,6 +137,7 @@ pub const Parser = struct {
                                 0 => return Attribute{ .reset_underline = {} },
                                 1 => return Attribute{ .underline = .single },
                                 2 => return Attribute{ .underline = .double },
+                                3 => return Attribute{ .underline = .curly },
                                 4 => return Attribute{ .underline = .dotted },
                                 5 => return Attribute{ .underline = .dashed },
 

commit 28a22fc07f50bc097a6bd0ad1d5f8c2e463a77bb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jun 20 09:24:07 2023 -0700

    various tests to ensure we parse curly underlines correctly

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index eda08ac8..5d57162e 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -344,6 +344,12 @@ test "sgr: underline styles" {
         try testing.expect(v.underline == .single);
     }
 
+    {
+        const v = testParseColon(&[_]u16{ 4, 3 });
+        try testing.expect(v == .underline);
+        try testing.expect(v.underline == .curly);
+    }
+
     {
         const v = testParseColon(&[_]u16{ 4, 4 });
         try testing.expect(v == .underline);

commit b9bc61c0a40660a93f51dc9e5ea90c7428948d17
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jun 20 09:34:29 2023 -0700

    terminal: parse underline color sequences (but do not handle yet)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 5d57162e..c7fcda03 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -33,6 +33,8 @@ pub const Attribute = union(enum) {
     /// Underline the text
     underline: Underline,
     reset_underline: void,
+    underline_color: RGB,
+    reset_underline_color: void,
 
     /// Blink the text
     blink: void,
@@ -210,8 +212,12 @@ pub const Parser = struct {
             48 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 
-                // In the 6-len form, ignore the 3rd param.
-                const rgb = slice[2..5];
+                // In the 6-len form, ignore the 3rd param. Otherwise, use it.
+                const rgb = if (slice.len == 5) slice[2..5] else rgb: {
+                    // Consume one more element
+                    self.idx += 1;
+                    break :rgb slice[3..6];
+                };
 
                 // We use @truncate because the value should be 0 to 255. If
                 // it isn't, the behavior is undefined so we just... truncate it.
@@ -231,6 +237,29 @@ pub const Parser = struct {
 
             49 => return Attribute{ .reset_bg = {} },
 
+            58 => if (slice.len >= 5 and slice[1] == 2) {
+                self.idx += 4;
+
+                // In the 6-len form, ignore the 3rd param. Otherwise, use it.
+                const rgb = if (slice.len == 5) slice[2..5] else rgb: {
+                    // Consume one more element
+                    self.idx += 1;
+                    break :rgb slice[3..6];
+                };
+
+                // We use @truncate because the value should be 0 to 255. If
+                // it isn't, the behavior is undefined so we just... truncate it.
+                return Attribute{
+                    .underline_color = .{
+                        .r = @truncate(u8, rgb[0]),
+                        .g = @truncate(u8, rgb[1]),
+                        .b = @truncate(u8, rgb[2]),
+                    },
+                };
+            },
+
+            59 => return Attribute{ .reset_underline_color = {} },
+
             90...97 => return Attribute{
                 // 82 instead of 90 to offset to "bright" colors
                 .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 82),
@@ -437,3 +466,26 @@ test "sgr: 256 color" {
     try testing.expect(p.next().? == .@"256_fg");
     try testing.expect(p.next().? == .@"256_bg");
 }
+
+test "sgr: underline color" {
+    {
+        const v = testParseColon(&[_]u16{ 58, 2, 1, 2, 3 });
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
+    }
+
+    {
+        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3 });
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
+    }
+}
+
+test "sgr: reset underline color" {
+    var p: Parser = .{ .params = &[_]u16{59} };
+    try testing.expect(p.next().? == .reset_underline_color);
+}

commit 97df179b0466eba8adf46d45d37b3b20dbd85c29
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jun 24 15:04:33 2023 -0700

    terminfo: switch to semicolon SGR 48 to prevent render issues

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index c7fcda03..865518b8 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -467,6 +467,16 @@ test "sgr: 256 color" {
     try testing.expect(p.next().? == .@"256_bg");
 }
 
+test "sgr: 24-bit bg color" {
+    {
+        const v = testParseColon(&[_]u16{ 48, 2, 1, 2, 3 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
+    }
+}
+
 test "sgr: underline color" {
     {
         const v = testParseColon(&[_]u16{ 58, 2, 1, 2, 3 });

commit aafff194f984bd769732c180db2d885b8126588f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 09:19:43 2023 -0700

    terminal: SGR parse invisible (attr 8, 28)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 865518b8..2f127b01 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -1,4 +1,4 @@
-//! SGR (Select Graphic Rendition) attribute parsing and types.
+//! SGR (Select Graphic Rendition) attrinvbute parsing and types.
 
 const std = @import("std");
 const testing = std.testing;
@@ -44,6 +44,10 @@ pub const Attribute = union(enum) {
     inverse: void,
     reset_inverse: void,
 
+    /// Invisible
+    invisible: void,
+    reset_invisible: void,
+
     /// Strikethrough the text.
     strikethrough: void,
     reset_strikethrough: void,
@@ -163,6 +167,8 @@ pub const Parser = struct {
 
             7 => return Attribute{ .inverse = {} },
 
+            8 => return Attribute{ .invisible = {} },
+
             9 => return Attribute{ .strikethrough = {} },
 
             22 => return Attribute{ .reset_bold = {} },
@@ -175,6 +181,8 @@ pub const Parser = struct {
 
             27 => return Attribute{ .reset_inverse = {} },
 
+            28 => return Attribute{ .reset_invisible = {} },
+
             29 => return Attribute{ .reset_strikethrough = {} },
 
             30...37 => return Attribute{
@@ -499,3 +507,9 @@ test "sgr: reset underline color" {
     var p: Parser = .{ .params = &[_]u16{59} };
     try testing.expect(p.next().? == .reset_underline_color);
 }
+
+test "sgr: invisible" {
+    var p: Parser = .{ .params = &[_]u16{ 8, 28 } };
+    try testing.expect(p.next().? == .invisible);
+    try testing.expect(p.next().? == .reset_invisible);
+}

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 2f127b01..5272c1fb 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -186,7 +186,7 @@ pub const Parser = struct {
             29 => return Attribute{ .reset_strikethrough = {} },
 
             30...37 => return Attribute{
-                .@"8_fg" = @intToEnum(color.Name, slice[0] - 30),
+                .@"8_fg" = @enumFromInt(color.Name, slice[0] - 30),
             },
 
             38 => if (slice.len >= 5 and slice[1] == 2) {
@@ -214,7 +214,7 @@ pub const Parser = struct {
             39 => return Attribute{ .reset_fg = {} },
 
             40...47 => return Attribute{
-                .@"8_bg" = @intToEnum(color.Name, slice[0] - 40),
+                .@"8_bg" = @enumFromInt(color.Name, slice[0] - 40),
             },
 
             48 => if (slice.len >= 5 and slice[1] == 2) {
@@ -270,11 +270,11 @@ pub const Parser = struct {
 
             90...97 => return Attribute{
                 // 82 instead of 90 to offset to "bright" colors
-                .@"8_bright_fg" = @intToEnum(color.Name, slice[0] - 82),
+                .@"8_bright_fg" = @enumFromInt(color.Name, slice[0] - 82),
             },
 
             100...107 => return Attribute{
-                .@"8_bright_bg" = @intToEnum(color.Name, slice[0] - 92),
+                .@"8_bright_bg" = @enumFromInt(color.Name, slice[0] - 92),
             },
 
             else => {},

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 5272c1fb..4ba19209 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -186,7 +186,7 @@ pub const Parser = struct {
             29 => return Attribute{ .reset_strikethrough = {} },
 
             30...37 => return Attribute{
-                .@"8_fg" = @enumFromInt(color.Name, slice[0] - 30),
+                .@"8_fg" = @enumFromInt(slice[0] - 30),
             },
 
             38 => if (slice.len >= 5 and slice[1] == 2) {
@@ -199,22 +199,22 @@ pub const Parser = struct {
                 // it isn't, the behavior is undefined so we just... truncate it.
                 return Attribute{
                     .direct_color_fg = .{
-                        .r = @truncate(u8, rgb[0]),
-                        .g = @truncate(u8, rgb[1]),
-                        .b = @truncate(u8, rgb[2]),
+                        .r = @truncate(rgb[0]),
+                        .g = @truncate(rgb[1]),
+                        .b = @truncate(rgb[2]),
                     },
                 };
             } else if (slice.len >= 2 and slice[1] == 5) {
                 self.idx += 2;
                 return Attribute{
-                    .@"256_fg" = @truncate(u8, slice[2]),
+                    .@"256_fg" = @truncate(slice[2]),
                 };
             },
 
             39 => return Attribute{ .reset_fg = {} },
 
             40...47 => return Attribute{
-                .@"8_bg" = @enumFromInt(color.Name, slice[0] - 40),
+                .@"8_bg" = @enumFromInt(slice[0] - 40),
             },
 
             48 => if (slice.len >= 5 and slice[1] == 2) {
@@ -231,15 +231,15 @@ pub const Parser = struct {
                 // it isn't, the behavior is undefined so we just... truncate it.
                 return Attribute{
                     .direct_color_bg = .{
-                        .r = @truncate(u8, rgb[0]),
-                        .g = @truncate(u8, rgb[1]),
-                        .b = @truncate(u8, rgb[2]),
+                        .r = @truncate(rgb[0]),
+                        .g = @truncate(rgb[1]),
+                        .b = @truncate(rgb[2]),
                     },
                 };
             } else if (slice.len >= 2 and slice[1] == 5) {
                 self.idx += 2;
                 return Attribute{
-                    .@"256_bg" = @truncate(u8, slice[2]),
+                    .@"256_bg" = @truncate(slice[2]),
                 };
             },
 
@@ -259,9 +259,9 @@ pub const Parser = struct {
                 // it isn't, the behavior is undefined so we just... truncate it.
                 return Attribute{
                     .underline_color = .{
-                        .r = @truncate(u8, rgb[0]),
-                        .g = @truncate(u8, rgb[1]),
-                        .b = @truncate(u8, rgb[2]),
+                        .r = @truncate(rgb[0]),
+                        .g = @truncate(rgb[1]),
+                        .b = @truncate(rgb[2]),
                     },
                 };
             },
@@ -270,11 +270,11 @@ pub const Parser = struct {
 
             90...97 => return Attribute{
                 // 82 instead of 90 to offset to "bright" colors
-                .@"8_bright_fg" = @enumFromInt(color.Name, slice[0] - 82),
+                .@"8_bright_fg" = @enumFromInt(slice[0] - 82),
             },
 
             100...107 => return Attribute{
-                .@"8_bright_bg" = @enumFromInt(color.Name, slice[0] - 92),
+                .@"8_bright_bg" = @enumFromInt(slice[0] - 92),
             },
 
             else => {},

commit 3391908a82cdf543e63eb2fbf337c980d4275e8f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 30 08:48:57 2023 -0700

    terminal: get rid of duplicate RGB struct

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 4ba19209..1fcb9ec4 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -33,7 +33,7 @@ pub const Attribute = union(enum) {
     /// Underline the text
     underline: Underline,
     reset_underline: void,
-    underline_color: RGB,
+    underline_color: color.RGB,
     reset_underline_color: void,
 
     /// Blink the text
@@ -53,10 +53,10 @@ pub const Attribute = union(enum) {
     reset_strikethrough: void,
 
     /// Set foreground color as RGB values.
-    direct_color_fg: RGB,
+    direct_color_fg: color.RGB,
 
     /// Set background color as RGB values.
-    direct_color_bg: RGB,
+    direct_color_bg: color.RGB,
 
     /// Set the background/foreground as a named color attribute.
     @"8_bg": color.Name,
@@ -76,12 +76,6 @@ pub const Attribute = union(enum) {
     /// Set foreground color as 256-color palette.
     @"256_fg": u8,
 
-    pub const RGB = struct {
-        r: u8,
-        g: u8,
-        b: u8,
-    };
-
     pub const Underline = enum(u3) {
         none = 0,
         single = 1,

commit c18527384e3bbbeaf0d72fbc070705de055f3efb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 30 14:58:44 2023 -0700

    terminal: sgr parsing doesn't parse 4-form 48, allows unstyled underline
    
    Fixes #362
    
    We previously tried to parse 4-form 48, but as far as I can tell this is
    never used anyways and in this real world scenario it expected us to
    parse a 3-form followed by an underline. This fixes the real world
    scenario as priority and adds a test.
    
    This also fixes an issue where single form colon underline may actually
    exist, again from a real world scenario.

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 1fcb9ec4..63477941 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -126,9 +126,8 @@ pub const Parser = struct {
                         // an element to get here.
                         0 => unreachable,
 
-                        // 1 is unreachable because we can't have a colon
-                        // separator if there are no separators.
-                        1 => unreachable,
+                        // 1 is possible if underline is the last element.
+                        1 => return Attribute{ .underline = .single },
 
                         // 2 means we have a specific underline style.
                         2 => {
@@ -214,12 +213,8 @@ pub const Parser = struct {
             48 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 
-                // In the 6-len form, ignore the 3rd param. Otherwise, use it.
-                const rgb = if (slice.len == 5) slice[2..5] else rgb: {
-                    // Consume one more element
-                    self.idx += 1;
-                    break :rgb slice[3..6];
-                };
+                // We only support the 5-len form.
+                const rgb = slice[2..5];
 
                 // We use @truncate because the value should be 0 to 255. If
                 // it isn't, the behavior is undefined so we just... truncate it.
@@ -507,3 +502,33 @@ test "sgr: invisible" {
     try testing.expect(p.next().? == .invisible);
     try testing.expect(p.next().? == .reset_invisible);
 }
+
+test "sgr: underline, bg, and fg" {
+    var p: Parser = .{
+        .params = &[_]u16{ 4, 38, 2, 255, 247, 219, 48, 2, 242, 93, 147, 4 },
+    };
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline);
+        try testing.expectEqual(Attribute.Underline.single, v.underline);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 255), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 247), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 219), v.direct_color_fg.b);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 242), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 93), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 147), v.direct_color_bg.b);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline);
+        try testing.expectEqual(Attribute.Underline.single, v.underline);
+    }
+}

commit d28e6739c7b7bd329e4cc53c886cfc4dcb5f7da4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Oct 27 09:25:16 2023 -0700

    terminal: sgr direct color fg missing color doesn't crash

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 63477941..ecec3ed5 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -197,7 +197,7 @@ pub const Parser = struct {
                         .b = @truncate(rgb[2]),
                     },
                 };
-            } else if (slice.len >= 2 and slice[1] == 5) {
+            } else if (slice.len >= 3 and slice[1] == 5) {
                 self.idx += 2;
                 return Attribute{
                     .@"256_fg" = @truncate(slice[2]),
@@ -532,3 +532,9 @@ test "sgr: underline, bg, and fg" {
         try testing.expectEqual(Attribute.Underline.single, v.underline);
     }
 }
+
+test "sgr: direct color fg missing color" {
+    // This used to crash
+    var p: Parser = .{ .params = &[_]u16{ 38, 5 }, .colon = false };
+    while (p.next()) |_| {}
+}

commit 306689b8a44ed0615b6ba6998229734548449be7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Oct 27 09:27:45 2023 -0700

    terminal: sgr direct bg also had wrong slice len

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index ecec3ed5..9b3dc7a2 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -225,7 +225,7 @@ pub const Parser = struct {
                         .b = @truncate(rgb[2]),
                     },
                 };
-            } else if (slice.len >= 2 and slice[1] == 5) {
+            } else if (slice.len >= 3 and slice[1] == 5) {
                 self.idx += 2;
                 return Attribute{
                     .@"256_bg" = @truncate(slice[2]),
@@ -538,3 +538,9 @@ test "sgr: direct color fg missing color" {
     var p: Parser = .{ .params = &[_]u16{ 38, 5 }, .colon = false };
     while (p.next()) |_| {}
 }
+
+test "sgr: direct color bg missing color" {
+    // This used to crash
+    var p: Parser = .{ .params = &[_]u16{ 48, 5 }, .colon = false };
+    while (p.next()) |_| {}
+}

commit 84a0e4e62db1b51d9f158a9a8159f0429278e4c6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Dec 7 14:57:07 2023 -0800

    terminal: support `58;5` for setting underline color via 256 palette
    
    Fixes #1013

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 9b3dc7a2..b23bd151 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -34,6 +34,7 @@ pub const Attribute = union(enum) {
     underline: Underline,
     reset_underline: void,
     underline_color: color.RGB,
+    @"256_underline_color": u8,
     reset_underline_color: void,
 
     /// Blink the text
@@ -253,6 +254,11 @@ pub const Parser = struct {
                         .b = @truncate(rgb[2]),
                     },
                 };
+            } else if (slice.len >= 3 and slice[1] == 5) {
+                self.idx += 2;
+                return Attribute{
+                    .@"256_underline_color" = @truncate(slice[2]),
+                };
             },
 
             59 => return Attribute{ .reset_underline_color = {} },
@@ -462,6 +468,13 @@ test "sgr: 256 color" {
     var p: Parser = .{ .params = &[_]u16{ 38, 5, 161, 48, 5, 236 } };
     try testing.expect(p.next().? == .@"256_fg");
     try testing.expect(p.next().? == .@"256_bg");
+    try testing.expect(p.next() == null);
+}
+
+test "sgr: 256 color underline" {
+    var p: Parser = .{ .params = &[_]u16{ 58, 5, 9 } };
+    try testing.expect(p.next().? == .@"256_underline_color");
+    try testing.expect(p.next() == null);
 }
 
 test "sgr: 24-bit bg color" {

commit 93643d1741bd3eec1835d415318a87c7f2121162
Author: Tim Culverhouse <tim@timculverhouse.com>
Date:   Fri Sep 27 22:22:22 2024 -0500

    sgr: add support for legacy double underline
    
    SGR 21 is defined to be a double underline. This behavior is common
    among many terminals, notably xterm.
    
    References: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Functions-using-CSI-_-ordered-by-the-final-character_s_

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index b23bd151..67a4c05e 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -165,6 +165,8 @@ pub const Parser = struct {
 
             9 => return Attribute{ .strikethrough = {} },
 
+            21 => return Attribute{ .underline = .double },
+
             22 => return Attribute{ .reset_bold = {} },
 
             23 => return Attribute{ .reset_italic = {} },

commit 4496e7d314adf883726ec821753d824e34337069
Author: Marijn Besseling <njirambem@gmail.com>
Date:   Sun Oct 20 12:51:18 2024 +0200

    implement overline decoration (SGR 53/55)

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 67a4c05e..7d602714 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -37,6 +37,10 @@ pub const Attribute = union(enum) {
     @"256_underline_color": u8,
     reset_underline_color: void,
 
+    // Overline the text
+    overline: void,
+    reset_overline: void,
+
     /// Blink the text
     blink: void,
     reset_blink: void,
@@ -237,6 +241,9 @@ pub const Parser = struct {
 
             49 => return Attribute{ .reset_bg = {} },
 
+            53 => return Attribute{ .overline = {} },
+            55 => return Attribute{ .reset_overline = {} },
+
             58 => if (slice.len >= 5 and slice[1] == 2) {
                 self.idx += 4;
 

commit 5ba8fee38a8f18f6488d58673d2128d801c4f0f4
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Tue Dec 31 14:35:07 2024 -0500

    test/terminal: add failing sgr direct color parsing test
    
    Behavior checked against xterm

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 7d602714..7dca98c9 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -566,3 +566,59 @@ test "sgr: direct color bg missing color" {
     var p: Parser = .{ .params = &[_]u16{ 48, 5 }, .colon = false };
     while (p.next()) |_| {}
 }
+
+test "sgr: direct fg/bg/underline ignore optional color space" {
+    // These behaviors have been verified against xterm.
+
+    // Colon version should skip the optional color space identifier
+    {
+        // 3 8 : 2 : Pi : Pr : Pg : Pb
+        const v = testParseColon(&[_]u16{ 38, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
+    }
+    {
+        // 4 8 : 2 : Pi : Pr : Pg : Pb
+        const v = testParseColon(&[_]u16{ 48, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
+    }
+    {
+        // 5 8 : 2 : Pi : Pr : Pg : Pb
+        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
+    }
+
+    // Semicolon version should not parse optional color space identifier
+    {
+        // 3 8 ; 2 ; Pr ; Pg ; Pb
+        const v = testParse(&[_]u16{ 38, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 0), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.b);
+    }
+    {
+        // 4 8 ; 2 ; Pr ; Pg ; Pb
+        const v = testParse(&[_]u16{ 48, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 0), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.b);
+    }
+    {
+        // 5 8 ; 2 ; Pr ; Pg ; Pb
+        const v = testParse(&[_]u16{ 58, 2, 0, 1, 2, 3, 4 });
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 0), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 1), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 2), v.underline_color.b);
+    }
+}

commit 4543cdeac867bff23a2239ba5667639fbbfb8a88
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Tue Dec 31 14:37:23 2024 -0500

    fix(terminal): correct SGR direct color parsing

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 7dca98c9..cdf39657 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -189,26 +189,39 @@ pub const Parser = struct {
                 .@"8_fg" = @enumFromInt(slice[0] - 30),
             },
 
-            38 => if (slice.len >= 5 and slice[1] == 2) {
-                self.idx += 4;
-
-                // In the 6-len form, ignore the 3rd param.
-                const rgb = slice[2..5];
-
-                // We use @truncate because the value should be 0 to 255. If
-                // it isn't, the behavior is undefined so we just... truncate it.
-                return Attribute{
-                    .direct_color_fg = .{
-                        .r = @truncate(rgb[0]),
-                        .g = @truncate(rgb[1]),
-                        .b = @truncate(rgb[2]),
-                    },
-                };
-            } else if (slice.len >= 3 and slice[1] == 5) {
-                self.idx += 2;
-                return Attribute{
-                    .@"256_fg" = @truncate(slice[2]),
-                };
+            38 => if (slice.len >= 2) switch (slice[1]) {
+                // `2` indicates direct-color (r, g, b).
+                // We need at least 3 more params for this to make sense.
+                2 => if (slice.len >= 5) {
+                    self.idx += 4;
+                    // When a colon separator is used, there may or may not be
+                    // a color space identifier as the third param, which we
+                    // need to ignore (it has no standardized behavior).
+                    const rgb = if (slice.len == 5 or !self.colon)
+                        slice[2..5]
+                    else rgb: {
+                        self.idx += 1;
+                        break :rgb slice[3..6];
+                    };
+
+                    // We use @truncate because the value should be 0 to 255. If
+                    // it isn't, the behavior is undefined so we just... truncate it.
+                    return Attribute{
+                        .direct_color_fg = .{
+                            .r = @truncate(rgb[0]),
+                            .g = @truncate(rgb[1]),
+                            .b = @truncate(rgb[2]),
+                        },
+                    };
+                },
+                // `5` indicates indexed color.
+                5 => if (slice.len >= 3) {
+                    self.idx += 2;
+                    return Attribute{
+                        .@"256_fg" = @truncate(slice[2]),
+                    };
+                },
+                else => {},
             },
 
             39 => return Attribute{ .reset_fg = {} },
@@ -217,26 +230,39 @@ pub const Parser = struct {
                 .@"8_bg" = @enumFromInt(slice[0] - 40),
             },
 
-            48 => if (slice.len >= 5 and slice[1] == 2) {
-                self.idx += 4;
-
-                // We only support the 5-len form.
-                const rgb = slice[2..5];
-
-                // We use @truncate because the value should be 0 to 255. If
-                // it isn't, the behavior is undefined so we just... truncate it.
-                return Attribute{
-                    .direct_color_bg = .{
-                        .r = @truncate(rgb[0]),
-                        .g = @truncate(rgb[1]),
-                        .b = @truncate(rgb[2]),
-                    },
-                };
-            } else if (slice.len >= 3 and slice[1] == 5) {
-                self.idx += 2;
-                return Attribute{
-                    .@"256_bg" = @truncate(slice[2]),
-                };
+            48 => if (slice.len >= 2) switch (slice[1]) {
+                // `2` indicates direct-color (r, g, b).
+                // We need at least 3 more params for this to make sense.
+                2 => if (slice.len >= 5) {
+                    self.idx += 4;
+                    // When a colon separator is used, there may or may not be
+                    // a color space identifier as the third param, which we
+                    // need to ignore (it has no standardized behavior).
+                    const rgb = if (slice.len == 5 or !self.colon)
+                        slice[2..5]
+                    else rgb: {
+                        self.idx += 1;
+                        break :rgb slice[3..6];
+                    };
+
+                    // We use @truncate because the value should be 0 to 255. If
+                    // it isn't, the behavior is undefined so we just... truncate it.
+                    return Attribute{
+                        .direct_color_bg = .{
+                            .r = @truncate(rgb[0]),
+                            .g = @truncate(rgb[1]),
+                            .b = @truncate(rgb[2]),
+                        },
+                    };
+                },
+                // `5` indicates indexed color.
+                5 => if (slice.len >= 3) {
+                    self.idx += 2;
+                    return Attribute{
+                        .@"256_bg" = @truncate(slice[2]),
+                    };
+                },
+                else => {},
             },
 
             49 => return Attribute{ .reset_bg = {} },
@@ -244,30 +270,39 @@ pub const Parser = struct {
             53 => return Attribute{ .overline = {} },
             55 => return Attribute{ .reset_overline = {} },
 
-            58 => if (slice.len >= 5 and slice[1] == 2) {
-                self.idx += 4;
-
-                // In the 6-len form, ignore the 3rd param. Otherwise, use it.
-                const rgb = if (slice.len == 5) slice[2..5] else rgb: {
-                    // Consume one more element
-                    self.idx += 1;
-                    break :rgb slice[3..6];
-                };
-
-                // We use @truncate because the value should be 0 to 255. If
-                // it isn't, the behavior is undefined so we just... truncate it.
-                return Attribute{
-                    .underline_color = .{
-                        .r = @truncate(rgb[0]),
-                        .g = @truncate(rgb[1]),
-                        .b = @truncate(rgb[2]),
-                    },
-                };
-            } else if (slice.len >= 3 and slice[1] == 5) {
-                self.idx += 2;
-                return Attribute{
-                    .@"256_underline_color" = @truncate(slice[2]),
-                };
+            58 => if (slice.len >= 2) switch (slice[1]) {
+                // `2` indicates direct-color (r, g, b).
+                // We need at least 3 more params for this to make sense.
+                2 => if (slice.len >= 5) {
+                    self.idx += 4;
+                    // When a colon separator is used, there may or may not be
+                    // a color space identifier as the third param, which we
+                    // need to ignore (it has no standardized behavior).
+                    const rgb = if (slice.len == 5 or !self.colon)
+                        slice[2..5]
+                    else rgb: {
+                        self.idx += 1;
+                        break :rgb slice[3..6];
+                    };
+
+                    // We use @truncate because the value should be 0 to 255. If
+                    // it isn't, the behavior is undefined so we just... truncate it.
+                    return Attribute{
+                        .underline_color = .{
+                            .r = @truncate(rgb[0]),
+                            .g = @truncate(rgb[1]),
+                            .b = @truncate(rgb[2]),
+                        },
+                    };
+                },
+                // `5` indicates indexed color.
+                5 => if (slice.len >= 3) {
+                    self.idx += 2;
+                    return Attribute{
+                        .@"256_underline_color" = @truncate(slice[2]),
+                    };
+                },
+                else => {},
             },
 
             59 => return Attribute{ .reset_underline_color = {} },

commit 7aed08be407ee22993974cb8eaa1a416c2c8c6bf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jan 13 10:52:29 2025 -0800

    terminal: keep track of colon vs semicolon state in CSI params
    
    Fixes #5022
    
    The CSI SGR sequence (CSI m) is unique in that its the only CSI sequence
    that allows colons as delimiters between some parameters, and the colon
    vs. semicolon changes the semantics of the parameters.
    
    Previously, Ghostty assumed that an SGR sequence was either all colons
    or all semicolons, and would change its behavior based on the first
    delimiter it encountered.
    
    This is incorrect. It is perfectly valid for an SGR sequence to have
    both colons and semicolons as delimiters. For example, Kakoune sends
    the following:
    
        ;4:3;38;2;175;175;215;58:2::190:80:70m
    
    This is equivalent to:
    
      - unset (0)
      - curly underline (4:3)
      - foreground color (38;2;175;175;215)
      - underline color (58:2::190:80:70)
    
    This commit changes the behavior of Ghostty to track the delimiter per
    parameter, rather than per sequence. It also updates the SGR parser to
    be more robust and handle the various edge cases that can occur. Tests
    were added for the new cases.

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index cdf39657..52bfb2c3 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -1,13 +1,17 @@
 //! SGR (Select Graphic Rendition) attrinvbute parsing and types.
 
 const std = @import("std");
+const assert = std.debug.assert;
 const testing = std.testing;
 const color = @import("color.zig");
+const SepList = @import("Parser.zig").Action.CSI.SepList;
 
 /// Attribute type for SGR
 pub const Attribute = union(enum) {
+    pub const Tag = std.meta.FieldEnum(Attribute);
+
     /// Unset all attributes
-    unset: void,
+    unset,
 
     /// Unknown attribute, the raw CSI command parameters are here.
     unknown: struct {
@@ -19,43 +23,43 @@ pub const Attribute = union(enum) {
     },
 
     /// Bold the text.
-    bold: void,
-    reset_bold: void,
+    bold,
+    reset_bold,
 
     /// Italic text.
-    italic: void,
-    reset_italic: void,
+    italic,
+    reset_italic,
 
     /// Faint/dim text.
     /// Note: reset faint is the same SGR code as reset bold
-    faint: void,
+    faint,
 
     /// Underline the text
     underline: Underline,
-    reset_underline: void,
+    reset_underline,
     underline_color: color.RGB,
     @"256_underline_color": u8,
-    reset_underline_color: void,
+    reset_underline_color,
 
     // Overline the text
-    overline: void,
-    reset_overline: void,
+    overline,
+    reset_overline,
 
     /// Blink the text
-    blink: void,
-    reset_blink: void,
+    blink,
+    reset_blink,
 
     /// Invert fg/bg colors.
-    inverse: void,
-    reset_inverse: void,
+    inverse,
+    reset_inverse,
 
     /// Invisible
-    invisible: void,
-    reset_invisible: void,
+    invisible,
+    reset_invisible,
 
     /// Strikethrough the text.
-    strikethrough: void,
-    reset_strikethrough: void,
+    strikethrough,
+    reset_strikethrough,
 
     /// Set foreground color as RGB values.
     direct_color_fg: color.RGB,
@@ -68,8 +72,8 @@ pub const Attribute = union(enum) {
     @"8_fg": color.Name,
 
     /// Reset the fg/bg to their default values.
-    reset_fg: void,
-    reset_bg: void,
+    reset_fg,
+    reset_bg,
 
     /// Set the background/foreground as a named bright color attribute.
     @"8_bright_bg": color.Name,
@@ -94,11 +98,9 @@ pub const Attribute = union(enum) {
 /// Parser parses the attributes from a list of SGR parameters.
 pub const Parser = struct {
     params: []const u16,
+    params_sep: SepList = SepList.initEmpty(),
     idx: usize = 0,
 
-    /// True if the separator is a colon
-    colon: bool = false,
-
     /// Next returns the next attribute or null if there are no more attributes.
     pub fn next(self: *Parser) ?Attribute {
         if (self.idx > self.params.len) return null;
@@ -106,220 +108,261 @@ pub const Parser = struct {
         // Implicitly means unset
         if (self.params.len == 0) {
             self.idx += 1;
-            return Attribute{ .unset = {} };
+            return .unset;
         }
 
         const slice = self.params[self.idx..self.params.len];
+        const colon = self.params_sep.isSet(self.idx);
         self.idx += 1;
 
         // Our last one will have an idx be the last value.
         if (slice.len == 0) return null;
 
+        // If we have a colon separator then we need to ensure we're
+        // parsing a value that allows it.
+        if (colon) switch (slice[0]) {
+            4, 38, 48, 58 => {},
+
+            else => {
+                // Consume all the colon separated values.
+                const start = self.idx;
+                while (self.params_sep.isSet(self.idx)) self.idx += 1;
+                self.idx += 1;
+                return .{ .unknown = .{
+                    .full = self.params,
+                    .partial = slice[0 .. self.idx - start + 1],
+                } };
+            },
+        };
+
         switch (slice[0]) {
-            0 => return Attribute{ .unset = {} },
-
-            1 => return Attribute{ .bold = {} },
-
-            2 => return Attribute{ .faint = {} },
-
-            3 => return Attribute{ .italic = {} },
-
-            4 => blk: {
-                if (self.colon) {
-                    switch (slice.len) {
-                        // 0 is unreachable because we're here and we read
-                        // an element to get here.
-                        0 => unreachable,
-
-                        // 1 is possible if underline is the last element.
-                        1 => return Attribute{ .underline = .single },
-
-                        // 2 means we have a specific underline style.
-                        2 => {
-                            self.idx += 1;
-                            switch (slice[1]) {
-                                0 => return Attribute{ .reset_underline = {} },
-                                1 => return Attribute{ .underline = .single },
-                                2 => return Attribute{ .underline = .double },
-                                3 => return Attribute{ .underline = .curly },
-                                4 => return Attribute{ .underline = .dotted },
-                                5 => return Attribute{ .underline = .dashed },
-
-                                // For unknown underline styles, just render
-                                // a single underline.
-                                else => return Attribute{ .underline = .single },
-                            }
-                        },
-
-                        // Colon-separated must only be 2.
-                        else => break :blk,
+            0 => return .unset,
+
+            1 => return .bold,
+
+            2 => return .faint,
+
+            3 => return .italic,
+
+            4 => underline: {
+                if (colon) {
+                    assert(slice.len >= 2);
+                    if (self.isColon()) {
+                        self.consumeUnknownColon();
+                        break :underline;
+                    }
+
+                    self.idx += 1;
+                    switch (slice[1]) {
+                        0 => return .reset_underline,
+                        1 => return .{ .underline = .single },
+                        2 => return .{ .underline = .double },
+                        3 => return .{ .underline = .curly },
+                        4 => return .{ .underline = .dotted },
+                        5 => return .{ .underline = .dashed },
+
+                        // For unknown underline styles, just render
+                        // a single underline.
+                        else => return .{ .underline = .single },
                     }
                 }
 
-                return Attribute{ .underline = .single };
+                return .{ .underline = .single };
             },
 
-            5 => return Attribute{ .blink = {} },
+            5 => return .blink,
 
-            6 => return Attribute{ .blink = {} },
+            6 => return .blink,
 
-            7 => return Attribute{ .inverse = {} },
+            7 => return .inverse,
 
-            8 => return Attribute{ .invisible = {} },
+            8 => return .invisible,
 
-            9 => return Attribute{ .strikethrough = {} },
+            9 => return .strikethrough,
 
-            21 => return Attribute{ .underline = .double },
+            21 => return .{ .underline = .double },
 
-            22 => return Attribute{ .reset_bold = {} },
+            22 => return .reset_bold,
 
-            23 => return Attribute{ .reset_italic = {} },
+            23 => return .reset_italic,
 
-            24 => return Attribute{ .reset_underline = {} },
+            24 => return .reset_underline,
 
-            25 => return Attribute{ .reset_blink = {} },
+            25 => return .reset_blink,
 
-            27 => return Attribute{ .reset_inverse = {} },
+            27 => return .reset_inverse,
 
-            28 => return Attribute{ .reset_invisible = {} },
+            28 => return .reset_invisible,
 
-            29 => return Attribute{ .reset_strikethrough = {} },
+            29 => return .reset_strikethrough,
 
-            30...37 => return Attribute{
+            30...37 => return .{
                 .@"8_fg" = @enumFromInt(slice[0] - 30),
             },
 
             38 => if (slice.len >= 2) switch (slice[1]) {
                 // `2` indicates direct-color (r, g, b).
                 // We need at least 3 more params for this to make sense.
-                2 => if (slice.len >= 5) {
-                    self.idx += 4;
-                    // When a colon separator is used, there may or may not be
-                    // a color space identifier as the third param, which we
-                    // need to ignore (it has no standardized behavior).
-                    const rgb = if (slice.len == 5 or !self.colon)
-                        slice[2..5]
-                    else rgb: {
-                        self.idx += 1;
-                        break :rgb slice[3..6];
-                    };
+                2 => if (self.parseDirectColor(
+                    .direct_color_fg,
+                    slice,
+                    colon,
+                )) |v| return v,
 
-                    // We use @truncate because the value should be 0 to 255. If
-                    // it isn't, the behavior is undefined so we just... truncate it.
-                    return Attribute{
-                        .direct_color_fg = .{
-                            .r = @truncate(rgb[0]),
-                            .g = @truncate(rgb[1]),
-                            .b = @truncate(rgb[2]),
-                        },
-                    };
-                },
                 // `5` indicates indexed color.
                 5 => if (slice.len >= 3) {
                     self.idx += 2;
-                    return Attribute{
+                    return .{
                         .@"256_fg" = @truncate(slice[2]),
                     };
                 },
                 else => {},
             },
 
-            39 => return Attribute{ .reset_fg = {} },
+            39 => return .reset_fg,
 
-            40...47 => return Attribute{
+            40...47 => return .{
                 .@"8_bg" = @enumFromInt(slice[0] - 40),
             },
 
             48 => if (slice.len >= 2) switch (slice[1]) {
                 // `2` indicates direct-color (r, g, b).
                 // We need at least 3 more params for this to make sense.
-                2 => if (slice.len >= 5) {
-                    self.idx += 4;
-                    // When a colon separator is used, there may or may not be
-                    // a color space identifier as the third param, which we
-                    // need to ignore (it has no standardized behavior).
-                    const rgb = if (slice.len == 5 or !self.colon)
-                        slice[2..5]
-                    else rgb: {
-                        self.idx += 1;
-                        break :rgb slice[3..6];
-                    };
+                2 => if (self.parseDirectColor(
+                    .direct_color_bg,
+                    slice,
+                    colon,
+                )) |v| return v,
 
-                    // We use @truncate because the value should be 0 to 255. If
-                    // it isn't, the behavior is undefined so we just... truncate it.
-                    return Attribute{
-                        .direct_color_bg = .{
-                            .r = @truncate(rgb[0]),
-                            .g = @truncate(rgb[1]),
-                            .b = @truncate(rgb[2]),
-                        },
-                    };
-                },
                 // `5` indicates indexed color.
                 5 => if (slice.len >= 3) {
                     self.idx += 2;
-                    return Attribute{
+                    return .{
                         .@"256_bg" = @truncate(slice[2]),
                     };
                 },
                 else => {},
             },
 
-            49 => return Attribute{ .reset_bg = {} },
+            49 => return .reset_bg,
 
-            53 => return Attribute{ .overline = {} },
-            55 => return Attribute{ .reset_overline = {} },
+            53 => return .overline,
+            55 => return .reset_overline,
 
             58 => if (slice.len >= 2) switch (slice[1]) {
                 // `2` indicates direct-color (r, g, b).
                 // We need at least 3 more params for this to make sense.
-                2 => if (slice.len >= 5) {
-                    self.idx += 4;
-                    // When a colon separator is used, there may or may not be
-                    // a color space identifier as the third param, which we
-                    // need to ignore (it has no standardized behavior).
-                    const rgb = if (slice.len == 5 or !self.colon)
-                        slice[2..5]
-                    else rgb: {
-                        self.idx += 1;
-                        break :rgb slice[3..6];
-                    };
+                2 => if (self.parseDirectColor(
+                    .underline_color,
+                    slice,
+                    colon,
+                )) |v| return v,
 
-                    // We use @truncate because the value should be 0 to 255. If
-                    // it isn't, the behavior is undefined so we just... truncate it.
-                    return Attribute{
-                        .underline_color = .{
-                            .r = @truncate(rgb[0]),
-                            .g = @truncate(rgb[1]),
-                            .b = @truncate(rgb[2]),
-                        },
-                    };
-                },
                 // `5` indicates indexed color.
                 5 => if (slice.len >= 3) {
                     self.idx += 2;
-                    return Attribute{
+                    return .{
                         .@"256_underline_color" = @truncate(slice[2]),
                     };
                 },
                 else => {},
             },
 
-            59 => return Attribute{ .reset_underline_color = {} },
+            59 => return .reset_underline_color,
 
-            90...97 => return Attribute{
+            90...97 => return .{
                 // 82 instead of 90 to offset to "bright" colors
                 .@"8_bright_fg" = @enumFromInt(slice[0] - 82),
             },
 
-            100...107 => return Attribute{
+            100...107 => return .{
                 .@"8_bright_bg" = @enumFromInt(slice[0] - 92),
             },
 
             else => {},
         }
 
-        return Attribute{ .unknown = .{ .full = self.params, .partial = slice } };
+        return .{ .unknown = .{ .full = self.params, .partial = slice } };
+    }
+
+    fn parseDirectColor(
+        self: *Parser,
+        comptime tag: Attribute.Tag,
+        slice: []const u16,
+        colon: bool,
+    ) ?Attribute {
+        // Any direct color style must have at least 5 values.
+        if (slice.len < 5) return null;
+
+        // Only used for direct color sets (38, 48, 58) and subparam 2.
+        assert(slice[1] == 2);
+
+        // Note: We use @truncate because the value should be 0 to 255. If
+        // it isn't, the behavior is undefined so we just... truncate it.
+
+        // If we don't have a colon, then we expect exactly 3 semicolon
+        // separated values.
+        if (!colon) {
+            self.idx += 4;
+            return @unionInit(Attribute, @tagName(tag), .{
+                .r = @truncate(slice[2]),
+                .g = @truncate(slice[3]),
+                .b = @truncate(slice[4]),
+            });
+        }
+
+        // We have a colon, we might have either 5 or 6 values depending
+        // on if the colorspace is present.
+        const count = self.countColon();
+        switch (count) {
+            3 => {
+                self.idx += 4;
+                return @unionInit(Attribute, @tagName(tag), .{
+                    .r = @truncate(slice[2]),
+                    .g = @truncate(slice[3]),
+                    .b = @truncate(slice[4]),
+                });
+            },
+
+            4 => {
+                self.idx += 5;
+                return @unionInit(Attribute, @tagName(tag), .{
+                    .r = @truncate(slice[3]),
+                    .g = @truncate(slice[4]),
+                    .b = @truncate(slice[5]),
+                });
+            },
+
+            else => {
+                self.consumeUnknownColon();
+                return null;
+            },
+        }
+    }
+
+    /// Returns true if the present position has a colon separator.
+    /// This always returns false for the last value since it has no
+    /// separator.
+    fn isColon(self: *Parser) bool {
+        // The `- 1` here is because the last value has no separator.
+        if (self.idx >= self.params.len - 1) return false;
+        return self.params_sep.isSet(self.idx);
+    }
+
+    fn countColon(self: *Parser) usize {
+        var count: usize = 0;
+        var idx = self.idx;
+        while (idx < self.params.len - 1 and self.params_sep.isSet(idx)) : (idx += 1) {
+            count += 1;
+        }
+        return count;
+    }
+
+    /// Consumes all the remaining parameters separated by a colon and
+    /// returns an unknown attribute.
+    fn consumeUnknownColon(self: *Parser) void {
+        const count = self.countColon();
+        self.idx += count + 1;
     }
 };
 
@@ -329,7 +372,7 @@ fn testParse(params: []const u16) Attribute {
 }
 
 fn testParseColon(params: []const u16) Attribute {
-    var p: Parser = .{ .params = params, .colon = true };
+    var p: Parser = .{ .params = params, .params_sep = SepList.initFull() };
     return p.next().?;
 }
 
@@ -366,6 +409,35 @@ test "sgr: Parser multiple" {
     try testing.expect(p.next() == null);
 }
 
+test "sgr: unsupported with colon" {
+    var p: Parser = .{
+        .params = &[_]u16{ 0, 4, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(0);
+            break :sep list;
+        },
+    };
+    try testing.expect(p.next().? == .unknown);
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
+test "sgr: unsupported with multiple colon" {
+    var p: Parser = .{
+        .params = &[_]u16{ 0, 4, 2, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(0);
+            list.set(1);
+            break :sep list;
+        },
+    };
+    try testing.expect(p.next().? == .unknown);
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
 test "sgr: bold" {
     {
         const v = testParse(&[_]u16{1});
@@ -439,6 +511,37 @@ test "sgr: underline styles" {
     }
 }
 
+test "sgr: underline style with more" {
+    var p: Parser = .{
+        .params = &[_]u16{ 4, 2, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(0);
+            break :sep list;
+        },
+    };
+
+    try testing.expect(p.next().? == .underline);
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
+test "sgr: underline style with too many colons" {
+    var p: Parser = .{
+        .params = &[_]u16{ 4, 2, 3, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(0);
+            list.set(1);
+            break :sep list;
+        },
+    };
+
+    try testing.expect(p.next().? == .unknown);
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
 test "sgr: blink" {
     {
         const v = testParse(&[_]u16{5});
@@ -592,13 +695,13 @@ test "sgr: underline, bg, and fg" {
 
 test "sgr: direct color fg missing color" {
     // This used to crash
-    var p: Parser = .{ .params = &[_]u16{ 38, 5 }, .colon = false };
+    var p: Parser = .{ .params = &[_]u16{ 38, 5 } };
     while (p.next()) |_| {}
 }
 
 test "sgr: direct color bg missing color" {
     // This used to crash
-    var p: Parser = .{ .params = &[_]u16{ 48, 5 }, .colon = false };
+    var p: Parser = .{ .params = &[_]u16{ 48, 5 } };
     while (p.next()) |_| {}
 }
 
@@ -608,7 +711,7 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     // Colon version should skip the optional color space identifier
     {
         // 3 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 38, 2, 0, 1, 2, 3, 4 });
+        const v = testParseColon(&[_]u16{ 38, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
         try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
@@ -616,7 +719,7 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     }
     {
         // 4 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 48, 2, 0, 1, 2, 3, 4 });
+        const v = testParseColon(&[_]u16{ 48, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_bg);
         try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
         try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
@@ -624,7 +727,7 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     }
     {
         // 5 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3, 4 });
+        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3 });
         try testing.expect(v == .underline_color);
         try testing.expectEqual(@as(u8, 1), v.underline_color.r);
         try testing.expectEqual(@as(u8, 2), v.underline_color.g);
@@ -634,7 +737,7 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     // Semicolon version should not parse optional color space identifier
     {
         // 3 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 38, 2, 0, 1, 2, 3, 4 });
+        const v = testParse(&[_]u16{ 38, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 0), v.direct_color_fg.r);
         try testing.expectEqual(@as(u8, 1), v.direct_color_fg.g);
@@ -642,7 +745,7 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     }
     {
         // 4 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 48, 2, 0, 1, 2, 3, 4 });
+        const v = testParse(&[_]u16{ 48, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_bg);
         try testing.expectEqual(@as(u8, 0), v.direct_color_bg.r);
         try testing.expectEqual(@as(u8, 1), v.direct_color_bg.g);
@@ -650,10 +753,114 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
     }
     {
         // 5 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 58, 2, 0, 1, 2, 3, 4 });
+        const v = testParse(&[_]u16{ 58, 2, 0, 1, 2, 3 });
         try testing.expect(v == .underline_color);
         try testing.expectEqual(@as(u8, 0), v.underline_color.r);
         try testing.expectEqual(@as(u8, 1), v.underline_color.g);
         try testing.expectEqual(@as(u8, 2), v.underline_color.b);
     }
 }
+
+test "sgr: direct fg colon with too many colons" {
+    var p: Parser = .{
+        .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 4, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            for (0..6) |idx| list.set(idx);
+            break :sep list;
+        },
+    };
+
+    try testing.expect(p.next().? == .unknown);
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
+test "sgr: direct fg colon with colorspace and extra param" {
+    var p: Parser = .{
+        .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            for (0..5) |idx| list.set(idx);
+            break :sep list;
+        },
+    };
+
+    {
+        const v = p.next().?;
+        std.log.warn("WHAT={}", .{v});
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
+    }
+
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
+test "sgr: direct fg colon no colorspace and extra param" {
+    var p: Parser = .{
+        .params = &[_]u16{ 38, 2, 1, 2, 3, 1 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            for (0..4) |idx| list.set(idx);
+            break :sep list;
+        },
+    };
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
+    }
+
+    try testing.expect(p.next().? == .bold);
+    try testing.expect(p.next() == null);
+}
+
+// Kakoune sent this complex SGR sequence that caused invalid behavior.
+test "sgr: kakoune input" {
+    // This used to crash
+    var p: Parser = .{
+        .params = &[_]u16{ 0, 4, 3, 38, 2, 175, 175, 215, 58, 2, 0, 190, 80, 70 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(1);
+            list.set(8);
+            list.set(9);
+            list.set(10);
+            list.set(11);
+            list.set(12);
+            break :sep list;
+        },
+    };
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .unset);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline);
+        try testing.expectEqual(Attribute.Underline.curly, v.underline);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 175), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 175), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 215), v.direct_color_fg.b);
+    }
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 190), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 80), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 70), v.underline_color.b);
+    }
+
+    //try testing.expect(p.next() == null);
+}

commit 22c506b03e2ea2ff83d0088b7cb1e15c6e2c64f7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 22 20:40:06 2025 -0800

    terminal: increase CSI max params to 24 to accept Kakoune sequence
    
    See #5930
    
    Kakoune sends a real SGR sequence with 17 parameters. Our previous max
    was 16 so we through away the entire sequence. This commit increases the
    max rather than fundamentally addressing limitations.
    
    Practically, it took us this long to witness a real world sequence that
    exceeded our previous limit. We may need to revisit this in the future,
    but this is an easy fix for now.
    
    In the future, as the comment states in this diff, we should probably
    look into a rare slow path where we heap allocate to accept up to some
    larger size (but still would need a cap to avoid DoS). For now,
    increasing to 24 slightly increases our memory usage but shouldn't
    result in any real world issues.

diff --git a/src/terminal/sgr.zig b/src/terminal/sgr.zig
index 52bfb2c3..2bc32c5f 100644
--- a/src/terminal/sgr.zig
+++ b/src/terminal/sgr.zig
@@ -103,12 +103,16 @@ pub const Parser = struct {
 
     /// Next returns the next attribute or null if there are no more attributes.
     pub fn next(self: *Parser) ?Attribute {
-        if (self.idx > self.params.len) return null;
+        if (self.idx >= self.params.len) {
+            // If we're at index zero it means we must have an empty
+            // list and an empty list implicitly means unset.
+            if (self.idx == 0) {
+                // Add one to ensure we don't loop on unset
+                self.idx += 1;
+                return .unset;
+            }
 
-        // Implicitly means unset
-        if (self.params.len == 0) {
-            self.idx += 1;
-            return .unset;
+            return null;
         }
 
         const slice = self.params[self.idx..self.params.len];
@@ -788,7 +792,6 @@ test "sgr: direct fg colon with colorspace and extra param" {
 
     {
         const v = p.next().?;
-        std.log.warn("WHAT={}", .{v});
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
         try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
@@ -864,3 +867,50 @@ test "sgr: kakoune input" {
 
     //try testing.expect(p.next() == null);
 }
+
+// Discussion #5930, another input sent by kakoune
+test "sgr: kakoune input issue underline, fg, and bg" {
+    // echo -e "\033[4:3;38;2;51;51;51;48;2;170;170;170;58;2;255;97;136mset everything in one sequence, broken\033[m"
+
+    // This used to crash
+    var p: Parser = .{
+        .params = &[_]u16{ 4, 3, 38, 2, 51, 51, 51, 48, 2, 170, 170, 170, 58, 2, 255, 97, 136 },
+        .params_sep = sep: {
+            var list = SepList.initEmpty();
+            list.set(0);
+            break :sep list;
+        },
+    };
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline);
+        try testing.expectEqual(Attribute.Underline.curly, v.underline);
+    }
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.b);
+    }
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.b);
+    }
+
+    {
+        const v = p.next().?;
+        try testing.expect(v == .underline_color);
+        try testing.expectEqual(@as(u8, 255), v.underline_color.r);
+        try testing.expectEqual(@as(u8, 97), v.underline_color.g);
+        try testing.expectEqual(@as(u8, 136), v.underline_color.b);
+    }
+
+    try testing.expect(p.next() == null);
+}

