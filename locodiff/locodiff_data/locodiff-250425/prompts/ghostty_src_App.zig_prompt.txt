# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/App.zig

commit 5bbdd75d70c5108e3e01701cd70424bb24cbb158
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Apr 3 20:39:32 2022 -0700

    clean up the main App

diff --git a/src/App.zig b/src/App.zig
new file mode 100644
index 00000000..152e6709
--- /dev/null
+++ b/src/App.zig
@@ -0,0 +1,107 @@
+//! App is the primary GUI application for ghostty. This builds the window,
+//! sets up the renderer, etc. The primary run loop is started by calling
+//! the "run" function.
+const App = @This();
+
+const std = @import("std");
+const gl = @import("opengl.zig");
+const glfw = @import("glfw");
+
+const log = std.log;
+
+window: glfw.Window,
+
+glprog: gl.Program,
+vao: gl.VertexArray,
+
+/// Initialize the main app instance. This creates the main window, sets
+/// up the renderer state, compiles the shaders, etc. This is the primary
+/// "startup" logic.
+pub fn init() !App {
+    // Create our window
+    const window = try glfw.Window.create(640, 480, "ghostty", null, null, .{
+        .context_version_major = 3,
+        .context_version_minor = 3,
+        .opengl_profile = .opengl_core_profile,
+        .opengl_forward_compat = true,
+    });
+    errdefer window.destroy();
+
+    // Setup OpenGL
+    // NOTE(mitchellh): we probably want to extract this to a dedicated
+    // renderer at some point.
+    try glfw.makeContextCurrent(window);
+    try glfw.swapInterval(1);
+    window.setSizeCallback((struct {
+        fn callback(_: glfw.Window, width: i32, height: i32) void {
+            log.info("set viewport {} {}", .{ width, height });
+            try gl.viewport(0, 0, width, height);
+        }
+    }).callback);
+
+    // Compile our shaders
+    const vs = try gl.Shader.create(gl.c.GL_VERTEX_SHADER);
+    try vs.setSourceAndCompile(vs_source);
+    errdefer vs.destroy();
+
+    const fs = try gl.Shader.create(gl.c.GL_FRAGMENT_SHADER);
+    try fs.setSourceAndCompile(fs_source);
+    errdefer fs.destroy();
+
+    // Link our shader program
+    const program = try gl.Program.create();
+    errdefer program.destroy();
+    try program.attachShader(vs);
+    try program.attachShader(fs);
+    try program.link();
+    vs.destroy();
+    fs.destroy();
+
+    // Create our bufer or vertices
+    const vertices = [_]f32{
+        -0.5, -0.5, 0.0, // left
+        0.5, -0.5, 0.0, // right
+        0.0, 0.5, 0.0, // top
+    };
+    const vao = try gl.VertexArray.create();
+    //defer vao.destroy();
+    const vbo = try gl.Buffer.create();
+    //defer vbo.destroy();
+    try vao.bind();
+    var binding = try vbo.bind(gl.c.GL_ARRAY_BUFFER);
+    try binding.setData(&vertices, gl.c.GL_STATIC_DRAW);
+    try binding.vertexAttribPointer(0, 3, gl.c.GL_FLOAT, false, 3 * @sizeOf(f32), null);
+    try binding.enableVertexAttribArray(0);
+    binding.unbind();
+    try gl.VertexArray.unbind();
+
+    return App{
+        .window = window,
+        .glprog = program,
+
+        .vao = vao,
+    };
+}
+
+pub fn deinit(self: *App) void {
+    self.window.destroy();
+    self.* = undefined;
+}
+
+pub fn run(self: App) !void {
+    while (!self.window.shouldClose()) {
+        // Setup basic OpenGL settings
+        gl.clearColor(0.2, 0.3, 0.3, 1.0);
+        gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
+
+        try self.glprog.use();
+        try self.vao.bind();
+        try gl.drawArrays(gl.c.GL_TRIANGLES, 0, 3);
+
+        try self.window.swapBuffers();
+        try glfw.waitEvents();
+    }
+}
+
+const vs_source = @embedFile("../shaders/shape.v.glsl");
+const fs_source = @embedFile("../shaders/shape.f.glsl");

commit 670af17a1b10a1ff3a84674e4e1b31097dbcb0bb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Apr 3 22:04:42 2022 -0700

    getting closer to dumb font rendering

diff --git a/src/App.zig b/src/App.zig
index 152e6709..09c6f880 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -4,8 +4,9 @@
 const App = @This();
 
 const std = @import("std");
-const gl = @import("opengl.zig");
 const glfw = @import("glfw");
+const gl = @import("opengl.zig");
+const TextRenderer = @import("TextRenderer.zig");
 
 const log = std.log;
 
@@ -17,7 +18,11 @@ vao: gl.VertexArray,
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
-pub fn init() !App {
+pub fn init(alloc: std.mem.Allocator) !App {
+    // Setup our text renderer
+    var texter = try TextRenderer.init(alloc);
+    defer texter.deinit();
+
     // Create our window
     const window = try glfw.Window.create(640, 480, "ghostty", null, null, .{
         .context_version_major = 3,
@@ -39,6 +44,10 @@ pub fn init() !App {
         }
     }).callback);
 
+    // Blending for text
+    gl.c.glEnable(gl.c.GL_BLEND);
+    gl.c.glBlendFunc(gl.c.GL_SRC_ALPHA, gl.c.GL_ONE_MINUS_SRC_ALPHA);
+
     // Compile our shaders
     const vs = try gl.Shader.create(gl.c.GL_VERTEX_SHADER);
     try vs.setSourceAndCompile(vs_source);

commit fc28b8c032aa3ee5a5d6f21719805ff54906d62f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 09:43:46 2022 -0700

    busted text rendering

diff --git a/src/App.zig b/src/App.zig
index 09c6f880..9a0982f8 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -12,17 +12,12 @@ const log = std.log;
 
 window: glfw.Window,
 
-glprog: gl.Program,
-vao: gl.VertexArray,
+text: TextRenderer,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: std.mem.Allocator) !App {
-    // Setup our text renderer
-    var texter = try TextRenderer.init(alloc);
-    defer texter.deinit();
-
     // Create our window
     const window = try glfw.Window.create(640, 480, "ghostty", null, null, .{
         .context_version_major = 3,
@@ -45,54 +40,22 @@ pub fn init(alloc: std.mem.Allocator) !App {
     }).callback);
 
     // Blending for text
+    gl.c.glEnable(gl.c.GL_CULL_FACE);
     gl.c.glEnable(gl.c.GL_BLEND);
     gl.c.glBlendFunc(gl.c.GL_SRC_ALPHA, gl.c.GL_ONE_MINUS_SRC_ALPHA);
 
-    // Compile our shaders
-    const vs = try gl.Shader.create(gl.c.GL_VERTEX_SHADER);
-    try vs.setSourceAndCompile(vs_source);
-    errdefer vs.destroy();
-
-    const fs = try gl.Shader.create(gl.c.GL_FRAGMENT_SHADER);
-    try fs.setSourceAndCompile(fs_source);
-    errdefer fs.destroy();
-
-    // Link our shader program
-    const program = try gl.Program.create();
-    errdefer program.destroy();
-    try program.attachShader(vs);
-    try program.attachShader(fs);
-    try program.link();
-    vs.destroy();
-    fs.destroy();
-
-    // Create our bufer or vertices
-    const vertices = [_]f32{
-        -0.5, -0.5, 0.0, // left
-        0.5, -0.5, 0.0, // right
-        0.0, 0.5, 0.0, // top
-    };
-    const vao = try gl.VertexArray.create();
-    //defer vao.destroy();
-    const vbo = try gl.Buffer.create();
-    //defer vbo.destroy();
-    try vao.bind();
-    var binding = try vbo.bind(gl.c.GL_ARRAY_BUFFER);
-    try binding.setData(&vertices, gl.c.GL_STATIC_DRAW);
-    try binding.vertexAttribPointer(0, 3, gl.c.GL_FLOAT, false, 3 * @sizeOf(f32), null);
-    try binding.enableVertexAttribArray(0);
-    binding.unbind();
-    try gl.VertexArray.unbind();
+    // Setup our text renderer
+    var texter = try TextRenderer.init(alloc);
+    errdefer texter.deinit();
 
     return App{
         .window = window,
-        .glprog = program,
-
-        .vao = vao,
+        .text = texter,
     };
 }
 
 pub fn deinit(self: *App) void {
+    self.text.deinit();
     self.window.destroy();
     self.* = undefined;
 }
@@ -103,9 +66,7 @@ pub fn run(self: App) !void {
         gl.clearColor(0.2, 0.3, 0.3, 1.0);
         gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
 
-        try self.glprog.use();
-        try self.vao.bind();
-        try gl.drawArrays(gl.c.GL_TRIANGLES, 0, 3);
+        try self.text.render("hello", 25.0, 25.0, 1.0, .{ 0.5, 0.8, 0.2 });
 
         try self.window.swapBuffers();
         try glfw.waitEvents();

commit 1a405442200ae9402c8c99ae206870390074eabf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 11:11:24 2022 -0700

    gb_math

diff --git a/src/App.zig b/src/App.zig
index 9a0982f8..784d390e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -32,12 +32,6 @@ pub fn init(alloc: std.mem.Allocator) !App {
     // renderer at some point.
     try glfw.makeContextCurrent(window);
     try glfw.swapInterval(1);
-    window.setSizeCallback((struct {
-        fn callback(_: glfw.Window, width: i32, height: i32) void {
-            log.info("set viewport {} {}", .{ width, height });
-            try gl.viewport(0, 0, width, height);
-        }
-    }).callback);
 
     // Blending for text
     gl.c.glEnable(gl.c.GL_CULL_FACE);
@@ -48,6 +42,13 @@ pub fn init(alloc: std.mem.Allocator) !App {
     var texter = try TextRenderer.init(alloc);
     errdefer texter.deinit();
 
+    window.setSizeCallback((struct {
+        fn callback(_: glfw.Window, width: i32, height: i32) void {
+            log.info("set viewport {} {}", .{ width, height });
+            try gl.viewport(0, 0, width, height);
+        }
+    }).callback);
+
     return App{
         .window = window,
         .text = texter,

commit c8a73d60a9baee2cb95c4fad6235686b6acc60d8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 11:53:09 2022 -0700

    less dumb

diff --git a/src/App.zig b/src/App.zig
index 784d390e..b0cfd0e1 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -67,7 +67,7 @@ pub fn run(self: App) !void {
         gl.clearColor(0.2, 0.3, 0.3, 1.0);
         gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
 
-        try self.text.render("hello", 25.0, 25.0, 1.0, .{ 0.5, 0.8, 0.2 });
+        try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, 1.0, .{ 0.5, 0.8, 0.2 });
 
         try self.window.swapBuffers();
         try glfw.waitEvents();

commit c6f1be3343899eefa092be835e06fccc4093780a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 14:35:19 2022 -0700

    move from epoxy to glad

diff --git a/src/App.zig b/src/App.zig
index b0cfd0e1..e4ae5cb9 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -33,6 +33,13 @@ pub fn init(alloc: std.mem.Allocator) !App {
     try glfw.makeContextCurrent(window);
     try glfw.swapInterval(1);
 
+    // Load OpenGL bindings
+    if (gl.c.gladLoadGL(
+        @ptrCast(fn ([*c]const u8) callconv(.C) ?fn () callconv(.C) void, glfw.getProcAddress),
+    ) == 0) {
+        return error.OpenGLInitFailed;
+    }
+
     // Blending for text
     gl.c.glEnable(gl.c.GL_CULL_FACE);
     gl.c.glEnable(gl.c.GL_BLEND);

commit 8797c4183384764bb03546d47ddf6bf44b499b10
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 14:59:22 2022 -0700

    output loaded OpenGL version

diff --git a/src/App.zig b/src/App.zig
index e4ae5cb9..17b74ce0 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -34,11 +34,17 @@ pub fn init(alloc: std.mem.Allocator) !App {
     try glfw.swapInterval(1);
 
     // Load OpenGL bindings
-    if (gl.c.gladLoadGL(
-        @ptrCast(fn ([*c]const u8) callconv(.C) ?fn () callconv(.C) void, glfw.getProcAddress),
-    ) == 0) {
+    const version = gl.c.gladLoadGL(@ptrCast(
+        fn ([*c]const u8) callconv(.C) ?fn () callconv(.C) void,
+        glfw.getProcAddress,
+    ));
+    if (version == 0) {
         return error.OpenGLInitFailed;
     }
+    log.info("loaded OpenGL {}.{}", .{
+        gl.c.GLAD_VERSION_MAJOR(@intCast(c_uint, version)),
+        gl.c.GLAD_VERSION_MINOR(@intCast(c_uint, version)),
+    });
 
     // Blending for text
     gl.c.glEnable(gl.c.GL_CULL_FACE);

commit 530fecee4a6cfe6ddaad4939bbd0a9ab61d6b74b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 15:10:22 2022 -0700

    opengl: glad helpers

diff --git a/src/App.zig b/src/App.zig
index 17b74ce0..0e16ea4c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -34,16 +34,10 @@ pub fn init(alloc: std.mem.Allocator) !App {
     try glfw.swapInterval(1);
 
     // Load OpenGL bindings
-    const version = gl.c.gladLoadGL(@ptrCast(
-        fn ([*c]const u8) callconv(.C) ?fn () callconv(.C) void,
-        glfw.getProcAddress,
-    ));
-    if (version == 0) {
-        return error.OpenGLInitFailed;
-    }
+    const version = try gl.glad.load(glfw.getProcAddress);
     log.info("loaded OpenGL {}.{}", .{
-        gl.c.GLAD_VERSION_MAJOR(@intCast(c_uint, version)),
-        gl.c.GLAD_VERSION_MINOR(@intCast(c_uint, version)),
+        gl.glad.versionMajor(version),
+        gl.glad.versionMinor(version),
     });
 
     // Blending for text

commit 684fb647052073e7849ab0a7d0ec09a938a9ee96
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 4 22:24:02 2022 -0700

    use a font atlas!

diff --git a/src/App.zig b/src/App.zig
index 0e16ea4c..77e7f7b1 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -74,7 +74,8 @@ pub fn run(self: App) !void {
         gl.clearColor(0.2, 0.3, 0.3, 1.0);
         gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
 
-        try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, 1.0, .{ 0.5, 0.8, 0.2 });
+        try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
+        //try self.text.render("hi", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
 
         try self.window.swapBuffers();
         try glfw.waitEvents();

commit 388c0056c9e6552444e4468f18cc7070b453a234
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 5 19:54:13 2022 -0700

    switch to pure Zig font atlas

diff --git a/src/App.zig b/src/App.zig
index 77e7f7b1..9d1959ba 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -4,12 +4,18 @@
 const App = @This();
 
 const std = @import("std");
+const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const gl = @import("opengl.zig");
-const TextRenderer = @import("TextRenderer.zig");
+const TextRenderer = if (true)
+    @import("TextRenderer.zig")
+else
+    @import("TextRenderer2.zig");
 
 const log = std.log;
 
+alloc: Allocator,
+
 window: glfw.Window,
 
 text: TextRenderer,
@@ -17,7 +23,7 @@ text: TextRenderer,
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
-pub fn init(alloc: std.mem.Allocator) !App {
+pub fn init(alloc: Allocator) !App {
     // Create our window
     const window = try glfw.Window.create(640, 480, "ghostty", null, null, .{
         .context_version_major = 3,
@@ -57,13 +63,14 @@ pub fn init(alloc: std.mem.Allocator) !App {
     }).callback);
 
     return App{
+        .alloc = alloc,
         .window = window,
         .text = texter,
     };
 }
 
 pub fn deinit(self: *App) void {
-    self.text.deinit();
+    self.text.deinit(self.alloc);
     self.window.destroy();
     self.* = undefined;
 }

commit 80490cb80dd2bc56a932e69d3445f02dc1889a5d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 5 19:54:48 2022 -0700

    remove ftgl build

diff --git a/src/App.zig b/src/App.zig
index 9d1959ba..5bff4d64 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -7,10 +7,7 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const gl = @import("opengl.zig");
-const TextRenderer = if (true)
-    @import("TextRenderer.zig")
-else
-    @import("TextRenderer2.zig");
+const TextRenderer = @import("TextRenderer.zig");
 
 const log = std.log;
 

commit 544286509fcff41eecec81a95b5c9b7ceba6083c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Apr 14 17:14:49 2022 -0700

    grid render a few cells

diff --git a/src/App.zig b/src/App.zig
index 5bff4d64..4838f1ca 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -8,6 +8,7 @@ const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const gl = @import("opengl.zig");
 const TextRenderer = @import("TextRenderer.zig");
+const Grid = @import("Grid.zig");
 
 const log = std.log;
 
@@ -16,6 +17,7 @@ alloc: Allocator,
 window: glfw.Window,
 
 text: TextRenderer,
+grid: Grid,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
@@ -43,14 +45,21 @@ pub fn init(alloc: Allocator) !App {
         gl.glad.versionMinor(version),
     });
 
-    // Blending for text
+    // Culling, probably not necessary. We have to change the winding
+    // order since our 0,0 is top-left.
     gl.c.glEnable(gl.c.GL_CULL_FACE);
+    gl.c.glFrontFace(gl.c.GL_CW);
+
+    // Blending for text
     gl.c.glEnable(gl.c.GL_BLEND);
     gl.c.glBlendFunc(gl.c.GL_SRC_ALPHA, gl.c.GL_ONE_MINUS_SRC_ALPHA);
 
     // Setup our text renderer
     var texter = try TextRenderer.init(alloc);
-    errdefer texter.deinit();
+    errdefer texter.deinit(alloc);
+
+    const grid = try Grid.init(alloc);
+    try grid.setScreenSize(.{ .width = 3000, .height = 1666 });
 
     window.setSizeCallback((struct {
         fn callback(_: glfw.Window, width: i32, height: i32) void {
@@ -63,6 +72,7 @@ pub fn init(alloc: Allocator) !App {
         .alloc = alloc,
         .window = window,
         .text = texter,
+        .grid = grid,
     };
 }
 
@@ -78,8 +88,8 @@ pub fn run(self: App) !void {
         gl.clearColor(0.2, 0.3, 0.3, 1.0);
         gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
 
-        try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
-        //try self.text.render("hi", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
+        try self.grid.render();
+        //try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
 
         try self.window.swapBuffers();
         try glfw.waitEvents();

commit ce70efd771abfcc6b3c554c2025fcb6e8147a0c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Apr 14 17:44:40 2022 -0700

    render a rainbow grid

diff --git a/src/App.zig b/src/App.zig
index 4838f1ca..f46ad09b 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -58,7 +58,7 @@ pub fn init(alloc: Allocator) !App {
     var texter = try TextRenderer.init(alloc);
     errdefer texter.deinit(alloc);
 
-    const grid = try Grid.init(alloc);
+    var grid = try Grid.init(alloc);
     try grid.setScreenSize(.{ .width = 3000, .height = 1666 });
 
     window.setSizeCallback((struct {

commit bb902cf4e315a8ccfb6103c73e4d8f440bef1d6d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Apr 14 21:07:16 2022 -0700

    new Window abstraction

diff --git a/src/App.zig b/src/App.zig
index f46ad09b..fd3df480 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -5,96 +5,32 @@ const App = @This();
 
 const std = @import("std");
 const Allocator = std.mem.Allocator;
-const glfw = @import("glfw");
-const gl = @import("opengl.zig");
-const TextRenderer = @import("TextRenderer.zig");
-const Grid = @import("Grid.zig");
+const Window = @import("Window.zig");
 
 const log = std.log;
 
 alloc: Allocator,
 
-window: glfw.Window,
-
-text: TextRenderer,
-grid: Grid,
+window: *Window,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: Allocator) !App {
-    // Create our window
-    const window = try glfw.Window.create(640, 480, "ghostty", null, null, .{
-        .context_version_major = 3,
-        .context_version_minor = 3,
-        .opengl_profile = .opengl_core_profile,
-        .opengl_forward_compat = true,
-    });
-    errdefer window.destroy();
-
-    // Setup OpenGL
-    // NOTE(mitchellh): we probably want to extract this to a dedicated
-    // renderer at some point.
-    try glfw.makeContextCurrent(window);
-    try glfw.swapInterval(1);
-
-    // Load OpenGL bindings
-    const version = try gl.glad.load(glfw.getProcAddress);
-    log.info("loaded OpenGL {}.{}", .{
-        gl.glad.versionMajor(version),
-        gl.glad.versionMinor(version),
-    });
-
-    // Culling, probably not necessary. We have to change the winding
-    // order since our 0,0 is top-left.
-    gl.c.glEnable(gl.c.GL_CULL_FACE);
-    gl.c.glFrontFace(gl.c.GL_CW);
-
-    // Blending for text
-    gl.c.glEnable(gl.c.GL_BLEND);
-    gl.c.glBlendFunc(gl.c.GL_SRC_ALPHA, gl.c.GL_ONE_MINUS_SRC_ALPHA);
-
-    // Setup our text renderer
-    var texter = try TextRenderer.init(alloc);
-    errdefer texter.deinit(alloc);
-
-    var grid = try Grid.init(alloc);
-    try grid.setScreenSize(.{ .width = 3000, .height = 1666 });
-
-    window.setSizeCallback((struct {
-        fn callback(_: glfw.Window, width: i32, height: i32) void {
-            log.info("set viewport {} {}", .{ width, height });
-            try gl.viewport(0, 0, width, height);
-        }
-    }).callback);
+    // Create the window
+    const window = try Window.create(alloc);
 
     return App{
         .alloc = alloc,
         .window = window,
-        .text = texter,
-        .grid = grid,
     };
 }
 
 pub fn deinit(self: *App) void {
-    self.text.deinit(self.alloc);
-    self.window.destroy();
+    self.window.destroy(self.alloc);
     self.* = undefined;
 }
 
 pub fn run(self: App) !void {
-    while (!self.window.shouldClose()) {
-        // Setup basic OpenGL settings
-        gl.clearColor(0.2, 0.3, 0.3, 1.0);
-        gl.clear(gl.c.GL_COLOR_BUFFER_BIT);
-
-        try self.grid.render();
-        //try self.text.render("sh $ /bin/bash -c \"echo hello\"", 25.0, 25.0, .{ 0.5, 0.8, 0.2 });
-
-        try self.window.swapBuffers();
-        try glfw.waitEvents();
-    }
+    try self.window.run();
 }
-
-const vs_source = @embedFile("../shaders/shape.v.glsl");
-const fs_source = @embedFile("../shaders/shape.f.glsl");

commit 2cd51f0cc450fc05848201edbd777629a3c310ed
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 15 13:09:35 2022 -0700

    basic pty opening

diff --git a/src/App.zig b/src/App.zig
index fd3df480..4f3b4cc6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -7,10 +7,11 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const Window = @import("Window.zig");
 
-const log = std.log;
-
+/// General purpose allocator
 alloc: Allocator,
 
+/// The primary window for the application. We currently support only
+/// single window operations.
 window: *Window,
 
 /// Initialize the main app instance. This creates the main window, sets

commit 19692f297e650580c7e749fd82d5d5c71da40460
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 19 13:10:50 2022 -0700

    set character callback and update the terminal

diff --git a/src/App.zig b/src/App.zig
index 4f3b4cc6..3394c5c7 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -28,7 +28,7 @@ pub fn init(alloc: Allocator) !App {
 }
 
 pub fn deinit(self: *App) void {
-    self.window.destroy(self.alloc);
+    self.window.destroy();
     self.* = undefined;
 }
 

commit cca32c4d1c5fe337f60e8045b164b16f0e0e66e7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 10:01:52 2022 -0700

    embedded libuv loop. still some issues:
    
    1. 100% CPU if no handles/requests
    2. slow to exit cause it waits for the next tick

diff --git a/src/App.zig b/src/App.zig
index 3394c5c7..7adae511 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -5,7 +5,11 @@ const App = @This();
 
 const std = @import("std");
 const Allocator = std.mem.Allocator;
+const glfw = @import("glfw");
 const Window = @import("Window.zig");
+const libuv = @import("libuv/main.zig");
+
+const log = std.log.scoped(.app);
 
 /// General purpose allocator
 alloc: Allocator,
@@ -14,24 +18,66 @@ alloc: Allocator,
 /// single window operations.
 window: *Window,
 
+// The main event loop for the application.
+loop: libuv.Loop,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: Allocator) !App {
     // Create the window
-    const window = try Window.create(alloc);
+    var window = try Window.create(alloc);
+    errdefer window.destroy();
+
+    // Create the event loop
+    var loop = try libuv.Loop.init(alloc);
+    errdefer loop.deinit(alloc);
 
     return App{
         .alloc = alloc,
         .window = window,
+        .loop = loop,
     };
 }
 
 pub fn deinit(self: *App) void {
     self.window.destroy();
+    self.loop.deinit(self.alloc);
     self.* = undefined;
 }
 
 pub fn run(self: App) !void {
-    try self.window.run();
+    // We are embedding two event loops: glfw and libuv. To do this, we
+    // create a separate thread that watches for libuv events and notifies
+    // glfw to wake up so we can run the libuv tick.
+    var embed = try libuv.Embed.init(self.alloc, self.loop, (struct {
+        fn callback() void {
+            glfw.postEmptyEvent() catch unreachable;
+        }
+    }).callback);
+    defer embed.deinit(self.alloc);
+    try embed.start();
+    errdefer embed.stop() catch unreachable;
+
+    // We need at least one handle in the event loop at all times
+    var timer = try libuv.Timer.init(self.alloc, self.loop);
+    defer timer.deinit(self.alloc);
+    try timer.start((struct {
+        fn callback(_: libuv.Timer) void {
+            log.info("timer tick", .{});
+        }
+    }).callback, 5000, 5000);
+
+    while (!self.window.shouldClose()) {
+        try self.window.run();
+
+        // Block for any glfw events. This may also be an "empty" event
+        // posted by the libuv watcher so that we trigger a libuv loop tick.
+        try glfw.waitEvents();
+
+        // Run the libuv loop
+        try embed.loopRun();
+    }
+
+    try embed.stop();
 }

commit a57f4e76f10b0312e31e50ac18d874103385fec8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 12:11:53 2022 -0700

    fully integrate libuv, no crash on close

diff --git a/src/App.zig b/src/App.zig
index 7adae511..a6c71d0d 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -57,15 +57,14 @@ pub fn run(self: App) !void {
     }).callback);
     defer embed.deinit(self.alloc);
     try embed.start();
-    errdefer embed.stop() catch unreachable;
+    errdefer embed.stop();
 
-    // We need at least one handle in the event loop at all times
+    // We need at least one handle in the event loop at all times so
+    // that the loop doesn't spin 100% CPU.
     var timer = try libuv.Timer.init(self.alloc, self.loop);
     defer timer.deinit(self.alloc);
     try timer.start((struct {
-        fn callback(_: libuv.Timer) void {
-            log.info("timer tick", .{});
-        }
+        fn callback(_: libuv.Timer) void {}
     }).callback, 5000, 5000);
 
     while (!self.window.shouldClose()) {
@@ -79,5 +78,13 @@ pub fn run(self: App) !void {
         try embed.loopRun();
     }
 
-    try embed.stop();
+    // CLose our timer so that we can cleanly close the loop.
+    timer.close(null);
+    _ = try self.loop.run(.default);
+
+    // Notify the embedder to stop. We purposely do NOT wait for `join`
+    // here because handles with long timeouts may cause this to take a long
+    // time. We're exiting the app anyways if we're here so we let the OS
+    // clean up the threads.
+    embed.stop();
 }

commit 947596ea5ea3ebb19323ccc2ae886e414b97e1d7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 12:15:15 2022 -0700

    clean up some of the libuv interations

diff --git a/src/App.zig b/src/App.zig
index a6c71d0d..1fbc9591 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -57,7 +57,12 @@ pub fn run(self: App) !void {
     }).callback);
     defer embed.deinit(self.alloc);
     try embed.start();
-    errdefer embed.stop();
+
+    // Notify the embedder to stop. We purposely do NOT wait for `join`
+    // here because handles with long timeouts may cause this to take a long
+    // time. We're exiting the app anyways if we're here so we let the OS
+    // clean up the threads.
+    defer embed.stop();
 
     // We need at least one handle in the event loop at all times so
     // that the loop doesn't spin 100% CPU.
@@ -81,10 +86,4 @@ pub fn run(self: App) !void {
     // CLose our timer so that we can cleanly close the loop.
     timer.close(null);
     _ = try self.loop.run(.default);
-
-    // Notify the embedder to stop. We purposely do NOT wait for `join`
-    // here because handles with long timeouts may cause this to take a long
-    // time. We're exiting the app anyways if we're here so we let the OS
-    // clean up the threads.
-    embed.stop();
 }

commit f8b305df62205d1a704a6e5d0a2747b546d3a206
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 13:56:39 2022 -0700

    pass around the event loop, setup a timer to prove it works

diff --git a/src/App.zig b/src/App.zig
index 1fbc9591..6f3d6fd3 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -18,21 +18,30 @@ alloc: Allocator,
 /// single window operations.
 window: *Window,
 
-// The main event loop for the application.
+// The main event loop for the application. The user data of this loop
+// is always the allocator used to create the loop. This is a convenience
+// so that users of the loop always have an allocator.
 loop: libuv.Loop,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: Allocator) !App {
-    // Create the window
-    var window = try Window.create(alloc);
-    errdefer window.destroy();
-
     // Create the event loop
     var loop = try libuv.Loop.init(alloc);
     errdefer loop.deinit(alloc);
 
+    // We always store allocator pointer on the loop data so that
+    // handles can use our global allocator.
+    const allocPtr = try alloc.create(Allocator);
+    errdefer alloc.destroy(allocPtr);
+    allocPtr.* = alloc;
+    loop.setData(allocPtr);
+
+    // Create the window
+    var window = try Window.create(alloc, loop);
+    errdefer window.destroy();
+
     return App{
         .alloc = alloc,
         .window = window,
@@ -42,6 +51,15 @@ pub fn init(alloc: Allocator) !App {
 
 pub fn deinit(self: *App) void {
     self.window.destroy();
+
+    // Run the loop one more time, because destroying our other things
+    // like windows usually cancel all our event loop stuff and we need
+    // one more run through to finalize all the closes.
+    _ = self.loop.run(.default) catch unreachable;
+
+    // Dealloc our allocator copy
+    self.alloc.destroy(self.loop.getData(Allocator).?);
+
     self.loop.deinit(self.alloc);
     self.* = undefined;
 }

commit cd602b660c19e358e38101f8f396981fd22e22c9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 15:33:50 2022 -0700

    blinking cursor

diff --git a/src/App.zig b/src/App.zig
index 6f3d6fd3..0f33bb20 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -76,18 +76,12 @@ pub fn run(self: App) !void {
     defer embed.deinit(self.alloc);
     try embed.start();
 
-    // Notify the embedder to stop. We purposely do NOT wait for `join`
-    // here because handles with long timeouts may cause this to take a long
-    // time. We're exiting the app anyways if we're here so we let the OS
-    // clean up the threads.
-    defer embed.stop();
-
     // We need at least one handle in the event loop at all times so
     // that the loop doesn't spin 100% CPU.
     var timer = try libuv.Timer.init(self.alloc, self.loop);
-    defer timer.deinit(self.alloc);
+    errdefer timer.deinit(self.alloc);
     try timer.start((struct {
-        fn callback(_: libuv.Timer) void {}
+        fn callback(_: *libuv.Timer) void {}
     }).callback, 5000, 5000);
 
     while (!self.window.shouldClose()) {
@@ -101,7 +95,14 @@ pub fn run(self: App) !void {
         try embed.loopRun();
     }
 
-    // CLose our timer so that we can cleanly close the loop.
-    timer.close(null);
-    _ = try self.loop.run(.default);
+    // Close our timer so that we can cleanly close the loop.
+    timer.close((struct {
+        fn callback(t: *libuv.Timer) void {
+            const alloc = t.loop().getData(Allocator).?.*;
+            t.deinit(alloc);
+        }
+    }).callback);
+
+    embed.stop();
+    try embed.join();
 }

commit 0b689723f75254ea5ea7232d7f72d1424aceaa29
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 15:42:08 2022 -0700

    use async handles to more immediately exit the event loop

diff --git a/src/App.zig b/src/App.zig
index 0f33bb20..1b56ae25 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -55,7 +55,8 @@ pub fn deinit(self: *App) void {
     // Run the loop one more time, because destroying our other things
     // like windows usually cancel all our event loop stuff and we need
     // one more run through to finalize all the closes.
-    _ = self.loop.run(.default) catch unreachable;
+    _ = self.loop.run(.default) catch |err|
+        log.err("error finalizing event loop: {}", .{err});
 
     // Dealloc our allocator copy
     self.alloc.destroy(self.loop.getData(Allocator).?);
@@ -76,13 +77,11 @@ pub fn run(self: App) !void {
     defer embed.deinit(self.alloc);
     try embed.start();
 
-    // We need at least one handle in the event loop at all times so
-    // that the loop doesn't spin 100% CPU.
-    var timer = try libuv.Timer.init(self.alloc, self.loop);
-    errdefer timer.deinit(self.alloc);
-    try timer.start((struct {
-        fn callback(_: *libuv.Timer) void {}
-    }).callback, 5000, 5000);
+    // This async handle is used to "wake up" the embed thread so we can
+    // exit immediately once the windows want to close.
+    var async_h = try libuv.Async.init(self.alloc, self.loop, (struct {
+        fn callback(_: *libuv.Async) void {}
+    }).callback);
 
     while (!self.window.shouldClose()) {
         try self.window.run();
@@ -95,14 +94,19 @@ pub fn run(self: App) !void {
         try embed.loopRun();
     }
 
-    // Close our timer so that we can cleanly close the loop.
-    timer.close((struct {
-        fn callback(t: *libuv.Timer) void {
-            const alloc = t.loop().getData(Allocator).?.*;
-            t.deinit(alloc);
+    // Notify the embed thread to stop. We do this before we send on the
+    // async handle so that when the thread goes around it exits.
+    embed.stop();
+
+    // Wake up the event loop and schedule our close.
+    try async_h.send();
+    async_h.close((struct {
+        fn callback(h: *libuv.Async) void {
+            const alloc = h.loop().getData(Allocator).?.*;
+            h.deinit(alloc);
         }
     }).callback);
 
-    embed.stop();
+    // Wait for the thread to end which should be almost instant.
     try embed.join();
 }

commit 87899421bd84394c6d5b076f059b9454f9ceec9a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 22 17:40:37 2022 -0700

    don't blink cursor when losing focus

diff --git a/src/App.zig b/src/App.zig
index 1b56ae25..bd7c06b3 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -90,6 +90,18 @@ pub fn run(self: App) !void {
         // posted by the libuv watcher so that we trigger a libuv loop tick.
         try glfw.waitEvents();
 
+        // If the window wants the event loop to wakeup, then we "kick" the
+        // embed thread to wake up. I'm not sure why we have to do this in a
+        // loop, this is surely a lacking in my understanding of libuv. But
+        // this works.
+        if (self.window.wakeup) {
+            self.window.wakeup = false;
+            while (embed.sleeping.load(.SeqCst) and embed.terminate.load(.SeqCst) == false) {
+                try async_h.send();
+                try embed.loopRun();
+            }
+        }
+
         // Run the libuv loop
         try embed.loopRun();
     }

commit 330d2ea270fffc63123de42784897a088d8998b6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 29 13:39:56 2022 -0700

    integrate tracy more deeply

diff --git a/src/App.zig b/src/App.zig
index bd7c06b3..2dcbe920 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -8,6 +8,7 @@ const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const Window = @import("Window.zig");
 const libuv = @import("libuv/main.zig");
+const tracy = @import("tracy/tracy.zig");
 
 const log = std.log.scoped(.app);
 
@@ -84,7 +85,15 @@ pub fn run(self: App) !void {
     }).callback);
 
     while (!self.window.shouldClose()) {
-        try self.window.run();
+        // Mark this so we're in a totally different "frame"
+        tracy.frameMark();
+
+        // Track the render part of the frame separately.
+        {
+            const frame = tracy.frame("render");
+            defer frame.end();
+            try self.window.run();
+        }
 
         // Block for any glfw events. This may also be an "empty" event
         // posted by the libuv watcher so that we trigger a libuv loop tick.
@@ -103,6 +112,8 @@ pub fn run(self: App) !void {
         }
 
         // Run the libuv loop
+        const frame = tracy.frame("libuv");
+        defer frame.end();
         try embed.loopRun();
     }
 

commit bb01357c421d64f072944f3d140d07997340c6a2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 29 19:21:06 2022 -0700

    Move the render to a timer that slows down under load

diff --git a/src/App.zig b/src/App.zig
index 2dcbe920..70451e09 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -85,31 +85,12 @@ pub fn run(self: App) !void {
     }).callback);
 
     while (!self.window.shouldClose()) {
-        // Mark this so we're in a totally different "frame"
-        tracy.frameMark();
-
-        // Track the render part of the frame separately.
-        {
-            const frame = tracy.frame("render");
-            defer frame.end();
-            try self.window.run();
-        }
-
         // Block for any glfw events. This may also be an "empty" event
         // posted by the libuv watcher so that we trigger a libuv loop tick.
         try glfw.waitEvents();
 
-        // If the window wants the event loop to wakeup, then we "kick" the
-        // embed thread to wake up. I'm not sure why we have to do this in a
-        // loop, this is surely a lacking in my understanding of libuv. But
-        // this works.
-        if (self.window.wakeup) {
-            self.window.wakeup = false;
-            while (embed.sleeping.load(.SeqCst) and embed.terminate.load(.SeqCst) == false) {
-                try async_h.send();
-                try embed.loopRun();
-            }
-        }
+        // Mark this so we're in a totally different "frame"
+        tracy.frameMark();
 
         // Run the libuv loop
         const frame = tracy.frame("libuv");

commit 3b54d05aeca9b3fe1116a975e0c7df470722e0e6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 14:00:35 2022 -0700

    CLI parsing, can set default foreground/background color

diff --git a/src/App.zig b/src/App.zig
index 70451e09..2332c530 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -9,6 +9,7 @@ const glfw = @import("glfw");
 const Window = @import("Window.zig");
 const libuv = @import("libuv/main.zig");
 const tracy = @import("tracy/tracy.zig");
+const Config = @import("config.zig").Config;
 
 const log = std.log.scoped(.app);
 
@@ -24,10 +25,13 @@ window: *Window,
 // so that users of the loop always have an allocator.
 loop: libuv.Loop,
 
+// The configuration for the app.
+config: *const Config,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
-pub fn init(alloc: Allocator) !App {
+pub fn init(alloc: Allocator, config: *const Config) !App {
     // Create the event loop
     var loop = try libuv.Loop.init(alloc);
     errdefer loop.deinit(alloc);
@@ -40,13 +44,14 @@ pub fn init(alloc: Allocator) !App {
     loop.setData(allocPtr);
 
     // Create the window
-    var window = try Window.create(alloc, loop);
+    var window = try Window.create(alloc, loop, config);
     errdefer window.destroy();
 
     return App{
         .alloc = alloc,
         .window = window,
         .loop = loop,
+        .config = config,
     };
 }
 

commit b2192ea8f79167121df566d2b8f024e161da5368
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 16 17:47:44 2022 -0700

    move libuv into pkg

diff --git a/src/App.zig b/src/App.zig
index 2332c530..eb988b28 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -7,7 +7,7 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const Window = @import("Window.zig");
-const libuv = @import("libuv/main.zig");
+const libuv = @import("libuv");
 const tracy = @import("tracy/tracy.zig");
 const Config = @import("config.zig").Config;
 

commit 2f36d5f715518e3f857c548c8c855164ab287f7e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 17 14:03:49 2022 -0700

    pkg/tracy

diff --git a/src/App.zig b/src/App.zig
index eb988b28..7867db4c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -8,7 +8,7 @@ const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const Window = @import("Window.zig");
 const libuv = @import("libuv");
-const tracy = @import("tracy/tracy.zig");
+const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
 
 const log = std.log.scoped(.app);

commit cd705359e8a6b677704b359fa37a1ae210d40abb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 5 19:30:15 2022 -0700

    Window thread is now single event loop!

diff --git a/src/App.zig b/src/App.zig
index 7867db4c..89e96192 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -7,7 +7,6 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const Window = @import("Window.zig");
-const libuv = @import("libuv");
 const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
 
@@ -20,11 +19,6 @@ alloc: Allocator,
 /// single window operations.
 window: *Window,
 
-// The main event loop for the application. The user data of this loop
-// is always the allocator used to create the loop. This is a convenience
-// so that users of the loop always have an allocator.
-loop: libuv.Loop,
-
 // The configuration for the app.
 config: *const Config,
 
@@ -32,63 +26,23 @@ config: *const Config,
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: Allocator, config: *const Config) !App {
-    // Create the event loop
-    var loop = try libuv.Loop.init(alloc);
-    errdefer loop.deinit(alloc);
-
-    // We always store allocator pointer on the loop data so that
-    // handles can use our global allocator.
-    const allocPtr = try alloc.create(Allocator);
-    errdefer alloc.destroy(allocPtr);
-    allocPtr.* = alloc;
-    loop.setData(allocPtr);
-
     // Create the window
-    var window = try Window.create(alloc, loop, config);
+    var window = try Window.create(alloc, config);
     errdefer window.destroy();
 
     return App{
         .alloc = alloc,
         .window = window,
-        .loop = loop,
         .config = config,
     };
 }
 
 pub fn deinit(self: *App) void {
     self.window.destroy();
-
-    // Run the loop one more time, because destroying our other things
-    // like windows usually cancel all our event loop stuff and we need
-    // one more run through to finalize all the closes.
-    _ = self.loop.run(.default) catch |err|
-        log.err("error finalizing event loop: {}", .{err});
-
-    // Dealloc our allocator copy
-    self.alloc.destroy(self.loop.getData(Allocator).?);
-
-    self.loop.deinit(self.alloc);
     self.* = undefined;
 }
 
 pub fn run(self: App) !void {
-    // We are embedding two event loops: glfw and libuv. To do this, we
-    // create a separate thread that watches for libuv events and notifies
-    // glfw to wake up so we can run the libuv tick.
-    var embed = try libuv.Embed.init(self.alloc, self.loop, (struct {
-        fn callback() void {
-            glfw.postEmptyEvent() catch unreachable;
-        }
-    }).callback);
-    defer embed.deinit(self.alloc);
-    try embed.start();
-
-    // This async handle is used to "wake up" the embed thread so we can
-    // exit immediately once the windows want to close.
-    var async_h = try libuv.Async.init(self.alloc, self.loop, (struct {
-        fn callback(_: *libuv.Async) void {}
-    }).callback);
-
     while (!self.window.shouldClose()) {
         // Block for any glfw events. This may also be an "empty" event
         // posted by the libuv watcher so that we trigger a libuv loop tick.
@@ -96,26 +50,5 @@ pub fn run(self: App) !void {
 
         // Mark this so we're in a totally different "frame"
         tracy.frameMark();
-
-        // Run the libuv loop
-        const frame = tracy.frame("libuv");
-        defer frame.end();
-        try embed.loopRun();
     }
-
-    // Notify the embed thread to stop. We do this before we send on the
-    // async handle so that when the thread goes around it exits.
-    embed.stop();
-
-    // Wake up the event loop and schedule our close.
-    try async_h.send();
-    async_h.close((struct {
-        fn callback(h: *libuv.Async) void {
-            const alloc = h.loop().getData(Allocator).?.*;
-            h.deinit(alloc);
-        }
-    }).callback);
-
-    // Wait for the thread to end which should be almost instant.
-    try embed.join();
 }

commit a2edbb4698e9ec1d31e0ccd2a2b6bdb9deeecaf9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 10:05:08 2022 -0800

    App prepare for multi-window

diff --git a/src/App.zig b/src/App.zig
index 89e96192..c8066557 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -9,46 +9,111 @@ const glfw = @import("glfw");
 const Window = @import("Window.zig");
 const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
+const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
 
 const log = std.log.scoped(.app);
 
+const WindowList = std.ArrayListUnmanaged(*Window);
+
+/// The type used for sending messages to the app thread.
+pub const Mailbox = BlockingQueue(Message, 64);
+
 /// General purpose allocator
 alloc: Allocator,
 
-/// The primary window for the application. We currently support only
-/// single window operations.
-window: *Window,
+/// The list of windows that are currently open
+windows: WindowList,
 
 // The configuration for the app.
 config: *const Config,
 
+/// The mailbox that can be used to send this thread messages. Note
+/// this is a blocking queue so if it is full you will get errors (or block).
+mailbox: *Mailbox,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn init(alloc: Allocator, config: *const Config) !App {
-    // Create the window
+    // The mailbox for messaging this thread
+    var mailbox = try Mailbox.create(alloc);
+    errdefer mailbox.destroy(alloc);
+
+    // Create the first window
     var window = try Window.create(alloc, config);
     errdefer window.destroy();
 
+    // Create our windows list and add our initial window.
+    var windows: WindowList = .{};
+    errdefer windows.deinit(alloc);
+    try windows.append(alloc, window);
+
     return App{
         .alloc = alloc,
-        .window = window,
+        .windows = windows,
         .config = config,
+        .mailbox = mailbox,
     };
 }
 
 pub fn deinit(self: *App) void {
-    self.window.destroy();
+    // Clean up all our windows
+    for (self.windows.items) |window| window.destroy();
+    self.windows.deinit(self.alloc);
+    self.mailbox.destroy(self.alloc);
     self.* = undefined;
 }
 
-pub fn run(self: App) !void {
-    while (!self.window.shouldClose()) {
-        // Block for any glfw events. This may also be an "empty" event
-        // posted by the libuv watcher so that we trigger a libuv loop tick.
+/// Wake up the app event loop. This should be called after any messages
+/// are sent to the mailbox.
+pub fn wakeup(self: App) void {
+    _ = self;
+    glfw.postEmptyEvent() catch {};
+}
+
+/// Run the main event loop for the application. This blocks until the
+/// application quits or every window is closed.
+pub fn run(self: *App) !void {
+    while (self.windows.items.len > 0) {
+        // Block for any glfw events.
         try glfw.waitEvents();
 
         // Mark this so we're in a totally different "frame"
         tracy.frameMark();
+
+        // If any windows are closing, destroy them
+        var i: usize = 0;
+        while (i < self.windows.items.len) {
+            const window = self.windows.items[i];
+            if (window.shouldClose()) {
+                window.destroy();
+                _ = self.windows.swapRemove(i);
+                continue;
+            }
+
+            i += 1;
+        }
+
+        // Drain our mailbox
+        try self.drainMailbox();
     }
 }
+
+/// Drain the mailbox.
+fn drainMailbox(self: *App) !void {
+    var drain = self.mailbox.drain();
+    defer drain.deinit();
+
+    while (drain.next()) |message| {
+        log.debug("mailbox message={}", .{message});
+        switch (message) {
+            .new_window => unreachable,
+        }
+    }
+}
+
+/// The message types that can be sent to the app thread.
+pub const Message = union(enum) {
+    /// Create a new terminal window.
+    new_window: void,
+};

commit ecbd119654e7846fb9931ad3445c9625a0f3414e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 10:34:43 2022 -0800

    Hook up new window, modify renderers

diff --git a/src/App.zig b/src/App.zig
index c8066557..744615f6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -10,6 +10,7 @@ const Window = @import("Window.zig");
 const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
 const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
+const renderer = @import("renderer.zig");
 
 const log = std.log.scoped(.app);
 
@@ -34,34 +35,33 @@ mailbox: *Mailbox,
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
-pub fn init(alloc: Allocator, config: *const Config) !App {
+pub fn create(alloc: Allocator, config: *const Config) !*App {
     // The mailbox for messaging this thread
     var mailbox = try Mailbox.create(alloc);
     errdefer mailbox.destroy(alloc);
 
-    // Create the first window
-    var window = try Window.create(alloc, config);
-    errdefer window.destroy();
-
-    // Create our windows list and add our initial window.
-    var windows: WindowList = .{};
-    errdefer windows.deinit(alloc);
-    try windows.append(alloc, window);
-
-    return App{
+    var app = try alloc.create(App);
+    errdefer alloc.destroy(app);
+    app.* = .{
         .alloc = alloc,
-        .windows = windows,
+        .windows = .{},
         .config = config,
         .mailbox = mailbox,
     };
+    errdefer app.windows.deinit(alloc);
+
+    // Create the first window
+    try app.newWindow();
+
+    return app;
 }
 
-pub fn deinit(self: *App) void {
+pub fn destroy(self: *App) void {
     // Clean up all our windows
     for (self.windows.items) |window| window.destroy();
     self.windows.deinit(self.alloc);
     self.mailbox.destroy(self.alloc);
-    self.* = undefined;
+    self.alloc.destroy(self);
 }
 
 /// Wake up the app event loop. This should be called after any messages
@@ -86,6 +86,11 @@ pub fn run(self: *App) !void {
         while (i < self.windows.items.len) {
             const window = self.windows.items[i];
             if (window.shouldClose()) {
+                // If this was our final window, deinitialize the renderer
+                if (self.windows.items.len == 1) {
+                    renderer.Renderer.lastWindowDeinit();
+                }
+
                 window.destroy();
                 _ = self.windows.swapRemove(i);
                 continue;
@@ -107,11 +112,24 @@ fn drainMailbox(self: *App) !void {
     while (drain.next()) |message| {
         log.debug("mailbox message={}", .{message});
         switch (message) {
-            .new_window => unreachable,
+            .new_window => try self.newWindow(),
         }
     }
 }
 
+/// Create a new window
+fn newWindow(self: *App) !void {
+    var window = try Window.create(self.alloc, self, self.config);
+    errdefer window.destroy();
+    try self.windows.append(self.alloc, window);
+    errdefer _ = self.windows.pop();
+
+    // This was the first window, so we need to initialize our renderer.
+    if (self.windows.items.len == 1) {
+        try window.renderer.firstWindowInit(window.window);
+    }
+}
+
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
     /// Create a new terminal window.

commit c9b01fdc6c0a3daf5db6eb44434ba4756446928b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 14:10:28 2022 -0800

    support app quitting to close all windows

diff --git a/src/App.zig b/src/App.zig
index 744615f6..00187bdc 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -74,7 +74,8 @@ pub fn wakeup(self: App) void {
 /// Run the main event loop for the application. This blocks until the
 /// application quits or every window is closed.
 pub fn run(self: *App) !void {
-    while (self.windows.items.len > 0) {
+    var quit: bool = false;
+    while (!quit and self.windows.items.len > 0) {
         // Block for any glfw events.
         try glfw.waitEvents();
 
@@ -100,12 +101,12 @@ pub fn run(self: *App) !void {
         }
 
         // Drain our mailbox
-        try self.drainMailbox();
+        try self.drainMailbox(&quit);
     }
 }
 
 /// Drain the mailbox.
-fn drainMailbox(self: *App) !void {
+fn drainMailbox(self: *App, quit: *bool) !void {
     var drain = self.mailbox.drain();
     defer drain.deinit();
 
@@ -113,6 +114,7 @@ fn drainMailbox(self: *App) !void {
         log.debug("mailbox message={}", .{message});
         switch (message) {
             .new_window => try self.newWindow(),
+            .quit => quit.* = true,
         }
     }
 }
@@ -134,4 +136,7 @@ fn newWindow(self: *App) !void {
 pub const Message = union(enum) {
     /// Create a new terminal window.
     new_window: void,
+
+    /// Quit
+    quit: void,
 };

commit fd304c93386d5cfb732983ecd2511d72d251f45f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 17:26:01 2022 -0800

    Deinit devmode more cleanly

diff --git a/src/App.zig b/src/App.zig
index 00187bdc..b0dc4fdf 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -32,6 +32,9 @@ config: *const Config,
 /// this is a blocking queue so if it is full you will get errors (or block).
 mailbox: *Mailbox,
 
+/// Set to true once we're quitting. This never goes false again.
+quit: bool,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -47,6 +50,7 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
         .windows = .{},
         .config = config,
         .mailbox = mailbox,
+        .quit = false,
     };
     errdefer app.windows.deinit(alloc);
 
@@ -74,8 +78,7 @@ pub fn wakeup(self: App) void {
 /// Run the main event loop for the application. This blocks until the
 /// application quits or every window is closed.
 pub fn run(self: *App) !void {
-    var quit: bool = false;
-    while (!quit and self.windows.items.len > 0) {
+    while (!self.quit and self.windows.items.len > 0) {
         // Block for any glfw events.
         try glfw.waitEvents();
 
@@ -87,11 +90,6 @@ pub fn run(self: *App) !void {
         while (i < self.windows.items.len) {
             const window = self.windows.items[i];
             if (window.shouldClose()) {
-                // If this was our final window, deinitialize the renderer
-                if (self.windows.items.len == 1) {
-                    renderer.Renderer.lastWindowDeinit();
-                }
-
                 window.destroy();
                 _ = self.windows.swapRemove(i);
                 continue;
@@ -100,13 +98,13 @@ pub fn run(self: *App) !void {
             i += 1;
         }
 
-        // Drain our mailbox
-        try self.drainMailbox(&quit);
+        // Drain our mailbox only if we're not quitting.
+        if (!self.quit) try self.drainMailbox();
     }
 }
 
 /// Drain the mailbox.
-fn drainMailbox(self: *App, quit: *bool) !void {
+fn drainMailbox(self: *App) !void {
     var drain = self.mailbox.drain();
     defer drain.deinit();
 
@@ -114,7 +112,7 @@ fn drainMailbox(self: *App, quit: *bool) !void {
         log.debug("mailbox message={}", .{message});
         switch (message) {
             .new_window => try self.newWindow(),
-            .quit => quit.* = true,
+            .quit => try self.setQuit(),
         }
     }
 }
@@ -125,10 +123,16 @@ fn newWindow(self: *App) !void {
     errdefer window.destroy();
     try self.windows.append(self.alloc, window);
     errdefer _ = self.windows.pop();
+}
+
+/// Start quitting
+fn setQuit(self: *App) !void {
+    if (self.quit) return;
+    self.quit = true;
 
-    // This was the first window, so we need to initialize our renderer.
-    if (self.windows.items.len == 1) {
-        try window.renderer.firstWindowInit(window.window);
+    // Mark that all our windows should close
+    for (self.windows.items) |window| {
+        window.window.setShouldClose(true);
     }
 }
 

commit 5b52333e51042053d17dee8122bd36953fd66b68
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 7 07:45:46 2022 -0800

    name threads and add more tracing

diff --git a/src/App.zig b/src/App.zig
index b0dc4fdf..f04f2ee6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -82,9 +82,6 @@ pub fn run(self: *App) !void {
         // Block for any glfw events.
         try glfw.waitEvents();
 
-        // Mark this so we're in a totally different "frame"
-        tracy.frameMark();
-
         // If any windows are closing, destroy them
         var i: usize = 0;
         while (i < self.windows.items.len) {

commit 4ced2290b3b15fc3f64531bb44a038e6a400c346
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 14 10:46:40 2022 -0800

    OSC handling, handle OSC change window title command

diff --git a/src/App.zig b/src/App.zig
index f04f2ee6..1a55538e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -106,10 +106,11 @@ fn drainMailbox(self: *App) !void {
     defer drain.deinit();
 
     while (drain.next()) |message| {
-        log.debug("mailbox message={}", .{message});
+        log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
             .new_window => try self.newWindow(),
             .quit => try self.setQuit(),
+            .window_message => |msg| try self.windowMessage(msg.window, msg.message),
         }
     }
 }
@@ -133,6 +134,22 @@ fn setQuit(self: *App) !void {
     }
 }
 
+/// Handle a window message
+fn windowMessage(self: *App, win: *Window, msg: Window.Message) !void {
+    // We want to ensure our window is still active. Window messages
+    // are quite rare and we normally don't have many windows so we do
+    // a simple linear search here.
+    for (self.windows.items) |window| {
+        if (window == win) {
+            try win.handleMessage(msg);
+            return;
+        }
+    }
+
+    // Window was not found, it probably quit before we handled the message.
+    // Not a problem.
+}
+
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
     /// Create a new terminal window.
@@ -140,4 +157,10 @@ pub const Message = union(enum) {
 
     /// Quit
     quit: void,
+
+    /// A message for a specific window
+    window_message: struct {
+        window: *Window,
+        message: Window.Message,
+    },
 };

commit 8eb97cd9adf67b2d5d610de7163393d2a4199d6c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 09:51:59 2022 -0800

    Option (def true) to inherit font size on new window

diff --git a/src/App.zig b/src/App.zig
index 1a55538e..a27e78ba 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -11,6 +11,7 @@ const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
 const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
+const font = @import("font/main.zig");
 
 const log = std.log.scoped(.app);
 
@@ -55,7 +56,7 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     errdefer app.windows.deinit(alloc);
 
     // Create the first window
-    try app.newWindow();
+    try app.newWindow(.{});
 
     return app;
 }
@@ -108,7 +109,7 @@ fn drainMailbox(self: *App) !void {
     while (drain.next()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
-            .new_window => try self.newWindow(),
+            .new_window => |msg| try self.newWindow(msg),
             .quit => try self.setQuit(),
             .window_message => |msg| try self.windowMessage(msg.window, msg.message),
         }
@@ -116,11 +117,14 @@ fn drainMailbox(self: *App) !void {
 }
 
 /// Create a new window
-fn newWindow(self: *App) !void {
+fn newWindow(self: *App, msg: Message.NewWindow) !void {
     var window = try Window.create(self.alloc, self, self.config);
     errdefer window.destroy();
     try self.windows.append(self.alloc, window);
     errdefer _ = self.windows.pop();
+
+    // Set initial font size if given
+    if (msg.font_size) |size| window.setFontSize(size);
 }
 
 /// Start quitting
@@ -153,7 +157,7 @@ fn windowMessage(self: *App, win: *Window, msg: Window.Message) !void {
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
     /// Create a new terminal window.
-    new_window: void,
+    new_window: NewWindow,
 
     /// Quit
     quit: void,
@@ -163,4 +167,10 @@ pub const Message = union(enum) {
         window: *Window,
         message: Window.Message,
     },
+
+    const NewWindow = struct {
+        /// The font size to create the window with or null to default to
+        /// the configuration amount.
+        font_size: ?font.face.DesiredSize = null,
+    };
 };

commit bb90104de3f71596b38b9b4c4aadb5d13be7f126
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 20:24:59 2022 -0800

    enable Mac native tabbing

diff --git a/src/App.zig b/src/App.zig
index a27e78ba..a2a81b68 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -4,6 +4,7 @@
 const App = @This();
 
 const std = @import("std");
+const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const Window = @import("Window.zig");
@@ -12,6 +13,8 @@ const Config = @import("config.zig").Config;
 const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
+const macos = @import("macos");
+const objc = @import("objc");
 
 const log = std.log.scoped(.app);
 
@@ -36,6 +39,21 @@ mailbox: *Mailbox,
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
+/// Mac settings
+darwin: if (Darwin.enabled) Darwin else void,
+
+/// Mac-specific settings
+pub const Darwin = struct {
+    pub const enabled = builtin.target.isDarwin();
+
+    tabbing_id: *macos.foundation.String,
+
+    pub fn deinit(self: *Darwin) void {
+        self.tabbing_id.release();
+        self.* = undefined;
+    }
+};
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -52,9 +70,30 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
         .config = config,
         .mailbox = mailbox,
         .quit = false,
+        .darwin = if (Darwin.enabled) undefined else {},
     };
     errdefer app.windows.deinit(alloc);
 
+    // On Mac, we enable window tabbing
+    if (comptime builtin.target.isDarwin()) {
+        const NSWindow = objc.Class.getClass("NSWindow").?;
+        NSWindow.msgSend(void, objc.sel("setAllowsAutomaticWindowTabbing:"), .{true});
+
+        // Our tabbing ID allows all of our windows to group together
+        const tabbing_id = try macos.foundation.String.createWithBytes(
+            "dev.ghostty.window",
+            .utf8,
+            false,
+        );
+        errdefer tabbing_id.release();
+
+        // Setup our Mac settings
+        app.darwin = .{
+            .tabbing_id = tabbing_id,
+        };
+    }
+    errdefer if (comptime builtin.target.isDarwin()) app.darwin.deinit();
+
     // Create the first window
     try app.newWindow(.{});
 

commit 8ac90d33e6de115e6cdb6ef708ce792f3dce2279
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 21:17:41 2022 -0800

    new_tab action

diff --git a/src/App.zig b/src/App.zig
index a2a81b68..fe542d8e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -95,7 +95,7 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     errdefer if (comptime builtin.target.isDarwin()) app.darwin.deinit();
 
     // Create the first window
-    try app.newWindow(.{});
+    _ = try app.newWindow(.{});
 
     return app;
 }
@@ -148,7 +148,8 @@ fn drainMailbox(self: *App) !void {
     while (drain.next()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
-            .new_window => |msg| try self.newWindow(msg),
+            .new_window => |msg| _ = try self.newWindow(msg),
+            .new_tab => |msg| try self.newTab(msg),
             .quit => try self.setQuit(),
             .window_message => |msg| try self.windowMessage(msg.window, msg.message),
         }
@@ -156,7 +157,7 @@ fn drainMailbox(self: *App) !void {
 }
 
 /// Create a new window
-fn newWindow(self: *App, msg: Message.NewWindow) !void {
+fn newWindow(self: *App, msg: Message.NewWindow) !*Window {
     var window = try Window.create(self.alloc, self, self.config);
     errdefer window.destroy();
     try self.windows.append(self.alloc, window);
@@ -164,6 +165,33 @@ fn newWindow(self: *App, msg: Message.NewWindow) !void {
 
     // Set initial font size if given
     if (msg.font_size) |size| window.setFontSize(size);
+
+    return window;
+}
+
+/// Create a new tab in the parent window
+fn newTab(self: *App, msg: Message.NewWindow) !void {
+    if (comptime !builtin.target.isDarwin()) {
+        log.warn("tabbing is not supported on this platform", .{});
+        return;
+    }
+
+    const parent = msg.parent orelse {
+        log.warn("parent must be set in new_tab message", .{});
+        return;
+    };
+
+    // If the parent was closed prior to us handling the message, we do nothing.
+    if (!self.hasWindow(parent)) {
+        log.warn("new_tab parent is gone, not launching a new tab", .{});
+        return;
+    }
+
+    // Create the new window
+    const window = try self.newWindow(msg);
+
+    // Add the window to our parent tab group
+    parent.addWindow(window);
 }
 
 /// Start quitting
@@ -182,22 +210,32 @@ fn windowMessage(self: *App, win: *Window, msg: Window.Message) !void {
     // We want to ensure our window is still active. Window messages
     // are quite rare and we normally don't have many windows so we do
     // a simple linear search here.
-    for (self.windows.items) |window| {
-        if (window == win) {
-            try win.handleMessage(msg);
-            return;
-        }
+    if (self.hasWindow(win)) {
+        try win.handleMessage(msg);
     }
 
     // Window was not found, it probably quit before we handled the message.
     // Not a problem.
 }
 
+fn hasWindow(self: *App, win: *Window) bool {
+    for (self.windows.items) |window| {
+        if (window == win) return true;
+    }
+
+    return false;
+}
+
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
     /// Create a new terminal window.
     new_window: NewWindow,
 
+    /// Create a new tab within the tab group of the focused window.
+    /// This does nothing if we're on a platform or using a window
+    /// environment that doesn't support tabs.
+    new_tab: NewWindow,
+
     /// Quit
     quit: void,
 
@@ -208,6 +246,9 @@ pub const Message = union(enum) {
     },
 
     const NewWindow = struct {
+        /// The parent window, only used for new tabs.
+        parent: ?*Window = null,
+
         /// The font size to create the window with or null to default to
         /// the configuration amount.
         font_size: ?font.face.DesiredSize = null,

commit 357ad43656bd2ee27ecfac9c33a7751d815c6e70
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 21:20:04 2022 -0800

    app: deinit darwin info

diff --git a/src/App.zig b/src/App.zig
index fe542d8e..60e0292a 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -104,6 +104,7 @@ pub fn destroy(self: *App) void {
     // Clean up all our windows
     for (self.windows.items) |window| window.destroy();
     self.windows.deinit(self.alloc);
+    if (comptime builtin.target.isDarwin()) self.darwin.deinit();
     self.mailbox.destroy(self.alloc);
     self.alloc.destroy(self);
 }

commit a15afa8211e30b2215b0be5fce700481fd37a729
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 20 20:16:40 2022 -0800

    do not block channel send while draining channel

diff --git a/src/App.zig b/src/App.zig
index 60e0292a..ab95b8b6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -143,10 +143,7 @@ pub fn run(self: *App) !void {
 
 /// Drain the mailbox.
 fn drainMailbox(self: *App) !void {
-    var drain = self.mailbox.drain();
-    defer drain.deinit();
-
-    while (drain.next()) |message| {
+    while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
             .new_window => |msg| _ = try self.newWindow(msg),

commit 9b0fbde838a97014bb7e05f5426460fc18efbc39
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 21 09:09:25 2022 -0800

    put some config in the devmode UI

diff --git a/src/App.zig b/src/App.zig
index ab95b8b6..514dc813 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -15,6 +15,7 @@ const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
 const macos = @import("macos");
 const objc = @import("objc");
+const DevMode = @import("DevMode.zig");
 
 const log = std.log.scoped(.app);
 
@@ -62,6 +63,9 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     var mailbox = try Mailbox.create(alloc);
     errdefer mailbox.destroy(alloc);
 
+    // If we have DevMode on, store the config so we can show it
+    if (DevMode.enabled) DevMode.instance.config = config;
+
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
     app.* = .{

commit ba0cbecd79ea0773189531bfe65862a9736351c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:18:32 2022 -0800

    core window doesn't have reference to glfw window anymore!

diff --git a/src/App.zig b/src/App.zig
index 514dc813..b83109f2 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -203,7 +203,7 @@ fn setQuit(self: *App) !void {
 
     // Mark that all our windows should close
     for (self.windows.items) |window| {
-        window.window.setShouldClose(true);
+        window.windowing_system.setShouldClose();
     }
 }
 

commit d5895f903479890c2fb61fd80dce32a5bbd7e84e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:32:36 2022 -0800

    rename windowing_system to just window

diff --git a/src/App.zig b/src/App.zig
index b83109f2..9ebf7d69 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -203,7 +203,7 @@ fn setQuit(self: *App) !void {
 
     // Mark that all our windows should close
     for (self.windows.items) |window| {
-        window.windowing_system.setShouldClose();
+        window.window.setShouldClose();
     }
 }
 

commit 83f5d29ae2c87c06958737a026f7d8506561daaf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:48:45 2022 -0800

    initialize glfw in app

diff --git a/src/App.zig b/src/App.zig
index 9ebf7d69..510bb1a0 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -59,6 +59,10 @@ pub const Darwin = struct {
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn create(alloc: Allocator, config: *const Config) !*App {
+    // Initialize glfw
+    try glfw.init(.{});
+    errdefer glfw.terminate();
+
     // The mailbox for messaging this thread
     var mailbox = try Mailbox.create(alloc);
     errdefer mailbox.destroy(alloc);
@@ -111,6 +115,9 @@ pub fn destroy(self: *App) void {
     if (comptime builtin.target.isDarwin()) self.darwin.deinit();
     self.mailbox.destroy(self.alloc);
     self.alloc.destroy(self);
+
+    // Close our windowing runtime
+    glfw.terminate();
 }
 
 /// Wake up the app event loop. This should be called after any messages

commit 58218af2b535b44b8da192c5e852962ca5cb13a4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:56:42 2022 -0800

    app: make apprt agnostic

diff --git a/src/App.zig b/src/App.zig
index 510bb1a0..b640d64c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -6,7 +6,7 @@ const App = @This();
 const std = @import("std");
 const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
-const glfw = @import("glfw");
+const apprt = @import("apprt.zig");
 const Window = @import("Window.zig");
 const tracy = @import("tracy");
 const Config = @import("config.zig").Config;
@@ -27,6 +27,9 @@ pub const Mailbox = BlockingQueue(Message, 64);
 /// General purpose allocator
 alloc: Allocator,
 
+/// The runtime for this app.
+runtime: apprt.runtime.App,
+
 /// The list of windows that are currently open
 windows: WindowList,
 
@@ -59,9 +62,9 @@ pub const Darwin = struct {
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn create(alloc: Allocator, config: *const Config) !*App {
-    // Initialize glfw
-    try glfw.init(.{});
-    errdefer glfw.terminate();
+    // Initialize app runtime
+    var app_backend = try apprt.runtime.App.init();
+    errdefer app_backend.terminate();
 
     // The mailbox for messaging this thread
     var mailbox = try Mailbox.create(alloc);
@@ -74,6 +77,7 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     errdefer alloc.destroy(app);
     app.* = .{
         .alloc = alloc,
+        .runtime = app_backend,
         .windows = .{},
         .config = config,
         .mailbox = mailbox,
@@ -117,22 +121,21 @@ pub fn destroy(self: *App) void {
     self.alloc.destroy(self);
 
     // Close our windowing runtime
-    glfw.terminate();
+    self.runtime.terminate();
 }
 
 /// Wake up the app event loop. This should be called after any messages
 /// are sent to the mailbox.
 pub fn wakeup(self: App) void {
-    _ = self;
-    glfw.postEmptyEvent() catch {};
+    self.runtime.wakeup() catch return;
 }
 
 /// Run the main event loop for the application. This blocks until the
 /// application quits or every window is closed.
 pub fn run(self: *App) !void {
     while (!self.quit and self.windows.items.len > 0) {
-        // Block for any glfw events.
-        try glfw.waitEvents();
+        // Block for any events.
+        try self.runtime.wait();
 
         // If any windows are closing, destroy them
         var i: usize = 0;

commit ce490e21ea49a30e3bcde1c7df48c3d3e6f17bad
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Dec 31 08:53:11 2022 -0800

    can specify a wasm target in build

diff --git a/src/App.zig b/src/App.zig
index b640d64c..e1e01bd0 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -266,3 +266,32 @@ pub const Message = union(enum) {
         font_size: ?font.face.DesiredSize = null,
     };
 };
+
+// Wasm API.
+pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
+    const wasm = @import("os/wasm.zig");
+    const alloc = wasm.alloc;
+
+    // export fn app_new(config: *Config) ?*App {
+    //     return app_new_(config) catch |err| {
+    //         log.err("error initializing app err={}", .{err});
+    //         return null;
+    //     };
+    // }
+    //
+    // fn app_new_(config: *Config) !*App {
+    //     const app = try App.create(alloc, config);
+    //     errdefer app.destroy();
+    //
+    //     const result = try alloc.create(App);
+    //     result.* = app;
+    //     return result;
+    // }
+    //
+    // export fn app_free(ptr: ?*App) void {
+    //     if (ptr) |v| {
+    //         v.destroy();
+    //         alloc.destroy(v);
+    //     }
+    // }
+};

commit 8b80e65928c8e38d9243d423eabdb164b7b1a4a0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 14 13:56:43 2023 -0800

    lots of broken stuff

diff --git a/src/App.zig b/src/App.zig
index e1e01bd0..40293775 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -5,6 +5,7 @@ const App = @This();
 
 const std = @import("std");
 const builtin = @import("builtin");
+const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const apprt = @import("apprt.zig");
 const Window = @import("Window.zig");
@@ -273,8 +274,7 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const alloc = wasm.alloc;
 
     // export fn app_new(config: *Config) ?*App {
-    //     return app_new_(config) catch |err| {
-    //         log.err("error initializing app err={}", .{err});
+    //     return app_new_(config) catch |err| { log.err("error initializing app err={}", .{err});
     //         return null;
     //     };
     // }
@@ -295,3 +295,15 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     //     }
     // }
 };
+
+pub const CAPI = struct {
+    const ProcessState = @import("main.zig").ProcessState;
+    var state: ?ProcessState = null;
+
+    export fn ghostty_init() c_int {
+        assert(state == null);
+        state = undefined;
+        ProcessState.init(&state.?);
+        return 0;
+    }
+};

commit 9bd527fe00a89aa34f396e82609e8913c2410e31
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 14 15:53:28 2023 -0800

    macos: config API

diff --git a/src/App.zig b/src/App.zig
index 40293775..aaeca8f8 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -297,13 +297,5 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
 };
 
 pub const CAPI = struct {
-    const ProcessState = @import("main.zig").ProcessState;
-    var state: ?ProcessState = null;
-
-    export fn ghostty_init() c_int {
-        assert(state == null);
-        state = undefined;
-        ProcessState.init(&state.?);
-        return 0;
-    }
+    const Ghostty = @import("main_c.zig").Ghostty;
 };

commit f30d80cabec688d17585af3f8169a4fb9a39bd8a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 14 21:48:13 2023 -0800

    build: must set run condition to always now

diff --git a/src/App.zig b/src/App.zig
index aaeca8f8..685aea44 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -295,7 +295,3 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     //     }
     // }
 };
-
-pub const CAPI = struct {
-    const Ghostty = @import("main_c.zig").Ghostty;
-};

commit ba8f142770a1103adc9ad799ffc566729af18972
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 15 21:53:14 2023 -0800

    app: only create first window in exe mode

diff --git a/src/App.zig b/src/App.zig
index 685aea44..78fccbde 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -7,6 +7,7 @@ const std = @import("std");
 const builtin = @import("builtin");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
+const build_config = @import("build_config.zig");
 const apprt = @import("apprt.zig");
 const Window = @import("Window.zig");
 const tracy = @import("tracy");
@@ -47,9 +48,11 @@ quit: bool,
 /// Mac settings
 darwin: if (Darwin.enabled) Darwin else void,
 
-/// Mac-specific settings
+/// Mac-specific settings. This is only enabled when the target is
+/// Mac and the artifact is a standalone exe. We don't target libs because
+/// the embedded API doesn't do windowing.
 pub const Darwin = struct {
-    pub const enabled = builtin.target.isDarwin();
+    pub const enabled = builtin.target.isDarwin() and build_config.artifact == .exe;
 
     tabbing_id: *macos.foundation.String,
 
@@ -87,8 +90,9 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     };
     errdefer app.windows.deinit(alloc);
 
-    // On Mac, we enable window tabbing
-    if (comptime builtin.target.isDarwin()) {
+    // On Mac, we enable window tabbing. We only do this if we're building
+    // a standalone exe. In embedded mode the host app handles this for us.
+    if (Darwin.enabled) {
         const NSWindow = objc.Class.getClass("NSWindow").?;
         NSWindow.msgSend(void, objc.sel("setAllowsAutomaticWindowTabbing:"), .{true});
 
@@ -107,8 +111,12 @@ pub fn create(alloc: Allocator, config: *const Config) !*App {
     }
     errdefer if (comptime builtin.target.isDarwin()) app.darwin.deinit();
 
-    // Create the first window
-    _ = try app.newWindow(.{});
+    // Create the first window if we're an executable. If we're a lib we
+    // do NOT create the first window because we expect the embedded API
+    // to do it via surfaces.
+    if (build_config.artifact == .exe) {
+        _ = try app.newWindow(.{});
+    }
 
     return app;
 }
@@ -117,7 +125,7 @@ pub fn destroy(self: *App) void {
     // Clean up all our windows
     for (self.windows.items) |window| window.destroy();
     self.windows.deinit(self.alloc);
-    if (comptime builtin.target.isDarwin()) self.darwin.deinit();
+    if (Darwin.enabled) self.darwin.deinit();
     self.mailbox.destroy(self.alloc);
     self.alloc.destroy(self);
 

commit eed6979868573df6786406c568204bf02d01a27d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 16 08:52:40 2023 -0800

    apprt: start embedded implement, make App API available to C

diff --git a/src/App.zig b/src/App.zig
index 78fccbde..731a6ee6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -65,9 +65,13 @@ pub const Darwin = struct {
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
-pub fn create(alloc: Allocator, config: *const Config) !*App {
+pub fn create(
+    alloc: Allocator,
+    rt_opts: apprt.runtime.App.Options,
+    config: *const Config,
+) !*App {
     // Initialize app runtime
-    var app_backend = try apprt.runtime.App.init();
+    var app_backend = try apprt.runtime.App.init(rt_opts);
     errdefer app_backend.terminate();
 
     // The mailbox for messaging this thread
@@ -303,3 +307,35 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     //     }
     // }
 };
+
+// C API
+pub const CAPI = struct {
+    const global = &@import("main.zig").state;
+
+    /// Create a new app.
+    export fn ghostty_app_new(
+        opts: *const apprt.runtime.App.Options,
+        config: *const Config,
+    ) ?*App {
+        return app_new_(opts, config) catch |err| {
+            log.err("error initializing app err={}", .{err});
+            return null;
+        };
+    }
+
+    fn app_new_(
+        opts: *const apprt.runtime.App.Options,
+        config: *const Config,
+    ) !*App {
+        const app = try App.create(global.alloc, opts.*, config);
+        errdefer app.destroy();
+        return app;
+    }
+
+    export fn ghostty_app_free(ptr: ?*App) void {
+        if (ptr) |v| {
+            v.destroy();
+            v.alloc.destroy(v);
+        }
+    }
+};

commit 085d462a688d68e900bd437551097e7f0c9ff479
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 08:49:43 2023 -0800

    lots of stubbing so window will kind of compile for embedded

diff --git a/src/App.zig b/src/App.zig
index 731a6ee6..462847d1 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -147,25 +147,31 @@ pub fn wakeup(self: App) void {
 /// application quits or every window is closed.
 pub fn run(self: *App) !void {
     while (!self.quit and self.windows.items.len > 0) {
-        // Block for any events.
-        try self.runtime.wait();
-
-        // If any windows are closing, destroy them
-        var i: usize = 0;
-        while (i < self.windows.items.len) {
-            const window = self.windows.items[i];
-            if (window.shouldClose()) {
-                window.destroy();
-                _ = self.windows.swapRemove(i);
-                continue;
-            }
-
-            i += 1;
+        try self.tick();
+    }
+}
+
+/// Tick ticks the app loop. This will drain our mailbox and process those
+/// events.
+pub fn tick(self: *App) !void {
+    // Block for any events.
+    try self.runtime.wait();
+
+    // If any windows are closing, destroy them
+    var i: usize = 0;
+    while (i < self.windows.items.len) {
+        const window = self.windows.items[i];
+        if (window.shouldClose()) {
+            window.destroy();
+            _ = self.windows.swapRemove(i);
+            continue;
         }
 
-        // Drain our mailbox only if we're not quitting.
-        if (!self.quit) try self.drainMailbox();
+        i += 1;
     }
+
+    // Drain our mailbox only if we're not quitting.
+    if (!self.quit) try self.drainMailbox();
 }
 
 /// Drain the mailbox.
@@ -201,6 +207,11 @@ fn newTab(self: *App, msg: Message.NewWindow) !void {
         return;
     }
 
+    if (comptime build_config.artifact != .exe) {
+        log.warn("tabbing is not supported in embedded mode", .{});
+        return;
+    }
+
     const parent = msg.parent orelse {
         log.warn("parent must be set in new_tab message", .{});
         return;
@@ -332,6 +343,14 @@ pub const CAPI = struct {
         return app;
     }
 
+    /// Tick the event loop. This should be called whenever the "wakeup"
+    /// callback is invoked for the runtime.
+    export fn ghostty_app_tick(v: *App) void {
+        v.tick() catch |err| {
+            log.err("error app tick err={}", .{err});
+        };
+    }
+
     export fn ghostty_app_free(ptr: ?*App) void {
         if (ptr) |v| {
             v.destroy();

commit c68f8082df8dfffe1730394d1a5b4c0b6798f751
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 09:03:23 2023 -0800

    apprt: can pass options through to Windows

diff --git a/src/App.zig b/src/App.zig
index 462847d1..c55f22d6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -189,7 +189,11 @@ fn drainMailbox(self: *App) !void {
 
 /// Create a new window
 fn newWindow(self: *App, msg: Message.NewWindow) !*Window {
-    var window = try Window.create(self.alloc, self, self.config);
+    if (comptime build_config.artifact != .exe) {
+        @panic("newWindow is not supported for embedded ghostty");
+    }
+
+    var window = try Window.create(self.alloc, self, self.config, .{});
     errdefer window.destroy();
     try self.windows.append(self.alloc, window);
     errdefer _ = self.windows.pop();

commit 55b05b22bb9c3f83eafc55ab80f3819d741f68eb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 12:31:35 2023 -0800

    c: create/destroy surface API

diff --git a/src/App.zig b/src/App.zig
index c55f22d6..2c70d399 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -115,13 +115,6 @@ pub fn create(
     }
     errdefer if (comptime builtin.target.isDarwin()) app.darwin.deinit();
 
-    // Create the first window if we're an executable. If we're a lib we
-    // do NOT create the first window because we expect the embedded API
-    // to do it via surfaces.
-    if (build_config.artifact == .exe) {
-        _ = try app.newWindow(.{});
-    }
-
     return app;
 }
 
@@ -174,6 +167,37 @@ pub fn tick(self: *App) !void {
     if (!self.quit) try self.drainMailbox();
 }
 
+/// Create a new window. This can be called only on the main thread. This
+/// can be called prior to ever running the app loop.
+pub fn newWindow(self: *App, msg: Message.NewWindow) !*Window {
+    var window = try Window.create(self.alloc, self, self.config, msg.runtime);
+    errdefer window.destroy();
+
+    try self.windows.append(self.alloc, window);
+    errdefer _ = self.windows.pop();
+
+    // Set initial font size if given
+    if (msg.font_size) |size| window.setFontSize(size);
+
+    return window;
+}
+
+/// Close a window and free all resources associated with it. This can
+/// only be called from the main thread.
+pub fn closeWindow(self: *App, window: *Window) void {
+    var i: usize = 0;
+    while (i < self.windows.items.len) {
+        const current = self.windows.items[i];
+        if (window == current) {
+            window.destroy();
+            _ = self.windows.swapRemove(i);
+            return;
+        }
+
+        i += 1;
+    }
+}
+
 /// Drain the mailbox.
 fn drainMailbox(self: *App) !void {
     while (self.mailbox.pop()) |message| {
@@ -187,23 +211,6 @@ fn drainMailbox(self: *App) !void {
     }
 }
 
-/// Create a new window
-fn newWindow(self: *App, msg: Message.NewWindow) !*Window {
-    if (comptime build_config.artifact != .exe) {
-        @panic("newWindow is not supported for embedded ghostty");
-    }
-
-    var window = try Window.create(self.alloc, self, self.config, .{});
-    errdefer window.destroy();
-    try self.windows.append(self.alloc, window);
-    errdefer _ = self.windows.pop();
-
-    // Set initial font size if given
-    if (msg.font_size) |size| window.setFontSize(size);
-
-    return window;
-}
-
 /// Create a new tab in the parent window
 fn newTab(self: *App, msg: Message.NewWindow) !void {
     if (comptime !builtin.target.isDarwin()) {
@@ -286,6 +293,9 @@ pub const Message = union(enum) {
     },
 
     const NewWindow = struct {
+        /// Runtime-specific window options.
+        runtime: apprt.runtime.Window.Options = .{},
+
         /// The parent window, only used for new tabs.
         parent: ?*Window = null,
 
@@ -361,4 +371,28 @@ pub const CAPI = struct {
             v.alloc.destroy(v);
         }
     }
+
+    /// Create a new surface as part of an app.
+    export fn ghostty_surface_new(
+        app: *App,
+        opts: *const apprt.runtime.Window.Options,
+    ) ?*Window {
+        return surface_new_(app, opts) catch |err| {
+            log.err("error initializing surface err={}", .{err});
+            return null;
+        };
+    }
+
+    fn surface_new_(
+        app: *App,
+        opts: *const apprt.runtime.Window.Options,
+    ) !*Window {
+        _ = opts;
+        const w = try app.newWindow(.{});
+        return w;
+    }
+
+    export fn ghostty_surface_free(ptr: ?*Window) void {
+        if (ptr) |v| v.app.closeWindow(v);
+    }
 };

commit ff9af8a07b88ff075ede0c7ebca919a18668be71
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 15:49:19 2023 -0800

    lots of progress running a surface but still crashes

diff --git a/src/App.zig b/src/App.zig
index 2c70d399..1d4b833f 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -387,8 +387,9 @@ pub const CAPI = struct {
         app: *App,
         opts: *const apprt.runtime.Window.Options,
     ) !*Window {
-        _ = opts;
-        const w = try app.newWindow(.{});
+        const w = try app.newWindow(.{
+            .runtime = opts.*,
+        });
         return w;
     }
 

commit cd77408efc9f4867296838d73ee8bc1f3ad9a1f8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 20:07:51 2023 -0800

    it draws!

diff --git a/src/App.zig b/src/App.zig
index 1d4b833f..982deb6b 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -396,4 +396,10 @@ pub const CAPI = struct {
     export fn ghostty_surface_free(ptr: ?*Window) void {
         if (ptr) |v| v.app.closeWindow(v);
     }
+
+    /// Update the size of a surface. This will trigger resize notifications
+    /// to the pty and the renderer.
+    export fn ghostty_surface_set_size(win: *Window, w: u32, h: u32) void {
+        win.window.updateSize(w, h);
+    }
 };

commit 074664398a1c30f1f75bb8f363a86234b927150c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 21:45:52 2023 -0800

    macos: correct scale factor propagated

diff --git a/src/App.zig b/src/App.zig
index 982deb6b..71793666 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -397,9 +397,19 @@ pub const CAPI = struct {
         if (ptr) |v| v.app.closeWindow(v);
     }
 
+    /// Tell the surface that it needs to schedule a render
+    export fn ghostty_surface_refresh(win: *Window) void {
+        win.window.refresh();
+    }
+
     /// Update the size of a surface. This will trigger resize notifications
     /// to the pty and the renderer.
     export fn ghostty_surface_set_size(win: *Window, w: u32, h: u32) void {
         win.window.updateSize(w, h);
     }
+
+    /// Update the content scale of the surface.
+    export fn ghostty_surface_set_content_scale(win: *Window, x: f64, y: f64) void {
+        win.window.updateContentScale(x, y);
+    }
 };

commit 573b163636d5c76ff2592d07bfdff434d2671dd0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 22:12:03 2023 -0800

    start input, its broken but we're getting there

diff --git a/src/App.zig b/src/App.zig
index 71793666..e28f3b76 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -11,6 +11,7 @@ const build_config = @import("build_config.zig");
 const apprt = @import("apprt.zig");
 const Window = @import("Window.zig");
 const tracy = @import("tracy");
+const input = @import("input.zig");
 const Config = @import("config.zig").Config;
 const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
@@ -412,4 +413,14 @@ pub const CAPI = struct {
     export fn ghostty_surface_set_content_scale(win: *Window, x: f64, y: f64) void {
         win.window.updateContentScale(x, y);
     }
+
+    /// Tell the surface that it needs to schedule a render
+    export fn ghostty_surface_key(
+        win: *Window,
+        action: input.Action,
+        key: input.Key,
+        mods: input.Mods,
+    ) void {
+        win.window.keyCallback(action, key, mods);
+    }
 };

commit 4b44b2bc95ae94088f3e891f19b517a83e0d52eb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 18 09:59:45 2023 -0800

    c: fix enums for input

diff --git a/src/App.zig b/src/App.zig
index e28f3b76..129214fa 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -419,8 +419,12 @@ pub const CAPI = struct {
         win: *Window,
         action: input.Action,
         key: input.Key,
-        mods: input.Mods,
+        mods: c_int,
     ) void {
-        win.window.keyCallback(action, key, mods);
+        win.window.keyCallback(
+            action,
+            key,
+            @bitCast(input.Mods, @truncate(u8, @bitCast(c_uint, mods))),
+        );
     }
 };

commit 7a368da0991ea47b75232af3e0b51651996e91b5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 18 11:08:54 2023 -0800

    macos: hook up text input

diff --git a/src/App.zig b/src/App.zig
index 129214fa..3a6e5097 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -427,4 +427,9 @@ pub const CAPI = struct {
             @bitCast(input.Mods, @truncate(u8, @bitCast(c_uint, mods))),
         );
     }
+
+    /// Tell the surface that it needs to schedule a render
+    export fn ghostty_surface_char(win: *Window, codepoint: u32) void {
+        win.window.charCallback(codepoint);
+    }
 };

commit 6b450f7c7d597dac5debe33452a6e83fac830aaa
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 18 16:51:36 2023 -0800

    macos: track surface focus state

diff --git a/src/App.zig b/src/App.zig
index 3a6e5097..948e409c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -414,6 +414,11 @@ pub const CAPI = struct {
         win.window.updateContentScale(x, y);
     }
 
+    /// Update the focused state of a surface.
+    export fn ghostty_surface_set_focus(win: *Window, focused: bool) void {
+        win.window.focusCallback(focused);
+    }
+
     /// Tell the surface that it needs to schedule a render
     export fn ghostty_surface_key(
         win: *Window,

commit e92d90b8d5bae2f478b480bc047a0e4b80d9918a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Feb 19 09:04:51 2023 -0800

    macos: new tab implementation

diff --git a/src/App.zig b/src/App.zig
index 948e409c..a29f8733 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -219,6 +219,8 @@ fn newTab(self: *App, msg: Message.NewWindow) !void {
         return;
     }
 
+    // In embedded mode, it is up to the embedder to implement tabbing
+    // on their own.
     if (comptime build_config.artifact != .exe) {
         log.warn("tabbing is not supported in embedded mode", .{});
         return;

commit 1659f52175516e06181ef442519d2217b90c4152
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Feb 19 09:42:56 2023 -0800

    macos: mouse button and mouse move events

diff --git a/src/App.zig b/src/App.zig
index a29f8733..c7fc751d 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -439,4 +439,23 @@ pub const CAPI = struct {
     export fn ghostty_surface_char(win: *Window, codepoint: u32) void {
         win.window.charCallback(codepoint);
     }
+
+    /// Tell the surface that it needs to schedule a render
+    export fn ghostty_surface_mouse_button(
+        win: *Window,
+        action: input.MouseButtonState,
+        button: input.MouseButton,
+        mods: c_int,
+    ) void {
+        win.window.mouseButtonCallback(
+            action,
+            button,
+            @bitCast(input.Mods, @truncate(u8, @bitCast(c_uint, mods))),
+        );
+    }
+
+    /// Update the mouse position within the view.
+    export fn ghostty_surface_mouse_pos(win: *Window, x: f64, y: f64) void {
+        win.window.cursorPosCallback(x, y);
+    }
 };

commit f1ebc6953e0cd61432b06230c7b4453d3ff2364b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Feb 19 09:46:50 2023 -0800

    macos: mouse scroll events

diff --git a/src/App.zig b/src/App.zig
index c7fc751d..5857154c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -458,4 +458,8 @@ pub const CAPI = struct {
     export fn ghostty_surface_mouse_pos(win: *Window, x: f64, y: f64) void {
         win.window.cursorPosCallback(x, y);
     }
+
+    export fn ghostty_surface_mouse_scroll(win: *Window, x: f64, y: f64) void {
+        win.window.scrollCallback(x, y);
+    }
 };

commit 8889dd7de2cde3cdcd9b540d733aaa455b80e7db
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Feb 19 12:28:17 2023 -0800

    macos: emoji keyboard works

diff --git a/src/App.zig b/src/App.zig
index 5857154c..29d3fc61 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -462,4 +462,10 @@ pub const CAPI = struct {
     export fn ghostty_surface_mouse_scroll(win: *Window, x: f64, y: f64) void {
         win.window.scrollCallback(x, y);
     }
+
+    export fn ghostty_surface_ime_point(win: *Window, x: *f64, y: *f64) void {
+        const pos = win.imePoint();
+        x.* = pos.x;
+        y.* = pos.y;
+    }
 };

commit dff45003e1bd6493a98f088c4767f544bc193f4e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Feb 19 15:18:01 2023 -0800

    macos: hook up clipboards

diff --git a/src/App.zig b/src/App.zig
index 29d3fc61..4efbda3b 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -368,6 +368,11 @@ pub const CAPI = struct {
         };
     }
 
+    /// Return the userdata associated with the app.
+    export fn ghostty_app_userdata(v: *App) ?*anyopaque {
+        return v.runtime.opts.userdata;
+    }
+
     export fn ghostty_app_free(ptr: ?*App) void {
         if (ptr) |v| {
             v.destroy();
@@ -400,6 +405,11 @@ pub const CAPI = struct {
         if (ptr) |v| v.app.closeWindow(v);
     }
 
+    /// Returns the app associated with a surface.
+    export fn ghostty_surface_app(win: *Window) *App {
+        return win.app;
+    }
+
     /// Tell the surface that it needs to schedule a render
     export fn ghostty_surface_refresh(win: *Window) void {
         win.window.refresh();

commit f268f3955e4b64fcc201c1aec5a40a390ed35bf5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 21 08:20:13 2023 -0800

    init gtk app

diff --git a/src/App.zig b/src/App.zig
index 4efbda3b..267b4f98 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -125,10 +125,11 @@ pub fn destroy(self: *App) void {
     self.windows.deinit(self.alloc);
     if (Darwin.enabled) self.darwin.deinit();
     self.mailbox.destroy(self.alloc);
-    self.alloc.destroy(self);
 
     // Close our windowing runtime
     self.runtime.terminate();
+
+    self.alloc.destroy(self);
 }
 
 /// Wake up the app event loop. This should be called after any messages
@@ -164,7 +165,7 @@ pub fn tick(self: *App) !void {
         i += 1;
     }
 
-    // Drain our mailbox only if we're not quitting.
+    // // Drain our mailbox only if we're not quitting.
     if (!self.quit) try self.drainMailbox();
 }
 

commit 3d8c62c41ff673a5156388863db8f70680d3e05e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 12:24:22 2023 -0800

    apprt refactor in progress, launches glfw no window

diff --git a/src/App.zig b/src/App.zig
index 267b4f98..4f8fdc85 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -30,9 +30,6 @@ pub const Mailbox = BlockingQueue(Message, 64);
 /// General purpose allocator
 alloc: Allocator,
 
-/// The runtime for this app.
-runtime: apprt.runtime.App,
-
 /// The list of windows that are currently open
 windows: WindowList,
 
@@ -46,35 +43,16 @@ mailbox: *Mailbox,
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
-/// Mac settings
-darwin: if (Darwin.enabled) Darwin else void,
-
-/// Mac-specific settings. This is only enabled when the target is
-/// Mac and the artifact is a standalone exe. We don't target libs because
-/// the embedded API doesn't do windowing.
-pub const Darwin = struct {
-    pub const enabled = builtin.target.isDarwin() and build_config.artifact == .exe;
-
-    tabbing_id: *macos.foundation.String,
-
-    pub fn deinit(self: *Darwin) void {
-        self.tabbing_id.release();
-        self.* = undefined;
-    }
-};
+/// App will call this when tick should be called.
+wakeup_cb: ?*const fn () void = null,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
 pub fn create(
     alloc: Allocator,
-    rt_opts: apprt.runtime.App.Options,
     config: *const Config,
 ) !*App {
-    // Initialize app runtime
-    var app_backend = try apprt.runtime.App.init(rt_opts);
-    errdefer app_backend.terminate();
-
     // The mailbox for messaging this thread
     var mailbox = try Mailbox.create(alloc);
     errdefer mailbox.destroy(alloc);
@@ -86,36 +64,13 @@ pub fn create(
     errdefer alloc.destroy(app);
     app.* = .{
         .alloc = alloc,
-        .runtime = app_backend,
         .windows = .{},
         .config = config,
         .mailbox = mailbox,
         .quit = false,
-        .darwin = if (Darwin.enabled) undefined else {},
     };
     errdefer app.windows.deinit(alloc);
 
-    // On Mac, we enable window tabbing. We only do this if we're building
-    // a standalone exe. In embedded mode the host app handles this for us.
-    if (Darwin.enabled) {
-        const NSWindow = objc.Class.getClass("NSWindow").?;
-        NSWindow.msgSend(void, objc.sel("setAllowsAutomaticWindowTabbing:"), .{true});
-
-        // Our tabbing ID allows all of our windows to group together
-        const tabbing_id = try macos.foundation.String.createWithBytes(
-            "dev.ghostty.window",
-            .utf8,
-            false,
-        );
-        errdefer tabbing_id.release();
-
-        // Setup our Mac settings
-        app.darwin = .{
-            .tabbing_id = tabbing_id,
-        };
-    }
-    errdefer if (comptime builtin.target.isDarwin()) app.darwin.deinit();
-
     return app;
 }
 
@@ -123,35 +78,22 @@ pub fn destroy(self: *App) void {
     // Clean up all our windows
     for (self.windows.items) |window| window.destroy();
     self.windows.deinit(self.alloc);
-    if (Darwin.enabled) self.darwin.deinit();
     self.mailbox.destroy(self.alloc);
 
-    // Close our windowing runtime
-    self.runtime.terminate();
-
     self.alloc.destroy(self);
 }
 
-/// Wake up the app event loop. This should be called after any messages
-/// are sent to the mailbox.
+/// Request the app runtime to process app events via tick.
 pub fn wakeup(self: App) void {
-    self.runtime.wakeup() catch return;
-}
-
-/// Run the main event loop for the application. This blocks until the
-/// application quits or every window is closed.
-pub fn run(self: *App) !void {
-    while (!self.quit and self.windows.items.len > 0) {
-        try self.tick();
-    }
+    if (self.wakeup_cb) |cb| cb();
 }
 
 /// Tick ticks the app loop. This will drain our mailbox and process those
-/// events.
-pub fn tick(self: *App) !void {
-    // Block for any events.
-    try self.runtime.wait();
-
+/// events. This should be called by the application runtime on every loop
+/// tick.
+///
+/// This returns whether the app should quit or not.
+pub fn tick(self: *App, rt_app: *apprt.runtime.App) !bool {
     // If any windows are closing, destroy them
     var i: usize = 0;
     while (i < self.windows.items.len) {
@@ -165,8 +107,11 @@ pub fn tick(self: *App) !void {
         i += 1;
     }
 
-    // // Drain our mailbox only if we're not quitting.
-    if (!self.quit) try self.drainMailbox();
+    // Drain our mailbox only if we're not quitting.
+    if (!self.quit) try self.drainMailbox(rt_app);
+
+    // We quit if our quit flag is on or if we have closed all windows.
+    return self.quit or self.windows.items.len == 0;
 }
 
 /// Create a new window. This can be called only on the main thread. This
@@ -201,7 +146,9 @@ pub fn closeWindow(self: *App, window: *Window) void {
 }
 
 /// Drain the mailbox.
-fn drainMailbox(self: *App) !void {
+fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
+    _ = rt_app;
+
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {

commit fbe35c226bf354d7c256d2bb5970f434d567889a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 14:37:37 2023 -0800

    Integrating new surface

diff --git a/src/App.zig b/src/App.zig
index 4f8fdc85..6819d505 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -9,7 +9,7 @@ const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const build_config = @import("build_config.zig");
 const apprt = @import("apprt.zig");
-const Window = @import("Window.zig");
+const Surface = @import("Surface.zig");
 const tracy = @import("tracy");
 const input = @import("input.zig");
 const Config = @import("config.zig").Config;
@@ -22,7 +22,8 @@ const DevMode = @import("DevMode.zig");
 
 const log = std.log.scoped(.app);
 
-const WindowList = std.ArrayListUnmanaged(*Window);
+const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);
+const SurfacePool = std.heap.MemoryPool(apprt.Surface);
 
 /// The type used for sending messages to the app thread.
 pub const Mailbox = BlockingQueue(Message, 64);
@@ -30,8 +31,14 @@ pub const Mailbox = BlockingQueue(Message, 64);
 /// General purpose allocator
 alloc: Allocator,
 
-/// The list of windows that are currently open
-windows: WindowList,
+/// The list of surfaces that are currently active.
+surfaces: SurfaceList,
+
+/// The memory pool to request surfaces. We use a memory pool because surfaces
+/// typically require stable pointers due to runtime GUI callbacks. Centralizing
+/// all the allocations in this pool makes it so that all our pools remain
+/// close in memory.
+surface_pool: SurfacePool,
 
 // The configuration for the app.
 config: *const Config,
@@ -64,20 +71,23 @@ pub fn create(
     errdefer alloc.destroy(app);
     app.* = .{
         .alloc = alloc,
-        .windows = .{},
+        .surfaces = .{},
+        .surface_pool = try SurfacePool.initPreheated(alloc, 2),
         .config = config,
         .mailbox = mailbox,
         .quit = false,
     };
-    errdefer app.windows.deinit(alloc);
+    errdefer app.surfaces.deinit(alloc);
+    errdefer app.surface_pool.deinit();
 
     return app;
 }
 
 pub fn destroy(self: *App) void {
-    // Clean up all our windows
-    for (self.windows.items) |window| window.destroy();
-    self.windows.deinit(self.alloc);
+    // Clean up all our surfaces
+    for (self.surfaces.items) |surface| surface.deinit();
+    self.surfaces.deinit(self.alloc);
+    self.surface_pool.deinit();
     self.mailbox.destroy(self.alloc);
 
     self.alloc.destroy(self);
@@ -94,13 +104,14 @@ pub fn wakeup(self: App) void {
 ///
 /// This returns whether the app should quit or not.
 pub fn tick(self: *App, rt_app: *apprt.runtime.App) !bool {
-    // If any windows are closing, destroy them
+    // If any surfaces are closing, destroy them
     var i: usize = 0;
-    while (i < self.windows.items.len) {
-        const window = self.windows.items[i];
-        if (window.shouldClose()) {
-            window.destroy();
-            _ = self.windows.swapRemove(i);
+    while (i < self.surfaces.items.len) {
+        const surface = self.surfaces.items[i];
+        if (surface.shouldClose()) {
+            surface.deinit();
+            _ = self.surfaces.swapRemove(i);
+            self.surface_pool.destroy(surface);
             continue;
         }
 
@@ -110,52 +121,56 @@ pub fn tick(self: *App, rt_app: *apprt.runtime.App) !bool {
     // Drain our mailbox only if we're not quitting.
     if (!self.quit) try self.drainMailbox(rt_app);
 
-    // We quit if our quit flag is on or if we have closed all windows.
-    return self.quit or self.windows.items.len == 0;
+    // We quit if our quit flag is on or if we have closed all surfaces.
+    return self.quit or self.surfaces.items.len == 0;
 }
 
-/// Create a new window. This can be called only on the main thread. This
-/// can be called prior to ever running the app loop.
-pub fn newWindow(self: *App, msg: Message.NewWindow) !*Window {
-    var window = try Window.create(self.alloc, self, self.config, msg.runtime);
-    errdefer window.destroy();
-
-    try self.windows.append(self.alloc, window);
-    errdefer _ = self.windows.pop();
-
-    // Set initial font size if given
-    if (msg.font_size) |size| window.setFontSize(size);
-
-    return window;
+/// Add an initialized surface. This is really only for the runtime
+/// implementations to call and should NOT be called by general app users.
+/// The surface must be from the pool.
+pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
+    try self.surfaces.append(self.alloc, rt_surface);
 }
 
-/// Close a window and free all resources associated with it. This can
-/// only be called from the main thread.
-pub fn closeWindow(self: *App, window: *Window) void {
+/// Delete the surface from the known surface list. This will NOT call the
+/// destructor or free the memory.
+pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
     var i: usize = 0;
-    while (i < self.windows.items.len) {
-        const current = self.windows.items[i];
-        if (window == current) {
-            window.destroy();
-            _ = self.windows.swapRemove(i);
-            return;
+    while (i < self.surfaces.items.len) {
+        if (self.surfaces.items[i] == rt_surface) {
+            _ = self.surfaces.swapRemove(i);
         }
-
-        i += 1;
     }
 }
 
+/// Close a window and free all resources associated with it. This can
+/// only be called from the main thread.
+// pub fn closeWindow(self: *App, window: *Window) void {
+//     var i: usize = 0;
+//     while (i < self.surfaces.items.len) {
+//         const current = self.surfaces.items[i];
+//         if (window == current) {
+//             window.destroy();
+//             _ = self.surfaces.swapRemove(i);
+//             return;
+//         }
+//
+//         i += 1;
+//     }
+// }
+
 /// Drain the mailbox.
 fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
-    _ = rt_app;
-
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
-            .new_window => |msg| _ = try self.newWindow(msg),
+            .new_window => |msg| {
+                _ = msg; // TODO
+                try rt_app.newWindow();
+            },
             .new_tab => |msg| try self.newTab(msg),
             .quit => try self.setQuit(),
-            .window_message => |msg| try self.windowMessage(msg.window, msg.message),
+            .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
         }
     }
 }
@@ -180,7 +195,7 @@ fn newTab(self: *App, msg: Message.NewWindow) !void {
     };
 
     // If the parent was closed prior to us handling the message, we do nothing.
-    if (!self.hasWindow(parent)) {
+    if (!self.hasSurface(parent)) {
         log.warn("new_tab parent is gone, not launching a new tab", .{});
         return;
     }
@@ -197,28 +212,28 @@ fn setQuit(self: *App) !void {
     if (self.quit) return;
     self.quit = true;
 
-    // Mark that all our windows should close
-    for (self.windows.items) |window| {
-        window.window.setShouldClose();
+    // Mark that all our surfaces should close
+    for (self.surfaces.items) |surface| {
+        surface.setShouldClose();
     }
 }
 
 /// Handle a window message
-fn windowMessage(self: *App, win: *Window, msg: Window.Message) !void {
+fn surfaceMessage(self: *App, surface: *Surface, msg: apprt.surface.Message) !void {
     // We want to ensure our window is still active. Window messages
     // are quite rare and we normally don't have many windows so we do
     // a simple linear search here.
-    if (self.hasWindow(win)) {
-        try win.handleMessage(msg);
+    if (self.hasSurface(surface)) {
+        try surface.handleMessage(msg);
     }
 
     // Window was not found, it probably quit before we handled the message.
     // Not a problem.
 }
 
-fn hasWindow(self: *App, win: *Window) bool {
-    for (self.windows.items) |window| {
-        if (window == win) return true;
+fn hasSurface(self: *App, surface: *Surface) bool {
+    for (self.surfaces.items) |v| {
+        if (&v.core_surface == surface) return true;
     }
 
     return false;
@@ -237,18 +252,18 @@ pub const Message = union(enum) {
     /// Quit
     quit: void,
 
-    /// A message for a specific window
-    window_message: struct {
-        window: *Window,
-        message: Window.Message,
+    /// A message for a specific surface.
+    surface_message: struct {
+        surface: *Surface,
+        message: apprt.surface.Message,
     },
 
     const NewWindow = struct {
         /// Runtime-specific window options.
-        runtime: apprt.runtime.Window.Options = .{},
+        runtime: apprt.runtime.Surface.Options = .{},
 
-        /// The parent window, only used for new tabs.
-        parent: ?*Window = null,
+        /// The parent surface, only used for new tabs.
+        parent: ?*Surface = null,
 
         /// The font size to create the window with or null to default to
         /// the configuration amount.
@@ -332,7 +347,7 @@ pub const CAPI = struct {
     export fn ghostty_surface_new(
         app: *App,
         opts: *const apprt.runtime.Window.Options,
-    ) ?*Window {
+    ) ?*Surface {
         return surface_new_(app, opts) catch |err| {
             log.err("error initializing surface err={}", .{err});
             return null;
@@ -342,46 +357,46 @@ pub const CAPI = struct {
     fn surface_new_(
         app: *App,
         opts: *const apprt.runtime.Window.Options,
-    ) !*Window {
+    ) !*Surface {
         const w = try app.newWindow(.{
             .runtime = opts.*,
         });
         return w;
     }
 
-    export fn ghostty_surface_free(ptr: ?*Window) void {
+    export fn ghostty_surface_free(ptr: ?*Surface) void {
         if (ptr) |v| v.app.closeWindow(v);
     }
 
     /// Returns the app associated with a surface.
-    export fn ghostty_surface_app(win: *Window) *App {
+    export fn ghostty_surface_app(win: *Surface) *App {
         return win.app;
     }
 
     /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_refresh(win: *Window) void {
+    export fn ghostty_surface_refresh(win: *Surface) void {
         win.window.refresh();
     }
 
     /// Update the size of a surface. This will trigger resize notifications
     /// to the pty and the renderer.
-    export fn ghostty_surface_set_size(win: *Window, w: u32, h: u32) void {
+    export fn ghostty_surface_set_size(win: *Surface, w: u32, h: u32) void {
         win.window.updateSize(w, h);
     }
 
     /// Update the content scale of the surface.
-    export fn ghostty_surface_set_content_scale(win: *Window, x: f64, y: f64) void {
+    export fn ghostty_surface_set_content_scale(win: *Surface, x: f64, y: f64) void {
         win.window.updateContentScale(x, y);
     }
 
     /// Update the focused state of a surface.
-    export fn ghostty_surface_set_focus(win: *Window, focused: bool) void {
+    export fn ghostty_surface_set_focus(win: *Surface, focused: bool) void {
         win.window.focusCallback(focused);
     }
 
     /// Tell the surface that it needs to schedule a render
     export fn ghostty_surface_key(
-        win: *Window,
+        win: *Surface,
         action: input.Action,
         key: input.Key,
         mods: c_int,
@@ -394,13 +409,13 @@ pub const CAPI = struct {
     }
 
     /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_char(win: *Window, codepoint: u32) void {
+    export fn ghostty_surface_char(win: *Surface, codepoint: u32) void {
         win.window.charCallback(codepoint);
     }
 
     /// Tell the surface that it needs to schedule a render
     export fn ghostty_surface_mouse_button(
-        win: *Window,
+        win: *Surface,
         action: input.MouseButtonState,
         button: input.MouseButton,
         mods: c_int,
@@ -413,15 +428,15 @@ pub const CAPI = struct {
     }
 
     /// Update the mouse position within the view.
-    export fn ghostty_surface_mouse_pos(win: *Window, x: f64, y: f64) void {
+    export fn ghostty_surface_mouse_pos(win: *Surface, x: f64, y: f64) void {
         win.window.cursorPosCallback(x, y);
     }
 
-    export fn ghostty_surface_mouse_scroll(win: *Window, x: f64, y: f64) void {
+    export fn ghostty_surface_mouse_scroll(win: *Surface, x: f64, y: f64) void {
         win.window.scrollCallback(x, y);
     }
 
-    export fn ghostty_surface_ime_point(win: *Window, x: *f64, y: *f64) void {
+    export fn ghostty_surface_ime_point(win: *Surface, x: *f64, y: *f64) void {
         const pos = win.imePoint();
         x.* = pos.x;
         y.* = pos.y;

commit 9e4560043a58199ff6d4fd2702c85b7a3a0aa81e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 14:58:20 2023 -0800

    fix crashes on close

diff --git a/src/App.zig b/src/App.zig
index 6819d505..c28faebf 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -109,9 +109,7 @@ pub fn tick(self: *App, rt_app: *apprt.runtime.App) !bool {
     while (i < self.surfaces.items.len) {
         const surface = self.surfaces.items[i];
         if (surface.shouldClose()) {
-            surface.deinit();
-            _ = self.surfaces.swapRemove(i);
-            self.surface_pool.destroy(surface);
+            rt_app.closeSurface(surface);
             continue;
         }
 

commit 053748481aed950536692f4a2e2b5e86a3391489
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 15:16:17 2023 -0800

    more crap

diff --git a/src/App.zig b/src/App.zig
index c28faebf..94efe5fd 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -164,9 +164,9 @@ fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
         switch (message) {
             .new_window => |msg| {
                 _ = msg; // TODO
-                try rt_app.newWindow();
+                _ = try rt_app.newWindow();
             },
-            .new_tab => |msg| try self.newTab(msg),
+            .new_tab => |msg| try self.newTab(rt_app, msg),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
         }
@@ -174,19 +174,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
 }
 
 /// Create a new tab in the parent window
-fn newTab(self: *App, msg: Message.NewWindow) !void {
-    if (comptime !builtin.target.isDarwin()) {
-        log.warn("tabbing is not supported on this platform", .{});
-        return;
-    }
-
-    // In embedded mode, it is up to the embedder to implement tabbing
-    // on their own.
-    if (comptime build_config.artifact != .exe) {
-        log.warn("tabbing is not supported in embedded mode", .{});
-        return;
-    }
-
+fn newTab(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void {
     const parent = msg.parent orelse {
         log.warn("parent must be set in new_tab message", .{});
         return;
@@ -198,11 +186,7 @@ fn newTab(self: *App, msg: Message.NewWindow) !void {
         return;
     }
 
-    // Create the new window
-    const window = try self.newWindow(msg);
-
-    // Add the window to our parent tab group
-    parent.addWindow(window);
+    try rt_app.newTab(parent);
 }
 
 /// Start quitting

commit 8c18e1ee48b9e1ff2ad114051b8ebfd309dcaacc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 15:32:30 2023 -0800

    remove memory pool usage for mac

diff --git a/src/App.zig b/src/App.zig
index 94efe5fd..0dee7d3e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -23,7 +23,6 @@ const DevMode = @import("DevMode.zig");
 const log = std.log.scoped(.app);
 
 const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);
-const SurfacePool = std.heap.MemoryPool(apprt.Surface);
 
 /// The type used for sending messages to the app thread.
 pub const Mailbox = BlockingQueue(Message, 64);
@@ -34,12 +33,6 @@ alloc: Allocator,
 /// The list of surfaces that are currently active.
 surfaces: SurfaceList,
 
-/// The memory pool to request surfaces. We use a memory pool because surfaces
-/// typically require stable pointers due to runtime GUI callbacks. Centralizing
-/// all the allocations in this pool makes it so that all our pools remain
-/// close in memory.
-surface_pool: SurfacePool,
-
 // The configuration for the app.
 config: *const Config,
 
@@ -72,13 +65,11 @@ pub fn create(
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
-        .surface_pool = try SurfacePool.initPreheated(alloc, 2),
         .config = config,
         .mailbox = mailbox,
         .quit = false,
     };
     errdefer app.surfaces.deinit(alloc);
-    errdefer app.surface_pool.deinit();
 
     return app;
 }
@@ -87,7 +78,6 @@ pub fn destroy(self: *App) void {
     // Clean up all our surfaces
     for (self.surfaces.items) |surface| surface.deinit();
     self.surfaces.deinit(self.alloc);
-    self.surface_pool.deinit();
     self.mailbox.destroy(self.alloc);
 
     self.alloc.destroy(self);

commit ac772c2d2d1c54534d156abca21074ce016d7516
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 19:31:12 2023 -0800

    inherit font size works again

diff --git a/src/App.zig b/src/App.zig
index 0dee7d3e..bf89a684 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -152,10 +152,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
-            .new_window => |msg| {
-                _ = msg; // TODO
-                _ = try rt_app.newWindow();
-            },
+            .new_window => |msg| try self.newWindow(rt_app, msg),
             .new_tab => |msg| try self.newTab(rt_app, msg),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
@@ -163,8 +160,20 @@ fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
     }
 }
 
+/// Create a new window
+fn newWindow(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void {
+    const window = try rt_app.newWindow();
+    if (self.config.@"window-inherit-font-size") {
+        if (msg.parent) |parent| {
+            if (self.hasSurface(parent)) {
+                window.core_surface.setFontSize(parent.font_size);
+            }
+        }
+    }
+}
+
 /// Create a new tab in the parent window
-fn newTab(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void {
+fn newTab(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewTab) !void {
     const parent = msg.parent orelse {
         log.warn("parent must be set in new_tab message", .{});
         return;
@@ -176,7 +185,8 @@ fn newTab(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void
         return;
     }
 
-    try rt_app.newTab(parent);
+    const window = try rt_app.newTab(parent);
+    if (self.config.@"window-inherit-font-size") window.core_surface.setFontSize(parent.font_size);
 }
 
 /// Start quitting
@@ -219,7 +229,7 @@ pub const Message = union(enum) {
     /// Create a new tab within the tab group of the focused window.
     /// This does nothing if we're on a platform or using a window
     /// environment that doesn't support tabs.
-    new_tab: NewWindow,
+    new_tab: NewTab,
 
     /// Quit
     quit: void,
@@ -234,12 +244,13 @@ pub const Message = union(enum) {
         /// Runtime-specific window options.
         runtime: apprt.runtime.Surface.Options = .{},
 
-        /// The parent surface, only used for new tabs.
+        /// The parent surface
         parent: ?*Surface = null,
+    };
 
-        /// The font size to create the window with or null to default to
-        /// the configuration amount.
-        font_size: ?font.face.DesiredSize = null,
+    const NewTab = struct {
+        /// The parent surface
+        parent: ?*Surface = null,
     };
 };
 

commit 705d56d18e362f7402b220cb8a9c6a826719907a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 20:08:48 2023 -0800

    surface no longer has reference to app

diff --git a/src/App.zig b/src/App.zig
index bf89a684..1afb82e3 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -24,9 +24,6 @@ const log = std.log.scoped(.app);
 
 const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);
 
-/// The type used for sending messages to the app thread.
-pub const Mailbox = BlockingQueue(Message, 64);
-
 /// General purpose allocator
 alloc: Allocator,
 
@@ -38,14 +35,11 @@ config: *const Config,
 
 /// The mailbox that can be used to send this thread messages. Note
 /// this is a blocking queue so if it is full you will get errors (or block).
-mailbox: *Mailbox,
+mailbox: Mailbox.Queue,
 
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
-/// App will call this when tick should be called.
-wakeup_cb: ?*const fn () void = null,
-
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -53,10 +47,6 @@ pub fn create(
     alloc: Allocator,
     config: *const Config,
 ) !*App {
-    // The mailbox for messaging this thread
-    var mailbox = try Mailbox.create(alloc);
-    errdefer mailbox.destroy(alloc);
-
     // If we have DevMode on, store the config so we can show it
     if (DevMode.enabled) DevMode.instance.config = config;
 
@@ -66,7 +56,7 @@ pub fn create(
         .alloc = alloc,
         .surfaces = .{},
         .config = config,
-        .mailbox = mailbox,
+        .mailbox = .{},
         .quit = false,
     };
     errdefer app.surfaces.deinit(alloc);
@@ -78,16 +68,10 @@ pub fn destroy(self: *App) void {
     // Clean up all our surfaces
     for (self.surfaces.items) |surface| surface.deinit();
     self.surfaces.deinit(self.alloc);
-    self.mailbox.destroy(self.alloc);
 
     self.alloc.destroy(self);
 }
 
-/// Request the app runtime to process app events via tick.
-pub fn wakeup(self: App) void {
-    if (self.wakeup_cb) |cb| cb();
-}
-
 /// Tick ticks the app loop. This will drain our mailbox and process those
 /// events. This should be called by the application runtime on every loop
 /// tick.
@@ -127,26 +111,13 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
     while (i < self.surfaces.items.len) {
         if (self.surfaces.items[i] == rt_surface) {
             _ = self.surfaces.swapRemove(i);
+            continue;
         }
+
+        i += 1;
     }
 }
 
-/// Close a window and free all resources associated with it. This can
-/// only be called from the main thread.
-// pub fn closeWindow(self: *App, window: *Window) void {
-//     var i: usize = 0;
-//     while (i < self.surfaces.items.len) {
-//         const current = self.surfaces.items[i];
-//         if (window == current) {
-//             window.destroy();
-//             _ = self.surfaces.swapRemove(i);
-//             return;
-//         }
-//
-//         i += 1;
-//     }
-// }
-
 /// Drain the mailbox.
 fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
     while (self.mailbox.pop()) |message| {
@@ -154,12 +125,18 @@ fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
         switch (message) {
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .new_tab => |msg| try self.newTab(rt_app, msg),
+            .close => |surface| try self.closeSurface(rt_app, surface),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
         }
     }
 }
 
+fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
+    if (!self.hasSurface(surface)) return;
+    rt_app.closeSurface(surface.rt_surface);
+}
+
 /// Create a new window
 fn newWindow(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void {
     const window = try rt_app.newWindow();
@@ -231,6 +208,10 @@ pub const Message = union(enum) {
     /// environment that doesn't support tabs.
     new_tab: NewTab,
 
+    /// Close a surface. This notifies the runtime that a surface
+    /// should close.
+    close: *Surface,
+
     /// Quit
     quit: void,
 
@@ -254,6 +235,25 @@ pub const Message = union(enum) {
     };
 };
 
+/// Mailbox is the way that other threads send the app thread messages.
+pub const Mailbox = struct {
+    /// The type used for sending messages to the app thread.
+    pub const Queue = BlockingQueue(Message, 64);
+
+    rt_app: *apprt.App,
+    mailbox: *Queue,
+
+    /// Send a message to the surface.
+    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {
+        const result = self.mailbox.push(msg, timeout);
+
+        // Wake up our app loop
+        self.rt_app.wakeup();
+
+        return result;
+    }
+};
+
 // Wasm API.
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");
@@ -329,7 +329,7 @@ pub const CAPI = struct {
     /// Create a new surface as part of an app.
     export fn ghostty_surface_new(
         app: *App,
-        opts: *const apprt.runtime.Window.Options,
+        opts: *const apprt.Surface.Options,
     ) ?*Surface {
         return surface_new_(app, opts) catch |err| {
             log.err("error initializing surface err={}", .{err});
@@ -339,7 +339,7 @@ pub const CAPI = struct {
 
     fn surface_new_(
         app: *App,
-        opts: *const apprt.runtime.Window.Options,
+        opts: *const apprt.Surface.Options,
     ) !*Surface {
         const w = try app.newWindow(.{
             .runtime = opts.*,

commit 2adb0c9234e934acd1a27349440fdf37a5d1c84f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 21:10:20 2023 -0800

    apprt: C API for embedded updated to new style

diff --git a/src/App.zig b/src/App.zig
index 1afb82e3..7986ed8d 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -77,7 +77,7 @@ pub fn destroy(self: *App) void {
 /// tick.
 ///
 /// This returns whether the app should quit or not.
-pub fn tick(self: *App, rt_app: *apprt.runtime.App) !bool {
+pub fn tick(self: *App, rt_app: *apprt.App) !bool {
     // If any surfaces are closing, destroy them
     var i: usize = 0;
     while (i < self.surfaces.items.len) {
@@ -119,7 +119,7 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
 }
 
 /// Drain the mailbox.
-fn drainMailbox(self: *App, rt_app: *apprt.runtime.App) !void {
+fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
@@ -138,7 +138,12 @@ fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
 }
 
 /// Create a new window
-fn newWindow(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !void {
+fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
+    if (!@hasDecl(apprt.App, "newWindow")) {
+        log.warn("newWindow is not supported by this runtime", .{});
+        return;
+    }
+
     const window = try rt_app.newWindow();
     if (self.config.@"window-inherit-font-size") {
         if (msg.parent) |parent| {
@@ -150,7 +155,12 @@ fn newWindow(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewWindow) !vo
 }
 
 /// Create a new tab in the parent window
-fn newTab(self: *App, rt_app: *apprt.runtime.App, msg: Message.NewTab) !void {
+fn newTab(self: *App, rt_app: *apprt.App, msg: Message.NewTab) !void {
+    if (!@hasDecl(apprt.App, "newTab")) {
+        log.warn("newTab is not supported by this runtime", .{});
+        return;
+    }
+
     const parent = msg.parent orelse {
         log.warn("parent must be set in new_tab message", .{});
         return;
@@ -281,147 +291,3 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     //     }
     // }
 };
-
-// C API
-pub const CAPI = struct {
-    const global = &@import("main.zig").state;
-
-    /// Create a new app.
-    export fn ghostty_app_new(
-        opts: *const apprt.runtime.App.Options,
-        config: *const Config,
-    ) ?*App {
-        return app_new_(opts, config) catch |err| {
-            log.err("error initializing app err={}", .{err});
-            return null;
-        };
-    }
-
-    fn app_new_(
-        opts: *const apprt.runtime.App.Options,
-        config: *const Config,
-    ) !*App {
-        const app = try App.create(global.alloc, opts.*, config);
-        errdefer app.destroy();
-        return app;
-    }
-
-    /// Tick the event loop. This should be called whenever the "wakeup"
-    /// callback is invoked for the runtime.
-    export fn ghostty_app_tick(v: *App) void {
-        v.tick() catch |err| {
-            log.err("error app tick err={}", .{err});
-        };
-    }
-
-    /// Return the userdata associated with the app.
-    export fn ghostty_app_userdata(v: *App) ?*anyopaque {
-        return v.runtime.opts.userdata;
-    }
-
-    export fn ghostty_app_free(ptr: ?*App) void {
-        if (ptr) |v| {
-            v.destroy();
-            v.alloc.destroy(v);
-        }
-    }
-
-    /// Create a new surface as part of an app.
-    export fn ghostty_surface_new(
-        app: *App,
-        opts: *const apprt.Surface.Options,
-    ) ?*Surface {
-        return surface_new_(app, opts) catch |err| {
-            log.err("error initializing surface err={}", .{err});
-            return null;
-        };
-    }
-
-    fn surface_new_(
-        app: *App,
-        opts: *const apprt.Surface.Options,
-    ) !*Surface {
-        const w = try app.newWindow(.{
-            .runtime = opts.*,
-        });
-        return w;
-    }
-
-    export fn ghostty_surface_free(ptr: ?*Surface) void {
-        if (ptr) |v| v.app.closeWindow(v);
-    }
-
-    /// Returns the app associated with a surface.
-    export fn ghostty_surface_app(win: *Surface) *App {
-        return win.app;
-    }
-
-    /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_refresh(win: *Surface) void {
-        win.window.refresh();
-    }
-
-    /// Update the size of a surface. This will trigger resize notifications
-    /// to the pty and the renderer.
-    export fn ghostty_surface_set_size(win: *Surface, w: u32, h: u32) void {
-        win.window.updateSize(w, h);
-    }
-
-    /// Update the content scale of the surface.
-    export fn ghostty_surface_set_content_scale(win: *Surface, x: f64, y: f64) void {
-        win.window.updateContentScale(x, y);
-    }
-
-    /// Update the focused state of a surface.
-    export fn ghostty_surface_set_focus(win: *Surface, focused: bool) void {
-        win.window.focusCallback(focused);
-    }
-
-    /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_key(
-        win: *Surface,
-        action: input.Action,
-        key: input.Key,
-        mods: c_int,
-    ) void {
-        win.window.keyCallback(
-            action,
-            key,
-            @bitCast(input.Mods, @truncate(u8, @bitCast(c_uint, mods))),
-        );
-    }
-
-    /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_char(win: *Surface, codepoint: u32) void {
-        win.window.charCallback(codepoint);
-    }
-
-    /// Tell the surface that it needs to schedule a render
-    export fn ghostty_surface_mouse_button(
-        win: *Surface,
-        action: input.MouseButtonState,
-        button: input.MouseButton,
-        mods: c_int,
-    ) void {
-        win.window.mouseButtonCallback(
-            action,
-            button,
-            @bitCast(input.Mods, @truncate(u8, @bitCast(c_uint, mods))),
-        );
-    }
-
-    /// Update the mouse position within the view.
-    export fn ghostty_surface_mouse_pos(win: *Surface, x: f64, y: f64) void {
-        win.window.cursorPosCallback(x, y);
-    }
-
-    export fn ghostty_surface_mouse_scroll(win: *Surface, x: f64, y: f64) void {
-        win.window.scrollCallback(x, y);
-    }
-
-    export fn ghostty_surface_ime_point(win: *Surface, x: *f64, y: *f64) void {
-        const pos = win.imePoint();
-        x.* = pos.x;
-        y.* = pos.y;
-    }
-};

commit fb13838532fed17ad0695728c776e4f2aefec32a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 08:44:01 2023 -0800

    apprt newWindow/newTab do not have to return a surface

diff --git a/src/App.zig b/src/App.zig
index 7986ed8d..7776dc49 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -144,14 +144,14 @@ fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
         return;
     }
 
-    const window = try rt_app.newWindow();
-    if (self.config.@"window-inherit-font-size") {
-        if (msg.parent) |parent| {
-            if (self.hasSurface(parent)) {
-                window.core_surface.setFontSize(parent.font_size);
-            }
-        }
-    }
+    const parent = if (msg.parent) |parent| parent: {
+        break :parent if (self.hasSurface(parent))
+            parent
+        else
+            null;
+    } else null;
+
+    try rt_app.newWindow(parent);
 }
 
 /// Create a new tab in the parent window
@@ -172,8 +172,7 @@ fn newTab(self: *App, rt_app: *apprt.App, msg: Message.NewTab) !void {
         return;
     }
 
-    const window = try rt_app.newTab(parent);
-    if (self.config.@"window-inherit-font-size") window.core_surface.setFontSize(parent.font_size);
+    try rt_app.newTab(parent);
 }
 
 /// Start quitting

commit 7f34afa3953289d33f95150c5f7d6a6d458a6993
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 09:43:52 2023 -0800

    gtk: hook up GL area and render a color

diff --git a/src/App.zig b/src/App.zig
index 7776dc49..1154cf86 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -231,9 +231,6 @@ pub const Message = union(enum) {
     },
 
     const NewWindow = struct {
-        /// Runtime-specific window options.
-        runtime: apprt.runtime.Surface.Options = .{},
-
         /// The parent surface
         parent: ?*Surface = null,
     };

commit 6acf67ec662c124a11debdf0669b822f84b1508b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 11:19:51 2023 -0800

    gtk: render!

diff --git a/src/App.zig b/src/App.zig
index 1154cf86..683a70f4 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -128,6 +128,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             .close => |surface| try self.closeSurface(rt_app, surface),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
+            .redraw_surface => |surface| try self.redrawSurface(rt_app, surface),
         }
     }
 }
@@ -137,6 +138,11 @@ fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
     rt_app.closeSurface(surface.rt_surface);
 }
 
+fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {
+    if (!self.hasSurface(&surface.core_surface)) return;
+    rt_app.redrawSurface(surface);
+}
+
 /// Create a new window
 fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
     if (!@hasDecl(apprt.App, "newWindow")) {
@@ -230,6 +236,12 @@ pub const Message = union(enum) {
         message: apprt.surface.Message,
     },
 
+    /// Redraw a surface. This only has an effect for runtimes that
+    /// use single-threaded draws. To redraw a surface for all runtimes,
+    /// wake up the renderer thread. The renderer thread will send this
+    /// message if it needs to.
+    redraw_surface: *apprt.Surface,
+
     const NewWindow = struct {
         /// The parent surface
         parent: ?*Surface = null,

commit 7a0411d65a29660da6ebd7697bd2342b5b637b35
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 25 10:38:19 2023 -0800

    apprt: move newTab to a surface callback rather than app

diff --git a/src/App.zig b/src/App.zig
index 683a70f4..77ee6c7d 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -124,7 +124,6 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
             .new_window => |msg| try self.newWindow(rt_app, msg),
-            .new_tab => |msg| try self.newTab(rt_app, msg),
             .close => |surface| try self.closeSurface(rt_app, surface),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
@@ -160,27 +159,6 @@ fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
     try rt_app.newWindow(parent);
 }
 
-/// Create a new tab in the parent window
-fn newTab(self: *App, rt_app: *apprt.App, msg: Message.NewTab) !void {
-    if (!@hasDecl(apprt.App, "newTab")) {
-        log.warn("newTab is not supported by this runtime", .{});
-        return;
-    }
-
-    const parent = msg.parent orelse {
-        log.warn("parent must be set in new_tab message", .{});
-        return;
-    };
-
-    // If the parent was closed prior to us handling the message, we do nothing.
-    if (!self.hasSurface(parent)) {
-        log.warn("new_tab parent is gone, not launching a new tab", .{});
-        return;
-    }
-
-    try rt_app.newTab(parent);
-}
-
 /// Start quitting
 fn setQuit(self: *App) !void {
     if (self.quit) return;
@@ -218,11 +196,6 @@ pub const Message = union(enum) {
     /// Create a new terminal window.
     new_window: NewWindow,
 
-    /// Create a new tab within the tab group of the focused window.
-    /// This does nothing if we're on a platform or using a window
-    /// environment that doesn't support tabs.
-    new_tab: NewTab,
-
     /// Close a surface. This notifies the runtime that a surface
     /// should close.
     close: *Surface,
@@ -246,11 +219,6 @@ pub const Message = union(enum) {
         /// The parent surface
         parent: ?*Surface = null,
     };
-
-    const NewTab = struct {
-        /// The parent surface
-        parent: ?*Surface = null,
-    };
 };
 
 /// Mailbox is the way that other threads send the app thread messages.

commit 9b10b5d71638e6c7eadc60da24639c8ff96f7ba7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 21:13:20 2023 -0700

    surface doesn't store a pointer to Config anymore

diff --git a/src/App.zig b/src/App.zig
index 77ee6c7d..f06fe144 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -30,7 +30,9 @@ alloc: Allocator,
 /// The list of surfaces that are currently active.
 surfaces: SurfaceList,
 
-// The configuration for the app.
+// The configuration for the app. This may change (app runtimes are notified
+// via the callback), but the change will only ever happen during tick()
+// so app runtimes can ensure there are no data races in reading this.
 config: *const Config,
 
 /// The mailbox that can be used to send this thread messages. Note

commit 3e1f975551c2258b82dbc4bb747fef3a5d5d1910
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 21:44:45 2023 -0700

    move config loading into apprt to prep for reloading

diff --git a/src/App.zig b/src/App.zig
index f06fe144..e9358b3a 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -30,11 +30,6 @@ alloc: Allocator,
 /// The list of surfaces that are currently active.
 surfaces: SurfaceList,
 
-// The configuration for the app. This may change (app runtimes are notified
-// via the callback), but the change will only ever happen during tick()
-// so app runtimes can ensure there are no data races in reading this.
-config: *const Config,
-
 /// The mailbox that can be used to send this thread messages. Note
 /// this is a blocking queue so if it is full you will get errors (or block).
 mailbox: Mailbox.Queue,
@@ -47,17 +42,15 @@ quit: bool,
 /// "startup" logic.
 pub fn create(
     alloc: Allocator,
-    config: *const Config,
 ) !*App {
     // If we have DevMode on, store the config so we can show it
-    if (DevMode.enabled) DevMode.instance.config = config;
+    //if (DevMode.enabled) DevMode.instance.config = config;
 
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
-        .config = config,
         .mailbox = .{},
         .quit = false,
     };
@@ -99,6 +92,21 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
     return self.quit or self.surfaces.items.len == 0;
 }
 
+/// Update the configuration associated with the app. This can only be
+/// called from the main thread.
+///
+/// The caller owns the config memory. The prior config must not be freed
+/// until this function returns successfully.
+pub fn updateConfig(self: *App, config: *const Config) !void {
+    // Update our config
+    self.config = config;
+
+    // Go through and update all of the surface configurations.
+    for (self.surfaces.items) |surface| {
+        try surface.handleMessage(.{ .change_config = config });
+    }
+}
+
 /// Add an initialized surface. This is really only for the runtime
 /// implementations to call and should NOT be called by general app users.
 /// The surface must be from the pool.
@@ -125,6 +133,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
+            .reload_config => try self.reloadConfig(rt_app),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| try self.closeSurface(rt_app, surface),
             .quit => try self.setQuit(),
@@ -134,6 +143,12 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
+fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
+    _ = rt_app;
+    _ = self;
+    //try rt_app.reloadConfig();
+}
+
 fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
     if (!self.hasSurface(surface)) return;
     rt_app.closeSurface(surface.rt_surface);
@@ -195,6 +210,10 @@ fn hasSurface(self: *App, surface: *Surface) bool {
 
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
+    /// Reload the configuration for the entire app and propagate it to
+    /// all the active surfaces.
+    reload_config: void,
+
     /// Create a new terminal window.
     new_window: NewWindow,
 

commit a9928cfb90a70bb5a24aca2b9193a1c4c38d8d76
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 21:52:42 2023 -0700

    implement reload_config app message

diff --git a/src/App.zig b/src/App.zig
index e9358b3a..7563058b 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -18,7 +18,6 @@ const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
 const macos = @import("macos");
 const objc = @import("objc");
-const DevMode = @import("DevMode.zig");
 
 const log = std.log.scoped(.app);
 
@@ -43,9 +42,6 @@ quit: bool,
 pub fn create(
     alloc: Allocator,
 ) !*App {
-    // If we have DevMode on, store the config so we can show it
-    //if (DevMode.enabled) DevMode.instance.config = config;
-
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
     app.* = .{
@@ -93,17 +89,12 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
 }
 
 /// Update the configuration associated with the app. This can only be
-/// called from the main thread.
-///
-/// The caller owns the config memory. The prior config must not be freed
-/// until this function returns successfully.
+/// called from the main thread. The caller owns the config memory. The
+/// memory can be freed immediately when this returns.
 pub fn updateConfig(self: *App, config: *const Config) !void {
-    // Update our config
-    self.config = config;
-
     // Go through and update all of the surface configurations.
     for (self.surfaces.items) |surface| {
-        try surface.handleMessage(.{ .change_config = config });
+        try surface.core_surface.handleMessage(.{ .change_config = config });
     }
 }
 
@@ -144,9 +135,9 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
 }
 
 fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
-    _ = rt_app;
-    _ = self;
-    //try rt_app.reloadConfig();
+    if (try rt_app.reloadConfig()) |new| {
+        try self.updateConfig(new);
+    }
 }
 
 fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {

commit f5c1dfa37471e8ea2ceff494e9b09953a6b485e4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 22:00:10 2023 -0700

    reload_config keybinding (defaults to ctrl+alt+super+space)

diff --git a/src/App.zig b/src/App.zig
index 7563058b..f2d18a7f 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -135,7 +135,9 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
 }
 
 fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
+    log.debug("reloading configuration", .{});
     if (try rt_app.reloadConfig()) |new| {
+        log.debug("new configuration received, applying", .{});
         try self.updateConfig(new);
     }
 }

commit 3689f1fe390ad14651d3cc96042339b7c47cd3cb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 25 16:36:12 2023 -0700

    apprt/gtk: only show exit confirmation if process is alive

diff --git a/src/App.zig b/src/App.zig
index f2d18a7f..b5635c0d 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -74,7 +74,7 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
     while (i < self.surfaces.items.len) {
         const surface = self.surfaces.items[i];
         if (surface.shouldClose()) {
-            rt_app.closeSurface(surface);
+            surface.close(false);
             continue;
         }
 
@@ -143,8 +143,10 @@ fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
 }
 
 fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
+    _ = rt_app;
+
     if (!self.hasSurface(surface)) return;
-    rt_app.closeSurface(surface.rt_surface);
+    surface.close();
 }
 
 fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {

commit f36a35ecc9e632e30a5f08e9c8dfd58ef2e3d88c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 27 10:10:06 2023 -0700

    core: quit flag is reset after tick

diff --git a/src/App.zig b/src/App.zig
index b5635c0d..b3993839 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -81,8 +81,12 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
         i += 1;
     }
 
-    // Drain our mailbox only if we're not quitting.
-    if (!self.quit) try self.drainMailbox(rt_app);
+    // Drain our mailbox
+    try self.drainMailbox(rt_app);
+
+    // No matter what, we reset the quit flag after a tick. If the apprt
+    // doesn't want to quit, then we can't force it to.
+    defer self.quit = false;
 
     // We quit if our quit flag is on or if we have closed all surfaces.
     return self.quit or self.surfaces.items.len == 0;
@@ -175,11 +179,6 @@ fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
 fn setQuit(self: *App) !void {
     if (self.quit) return;
     self.quit = true;
-
-    // Mark that all our surfaces should close
-    for (self.surfaces.items) |surface| {
-        surface.setShouldClose();
-    }
 }
 
 /// Handle a window message

commit a158813a3dc5b1dc30b0bade4b0ff7e62eda9149
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 18:59:40 2023 -0700

    app keeps track of last focused surface

diff --git a/src/App.zig b/src/App.zig
index b3993839..52c926d2 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -29,6 +29,10 @@ alloc: Allocator,
 /// The list of surfaces that are currently active.
 surfaces: SurfaceList,
 
+/// The last focused surface. This surface may not be valid;
+/// you must always call hasSurface to validate it.
+focused_surface: ?*Surface = null,
+
 /// The mailbox that can be used to send this thread messages. Note
 /// this is a blocking queue so if it is full you will get errors (or block).
 mailbox: Mailbox.Queue,
@@ -131,6 +135,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             .reload_config => try self.reloadConfig(rt_app),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| try self.closeSurface(rt_app, surface),
+            .focus => |surface| try self.focusSurface(rt_app, surface),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
             .redraw_surface => |surface| try self.redrawSurface(rt_app, surface),
@@ -153,6 +158,13 @@ fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
     surface.close();
 }
 
+fn focusSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
+    _ = rt_app;
+
+    if (!self.hasSurface(surface)) return;
+    self.focused_surface = surface;
+}
+
 fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {
     if (!self.hasSurface(&surface.core_surface)) return;
     rt_app.redrawSurface(surface);
@@ -215,6 +227,11 @@ pub const Message = union(enum) {
     /// should close.
     close: *Surface,
 
+    /// The last focused surface. The app keeps track of this to
+    /// enable "inheriting" various configurations from the last
+    /// surface.
+    focus: *Surface,
+
     /// Quit
     quit: void,
 

commit 553e09eff988d83854e5a81af74f8b8d4f5b8eb4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 19:12:01 2023 -0700

    apprt/embedded: new surfaces inherit last focused

diff --git a/src/App.zig b/src/App.zig
index 52c926d2..5b638fdf 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -127,6 +127,14 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
     }
 }
 
+/// The last focused surface. This is only valid while on the main thread
+/// before tick is called.
+pub fn focusedSurface(self: *App) ?*Surface {
+    const surface = self.focused_surface orelse return null;
+    if (!self.hasSurface(surface)) return null;
+    return surface;
+}
+
 /// Drain the mailbox.
 fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {

commit f31d6fb8fe64ba52d5adde20a17c6709abe7d0c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 21:08:50 2023 -0700

    apprt: clean up how apprt initializes surfaces

diff --git a/src/App.zig b/src/App.zig
index 5b638fdf..b2893fdd 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -129,7 +129,7 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
 
 /// The last focused surface. This is only valid while on the main thread
 /// before tick is called.
-pub fn focusedSurface(self: *App) ?*Surface {
+pub fn focusedSurface(self: *const App) ?*Surface {
     const surface = self.focused_surface orelse return null;
     if (!self.hasSurface(surface)) return null;
     return surface;
@@ -214,7 +214,7 @@ fn surfaceMessage(self: *App, surface: *Surface, msg: apprt.surface.Message) !vo
     // Not a problem.
 }
 
-fn hasSurface(self: *App, surface: *Surface) bool {
+fn hasSurface(self: *const App, surface: *const Surface) bool {
     for (self.surfaces.items) |v| {
         if (&v.core_surface == surface) return true;
     }

commit bd7cc4b71ddb818b5724367533d25080b078099d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 8 09:21:52 2023 -0700

    core: App looks up resources dir on startup

diff --git a/src/App.zig b/src/App.zig
index b2893fdd..42c4183f 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -16,6 +16,7 @@ const Config = @import("config.zig").Config;
 const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
+const internal_os = @import("os/main.zig");
 const macos = @import("macos");
 const objc = @import("objc");
 
@@ -40,6 +41,10 @@ mailbox: Mailbox.Queue,
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
+/// The app resources directory, equivalent to zig-out/share when we build
+/// from source. This is null if we can't detect it.
+resources_dir: ?[]const u8 = null,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -48,11 +53,21 @@ pub fn create(
 ) !*App {
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
+
+    // Find our resources directory once for the app so every launch
+    // hereafter can use this cached value.
+    var resources_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const resources_dir = if (try internal_os.resourcesDir(&resources_buf)) |dir|
+        try alloc.dupe(u8, dir)
+    else
+        null;
+
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
         .mailbox = .{},
         .quit = false,
+        .resources_dir = resources_dir,
     };
     errdefer app.surfaces.deinit(alloc);
 
@@ -64,6 +79,7 @@ pub fn destroy(self: *App) void {
     for (self.surfaces.items) |surface| surface.deinit();
     self.surfaces.deinit(self.alloc);
 
+    if (self.resources_dir) |dir| self.alloc.free(dir);
     self.alloc.destroy(self);
 }
 

commit 619d2ade3ee194551889fe6cb1ea2d28aada8cba
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 08:01:33 2023 -0700

    only initialize font discovery mechanism once, cache on App
    
    Fontconfig in particular appears unsafe to initialize multiple times.
    
    Font discovery is a singleton object in an application and only ever
    accessed from the main thread so we can work around this by only
    initializing and caching the font discovery mechanism exactly once on
    the app singleton.

diff --git a/src/App.zig b/src/App.zig
index 42c4183f..32f89069 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -45,6 +45,11 @@ quit: bool,
 /// from source. This is null if we can't detect it.
 resources_dir: ?[]const u8 = null,
 
+/// Font discovery mechanism. This is only safe to use from the main thread.
+/// This is lazily initialized on the first call to fontDiscover so do
+/// not access this directly.
+font_discover: ?font.Discover = null,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -80,6 +85,8 @@ pub fn destroy(self: *App) void {
     self.surfaces.deinit(self.alloc);
 
     if (self.resources_dir) |dir| self.alloc.free(dir);
+    if (self.font_discover) |*v| v.deinit();
+
     self.alloc.destroy(self);
 }
 
@@ -151,6 +158,20 @@ pub fn focusedSurface(self: *const App) ?*Surface {
     return surface;
 }
 
+/// Initialize once and return the font discovery mechanism. This remains
+/// initialized throughout the lifetime of the application because some
+/// font discovery mechanisms (i.e. fontconfig) are unsafe to reinit.
+pub fn fontDiscover(self: *App) !?font.Discover {
+    // If we're built without a font discovery mechanism, return null
+    if (comptime font.Discover == void) return null;
+
+    // If we initialized, use it
+    if (self.font_discover) |v| return v;
+
+    self.font_discover = font.Discover.init();
+    return self.font_discover.?;
+}
+
 /// Drain the mailbox.
 fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {

commit 0af6edc25b04be4afacf12ab549d55b77644ef39
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 11:51:24 2023 -0700

    only the app should own the font discovery instance

diff --git a/src/App.zig b/src/App.zig
index 32f89069..c7721eb5 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -161,15 +161,15 @@ pub fn focusedSurface(self: *const App) ?*Surface {
 /// Initialize once and return the font discovery mechanism. This remains
 /// initialized throughout the lifetime of the application because some
 /// font discovery mechanisms (i.e. fontconfig) are unsafe to reinit.
-pub fn fontDiscover(self: *App) !?font.Discover {
+pub fn fontDiscover(self: *App) !?*font.Discover {
     // If we're built without a font discovery mechanism, return null
     if (comptime font.Discover == void) return null;
 
     // If we initialized, use it
-    if (self.font_discover) |v| return v;
+    if (self.font_discover) |*v| return v;
 
     self.font_discover = font.Discover.init();
-    return self.font_discover.?;
+    return &self.font_discover.?;
 }
 
 /// Drain the mailbox.

commit 6a8d302fa0ebf7739f7c75fd027730abfbba671a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 20:57:28 2023 -0700

    core: set focused surface pointer to null if matches on delete
    
    We previously never set the focused pointer to null. I thought this
    would be fine because a `hasSurface` check would say it doesn't exist.
    But I didn't account for the fact that a deleted surface followed very
    quickly by a new surface would free the pointer, then the allocation
    would reuse the very same pointer, making `hasSurface` return a false
    positive.
    
    Well, technically, hasSurface is not wrong, the surface exists, but its
    not really the same surface, its just a surface that happens to have the
    same pointer as a previously freed surface.
    
    Co-authored-by: Will Pragnell <wpragnell@gmail.com>

diff --git a/src/App.zig b/src/App.zig
index c7721eb5..942581e3 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -139,6 +139,16 @@ pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
 /// Delete the surface from the known surface list. This will NOT call the
 /// destructor or free the memory.
 pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
+    // If this surface is the focused surface then we need to clear it.
+    // There was a bug where we relied on hasSurface to return false and
+    // just let focused surface be but the allocator was reusing addresses
+    // after free and giving false positives, so we must clear it.
+    if (self.focused_surface) |focused| {
+        if (focused == &rt_surface.core_surface) {
+            self.focused_surface = null;
+        }
+    }
+
     var i: usize = 0;
     while (i < self.surfaces.items.len) {
         if (self.surfaces.items[i] == rt_surface) {

commit 56ccadd7f1de5df4041d475a1af9c051e034ffbc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Sep 11 15:44:08 2023 -0700

    core: app needsConfirmQuit to streamline quitting if no active sessions

diff --git a/src/App.zig b/src/App.zig
index 942581e3..4b88c30e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -168,6 +168,16 @@ pub fn focusedSurface(self: *const App) ?*Surface {
     return surface;
 }
 
+/// Returns true if confirmation is needed to quit the app. It is up to
+/// the apprt to call this.
+pub fn needsConfirmQuit(self: *const App) bool {
+    for (self.surfaces.items) |v| {
+        if (v.core_surface.needsConfirmQuit()) return true;
+    }
+
+    return false;
+}
+
 /// Initialize once and return the font discovery mechanism. This remains
 /// initialized throughout the lifetime of the application because some
 /// font discovery mechanisms (i.e. fontconfig) are unsafe to reinit.

commit 678bd0de0c4938e2150e1627fb75038b915f9db5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 13 08:34:09 2023 -0700

    core: surface should not use app mailbox
    
    The surface runs on the same thread as the app so if we use the app
    mailbox then we risk filling the queue before it can drain. The surface
    should use the app directly.
    
    This commit just changes all the calls to use the app directly. We may
    also want to coalesce certain changes to avoid too much CPU but I defer
    that to a future change.

diff --git a/src/App.zig b/src/App.zig
index 4b88c30e..bdf5cb77 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -199,8 +199,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
         switch (message) {
             .reload_config => try self.reloadConfig(rt_app),
             .new_window => |msg| try self.newWindow(rt_app, msg),
-            .close => |surface| try self.closeSurface(rt_app, surface),
-            .focus => |surface| try self.focusSurface(rt_app, surface),
+            .close => |surface| try self.closeSurface(surface),
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
             .redraw_surface => |surface| try self.redrawSurface(rt_app, surface),
@@ -208,7 +207,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
-fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
+pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     log.debug("reloading configuration", .{});
     if (try rt_app.reloadConfig()) |new| {
         log.debug("new configuration received, applying", .{});
@@ -216,16 +215,12 @@ fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
-fn closeSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
-    _ = rt_app;
-
+pub fn closeSurface(self: *App, surface: *Surface) !void {
     if (!self.hasSurface(surface)) return;
     surface.close();
 }
 
-fn focusSurface(self: *App, rt_app: *apprt.App, surface: *Surface) !void {
-    _ = rt_app;
-
+pub fn focusSurface(self: *App, surface: *Surface) void {
     if (!self.hasSurface(surface)) return;
     self.focused_surface = surface;
 }
@@ -236,7 +231,7 @@ fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void
 }
 
 /// Create a new window
-fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
+pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
     if (!@hasDecl(apprt.App, "newWindow")) {
         log.warn("newWindow is not supported by this runtime", .{});
         return;
@@ -253,7 +248,7 @@ fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
 }
 
 /// Start quitting
-fn setQuit(self: *App) !void {
+pub fn setQuit(self: *App) !void {
     if (self.quit) return;
     self.quit = true;
 }
@@ -292,11 +287,6 @@ pub const Message = union(enum) {
     /// should close.
     close: *Surface,
 
-    /// The last focused surface. The app keeps track of this to
-    /// enable "inheriting" various configurations from the last
-    /// surface.
-    focus: *Surface,
-
     /// Quit
     quit: void,
 

commit 088ae5c45488c717fe3b708dac4084eef8a3afb7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 19 19:43:04 2023 -0700

    fix build with no font discovery

diff --git a/src/App.zig b/src/App.zig
index bdf5cb77..12a4389c 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -85,7 +85,9 @@ pub fn destroy(self: *App) void {
     self.surfaces.deinit(self.alloc);
 
     if (self.resources_dir) |dir| self.alloc.free(dir);
-    if (self.font_discover) |*v| v.deinit();
+    if (comptime font.Discover != void) {
+        if (self.font_discover) |*v| v.deinit();
+    }
 
     self.alloc.destroy(self);
 }

commit 5a299e14e48cd3987453c56a0c661dbc783c48b7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 22 08:46:30 2023 -0700

    all threads are notified of inspector state, trigger render

diff --git a/src/App.zig b/src/App.zig
index 12a4389c..b9b9501e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -205,6 +205,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             .quit => try self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
             .redraw_surface => |surface| try self.redrawSurface(rt_app, surface),
+            .redraw_inspector => |surface| try self.redrawInspector(rt_app, surface),
         }
     }
 }
@@ -232,6 +233,11 @@ fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void
     rt_app.redrawSurface(surface);
 }
 
+fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {
+    if (!self.hasSurface(&surface.core_surface)) return;
+    rt_app.redrawInspector(surface);
+}
+
 /// Create a new window
 pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
     if (!@hasDecl(apprt.App, "newWindow")) {
@@ -304,6 +310,10 @@ pub const Message = union(enum) {
     /// message if it needs to.
     redraw_surface: *apprt.Surface,
 
+    /// Redraw the inspector. This is called whenever some non-OS event
+    /// causes the inspector to need to be redrawn.
+    redraw_inspector: *apprt.Surface,
+
     const NewWindow = struct {
         /// The parent surface
         parent: ?*Surface = null,

commit 232df8de8ff23ca6f3bd65516224df0f80ddf6ad
Author: kcbanner <kcbanner@gmail.com>
Date:   Sun Oct 29 04:03:06 2023 -0400

    windows: add support for the glfw backend on Windows
    
    Changes:
    - Add WindowsPty, which uses the ConPTY API to create a pseudo console
    - Pty now selects between PosixPty and WindowsPty
    - Windows support in Command, including the ability to launch a process with a pseudo console
    - Enable Command tests on windows
    - Add some environment variable abstractions to handle the missing libc APIs on Windows
    - Windows version of ReadThread

diff --git a/src/App.zig b/src/App.zig
index b9b9501e..a09860a8 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -61,11 +61,8 @@ pub fn create(
 
     // Find our resources directory once for the app so every launch
     // hereafter can use this cached value.
-    var resources_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-    const resources_dir = if (try internal_os.resourcesDir(&resources_buf)) |dir|
-        try alloc.dupe(u8, dir)
-    else
-        null;
+    const resources_dir = try internal_os.resourcesDir(alloc);
+    errdefer if (resources_dir) |dir| alloc.free(dir);
 
     app.* = .{
         .alloc = alloc,

commit 45a4be68736aebb23d9bac5c7f7ab72dcadf5bc0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 22 21:12:01 2023 -0800

    core: move resources dir to main global state

diff --git a/src/App.zig b/src/App.zig
index a09860a8..78561772 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -41,10 +41,6 @@ mailbox: Mailbox.Queue,
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
-/// The app resources directory, equivalent to zig-out/share when we build
-/// from source. This is null if we can't detect it.
-resources_dir: ?[]const u8 = null,
-
 /// Font discovery mechanism. This is only safe to use from the main thread.
 /// This is lazily initialized on the first call to fontDiscover so do
 /// not access this directly.
@@ -59,17 +55,11 @@ pub fn create(
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
 
-    // Find our resources directory once for the app so every launch
-    // hereafter can use this cached value.
-    const resources_dir = try internal_os.resourcesDir(alloc);
-    errdefer if (resources_dir) |dir| alloc.free(dir);
-
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
         .mailbox = .{},
         .quit = false,
-        .resources_dir = resources_dir,
     };
     errdefer app.surfaces.deinit(alloc);
 
@@ -81,7 +71,6 @@ pub fn destroy(self: *App) void {
     for (self.surfaces.items) |surface| surface.deinit();
     self.surfaces.deinit(self.alloc);
 
-    if (self.resources_dir) |dir| self.alloc.free(dir);
     if (comptime font.Discover != void) {
         if (self.font_discover) |*v| v.deinit();
     }

commit b021d76edf8d8574c1b60cf75e04944c1394dcb4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 13 16:35:14 2023 -0800

    core: quit-after-last-window-closed works properly with "exit"
    
    Fixes #1085
    
    This moves the logic of exiting when there are no surfaces left fully to
    apprt and away from the core.

diff --git a/src/App.zig b/src/App.zig
index 78561772..c1917f79 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -103,8 +103,8 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
     // doesn't want to quit, then we can't force it to.
     defer self.quit = false;
 
-    // We quit if our quit flag is on or if we have closed all surfaces.
-    return self.quit or self.surfaces.items.len == 0;
+    // We quit if our quit flag is on
+    return self.quit;
 }
 
 /// Update the configuration associated with the app. This can only be

commit 646e3c365c8e481b9c003fa5e5dab71a3ec8eb0f
Author: Borja Clemente <borja.clemente@gmail.com>
Date:   Sun Dec 17 14:22:38 2023 +0100

    Add settings shortcut on MacOS
    
    - Settings shortcut opens the config file in the default editor.
    
    Signed-off-by: Borja Clemente <borja.clemente@gmail.com>

diff --git a/src/App.zig b/src/App.zig
index c1917f79..99949d9e 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -186,6 +186,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
             .reload_config => try self.reloadConfig(rt_app),
+            .open_config => try self.openConfig(rt_app),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| try self.closeSurface(surface),
             .quit => try self.setQuit(),
@@ -196,6 +197,12 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
+pub fn openConfig(self: *App, rt_app: *apprt.App) !void {
+    _ = self;
+    log.debug("opening configuration", .{});
+    try rt_app.openConfig();
+}
+
 pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     log.debug("reloading configuration", .{});
     if (try rt_app.reloadConfig()) |new| {
@@ -274,6 +281,9 @@ pub const Message = union(enum) {
     /// all the active surfaces.
     reload_config: void,
 
+    // Open the configuration file
+    open_config: void,
+
     /// Create a new terminal window.
     new_window: NewWindow,
 

commit 6d7053a1ad32745a94d3589bfc5f49e8c157e35c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 1 15:37:09 2024 -0700

    core: convert surface/app to use GroupCacheSet

diff --git a/src/App.zig b/src/App.zig
index 99949d9e..53ca77c6 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -41,10 +41,9 @@ mailbox: Mailbox.Queue,
 /// Set to true once we're quitting. This never goes false again.
 quit: bool,
 
-/// Font discovery mechanism. This is only safe to use from the main thread.
-/// This is lazily initialized on the first call to fontDiscover so do
-/// not access this directly.
-font_discover: ?font.Discover = null,
+/// The set of font GroupCache instances shared by surfaces with the
+/// same font configuration.
+font_group_set: font.GroupCacheSet,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
@@ -55,11 +54,15 @@ pub fn create(
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
 
+    var font_group_set = try font.GroupCacheSet.init(alloc);
+    errdefer font_group_set.deinit();
+
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
         .mailbox = .{},
         .quit = false,
+        .font_group_set = font_group_set,
     };
     errdefer app.surfaces.deinit(alloc);
 
@@ -71,9 +74,9 @@ pub fn destroy(self: *App) void {
     for (self.surfaces.items) |surface| surface.deinit();
     self.surfaces.deinit(self.alloc);
 
-    if (comptime font.Discover != void) {
-        if (self.font_discover) |*v| v.deinit();
-    }
+    // Clean up our font group cache
+    // TODO(fontmem): assert all ref counts are zero
+    self.font_group_set.deinit();
 
     self.alloc.destroy(self);
 }
@@ -166,20 +169,6 @@ pub fn needsConfirmQuit(self: *const App) bool {
     return false;
 }
 
-/// Initialize once and return the font discovery mechanism. This remains
-/// initialized throughout the lifetime of the application because some
-/// font discovery mechanisms (i.e. fontconfig) are unsafe to reinit.
-pub fn fontDiscover(self: *App) !?*font.Discover {
-    // If we're built without a font discovery mechanism, return null
-    if (comptime font.Discover == void) return null;
-
-    // If we initialized, use it
-    if (self.font_discover) |*v| return v;
-
-    self.font_discover = font.Discover.init();
-    return &self.font_discover.?;
-}
-
 /// Drain the mailbox.
 fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {

commit 04e0cd29e59ac9b99e0a7f98df398c6c082ba694
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 5 15:24:24 2024 -0700

    core: begin converting to SharedGridSet, renderers still broken

diff --git a/src/App.zig b/src/App.zig
index 53ca77c6..d9b5e67f 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -43,7 +43,7 @@ quit: bool,
 
 /// The set of font GroupCache instances shared by surfaces with the
 /// same font configuration.
-font_group_set: font.GroupCacheSet,
+font_grid_set: font.SharedGridSet,
 
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
@@ -54,15 +54,15 @@ pub fn create(
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
 
-    var font_group_set = try font.GroupCacheSet.init(alloc);
-    errdefer font_group_set.deinit();
+    var font_grid_set = try font.SharedGridSet.init(alloc);
+    errdefer font_grid_set.deinit();
 
     app.* = .{
         .alloc = alloc,
         .surfaces = .{},
         .mailbox = .{},
         .quit = false,
-        .font_group_set = font_group_set,
+        .font_grid_set = font_grid_set,
     };
     errdefer app.surfaces.deinit(alloc);
 
@@ -76,7 +76,7 @@ pub fn destroy(self: *App) void {
 
     // Clean up our font group cache
     // TODO(fontmem): assert all ref counts are zero
-    self.font_group_set.deinit();
+    self.font_grid_set.deinit();
 
     self.alloc.destroy(self);
 }

commit 2a06cf54ba02c9a1dd7289600780fefb258b9bd9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 5 21:28:50 2024 -0700

    core: App asserts the font grid set is empty on close

diff --git a/src/App.zig b/src/App.zig
index d9b5e67f..41a7887b 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -75,7 +75,10 @@ pub fn destroy(self: *App) void {
     self.surfaces.deinit(self.alloc);
 
     // Clean up our font group cache
-    // TODO(fontmem): assert all ref counts are zero
+    // We should have zero items in the grid set at this point because
+    // destroy only gets called when the app is shutting down and this
+    // should gracefully close all surfaces.
+    assert(self.font_grid_set.count() == 0);
     self.font_grid_set.deinit();
 
     self.alloc.destroy(self);

commit 7c893881c349203fbc0e987e55988eaf887848a9
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Fri May 17 17:13:43 2024 -0500

    Address review comments
    
    1. Switch to using Wyhash instead of a cryptographic hash.
    2. Move global variables to App struct.

diff --git a/src/App.zig b/src/App.zig
index 41a7887b..314d0b25 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -45,6 +45,12 @@ quit: bool,
 /// same font configuration.
 font_grid_set: font.SharedGridSet,
 
+// Used to rate limit desktop notifications. Some platforms (notably macOS) will
+// run out of resources if desktop notifications are sent too fast and the OS
+// will kill Ghostty.
+last_notification_time: ?std.time.Instant = null,
+last_notification_digest: u64 = 0,
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.

commit ec0f90d1b6215eeee41a5bfcf7cd672eecc75478
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Thu Aug 1 14:49:02 2024 -0500

    Improve quit timers.
    
    Instead of "polling" to see if a quit timer has expired, start a single
    timer that expires after the confiugred delay when no more surfaces are
    open. That timer can be cancelled if necessary.

diff --git a/src/App.zig b/src/App.zig
index 314d0b25..69145ee5 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -134,6 +134,8 @@ pub fn updateConfig(self: *App, config: *const Config) !void {
 /// The surface must be from the pool.
 pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
     try self.surfaces.append(self.alloc, rt_surface);
+
+    if (@hasDecl(apprt.App, "cancelQuitTimer")) rt_surface.app.cancelQuitTimer();
 }
 
 /// Delete the surface from the known surface list. This will NOT call the
@@ -158,6 +160,8 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
 
         i += 1;
     }
+
+    if (@hasDecl(apprt.App, "startQuitTimer") and self.surfaces.items.len == 0) rt_surface.app.startQuitTimer();
 }
 
 /// The last focused surface. This is only valid while on the main thread

commit 224f2d04911c573bc2332f8466924efc12447267
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 3 10:05:31 2024 -0700

    apprt/gtk: use tagged union for quit timer

diff --git a/src/App.zig b/src/App.zig
index 69145ee5..f933b712 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -135,6 +135,9 @@ pub fn updateConfig(self: *App, config: *const Config) !void {
 pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
     try self.surfaces.append(self.alloc, rt_surface);
 
+    // Since we have non-zero surfaces, we can cancel the quit timer.
+    // It is up to the apprt if there is a quit timer at all and if it
+    // should be canceled.
     if (@hasDecl(apprt.App, "cancelQuitTimer")) rt_surface.app.cancelQuitTimer();
 }
 
@@ -161,7 +164,10 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
         i += 1;
     }
 
-    if (@hasDecl(apprt.App, "startQuitTimer") and self.surfaces.items.len == 0) rt_surface.app.startQuitTimer();
+    // If we have no surfaces, we can start the quit timer. It is up to the
+    // apprt to determine if this is necessary.
+    if (@hasDecl(apprt.App, "startQuitTimer") and
+        self.surfaces.items.len == 0) rt_surface.app.startQuitTimer();
 }
 
 /// The last focused surface. This is only valid while on the main thread

commit 7f8c1a37ffa2e644af65c0d0ec6bbbee9c98635b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Sep 23 15:05:36 2024 -0700

    core: handle app bindings in the App struct

diff --git a/src/App.zig b/src/App.zig
index f933b712..4b9c2673 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -262,6 +262,58 @@ pub fn setQuit(self: *App) !void {
     self.quit = true;
 }
 
+/// Perform a binding action. This only accepts actions that are scoped
+/// to the app. Callers can use performAllAction to perform any action
+/// and any non-app-scoped actions will be performed on all surfaces.
+pub fn performAction(
+    self: *App,
+    rt_app: *apprt.App,
+    action: input.Binding.Action.Scoped(.app),
+) !void {
+    switch (action) {
+        .unbind => unreachable,
+        .ignore => {},
+        .quit => try self.setQuit(),
+        .open_config => try self.openConfig(rt_app),
+        .reload_config => try self.reloadConfig(rt_app),
+        .close_all_windows => {
+            if (@hasDecl(apprt.App, "closeAllWindows")) {
+                rt_app.closeAllWindows();
+            } else log.warn("runtime doesn't implement closeAllWindows", .{});
+        },
+    }
+}
+
+/// Perform an app-wide binding action. If the action is surface-specific
+/// then it will be performed on all surfaces. To perform only app-scoped
+/// actions, use performAction.
+pub fn performAllAction(
+    self: *App,
+    rt_app: *apprt.App,
+    action: input.Binding.Action,
+) !void {
+    switch (action.scope()) {
+        // App-scoped actions are handled by the app so that they aren't
+        // repeated for each surface (since each surface forwards
+        // app-scoped actions back up).
+        .app => try self.performAction(
+            rt_app,
+            action.scoped(.app).?, // asserted through the scope match
+        ),
+
+        // Surface-scoped actions are performed on all surfaces. Errors
+        // are logged but processing continues.
+        .surface => for (self.surfaces.items) |surface| {
+            _ = surface.core_surface.performBindingAction(action) catch |err| {
+                log.warn("error performing binding action on surface ptr={X} err={}", .{
+                    @intFromPtr(surface),
+                    err,
+                });
+            };
+        },
+    }
+}
+
 /// Handle a window message
 fn surfaceMessage(self: *App, surface: *Surface, msg: apprt.surface.Message) !void {
     // We want to ensure our window is still active. Window messages

commit 1ad904478d2c6f3622268e0fd775f6936159d9e7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Sep 23 20:58:37 2024 -0700

    Tap events, core API to handle global keybinds

diff --git a/src/App.zig b/src/App.zig
index 4b9c2673..31f3e451 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -262,6 +262,49 @@ pub fn setQuit(self: *App) !void {
     self.quit = true;
 }
 
+/// Handle a key event at the app-scope. If this key event is used,
+/// this will return true and the caller shouldn't continue processing
+/// the event. If the event is not used, this will return false.
+pub fn keyEvent(
+    self: *App,
+    rt_app: *apprt.App,
+    event: input.KeyEvent,
+) bool {
+    switch (event.action) {
+        // We don't care about key release events.
+        .release => return false,
+
+        // Continue processing key press events.
+        .press, .repeat => {},
+    }
+
+    // Get the keybind entry for this event. We don't support key sequences
+    // so we can look directly in the top-level set.
+    const entry = rt_app.config.keybind.set.getEvent(event) orelse return false;
+    const leaf: input.Binding.Set.Leaf = switch (entry) {
+        // Sequences aren't supported. Our configuration parser verifies
+        // this for global keybinds but we may still get an entry for
+        // a non-global keybind.
+        .leader => return false,
+
+        // Leaf entries are good
+        .leaf => |leaf| leaf,
+    };
+
+    // We only care about global keybinds
+    if (!leaf.flags.global) return false;
+
+    // Perform the action
+    self.performAllAction(rt_app, leaf.action) catch |err| {
+        log.warn("error performing global keybind action action={s} err={}", .{
+            @tagName(leaf.action),
+            err,
+        });
+    };
+
+    return true;
+}
+
 /// Perform a binding action. This only accepts actions that are scoped
 /// to the app. Callers can use performAllAction to perform any action
 /// and any non-app-scoped actions will be performed on all surfaces.

commit 1b316638659bcc09633618ff499bd198cb86bb62
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Sep 24 17:00:38 2024 -0700

    apprt/embedded: new_window can be called without a parent

diff --git a/src/App.zig b/src/App.zig
index 31f3e451..d93e00a2 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -317,6 +317,7 @@ pub fn performAction(
         .unbind => unreachable,
         .ignore => {},
         .quit => try self.setQuit(),
+        .new_window => try self.newWindow(rt_app, .{ .parent = null }),
         .open_config => try self.openConfig(rt_app),
         .reload_config => try self.reloadConfig(rt_app),
         .close_all_windows => {

commit 13603c51a922392e925fd5f8bd2f0221ac438dbb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 11:01:35 2024 -0700

    apprt: begin transition to making actions an enum and not use hasDecl

diff --git a/src/App.zig b/src/App.zig
index d93e00a2..65153127 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -241,19 +241,17 @@ fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !voi
 
 /// Create a new window
 pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
-    if (!@hasDecl(apprt.App, "newWindow")) {
-        log.warn("newWindow is not supported by this runtime", .{});
-        return;
-    }
-
-    const parent = if (msg.parent) |parent| parent: {
-        break :parent if (self.hasSurface(parent))
-            parent
-        else
-            null;
-    } else null;
+    const target: apprt.Target = target: {
+        const parent = msg.parent orelse break :target .app;
+        if (self.hasSurface(parent)) break :target .{ .surface = parent };
+        break :target .app;
+    };
 
-    try rt_app.newWindow(parent);
+    try rt_app.performAction(
+        target,
+        .new_window,
+        {},
+    );
 }
 
 /// Start quitting

commit 0e043bc0e479d17b60c4401ca82742ee2269e4f0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 11:25:20 2024 -0700

    apprt: transition all hasDecls in App.zig to use the new action dispatch

diff --git a/src/App.zig b/src/App.zig
index 65153127..4462c7c8 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -138,7 +138,13 @@ pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
     // Since we have non-zero surfaces, we can cancel the quit timer.
     // It is up to the apprt if there is a quit timer at all and if it
     // should be canceled.
-    if (@hasDecl(apprt.App, "cancelQuitTimer")) rt_surface.app.cancelQuitTimer();
+    rt_surface.app.performAction(
+        .{ .surface = &rt_surface.core_surface },
+        .quit_timer,
+        .stop,
+    ) catch |err| {
+        log.warn("error stopping quit timer err={}", .{err});
+    };
 }
 
 /// Delete the surface from the known surface list. This will NOT call the
@@ -166,8 +172,13 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
 
     // If we have no surfaces, we can start the quit timer. It is up to the
     // apprt to determine if this is necessary.
-    if (@hasDecl(apprt.App, "startQuitTimer") and
-        self.surfaces.items.len == 0) rt_surface.app.startQuitTimer();
+    if (self.surfaces.items.len == 0) rt_surface.app.performAction(
+        .{ .surface = &rt_surface.core_surface },
+        .quit_timer,
+        .start,
+    ) catch |err| {
+        log.warn("error starting quit timer err={}", .{err});
+    };
 }
 
 /// The last focused surface. This is only valid while on the main thread
@@ -194,7 +205,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
             .reload_config => try self.reloadConfig(rt_app),
-            .open_config => try self.openConfig(rt_app),
+            .open_config => try self.performAction(rt_app, .open_config),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| try self.closeSurface(surface),
             .quit => try self.setQuit(),
@@ -205,12 +216,6 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
-pub fn openConfig(self: *App, rt_app: *apprt.App) !void {
-    _ = self;
-    log.debug("opening configuration", .{});
-    try rt_app.openConfig();
-}
-
 pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     log.debug("reloading configuration", .{});
     if (try rt_app.reloadConfig()) |new| {
@@ -316,13 +321,9 @@ pub fn performAction(
         .ignore => {},
         .quit => try self.setQuit(),
         .new_window => try self.newWindow(rt_app, .{ .parent = null }),
-        .open_config => try self.openConfig(rt_app),
+        .open_config => try rt_app.performAction(.app, .open_config, {}),
         .reload_config => try self.reloadConfig(rt_app),
-        .close_all_windows => {
-            if (@hasDecl(apprt.App, "closeAllWindows")) {
-                rt_app.closeAllWindows();
-            } else log.warn("runtime doesn't implement closeAllWindows", .{});
-        },
+        .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
     }
 }
 

commit 7befb5a418a8aaf174df541f57b850f430358678
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Sep 27 12:05:04 2024 -0700

    macos: fix previous/next tab bindings, improve action logging

diff --git a/src/App.zig b/src/App.zig
index 4462c7c8..2e8ac3cf 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -139,7 +139,7 @@ pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
     // It is up to the apprt if there is a quit timer at all and if it
     // should be canceled.
     rt_surface.app.performAction(
-        .{ .surface = &rt_surface.core_surface },
+        .app,
         .quit_timer,
         .stop,
     ) catch |err| {
@@ -173,7 +173,7 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
     // If we have no surfaces, we can start the quit timer. It is up to the
     // apprt to determine if this is necessary.
     if (self.surfaces.items.len == 0) rt_surface.app.performAction(
-        .{ .surface = &rt_surface.core_surface },
+        .app,
         .quit_timer,
         .start,
     ) catch |err| {

commit 7806366eec8d631d97c42d05210bad39a8c8eaaf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 09:48:47 2024 -0700

    core: fix up toggle_slide_terminal action for rebase

diff --git a/src/App.zig b/src/App.zig
index 2e8ac3cf..369fc428 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -324,6 +324,7 @@ pub fn performAction(
         .open_config => try rt_app.performAction(.app, .open_config, {}),
         .reload_config => try self.reloadConfig(rt_app),
         .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
+        .toggle_slide_terminal => try rt_app.performAction(.app, .toggle_slide_terminal, {}),
     }
 }
 

commit 1570ef01a78072ad34f3fab160ed85d180c46465
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 28 15:20:24 2024 -0700

    rename slide to quick terminal

diff --git a/src/App.zig b/src/App.zig
index 369fc428..5922528a 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -324,7 +324,7 @@ pub fn performAction(
         .open_config => try rt_app.performAction(.app, .open_config, {}),
         .reload_config => try self.reloadConfig(rt_app),
         .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
-        .toggle_slide_terminal => try rt_app.performAction(.app, .toggle_slide_terminal, {}),
+        .toggle_quick_terminal => try rt_app.performAction(.app, .toggle_quick_terminal, {}),
     }
 }
 

commit 24ba1a6100fb13a07fd847416b0dbb20aabbf4b0
Author: Roland Peelen <roland@peppr.nl>
Date:   Mon Sep 30 19:53:18 2024 +0200

    Add action on Zig side

diff --git a/src/App.zig b/src/App.zig
index 5922528a..7e82bf00 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -325,6 +325,7 @@ pub fn performAction(
         .reload_config => try self.reloadConfig(rt_app),
         .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
         .toggle_quick_terminal => try rt_app.performAction(.app, .toggle_quick_terminal, {}),
+        .toggle_visibility => try rt_app.performAction(.app, .toggle_visibility, {}),
     }
 }
 

commit f9e6d6efa6f1983ec7d9043e450ff362d59cef2b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 5 10:02:28 2024 -1000

    macos: forward key events to the app when no windows exist

diff --git a/src/App.zig b/src/App.zig
index 7e82bf00..df305ae4 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -294,9 +294,6 @@ pub fn keyEvent(
         .leaf => |leaf| leaf,
     };
 
-    // We only care about global keybinds
-    if (!leaf.flags.global) return false;
-
     // Perform the action
     self.performAllAction(rt_app, leaf.action) catch |err| {
         log.warn("error performing global keybind action action={s} err={}", .{

commit 6785f886ad26d22e5f4f2caa40500db1be6e3f6c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 6 09:32:07 2024 -1000

    core: ghostty_app_key only handles global keybinds for now
    
    This introduces a separate bug fixes #2396

diff --git a/src/App.zig b/src/App.zig
index df305ae4..7e82bf00 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -294,6 +294,9 @@ pub fn keyEvent(
         .leaf => |leaf| leaf,
     };
 
+    // We only care about global keybinds
+    if (!leaf.flags.global) return false;
+
     // Perform the action
     self.performAllAction(rt_app, leaf.action) catch |err| {
         log.warn("error performing global keybind action action={s} err={}", .{

commit bac1780c3c7dbafb4f7748638e7fdfaa0fc860d9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 6 09:54:07 2024 -1000

    core: add app focused state, make App.keyEvent focus aware

diff --git a/src/App.zig b/src/App.zig
index 7e82bf00..b557aaa0 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -30,6 +30,21 @@ alloc: Allocator,
 /// The list of surfaces that are currently active.
 surfaces: SurfaceList,
 
+/// This is true if the app that Ghostty is in is focused. This may
+/// mean that no surfaces (terminals) are focused but the app is still
+/// focused, i.e. may an about window. On macOS, this concept is known
+/// as the "active" app while focused windows are known as the
+/// "main" window.
+///
+/// This is used to determine if keyboard shortcuts that are non-global
+/// should be processed. If the app is not focused, then we don't want
+/// to process keyboard shortcuts that are not global.
+///
+/// This defaults to true since we assume that the app is focused when
+/// Ghostty is initialized but a well behaved apprt should call
+/// focusEvent to set this to the correct value right away.
+focused: bool = true,
+
 /// The last focused surface. This surface may not be valid;
 /// you must always call hasSurface to validate it.
 focused_surface: ?*Surface = null,
@@ -54,6 +69,9 @@ last_notification_digest: u64 = 0,
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
+///
+/// After calling this function, well behaved apprts should then call
+/// `focusEvent` to set the initial focus state of the app.
 pub fn create(
     alloc: Allocator,
 ) !*App {
@@ -265,9 +283,21 @@ pub fn setQuit(self: *App) !void {
     self.quit = true;
 }
 
+/// Handle an app-level focus event. This should be called whenever
+/// the focus state of the entire app containing Ghostty changes.
+/// This is separate from surface focus events. See the `focused`
+/// field for more information.
+pub fn focusEvent(self: *App, focused: bool) void {
+    self.focused = focused;
+}
+
 /// Handle a key event at the app-scope. If this key event is used,
 /// this will return true and the caller shouldn't continue processing
 /// the event. If the event is not used, this will return false.
+///
+/// If the app currently has focus then all key events are processed.
+/// If the app does not have focus then only global key events are
+/// processed.
 pub fn keyEvent(
     self: *App,
     rt_app: *apprt.App,
@@ -294,13 +324,33 @@ pub fn keyEvent(
         .leaf => |leaf| leaf,
     };
 
-    // We only care about global keybinds
-    if (!leaf.flags.global) return false;
+    // If we aren't focused, then we only process global keybinds.
+    if (!self.focused and !leaf.flags.global) return false;
+
+    // Global keybinds are done using performAll so that they
+    // can target all surfaces too.
+    if (leaf.flags.global) {
+        self.performAllAction(rt_app, leaf.action) catch |err| {
+            log.warn("error performing global keybind action action={s} err={}", .{
+                @tagName(leaf.action),
+                err,
+            });
+        };
+
+        return true;
+    }
 
-    // Perform the action
-    self.performAllAction(rt_app, leaf.action) catch |err| {
-        log.warn("error performing global keybind action action={s} err={}", .{
-            @tagName(leaf.action),
+    // Must be focused to process non-global keybinds
+    assert(self.focused);
+    assert(!leaf.flags.global);
+
+    // If we are focused, then we process keybinds only if they are
+    // app-scoped. Otherwise, we do nothing. Surface-scoped should
+    // be processed by Surface.keyEvent.
+    const app_action = leaf.action.scoped(.app) orelse return false;
+    self.performAction(rt_app, app_action) catch |err| {
+        log.warn("error performing app keybind action action={s} err={}", .{
+            @tagName(app_action),
             err,
         });
     };

commit e56cfbdc8b8a5550889452f9da0d71d382938bc1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 6 10:06:07 2024 -1000

    macos: set the proper app focus state

diff --git a/src/App.zig b/src/App.zig
index b557aaa0..6a4a7a54 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -288,6 +288,7 @@ pub fn setQuit(self: *App) !void {
 /// This is separate from surface focus events. See the `focused`
 /// field for more information.
 pub fn focusEvent(self: *App, focused: bool) void {
+    log.debug("focus event focused={}", .{focused});
     self.focused = focused;
 }
 

commit 494fedca2f33bf1959c03dfd5c6cce1d854699e3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 6 13:30:53 2024 -0700

    apprt/gtk: report proper app focus state

diff --git a/src/App.zig b/src/App.zig
index 6a4a7a54..599265a4 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -288,6 +288,9 @@ pub fn setQuit(self: *App) !void {
 /// This is separate from surface focus events. See the `focused`
 /// field for more information.
 pub fn focusEvent(self: *App, focused: bool) void {
+    // Prevent redundant focus events
+    if (self.focused == focused) return;
+
     log.debug("focus event focused={}", .{focused});
     self.focused = focused;
 }

commit 8d7367fa645ee53d559a6bb0c700308219e19bb3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 8 06:29:31 2024 -1000

    input: return a K/V entry for the binding set `get`

diff --git a/src/App.zig b/src/App.zig
index 599265a4..0d09fed5 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -318,7 +318,7 @@ pub fn keyEvent(
     // Get the keybind entry for this event. We don't support key sequences
     // so we can look directly in the top-level set.
     const entry = rt_app.config.keybind.set.getEvent(event) orelse return false;
-    const leaf: input.Binding.Set.Leaf = switch (entry) {
+    const leaf: input.Binding.Set.Leaf = switch (entry.value_ptr.*) {
         // Sequences aren't supported. Our configuration parser verifies
         // this for global keybinds but we may still get an entry for
         // a non-global keybind.

commit 3f1d6eb301a7fb3d967c7f17c555c8dd761d900c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 17 22:00:05 2024 -0700

    expand explicit error set usage
    
    This continues our work to improve the amount of explicit error sets
    we use in the codebase. Explicit error sets make it easier to understand
    possible failure scenarios, allow us to use exhaustive matching, create
    compiler errors if errors are unexpectedly added or removed, etc.
    
    The goal eventually is 100% coverage but we're not even close yet.
    This just moves us a little closer.

diff --git a/src/App.zig b/src/App.zig
index 0d09fed5..b1ea2eb7 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -66,6 +66,8 @@ font_grid_set: font.SharedGridSet,
 last_notification_time: ?std.time.Instant = null,
 last_notification_digest: u64 = 0,
 
+pub const CreateError = Allocator.Error || font.SharedGridSet.InitError;
+
 /// Initialize the main app instance. This creates the main window, sets
 /// up the renderer state, compiles the shaders, etc. This is the primary
 /// "startup" logic.
@@ -74,7 +76,7 @@ last_notification_digest: u64 = 0,
 /// `focusEvent` to set the initial focus state of the app.
 pub fn create(
     alloc: Allocator,
-) !*App {
+) CreateError!*App {
     var app = try alloc.create(App);
     errdefer alloc.destroy(app);
 
@@ -150,7 +152,10 @@ pub fn updateConfig(self: *App, config: *const Config) !void {
 /// Add an initialized surface. This is really only for the runtime
 /// implementations to call and should NOT be called by general app users.
 /// The surface must be from the pool.
-pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {
+pub fn addSurface(
+    self: *App,
+    rt_surface: *apprt.Surface,
+) Allocator.Error!void {
     try self.surfaces.append(self.alloc, rt_surface);
 
     // Since we have non-zero surfaces, we can cancel the quit timer.
@@ -225,11 +230,11 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             .reload_config => try self.reloadConfig(rt_app),
             .open_config => try self.performAction(rt_app, .open_config),
             .new_window => |msg| try self.newWindow(rt_app, msg),
-            .close => |surface| try self.closeSurface(surface),
-            .quit => try self.setQuit(),
+            .close => |surface| self.closeSurface(surface),
+            .quit => self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
-            .redraw_surface => |surface| try self.redrawSurface(rt_app, surface),
-            .redraw_inspector => |surface| try self.redrawInspector(rt_app, surface),
+            .redraw_surface => |surface| self.redrawSurface(rt_app, surface),
+            .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),
         }
     }
 }
@@ -242,7 +247,7 @@ pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
-pub fn closeSurface(self: *App, surface: *Surface) !void {
+pub fn closeSurface(self: *App, surface: *Surface) void {
     if (!self.hasSurface(surface)) return;
     surface.close();
 }
@@ -252,12 +257,12 @@ pub fn focusSurface(self: *App, surface: *Surface) void {
     self.focused_surface = surface;
 }
 
-fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {
+fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {
     if (!self.hasSurface(&surface.core_surface)) return;
     rt_app.redrawSurface(surface);
 }
 
-fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) !void {
+fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {
     if (!self.hasSurface(&surface.core_surface)) return;
     rt_app.redrawInspector(surface);
 }
@@ -278,7 +283,7 @@ pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
 }
 
 /// Start quitting
-pub fn setQuit(self: *App) !void {
+pub fn setQuit(self: *App) void {
     if (self.quit) return;
     self.quit = true;
 }
@@ -373,7 +378,7 @@ pub fn performAction(
     switch (action) {
         .unbind => unreachable,
         .ignore => {},
-        .quit => try self.setQuit(),
+        .quit => self.setQuit(),
         .new_window => try self.newWindow(rt_app, .{ .parent = null }),
         .open_config => try rt_app.performAction(.app, .open_config, {}),
         .reload_config => try self.reloadConfig(rt_app),

commit 463f4afc0529f3992aecdf552cfe0f3e81796722
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Oct 18 08:14:40 2024 -0700

    apprt/glfw: exit with invalid CLI args

diff --git a/src/App.zig b/src/App.zig
index b1ea2eb7..0f9a0d89 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -231,10 +231,19 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             .open_config => try self.performAction(rt_app, .open_config),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| self.closeSurface(surface),
-            .quit => self.setQuit(),
             .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
             .redraw_surface => |surface| self.redrawSurface(rt_app, surface),
             .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),
+
+            // If we're quitting, then we set the quit flag and stop
+            // draining the mailbox immediately. This lets us defer
+            // mailbox processing to the next tick so that the apprt
+            // can try to quick as quickly as possible.
+            .quit => {
+                log.info("quit message received, short circuiting mailbox drain", .{});
+                self.setQuit();
+                return;
+            },
         }
     }
 }

commit c90ed293417add9bab0ac52ccef9eae0efd3e0cb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Oct 18 12:53:32 2024 -0700

    cli: skip argv0 and actions when parsing CLI flags
    
    This fixes a regression from #2454. In that PR, we added an error when
    positional arguments are detected. I believe that's correct, but we
    were silently relying on the previous behavior in the CLI commands.
    
    This commit changes the CLI commands to use a new argsIterator function
    that creates an iterator that skips the first argument (argv0). This is
    the same behavior that the config parsing does and now uses this shared
    logic.
    
    This also makes it so the argsIterator ignores actions (`+things`)
    and we document that we expect those to be handled earlier.

diff --git a/src/App.zig b/src/App.zig
index 0f9a0d89..c54c6716 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -238,7 +238,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             // If we're quitting, then we set the quit flag and stop
             // draining the mailbox immediately. This lets us defer
             // mailbox processing to the next tick so that the apprt
-            // can try to quick as quickly as possible.
+            // can try to quit as quickly as possible.
             .quit => {
                 log.info("quit message received, short circuiting mailbox drain", .{});
                 self.setQuit();

commit 65f1cefb4e8fb2da369d8afdcf2ea6e15ffde164
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 5 16:51:13 2024 -0800

    config: add "initial-command" config, "-e" sets that
    
    Fixes #2601
    
    It is more expected behavior that `-e` affects only the first window. By
    introducing a dedicated configuration we avoid making `-e` too magical:
    its simply syntax sugar for setting the "initial-command" configuration.

diff --git a/src/App.zig b/src/App.zig
index c54c6716..cc8277c5 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -66,6 +66,11 @@ font_grid_set: font.SharedGridSet,
 last_notification_time: ?std.time.Instant = null,
 last_notification_digest: u64 = 0,
 
+/// Set to false once we've created at least one surface. This
+/// never goes true again. This can be used by surfaces to determine
+/// if they are the first surface.
+first: bool = true,
+
 pub const CreateError = Allocator.Error || font.SharedGridSet.InitError;
 
 /// Initialize the main app instance. This creates the main window, sets

commit a436bd0af62a4bdc5af14774b955f7b46ccd9deb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 7 14:38:54 2024 -0800

    move datastructures to dedicated "datastruct" package

diff --git a/src/App.zig b/src/App.zig
index cc8277c5..271ba204 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -13,7 +13,7 @@ const Surface = @import("Surface.zig");
 const tracy = @import("tracy");
 const input = @import("input.zig");
 const Config = @import("config.zig").Config;
-const BlockingQueue = @import("./blocking_queue.zig").BlockingQueue;
+const BlockingQueue = @import("datastruct/main.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
 const internal_os = @import("os/main.zig");

commit fadfb08efef52b23ceac598839c98fdf51d2cf1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 20 15:08:47 2024 -0800

    apprt: add `config_change` action

diff --git a/src/App.zig b/src/App.zig
index 271ba204..ebf257f0 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -147,11 +147,18 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
 /// Update the configuration associated with the app. This can only be
 /// called from the main thread. The caller owns the config memory. The
 /// memory can be freed immediately when this returns.
-pub fn updateConfig(self: *App, config: *const Config) !void {
+pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void {
     // Go through and update all of the surface configurations.
     for (self.surfaces.items) |surface| {
         try surface.core_surface.handleMessage(.{ .change_config = config });
     }
+
+    // Notify the apprt that the app has changed configuration.
+    try rt_app.performAction(
+        .app,
+        .config_change,
+        .{ .config = config },
+    );
 }
 
 /// Add an initialized surface. This is really only for the runtime
@@ -257,7 +264,7 @@ pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
     log.debug("reloading configuration", .{});
     if (try rt_app.reloadConfig()) |new| {
         log.debug("new configuration received, applying", .{});
-        try self.updateConfig(new);
+        try self.updateConfig(rt_app, new);
     }
 }
 

commit a191f3c396eec57293dd5df8a2a56e0b01384f5a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 22 10:43:51 2024 -0800

    apprt: switch to reload_config action that calls update_config API

diff --git a/src/App.zig b/src/App.zig
index ebf257f0..57b30ada 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -12,7 +12,8 @@ const apprt = @import("apprt.zig");
 const Surface = @import("Surface.zig");
 const tracy = @import("tracy");
 const input = @import("input.zig");
-const Config = @import("config.zig").Config;
+const configpkg = @import("config.zig");
+const Config = configpkg.Config;
 const BlockingQueue = @import("datastruct/main.zig").BlockingQueue;
 const renderer = @import("renderer.zig");
 const font = @import("font/main.zig");
@@ -239,7 +240,6 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     while (self.mailbox.pop()) |message| {
         log.debug("mailbox message={s}", .{@tagName(message)});
         switch (message) {
-            .reload_config => try self.reloadConfig(rt_app),
             .open_config => try self.performAction(rt_app, .open_config),
             .new_window => |msg| try self.newWindow(rt_app, msg),
             .close => |surface| self.closeSurface(surface),
@@ -260,14 +260,6 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
     }
 }
 
-pub fn reloadConfig(self: *App, rt_app: *apprt.App) !void {
-    log.debug("reloading configuration", .{});
-    if (try rt_app.reloadConfig()) |new| {
-        log.debug("new configuration received, applying", .{});
-        try self.updateConfig(rt_app, new);
-    }
-}
-
 pub fn closeSurface(self: *App, surface: *Surface) void {
     if (!self.hasSurface(surface)) return;
     surface.close();
@@ -402,7 +394,7 @@ pub fn performAction(
         .quit => self.setQuit(),
         .new_window => try self.newWindow(rt_app, .{ .parent = null }),
         .open_config => try rt_app.performAction(.app, .open_config, {}),
-        .reload_config => try self.reloadConfig(rt_app),
+        .reload_config => try rt_app.performAction(.app, .reload_config, .{}),
         .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
         .toggle_quick_terminal => try rt_app.performAction(.app, .toggle_quick_terminal, {}),
         .toggle_visibility => try rt_app.performAction(.app, .toggle_visibility, {}),
@@ -462,10 +454,6 @@ fn hasSurface(self: *const App, surface: *const Surface) bool {
 
 /// The message types that can be sent to the app thread.
 pub const Message = union(enum) {
-    /// Reload the configuration for the entire app and propagate it to
-    /// all the active surfaces.
-    reload_config: void,
-
     // Open the configuration file
     open_config: void,
 

commit cd49015243b794cf51ca30e8d32f09d4d362925f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 22 13:42:48 2024 -0800

    App applies conditional state, supports theme setting
    
    The prior light/dark mode awareness work works on surface-level APIs. As
    a result, configurations used at the app-level (such as split divider
    colors, inactive split opacity, etc.) are not aware of the current theme
    configurations and default to the "light" theme.
    
    This commit adds APIs to specify app-level color scheme changes. This
    changes the configuration for the app and sets the default conditional
    state to use that new theme. This latter point makes it so that future
    surfaces use the correct theme on load rather than requiring some apprt
    event loop ticks. Some users have already reported a short "flicker" to
    load the correct theme, so this should help alleviate that.

diff --git a/src/App.zig b/src/App.zig
index 57b30ada..279c4e49 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -67,6 +67,11 @@ font_grid_set: font.SharedGridSet,
 last_notification_time: ?std.time.Instant = null,
 last_notification_digest: u64 = 0,
 
+/// The conditional state of the configuration. See the equivalent field
+/// in the Surface struct for more information. In this case, this applies
+/// to the app-level config and as a default for new surfaces.
+config_conditional_state: configpkg.ConditionalState,
+
 /// Set to false once we've created at least one surface. This
 /// never goes true again. This can be used by surfaces to determine
 /// if they are the first surface.
@@ -95,6 +100,7 @@ pub fn create(
         .mailbox = .{},
         .quit = false,
         .font_grid_set = font_grid_set,
+        .config_conditional_state = .{},
     };
     errdefer app.surfaces.deinit(alloc);
 
@@ -154,11 +160,24 @@ pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void
         try surface.core_surface.handleMessage(.{ .change_config = config });
     }
 
+    // Apply our conditional state. If we fail to apply the conditional state
+    // then we log and attempt to move forward with the old config.
+    // We only apply this to the app-level config because the surface
+    // config applies its own conditional state.
+    var applied_: ?configpkg.Config = config.changeConditionalState(
+        self.config_conditional_state,
+    ) catch |err| err: {
+        log.warn("failed to apply conditional state to config err={}", .{err});
+        break :err null;
+    };
+    defer if (applied_) |*c| c.deinit();
+    const applied: *const configpkg.Config = if (applied_) |*c| c else config;
+
     // Notify the apprt that the app has changed configuration.
     try rt_app.performAction(
         .app,
         .config_change,
-        .{ .config = config },
+        .{ .config = applied },
     );
 }
 
@@ -380,6 +399,33 @@ pub fn keyEvent(
     return true;
 }
 
+/// Call to notify Ghostty that the color scheme for the app has changed.
+/// "Color scheme" in this case refers to system themes such as "light/dark".
+pub fn colorSchemeEvent(
+    self: *App,
+    rt_app: *apprt.App,
+    scheme: apprt.ColorScheme,
+) !void {
+    const new_scheme: configpkg.ConditionalState.Theme = switch (scheme) {
+        .light => .light,
+        .dark => .dark,
+    };
+
+    // If our scheme didn't change, then we don't do anything.
+    if (self.config_conditional_state.theme == new_scheme) return;
+
+    // Setup our conditional state which has the current color theme.
+    self.config_conditional_state.theme = new_scheme;
+
+    // Request our configuration be reloaded because the new scheme may
+    // impact the colors of the app.
+    try rt_app.performAction(
+        .app,
+        .reload_config,
+        .{ .soft = true },
+    );
+}
+
 /// Perform a binding action. This only accepts actions that are scoped
 /// to the app. Callers can use performAllAction to perform any action
 /// and any non-app-scoped actions will be performed on all surfaces.

commit e8811ac6fb0063887adcaa58892a76e77a5c180c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 4 07:10:07 2025 -0800

    Move app quit to apprt action
    
    This changes quit signaling from a boolean return from core app `tick()`
    to an apprt action. This simplifies the API and conceptually makes more
    sense to me now.
    
    This wasn't done just for that; this change was also needed so that
    macOS can quit cleanly while fixing #4540 since we may no longer trigger
    menu items. I wanted to split this out into a separate commit/PR because
    it adds complexity making the diff harder to read.

diff --git a/src/App.zig b/src/App.zig
index 279c4e49..b0de85c9 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -54,9 +54,6 @@ focused_surface: ?*Surface = null,
 /// this is a blocking queue so if it is full you will get errors (or block).
 mailbox: Mailbox.Queue,
 
-/// Set to true once we're quitting. This never goes false again.
-quit: bool,
-
 /// The set of font GroupCache instances shared by surfaces with the
 /// same font configuration.
 font_grid_set: font.SharedGridSet,
@@ -98,7 +95,6 @@ pub fn create(
         .alloc = alloc,
         .surfaces = .{},
         .mailbox = .{},
-        .quit = false,
         .font_grid_set = font_grid_set,
         .config_conditional_state = .{},
     };
@@ -125,9 +121,7 @@ pub fn destroy(self: *App) void {
 /// Tick ticks the app loop. This will drain our mailbox and process those
 /// events. This should be called by the application runtime on every loop
 /// tick.
-///
-/// This returns whether the app should quit or not.
-pub fn tick(self: *App, rt_app: *apprt.App) !bool {
+pub fn tick(self: *App, rt_app: *apprt.App) !void {
     // If any surfaces are closing, destroy them
     var i: usize = 0;
     while (i < self.surfaces.items.len) {
@@ -142,13 +136,6 @@ pub fn tick(self: *App, rt_app: *apprt.App) !bool {
 
     // Drain our mailbox
     try self.drainMailbox(rt_app);
-
-    // No matter what, we reset the quit flag after a tick. If the apprt
-    // doesn't want to quit, then we can't force it to.
-    defer self.quit = false;
-
-    // We quit if our quit flag is on
-    return self.quit;
 }
 
 /// Update the configuration associated with the app. This can only be
@@ -272,7 +259,7 @@ fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
             // can try to quit as quickly as possible.
             .quit => {
                 log.info("quit message received, short circuiting mailbox drain", .{});
-                self.setQuit();
+                try self.performAction(rt_app, .quit);
                 return;
             },
         }
@@ -314,12 +301,6 @@ pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
     );
 }
 
-/// Start quitting
-pub fn setQuit(self: *App) void {
-    if (self.quit) return;
-    self.quit = true;
-}
-
 /// Handle an app-level focus event. This should be called whenever
 /// the focus state of the entire app containing Ghostty changes.
 /// This is separate from surface focus events. See the `focused`
@@ -437,7 +418,7 @@ pub fn performAction(
     switch (action) {
         .unbind => unreachable,
         .ignore => {},
-        .quit => self.setQuit(),
+        .quit => try rt_app.performAction(.app, .quit, {}),
         .new_window => try self.newWindow(rt_app, .{ .parent = null }),
         .open_config => try rt_app.performAction(.app, .open_config, {}),
         .reload_config => try rt_app.performAction(.app, .reload_config, .{}),

commit 40bdea73357ded7a3a753ee8f26d65a07434f087
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 4 14:07:33 2025 -0800

    macos: handle overridden system bindings with no focused window

diff --git a/src/App.zig b/src/App.zig
index b0de85c9..a6b54db2 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -313,6 +313,25 @@ pub fn focusEvent(self: *App, focused: bool) void {
     self.focused = focused;
 }
 
+/// Returns true if the given key event would trigger a keybinding
+/// if it were to be processed. This is useful for determining if
+/// a key event should be sent to the terminal or not.
+pub fn keyEventIsBinding(
+    self: *App,
+    rt_app: *apprt.App,
+    event: input.KeyEvent,
+) bool {
+    _ = self;
+
+    switch (event.action) {
+        .release => return false,
+        .press, .repeat => {},
+    }
+
+    // If we have a keybinding for this event then we return true.
+    return rt_app.config.keybind.set.getEvent(event) != null;
+}
+
 /// Handle a key event at the app-scope. If this key event is used,
 /// this will return true and the caller shouldn't continue processing
 /// the event. If the event is not used, this will return false.

commit 4ad749607aaafdba457aa21e5a5645c19976b341
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Sat Feb 8 15:56:29 2025 -0600

    core: performAction now returns a bool
    
    This is to facilitate the `performable:` prefix on keybinds that are
    implemented using app runtime actions.

diff --git a/src/App.zig b/src/App.zig
index a6b54db2..15859d11 100644
--- a/src/App.zig
+++ b/src/App.zig
@@ -161,7 +161,7 @@ pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void
     const applied: *const configpkg.Config = if (applied_) |*c| c else config;
 
     // Notify the apprt that the app has changed configuration.
-    try rt_app.performAction(
+    _ = try rt_app.performAction(
         .app,
         .config_change,
         .{ .config = applied },
@@ -180,7 +180,7 @@ pub fn addSurface(
     // Since we have non-zero surfaces, we can cancel the quit timer.
     // It is up to the apprt if there is a quit timer at all and if it
     // should be canceled.
-    rt_surface.app.performAction(
+    _ = rt_surface.app.performAction(
         .app,
         .quit_timer,
         .stop,
@@ -214,7 +214,7 @@ pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
 
     // If we have no surfaces, we can start the quit timer. It is up to the
     // apprt to determine if this is necessary.
-    if (self.surfaces.items.len == 0) rt_surface.app.performAction(
+    if (self.surfaces.items.len == 0) _ = rt_surface.app.performAction(
         .app,
         .quit_timer,
         .start,
@@ -294,7 +294,7 @@ pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {
         break :target .app;
     };
 
-    try rt_app.performAction(
+    _ = try rt_app.performAction(
         target,
         .new_window,
         {},
@@ -419,7 +419,7 @@ pub fn colorSchemeEvent(
 
     // Request our configuration be reloaded because the new scheme may
     // impact the colors of the app.
-    try rt_app.performAction(
+    _ = try rt_app.performAction(
         .app,
         .reload_config,
         .{ .soft = true },
@@ -437,13 +437,13 @@ pub fn performAction(
     switch (action) {
         .unbind => unreachable,
         .ignore => {},
-        .quit => try rt_app.performAction(.app, .quit, {}),
-        .new_window => try self.newWindow(rt_app, .{ .parent = null }),
-        .open_config => try rt_app.performAction(.app, .open_config, {}),
-        .reload_config => try rt_app.performAction(.app, .reload_config, .{}),
-        .close_all_windows => try rt_app.performAction(.app, .close_all_windows, {}),
-        .toggle_quick_terminal => try rt_app.performAction(.app, .toggle_quick_terminal, {}),
-        .toggle_visibility => try rt_app.performAction(.app, .toggle_visibility, {}),
+        .quit => _ = try rt_app.performAction(.app, .quit, {}),
+        .new_window => _ = try self.newWindow(rt_app, .{ .parent = null }),
+        .open_config => _ = try rt_app.performAction(.app, .open_config, {}),
+        .reload_config => _ = try rt_app.performAction(.app, .reload_config, .{}),
+        .close_all_windows => _ = try rt_app.performAction(.app, .close_all_windows, {}),
+        .toggle_quick_terminal => _ = try rt_app.performAction(.app, .toggle_quick_terminal, {}),
+        .toggle_visibility => _ = try rt_app.performAction(.app, .toggle_visibility, {}),
     }
 }
 

