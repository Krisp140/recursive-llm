# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/id_tracker/immutable_id_tracker.rs

commit 6650e5885f6b622161741fb7ecfe181b81a346bf
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Jul 17 19:45:22 2024 +0200

    Merge pull request #4403
    
    * add immutable_id_tracker
    
    * add dirty flag in test
    
    * don't use immutable_id_tracker for now
    
    * improve and integrate new immutable_id_tracker
    
    * split external_to_internal into two BTreeMaps
    
    * apply rquested changes
    
    * delay mmap writes until flush
    
    * remove unnecessary clone
    
    * single source of truth for file path
    
    * use custom de/serialization for more performance
    
    * disable id tracker and fix codespell
    
    * improve code & test
    
    * Other minor nitpicks
    
    * Apply suggestions from code review
    
    * fix rebase issues
    
    * basic custom mappings storage implementation
    
    * add tests & fix bugs
    
    * add more tests and fix bugs
    
    * undo .codespellrc
    
    * disable immutable_id_tracker completely for now
    
    * fix clippy
    
    * Remove unnecessary pub
    
    * minor renaming

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
new file mode 100644
index 000000000..26342535c
--- /dev/null
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -0,0 +1,880 @@
+// TODO: Remove when we release the next version and integrate the immutable id tracker
+#![allow(dead_code)]
+use std::collections::BTreeMap;
+use std::fs::File;
+use std::io::{BufReader, BufWriter, Read, Write};
+use std::mem::size_of_val;
+use std::path::{Path, PathBuf};
+
+use bitvec::prelude::BitSlice;
+use bitvec::vec::BitVec;
+use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
+use common::types::PointOffsetType;
+use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
+use uuid::Uuid;
+
+use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
+use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWrapper;
+use crate::common::mmap_type::{MmapBitSlice, MmapSlice};
+use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::Flusher;
+use crate::id_tracker::IdTracker;
+use crate::types::{ExtendedPointId, PointIdType, SeqNumberType};
+
+pub const DELETED_FILE_NAME: &str = "id_tracker.deleted";
+pub const MAPPINGS_FILE_NAME: &str = "id_tracker.mappings";
+pub const VERSION_MAPPING_FILE_NAME: &str = "id_tracker.versions";
+
+#[derive(Debug)]
+pub struct ImmutableIdTracker {
+    path: PathBuf,
+
+    deleted: BitVec,
+    deleted_wrapper: MmapBitSliceBufferedUpdateWrapper,
+
+    internal_to_version: Vec<SeqNumberType>,
+    internal_to_version_wrapper: MmapSliceBufferedUpdateWrapper<SeqNumberType>,
+
+    mappings: PointMappings,
+}
+
+#[derive(Clone, PartialEq, Debug)]
+pub struct PointMappings {
+    pub(crate) internal_to_external: Vec<PointIdType>,
+
+    // Having two separate maps allows us iterating only over one type at a time without having to filter.
+    pub(crate) external_to_internal_num: BTreeMap<u64, PointOffsetType>,
+    pub(crate) external_to_internal_uuid: BTreeMap<Uuid, PointOffsetType>,
+}
+
+/// Used endianness for storing PointMapping-files.
+type FileEndianess = LittleEndian;
+
+impl PointMappings {
+    const EXTERNAL_ID_NUMBER_BYTE: u8 = 0;
+    const EXTERNAL_ID_UUID_BYTE: u8 = 1;
+
+    /// Loads a `PointMappings` from the given reader. Applies an optional filter of deleted items
+    /// to prevent allocating unneeded data.
+    pub fn load<R: Read>(mut reader: R, filter: Option<&BitSlice>) -> OperationResult<Self> {
+        // Deserialize the header
+        let len = reader.read_u64::<FileEndianess>()? as usize;
+
+        let mut internal_to_external = Vec::with_capacity(len);
+        let mut external_to_internal_num: BTreeMap<u64, PointOffsetType> = BTreeMap::new();
+        let mut external_to_internal_uuid: BTreeMap<Uuid, PointOffsetType> = BTreeMap::new();
+
+        // Deserialize the list entries
+        for i in 0..len {
+            let (internal_id, external_id) = Self::read_entry(&mut reader)?;
+
+            // Need to push this regardless of point deletion as the vecs index represents the internal id
+            // which would become wrong if we leave out entries.
+            internal_to_external.push(external_id);
+
+            let deleted = filter
+                .as_ref()
+                .and_then(|deleted| deleted.get(i).as_deref().copied())
+                .unwrap_or_default();
+
+            if deleted {
+                continue;
+            }
+
+            match external_id {
+                ExtendedPointId::NumId(num) => {
+                    external_to_internal_num.insert(num, internal_id);
+                }
+                ExtendedPointId::Uuid(uuid) => {
+                    external_to_internal_uuid.insert(uuid, internal_id);
+                }
+            }
+        }
+
+        // Check that the file has ben fully read.
+        #[cfg(debug_assertions)] // Only for dev builds
+        {
+            let mut buf = vec![];
+            let read_bytes = reader.read_to_end(&mut buf).unwrap();
+            assert_eq!(buf.len(), 0);
+            assert_eq!(read_bytes, 0);
+        }
+
+        Ok(PointMappings {
+            internal_to_external,
+            external_to_internal_num,
+            external_to_internal_uuid,
+        })
+    }
+
+    /// Loads a single entry from a reader. Expects the reader to be aligned so, that the next read
+    /// byte is the first byte of a new entry.
+    /// This function reads exact one entry which means after calling this function, the reader
+    /// will be at the start of the next entry.
+    fn read_entry<R: Read>(mut reader: R) -> OperationResult<(PointOffsetType, ExtendedPointId)> {
+        let point_id_type = reader.read_u8()?;
+
+        let external_id = if point_id_type == Self::EXTERNAL_ID_NUMBER_BYTE {
+            let num = reader.read_u64::<FileEndianess>()?;
+            PointIdType::NumId(num)
+        } else if point_id_type == Self::EXTERNAL_ID_UUID_BYTE {
+            let uuid_u128 = reader.read_u128::<FileEndianess>()?;
+            PointIdType::Uuid(Uuid::from_u128_le(uuid_u128))
+        } else {
+            return Err(OperationError::InconsistentStorage {
+                description: "Invalid byte read when deserializing Immutable id tracker"
+                    .to_string(),
+            });
+        };
+
+        let internal_id = reader.read_u32::<FileEndianess>()? as PointOffsetType;
+        Ok((internal_id, external_id))
+    }
+
+    /// Serializes the `PointMappings` into the given writer using the file format specified below.
+    ///
+    /// ## File format
+    /// In general the format looks like this:
+    /// +---------------------------+-----------------+
+    /// | Header (list length: u64) | List of entries |
+    /// +---------------------------+-----------------+
+    ///
+    /// A single list entry:
+    /// +-----------------+-----------------------+------------------+
+    /// | PointIdType: u8 | Number/UUID: u64/u128 | Internal ID: u32 |
+    /// +-----------------+-----------------------+------------------+
+    /// A single entry is thus either 1+8+4=13 or 1+16+4=21 bytes in size depending
+    /// on the PointIdType.
+
+    pub fn store<W: Write>(&self, mut writer: W) -> OperationResult<()> {
+        // Serialize the header (=length).
+        writer.write_u64::<FileEndianess>(self.internal_to_external.len() as u64)?;
+
+        // Serialize all entries
+        for external_id in self.internal_to_external.iter() {
+            self.write_entry(&mut writer, external_id)?;
+        }
+
+        writer.flush()?;
+        Ok(())
+    }
+
+    fn write_entry<W: Write>(
+        &self,
+        mut writer: W,
+        external_id: &PointIdType,
+    ) -> OperationResult<()> {
+        // Serializing External ID
+        match external_id {
+            PointIdType::NumId(num) => {
+                // Byte to distinguish between Number and UUID
+                writer.write_u8(Self::EXTERNAL_ID_NUMBER_BYTE)?;
+
+                // The PointID's number
+                writer.write_u64::<FileEndianess>(*num)?;
+            }
+            PointIdType::Uuid(uuid) => {
+                // Byte to distinguish between Number and UUID
+                writer.write_u8(Self::EXTERNAL_ID_UUID_BYTE)?;
+
+                // The PointID's UUID
+                writer.write_u128::<FileEndianess>(uuid.to_u128_le())?;
+            }
+        }
+
+        let internal_id = match external_id {
+            PointIdType::NumId(n) => self.external_to_internal_num.get(n),
+            PointIdType::Uuid(u) => self.external_to_internal_uuid.get(u),
+        }
+        .ok_or(OperationError::PointIdError {
+            missed_point_id: *external_id,
+        })?;
+
+        // Serializing Internal ID
+        writer.write_u32::<FileEndianess>(*internal_id)?;
+
+        Ok(())
+    }
+}
+
+impl ImmutableIdTracker {
+    pub fn open(segment_path: &Path) -> OperationResult<Self> {
+        let deleted_raw = open_write_mmap(&Self::deleted_file_path(segment_path))?;
+        let deleted_mmap = MmapBitSlice::try_from(deleted_raw, 0)?;
+        let deleted_bitvec = deleted_mmap.to_bitvec();
+        let deleted_wrapper = MmapBitSliceBufferedUpdateWrapper::new(deleted_mmap);
+
+        let internal_to_version_map =
+            open_write_mmap(&Self::version_mapping_file_path(segment_path))?;
+        let internal_to_version_mapslice: MmapSlice<SeqNumberType> =
+            unsafe { MmapSlice::try_from(internal_to_version_map)? };
+        let internal_to_version = internal_to_version_mapslice.to_vec();
+        let internal_to_version_wrapper =
+            MmapSliceBufferedUpdateWrapper::new(internal_to_version_mapslice);
+
+        let reader = BufReader::new(File::open(Self::mappings_file_path(segment_path))?);
+        let mappings = PointMappings::load(reader, Some(&deleted_bitvec))?;
+
+        Ok(Self {
+            path: segment_path.to_path_buf(),
+            deleted: deleted_bitvec,
+            deleted_wrapper,
+            internal_to_version_wrapper,
+            internal_to_version,
+            mappings,
+        })
+    }
+
+    pub(super) fn new(
+        path: &Path,
+        deleted: &BitSlice,
+        internal_to_version: &[SeqNumberType],
+        mappings: PointMappings,
+    ) -> OperationResult<Self> {
+        // Create mmap file for deleted bitvec
+        let deleted_filepath = Self::deleted_file_path(path);
+        {
+            let deleted_size = bitmap_mmap_size(deleted);
+            create_and_ensure_length(&deleted_filepath, deleted_size)?;
+        }
+
+        let deleted_mmap = open_write_mmap(&deleted_filepath)?;
+        let mut deleted_new = MmapBitSlice::try_from(deleted_mmap, 0)?;
+        deleted_new[..deleted.len()].copy_from_bitslice(deleted);
+        let deleted_wrapper = MmapBitSliceBufferedUpdateWrapper::new(deleted_new);
+
+        // Create mmap file for internal-to-version list
+        let version_filepath = Self::version_mapping_file_path(path);
+        {
+            let version_size = size_of_val(internal_to_version);
+            create_and_ensure_length(&version_filepath, version_size)?;
+        }
+        let mut internal_to_version_wrapper =
+            unsafe { MmapSlice::try_from(open_write_mmap(&version_filepath)?)? };
+        internal_to_version_wrapper.copy_from_slice(internal_to_version);
+        let internal_to_version = internal_to_version_wrapper.to_vec();
+        let internal_to_version_wrapper =
+            MmapSliceBufferedUpdateWrapper::new(internal_to_version_wrapper);
+
+        // Write mappings to disk.
+        let writer = BufWriter::new(File::create(Self::mappings_file_path(path))?);
+        mappings.store(writer)?;
+
+        Ok(Self {
+            path: path.to_path_buf(),
+            deleted: deleted.to_bitvec(),
+            deleted_wrapper,
+            internal_to_version_wrapper,
+            internal_to_version,
+            mappings,
+        })
+    }
+
+    fn deleted_file_path(base: &Path) -> PathBuf {
+        base.join(DELETED_FILE_NAME)
+    }
+
+    fn version_mapping_file_path(base: &Path) -> PathBuf {
+        base.join(VERSION_MAPPING_FILE_NAME)
+    }
+
+    pub(crate) fn mappings_file_path(base: &Path) -> PathBuf {
+        base.join(MAPPINGS_FILE_NAME)
+    }
+}
+
+/// Returns the required mmap filesize for a `BitSlice`.
+fn bitmap_mmap_size(deleted: &BitSlice) -> usize {
+    let usize_bytes = std::mem::size_of::<usize>();
+    let num_bytes = deleted.len().div_ceil(8); // used bytes
+    num_bytes.div_ceil(usize_bytes) * usize_bytes // Make it a multiple of usize-width.
+}
+
+impl IdTracker for ImmutableIdTracker {
+    fn internal_version(&self, internal_id: PointOffsetType) -> Option<SeqNumberType> {
+        self.internal_to_version.get(internal_id as usize).copied()
+    }
+
+    fn set_internal_version(
+        &mut self,
+        internal_id: PointOffsetType,
+        version: SeqNumberType,
+    ) -> OperationResult<()> {
+        if self.external_id(internal_id).is_some() {
+            if let Some(old_version) = self.internal_to_version.get_mut(internal_id as usize) {
+                *old_version = version;
+                self.internal_to_version_wrapper
+                    .set(internal_id as usize, version);
+            }
+        }
+
+        Ok(())
+    }
+
+    fn internal_id(&self, external_id: PointIdType) -> Option<PointOffsetType> {
+        match external_id {
+            PointIdType::NumId(num) => self.mappings.external_to_internal_num.get(&num).copied(),
+            PointIdType::Uuid(uuid) => self.mappings.external_to_internal_uuid.get(&uuid).copied(),
+        }
+    }
+
+    fn external_id(&self, internal_id: PointOffsetType) -> Option<PointIdType> {
+        if *self.deleted.get(internal_id as usize)? {
+            return None;
+        }
+
+        self.mappings
+            .internal_to_external
+            .get(internal_id as usize)
+            .map(|i| i.into())
+    }
+
+    fn set_link(
+        &mut self,
+        _external_id: PointIdType,
+        _internal_id: PointOffsetType,
+    ) -> OperationResult<()> {
+        panic!("Trying to call a mutating function (`set_link`) of an immutable id tracker");
+    }
+
+    fn drop(&mut self, external_id: PointIdType) -> OperationResult<()> {
+        let internal_id = match external_id {
+            // We "temporarily" remove existing points from the BTreeMaps without writing them to disk
+            // because we remove deleted points of a previous load directly when loading.
+            PointIdType::NumId(num) => self.mappings.external_to_internal_num.remove(&num),
+            PointIdType::Uuid(uuid) => self.mappings.external_to_internal_uuid.remove(&uuid),
+        };
+
+        if let Some(internal_id) = internal_id {
+            self.deleted.set(internal_id as usize, true);
+            self.deleted_wrapper.set(internal_id as usize, true);
+        }
+
+        Ok(())
+    }
+
+    fn iter_external(&self) -> Box<dyn Iterator<Item = PointIdType> + '_> {
+        let iter_num = self
+            .mappings
+            .external_to_internal_num
+            .keys()
+            .map(|i| PointIdType::NumId(*i));
+
+        let iter_uuid = self
+            .mappings
+            .external_to_internal_uuid
+            .keys()
+            .map(|i| PointIdType::Uuid(*i));
+        // order is important here, we want to iterate over the u64 ids first
+        Box::new(iter_num.chain(iter_uuid))
+    }
+
+    fn iter_internal(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
+        Box::new(
+            (0..self.mappings.internal_to_external.len() as PointOffsetType)
+                .filter(move |i| !self.deleted[*i as usize]),
+        )
+    }
+
+    fn iter_from(
+        &self,
+        external_id: Option<PointIdType>,
+    ) -> Box<dyn Iterator<Item = (PointIdType, PointOffsetType)> + '_> {
+        let full_num_iter = || {
+            self.mappings
+                .external_to_internal_num
+                .iter()
+                .map(|(k, v)| (PointIdType::NumId(*k), *v))
+        };
+        let offset_num_iter = |offset: u64| {
+            self.mappings
+                .external_to_internal_num
+                .range(offset..)
+                .map(|(k, v)| (PointIdType::NumId(*k), *v))
+        };
+        let full_uuid_iter = || {
+            self.mappings
+                .external_to_internal_uuid
+                .iter()
+                .map(|(k, v)| (PointIdType::Uuid(*k), *v))
+        };
+        let offset_uuid_iter = |offset: Uuid| {
+            self.mappings
+                .external_to_internal_uuid
+                .range(offset..)
+                .map(|(k, v)| (PointIdType::Uuid(*k), *v))
+        };
+
+        match external_id {
+            None => {
+                let iter_num = full_num_iter();
+                let iter_uuid = full_uuid_iter();
+                // order is important here, we want to iterate over the u64 ids first
+                Box::new(iter_num.chain(iter_uuid))
+            }
+            Some(offset) => match offset {
+                PointIdType::NumId(idx) => {
+                    // Because u64 keys are less that uuid key, we can just use the full iterator for uuid
+                    let iter_num = offset_num_iter(idx);
+                    let iter_uuid = full_uuid_iter();
+                    // order is important here, we want to iterate over the u64 ids first
+                    Box::new(iter_num.chain(iter_uuid))
+                }
+                PointIdType::Uuid(uuid) => {
+                    // if offset is a uuid, we can only iterate over uuids
+                    Box::new(offset_uuid_iter(uuid))
+                }
+            },
+        }
+    }
+
+    fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
+        self.iter_internal()
+    }
+
+    /// Creates a flusher function, that writes the deleted points bitvec to disk.
+    fn mapping_flusher(&self) -> Flusher {
+        // Only flush deletions because mappings are immutable
+        self.deleted_wrapper.flusher()
+    }
+
+    /// Creates a flusher function, that writes the points versions to disk.
+    fn versions_flusher(&self) -> Flusher {
+        self.internal_to_version_wrapper.flusher()
+    }
+
+    fn total_point_count(&self) -> usize {
+        self.mappings.internal_to_external.len()
+    }
+
+    fn available_point_count(&self) -> usize {
+        self.mappings.external_to_internal_num.len() + self.mappings.external_to_internal_uuid.len()
+    }
+
+    fn deleted_point_count(&self) -> usize {
+        self.total_point_count() - self.available_point_count()
+    }
+
+    fn deleted_point_bitslice(&self) -> &BitSlice {
+        &self.deleted
+    }
+
+    fn is_deleted_point(&self, key: PointOffsetType) -> bool {
+        let key = key as usize;
+        if key >= self.deleted.len() {
+            return true;
+        }
+        self.deleted[key]
+    }
+
+    fn name(&self) -> &'static str {
+        "immutable id tracker"
+    }
+
+    fn cleanup_versions(&mut self) -> OperationResult<()> {
+        let mut to_remove = Vec::new();
+        for internal_id in self.iter_internal() {
+            if self.internal_version(internal_id).is_none() {
+                if let Some(external_id) = self.external_id(internal_id) {
+                    to_remove.push(external_id);
+                } else {
+                    debug_assert!(false, "internal id {} has no external id", internal_id);
+                }
+            }
+        }
+        for external_id in to_remove {
+            self.drop(external_id)?;
+            #[cfg(debug_assertions)] // Only for dev builds
+            {
+                log::debug!("dropped version for point {} without version", external_id);
+            }
+        }
+        Ok(())
+    }
+
+    fn files(&self) -> Vec<PathBuf> {
+        vec![
+            Self::deleted_file_path(&self.path),
+            Self::mappings_file_path(&self.path),
+            Self::version_mapping_file_path(&self.path),
+        ]
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use std::collections::{HashMap, HashSet};
+
+    use itertools::Itertools;
+    use rand::prelude::*;
+    use rand::Rng;
+    use tempfile::Builder;
+
+    use super::*;
+    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+    use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
+    use crate::id_tracker::IdTrackerEnum;
+
+    const RAND_SEED: u64 = 42;
+
+    #[test]
+    fn test_iterator() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
+
+        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
+
+        id_tracker.set_link(200.into(), 0).unwrap();
+        id_tracker.set_link(100.into(), 1).unwrap();
+        id_tracker.set_link(150.into(), 2).unwrap();
+        id_tracker.set_link(120.into(), 3).unwrap();
+        id_tracker.set_link(180.into(), 4).unwrap();
+        id_tracker.set_link(110.into(), 5).unwrap();
+        id_tracker.set_link(115.into(), 6).unwrap();
+        id_tracker.set_link(190.into(), 7).unwrap();
+        id_tracker.set_link(177.into(), 8).unwrap();
+        id_tracker.set_link(118.into(), 9).unwrap();
+
+        let id_tracker = id_tracker.make_immutable(dir.path()).unwrap();
+
+        let first_four = id_tracker.iter_from(None).take(4).collect_vec();
+
+        assert_eq!(first_four.len(), 4);
+        assert_eq!(first_four[0].0, 100.into());
+
+        let last = id_tracker.iter_from(Some(first_four[3].0)).collect_vec();
+        assert_eq!(last.len(), 7);
+    }
+
+    const TEST_POINTS: &[PointIdType] = &[
+        PointIdType::NumId(100),
+        PointIdType::Uuid(Uuid::from_u128(123_u128)),
+        PointIdType::Uuid(Uuid::from_u128(156_u128)),
+        PointIdType::NumId(150),
+        PointIdType::NumId(120),
+        PointIdType::Uuid(Uuid::from_u128(12_u128)),
+        PointIdType::NumId(180),
+        PointIdType::NumId(110),
+        PointIdType::NumId(115),
+        PointIdType::Uuid(Uuid::from_u128(673_u128)),
+        PointIdType::NumId(190),
+        PointIdType::NumId(177),
+        PointIdType::Uuid(Uuid::from_u128(971_u128)),
+    ];
+
+    fn make_immutable_tracker(path: &Path) -> ImmutableIdTracker {
+        let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
+
+        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
+
+        for (id, value) in TEST_POINTS.iter().enumerate() {
+            id_tracker.set_link(*value, id as PointOffsetType).unwrap();
+        }
+
+        match id_tracker.make_immutable(path).unwrap() {
+            IdTrackerEnum::MutableIdTracker(_) => {
+                unreachable!()
+            }
+            IdTrackerEnum::ImmutableIdTracker(m) => {
+                m.mapping_flusher()().unwrap();
+                m.versions_flusher()().unwrap();
+                m
+            }
+        }
+    }
+
+    #[test]
+    fn test_mixed_types_iterator() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let id_tracker = make_immutable_tracker(dir.path());
+
+        let sorted_from_tracker = id_tracker.iter_from(None).map(|(k, _)| k).collect_vec();
+
+        let mut values = TEST_POINTS.to_vec();
+        values.sort();
+
+        assert_eq!(sorted_from_tracker, values);
+    }
+
+    #[test]
+    fn test_load_store() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let (old_deleted, old_mappings, old_versions) = {
+            let id_tracker = make_immutable_tracker(dir.path());
+            (
+                id_tracker.deleted.to_bitvec(),
+                id_tracker.mappings,
+                id_tracker.internal_to_version,
+            )
+        };
+
+        let mut loaded_id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
+
+        // We may extend the length of deleted bitvec as memory maps need to be aligned to
+        // a multiple of `usize-width`.
+        assert_eq!(old_deleted, loaded_id_tracker.deleted[..old_deleted.len()]);
+
+        assert_eq!(old_versions, loaded_id_tracker.internal_to_version);
+
+        assert_eq!(old_mappings, loaded_id_tracker.mappings);
+
+        loaded_id_tracker.drop(PointIdType::NumId(180)).unwrap();
+    }
+
+    /// Mutates an ID tracker and stores it to disk. Tests whether loading results in the exact same
+    /// ID tracker.
+    #[test]
+    fn test_store_load_mutated() {
+        let mut rng = StdRng::seed_from_u64(RAND_SEED);
+
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let (dropped_points, custom_version) = {
+            let mut id_tracker = make_immutable_tracker(dir.path());
+
+            let mut dropped_points = HashSet::new();
+            let mut custom_version = HashMap::new();
+
+            for (index, point) in TEST_POINTS.iter().enumerate() {
+                if index % 2 == 0 {
+                    continue;
+                }
+
+                if index % 3 == 0 {
+                    id_tracker.drop(*point).unwrap();
+                    dropped_points.insert(*point);
+                    continue;
+                }
+
+                if index % 5 == 0 {
+                    let new_version = rng.next_u64();
+                    id_tracker
+                        .set_internal_version(index as PointOffsetType, new_version)
+                        .unwrap();
+                    custom_version.insert(index as PointOffsetType, new_version);
+                }
+            }
+
+            id_tracker.mapping_flusher()().unwrap();
+            id_tracker.versions_flusher()().unwrap();
+
+            (dropped_points, custom_version)
+        };
+
+        let id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
+        for (index, point) in TEST_POINTS.iter().enumerate() {
+            let internal_id = index as PointOffsetType;
+
+            if dropped_points.contains(point) {
+                assert!(id_tracker.is_deleted_point(internal_id));
+                assert_eq!(id_tracker.external_id(internal_id), None);
+                match point {
+                    PointIdType::NumId(num) => {
+                        assert!(!id_tracker
+                            .mappings
+                            .external_to_internal_num
+                            .contains_key(num));
+                    }
+                    PointIdType::Uuid(uuid) => {
+                        assert!(!id_tracker
+                            .mappings
+                            .external_to_internal_uuid
+                            .contains_key(uuid));
+                    }
+                }
+
+                continue;
+            }
+
+            // Check version
+            let expect_version = custom_version.get(&internal_id).unwrap_or(&0);
+            assert_eq!(
+                id_tracker.internal_to_version.get(internal_id as usize),
+                Some(expect_version)
+            );
+
+            // Check that unmodified points still haven't changed.
+            assert_eq!(
+                id_tracker.external_id(index as PointOffsetType),
+                Some(*point)
+            );
+        }
+    }
+
+    #[test]
+    fn test_all_points_have_version() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let id_tracker = make_immutable_tracker(dir.path());
+        for i in id_tracker.iter_ids() {
+            assert!(id_tracker.internal_version(i).is_some());
+        }
+    }
+
+    #[test]
+    fn test_point_deletion_correctness() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let id_tracker = make_immutable_tracker(dir.path());
+        assert_point_deletion_correctness(IdTrackerEnum::ImmutableIdTracker(id_tracker));
+    }
+
+    fn assert_point_deletion_correctness(mut id_tracker: IdTrackerEnum) {
+        // No deletions yet
+        assert_eq!(
+            id_tracker.total_point_count(),
+            id_tracker.available_point_count()
+        );
+
+        let point_to_delete = PointIdType::NumId(100);
+
+        assert!(id_tracker.iter_external().contains(&point_to_delete));
+
+        assert_eq!(id_tracker.internal_id(point_to_delete), Some(0));
+
+        id_tracker.drop(point_to_delete).unwrap();
+
+        assert!(!point_exists(&id_tracker, point_to_delete));
+
+        assert_eq!(
+            id_tracker.available_point_count(),
+            id_tracker.total_point_count() - 1
+        );
+    }
+
+    fn point_exists(id_tracker: &IdTrackerEnum, point: PointIdType) -> bool {
+        id_tracker.internal_id(point).is_some()
+            && id_tracker.iter_external().contains(&point)
+            && id_tracker.iter_from(None).any(|i| i.0 == point)
+    }
+
+    #[test]
+    fn test_point_deletion_persists_reload() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let point_to_delete = PointIdType::NumId(100);
+
+        let old_mappings = {
+            let mut id_tracker = make_immutable_tracker(dir.path());
+            let intetrnal_id = id_tracker
+                .internal_id(point_to_delete)
+                .expect("Point to delete exists.");
+            assert!(!id_tracker.is_deleted_point(intetrnal_id));
+            id_tracker.drop(point_to_delete).unwrap();
+            id_tracker.versions_flusher()().unwrap();
+            id_tracker.mapping_flusher()().unwrap();
+            id_tracker.mappings
+        };
+
+        // Point should still be gone
+        let id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
+        assert_eq!(id_tracker.internal_id(point_to_delete), None);
+
+        // Old mappings should be the same as newly loaded one.
+        assert_eq!(
+            old_mappings.external_to_internal_num,
+            id_tracker.mappings.external_to_internal_num
+        );
+    }
+
+    fn gen_random_point_mappings(size: usize, rand: &mut StdRng) -> PointMappings {
+        const UUID_LIKELYNESS: f64 = 0.5;
+
+        let mut external_to_internal_num = BTreeMap::new();
+        let mut external_to_internal_uuid = BTreeMap::new();
+
+        let internal_to_external = (0..size)
+            .map(|_| {
+                if rand.gen_bool(UUID_LIKELYNESS) {
+                    PointIdType::Uuid(Uuid::new_v4())
+                } else {
+                    PointIdType::NumId(rand.next_u64())
+                }
+            })
+            .enumerate()
+            .inspect(|(pos, point_type)| match point_type {
+                ExtendedPointId::NumId(num) => {
+                    external_to_internal_num.insert(*num, *pos as u32);
+                }
+                ExtendedPointId::Uuid(uuid) => {
+                    external_to_internal_uuid.insert(*uuid, *pos as u32);
+                }
+            })
+            .map(|i| i.1)
+            .collect();
+
+        PointMappings {
+            internal_to_external,
+            external_to_internal_num,
+            external_to_internal_uuid,
+        }
+    }
+
+    /// Tests de/serializing of whole `PointMappings`.
+    #[test]
+    fn test_point_mappings_de_serialization() {
+        let mut rng = StdRng::seed_from_u64(RAND_SEED);
+
+        let mut buf = vec![];
+
+        // Test different sized PointMappings, growing exponentially to also test large ones.
+        // This way we test up to 2^22=4_194_304 points.
+        for size_exp in (0..23u32).step_by(3) {
+            buf.clear();
+
+            let size = 2usize.pow(size_exp);
+
+            let mappings = gen_random_point_mappings(size, &mut rng);
+
+            mappings.store(&mut buf).unwrap();
+
+            // 16 is the min byte size of an entry. The exact number is not that important
+            // we just want to ensure that the written bytes correlate to the amount of entries.
+            assert!(buf.len() >= size * 16);
+
+            let new_mappings = PointMappings::load(&*buf, None).unwrap();
+
+            assert_eq!(new_mappings.internal_to_external.len(), size);
+            assert_eq!(mappings, new_mappings);
+        }
+    }
+
+    /// Verifies that de/serializing works properly for empty `PointMappings`.
+    #[test]
+    fn test_point_mappings_de_serialization_empty() {
+        let mut rng = StdRng::seed_from_u64(RAND_SEED);
+        let mappings = gen_random_point_mappings(0, &mut rng);
+
+        let mut buf = vec![];
+
+        mappings.store(&mut buf).unwrap();
+
+        // We still have a header!
+        assert!(!buf.is_empty());
+
+        let new_mappings = PointMappings::load(&*buf, None).unwrap();
+
+        assert!(new_mappings.internal_to_external.is_empty());
+        assert_eq!(mappings, new_mappings);
+    }
+
+    /// Tests de/serializing of only single ID mappings.
+    #[test]
+    fn test_point_mappings_de_serialization_single() {
+        let mut rng = StdRng::seed_from_u64(RAND_SEED);
+
+        const SIZE: usize = 400_000;
+
+        let mappings = gen_random_point_mappings(SIZE, &mut rng);
+
+        for i in 0..SIZE {
+            let mut buf = vec![];
+
+            let expected_external = mappings.internal_to_external[i];
+
+            mappings.write_entry(&mut buf, &expected_external).unwrap();
+
+            let (got_internal, got_external) = PointMappings::read_entry(&*buf).unwrap();
+
+            assert_eq!(i as PointOffsetType, got_internal);
+            assert_eq!(expected_external, got_external);
+        }
+    }
+}

commit 961984c881e571f62413b6ad1507278a8a8adc76
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Thu Jul 18 15:45:11 2024 -0400

    implement iter_random for immutable_id_tracker (#4700)

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 26342535c..9b78793b2 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -3,6 +3,7 @@
 use std::collections::BTreeMap;
 use std::fs::File;
 use std::io::{BufReader, BufWriter, Read, Write};
+use std::iter;
 use std::mem::size_of_val;
 use std::path::{Path, PathBuf};
 
@@ -10,7 +11,9 @@ use bitvec::prelude::BitSlice;
 use bitvec::vec::BitVec;
 use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
 use common::types::PointOffsetType;
+use itertools::Itertools;
 use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
+use rand::distributions::Distribution;
 use uuid::Uuid;
 
 use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
@@ -432,6 +435,31 @@ impl IdTracker for ImmutableIdTracker {
         self.iter_internal()
     }
 
+    fn iter_random(&self) -> Box<dyn Iterator<Item = (PointIdType, PointOffsetType)> + '_> {
+        let rng = rand::thread_rng();
+        let max_internal = self.mappings.internal_to_external.len();
+        if max_internal == 0 {
+            return Box::new(iter::empty());
+        }
+        let uniform = rand::distributions::Uniform::new(0, max_internal);
+        let iter = Distribution::sample_iter(uniform, rng)
+            // TODO: this is not efficient if `max_internal` is large and we iterate over most of them,
+            // but it's good enough for low limits.
+            //
+            // We could improve it by using a variable-period PRNG to adjust depending on the number of available points.
+            .unique()
+            .take(max_internal)
+            .filter_map(move |i| {
+                if self.deleted[i] {
+                    None
+                } else {
+                    Some((self.mappings.internal_to_external[i], i as PointOffsetType))
+                }
+            });
+
+        Box::new(iter)
+    }
+
     /// Creates a flusher function, that writes the deleted points bitvec to disk.
     fn mapping_flusher(&self) -> Flusher {
         // Only flush deletions because mappings are immutable

commit e6a2817683e862ba594da4db1134dcf25fe91762
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 19 21:58:32 2024 +0200

    In memory IdTracker (#4658)
    
    * add in_memory_id_tracker
    
    * add ImmutableIdTracker to IdTrackerEnum
    
    * improve in in_memory_id_tracker
    
    * Add benchmark and revert changes
    
    * fix not compiling
    
    * rebase to dev
    
    * Minor ImmutableIdTracker improvements (#4698)
    
    * remove unnecessary allocation + add minor improvements
    
    * fix import
    
    * refactor points_mapping to share function between immutable & in_memory id trackers
    
    * test and fix for version persistence;
    
    * fmt
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 9b78793b2..af054e506 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -1,19 +1,14 @@
-// TODO: Remove when we release the next version and integrate the immutable id tracker
-#![allow(dead_code)]
 use std::collections::BTreeMap;
 use std::fs::File;
 use std::io::{BufReader, BufWriter, Read, Write};
-use std::iter;
-use std::mem::size_of_val;
+use std::mem::{size_of, size_of_val};
 use std::path::{Path, PathBuf};
 
 use bitvec::prelude::BitSlice;
 use bitvec::vec::BitVec;
-use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
+use byteorder::{ReadBytesExt, WriteBytesExt};
 use common::types::PointOffsetType;
-use itertools::Itertools;
 use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
-use rand::distributions::Distribution;
 use uuid::Uuid;
 
 use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
@@ -21,6 +16,8 @@ use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWr
 use crate::common::mmap_type::{MmapBitSlice, MmapSlice};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
+use crate::id_tracker::point_mappings::{FileEndianess, PointMappings};
 use crate::id_tracker::IdTracker;
 use crate::types::{ExtendedPointId, PointIdType, SeqNumberType};
 
@@ -28,11 +25,42 @@ pub const DELETED_FILE_NAME: &str = "id_tracker.deleted";
 pub const MAPPINGS_FILE_NAME: &str = "id_tracker.mappings";
 pub const VERSION_MAPPING_FILE_NAME: &str = "id_tracker.versions";
 
+const EXTERNAL_ID_NUMBER_BYTE: u8 = 0;
+const EXTERNAL_ID_UUID_BYTE: u8 = 1;
+
+enum ExternalIdType {
+    Number,
+    Uuid,
+}
+
+impl ExternalIdType {
+    fn from_byte(byte: u8) -> Option<Self> {
+        match byte {
+            EXTERNAL_ID_NUMBER_BYTE => Some(Self::Number),
+            EXTERNAL_ID_UUID_BYTE => Some(Self::Uuid),
+            _ => None,
+        }
+    }
+
+    fn to_byte(&self) -> u8 {
+        match self {
+            Self::Number => EXTERNAL_ID_NUMBER_BYTE,
+            Self::Uuid => EXTERNAL_ID_UUID_BYTE,
+        }
+    }
+
+    fn from_point_id(point_id: &PointIdType) -> Self {
+        match point_id {
+            PointIdType::NumId(_) => Self::Number,
+            PointIdType::Uuid(_) => Self::Uuid,
+        }
+    }
+}
+
 #[derive(Debug)]
 pub struct ImmutableIdTracker {
     path: PathBuf,
 
-    deleted: BitVec,
     deleted_wrapper: MmapBitSliceBufferedUpdateWrapper,
 
     internal_to_version: Vec<SeqNumberType>,
@@ -41,28 +69,31 @@ pub struct ImmutableIdTracker {
     mappings: PointMappings,
 }
 
-#[derive(Clone, PartialEq, Debug)]
-pub struct PointMappings {
-    pub(crate) internal_to_external: Vec<PointIdType>,
-
-    // Having two separate maps allows us iterating only over one type at a time without having to filter.
-    pub(crate) external_to_internal_num: BTreeMap<u64, PointOffsetType>,
-    pub(crate) external_to_internal_uuid: BTreeMap<Uuid, PointOffsetType>,
-}
+impl ImmutableIdTracker {
+    pub fn from_in_memory_tracker(
+        in_memory_tracker: InMemoryIdTracker,
+        path: &Path,
+    ) -> OperationResult<Self> {
+        let (internal_to_version, mappings) = in_memory_tracker.into_internal();
 
-/// Used endianness for storing PointMapping-files.
-type FileEndianess = LittleEndian;
+        let id_tracker = Self::new(path, &internal_to_version, mappings)?;
 
-impl PointMappings {
-    const EXTERNAL_ID_NUMBER_BYTE: u8 = 0;
-    const EXTERNAL_ID_UUID_BYTE: u8 = 1;
+        Ok(id_tracker)
+    }
 
     /// Loads a `PointMappings` from the given reader. Applies an optional filter of deleted items
     /// to prevent allocating unneeded data.
-    pub fn load<R: Read>(mut reader: R, filter: Option<&BitSlice>) -> OperationResult<Self> {
+    fn load_mapping<R: Read>(
+        mut reader: R,
+        deleted: Option<BitVec>,
+    ) -> OperationResult<PointMappings> {
         // Deserialize the header
         let len = reader.read_u64::<FileEndianess>()? as usize;
 
+        let mut deleted = deleted.unwrap_or_else(|| BitVec::repeat(false, len));
+
+        deleted.truncate(len);
+
         let mut internal_to_external = Vec::with_capacity(len);
         let mut external_to_internal_num: BTreeMap<u64, PointOffsetType> = BTreeMap::new();
         let mut external_to_internal_uuid: BTreeMap<Uuid, PointOffsetType> = BTreeMap::new();
@@ -73,14 +104,15 @@ impl PointMappings {
 
             // Need to push this regardless of point deletion as the vecs index represents the internal id
             // which would become wrong if we leave out entries.
-            internal_to_external.push(external_id);
+            if internal_to_external.len() <= internal_id as usize {
+                internal_to_external.resize(internal_id as usize + 1, PointIdType::NumId(0));
+            }
 
-            let deleted = filter
-                .as_ref()
-                .and_then(|deleted| deleted.get(i).as_deref().copied())
-                .unwrap_or_default();
+            internal_to_external[internal_id as usize] = external_id;
 
-            if deleted {
+            let point_deleted = deleted.get(i).as_deref().copied().unwrap_or(false);
+
+            if point_deleted {
                 continue;
             }
 
@@ -97,37 +129,41 @@ impl PointMappings {
         // Check that the file has ben fully read.
         #[cfg(debug_assertions)] // Only for dev builds
         {
-            let mut buf = vec![];
-            let read_bytes = reader.read_to_end(&mut buf).unwrap();
-            assert_eq!(buf.len(), 0);
-            assert_eq!(read_bytes, 0);
+            debug_assert_eq!(reader.bytes().map(Result::unwrap).count(), 0,);
         }
 
-        Ok(PointMappings {
+        Ok(PointMappings::new(
+            deleted,
             internal_to_external,
             external_to_internal_num,
             external_to_internal_uuid,
-        })
+        ))
     }
 
     /// Loads a single entry from a reader. Expects the reader to be aligned so, that the next read
     /// byte is the first byte of a new entry.
     /// This function reads exact one entry which means after calling this function, the reader
     /// will be at the start of the next entry.
-    fn read_entry<R: Read>(mut reader: R) -> OperationResult<(PointOffsetType, ExtendedPointId)> {
+    pub(crate) fn read_entry<R: Read>(
+        mut reader: R,
+    ) -> OperationResult<(PointOffsetType, ExtendedPointId)> {
         let point_id_type = reader.read_u8()?;
 
-        let external_id = if point_id_type == Self::EXTERNAL_ID_NUMBER_BYTE {
-            let num = reader.read_u64::<FileEndianess>()?;
-            PointIdType::NumId(num)
-        } else if point_id_type == Self::EXTERNAL_ID_UUID_BYTE {
-            let uuid_u128 = reader.read_u128::<FileEndianess>()?;
-            PointIdType::Uuid(Uuid::from_u128_le(uuid_u128))
-        } else {
-            return Err(OperationError::InconsistentStorage {
-                description: "Invalid byte read when deserializing Immutable id tracker"
-                    .to_string(),
-            });
+        let external_id = match ExternalIdType::from_byte(point_id_type) {
+            None => {
+                return Err(OperationError::InconsistentStorage {
+                    description: "Invalid byte read when deserializing Immutable id tracker"
+                        .to_string(),
+                })
+            }
+            Some(ExternalIdType::Number) => {
+                let num = reader.read_u64::<FileEndianess>()?;
+                PointIdType::NumId(num)
+            }
+            Some(ExternalIdType::Uuid) => {
+                let uuid_u128 = reader.read_u128::<FileEndianess>()?;
+                PointIdType::Uuid(Uuid::from_u128_le(uuid_u128))
+            }
         };
 
         let internal_id = reader.read_u32::<FileEndianess>()? as PointOffsetType;
@@ -149,13 +185,15 @@ impl PointMappings {
     /// A single entry is thus either 1+8+4=13 or 1+16+4=21 bytes in size depending
     /// on the PointIdType.
 
-    pub fn store<W: Write>(&self, mut writer: W) -> OperationResult<()> {
+    fn store_mapping<W: Write>(mappings: &PointMappings, mut writer: W) -> OperationResult<()> {
+        let number_of_entries = mappings.total_point_count();
+
         // Serialize the header (=length).
-        writer.write_u64::<FileEndianess>(self.internal_to_external.len() as u64)?;
+        writer.write_u64::<FileEndianess>(number_of_entries as u64)?;
 
         // Serialize all entries
-        for external_id in self.internal_to_external.iter() {
-            self.write_entry(&mut writer, external_id)?;
+        for (internal_id, external_id) in mappings.iter_internal_raw() {
+            Self::write_entry(&mut writer, internal_id, external_id)?;
         }
 
         writer.flush()?;
@@ -163,44 +201,31 @@ impl PointMappings {
     }
 
     fn write_entry<W: Write>(
-        &self,
         mut writer: W,
-        external_id: &PointIdType,
+        internal_id: PointOffsetType,
+        external_id: PointIdType,
     ) -> OperationResult<()> {
+        // Byte to distinguish between Number and UUID
+        writer.write_u8(ExternalIdType::from_point_id(&external_id).to_byte())?;
+
         // Serializing External ID
         match external_id {
             PointIdType::NumId(num) => {
-                // Byte to distinguish between Number and UUID
-                writer.write_u8(Self::EXTERNAL_ID_NUMBER_BYTE)?;
-
                 // The PointID's number
-                writer.write_u64::<FileEndianess>(*num)?;
+                writer.write_u64::<FileEndianess>(num)?;
             }
             PointIdType::Uuid(uuid) => {
-                // Byte to distinguish between Number and UUID
-                writer.write_u8(Self::EXTERNAL_ID_UUID_BYTE)?;
-
                 // The PointID's UUID
                 writer.write_u128::<FileEndianess>(uuid.to_u128_le())?;
             }
         }
 
-        let internal_id = match external_id {
-            PointIdType::NumId(n) => self.external_to_internal_num.get(n),
-            PointIdType::Uuid(u) => self.external_to_internal_uuid.get(u),
-        }
-        .ok_or(OperationError::PointIdError {
-            missed_point_id: *external_id,
-        })?;
-
         // Serializing Internal ID
-        writer.write_u32::<FileEndianess>(*internal_id)?;
+        writer.write_u32::<FileEndianess>(internal_id)?;
 
         Ok(())
     }
-}
 
-impl ImmutableIdTracker {
     pub fn open(segment_path: &Path) -> OperationResult<Self> {
         let deleted_raw = open_write_mmap(&Self::deleted_file_path(segment_path))?;
         let deleted_mmap = MmapBitSlice::try_from(deleted_raw, 0)?;
@@ -216,11 +241,10 @@ impl ImmutableIdTracker {
             MmapSliceBufferedUpdateWrapper::new(internal_to_version_mapslice);
 
         let reader = BufReader::new(File::open(Self::mappings_file_path(segment_path))?);
-        let mappings = PointMappings::load(reader, Some(&deleted_bitvec))?;
+        let mappings = Self::load_mapping(reader, Some(deleted_bitvec))?;
 
         Ok(Self {
             path: segment_path.to_path_buf(),
-            deleted: deleted_bitvec,
             deleted_wrapper,
             internal_to_version_wrapper,
             internal_to_version,
@@ -230,42 +254,64 @@ impl ImmutableIdTracker {
 
     pub(super) fn new(
         path: &Path,
-        deleted: &BitSlice,
         internal_to_version: &[SeqNumberType],
         mappings: PointMappings,
     ) -> OperationResult<Self> {
         // Create mmap file for deleted bitvec
         let deleted_filepath = Self::deleted_file_path(path);
         {
-            let deleted_size = bitmap_mmap_size(deleted);
+            let deleted_size = bitmap_mmap_size(mappings.total_point_count());
             create_and_ensure_length(&deleted_filepath, deleted_size)?;
         }
 
+        debug_assert!(mappings.deleted().len() <= mappings.total_point_count());
+
         let deleted_mmap = open_write_mmap(&deleted_filepath)?;
         let mut deleted_new = MmapBitSlice::try_from(deleted_mmap, 0)?;
-        deleted_new[..deleted.len()].copy_from_bitslice(deleted);
+        deleted_new[..mappings.deleted().len()].copy_from_bitslice(mappings.deleted());
+
+        for i in mappings.deleted().len()..mappings.total_point_count() {
+            deleted_new.set(i, true);
+        }
+
         let deleted_wrapper = MmapBitSliceBufferedUpdateWrapper::new(deleted_new);
 
         // Create mmap file for internal-to-version list
         let version_filepath = Self::version_mapping_file_path(path);
+
+        // Amount of points without version
+        let missing_version_count = mappings
+            .total_point_count()
+            .saturating_sub(internal_to_version.len());
+
+        let missing_versions_size = missing_version_count * size_of::<SeqNumberType>();
+        let internal_to_version_size = size_of_val(internal_to_version);
+        let min_size = internal_to_version_size + missing_versions_size;
         {
-            let version_size = size_of_val(internal_to_version);
+            let version_size = mmap_size::<SeqNumberType>(min_size);
             create_and_ensure_length(&version_filepath, version_size)?;
         }
         let mut internal_to_version_wrapper =
             unsafe { MmapSlice::try_from(open_write_mmap(&version_filepath)?)? };
-        internal_to_version_wrapper.copy_from_slice(internal_to_version);
+
+        internal_to_version_wrapper[..internal_to_version.len()]
+            .copy_from_slice(internal_to_version);
         let internal_to_version = internal_to_version_wrapper.to_vec();
+
+        debug_assert_eq!(internal_to_version.len(), mappings.total_point_count());
+
         let internal_to_version_wrapper =
             MmapSliceBufferedUpdateWrapper::new(internal_to_version_wrapper);
 
         // Write mappings to disk.
         let writer = BufWriter::new(File::create(Self::mappings_file_path(path))?);
-        mappings.store(writer)?;
+        Self::store_mapping(&mappings, writer)?;
+
+        deleted_wrapper.flusher()()?;
+        internal_to_version_wrapper.flusher()()?;
 
         Ok(Self {
             path: path.to_path_buf(),
-            deleted: deleted.to_bitvec(),
             deleted_wrapper,
             internal_to_version_wrapper,
             internal_to_version,
@@ -286,11 +332,16 @@ impl ImmutableIdTracker {
     }
 }
 
+/// Returns the required mmap filesize for a given length of a slice of type `T`.
+fn mmap_size<T>(len: usize) -> usize {
+    let item_width = size_of::<T>();
+    len.div_ceil(item_width) * item_width // Make it a multiple of usize-width.
+}
+
 /// Returns the required mmap filesize for a `BitSlice`.
-fn bitmap_mmap_size(deleted: &BitSlice) -> usize {
-    let usize_bytes = std::mem::size_of::<usize>();
-    let num_bytes = deleted.len().div_ceil(8); // used bytes
-    num_bytes.div_ceil(usize_bytes) * usize_bytes // Make it a multiple of usize-width.
+fn bitmap_mmap_size(number_of_elements: usize) -> usize {
+    const BITS_TO_BYTES: usize = 8; // .len() returns bits but we want bytes!
+    mmap_size::<usize>(number_of_elements.div_ceil(BITS_TO_BYTES))
 }
 
 impl IdTracker for ImmutableIdTracker {
@@ -304,7 +355,12 @@ impl IdTracker for ImmutableIdTracker {
         version: SeqNumberType,
     ) -> OperationResult<()> {
         if self.external_id(internal_id).is_some() {
-            if let Some(old_version) = self.internal_to_version.get_mut(internal_id as usize) {
+            let old_version = self.internal_to_version.get_mut(internal_id as usize);
+            debug_assert!(
+                old_version.is_some(),
+                "Can't extend version list in immutable tracker"
+            );
+            if let Some(old_version) = old_version {
                 *old_version = version;
                 self.internal_to_version_wrapper
                     .set(internal_id as usize, version);
@@ -315,21 +371,11 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn internal_id(&self, external_id: PointIdType) -> Option<PointOffsetType> {
-        match external_id {
-            PointIdType::NumId(num) => self.mappings.external_to_internal_num.get(&num).copied(),
-            PointIdType::Uuid(uuid) => self.mappings.external_to_internal_uuid.get(&uuid).copied(),
-        }
+        self.mappings.internal_id(&external_id)
     }
 
     fn external_id(&self, internal_id: PointOffsetType) -> Option<PointIdType> {
-        if *self.deleted.get(internal_id as usize)? {
-            return None;
-        }
-
-        self.mappings
-            .internal_to_external
-            .get(internal_id as usize)
-            .map(|i| i.into())
+        self.mappings.external_id(internal_id)
     }
 
     fn set_link(
@@ -341,15 +387,9 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn drop(&mut self, external_id: PointIdType) -> OperationResult<()> {
-        let internal_id = match external_id {
-            // We "temporarily" remove existing points from the BTreeMaps without writing them to disk
-            // because we remove deleted points of a previous load directly when loading.
-            PointIdType::NumId(num) => self.mappings.external_to_internal_num.remove(&num),
-            PointIdType::Uuid(uuid) => self.mappings.external_to_internal_uuid.remove(&uuid),
-        };
+        let internal_id = self.mappings.drop(external_id);
 
         if let Some(internal_id) = internal_id {
-            self.deleted.set(internal_id as usize, true);
             self.deleted_wrapper.set(internal_id as usize, true);
         }
 
@@ -357,78 +397,18 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn iter_external(&self) -> Box<dyn Iterator<Item = PointIdType> + '_> {
-        let iter_num = self
-            .mappings
-            .external_to_internal_num
-            .keys()
-            .map(|i| PointIdType::NumId(*i));
-
-        let iter_uuid = self
-            .mappings
-            .external_to_internal_uuid
-            .keys()
-            .map(|i| PointIdType::Uuid(*i));
-        // order is important here, we want to iterate over the u64 ids first
-        Box::new(iter_num.chain(iter_uuid))
+        self.mappings.iter_external()
     }
 
     fn iter_internal(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
-        Box::new(
-            (0..self.mappings.internal_to_external.len() as PointOffsetType)
-                .filter(move |i| !self.deleted[*i as usize]),
-        )
+        self.mappings.iter_internal()
     }
 
     fn iter_from(
         &self,
         external_id: Option<PointIdType>,
     ) -> Box<dyn Iterator<Item = (PointIdType, PointOffsetType)> + '_> {
-        let full_num_iter = || {
-            self.mappings
-                .external_to_internal_num
-                .iter()
-                .map(|(k, v)| (PointIdType::NumId(*k), *v))
-        };
-        let offset_num_iter = |offset: u64| {
-            self.mappings
-                .external_to_internal_num
-                .range(offset..)
-                .map(|(k, v)| (PointIdType::NumId(*k), *v))
-        };
-        let full_uuid_iter = || {
-            self.mappings
-                .external_to_internal_uuid
-                .iter()
-                .map(|(k, v)| (PointIdType::Uuid(*k), *v))
-        };
-        let offset_uuid_iter = |offset: Uuid| {
-            self.mappings
-                .external_to_internal_uuid
-                .range(offset..)
-                .map(|(k, v)| (PointIdType::Uuid(*k), *v))
-        };
-
-        match external_id {
-            None => {
-                let iter_num = full_num_iter();
-                let iter_uuid = full_uuid_iter();
-                // order is important here, we want to iterate over the u64 ids first
-                Box::new(iter_num.chain(iter_uuid))
-            }
-            Some(offset) => match offset {
-                PointIdType::NumId(idx) => {
-                    // Because u64 keys are less that uuid key, we can just use the full iterator for uuid
-                    let iter_num = offset_num_iter(idx);
-                    let iter_uuid = full_uuid_iter();
-                    // order is important here, we want to iterate over the u64 ids first
-                    Box::new(iter_num.chain(iter_uuid))
-                }
-                PointIdType::Uuid(uuid) => {
-                    // if offset is a uuid, we can only iterate over uuids
-                    Box::new(offset_uuid_iter(uuid))
-                }
-            },
-        }
+        self.mappings.iter_from(external_id)
     }
 
     fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
@@ -436,28 +416,7 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn iter_random(&self) -> Box<dyn Iterator<Item = (PointIdType, PointOffsetType)> + '_> {
-        let rng = rand::thread_rng();
-        let max_internal = self.mappings.internal_to_external.len();
-        if max_internal == 0 {
-            return Box::new(iter::empty());
-        }
-        let uniform = rand::distributions::Uniform::new(0, max_internal);
-        let iter = Distribution::sample_iter(uniform, rng)
-            // TODO: this is not efficient if `max_internal` is large and we iterate over most of them,
-            // but it's good enough for low limits.
-            //
-            // We could improve it by using a variable-period PRNG to adjust depending on the number of available points.
-            .unique()
-            .take(max_internal)
-            .filter_map(move |i| {
-                if self.deleted[i] {
-                    None
-                } else {
-                    Some((self.mappings.internal_to_external[i], i as PointOffsetType))
-                }
-            });
-
-        Box::new(iter)
+        self.mappings.iter_random()
     }
 
     /// Creates a flusher function, that writes the deleted points bitvec to disk.
@@ -472,11 +431,11 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn total_point_count(&self) -> usize {
-        self.mappings.internal_to_external.len()
+        self.mappings.total_point_count()
     }
 
     fn available_point_count(&self) -> usize {
-        self.mappings.external_to_internal_num.len() + self.mappings.external_to_internal_uuid.len()
+        self.mappings.available_point_count()
     }
 
     fn deleted_point_count(&self) -> usize {
@@ -484,15 +443,11 @@ impl IdTracker for ImmutableIdTracker {
     }
 
     fn deleted_point_bitslice(&self) -> &BitSlice {
-        &self.deleted
+        self.mappings.deleted()
     }
 
     fn is_deleted_point(&self, key: PointOffsetType) -> bool {
-        let key = key as usize;
-        if key >= self.deleted.len() {
-            return true;
-        }
-        self.deleted[key]
+        self.mappings.is_deleted_point(key)
     }
 
     fn name(&self) -> &'static str {
@@ -530,27 +485,26 @@ impl IdTracker for ImmutableIdTracker {
 }
 
 #[cfg(test)]
-mod test {
+pub(super) mod test {
     use std::collections::{HashMap, HashSet};
 
     use itertools::Itertools;
     use rand::prelude::*;
     use rand::Rng;
     use tempfile::Builder;
+    use uuid::Uuid;
 
     use super::*;
     use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
-    use crate::id_tracker::IdTrackerEnum;
 
     const RAND_SEED: u64 = 42;
 
     #[test]
     fn test_iterator() {
         let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-        let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
 
-        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
+        let mut id_tracker = InMemoryIdTracker::new();
 
         id_tracker.set_link(200.into(), 0).unwrap();
         id_tracker.set_link(100.into(), 1).unwrap();
@@ -563,7 +517,8 @@ mod test {
         id_tracker.set_link(177.into(), 8).unwrap();
         id_tracker.set_link(118.into(), 9).unwrap();
 
-        let id_tracker = id_tracker.make_immutable(dir.path()).unwrap();
+        let id_tracker =
+            ImmutableIdTracker::from_in_memory_tracker(id_tracker, dir.path()).unwrap();
 
         let first_four = id_tracker.iter_from(None).take(4).collect_vec();
 
@@ -574,7 +529,7 @@ mod test {
         assert_eq!(last.len(), 7);
     }
 
-    const TEST_POINTS: &[PointIdType] = &[
+    pub const TEST_POINTS: &[PointIdType] = &[
         PointIdType::NumId(100),
         PointIdType::Uuid(Uuid::from_u128(123_u128)),
         PointIdType::Uuid(Uuid::from_u128(156_u128)),
@@ -590,27 +545,6 @@ mod test {
         PointIdType::Uuid(Uuid::from_u128(971_u128)),
     ];
 
-    fn make_immutable_tracker(path: &Path) -> ImmutableIdTracker {
-        let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
-
-        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
-
-        for (id, value) in TEST_POINTS.iter().enumerate() {
-            id_tracker.set_link(*value, id as PointOffsetType).unwrap();
-        }
-
-        match id_tracker.make_immutable(path).unwrap() {
-            IdTrackerEnum::MutableIdTracker(_) => {
-                unreachable!()
-            }
-            IdTrackerEnum::ImmutableIdTracker(m) => {
-                m.mapping_flusher()().unwrap();
-                m.versions_flusher()().unwrap();
-                m
-            }
-        }
-    }
-
     #[test]
     fn test_mixed_types_iterator() {
         let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
@@ -627,21 +561,15 @@ mod test {
     #[test]
     fn test_load_store() {
         let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-        let (old_deleted, old_mappings, old_versions) = {
+        let (old_mappings, old_versions) = {
             let id_tracker = make_immutable_tracker(dir.path());
-            (
-                id_tracker.deleted.to_bitvec(),
-                id_tracker.mappings,
-                id_tracker.internal_to_version,
-            )
+            (id_tracker.mappings, id_tracker.internal_to_version)
         };
 
         let mut loaded_id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
 
         // We may extend the length of deleted bitvec as memory maps need to be aligned to
         // a multiple of `usize-width`.
-        assert_eq!(old_deleted, loaded_id_tracker.deleted[..old_deleted.len()]);
-
         assert_eq!(old_versions, loaded_id_tracker.internal_to_version);
 
         assert_eq!(old_mappings, loaded_id_tracker.mappings);
@@ -695,26 +623,14 @@ mod test {
             if dropped_points.contains(point) {
                 assert!(id_tracker.is_deleted_point(internal_id));
                 assert_eq!(id_tracker.external_id(internal_id), None);
-                match point {
-                    PointIdType::NumId(num) => {
-                        assert!(!id_tracker
-                            .mappings
-                            .external_to_internal_num
-                            .contains_key(num));
-                    }
-                    PointIdType::Uuid(uuid) => {
-                        assert!(!id_tracker
-                            .mappings
-                            .external_to_internal_uuid
-                            .contains_key(uuid));
-                    }
-                }
+                assert!(id_tracker.mappings.internal_id(point).is_none());
 
                 continue;
             }
 
             // Check version
-            let expect_version = custom_version.get(&internal_id).unwrap_or(&0);
+            let expect_version = custom_version.get(&internal_id).unwrap_or(&DEFAULT_VERSION);
+
             assert_eq!(
                 id_tracker.internal_to_version.get(internal_id as usize),
                 Some(expect_version)
@@ -740,16 +656,9 @@ mod test {
     #[test]
     fn test_point_deletion_correctness() {
         let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-        let id_tracker = make_immutable_tracker(dir.path());
-        assert_point_deletion_correctness(IdTrackerEnum::ImmutableIdTracker(id_tracker));
-    }
+        let mut id_tracker = make_immutable_tracker(dir.path());
 
-    fn assert_point_deletion_correctness(mut id_tracker: IdTrackerEnum) {
-        // No deletions yet
-        assert_eq!(
-            id_tracker.total_point_count(),
-            id_tracker.available_point_count()
-        );
+        let deleted_points = id_tracker.total_point_count() - id_tracker.available_point_count();
 
         let point_to_delete = PointIdType::NumId(100);
 
@@ -759,18 +668,16 @@ mod test {
 
         id_tracker.drop(point_to_delete).unwrap();
 
-        assert!(!point_exists(&id_tracker, point_to_delete));
+        let point_exists = id_tracker.internal_id(point_to_delete).is_some()
+            && id_tracker.iter_external().contains(&point_to_delete)
+            && id_tracker.iter_from(None).any(|i| i.0 == point_to_delete);
 
-        assert_eq!(
-            id_tracker.available_point_count(),
-            id_tracker.total_point_count() - 1
-        );
-    }
+        assert!(!point_exists);
+
+        let new_deleted_points =
+            id_tracker.total_point_count() - id_tracker.available_point_count();
 
-    fn point_exists(id_tracker: &IdTrackerEnum, point: PointIdType) -> bool {
-        id_tracker.internal_id(point).is_some()
-            && id_tracker.iter_external().contains(&point)
-            && id_tracker.iter_from(None).any(|i| i.0 == point)
+        assert_eq!(new_deleted_points, deleted_points + 1);
     }
 
     #[test]
@@ -796,18 +703,23 @@ mod test {
         assert_eq!(id_tracker.internal_id(point_to_delete), None);
 
         // Old mappings should be the same as newly loaded one.
-        assert_eq!(
-            old_mappings.external_to_internal_num,
-            id_tracker.mappings.external_to_internal_num
-        );
+        assert_eq!(old_mappings, id_tracker.mappings);
     }
 
     fn gen_random_point_mappings(size: usize, rand: &mut StdRng) -> PointMappings {
+        use std::collections::BTreeMap;
+
+        use uuid::Uuid;
+
+        use crate::types::ExtendedPointId;
+
         const UUID_LIKELYNESS: f64 = 0.5;
 
         let mut external_to_internal_num = BTreeMap::new();
         let mut external_to_internal_uuid = BTreeMap::new();
 
+        let default_deleted = BitVec::repeat(false, size);
+
         let internal_to_external = (0..size)
             .map(|_| {
                 if rand.gen_bool(UUID_LIKELYNESS) {
@@ -825,14 +737,15 @@ mod test {
                     external_to_internal_uuid.insert(*uuid, *pos as u32);
                 }
             })
-            .map(|i| i.1)
+            .map(|(_, point_id)| point_id)
             .collect();
 
-        PointMappings {
+        PointMappings::new(
+            default_deleted,
             internal_to_external,
             external_to_internal_num,
             external_to_internal_uuid,
-        }
+        )
     }
 
     /// Tests de/serializing of whole `PointMappings`.
@@ -843,23 +756,23 @@ mod test {
         let mut buf = vec![];
 
         // Test different sized PointMappings, growing exponentially to also test large ones.
-        // This way we test up to 2^22=4_194_304 points.
-        for size_exp in (0..23u32).step_by(3) {
+        // This way we test up to 2^16 entries.
+        for size_exp in (0..16u32).step_by(3) {
             buf.clear();
 
             let size = 2usize.pow(size_exp);
 
             let mappings = gen_random_point_mappings(size, &mut rng);
 
-            mappings.store(&mut buf).unwrap();
+            ImmutableIdTracker::store_mapping(&mappings, &mut buf).unwrap();
 
             // 16 is the min byte size of an entry. The exact number is not that important
             // we just want to ensure that the written bytes correlate to the amount of entries.
             assert!(buf.len() >= size * 16);
 
-            let new_mappings = PointMappings::load(&*buf, None).unwrap();
+            let new_mappings = ImmutableIdTracker::load_mapping(&*buf, None).unwrap();
 
-            assert_eq!(new_mappings.internal_to_external.len(), size);
+            assert_eq!(new_mappings.total_point_count(), size);
             assert_eq!(mappings, new_mappings);
         }
     }
@@ -872,14 +785,14 @@ mod test {
 
         let mut buf = vec![];
 
-        mappings.store(&mut buf).unwrap();
+        ImmutableIdTracker::store_mapping(&mappings, &mut buf).unwrap();
 
         // We still have a header!
         assert!(!buf.is_empty());
 
-        let new_mappings = PointMappings::load(&*buf, None).unwrap();
+        let new_mappings = ImmutableIdTracker::load_mapping(&*buf, None).unwrap();
 
-        assert!(new_mappings.internal_to_external.is_empty());
+        assert_eq!(new_mappings.total_point_count(), 0);
         assert_eq!(mappings, new_mappings);
     }
 
@@ -895,14 +808,169 @@ mod test {
         for i in 0..SIZE {
             let mut buf = vec![];
 
-            let expected_external = mappings.internal_to_external[i];
+            let internal_id = i as PointOffsetType;
 
-            mappings.write_entry(&mut buf, &expected_external).unwrap();
+            let expected_external = mappings.external_id(internal_id).unwrap();
 
-            let (got_internal, got_external) = PointMappings::read_entry(&*buf).unwrap();
+            ImmutableIdTracker::write_entry(&mut buf, internal_id, expected_external).unwrap();
+
+            let (got_internal, got_external) = ImmutableIdTracker::read_entry(&*buf).unwrap();
 
             assert_eq!(i as PointOffsetType, got_internal);
             assert_eq!(expected_external, got_external);
         }
     }
+
+    const DEFAULT_VERSION: SeqNumberType = 42;
+
+    fn make_in_memory_tracker_from_memory() -> InMemoryIdTracker {
+        let mut id_tracker = InMemoryIdTracker::new();
+
+        for value in TEST_POINTS.iter() {
+            let internal_id = id_tracker.total_point_count() as PointOffsetType;
+            id_tracker.set_link(*value, internal_id).unwrap();
+            id_tracker
+                .set_internal_version(internal_id, DEFAULT_VERSION)
+                .unwrap()
+        }
+
+        id_tracker
+    }
+
+    fn make_immutable_tracker(path: &Path) -> ImmutableIdTracker {
+        let id_tracker = make_in_memory_tracker_from_memory();
+        ImmutableIdTracker::from_in_memory_tracker(id_tracker, path).unwrap()
+    }
+
+    #[test]
+    fn test_id_tracker_equal() {
+        let in_memory_id_tracker = make_in_memory_tracker_from_memory();
+
+        let immutable_id_tracker_dir = Builder::new()
+            .prefix("storage_dir_immutable")
+            .tempdir()
+            .unwrap();
+        let immutable_id_tracker = make_immutable_tracker(immutable_id_tracker_dir.path());
+
+        assert_eq!(
+            in_memory_id_tracker.available_point_count(),
+            immutable_id_tracker.available_point_count()
+        );
+        assert_eq!(
+            in_memory_id_tracker.total_point_count(),
+            immutable_id_tracker.total_point_count()
+        );
+
+        for (internal, external) in TEST_POINTS.iter().enumerate() {
+            let internal = internal as PointOffsetType;
+
+            assert_eq!(
+                in_memory_id_tracker.internal_id(*external),
+                immutable_id_tracker.internal_id(*external)
+            );
+
+            assert_eq!(
+                in_memory_id_tracker
+                    .internal_version(internal)
+                    .unwrap_or_default(),
+                immutable_id_tracker
+                    .internal_version(internal)
+                    .unwrap_or_default()
+            );
+
+            assert_eq!(
+                in_memory_id_tracker.external_id(internal),
+                immutable_id_tracker.external_id(internal)
+            );
+        }
+    }
+
+    #[test]
+    fn simple_id_tracker_vs_immutable_tracker_congruence() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+        let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
+
+        let mut id_tracker = InMemoryIdTracker::new();
+        let mut simple_id_tracker = SimpleIdTracker::open(db).unwrap();
+
+        // Insert 100 random points into id_tracker
+
+        let num_points = 200;
+        let mut rng = StdRng::seed_from_u64(RAND_SEED);
+
+        for _ in 0..num_points {
+            // Generate num id in range from 0 to 100
+
+            let point_id = PointIdType::NumId(rng.gen_range(0..num_points as u64));
+
+            let version = rng.gen_range(0..1000);
+
+            let internal_id_mmap = id_tracker.total_point_count() as PointOffsetType;
+            let internal_id_simple = simple_id_tracker.total_point_count() as PointOffsetType;
+
+            assert_eq!(internal_id_mmap, internal_id_simple);
+
+            if id_tracker.internal_id(point_id).is_some() {
+                id_tracker.drop(point_id).unwrap();
+            }
+            id_tracker.set_link(point_id, internal_id_mmap).unwrap();
+            id_tracker
+                .set_internal_version(internal_id_mmap, version)
+                .unwrap();
+
+            if simple_id_tracker.internal_id(point_id).is_some() {
+                simple_id_tracker.drop(point_id).unwrap();
+            }
+            simple_id_tracker
+                .set_link(point_id, internal_id_simple)
+                .unwrap();
+            simple_id_tracker
+                .set_internal_version(internal_id_simple, version)
+                .unwrap();
+        }
+
+        let immutable_id_tracker =
+            ImmutableIdTracker::from_in_memory_tracker(id_tracker, dir.path()).unwrap();
+        drop(immutable_id_tracker);
+
+        let immutable_id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
+
+        for (external_id, internal_id) in simple_id_tracker.iter_from(None) {
+            assert_eq!(
+                simple_id_tracker.internal_version(internal_id).unwrap(),
+                immutable_id_tracker.internal_version(internal_id).unwrap()
+            );
+            assert_eq!(
+                simple_id_tracker.external_id(internal_id),
+                immutable_id_tracker.external_id(internal_id)
+            );
+            assert_eq!(
+                external_id,
+                immutable_id_tracker.external_id(internal_id).unwrap()
+            );
+            assert_eq!(
+                simple_id_tracker.external_id(internal_id).unwrap(),
+                immutable_id_tracker.external_id(internal_id).unwrap()
+            );
+        }
+
+        for (external_id, internal_id) in immutable_id_tracker.iter_from(None) {
+            assert_eq!(
+                simple_id_tracker.internal_version(internal_id).unwrap(),
+                simple_id_tracker.internal_version(internal_id).unwrap()
+            );
+            assert_eq!(
+                simple_id_tracker.external_id(internal_id),
+                simple_id_tracker.external_id(internal_id)
+            );
+            assert_eq!(
+                external_id,
+                simple_id_tracker.external_id(internal_id).unwrap()
+            );
+            assert_eq!(
+                simple_id_tracker.external_id(internal_id).unwrap(),
+                immutable_id_tracker.external_id(internal_id).unwrap()
+            );
+        }
+    }
 }

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index af054e506..f2016bc92 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -461,7 +461,7 @@ impl IdTracker for ImmutableIdTracker {
                 if let Some(external_id) = self.external_id(internal_id) {
                     to_remove.push(external_id);
                 } else {
-                    debug_assert!(false, "internal id {} has no external id", internal_id);
+                    debug_assert!(false, "internal id {internal_id} has no external id");
                 }
             }
         }

commit 30a6aa4e742db5a7f1e55bcb3f4485ff05046ae5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 26 18:38:35 2024 +0200

    Enable new idtracker (#4692)
    
    * enable immutable_id_tracker and in_memory_id_tracker
    
    * remove redundent flush
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index f2016bc92..6b045d40b 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -252,7 +252,7 @@ impl ImmutableIdTracker {
         })
     }
 
-    pub(super) fn new(
+    pub fn new(
         path: &Path,
         internal_to_version: &[SeqNumberType],
         mappings: PointMappings,

commit 3be87b11ebd82b8ad65918babf54ebc3f253a13d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 14 11:04:56 2024 +0200

    Mmap subcrate refactoring (#4886)
    
    * make mmap_type independent from segment structures
    
    * make bitvec and thiserror workspace dependencies
    
    * move mmap_type into common/memory subcrate
    
    * fmt

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 6b045d40b..c5fd65090 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -9,11 +9,11 @@ use bitvec::vec::BitVec;
 use byteorder::{ReadBytesExt, WriteBytesExt};
 use common::types::PointOffsetType;
 use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
+use memory::mmap_type::{MmapBitSlice, MmapSlice};
 use uuid::Uuid;
 
 use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
 use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWrapper;
-use crate::common::mmap_type::{MmapBitSlice, MmapSlice};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;

commit 59a372b13132ec485b313e36ce26a94bfb855d74
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Aug 14 13:41:37 2024 +0000

    InRamChunkedMmap: optimize using madvise (#4881)
    
    * refactor: introduce AdviceSetting for open_read_mmap/open_write_mmap
    
    * perf: use Advice::Normal in a few places
    
    * perf: use MADV_DONTNEED after reading
    
    * perf: use POSIX_FADV_DONTNEED after reading

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index c5fd65090..c9f566f7b 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -8,6 +8,7 @@ use bitvec::prelude::BitSlice;
 use bitvec::vec::BitVec;
 use byteorder::{ReadBytesExt, WriteBytesExt};
 use common::types::PointOffsetType;
+use memory::madvise::AdviceSetting;
 use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
 use memory::mmap_type::{MmapBitSlice, MmapSlice};
 use uuid::Uuid;
@@ -227,13 +228,18 @@ impl ImmutableIdTracker {
     }
 
     pub fn open(segment_path: &Path) -> OperationResult<Self> {
-        let deleted_raw = open_write_mmap(&Self::deleted_file_path(segment_path))?;
+        let deleted_raw = open_write_mmap(
+            &Self::deleted_file_path(segment_path),
+            AdviceSetting::Global,
+        )?;
         let deleted_mmap = MmapBitSlice::try_from(deleted_raw, 0)?;
         let deleted_bitvec = deleted_mmap.to_bitvec();
         let deleted_wrapper = MmapBitSliceBufferedUpdateWrapper::new(deleted_mmap);
 
-        let internal_to_version_map =
-            open_write_mmap(&Self::version_mapping_file_path(segment_path))?;
+        let internal_to_version_map = open_write_mmap(
+            &Self::version_mapping_file_path(segment_path),
+            AdviceSetting::Global,
+        )?;
         let internal_to_version_mapslice: MmapSlice<SeqNumberType> =
             unsafe { MmapSlice::try_from(internal_to_version_map)? };
         let internal_to_version = internal_to_version_mapslice.to_vec();
@@ -266,7 +272,7 @@ impl ImmutableIdTracker {
 
         debug_assert!(mappings.deleted().len() <= mappings.total_point_count());
 
-        let deleted_mmap = open_write_mmap(&deleted_filepath)?;
+        let deleted_mmap = open_write_mmap(&deleted_filepath, AdviceSetting::Global)?;
         let mut deleted_new = MmapBitSlice::try_from(deleted_mmap, 0)?;
         deleted_new[..mappings.deleted().len()].copy_from_bitslice(mappings.deleted());
 
@@ -291,8 +297,9 @@ impl ImmutableIdTracker {
             let version_size = mmap_size::<SeqNumberType>(min_size);
             create_and_ensure_length(&version_filepath, version_size)?;
         }
-        let mut internal_to_version_wrapper =
-            unsafe { MmapSlice::try_from(open_write_mmap(&version_filepath)?)? };
+        let mut internal_to_version_wrapper = unsafe {
+            MmapSlice::try_from(open_write_mmap(&version_filepath, AdviceSetting::Global)?)?
+        };
 
         internal_to_version_wrapper[..internal_to_version.len()]
             .copy_from_slice(internal_to_version);

commit b3b22793769d2a18b5be99beb96b29fbf275521e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat Sep 14 20:53:07 2024 +0200

    Allow explicit populate of mmap (#4923)
    
    * expose mmap populate
    
    * expose mmap populate in open_read_mmap
    
    * FOR TEST, REVERSE IT: make InRamChunkedMmap default
    
    * enable populate advise on unix
    
    * fix clippy
    
    * unix -> linux
    
    * Update lib/collection/src/config.rs
    
    * clippy fixes
    
    * resolve conflicts
    
    * fmt
    
    * Runtime check for PopulateRead
    
    ---------
    
    Co-authored-by: xzfc <xzfcpw@gmail.com>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index c9f566f7b..9ece068ba 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -231,6 +231,7 @@ impl ImmutableIdTracker {
         let deleted_raw = open_write_mmap(
             &Self::deleted_file_path(segment_path),
             AdviceSetting::Global,
+            true,
         )?;
         let deleted_mmap = MmapBitSlice::try_from(deleted_raw, 0)?;
         let deleted_bitvec = deleted_mmap.to_bitvec();
@@ -239,6 +240,7 @@ impl ImmutableIdTracker {
         let internal_to_version_map = open_write_mmap(
             &Self::version_mapping_file_path(segment_path),
             AdviceSetting::Global,
+            true,
         )?;
         let internal_to_version_mapslice: MmapSlice<SeqNumberType> =
             unsafe { MmapSlice::try_from(internal_to_version_map)? };
@@ -272,7 +274,7 @@ impl ImmutableIdTracker {
 
         debug_assert!(mappings.deleted().len() <= mappings.total_point_count());
 
-        let deleted_mmap = open_write_mmap(&deleted_filepath, AdviceSetting::Global)?;
+        let deleted_mmap = open_write_mmap(&deleted_filepath, AdviceSetting::Global, false)?;
         let mut deleted_new = MmapBitSlice::try_from(deleted_mmap, 0)?;
         deleted_new[..mappings.deleted().len()].copy_from_bitslice(mappings.deleted());
 
@@ -298,7 +300,11 @@ impl ImmutableIdTracker {
             create_and_ensure_length(&version_filepath, version_size)?;
         }
         let mut internal_to_version_wrapper = unsafe {
-            MmapSlice::try_from(open_write_mmap(&version_filepath, AdviceSetting::Global)?)?
+            MmapSlice::try_from(open_write_mmap(
+                &version_filepath,
+                AdviceSetting::Global,
+                false,
+            )?)?
         };
 
         internal_to_version_wrapper[..internal_to_version.len()]

commit f416f2b98f08fc7749814b0725f9035459b5c057
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 27 11:24:58 2024 +0100

    Clippy 1.83 (#5513)
    
    * Clippy 1.83
    
    * there is more

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 9ece068ba..7c434f633 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -185,7 +185,6 @@ impl ImmutableIdTracker {
     /// +-----------------+-----------------------+------------------+
     /// A single entry is thus either 1+8+4=13 or 1+16+4=21 bytes in size depending
     /// on the PointIdType.
-
     fn store_mapping<W: Write>(mappings: &PointMappings, mut writer: W) -> OperationResult<()> {
         let number_of_entries = mappings.total_point_count();
 

commit 4abd77158aa514efb6284b1668e8f02a7b9418f1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Dec 10 00:13:03 2024 +0100

    use fsync instead of flush (#5629)

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 7c434f633..33ff713a7 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -316,8 +316,10 @@ impl ImmutableIdTracker {
             MmapSliceBufferedUpdateWrapper::new(internal_to_version_wrapper);
 
         // Write mappings to disk.
-        let writer = BufWriter::new(File::create(Self::mappings_file_path(path))?);
+        let file = File::create(Self::mappings_file_path(path))?;
+        let writer = BufWriter::new(&file);
         Self::store_mapping(&mappings, writer)?;
+        file.sync_all()?;
 
         deleted_wrapper.flusher()()?;
         internal_to_version_wrapper.flusher()()?;

commit 4c178230e3076243979dcab89c18079c11e42b54
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 22 14:21:27 2025 +0000

    Optimize `merged_points` computation in `SegmentBuilder::update()` (#5820)
    
    * Optimize `merged_points` computation in `SegmentBuilder::update()`
    
    * Fixes

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 33ff713a7..d88d99ded 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -720,48 +720,6 @@ pub(super) mod test {
         assert_eq!(old_mappings, id_tracker.mappings);
     }
 
-    fn gen_random_point_mappings(size: usize, rand: &mut StdRng) -> PointMappings {
-        use std::collections::BTreeMap;
-
-        use uuid::Uuid;
-
-        use crate::types::ExtendedPointId;
-
-        const UUID_LIKELYNESS: f64 = 0.5;
-
-        let mut external_to_internal_num = BTreeMap::new();
-        let mut external_to_internal_uuid = BTreeMap::new();
-
-        let default_deleted = BitVec::repeat(false, size);
-
-        let internal_to_external = (0..size)
-            .map(|_| {
-                if rand.gen_bool(UUID_LIKELYNESS) {
-                    PointIdType::Uuid(Uuid::new_v4())
-                } else {
-                    PointIdType::NumId(rand.next_u64())
-                }
-            })
-            .enumerate()
-            .inspect(|(pos, point_type)| match point_type {
-                ExtendedPointId::NumId(num) => {
-                    external_to_internal_num.insert(*num, *pos as u32);
-                }
-                ExtendedPointId::Uuid(uuid) => {
-                    external_to_internal_uuid.insert(*uuid, *pos as u32);
-                }
-            })
-            .map(|(_, point_id)| point_id)
-            .collect();
-
-        PointMappings::new(
-            default_deleted,
-            internal_to_external,
-            external_to_internal_num,
-            external_to_internal_uuid,
-        )
-    }
-
     /// Tests de/serializing of whole `PointMappings`.
     #[test]
     fn test_point_mappings_de_serialization() {
@@ -776,7 +734,7 @@ pub(super) mod test {
 
             let size = 2usize.pow(size_exp);
 
-            let mappings = gen_random_point_mappings(size, &mut rng);
+            let mappings = PointMappings::random(&mut rng, size as u32);
 
             ImmutableIdTracker::store_mapping(&mappings, &mut buf).unwrap();
 
@@ -795,7 +753,7 @@ pub(super) mod test {
     #[test]
     fn test_point_mappings_de_serialization_empty() {
         let mut rng = StdRng::seed_from_u64(RAND_SEED);
-        let mappings = gen_random_point_mappings(0, &mut rng);
+        let mappings = PointMappings::random(&mut rng, 0);
 
         let mut buf = vec![];
 
@@ -817,7 +775,7 @@ pub(super) mod test {
 
         const SIZE: usize = 400_000;
 
-        let mappings = gen_random_point_mappings(SIZE, &mut rng);
+        let mappings = PointMappings::random(&mut rng, SIZE as u32);
 
         for i in 0..SIZE {
             let mut buf = vec![];

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index d88d99ded..db4ecadb9 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -873,9 +873,9 @@ pub(super) mod test {
         for _ in 0..num_points {
             // Generate num id in range from 0 to 100
 
-            let point_id = PointIdType::NumId(rng.gen_range(0..num_points as u64));
+            let point_id = PointIdType::NumId(rng.random_range(0..num_points as u64));
 
-            let version = rng.gen_range(0..1000);
+            let version = rng.random_range(0..1000);
 
             let internal_id_mmap = id_tracker.total_point_count() as PointOffsetType;
             let internal_id_simple = simple_id_tracker.total_point_count() as PointOffsetType;

commit 4a9574236c91b5aa31e0cc79f36093a2b01051f0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 13:41:50 2025 +0100

    Optimize immutable id tracker (#6022)
    
    * WIP: compressed versions store
    
    * compressed versions store
    
    * fmt
    
    * model test against vec
    
    * use u32::BITS instead of new const
    
    * clippy üò°
    
    * rename CompressedVersionsStore -> CompressedVersions
    
    * Apply suggestions from code review
    
    * Use ahash
    
    * Assert length of version slice
    
    * Add has function
    
    ---------
    
    Co-authored-by: Luis Coss√≠o <luis.cossio@outlook.com>
    Co-authored-by: Tim Vis√©e <tim+github@visee.me>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index db4ecadb9..694dceb4e 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -17,6 +17,7 @@ use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUp
 use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWrapper;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::id_tracker::compressed::versions_store::CompressedVersions;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
 use crate::id_tracker::point_mappings::{FileEndianess, PointMappings};
 use crate::id_tracker::IdTracker;
@@ -64,7 +65,7 @@ pub struct ImmutableIdTracker {
 
     deleted_wrapper: MmapBitSliceBufferedUpdateWrapper,
 
-    internal_to_version: Vec<SeqNumberType>,
+    internal_to_version: CompressedVersions,
     internal_to_version_wrapper: MmapSliceBufferedUpdateWrapper<SeqNumberType>,
 
     mappings: PointMappings,
@@ -243,7 +244,7 @@ impl ImmutableIdTracker {
         )?;
         let internal_to_version_mapslice: MmapSlice<SeqNumberType> =
             unsafe { MmapSlice::try_from(internal_to_version_map)? };
-        let internal_to_version = internal_to_version_mapslice.to_vec();
+        let internal_to_version = CompressedVersions::from_slice(&internal_to_version_mapslice);
         let internal_to_version_wrapper =
             MmapSliceBufferedUpdateWrapper::new(internal_to_version_mapslice);
 
@@ -308,7 +309,7 @@ impl ImmutableIdTracker {
 
         internal_to_version_wrapper[..internal_to_version.len()]
             .copy_from_slice(internal_to_version);
-        let internal_to_version = internal_to_version_wrapper.to_vec();
+        let internal_to_version = CompressedVersions::from_slice(&internal_to_version_wrapper);
 
         debug_assert_eq!(internal_to_version.len(), mappings.total_point_count());
 
@@ -360,7 +361,7 @@ fn bitmap_mmap_size(number_of_elements: usize) -> usize {
 
 impl IdTracker for ImmutableIdTracker {
     fn internal_version(&self, internal_id: PointOffsetType) -> Option<SeqNumberType> {
-        self.internal_to_version.get(internal_id as usize).copied()
+        self.internal_to_version.get(internal_id as usize)
     }
 
     fn set_internal_version(
@@ -369,13 +370,13 @@ impl IdTracker for ImmutableIdTracker {
         version: SeqNumberType,
     ) -> OperationResult<()> {
         if self.external_id(internal_id).is_some() {
-            let old_version = self.internal_to_version.get_mut(internal_id as usize);
+            let has_version = self.internal_to_version.has(internal_id as usize);
             debug_assert!(
-                old_version.is_some(),
-                "Can't extend version list in immutable tracker"
+                has_version,
+                "Can't extend version list in immutable tracker",
             );
-            if let Some(old_version) = old_version {
-                *old_version = version;
+            if has_version {
+                self.internal_to_version.set(internal_id as usize, version);
                 self.internal_to_version_wrapper
                     .set(internal_id as usize, version);
             }
@@ -584,7 +585,17 @@ pub(super) mod test {
 
         // We may extend the length of deleted bitvec as memory maps need to be aligned to
         // a multiple of `usize-width`.
-        assert_eq!(old_versions, loaded_id_tracker.internal_to_version);
+        assert_eq!(
+            old_versions.len(),
+            loaded_id_tracker.internal_to_version.len()
+        );
+        for i in 0..old_versions.len() {
+            assert_eq!(
+                old_versions.get(i),
+                loaded_id_tracker.internal_to_version.get(i),
+                "Version mismatch at index {i}",
+            );
+        }
 
         assert_eq!(old_mappings, loaded_id_tracker.mappings);
 
@@ -643,7 +654,10 @@ pub(super) mod test {
             }
 
             // Check version
-            let expect_version = custom_version.get(&internal_id).unwrap_or(&DEFAULT_VERSION);
+            let expect_version = custom_version
+                .get(&internal_id)
+                .copied()
+                .unwrap_or(DEFAULT_VERSION);
 
             assert_eq!(
                 id_tracker.internal_to_version.get(internal_id as usize),

commit 66dd336cf7a2005a7c828eb35a32d81670380c68
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 14:21:05 2025 +0100

    Optimize immutable id tracker mapping (#6023)
    
    * clone PointMappings into CompressedPointMappings
    
    * fmt
    
    * compressed internal to external
    
    * implement compressed external to internal mapping
    
    * some autogenerated tests
    
    * fix test
    
    * Explicitly resize deleted flags, ensure length matches number of points
    
    * Review remarks
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 694dceb4e..f97a1d6eb 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -1,4 +1,3 @@
-use std::collections::BTreeMap;
 use std::fs::File;
 use std::io::{BufReader, BufWriter, Read, Write};
 use std::mem::{size_of, size_of_val};
@@ -17,9 +16,12 @@ use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUp
 use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWrapper;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::id_tracker::compressed::compressed_point_mappings::CompressedPointMappings;
+use crate::id_tracker::compressed::external_to_internal::CompressedExternalToInternal;
+use crate::id_tracker::compressed::internal_to_external::CompressedInternalToExternal;
 use crate::id_tracker::compressed::versions_store::CompressedVersions;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
-use crate::id_tracker::point_mappings::{FileEndianess, PointMappings};
+use crate::id_tracker::point_mappings::FileEndianess;
 use crate::id_tracker::IdTracker;
 use crate::types::{ExtendedPointId, PointIdType, SeqNumberType};
 
@@ -68,7 +70,7 @@ pub struct ImmutableIdTracker {
     internal_to_version: CompressedVersions,
     internal_to_version_wrapper: MmapSliceBufferedUpdateWrapper<SeqNumberType>,
 
-    mappings: PointMappings,
+    mappings: CompressedPointMappings,
 }
 
 impl ImmutableIdTracker {
@@ -77,18 +79,18 @@ impl ImmutableIdTracker {
         path: &Path,
     ) -> OperationResult<Self> {
         let (internal_to_version, mappings) = in_memory_tracker.into_internal();
-
-        let id_tracker = Self::new(path, &internal_to_version, mappings)?;
+        let compressed_mappings = CompressedPointMappings::from_mappings(mappings);
+        let id_tracker = Self::new(path, &internal_to_version, compressed_mappings)?;
 
         Ok(id_tracker)
     }
 
-    /// Loads a `PointMappings` from the given reader. Applies an optional filter of deleted items
+    /// Loads a `CompressedPointMappings` from the given reader. Applies an optional filter of deleted items
     /// to prevent allocating unneeded data.
     fn load_mapping<R: Read>(
         mut reader: R,
         deleted: Option<BitVec>,
-    ) -> OperationResult<PointMappings> {
+    ) -> OperationResult<CompressedPointMappings> {
         // Deserialize the header
         let len = reader.read_u64::<FileEndianess>()? as usize;
 
@@ -96,9 +98,9 @@ impl ImmutableIdTracker {
 
         deleted.truncate(len);
 
-        let mut internal_to_external = Vec::with_capacity(len);
-        let mut external_to_internal_num: BTreeMap<u64, PointOffsetType> = BTreeMap::new();
-        let mut external_to_internal_uuid: BTreeMap<Uuid, PointOffsetType> = BTreeMap::new();
+        let mut internal_to_external = CompressedInternalToExternal::with_capacity(len);
+        let mut external_to_internal_num: Vec<(u64, PointOffsetType)> = Vec::new();
+        let mut external_to_internal_uuid: Vec<(Uuid, PointOffsetType)> = Vec::new();
 
         // Deserialize the list entries
         for i in 0..len {
@@ -110,7 +112,7 @@ impl ImmutableIdTracker {
                 internal_to_external.resize(internal_id as usize + 1, PointIdType::NumId(0));
             }
 
-            internal_to_external[internal_id as usize] = external_id;
+            internal_to_external.set(internal_id, external_id);
 
             let point_deleted = deleted.get(i).as_deref().copied().unwrap_or(false);
 
@@ -120,25 +122,29 @@ impl ImmutableIdTracker {
 
             match external_id {
                 ExtendedPointId::NumId(num) => {
-                    external_to_internal_num.insert(num, internal_id);
+                    external_to_internal_num.push((num, internal_id));
                 }
                 ExtendedPointId::Uuid(uuid) => {
-                    external_to_internal_uuid.insert(uuid, internal_id);
+                    external_to_internal_uuid.push((uuid, internal_id));
                 }
             }
         }
 
-        // Check that the file has ben fully read.
+        // Check that the file has been fully read.
         #[cfg(debug_assertions)] // Only for dev builds
         {
             debug_assert_eq!(reader.bytes().map(Result::unwrap).count(), 0,);
         }
 
-        Ok(PointMappings::new(
-            deleted,
-            internal_to_external,
+        let external_to_internal = CompressedExternalToInternal::from_vectors(
             external_to_internal_num,
             external_to_internal_uuid,
+        );
+
+        Ok(CompressedPointMappings::new(
+            deleted,
+            internal_to_external,
+            external_to_internal,
         ))
     }
 
@@ -186,7 +192,10 @@ impl ImmutableIdTracker {
     /// +-----------------+-----------------------+------------------+
     /// A single entry is thus either 1+8+4=13 or 1+16+4=21 bytes in size depending
     /// on the PointIdType.
-    fn store_mapping<W: Write>(mappings: &PointMappings, mut writer: W) -> OperationResult<()> {
+    fn store_mapping<W: Write>(
+        mappings: &CompressedPointMappings,
+        mut writer: W,
+    ) -> OperationResult<()> {
         let number_of_entries = mappings.total_point_count();
 
         // Serialize the header (=length).
@@ -263,7 +272,7 @@ impl ImmutableIdTracker {
     pub fn new(
         path: &Path,
         internal_to_version: &[SeqNumberType],
-        mappings: PointMappings,
+        mappings: CompressedPointMappings,
     ) -> OperationResult<Self> {
         // Create mmap file for deleted bitvec
         let deleted_filepath = Self::deleted_file_path(path);
@@ -730,8 +739,15 @@ pub(super) mod test {
         let id_tracker = ImmutableIdTracker::open(dir.path()).unwrap();
         assert_eq!(id_tracker.internal_id(point_to_delete), None);
 
-        // Old mappings should be the same as newly loaded one.
-        assert_eq!(old_mappings, id_tracker.mappings);
+        old_mappings
+            .iter_internal_raw()
+            .zip(id_tracker.mappings.iter_internal_raw())
+            .for_each(
+                |((old_internal, old_external), (new_internal, new_external))| {
+                    assert_eq!(old_internal, new_internal);
+                    assert_eq!(old_external, new_external);
+                },
+            );
     }
 
     /// Tests de/serializing of whole `PointMappings`.
@@ -748,7 +764,7 @@ pub(super) mod test {
 
             let size = 2usize.pow(size_exp);
 
-            let mappings = PointMappings::random(&mut rng, size as u32);
+            let mappings = CompressedPointMappings::random(&mut rng, size as u32);
 
             ImmutableIdTracker::store_mapping(&mappings, &mut buf).unwrap();
 
@@ -767,7 +783,7 @@ pub(super) mod test {
     #[test]
     fn test_point_mappings_de_serialization_empty() {
         let mut rng = StdRng::seed_from_u64(RAND_SEED);
-        let mappings = PointMappings::random(&mut rng, 0);
+        let mappings = CompressedPointMappings::random(&mut rng, 0);
 
         let mut buf = vec![];
 
@@ -789,7 +805,7 @@ pub(super) mod test {
 
         const SIZE: usize = 400_000;
 
-        let mappings = PointMappings::random(&mut rng, SIZE as u32);
+        let mappings = CompressedPointMappings::random(&mut rng, SIZE as u32);
 
         for i in 0..SIZE {
             let mut buf = vec![];

commit 9fbc8df1850c3c1afd77df70a77fb7fc36fae7ea
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Fri Feb 21 11:59:47 2025 +0100

    Use u32 index in compressed version store, doesn't support bigger values (#6036)
    
    * Use u32 index in compressed version store, doesn't support bigger values
    
    * Patch test

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index f97a1d6eb..1d23226cb 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -370,7 +370,7 @@ fn bitmap_mmap_size(number_of_elements: usize) -> usize {
 
 impl IdTracker for ImmutableIdTracker {
     fn internal_version(&self, internal_id: PointOffsetType) -> Option<SeqNumberType> {
-        self.internal_to_version.get(internal_id as usize)
+        self.internal_to_version.get(internal_id)
     }
 
     fn set_internal_version(
@@ -379,13 +379,13 @@ impl IdTracker for ImmutableIdTracker {
         version: SeqNumberType,
     ) -> OperationResult<()> {
         if self.external_id(internal_id).is_some() {
-            let has_version = self.internal_to_version.has(internal_id as usize);
+            let has_version = self.internal_to_version.has(internal_id);
             debug_assert!(
                 has_version,
                 "Can't extend version list in immutable tracker",
             );
             if has_version {
-                self.internal_to_version.set(internal_id as usize, version);
+                self.internal_to_version.set(internal_id, version);
                 self.internal_to_version_wrapper
                     .set(internal_id as usize, version);
             }
@@ -598,7 +598,7 @@ pub(super) mod test {
             old_versions.len(),
             loaded_id_tracker.internal_to_version.len()
         );
-        for i in 0..old_versions.len() {
+        for i in 0..old_versions.len() as u32 {
             assert_eq!(
                 old_versions.get(i),
                 loaded_id_tracker.internal_to_version.get(i),
@@ -669,7 +669,7 @@ pub(super) mod test {
                 .unwrap_or(DEFAULT_VERSION);
 
             assert_eq!(
-                id_tracker.internal_to_version.get(internal_id as usize),
+                id_tracker.internal_to_version.get(internal_id),
                 Some(expect_version)
             );
 

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 1d23226cb..46bb5fba5 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -12,17 +12,17 @@ use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
 use memory::mmap_type::{MmapBitSlice, MmapSlice};
 use uuid::Uuid;
 
+use crate::common::Flusher;
 use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
 use crate::common::mmap_slice_buffered_update_wrapper::MmapSliceBufferedUpdateWrapper;
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::common::Flusher;
+use crate::id_tracker::IdTracker;
 use crate::id_tracker::compressed::compressed_point_mappings::CompressedPointMappings;
 use crate::id_tracker::compressed::external_to_internal::CompressedExternalToInternal;
 use crate::id_tracker::compressed::internal_to_external::CompressedInternalToExternal;
 use crate::id_tracker::compressed::versions_store::CompressedVersions;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
 use crate::id_tracker::point_mappings::FileEndianess;
-use crate::id_tracker::IdTracker;
 use crate::types::{ExtendedPointId, PointIdType, SeqNumberType};
 
 pub const DELETED_FILE_NAME: &str = "id_tracker.deleted";
@@ -162,7 +162,7 @@ impl ImmutableIdTracker {
                 return Err(OperationError::InconsistentStorage {
                     description: "Invalid byte read when deserializing Immutable id tracker"
                         .to_string(),
-                })
+                });
             }
             Some(ExternalIdType::Number) => {
                 let num = reader.read_u64::<FileEndianess>()?;
@@ -513,13 +513,13 @@ pub(super) mod test {
     use std::collections::{HashMap, HashSet};
 
     use itertools::Itertools;
-    use rand::prelude::*;
     use rand::Rng;
+    use rand::prelude::*;
     use tempfile::Builder;
     use uuid::Uuid;
 
     use super::*;
-    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 
     const RAND_SEED: u64 = 42;

commit 82220f3ee1cf8965a99ac04ff349971afb184742
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Wed Mar 12 12:29:42 2025 +0100

    Fix incorrect assertions in immutable ID tracker test (#6155)

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 46bb5fba5..ec01dd25a 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -959,11 +959,11 @@ pub(super) mod test {
         for (external_id, internal_id) in immutable_id_tracker.iter_from(None) {
             assert_eq!(
                 simple_id_tracker.internal_version(internal_id).unwrap(),
-                simple_id_tracker.internal_version(internal_id).unwrap()
+                immutable_id_tracker.internal_version(internal_id).unwrap()
             );
             assert_eq!(
                 simple_id_tracker.external_id(internal_id),
-                simple_id_tracker.external_id(internal_id)
+                immutable_id_tracker.external_id(internal_id)
             );
             assert_eq!(
                 external_id,

commit 724b45f18208ac2eba779a21bbf4646d3f9f6d49
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Mar 12 20:27:51 2025 +0000

    Add BitSliceExt::get_bit (#6162)

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index ec01dd25a..f3dd085b5 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -6,6 +6,7 @@ use std::path::{Path, PathBuf};
 use bitvec::prelude::BitSlice;
 use bitvec::vec::BitVec;
 use byteorder::{ReadBytesExt, WriteBytesExt};
+use common::ext::BitSliceExt as _;
 use common::types::PointOffsetType;
 use memory::madvise::AdviceSetting;
 use memory::mmap_ops::{create_and_ensure_length, open_write_mmap};
@@ -114,8 +115,7 @@ impl ImmutableIdTracker {
 
             internal_to_external.set(internal_id, external_id);
 
-            let point_deleted = deleted.get(i).as_deref().copied().unwrap_or(false);
-
+            let point_deleted = deleted.get_bit(i).unwrap_or(false);
             if point_deleted {
                 continue;
             }

commit dfc7d8c163d8238aa4856802d1bac8913a711fc2
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Thu Mar 13 12:26:33 2025 +0100

    Embed storage type bytes into enum itself (#6164)

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index f3dd085b5..b6c7a1461 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -30,30 +30,22 @@ pub const DELETED_FILE_NAME: &str = "id_tracker.deleted";
 pub const MAPPINGS_FILE_NAME: &str = "id_tracker.mappings";
 pub const VERSION_MAPPING_FILE_NAME: &str = "id_tracker.versions";
 
-const EXTERNAL_ID_NUMBER_BYTE: u8 = 0;
-const EXTERNAL_ID_UUID_BYTE: u8 = 1;
-
+#[derive(Copy, Clone)]
+#[repr(u8)]
 enum ExternalIdType {
-    Number,
-    Uuid,
+    Number = 0,
+    Uuid = 1,
 }
 
 impl ExternalIdType {
     fn from_byte(byte: u8) -> Option<Self> {
         match byte {
-            EXTERNAL_ID_NUMBER_BYTE => Some(Self::Number),
-            EXTERNAL_ID_UUID_BYTE => Some(Self::Uuid),
+            x if x == Self::Number as u8 => Some(Self::Number),
+            x if x == Self::Uuid as u8 => Some(Self::Uuid),
             _ => None,
         }
     }
 
-    fn to_byte(&self) -> u8 {
-        match self {
-            Self::Number => EXTERNAL_ID_NUMBER_BYTE,
-            Self::Uuid => EXTERNAL_ID_UUID_BYTE,
-        }
-    }
-
     fn from_point_id(point_id: &PointIdType) -> Self {
         match point_id {
             PointIdType::NumId(_) => Self::Number,
@@ -216,7 +208,7 @@ impl ImmutableIdTracker {
         external_id: PointIdType,
     ) -> OperationResult<()> {
         // Byte to distinguish between Number and UUID
-        writer.write_u8(ExternalIdType::from_point_id(&external_id).to_byte())?;
+        writer.write_u8(ExternalIdType::from_point_id(&external_id) as u8)?;
 
         // Serializing External ID
         match external_id {
@@ -364,8 +356,7 @@ fn mmap_size<T>(len: usize) -> usize {
 
 /// Returns the required mmap filesize for a `BitSlice`.
 fn bitmap_mmap_size(number_of_elements: usize) -> usize {
-    const BITS_TO_BYTES: usize = 8; // .len() returns bits but we want bytes!
-    mmap_size::<usize>(number_of_elements.div_ceil(BITS_TO_BYTES))
+    mmap_size::<usize>(number_of_elements.div_ceil(u8::BITS as usize))
 }
 
 impl IdTracker for ImmutableIdTracker {

commit ae71337b112c49216aa960cb6011362bbdcb4f1d
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Fri Mar 14 09:52:55 2025 +0100

    Add mutable ID tracker tests (#6158)
    
    * Add mutable ID tracker tests, ported from immutable ID tracker
    
    * Also test raw mappings, reset inverse mapping when dropping point
    
    * Always flush mappings before version, also in test

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index b6c7a1461..0212e0c22 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -721,8 +721,8 @@ pub(super) mod test {
                 .expect("Point to delete exists.");
             assert!(!id_tracker.is_deleted_point(intetrnal_id));
             id_tracker.drop(point_to_delete).unwrap();
-            id_tracker.versions_flusher()().unwrap();
             id_tracker.mapping_flusher()().unwrap();
+            id_tracker.versions_flusher()().unwrap();
             id_tracker.mappings
         };
 

commit f230629fa0e62e069e683cce60e24319ab3cc84b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 25 10:08:21 2025 +0100

    build(deps): bump log from 0.4.26 to 0.4.27 (#6247)
    
    * build(deps): bump log from 0.4.26 to 0.4.27
    
    Bumps [log](https://github.com/rust-lang/log) from 0.4.26 to 0.4.27.
    - [Release notes](https://github.com/rust-lang/log/releases)
    - [Changelog](https://github.com/rust-lang/log/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/rust-lang/log/compare/0.4.26...0.4.27)
    
    ---
    updated-dependencies:
    - dependency-name: log
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * put variables inside the strings for log macros
    
    * also for pyroscope
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Luis Coss√≠o <luis.cossio@outlook.com>

diff --git a/lib/segment/src/id_tracker/immutable_id_tracker.rs b/lib/segment/src/id_tracker/immutable_id_tracker.rs
index 0212e0c22..badea9c4f 100644
--- a/lib/segment/src/id_tracker/immutable_id_tracker.rs
+++ b/lib/segment/src/id_tracker/immutable_id_tracker.rs
@@ -484,7 +484,7 @@ impl IdTracker for ImmutableIdTracker {
             self.drop(external_id)?;
             #[cfg(debug_assertions)] // Only for dev builds
             {
-                log::debug!("dropped version for point {} without version", external_id);
+                log::debug!("dropped version for point {external_id} without version");
             }
         }
         Ok(())

