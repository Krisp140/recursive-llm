# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/ReactFiberNewContext.js

commit 87ae211ccd8d61796cfdef138d1e12fb7a74f85d
Author: Andrew Clark <acdlite@me.com>
Date:   Wed Jan 24 19:36:22 2018 -0800

    New context API (#11818)
    
    * New context API
    
    Introduces a declarative context API that propagates updates even when
    shouldComponentUpdate returns false.
    
    * Fuzz tester for context
    
    * Use ReactElement for provider and consumer children
    
    * Unify more branches in createFiberFromElement
    
    * Compare context values using Object.is
    
    Same semantics as PureComponent/shallowEqual.
    
    * Add support for Provider and Consumer to server-side renderer
    
    * Store providers on global stack
    
    Rather than using a linked list stored on the context type. The global
    stack can be reset in case of an interruption or error, whereas with the
    linked list implementation, you'd need to keep track of every
    context type.
    
    * Put new context API behind a feature flag
    
    We'll enable this in www only for now.
    
    * Store nearest provider on context object
    
    * Handle reentrancy in server renderer
    
    Context stack should be per server renderer instance.
    
    * Bailout of consumer updates using bitmask
    
    The context type defines an optional function that compares two context
    values, returning a bitfield. A consumer may specify the bits it needs
    for rendering. If a provider's context changes, and the consumer's bits
    do not intersect with the changed bits, we can skip the consumer.
    
    This is similar to how selectors are used in Redux but fast enough to do
    while scanning the tree. The only user code involved is the function
    that computes the changed bits. But that's only called once per provider
    update, not for every consumer.
    
    * Store current value and changed bits on context object
    
    There are fewer providers than consumers, so better to do this work
    at the provider.
    
    * Use maximum of 31 bits for bitmask
    
    This is the largest integer size in V8 on 32-bit systems. Warn in
    development if too large a number is used.
    
    * ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer
    
    * Inline Object.is
    
    * Warn if multiple renderers concurrently render the same context provider
    
    Let's see if we can get away with not supporting this for now. If it
    turns out that it's needed, we can fall back to backtracking the
    fiber return path.
    
    * Nits that came up during review

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
new file mode 100644
index 0000000000..ba59ae5998
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -0,0 +1,70 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {Fiber} from './ReactFiber';
+import type {ReactContext} from 'shared/ReactTypes';
+
+import warning from 'fbjs/lib/warning';
+
+let stack: Array<Fiber> = [];
+let index = -1;
+
+let rendererSigil;
+if (__DEV__) {
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+}
+
+export function pushProvider(providerFiber: Fiber): void {
+  index += 1;
+  stack[index] = providerFiber;
+  const context: ReactContext<any> = providerFiber.type.context;
+  context.currentValue = providerFiber.pendingProps.value;
+  context.changedBits = providerFiber.stateNode;
+
+  if (__DEV__) {
+    warning(
+      context._currentRenderer === null ||
+        context._currentRenderer === rendererSigil,
+      'Detected multiple renderers concurrently rendering the ' +
+        'same context provider. This is currently unsupported.',
+    );
+    context._currentRenderer = rendererSigil;
+  }
+}
+
+export function popProvider(providerFiber: Fiber): void {
+  if (__DEV__) {
+    warning(index > -1 && providerFiber === stack[index], 'Unexpected pop.');
+  }
+  stack[index] = null;
+  index -= 1;
+  const context: ReactContext<any> = providerFiber.type.context;
+  if (index < 0) {
+    context.currentValue = context.defaultValue;
+    context.changedBits = 0;
+  } else {
+    const previousProviderFiber = stack[index];
+    context.currentValue = previousProviderFiber.pendingProps.value;
+    context.changedBits = previousProviderFiber.stateNode;
+  }
+}
+
+export function resetProviderStack(): void {
+  for (let i = index; i > -1; i--) {
+    const providerFiber = stack[i];
+    const context: ReactContext<any> = providerFiber.type.context;
+    context.currentValue = context.defaultValue;
+    context.changedBits = 0;
+    stack[i] = null;
+    if (__DEV__) {
+      context._currentRenderer = null;
+    }
+  }
+}

commit 28aa084ad84a681be1c45def2f4b4c0dd8a43871
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jan 30 13:06:12 2018 -0800

    Switch to JSX API for context (#12123)
    
    * Switch to JSX API for context
    
    80% sure this will be the final API. Merging this now so we can get this
    into the next www sync in preparation for 16.3.
    
    * Promote context to a stable API

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index ba59ae5998..af6e94fe7b 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -67,4 +67,5 @@ export function resetProviderStack(): void {
       context._currentRenderer = null;
     }
   }
+  index = -1;
 }

commit b5e961508709ac61f7e2de60a047238216f09a04
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Feb 8 14:23:41 2018 -0800

    Interleaved Context.Provider bugfix (#12187)
    
    * Added failing unit test
    
    * Maybe fixed interleaved context provider bug?

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index af6e94fe7b..1b1758e088 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -12,6 +12,8 @@ import type {ReactContext} from 'shared/ReactTypes';
 
 import warning from 'fbjs/lib/warning';
 
+let changedBitsStack: Array<any> = [];
+let currentValueStack: Array<any> = [];
 let stack: Array<Fiber> = [];
 let index = -1;
 
@@ -22,9 +24,11 @@ if (__DEV__) {
 }
 
 export function pushProvider(providerFiber: Fiber): void {
+  const context: ReactContext<any> = providerFiber.type.context;
   index += 1;
+  changedBitsStack[index] = context.changedBits;
+  currentValueStack[index] = context.currentValue;
   stack[index] = providerFiber;
-  const context: ReactContext<any> = providerFiber.type.context;
   context.currentValue = providerFiber.pendingProps.value;
   context.changedBits = providerFiber.stateNode;
 
@@ -43,17 +47,15 @@ export function popProvider(providerFiber: Fiber): void {
   if (__DEV__) {
     warning(index > -1 && providerFiber === stack[index], 'Unexpected pop.');
   }
+  const changedBits = changedBitsStack[index];
+  const currentValue = currentValueStack[index];
+  changedBitsStack[index] = null;
+  currentValueStack[index] = null;
   stack[index] = null;
   index -= 1;
   const context: ReactContext<any> = providerFiber.type.context;
-  if (index < 0) {
-    context.currentValue = context.defaultValue;
-    context.changedBits = 0;
-  } else {
-    const previousProviderFiber = stack[index];
-    context.currentValue = previousProviderFiber.pendingProps.value;
-    context.changedBits = previousProviderFiber.stateNode;
-  }
+  context.currentValue = currentValue;
+  context.changedBits = changedBits;
 }
 
 export function resetProviderStack(): void {
@@ -62,6 +64,8 @@ export function resetProviderStack(): void {
     const context: ReactContext<any> = providerFiber.type.context;
     context.currentValue = context.defaultValue;
     context.changedBits = 0;
+    changedBitsStack[i] = null;
+    currentValueStack[i] = null;
     stack[i] = null;
     if (__DEV__) {
       context._currentRenderer = null;

commit ad9544f48e58f2599a8ea0de1e9f4dd104db30bb
Author: Andrew Clark <acdlite@me.com>
Date:   Mon Mar 12 14:30:47 2018 -0700

    Prefix internal context properties with underscore (#12358)
    
    So these aren't mistaken for public properties. Ideally, we'd use
    symbols or private fields.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 1b1758e088..3c8bf67fd0 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -26,11 +26,11 @@ if (__DEV__) {
 export function pushProvider(providerFiber: Fiber): void {
   const context: ReactContext<any> = providerFiber.type.context;
   index += 1;
-  changedBitsStack[index] = context.changedBits;
-  currentValueStack[index] = context.currentValue;
+  changedBitsStack[index] = context._changedBits;
+  currentValueStack[index] = context._currentValue;
   stack[index] = providerFiber;
-  context.currentValue = providerFiber.pendingProps.value;
-  context.changedBits = providerFiber.stateNode;
+  context._currentValue = providerFiber.pendingProps.value;
+  context._changedBits = providerFiber.stateNode;
 
   if (__DEV__) {
     warning(
@@ -54,16 +54,16 @@ export function popProvider(providerFiber: Fiber): void {
   stack[index] = null;
   index -= 1;
   const context: ReactContext<any> = providerFiber.type.context;
-  context.currentValue = currentValue;
-  context.changedBits = changedBits;
+  context._currentValue = currentValue;
+  context._changedBits = changedBits;
 }
 
 export function resetProviderStack(): void {
   for (let i = index; i > -1; i--) {
     const providerFiber = stack[i];
     const context: ReactContext<any> = providerFiber.type.context;
-    context.currentValue = context.defaultValue;
-    context.changedBits = 0;
+    context._currentValue = context._defaultValue;
+    context._changedBits = 0;
     changedBitsStack[i] = null;
     currentValueStack[i] = null;
     stack[i] = null;

commit 208b490ed907346ae3e37159535299899f74312d
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Mar 15 19:27:44 2018 -0700

    Unify context stack implementations (#12359)
    
    * Use module pattern so context stack is isolated per renderer
    
    * Unify context implementations
    
    Implements the new context API on top of the existing ReactStack that we
    already use for host context and legacy context. Now there is a single
    array that we push and pop from.
    
    This makes the interrupt path slightly slower, since when we reset the
    unit of work pointer, we have to iterate over the stack (like before)
    *and* switch on the type of work (not like before). On the other hand,
    this unifies all of the unwinding behavior in the UnwindWork module.
    
    * Add DEV only warning if stack is not reset properly

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 3c8bf67fd0..5f64352438 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -9,67 +9,64 @@
 
 import type {Fiber} from './ReactFiber';
 import type {ReactContext} from 'shared/ReactTypes';
+import type {StackCursor, Stack} from './ReactFiberStack';
 
 import warning from 'fbjs/lib/warning';
 
-let changedBitsStack: Array<any> = [];
-let currentValueStack: Array<any> = [];
-let stack: Array<Fiber> = [];
-let index = -1;
+export type NewContext = {
+  pushProvider(providerFiber: Fiber): void,
+  popProvider(providerFiber: Fiber): void,
+};
 
-let rendererSigil;
-if (__DEV__) {
-  // Use this to detect multiple renderers using the same context
-  rendererSigil = {};
-}
-
-export function pushProvider(providerFiber: Fiber): void {
-  const context: ReactContext<any> = providerFiber.type.context;
-  index += 1;
-  changedBitsStack[index] = context._changedBits;
-  currentValueStack[index] = context._currentValue;
-  stack[index] = providerFiber;
-  context._currentValue = providerFiber.pendingProps.value;
-  context._changedBits = providerFiber.stateNode;
+export default function(stack: Stack) {
+  const {createCursor, push, pop} = stack;
 
-  if (__DEV__) {
-    warning(
-      context._currentRenderer === null ||
-        context._currentRenderer === rendererSigil,
-      'Detected multiple renderers concurrently rendering the ' +
-        'same context provider. This is currently unsupported.',
-    );
-    context._currentRenderer = rendererSigil;
-  }
-}
+  const providerCursor: StackCursor<Fiber | null> = createCursor(null);
+  const valueCursor: StackCursor<mixed> = createCursor(null);
+  const changedBitsCursor: StackCursor<number> = createCursor(0);
 
-export function popProvider(providerFiber: Fiber): void {
+  let rendererSigil;
   if (__DEV__) {
-    warning(index > -1 && providerFiber === stack[index], 'Unexpected pop.');
+    // Use this to detect multiple renderers using the same context
+    rendererSigil = {};
   }
-  const changedBits = changedBitsStack[index];
-  const currentValue = currentValueStack[index];
-  changedBitsStack[index] = null;
-  currentValueStack[index] = null;
-  stack[index] = null;
-  index -= 1;
-  const context: ReactContext<any> = providerFiber.type.context;
-  context._currentValue = currentValue;
-  context._changedBits = changedBits;
-}
 
-export function resetProviderStack(): void {
-  for (let i = index; i > -1; i--) {
-    const providerFiber = stack[i];
+  function pushProvider(providerFiber: Fiber): void {
     const context: ReactContext<any> = providerFiber.type.context;
-    context._currentValue = context._defaultValue;
-    context._changedBits = 0;
-    changedBitsStack[i] = null;
-    currentValueStack[i] = null;
-    stack[i] = null;
+
+    push(changedBitsCursor, context._changedBits, providerFiber);
+    push(valueCursor, context._currentValue, providerFiber);
+    push(providerCursor, providerFiber, providerFiber);
+
+    context._currentValue = providerFiber.pendingProps.value;
+    context._changedBits = providerFiber.stateNode;
+
     if (__DEV__) {
-      context._currentRenderer = null;
+      warning(
+        context._currentRenderer === null ||
+          context._currentRenderer === rendererSigil,
+        'Detected multiple renderers concurrently rendering the ' +
+          'same context provider. This is currently unsupported.',
+      );
+      context._currentRenderer = rendererSigil;
     }
   }
-  index = -1;
+
+  function popProvider(providerFiber: Fiber): void {
+    const changedBits = changedBitsCursor.current;
+    const currentValue = valueCursor.current;
+
+    pop(providerCursor, providerFiber);
+    pop(valueCursor, providerFiber);
+    pop(changedBitsCursor, providerFiber);
+
+    const context: ReactContext<any> = providerFiber.type.context;
+    context._currentValue = currentValue;
+    context._changedBits = changedBits;
+  }
+
+  return {
+    pushProvider,
+    popProvider,
+  };
 }

commit ba245f6f9b0bf31c2ebff5c087c21bcae111e6c3
Author: Mateusz Burzyński <mateuszburzynski@gmail.com>
Date:   Tue Apr 3 02:47:25 2018 +0200

    Prefix _context property on returned ReactContext from createContext - it's private (#12501)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 5f64352438..ab9c27e88a 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -32,7 +32,7 @@ export default function(stack: Stack) {
   }
 
   function pushProvider(providerFiber: Fiber): void {
-    const context: ReactContext<any> = providerFiber.type.context;
+    const context: ReactContext<any> = providerFiber.type._context;
 
     push(changedBitsCursor, context._changedBits, providerFiber);
     push(valueCursor, context._currentValue, providerFiber);
@@ -60,7 +60,7 @@ export default function(stack: Stack) {
     pop(valueCursor, providerFiber);
     pop(changedBitsCursor, providerFiber);
 
-    const context: ReactContext<any> = providerFiber.type.context;
+    const context: ReactContext<any> = providerFiber.type._context;
     context._currentValue = currentValue;
     context._changedBits = changedBits;
   }

commit b0726e99476ea67c7558cbf268685998a38ade7c
Author: Andrew Clark <acdlite@me.com>
Date:   Thu May 10 18:34:01 2018 -0700

    Support sharing context objects between concurrent renderers (#12779)
    
    * Support concurrent primary and secondary renderers.
    
    As a workaround to support multiple concurrent renderers, we categorize
    some renderers as primary and others as secondary. We only expect
    there to be two concurrent renderers at most: React Native (primary) and
    Fabric (secondary); React DOM (primary) and React ART (secondary).
    Secondary renderers store their context values on separate fields.
    
    * Add back concurrent renderer warning
    
    Only warn for two concurrent primary or two concurrent secondary renderers.
    
    * Change "_secondary" suffix to "2"
    
    #EveryBitCounts

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index ab9c27e88a..3aaf553ec5 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -11,14 +11,16 @@ import type {Fiber} from './ReactFiber';
 import type {ReactContext} from 'shared/ReactTypes';
 import type {StackCursor, Stack} from './ReactFiberStack';
 
-import warning from 'fbjs/lib/warning';
-
 export type NewContext = {
   pushProvider(providerFiber: Fiber): void,
   popProvider(providerFiber: Fiber): void,
+  getContextCurrentValue(context: ReactContext<any>): any,
+  getContextChangedBits(context: ReactContext<any>): number,
 };
 
-export default function(stack: Stack) {
+import warning from 'fbjs/lib/warning';
+
+export default function(stack: Stack, isPrimaryRenderer: boolean) {
   const {createCursor, push, pop} = stack;
 
   const providerCursor: StackCursor<Fiber | null> = createCursor(null);
@@ -34,21 +36,38 @@ export default function(stack: Stack) {
   function pushProvider(providerFiber: Fiber): void {
     const context: ReactContext<any> = providerFiber.type._context;
 
-    push(changedBitsCursor, context._changedBits, providerFiber);
-    push(valueCursor, context._currentValue, providerFiber);
-    push(providerCursor, providerFiber, providerFiber);
-
-    context._currentValue = providerFiber.pendingProps.value;
-    context._changedBits = providerFiber.stateNode;
-
-    if (__DEV__) {
-      warning(
-        context._currentRenderer === null ||
-          context._currentRenderer === rendererSigil,
-        'Detected multiple renderers concurrently rendering the ' +
-          'same context provider. This is currently unsupported.',
-      );
-      context._currentRenderer = rendererSigil;
+    if (isPrimaryRenderer) {
+      push(changedBitsCursor, context._changedBits, providerFiber);
+      push(valueCursor, context._currentValue, providerFiber);
+      push(providerCursor, providerFiber, providerFiber);
+
+      context._currentValue = providerFiber.pendingProps.value;
+      context._changedBits = providerFiber.stateNode;
+      if (__DEV__) {
+        warning(
+          context._currentRenderer === null ||
+            context._currentRenderer === rendererSigil,
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+        context._currentRenderer = rendererSigil;
+      }
+    } else {
+      push(changedBitsCursor, context._changedBits2, providerFiber);
+      push(valueCursor, context._currentValue2, providerFiber);
+      push(providerCursor, providerFiber, providerFiber);
+
+      context._currentValue2 = providerFiber.pendingProps.value;
+      context._changedBits2 = providerFiber.stateNode;
+      if (__DEV__) {
+        warning(
+          context._currentRenderer2 === null ||
+            context._currentRenderer2 === rendererSigil,
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+        context._currentRenderer2 = rendererSigil;
+      }
     }
   }
 
@@ -61,12 +80,27 @@ export default function(stack: Stack) {
     pop(changedBitsCursor, providerFiber);
 
     const context: ReactContext<any> = providerFiber.type._context;
-    context._currentValue = currentValue;
-    context._changedBits = changedBits;
+    if (isPrimaryRenderer) {
+      context._currentValue = currentValue;
+      context._changedBits = changedBits;
+    } else {
+      context._currentValue2 = currentValue;
+      context._changedBits2 = changedBits;
+    }
+  }
+
+  function getContextCurrentValue(context: ReactContext<any>): any {
+    return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+  }
+
+  function getContextChangedBits(context: ReactContext<any>): number {
+    return isPrimaryRenderer ? context._changedBits : context._changedBits2;
   }
 
   return {
     pushProvider,
     popProvider,
+    getContextCurrentValue,
+    getContextChangedBits,
   };
 }

commit d4123b4784c75af0bfb5f6505e6c567e354b4155
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed May 16 17:31:56 2018 -0700

    Relax current renderer warning (#12838)
    
    If you use an older version of `react` this won't get initialized to null. We don't really need it to be initialized to work.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 3aaf553ec5..74e1c73390 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -45,7 +45,8 @@ export default function(stack: Stack, isPrimaryRenderer: boolean) {
       context._changedBits = providerFiber.stateNode;
       if (__DEV__) {
         warning(
-          context._currentRenderer === null ||
+          context._currentRenderer === undefined ||
+            context._currentRenderer === null ||
             context._currentRenderer === rendererSigil,
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',
@@ -61,7 +62,8 @@ export default function(stack: Stack, isPrimaryRenderer: boolean) {
       context._changedBits2 = providerFiber.stateNode;
       if (__DEV__) {
         warning(
-          context._currentRenderer2 === null ||
+          context._currentRenderer2 === undefined ||
+            context._currentRenderer2 === null ||
             context._currentRenderer2 === rendererSigil,
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',

commit 47b003a828fe98e12947ba98e819ec4e617deef1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat May 19 11:29:11 2018 +0100

    Resolve host configs at build time (#12792)
    
    * Extract base Jest config
    
    This makes it easier to change the source config without affecting the build test config.
    
    * Statically import the host config
    
    This changes react-reconciler to import HostConfig instead of getting it through a function argument.
    
    Rather than start with packages like ReactDOM that want to inline it, I started with React Noop and ensured that *custom* renderers using react-reconciler package still work. To do this, I'm making HostConfig module in the reconciler look at a global variable by default (which, in case of the react-reconciler npm package, ends up being the host config argument in the top-level scope).
    
    This is still very broken.
    
    * Add scaffolding for importing an inlined renderer
    
    * Fix the build
    
    * ES exports for renderer methods
    
    * ES modules for host configs
    
    * Remove closures from the reconciler
    
    * Check each renderer's config with Flow
    
    * Fix uncovered Flow issue
    
    We know nextHydratableInstance doesn't get mutated inside this function, but Flow doesn't so it thinks it may be null.
    Help Flow.
    
    * Prettier
    
    * Get rid of enable*Reconciler flags
    
    They are not as useful anymore because for almost all cases (except third party renderers) we *know* whether it supports mutation or persistence.
    
    This refactoring means react-reconciler and react-reconciler/persistent third-party packages now ship the same thing.
    Not ideal, but this seems worth how simpler the code becomes. We can later look into addressing it by having a single toggle instead.
    
    * Prettier again
    
    * Fix Flow config creation issue
    
    * Fix imprecise Flow typing
    
    * Revert accidental changes

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 74e1c73390..f2715acfb2 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -9,7 +9,7 @@
 
 import type {Fiber} from './ReactFiber';
 import type {ReactContext} from 'shared/ReactTypes';
-import type {StackCursor, Stack} from './ReactFiberStack';
+import type {StackCursor} from './ReactFiberStack';
 
 export type NewContext = {
   pushProvider(providerFiber: Fiber): void,
@@ -19,90 +19,88 @@ export type NewContext = {
 };
 
 import warning from 'fbjs/lib/warning';
+import {isPrimaryRenderer} from './ReactFiberHostConfig';
+import {createCursor, push, pop} from './ReactFiberStack';
 
-export default function(stack: Stack, isPrimaryRenderer: boolean) {
-  const {createCursor, push, pop} = stack;
+const providerCursor: StackCursor<Fiber | null> = createCursor(null);
+const valueCursor: StackCursor<mixed> = createCursor(null);
+const changedBitsCursor: StackCursor<number> = createCursor(0);
 
-  const providerCursor: StackCursor<Fiber | null> = createCursor(null);
-  const valueCursor: StackCursor<mixed> = createCursor(null);
-  const changedBitsCursor: StackCursor<number> = createCursor(0);
-
-  let rendererSigil;
-  if (__DEV__) {
-    // Use this to detect multiple renderers using the same context
-    rendererSigil = {};
-  }
-
-  function pushProvider(providerFiber: Fiber): void {
-    const context: ReactContext<any> = providerFiber.type._context;
-
-    if (isPrimaryRenderer) {
-      push(changedBitsCursor, context._changedBits, providerFiber);
-      push(valueCursor, context._currentValue, providerFiber);
-      push(providerCursor, providerFiber, providerFiber);
-
-      context._currentValue = providerFiber.pendingProps.value;
-      context._changedBits = providerFiber.stateNode;
-      if (__DEV__) {
-        warning(
-          context._currentRenderer === undefined ||
-            context._currentRenderer === null ||
-            context._currentRenderer === rendererSigil,
-          'Detected multiple renderers concurrently rendering the ' +
-            'same context provider. This is currently unsupported.',
-        );
-        context._currentRenderer = rendererSigil;
-      }
-    } else {
-      push(changedBitsCursor, context._changedBits2, providerFiber);
-      push(valueCursor, context._currentValue2, providerFiber);
-      push(providerCursor, providerFiber, providerFiber);
+let rendererSigil;
+if (__DEV__) {
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+}
 
-      context._currentValue2 = providerFiber.pendingProps.value;
-      context._changedBits2 = providerFiber.stateNode;
-      if (__DEV__) {
-        warning(
-          context._currentRenderer2 === undefined ||
-            context._currentRenderer2 === null ||
-            context._currentRenderer2 === rendererSigil,
-          'Detected multiple renderers concurrently rendering the ' +
-            'same context provider. This is currently unsupported.',
-        );
-        context._currentRenderer2 = rendererSigil;
-      }
+function pushProvider(providerFiber: Fiber): void {
+  const context: ReactContext<any> = providerFiber.type._context;
+
+  if (isPrimaryRenderer) {
+    push(changedBitsCursor, context._changedBits, providerFiber);
+    push(valueCursor, context._currentValue, providerFiber);
+    push(providerCursor, providerFiber, providerFiber);
+
+    context._currentValue = providerFiber.pendingProps.value;
+    context._changedBits = providerFiber.stateNode;
+    if (__DEV__) {
+      warning(
+        context._currentRenderer === undefined ||
+          context._currentRenderer === null ||
+          context._currentRenderer === rendererSigil,
+        'Detected multiple renderers concurrently rendering the ' +
+          'same context provider. This is currently unsupported.',
+      );
+      context._currentRenderer = rendererSigil;
     }
-  }
-
-  function popProvider(providerFiber: Fiber): void {
-    const changedBits = changedBitsCursor.current;
-    const currentValue = valueCursor.current;
-
-    pop(providerCursor, providerFiber);
-    pop(valueCursor, providerFiber);
-    pop(changedBitsCursor, providerFiber);
-
-    const context: ReactContext<any> = providerFiber.type._context;
-    if (isPrimaryRenderer) {
-      context._currentValue = currentValue;
-      context._changedBits = changedBits;
-    } else {
-      context._currentValue2 = currentValue;
-      context._changedBits2 = changedBits;
+  } else {
+    push(changedBitsCursor, context._changedBits2, providerFiber);
+    push(valueCursor, context._currentValue2, providerFiber);
+    push(providerCursor, providerFiber, providerFiber);
+
+    context._currentValue2 = providerFiber.pendingProps.value;
+    context._changedBits2 = providerFiber.stateNode;
+    if (__DEV__) {
+      warning(
+        context._currentRenderer2 === undefined ||
+          context._currentRenderer2 === null ||
+          context._currentRenderer2 === rendererSigil,
+        'Detected multiple renderers concurrently rendering the ' +
+          'same context provider. This is currently unsupported.',
+      );
+      context._currentRenderer2 = rendererSigil;
     }
   }
+}
 
-  function getContextCurrentValue(context: ReactContext<any>): any {
-    return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+function popProvider(providerFiber: Fiber): void {
+  const changedBits = changedBitsCursor.current;
+  const currentValue = valueCursor.current;
+
+  pop(providerCursor, providerFiber);
+  pop(valueCursor, providerFiber);
+  pop(changedBitsCursor, providerFiber);
+
+  const context: ReactContext<any> = providerFiber.type._context;
+  if (isPrimaryRenderer) {
+    context._currentValue = currentValue;
+    context._changedBits = changedBits;
+  } else {
+    context._currentValue2 = currentValue;
+    context._changedBits2 = changedBits;
   }
+}
 
-  function getContextChangedBits(context: ReactContext<any>): number {
-    return isPrimaryRenderer ? context._changedBits : context._changedBits2;
-  }
+function getContextCurrentValue(context: ReactContext<any>): any {
+  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+}
 
-  return {
-    pushProvider,
-    popProvider,
-    getContextCurrentValue,
-    getContextChangedBits,
-  };
+function getContextChangedBits(context: ReactContext<any>): number {
+  return isPrimaryRenderer ? context._changedBits : context._changedBits2;
 }
+
+export {
+  pushProvider,
+  popProvider,
+  getContextCurrentValue,
+  getContextChangedBits,
+};

commit aeda7b745d9c080150704feb20ea576238a1b9a1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jun 19 16:03:45 2018 +0100

    Remove fbjs dependency (#13069)
    
    * Inline fbjs/lib/invariant
    
    * Inline fbjs/lib/warning
    
    * Remove remaining usage of fbjs in packages/*.js
    
    * Fix lint
    
    * Remove fbjs from dependencies
    
    * Protect against accidental fbjs imports
    
    * Fix broken test mocks
    
    * Allow transitive deps on fbjs/ for UMD bundles
    
    * Remove fbjs from release script

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index f2715acfb2..4826412dde 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -18,7 +18,7 @@ export type NewContext = {
   getContextChangedBits(context: ReactContext<any>): number,
 };
 
-import warning from 'fbjs/lib/warning';
+import warning from 'shared/warning';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 

commit f9358c51c8de93abe3cdd0f4720b489befad8c48
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 22:31:59 2018 +0100

    Change warning() to automatically inject the stack, and add warningWithoutStack() as opt-out (#13161)
    
    * Use %s in the console calls
    
    * Add shared/warningWithStack
    
    * Convert some warning callsites to warningWithStack
    
    * Use warningInStack in shared utilities and remove unnecessary checks
    
    * Replace more warning() calls with warningWithStack()
    
    * Fixes after rebase + use warningWithStack in react
    
    * Make warning have stack by default; warningWithoutStack opts out
    
    * Forbid builds that may not use internals
    
    * Revert newly added stacks
    
    I changed my mind and want to keep this PR without functional changes. So we won't "fix" any warnings that are already missing stacks. We'll do it in follow-ups instead.
    
    * Fix silly find/replace mistake
    
    * Reorder imports
    
    * Add protection against warning argument count mismatches
    
    * Address review

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 4826412dde..729f7469e2 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -18,7 +18,7 @@ export type NewContext = {
   getContextChangedBits(context: ReactContext<any>): number,
 };
 
-import warning from 'shared/warning';
+import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 
@@ -43,7 +43,7 @@ function pushProvider(providerFiber: Fiber): void {
     context._currentValue = providerFiber.pendingProps.value;
     context._changedBits = providerFiber.stateNode;
     if (__DEV__) {
-      warning(
+      warningWithoutStack(
         context._currentRenderer === undefined ||
           context._currentRenderer === null ||
           context._currentRenderer === rendererSigil,
@@ -60,7 +60,7 @@ function pushProvider(providerFiber: Fiber): void {
     context._currentValue2 = providerFiber.pendingProps.value;
     context._changedBits2 = providerFiber.stateNode;
     if (__DEV__) {
-      warning(
+      warningWithoutStack(
         context._currentRenderer2 === undefined ||
           context._currentRenderer2 === null ||
           context._currentRenderer2 === rendererSigil,

commit 2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Jul 20 16:49:06 2018 -0700

    [Experimental] API for reading context from within any render phase function (#13139)
    
    * Store list of contexts on the fiber
    
    Currently, context can only be read by a special type of component,
    ContextConsumer. We want to add support to all fibers, including
    classes and functional components.
    
    Each fiber may read from one or more contexts. To enable quick, mono-
    morphic access of this list, we'll store them on a fiber property.
    
    * Context.unstable_read
    
    unstable_read can be called anywhere within the render phase. That
    includes the render method, getDerivedStateFromProps, constructors,
    functional components, and context consumer render props.
    
    If it's called outside the render phase, an error is thrown.
    
    * Remove vestigial context cursor
    
    Wasn't being used.
    
    * Split fiber.expirationTime into two separate fields
    
    Currently, the `expirationTime` field represents the pending work of
    both the fiber itself — including new props, state, and context — and of
    any updates in that fiber's subtree.
    
    This commit adds a second field called `childExpirationTime`. Now
    `expirationTime` only represents the pending work of the fiber itself.
    The subtree's pending work is represented by `childExpirationTime`.
    
    The biggest advantage is it requires fewer checks to bailout on already
    finished work. For most types of work, if the `expirationTime` does not
    match the render expiration time, we can bailout immediately without
    any further checks. This won't work for fibers that have
    `shouldComponentUpdate` semantics (class components), for which we still
    need to check for props and state changes explicitly.
    
    * Performance nits
    
    Optimize `readContext` for most common case

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 729f7469e2..a267df48bf 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -7,22 +7,26 @@
  * @flow
  */
 
-import type {Fiber} from './ReactFiber';
 import type {ReactContext} from 'shared/ReactTypes';
+import type {Fiber} from './ReactFiber';
 import type {StackCursor} from './ReactFiberStack';
+import type {ExpirationTime} from './ReactFiberExpirationTime';
 
-export type NewContext = {
-  pushProvider(providerFiber: Fiber): void,
-  popProvider(providerFiber: Fiber): void,
-  getContextCurrentValue(context: ReactContext<any>): any,
-  getContextChangedBits(context: ReactContext<any>): number,
+export type ContextDependency<T> = {
+  context: ReactContext<T>,
+  observedBits: number,
+  next: ContextDependency<mixed> | null,
 };
 
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
+import maxSigned31BitInt from './maxSigned31BitInt';
+import {NoWork} from './ReactFiberExpirationTime';
+import {ContextProvider} from 'shared/ReactTypeOfWork';
+
+import invariant from 'shared/invariant';
 
-const providerCursor: StackCursor<Fiber | null> = createCursor(null);
 const valueCursor: StackCursor<mixed> = createCursor(null);
 const changedBitsCursor: StackCursor<number> = createCursor(0);
 
@@ -32,13 +36,24 @@ if (__DEV__) {
   rendererSigil = {};
 }
 
-function pushProvider(providerFiber: Fiber): void {
+let currentlyRenderingFiber: Fiber | null = null;
+let lastContextDependency: ContextDependency<mixed> | null = null;
+let lastContext: ReactContext<any> | null = null;
+
+export function resetContextDependences(): void {
+  // This is called right before React yields execution, to ensure `readContext`
+  // cannot be called outside the render phase.
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContext = null;
+}
+
+export function pushProvider(providerFiber: Fiber): void {
   const context: ReactContext<any> = providerFiber.type._context;
 
   if (isPrimaryRenderer) {
     push(changedBitsCursor, context._changedBits, providerFiber);
     push(valueCursor, context._currentValue, providerFiber);
-    push(providerCursor, providerFiber, providerFiber);
 
     context._currentValue = providerFiber.pendingProps.value;
     context._changedBits = providerFiber.stateNode;
@@ -55,7 +70,6 @@ function pushProvider(providerFiber: Fiber): void {
   } else {
     push(changedBitsCursor, context._changedBits2, providerFiber);
     push(valueCursor, context._currentValue2, providerFiber);
-    push(providerCursor, providerFiber, providerFiber);
 
     context._currentValue2 = providerFiber.pendingProps.value;
     context._changedBits2 = providerFiber.stateNode;
@@ -72,11 +86,10 @@ function pushProvider(providerFiber: Fiber): void {
   }
 }
 
-function popProvider(providerFiber: Fiber): void {
+export function popProvider(providerFiber: Fiber): void {
   const changedBits = changedBitsCursor.current;
   const currentValue = valueCursor.current;
 
-  pop(providerCursor, providerFiber);
   pop(valueCursor, providerFiber);
   pop(changedBitsCursor, providerFiber);
 
@@ -90,17 +103,207 @@ function popProvider(providerFiber: Fiber): void {
   }
 }
 
-function getContextCurrentValue(context: ReactContext<any>): any {
-  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+export function propagateContextChange(
+  workInProgress: Fiber,
+  context: ReactContext<mixed>,
+  changedBits: number,
+  renderExpirationTime: ExpirationTime,
+): void {
+  let fiber = workInProgress.child;
+  if (fiber !== null) {
+    // Set the return pointer of the child to the work-in-progress fiber.
+    fiber.return = workInProgress;
+  }
+  while (fiber !== null) {
+    let nextFiber;
+
+    // Visit this fiber.
+    let dependency = fiber.firstContextDependency;
+    if (dependency !== null) {
+      do {
+        // Check if the context matches.
+        if (
+          dependency.context === context &&
+          (dependency.observedBits & changedBits) !== 0
+        ) {
+          // Match! Schedule an update on this fiber.
+          if (
+            fiber.expirationTime === NoWork ||
+            fiber.expirationTime > renderExpirationTime
+          ) {
+            fiber.expirationTime = renderExpirationTime;
+          }
+          let alternate = fiber.alternate;
+          if (
+            alternate !== null &&
+            (alternate.expirationTime === NoWork ||
+              alternate.expirationTime > renderExpirationTime)
+          ) {
+            alternate.expirationTime = renderExpirationTime;
+          }
+          // Update the child expiration time of all the ancestors, including
+          // the alternates.
+          let node = fiber.return;
+          while (node !== null) {
+            alternate = node.alternate;
+            if (
+              node.childExpirationTime === NoWork ||
+              node.childExpirationTime > renderExpirationTime
+            ) {
+              node.childExpirationTime = renderExpirationTime;
+              if (
+                alternate !== null &&
+                (alternate.childExpirationTime === NoWork ||
+                  alternate.childExpirationTime > renderExpirationTime)
+              ) {
+                alternate.childExpirationTime = renderExpirationTime;
+              }
+            } else if (
+              alternate !== null &&
+              (alternate.childExpirationTime === NoWork ||
+                alternate.childExpirationTime > renderExpirationTime)
+            ) {
+              alternate.childExpirationTime = renderExpirationTime;
+            } else {
+              // Neither alternate was updated, which means the rest of the
+              // ancestor path already has sufficient priority.
+              break;
+            }
+            node = node.return;
+          }
+          // Don't scan deeper than a matching consumer. When we render the
+          // consumer, we'll continue scanning from that point. This way the
+          // scanning work is time-sliced.
+          nextFiber = null;
+        } else {
+          nextFiber = fiber.child;
+        }
+        dependency = dependency.next;
+      } while (dependency !== null);
+    } else if (fiber.tag === ContextProvider) {
+      // Don't scan deeper if this is a matching provider
+      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
+    } else {
+      // Traverse down.
+      nextFiber = fiber.child;
+    }
+
+    if (nextFiber !== null) {
+      // Set the return pointer of the child to the work-in-progress fiber.
+      nextFiber.return = fiber;
+    } else {
+      // No child. Traverse to next sibling.
+      nextFiber = fiber;
+      while (nextFiber !== null) {
+        if (nextFiber === workInProgress) {
+          // We're back to the root of this subtree. Exit.
+          nextFiber = null;
+          break;
+        }
+        let sibling = nextFiber.sibling;
+        if (sibling !== null) {
+          // Set the return pointer of the sibling to the work-in-progress fiber.
+          sibling.return = nextFiber.return;
+          nextFiber = sibling;
+          break;
+        }
+        // No more siblings. Traverse up.
+        nextFiber = nextFiber.return;
+      }
+    }
+    fiber = nextFiber;
+  }
 }
 
-function getContextChangedBits(context: ReactContext<any>): number {
-  return isPrimaryRenderer ? context._changedBits : context._changedBits2;
+export function prepareToReadContext(
+  workInProgress: Fiber,
+  renderExpirationTime: ExpirationTime,
+): boolean {
+  currentlyRenderingFiber = workInProgress;
+  lastContextDependency = null;
+  lastContext = null;
+
+  const firstContextDependency = workInProgress.firstContextDependency;
+  if (firstContextDependency !== null) {
+    // Reset the work-in-progress list
+    workInProgress.firstContextDependency = null;
+
+    // Iterate through the context dependencies and see if there were any
+    // changes. If so, continue propagating the context change by scanning
+    // the child subtree.
+    let dependency = firstContextDependency;
+    let hasPendingContext = false;
+    do {
+      const context = dependency.context;
+      const changedBits = isPrimaryRenderer
+        ? context._changedBits
+        : context._changedBits2;
+      if (changedBits !== 0) {
+        // Resume context change propagation. We need to call this even if
+        // this fiber bails out, in case deeply nested consumers observe more
+        // bits than this one.
+        propagateContextChange(
+          workInProgress,
+          context,
+          changedBits,
+          renderExpirationTime,
+        );
+        if ((changedBits & dependency.observedBits) !== 0) {
+          hasPendingContext = true;
+        }
+      }
+      dependency = dependency.next;
+    } while (dependency !== null);
+    return hasPendingContext;
+  } else {
+    return false;
+  }
 }
 
-export {
-  pushProvider,
-  popProvider,
-  getContextCurrentValue,
-  getContextChangedBits,
-};
+export function readContext<T>(
+  context: ReactContext<T>,
+  observedBits: void | number | boolean,
+): T {
+  if (typeof observedBits !== 'number') {
+    if (observedBits === false) {
+      // Do not observe updates
+      observedBits = 0;
+    } else {
+      // Observe all updates
+      observedBits = maxSigned31BitInt;
+    }
+  }
+
+  if (lastContext === null) {
+    invariant(
+      currentlyRenderingFiber !== null,
+      'Context.unstable_read(): Context can only be read while React is ' +
+        'rendering, e.g. inside the render method or getDerivedStateFromProps.',
+    );
+    // This is the first dependency in the list
+    currentlyRenderingFiber.firstContextDependency = lastContextDependency = {
+      context: ((context: any): ReactContext<mixed>),
+      observedBits,
+      next: null,
+    };
+    lastContext = context;
+  } else {
+    // `lastContextDependency` is always non-null if `lastContext is.
+    const lastDependency: ContextDependency<T> = (lastContextDependency: any);
+    if (lastContext === context) {
+      // Fast path. The previous context has the same type. We can reuse
+      // the same node.
+      lastDependency.observedBits |= observedBits;
+    } else {
+      // Append a new context item.
+      lastContextDependency = lastDependency.next = {
+        context: ((context: any): ReactContext<mixed>),
+        observedBits,
+        next: null,
+      };
+      lastContext = context;
+    }
+  }
+
+  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+}

commit a32c727f2e24bc2e8b5f532420a52b1bae2f98af
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Jul 21 20:13:46 2018 -0700

    Optimize readContext for Subsequent Reads of All Bits (#13248)
    
    This is likely the common case because individual component authors
    will casually call read on common contexts like the cache, or cache
    provider.
    
    Where as libraries like Relay only call read once per fragment and pass
    all observed bits at once.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index a267df48bf..91d0b52826 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -38,14 +38,14 @@ if (__DEV__) {
 
 let currentlyRenderingFiber: Fiber | null = null;
 let lastContextDependency: ContextDependency<mixed> | null = null;
-let lastContext: ReactContext<any> | null = null;
+let lastContextWithAllBitsObserved: ReactContext<any> | null = null;
 
 export function resetContextDependences(): void {
   // This is called right before React yields execution, to ensure `readContext`
   // cannot be called outside the render phase.
   currentlyRenderingFiber = null;
   lastContextDependency = null;
-  lastContext = null;
+  lastContextWithAllBitsObserved = null;
 }
 
 export function pushProvider(providerFiber: Fiber): void {
@@ -221,7 +221,7 @@ export function prepareToReadContext(
 ): boolean {
   currentlyRenderingFiber = workInProgress;
   lastContextDependency = null;
-  lastContext = null;
+  lastContextWithAllBitsObserved = null;
 
   const firstContextDependency = workInProgress.firstContextDependency;
   if (firstContextDependency !== null) {
@@ -264,46 +264,41 @@ export function readContext<T>(
   context: ReactContext<T>,
   observedBits: void | number | boolean,
 ): T {
-  if (typeof observedBits !== 'number') {
-    if (observedBits === false) {
-      // Do not observe updates
-      observedBits = 0;
+  if (lastContextWithAllBitsObserved === context) {
+    // Nothing to do. We already observe everything in this context.
+  } else if (observedBits === false || observedBits === 0) {
+    // Do not observe any updates.
+  } else {
+    let resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.
+    if (
+      typeof observedBits !== 'number' ||
+      observedBits === maxSigned31BitInt
+    ) {
+      // Observe all updates.
+      lastContextWithAllBitsObserved = ((context: any): ReactContext<mixed>);
+      resolvedObservedBits = maxSigned31BitInt;
     } else {
-      // Observe all updates
-      observedBits = maxSigned31BitInt;
+      resolvedObservedBits = observedBits;
     }
-  }
 
-  if (lastContext === null) {
-    invariant(
-      currentlyRenderingFiber !== null,
-      'Context.unstable_read(): Context can only be read while React is ' +
-        'rendering, e.g. inside the render method or getDerivedStateFromProps.',
-    );
-    // This is the first dependency in the list
-    currentlyRenderingFiber.firstContextDependency = lastContextDependency = {
+    let contextItem = {
       context: ((context: any): ReactContext<mixed>),
-      observedBits,
+      observedBits: resolvedObservedBits,
       next: null,
     };
-    lastContext = context;
-  } else {
-    // `lastContextDependency` is always non-null if `lastContext is.
-    const lastDependency: ContextDependency<T> = (lastContextDependency: any);
-    if (lastContext === context) {
-      // Fast path. The previous context has the same type. We can reuse
-      // the same node.
-      lastDependency.observedBits |= observedBits;
+
+    if (lastContextDependency === null) {
+      invariant(
+        currentlyRenderingFiber !== null,
+        'Context.unstable_read(): Context can only be read while React is ' +
+          'rendering, e.g. inside the render method or getDerivedStateFromProps.',
+      );
+      // This is the first dependency in the list
+      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
     } else {
       // Append a new context item.
-      lastContextDependency = lastDependency.next = {
-        context: ((context: any): ReactContext<mixed>),
-        observedBits,
-        next: null,
-      };
-      lastContext = context;
+      lastContextDependency = lastContextDependency.next = contextItem;
     }
   }
-
   return isPrimaryRenderer ? context._currentValue : context._currentValue2;
 }

commit 2a2ef7e0fd86612404676b15bb3dd9df7ade536e
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Jul 27 13:42:17 2018 -0700

    Remove unnecessary branching from updateContextProvider (#13282)
    
    This code had gotten unnecessarily complex after some recent changes.
    Cleaned it up a bit.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 91d0b52826..e8f8e1b1e2 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -26,7 +26,9 @@ import {NoWork} from './ReactFiberExpirationTime';
 import {ContextProvider} from 'shared/ReactTypeOfWork';
 
 import invariant from 'shared/invariant';
+import warning from 'shared/warning';
 
+import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
 const valueCursor: StackCursor<mixed> = createCursor(null);
 const changedBitsCursor: StackCursor<number> = createCursor(0);
 
@@ -48,7 +50,7 @@ export function resetContextDependences(): void {
   lastContextWithAllBitsObserved = null;
 }
 
-export function pushProvider(providerFiber: Fiber): void {
+export function pushProvider(providerFiber: Fiber, changedBits: number): void {
   const context: ReactContext<any> = providerFiber.type._context;
 
   if (isPrimaryRenderer) {
@@ -56,7 +58,7 @@ export function pushProvider(providerFiber: Fiber): void {
     push(valueCursor, context._currentValue, providerFiber);
 
     context._currentValue = providerFiber.pendingProps.value;
-    context._changedBits = providerFiber.stateNode;
+    context._changedBits = changedBits;
     if (__DEV__) {
       warningWithoutStack(
         context._currentRenderer === undefined ||
@@ -72,7 +74,7 @@ export function pushProvider(providerFiber: Fiber): void {
     push(valueCursor, context._currentValue2, providerFiber);
 
     context._currentValue2 = providerFiber.pendingProps.value;
-    context._changedBits2 = providerFiber.stateNode;
+    context._changedBits2 = changedBits;
     if (__DEV__) {
       warningWithoutStack(
         context._currentRenderer2 === undefined ||
@@ -103,6 +105,39 @@ export function popProvider(providerFiber: Fiber): void {
   }
 }
 
+export function calculateChangedBits<T>(
+  context: ReactContext<T>,
+  newValue: T,
+  oldValue: T,
+) {
+  // Use Object.is to compare the new context value to the old value. Inlined
+  // Object.is polyfill.
+  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+  if (
+    (oldValue === newValue &&
+      (oldValue !== 0 || 1 / oldValue === 1 / (newValue: any))) ||
+    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare
+  ) {
+    // No change
+    return 0;
+  } else {
+    const changedBits =
+      typeof context._calculateChangedBits === 'function'
+        ? context._calculateChangedBits(oldValue, newValue)
+        : MAX_SIGNED_31_BIT_INT;
+
+    if (__DEV__) {
+      warning(
+        (changedBits & MAX_SIGNED_31_BIT_INT) === changedBits,
+        'calculateChangedBits: Expected the return value to be a ' +
+          '31-bit integer. Instead received: %s',
+        changedBits,
+      );
+    }
+    return changedBits | 0;
+  }
+}
+
 export function propagateContextChange(
   workInProgress: Fiber,
   context: ReactContext<mixed>,

commit 1bc975d073dd6f60217d645b43a84e79f96a216b
Author: Andrew Clark <acdlite@me.com>
Date:   Wed Aug 15 11:19:53 2018 -0700

    Don't stop context traversal at matching consumers (#13391)
    
    * Don't stop context traversal at matching consumers
    
    Originally, the idea was to time slice the traversal. This worked when
    there was only a single context type per consumer.
    
    Now that each fiber may have a list of context dependencies, including
    duplicate entries, that optimization no longer makes sense – we could
    end up scanning the same subtree multiple times.
    
    * Remove changedBits from context object and stack
    
    Don't need it anymore, yay

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index e8f8e1b1e2..39c190431f 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -23,14 +23,18 @@ import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import maxSigned31BitInt from './maxSigned31BitInt';
 import {NoWork} from './ReactFiberExpirationTime';
-import {ContextProvider} from 'shared/ReactTypeOfWork';
+import {ContextProvider, ClassComponent} from 'shared/ReactTypeOfWork';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';
+import {
+  createUpdate,
+  enqueueUpdate,
+  ForceUpdate,
+} from 'react-reconciler/src/ReactUpdateQueue';
 
 import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
 const valueCursor: StackCursor<mixed> = createCursor(null);
-const changedBitsCursor: StackCursor<number> = createCursor(0);
 
 let rendererSigil;
 if (__DEV__) {
@@ -50,15 +54,13 @@ export function resetContextDependences(): void {
   lastContextWithAllBitsObserved = null;
 }
 
-export function pushProvider(providerFiber: Fiber, changedBits: number): void {
-  const context: ReactContext<any> = providerFiber.type._context;
+export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
+  const context: ReactContext<T> = providerFiber.type._context;
 
   if (isPrimaryRenderer) {
-    push(changedBitsCursor, context._changedBits, providerFiber);
     push(valueCursor, context._currentValue, providerFiber);
 
-    context._currentValue = providerFiber.pendingProps.value;
-    context._changedBits = changedBits;
+    context._currentValue = nextValue;
     if (__DEV__) {
       warningWithoutStack(
         context._currentRenderer === undefined ||
@@ -70,11 +72,9 @@ export function pushProvider(providerFiber: Fiber, changedBits: number): void {
       context._currentRenderer = rendererSigil;
     }
   } else {
-    push(changedBitsCursor, context._changedBits2, providerFiber);
     push(valueCursor, context._currentValue2, providerFiber);
 
-    context._currentValue2 = providerFiber.pendingProps.value;
-    context._changedBits2 = changedBits;
+    context._currentValue2 = nextValue;
     if (__DEV__) {
       warningWithoutStack(
         context._currentRenderer2 === undefined ||
@@ -89,19 +89,15 @@ export function pushProvider(providerFiber: Fiber, changedBits: number): void {
 }
 
 export function popProvider(providerFiber: Fiber): void {
-  const changedBits = changedBitsCursor.current;
   const currentValue = valueCursor.current;
 
   pop(valueCursor, providerFiber);
-  pop(changedBitsCursor, providerFiber);
 
   const context: ReactContext<any> = providerFiber.type._context;
   if (isPrimaryRenderer) {
     context._currentValue = currentValue;
-    context._changedBits = changedBits;
   } else {
     context._currentValue2 = currentValue;
-    context._changedBits2 = changedBits;
   }
 }
 
@@ -162,6 +158,18 @@ export function propagateContextChange(
           (dependency.observedBits & changedBits) !== 0
         ) {
           // Match! Schedule an update on this fiber.
+
+          if (fiber.tag === ClassComponent) {
+            // Schedule a force update on the work-in-progress.
+            const update = createUpdate(renderExpirationTime);
+            update.tag = ForceUpdate;
+            // TODO: Because we don't have a work-in-progress, this will add the
+            // update to the current fiber, too, which means it will persist even if
+            // this render is thrown away. Since it's a race condition, not sure it's
+            // worth fixing.
+            enqueueUpdate(fiber, update);
+          }
+
           if (
             fiber.expirationTime === NoWork ||
             fiber.expirationTime > renderExpirationTime
@@ -206,13 +214,8 @@ export function propagateContextChange(
             }
             node = node.return;
           }
-          // Don't scan deeper than a matching consumer. When we render the
-          // consumer, we'll continue scanning from that point. This way the
-          // scanning work is time-sliced.
-          nextFiber = null;
-        } else {
-          nextFiber = fiber.child;
         }
+        nextFiber = fiber.child;
         dependency = dependency.next;
       } while (dependency !== null);
     } else if (fiber.tag === ContextProvider) {
@@ -253,46 +256,13 @@ export function propagateContextChange(
 export function prepareToReadContext(
   workInProgress: Fiber,
   renderExpirationTime: ExpirationTime,
-): boolean {
+): void {
   currentlyRenderingFiber = workInProgress;
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
 
-  const firstContextDependency = workInProgress.firstContextDependency;
-  if (firstContextDependency !== null) {
-    // Reset the work-in-progress list
-    workInProgress.firstContextDependency = null;
-
-    // Iterate through the context dependencies and see if there were any
-    // changes. If so, continue propagating the context change by scanning
-    // the child subtree.
-    let dependency = firstContextDependency;
-    let hasPendingContext = false;
-    do {
-      const context = dependency.context;
-      const changedBits = isPrimaryRenderer
-        ? context._changedBits
-        : context._changedBits2;
-      if (changedBits !== 0) {
-        // Resume context change propagation. We need to call this even if
-        // this fiber bails out, in case deeply nested consumers observe more
-        // bits than this one.
-        propagateContextChange(
-          workInProgress,
-          context,
-          changedBits,
-          renderExpirationTime,
-        );
-        if ((changedBits & dependency.observedBits) !== 0) {
-          hasPendingContext = true;
-        }
-      }
-      dependency = dependency.next;
-    } while (dependency !== null);
-    return hasPendingContext;
-  } else {
-    return false;
-  }
+  // Reset the work-in-progress list
+  workInProgress.firstContextDependency = null;
 }
 
 export function readContext<T>(

commit 5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Aug 16 09:21:59 2018 -0700

    Accept promise as element type (#13397)
    
    * Accept promise as element type
    
    On the initial render, the element will suspend as if a promise were
    thrown from inside the body of the unresolved component. Siblings should
    continue rendering and if the parent is a Placeholder, the promise
    should be captured by that Placeholder.
    
    When the promise resolves, rendering resumes. If the resolved value
    has a `default` property, it is assumed to be the default export of
    an ES module, and we use that as the component type. If it does not have
    a `default` property, we use the resolved value itself.
    
    The resolved value is stored as an expando on the promise/thenable.
    
    * Use special types of work for lazy components
    
    Because reconciliation is a hot path, this adds ClassComponentLazy,
    FunctionalComponentLazy, and ForwardRefLazy as special types of work.
    The other types are not supported, but wouldn't be placed into a
    separate module regardless.
    
    * Resolve defaultProps for lazy types
    
    * Remove some calls to isContextProvider
    
    isContextProvider checks the fiber tag, but it's typically called after
    we've already refined the type of work. We should get rid of it. I
    removed some of them in the previous commit, and deleted a few more
    in this one. I left a few behind because the remaining ones would
    require additional refactoring that feels outside the scope of this PR.
    
    * Remove getLazyComponentTypeIfResolved
    
    * Return baseProps instead of null
    
    The caller compares the result to baseProps to see if anything changed.
    
    * Avoid redundant checks by inlining getFiberTagFromObjectType
    
    * Move tag resolution to ReactFiber module
    
    * Pass next props to update* functions
    
    We should do this with all types of work in the future.
    
    * Refine component type before pushing/popping context
    
    Removes unnecessary checks.
    
    * Replace all occurrences of _reactResult with helper
    
    * Move shared thenable logic to `shared` package
    
    * Check type of wrapper object before resolving to `default` export
    
    * Return resolved tag instead of reassigning

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 39c190431f..06583cdd80 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -23,7 +23,11 @@ import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import maxSigned31BitInt from './maxSigned31BitInt';
 import {NoWork} from './ReactFiberExpirationTime';
-import {ContextProvider, ClassComponent} from 'shared/ReactTypeOfWork';
+import {
+  ContextProvider,
+  ClassComponent,
+  ClassComponentLazy,
+} from 'shared/ReactTypeOfWork';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';
@@ -159,7 +163,10 @@ export function propagateContextChange(
         ) {
           // Match! Schedule an update on this fiber.
 
-          if (fiber.tag === ClassComponent) {
+          if (
+            fiber.tag === ClassComponent ||
+            fiber.tag === ClassComponentLazy
+          ) {
             // Schedule a force update on the work-in-progress.
             const update = createUpdate(renderExpirationTime);
             update.tag = ForceUpdate;

commit 340bfd9393e8173adca5380e6587e1ea1a23cefa
Author: Sophie Alpert <git@sophiebits.com>
Date:   Sun Aug 26 13:40:27 2018 -0700

    Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)
    
    * Rename ReactTypeOfWork to ReactWorkTags
    
    And `type TypeOfWork` to `type WorkTag`.
    
    * Rename ReactTypeOfSideEffect too

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 06583cdd80..d28b42f821 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -27,7 +27,7 @@ import {
   ContextProvider,
   ClassComponent,
   ClassComponentLazy,
-} from 'shared/ReactTypeOfWork';
+} from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Héctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index d28b42f821..0de11bc0f2 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 7685b55d27c3932fd803230452cfd3d1ab076195
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Oct 16 14:58:00 2018 -0400

    Remove unstable_read() in favor of direct dispatcher call (#13861)
    
    * Remove unstable_read() in favor of direct dispatcher call
    
    * This no longer throws immediately

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 0de11bc0f2..fd4a739bfc 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -302,7 +302,7 @@ export function readContext<T>(
     if (lastContextDependency === null) {
       invariant(
         currentlyRenderingFiber !== null,
-        'Context.unstable_read(): Context can only be read while React is ' +
+        'Context can only be read while React is ' +
           'rendering, e.g. inside the render method or getDerivedStateFromProps.',
       );
       // This is the first dependency in the list

commit 95a313ec0b957f71798a69d8e83408f40e76765b
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Oct 19 22:22:45 2018 -0700

    Unfork Lazy Component Branches (#13902)
    
    * Introduce elementType field
    
    This will be used to store the wrapped type of an element. E.g. pure and
    lazy.
    
    The existing type field will be used for the unwrapped type within them.
    
    * Store the unwrapped type on the type field of lazy components
    
    * Use the raw tags for lazy components
    
    Instead, we check if the elementType and type are equal to test if
    we need to resolve props. This is slightly slower in the normal case
    but will yield less code and branching.
    
    * Clean up lazy branches
    
    * Collapse work tag numbering
    
    * Split IndeterminateComponent out from Lazy
    
    This way we don't have to check the type in a hacky way in the
    indeterminate path. Also, lets us deal with lazy that resolves to
    indeterminate and such.
    
    * Missing clean up in rebase

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index fd4a739bfc..44a6f73cac 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -23,11 +23,7 @@ import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import maxSigned31BitInt from './maxSigned31BitInt';
 import {NoWork} from './ReactFiberExpirationTime';
-import {
-  ContextProvider,
-  ClassComponent,
-  ClassComponentLazy,
-} from 'shared/ReactWorkTags';
+import {ContextProvider, ClassComponent} from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';
@@ -163,10 +159,7 @@ export function propagateContextChange(
         ) {
           // Match! Schedule an update on this fiber.
 
-          if (
-            fiber.tag === ClassComponent ||
-            fiber.tag === ClassComponentLazy
-          ) {
+          if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
             const update = createUpdate(renderExpirationTime);
             update.tag = ForceUpdate;

commit 04c4f2fcea0ba1496b5b20d0fca8d8d48d6ecf64
Author: yongningfu <535802703@qq.com>
Date:   Mon Oct 22 23:24:44 2018 +0800

    [reconciler] ReactFiberNewContext import maxSigned31BitInt twice (#13857)
    
    * [reconciler] ReactFiberNewContext import maxSigned31BitInt twice
    
    * rename maxSigned31BitInt to MAX_SIGNED_31_BIT_INT

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 44a6f73cac..582614e290 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -21,7 +21,7 @@ export type ContextDependency<T> = {
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
-import maxSigned31BitInt from './maxSigned31BitInt';
+import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
 import {NoWork} from './ReactFiberExpirationTime';
 import {ContextProvider, ClassComponent} from 'shared/ReactWorkTags';
 
@@ -33,7 +33,6 @@ import {
   ForceUpdate,
 } from 'react-reconciler/src/ReactUpdateQueue';
 
-import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
 let rendererSigil;
@@ -277,11 +276,11 @@ export function readContext<T>(
     let resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.
     if (
       typeof observedBits !== 'number' ||
-      observedBits === maxSigned31BitInt
+      observedBits === MAX_SIGNED_31_BIT_INT
     ) {
       // Observe all updates.
       lastContextWithAllBitsObserved = ((context: any): ReactContext<mixed>);
-      resolvedObservedBits = maxSigned31BitInt;
+      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
     } else {
       resolvedObservedBits = observedBits;
     }

commit 169f935f781c764a8c04f441c5e27b00a0329e8c
Author: Sophie Alpert <git@sophiebits.com>
Date:   Tue Oct 30 15:26:20 2018 -0700

    Flip expiration times (#13912)
    
    See https://github.com/facebook/react/pull/13912 commit messages for how this was done.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 582614e290..8af6bd09e0 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -22,7 +22,6 @@ import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
-import {NoWork} from './ReactFiberExpirationTime';
 import {ContextProvider, ClassComponent} from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
@@ -169,17 +168,13 @@ export function propagateContextChange(
             enqueueUpdate(fiber, update);
           }
 
-          if (
-            fiber.expirationTime === NoWork ||
-            fiber.expirationTime > renderExpirationTime
-          ) {
+          if (fiber.expirationTime < renderExpirationTime) {
             fiber.expirationTime = renderExpirationTime;
           }
           let alternate = fiber.alternate;
           if (
             alternate !== null &&
-            (alternate.expirationTime === NoWork ||
-              alternate.expirationTime > renderExpirationTime)
+            alternate.expirationTime < renderExpirationTime
           ) {
             alternate.expirationTime = renderExpirationTime;
           }
@@ -188,22 +183,17 @@ export function propagateContextChange(
           let node = fiber.return;
           while (node !== null) {
             alternate = node.alternate;
-            if (
-              node.childExpirationTime === NoWork ||
-              node.childExpirationTime > renderExpirationTime
-            ) {
+            if (node.childExpirationTime < renderExpirationTime) {
               node.childExpirationTime = renderExpirationTime;
               if (
                 alternate !== null &&
-                (alternate.childExpirationTime === NoWork ||
-                  alternate.childExpirationTime > renderExpirationTime)
+                alternate.childExpirationTime < renderExpirationTime
               ) {
                 alternate.childExpirationTime = renderExpirationTime;
               }
             } else if (
               alternate !== null &&
-              (alternate.childExpirationTime === NoWork ||
-                alternate.childExpirationTime > renderExpirationTime)
+              alternate.childExpirationTime < renderExpirationTime
             ) {
               alternate.childExpirationTime = renderExpirationTime;
             } else {

commit a9b035b0c2b8235405835beca0c4db2cc37f18d0
Author: Maksim Markelov <maks-markel@mail.ru>
Date:   Tue Jan 8 17:21:12 2019 +0300

    Separate Object.is polyfill (#14334)
    
    * Separate_Object_Is_Polyfill

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 8af6bd09e0..23439ff706 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -26,6 +26,7 @@ import {ContextProvider, ClassComponent} from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';
+import is from 'shared/objectIs';
 import {
   createUpdate,
   enqueueUpdate,
@@ -104,14 +105,7 @@ export function calculateChangedBits<T>(
   newValue: T,
   oldValue: T,
 ) {
-  // Use Object.is to compare the new context value to the old value. Inlined
-  // Object.is polyfill.
-  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-  if (
-    (oldValue === newValue &&
-      (oldValue !== 0 || 1 / oldValue === 1 / (newValue: any))) ||
-    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare
-  ) {
+  if (is(oldValue, newValue)) {
     // No change
     return 0;
   } else {

commit 790c8ef04195f0fc11ca3fb08e63f870f81483ac
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Jan 16 17:23:35 2019 -0800

    Allow useReducer to bail out of rendering by returning previous state (#14569)
    
    * Allow useReducer to bail out of rendering by returning previous state
    
    This is conceptually similar to `shouldComponentUpdate`, except because
    there could be multiple useReducer (or useState) Hooks in a single
    component, we can only bail out if none of the Hooks produce a new
    value. We also can't bail out if any the other types of inputs — state
    and context — have changed.
    
    These optimizations rely on the constraint that components are pure
    functions of props, state, and context.
    
    In some cases, we can bail out without entering the render phase by
    eagerly computing the next state and comparing it to the current one.
    This only works if we are absolutely certain that the queue is empty at
    the time of the update. In concurrent mode, this is difficult to
    determine, because there could be multiple copies of the queue and we
    don't know which one is current without doing lots of extra work, which
    would defeat the purpose of the optimization. However, in our
    implementation, there are at most only two copies of the queue, and if
    *both* are empty then we know that the current queue must be.
    
    * Add test for context consumers inside hidden subtree
    
    Should not bail out during subsequent update. (This isn't directly
    related to this PR because we should have had this test, anyway.)
    
    * Refactor to use module-level variable instead of effect bit
    
    * Add test combining state bailout and props bailout (memo)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 23439ff706..9687f40d7f 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -12,7 +12,12 @@ import type {Fiber} from './ReactFiber';
 import type {StackCursor} from './ReactFiberStack';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 
-export type ContextDependency<T> = {
+export type ContextDependencyList = {
+  first: ContextDependency<mixed>,
+  expirationTime: ExpirationTime,
+};
+
+type ContextDependency<T> = {
   context: ReactContext<T>,
   observedBits: number,
   next: ContextDependency<mixed> | null,
@@ -32,6 +37,8 @@ import {
   enqueueUpdate,
   ForceUpdate,
 } from 'react-reconciler/src/ReactUpdateQueue';
+import {NoWork} from './ReactFiberExpirationTime';
+import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
@@ -141,9 +148,12 @@ export function propagateContextChange(
     let nextFiber;
 
     // Visit this fiber.
-    let dependency = fiber.firstContextDependency;
-    if (dependency !== null) {
-      do {
+    const list = fiber.contextDependencies;
+    if (list !== null) {
+      nextFiber = fiber.child;
+
+      let dependency = list.first;
+      while (dependency !== null) {
         // Check if the context matches.
         if (
           dependency.context === context &&
@@ -197,10 +207,18 @@ export function propagateContextChange(
             }
             node = node.return;
           }
+
+          // Mark the expiration time on the list, too.
+          if (list.expirationTime < renderExpirationTime) {
+            list.expirationTime = renderExpirationTime;
+          }
+
+          // Since we already found a match, we can stop traversing the
+          // dependency list.
+          break;
         }
-        nextFiber = fiber.child;
         dependency = dependency.next;
-      } while (dependency !== null);
+      }
     } else if (fiber.tag === ContextProvider) {
       // Don't scan deeper if this is a matching provider
       nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
@@ -244,8 +262,17 @@ export function prepareToReadContext(
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
 
+  const currentDependencies = workInProgress.contextDependencies;
+  if (
+    currentDependencies !== null &&
+    currentDependencies.expirationTime >= renderExpirationTime
+  ) {
+    // Context list has a pending update. Mark that this fiber performed work.
+    markWorkInProgressReceivedUpdate();
+  }
+
   // Reset the work-in-progress list
-  workInProgress.firstContextDependency = null;
+  workInProgress.contextDependencies = null;
 }
 
 export function readContext<T>(
@@ -281,8 +308,13 @@ export function readContext<T>(
         'Context can only be read while React is ' +
           'rendering, e.g. inside the render method or getDerivedStateFromProps.',
       );
-      // This is the first dependency in the list
-      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
+
+      // This is the first dependency for this component. Create a new list.
+      lastContextDependency = contextItem;
+      currentlyRenderingFiber.contextDependencies = {
+        first: contextItem,
+        expirationTime: NoWork,
+      };
     } else {
       // Append a new context item.
       lastContextDependency = lastContextDependency.next = contextItem;

commit a129259ad6a61790fe1912a87cb45018d942f90c
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Jan 23 15:51:57 2019 +0000

    Disallow reading context during useMemo etc (#14653)
    
    * Revert "Revert "Double-render function components with Hooks in DEV in StrictMode" (#14652)"
    
    This reverts commit 3fbebb2a0b3b806f428c4154700af8e75e561895.
    
    * Revert "Revert "Disallow reading context during useMemo etc" (#14651)"
    
    This reverts commit 5fce6488ce1dc97e31515a47ff409d32ab722d65.
    
    * Add extra passing test for an edge case
    
    Mentioned by @acdlite to watch out for
    
    * More convoluted test
    
    * Don't rely on expirationTime
    
    Addresses @acdlite's concerns
    
    * Edge case: forbid readContext() during eager reducer

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 9687f40d7f..cbba426499 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -52,12 +52,37 @@ let currentlyRenderingFiber: Fiber | null = null;
 let lastContextDependency: ContextDependency<mixed> | null = null;
 let lastContextWithAllBitsObserved: ReactContext<any> | null = null;
 
+// We stash the variables above before entering user code in Hooks.
+let stashedCurrentlyRenderingFiber: Fiber | null = null;
+let stashedLastContextDependency: ContextDependency<mixed> | null = null;
+let stashedLastContextWithAllBitsObserved: ReactContext<any> | null = null;
+
 export function resetContextDependences(): void {
   // This is called right before React yields execution, to ensure `readContext`
   // cannot be called outside the render phase.
   currentlyRenderingFiber = null;
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
+
+  stashedCurrentlyRenderingFiber = null;
+  stashedLastContextDependency = null;
+  stashedLastContextWithAllBitsObserved = null;
+}
+
+export function stashContextDependencies(): void {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+}
+
+export function unstashContextDependencies(): void {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
 }
 
 export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {

commit f0befae657e2470f966235d2963179a9a1f948bd
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Jan 23 16:14:32 2019 +0000

    Tweak context invariant message (#14671)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index cbba426499..ac09ea2703 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -330,8 +330,10 @@ export function readContext<T>(
     if (lastContextDependency === null) {
       invariant(
         currentlyRenderingFiber !== null,
-        'Context can only be read while React is ' +
-          'rendering, e.g. inside the render method or getDerivedStateFromProps.',
+        'Context can only be read while React is rendering. ' +
+          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+          'In function components, you can read it directly in the function body, but not ' +
+          'inside Hooks like useReducer() or useMemo().',
       );
 
       // This is the first dependency for this component. Create a new list.

commit 8bcc88f2e7a7dc3e950bfcca1d3c6bbd251c4b20
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 24 19:31:20 2019 +0000

    Make all readContext() and Hook-in-a-Hook checks DEV-only (#14677)
    
    * Make readContext() in Hooks DEV-only warning
    
    * Warn about readContext() during class render-phase setState()
    
    * Warn on readContext() in SSR inside useMemo and useReducer
    
    * Make all Hooks-in-Hooks warnings DEV-only
    
    * Rename stashContextDependencies
    
    * Clean up warning state on errors

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index ac09ea2703..26530f0362 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -52,10 +52,7 @@ let currentlyRenderingFiber: Fiber | null = null;
 let lastContextDependency: ContextDependency<mixed> | null = null;
 let lastContextWithAllBitsObserved: ReactContext<any> | null = null;
 
-// We stash the variables above before entering user code in Hooks.
-let stashedCurrentlyRenderingFiber: Fiber | null = null;
-let stashedLastContextDependency: ContextDependency<mixed> | null = null;
-let stashedLastContextWithAllBitsObserved: ReactContext<any> | null = null;
+let isDisallowedContextReadInDEV: boolean = false;
 
 export function resetContextDependences(): void {
   // This is called right before React yields execution, to ensure `readContext`
@@ -63,26 +60,21 @@ export function resetContextDependences(): void {
   currentlyRenderingFiber = null;
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
-
-  stashedCurrentlyRenderingFiber = null;
-  stashedLastContextDependency = null;
-  stashedLastContextWithAllBitsObserved = null;
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = false;
+  }
 }
 
-export function stashContextDependencies(): void {
-  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
-  stashedLastContextDependency = lastContextDependency;
-  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
-
-  currentlyRenderingFiber = null;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
+export function enterDisallowedContextReadInDEV(): void {
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = true;
+  }
 }
 
-export function unstashContextDependencies(): void {
-  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
-  lastContextDependency = stashedLastContextDependency;
-  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+export function exitDisallowedContextReadInDEV(): void {
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = false;
+  }
 }
 
 export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
@@ -304,6 +296,18 @@ export function readContext<T>(
   context: ReactContext<T>,
   observedBits: void | number | boolean,
 ): T {
+  if (__DEV__) {
+    // This warning would fire if you read context inside a Hook like useMemo.
+    // Unlike the class check below, it's not enforced in production for perf.
+    warning(
+      !isDisallowedContextReadInDEV,
+      'Context can only be read while React is rendering. ' +
+        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+        'In function components, you can read it directly in the function body, but not ' +
+        'inside Hooks like useReducer() or useMemo().',
+    );
+  }
+
   if (lastContextWithAllBitsObserved === context) {
     // Nothing to do. We already observe everything in this context.
   } else if (observedBits === false || observedBits === 0) {

commit f3a14951ab9bccfd59ca977493b72321b24e50a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Feb 11 21:25:44 2019 -0800

    Partial Hydration (#14717)
    
    * Basic partial hydration test
    
    * Render comments around Suspense components
    
    We need this to be able to identify how far to skip ahead if we're not
    going to hydrate this subtree yet.
    
    * Add DehydratedSuspenseComponent type of work
    
    Will be used for Suspense boundaries that are left with their server
    rendered content intact.
    
    * Add comment node as hydratable instance type as placeholder for suspense
    
    * Skip past nodes within the Suspense boundary
    
    This lets us continue hydrating sibling nodes.
    
    * A dehydrated suspense boundary comment should be considered a sibling
    
    * Retry hydrating at offscreen pri or after ping if suspended
    
    * Enter hydration state when retrying dehydrated suspense boundary
    
    * Delete all children within a dehydrated suspense boundary when it's deleted
    
    * Delete server rendered content when props change before hydration completes
    
    * Make test internal
    
    * Wrap in act
    
    * Change SSR Fixture to use Partial Hydration
    
    This requires the enableSuspenseServerRenderer flag to be manually enabled
    for the build to work.
    
    * Changes to any parent Context forces clearing dehydrated content
    
    We mark dehydrated boundaries as having child work, since they might have
    components that read from the changed context.
    
    We check this in beginWork and if it does we treat it as if the input
    has changed (same as if props changes).
    
    * Wrap in feature flag
    
    * Treat Suspense boundaries without fallbacks as if not-boundaries
    
    These don't come into play for purposes of hydration.
    
    * Fix clearing of nested suspense boundaries
    
    * ping -> retry
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Typo
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Use didReceiveUpdate instead of manually comparing props
    
    * Leave comment for why it's ok to ignore the timeout

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 26530f0362..40d52147e5 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -27,7 +27,11 @@ import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
-import {ContextProvider, ClassComponent} from 'shared/ReactWorkTags';
+import {
+  ContextProvider,
+  ClassComponent,
+  DehydratedSuspenseComponent,
+} from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
 import warning from 'shared/warning';
@@ -39,6 +43,7 @@ import {
 } from 'react-reconciler/src/ReactUpdateQueue';
 import {NoWork} from './ReactFiberExpirationTime';
 import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
+import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
@@ -150,6 +155,37 @@ export function calculateChangedBits<T>(
   }
 }
 
+function scheduleWorkOnParentPath(
+  parent: Fiber | null,
+  renderExpirationTime: ExpirationTime,
+) {
+  // Update the child expiration time of all the ancestors, including
+  // the alternates.
+  let node = parent;
+  while (node !== null) {
+    let alternate = node.alternate;
+    if (node.childExpirationTime < renderExpirationTime) {
+      node.childExpirationTime = renderExpirationTime;
+      if (
+        alternate !== null &&
+        alternate.childExpirationTime < renderExpirationTime
+      ) {
+        alternate.childExpirationTime = renderExpirationTime;
+      }
+    } else if (
+      alternate !== null &&
+      alternate.childExpirationTime < renderExpirationTime
+    ) {
+      alternate.childExpirationTime = renderExpirationTime;
+    } else {
+      // Neither alternate was updated, which means the rest of the
+      // ancestor path already has sufficient priority.
+      break;
+    }
+    node = node.return;
+  }
+}
+
 export function propagateContextChange(
   workInProgress: Fiber,
   context: ReactContext<mixed>,
@@ -199,31 +235,8 @@ export function propagateContextChange(
           ) {
             alternate.expirationTime = renderExpirationTime;
           }
-          // Update the child expiration time of all the ancestors, including
-          // the alternates.
-          let node = fiber.return;
-          while (node !== null) {
-            alternate = node.alternate;
-            if (node.childExpirationTime < renderExpirationTime) {
-              node.childExpirationTime = renderExpirationTime;
-              if (
-                alternate !== null &&
-                alternate.childExpirationTime < renderExpirationTime
-              ) {
-                alternate.childExpirationTime = renderExpirationTime;
-              }
-            } else if (
-              alternate !== null &&
-              alternate.childExpirationTime < renderExpirationTime
-            ) {
-              alternate.childExpirationTime = renderExpirationTime;
-            } else {
-              // Neither alternate was updated, which means the rest of the
-              // ancestor path already has sufficient priority.
-              break;
-            }
-            node = node.return;
-          }
+
+          scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
 
           // Mark the expiration time on the list, too.
           if (list.expirationTime < renderExpirationTime) {
@@ -239,6 +252,29 @@ export function propagateContextChange(
     } else if (fiber.tag === ContextProvider) {
       // Don't scan deeper if this is a matching provider
       nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
+    } else if (
+      enableSuspenseServerRenderer &&
+      fiber.tag === DehydratedSuspenseComponent
+    ) {
+      // If a dehydrated suspense component is in this subtree, we don't know
+      // if it will have any context consumers in it. The best we can do is
+      // mark it as having updates on its children.
+      if (fiber.expirationTime < renderExpirationTime) {
+        fiber.expirationTime = renderExpirationTime;
+      }
+      let alternate = fiber.alternate;
+      if (
+        alternate !== null &&
+        alternate.expirationTime < renderExpirationTime
+      ) {
+        alternate.expirationTime = renderExpirationTime;
+      }
+      // This is intentionally passing this fiber as the parent
+      // because we want to schedule this fiber as having work
+      // on its children. We'll use the childExpirationTime on
+      // this fiber to indicate that a context has changed.
+      scheduleWorkOnParentPath(fiber, renderExpirationTime);
+      nextFiber = fiber.sibling;
     } else {
       // Traverse down.
       nextFiber = fiber.child;

commit 9c6de716d028f17736d0892d8a3d8f3ac2cb62bd
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu May 16 16:51:18 2019 -0700

    Add withSuspenseConfig API (#15593)
    
    * Add suspendIfNeeded API and a global scope to track it
    
    Adds a "current" suspense config that gets applied to all updates scheduled
    during the current scope.
    
    I suspect we might want to add other types of configurations to the "batch"
    so I called it the "batch config".
    
    This works across renderers/roots but they won't actually necessarily go
    into the same batch.
    
    * Add the suspenseConfig to all updates created during this scope
    
    * Compute expiration time based on the timeout of the suspense config
    
    * Track if there was a processed suspenseConfig this render pass
    
    We'll use this info to suspend a commit for longer when necessary.
    
    * Mark suspended states that should be avoided as a separate flag
    
    This lets us track which renders we want to suspend for a short time vs
    a longer time if possible.
    
    * Suspend until the full expiration time if something asked to suspend
    
    * Reenable an old test that we can now repro again
    
    * Suspend the commit even if it is complete if there is a minimum delay
    
    This can be used to implement spinners that don't flicker if the data
    and rendering is really fast.
    
    * Default timeoutMs to low pri expiration if not provided
    
    This is a required argument in the type signature but people may not
    supply it and this is a user facing object.
    
    * Rename to withSuspenseConfig and drop the default config
    
    This allow opting out of suspending in some nested scope.
    
    A lot of time when you use this function you'll use it with high level
    helpers. Those helpers often want to accept some additional configuration
    for suspense and if it should suspend at all. The easiest way is to just
    have the api accept null or a suspense config and pass it through. However,
    then you have to remember that calling suspendIfNeeded has a default.
    
    It gets simpler by just saying tat you can pass the config. You can have
    your own default in user space.
    
    * Track the largest suspense config expiration separately
    
    This ensures that if we've scheduled lower pri work that doesn't have a
    suspenseConfig, we don't consider its expiration as the timeout.
    
    * Add basic tests for functionality using each update mechanism
    
    * Fix issue when newly created avoided boundary doesn't suspend with delay
    
    * Add test for loading indicator with minLoadingDurationMs option

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 40d52147e5..12f941ad4f 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -216,7 +216,7 @@ export function propagateContextChange(
 
           if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
-            const update = createUpdate(renderExpirationTime);
+            const update = createUpdate(renderExpirationTime, null);
             update.tag = ForceUpdate;
             // TODO: Because we don't have a work-in-progress, this will add the
             // update to the current fiber, too, which means it will persist even if

commit f50f9ba5db4fd08693ad9d592bfe6f9ab1b5cdbf
Author: Maksim Markelov <maks-markel@mail.ru>
Date:   Wed May 22 13:24:31 2019 +0300

    Fix ReactFiberNewContext spelling (#15692)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 12f941ad4f..c0b10fabbd 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -59,7 +59,7 @@ let lastContextWithAllBitsObserved: ReactContext<any> | null = null;
 
 let isDisallowedContextReadInDEV: boolean = false;
 
-export function resetContextDependences(): void {
+export function resetContextDependencies(): void {
   // This is called right before React yields execution, to ensure `readContext`
   // cannot be called outside the render phase.
   currentlyRenderingFiber = null;

commit 76864f7ff729f8293e8e772da7ad8416d7def6b3
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Jun 19 19:34:28 2019 -0700

    Add SuspenseList Component (#15902)
    
    * Add SuspenseList component type
    
    * Push SuspenseContext for SuspenseList
    
    * Force Suspense boundaries into their fallback state
    
    In the "together" mode, we do a second render pass that forces the
    fallbacks to stay in place, if not all can unsuspend at once.
    
    * Add test
    
    * Transfer thennables to the SuspenseList
    
    This way, we end up retrying the SuspenseList in case the nested boundary
    that just suspended doesn't actually get mounted with this set of
    thennables. This happens when the second pass renders the fallback
    directly without first attempting to render the content.
    
    * Add warning for unsupported displayOrder
    
    * Add tests for nested sibling boundaries and nested lists
    
    * Fix nested SuspenseList forwarding thennables
    
    * Rename displayOrder to revealOrder
    
    Display order has some "display list" connotations making it sound like
    a z-index thing.
    
    Reveal indicates that this isn't really about when something gets rendered
    or is ready to be rendered. It's about when content that is already there
    gets to be revealed.
    
    * Add test for avoided boundaries
    
    * Make SuspenseList a noop in legacy mode
    
    * Use an explicit suspense list state object
    
    This will be used for more things in the directional case.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index c0b10fabbd..d6c213debf 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -155,7 +155,7 @@ export function calculateChangedBits<T>(
   }
 }
 
-function scheduleWorkOnParentPath(
+export function scheduleWorkOnParentPath(
   parent: Fiber | null,
   renderExpirationTime: ExpirationTime,
 ) {

commit 720db4cbe675e80820ec81abab499492309b9252
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Fri Jun 21 03:12:40 2019 +0100

    [Flare] Add useEvent hook implementation (#15927)
    
    * [Flare] Add useEvent hook implementation
    
    Validate hooks have decendent event components
    
    Few fixes and displayName changes
    
    Fix more responder bugs
    
    Update error codes
    
    * Add another test
    
    * Address feedback

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index d6c213debf..6837235751 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -12,12 +12,7 @@ import type {Fiber} from './ReactFiber';
 import type {StackCursor} from './ReactFiberStack';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 
-export type ContextDependencyList = {
-  first: ContextDependency<mixed>,
-  expirationTime: ExpirationTime,
-};
-
-type ContextDependency<T> = {
+export type ContextDependency<T> = {
   context: ReactContext<T>,
   observedBits: number,
   next: ContextDependency<mixed> | null,
@@ -201,11 +196,12 @@ export function propagateContextChange(
     let nextFiber;
 
     // Visit this fiber.
-    const list = fiber.contextDependencies;
+    const dependencies = fiber.dependencies;
+    const list = dependencies.firstContext;
     if (list !== null) {
       nextFiber = fiber.child;
 
-      let dependency = list.first;
+      let dependency = list;
       while (dependency !== null) {
         // Check if the context matches.
         if (
@@ -239,8 +235,8 @@ export function propagateContextChange(
           scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
 
           // Mark the expiration time on the list, too.
-          if (list.expirationTime < renderExpirationTime) {
-            list.expirationTime = renderExpirationTime;
+          if (dependencies.expirationTime < renderExpirationTime) {
+            dependencies.expirationTime = renderExpirationTime;
           }
 
           // Since we already found a match, we can stop traversing the
@@ -315,17 +311,18 @@ export function prepareToReadContext(
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
 
-  const currentDependencies = workInProgress.contextDependencies;
+  const dependencies = workInProgress.dependencies;
+  const firstContext = dependencies.firstContext;
   if (
-    currentDependencies !== null &&
-    currentDependencies.expirationTime >= renderExpirationTime
+    firstContext !== null &&
+    dependencies.expirationTime >= renderExpirationTime
   ) {
     // Context list has a pending update. Mark that this fiber performed work.
     markWorkInProgressReceivedUpdate();
   }
 
   // Reset the work-in-progress list
-  workInProgress.contextDependencies = null;
+  dependencies.firstContext = null;
 }
 
 export function readContext<T>(
@@ -378,10 +375,9 @@ export function readContext<T>(
 
       // This is the first dependency for this component. Create a new list.
       lastContextDependency = contextItem;
-      currentlyRenderingFiber.contextDependencies = {
-        first: contextItem,
-        expirationTime: NoWork,
-      };
+      const dependencies = currentlyRenderingFiber.dependencies;
+      dependencies.expirationTime = NoWork;
+      dependencies.firstContext = contextItem;
     } else {
       // Append a new context item.
       lastContextDependency = lastContextDependency.next = contextItem;

commit 175111de723979161b73c2751c3396d22f405dfa
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 20 20:12:22 2019 -0700

    Lazily initialize dependencies object (#15944)
    
    Most fibers do not have events or context, so we save memory lazily
    initializing this container node.
    
    Follow-up from #15927

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 6837235751..a77377696f 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -196,12 +196,11 @@ export function propagateContextChange(
     let nextFiber;
 
     // Visit this fiber.
-    const dependencies = fiber.dependencies;
-    const list = dependencies.firstContext;
+    const list = fiber.dependencies;
     if (list !== null) {
       nextFiber = fiber.child;
 
-      let dependency = list;
+      let dependency = list.firstContext;
       while (dependency !== null) {
         // Check if the context matches.
         if (
@@ -235,8 +234,8 @@ export function propagateContextChange(
           scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
 
           // Mark the expiration time on the list, too.
-          if (dependencies.expirationTime < renderExpirationTime) {
-            dependencies.expirationTime = renderExpirationTime;
+          if (list.expirationTime < renderExpirationTime) {
+            list.expirationTime = renderExpirationTime;
           }
 
           // Since we already found a match, we can stop traversing the
@@ -312,17 +311,17 @@ export function prepareToReadContext(
   lastContextWithAllBitsObserved = null;
 
   const dependencies = workInProgress.dependencies;
-  const firstContext = dependencies.firstContext;
-  if (
-    firstContext !== null &&
-    dependencies.expirationTime >= renderExpirationTime
-  ) {
-    // Context list has a pending update. Mark that this fiber performed work.
-    markWorkInProgressReceivedUpdate();
+  if (dependencies !== null) {
+    const firstContext = dependencies.firstContext;
+    if (firstContext !== null) {
+      if (dependencies.expirationTime >= renderExpirationTime) {
+        // Context list has a pending update. Mark that this fiber performed work.
+        markWorkInProgressReceivedUpdate();
+      }
+      // Reset the work-in-progress list
+      dependencies.firstContext = null;
+    }
   }
-
-  // Reset the work-in-progress list
-  dependencies.firstContext = null;
 }
 
 export function readContext<T>(
@@ -375,9 +374,11 @@ export function readContext<T>(
 
       // This is the first dependency for this component. Create a new list.
       lastContextDependency = contextItem;
-      const dependencies = currentlyRenderingFiber.dependencies;
-      dependencies.expirationTime = NoWork;
-      dependencies.firstContext = contextItem;
+      currentlyRenderingFiber.dependencies = {
+        expirationTime: NoWork,
+        firstContext: contextItem,
+        events: null,
+      };
     } else {
       // Append a new context item.
       lastContextDependency = lastContextDependency.next = contextItem;

commit 509889119360ed83ca6ef3f83bcf01e5aa7dcd81
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Jul 23 23:46:44 2019 +0100

    [Flare] Redesign core event system (#16163)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index a77377696f..c02b482d1d 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -377,7 +377,8 @@ export function readContext<T>(
       currentlyRenderingFiber.dependencies = {
         expirationTime: NoWork,
         firstContext: contextItem,
-        events: null,
+        listeners: null,
+        responders: null,
       };
     } else {
       // Append a new context item.

commit 42794557ca44a8c05c71aab698d44d1294236538
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Aug 1 19:08:54 2019 +0100

    [Flare] Tweaks to Flare system design and API (#16264)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index c02b482d1d..35540c2ca8 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -377,7 +377,6 @@ export function readContext<T>(
       currentlyRenderingFiber.dependencies = {
         expirationTime: NoWork,
         firstContext: contextItem,
-        listeners: null,
         responders: null,
       };
     } else {

commit 50addf4c0e411e351de7290c8c60ec775c25c8c4
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Aug 12 15:58:38 2019 -0700

    Refactor Partial Hydration (#16346)
    
    * Move dehydrated to be child of regular SuspenseComponent
    
    We now store the comment node on SuspenseState instead and that indicates
    that this SuspenseComponent is still dehydrated.
    
    We also store a child but that is only used to represent the DOM node for
    deletions and getNextHostSibling.
    
    * Move logic from DehydratedSuspenseComponent to SuspenseComponent
    
    Forked based on SuspenseState.dehydrated instead.
    
    * Retry logic for dehydrated boundary
    
    We can now simplify the logic for retrying dehydrated boundaries without
    hydrating. This is becomes simply a reconciliation against the dehydrated
    fragment which gets deleted, and the new children gets inserted.
    
    * Remove dehydrated from throw
    
    Instead we use the regular Suspense path. To save code, we attach retry
    listeners in the commit phase even though technically we don't have to.
    
    * Pop to nearest Suspense
    
    I think this is right...?
    
    * Popping hydration state should skip past the dehydrated instance
    
    * Split mount from update and special case suspended second pass
    
    The DidCapture flag isn't used consistently in the same way. We need
    further refactor for this.
    
    * Reorganize update path
    
    If we remove the dehydration status in the first pass and then do a second
    pass because we suspended, then we need to continue as if it didn't
    previously suspend. Since there is no fragment child etc.
    
    However, we must readd the deletion.
    
    * Schedule context work on the boundary and not the child
    
    * Warn for Suspense hydration in legacy mode
    
    It does a two pass render that client renders the content.
    
    * Rename DehydratedSuspenseComponent -> DehydratedFragment
    
    This now doesn't represent a suspense boundary itself. Its parent does.
    
    This Fiber represents the fragment around the dehydrated content.
    
    * Refactor returns
    
    Avoids the temporary mutable variables. I kept losing track of them.
    
    * Add a comment explaining the type.
    
    Placing it in the type since that's the central point as opposed to spread
    out.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 35540c2ca8..1839283ba6 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -25,7 +25,7 @@ import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
 import {
   ContextProvider,
   ClassComponent,
-  DehydratedSuspenseComponent,
+  DehydratedFragment,
 } from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
@@ -249,15 +249,20 @@ export function propagateContextChange(
       nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
     } else if (
       enableSuspenseServerRenderer &&
-      fiber.tag === DehydratedSuspenseComponent
+      fiber.tag === DehydratedFragment
     ) {
-      // If a dehydrated suspense component is in this subtree, we don't know
+      // If a dehydrated suspense bounudary is in this subtree, we don't know
       // if it will have any context consumers in it. The best we can do is
-      // mark it as having updates on its children.
-      if (fiber.expirationTime < renderExpirationTime) {
-        fiber.expirationTime = renderExpirationTime;
+      // mark it as having updates.
+      let parentSuspense = fiber.return;
+      invariant(
+        parentSuspense !== null,
+        'We just came from a parent so we must have had a parent. This is a bug in React.',
+      );
+      if (parentSuspense.expirationTime < renderExpirationTime) {
+        parentSuspense.expirationTime = renderExpirationTime;
       }
-      let alternate = fiber.alternate;
+      let alternate = parentSuspense.alternate;
       if (
         alternate !== null &&
         alternate.expirationTime < renderExpirationTime
@@ -268,7 +273,7 @@ export function propagateContextChange(
       // because we want to schedule this fiber as having work
       // on its children. We'll use the childExpirationTime on
       // this fiber to indicate that a context has changed.
-      scheduleWorkOnParentPath(fiber, renderExpirationTime);
+      scheduleWorkOnParentPath(parentSuspense, renderExpirationTime);
       nextFiber = fiber.sibling;
     } else {
       // Traverse down.

commit 9ac42dd074c42b66ecc0334b75200b1d2989f892
Author: Laura buns <walaura@fb.com>
Date:   Wed Dec 11 03:28:14 2019 +0000

    Remove the condition argument from warning() (#17568)
    
    * prep for codemod
    
    * prep warnings
    
    * rename lint rules
    
    * codemod for ifs
    
    * shim www functions
    
    * Handle more cases in the transform
    
    * Thanks De Morgan
    
    * Run the codemod
    
    * Delete the transform
    
    * Fix up confusing conditions manually
    
    * Fix up www shims to match expected API
    
    * Also check for low-pri warning in the lint rule

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 1839283ba6..37a6997729 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -85,13 +85,16 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
 
     context._currentValue = nextValue;
     if (__DEV__) {
-      warningWithoutStack(
-        context._currentRenderer === undefined ||
-          context._currentRenderer === null ||
-          context._currentRenderer === rendererSigil,
-        'Detected multiple renderers concurrently rendering the ' +
-          'same context provider. This is currently unsupported.',
-      );
+      if (
+        context._currentRenderer !== undefined &&
+        context._currentRenderer !== null &&
+        context._currentRenderer !== rendererSigil
+      ) {
+        warningWithoutStack(
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+      }
       context._currentRenderer = rendererSigil;
     }
   } else {
@@ -99,13 +102,16 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
 
     context._currentValue2 = nextValue;
     if (__DEV__) {
-      warningWithoutStack(
-        context._currentRenderer2 === undefined ||
-          context._currentRenderer2 === null ||
-          context._currentRenderer2 === rendererSigil,
-        'Detected multiple renderers concurrently rendering the ' +
-          'same context provider. This is currently unsupported.',
-      );
+      if (
+        context._currentRenderer2 !== undefined &&
+        context._currentRenderer2 !== null &&
+        context._currentRenderer2 !== rendererSigil
+      ) {
+        warningWithoutStack(
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+      }
       context._currentRenderer2 = rendererSigil;
     }
   }
@@ -139,12 +145,13 @@ export function calculateChangedBits<T>(
         : MAX_SIGNED_31_BIT_INT;
 
     if (__DEV__) {
-      warning(
-        (changedBits & MAX_SIGNED_31_BIT_INT) === changedBits,
-        'calculateChangedBits: Expected the return value to be a ' +
-          '31-bit integer. Instead received: %s',
-        changedBits,
-      );
+      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
+        warning(
+          'calculateChangedBits: Expected the return value to be a ' +
+            '31-bit integer. Instead received: %s',
+          changedBits,
+        );
+      }
     }
     return changedBits | 0;
   }
@@ -336,13 +343,14 @@ export function readContext<T>(
   if (__DEV__) {
     // This warning would fire if you read context inside a Hook like useMemo.
     // Unlike the class check below, it's not enforced in production for perf.
-    warning(
-      !isDisallowedContextReadInDEV,
-      'Context can only be read while React is rendering. ' +
-        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-        'In function components, you can read it directly in the function body, but not ' +
-        'inside Hooks like useReducer() or useMemo().',
-    );
+    if (isDisallowedContextReadInDEV) {
+      warning(
+        'Context can only be read while React is rendering. ' +
+          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+          'In function components, you can read it directly in the function body, but not ' +
+          'inside Hooks like useReducer() or useMemo().',
+      );
+    }
   }
 
   if (lastContextWithAllBitsObserved === context) {

commit b15bf36750ca4c4a5a09f2de76c5315ded1258d0
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 12 23:47:55 2019 +0000

    Add component stacks to (almost) all warnings (#17586)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 37a6997729..dcc75e06a5 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -18,7 +18,6 @@ export type ContextDependency<T> = {
   next: ContextDependency<mixed> | null,
 };
 
-import warningWithoutStack from 'shared/warningWithoutStack';
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
@@ -90,7 +89,7 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
         context._currentRenderer !== null &&
         context._currentRenderer !== rendererSigil
       ) {
-        warningWithoutStack(
+        warning(
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',
         );
@@ -107,7 +106,7 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
         context._currentRenderer2 !== null &&
         context._currentRenderer2 !== rendererSigil
       ) {
-        warningWithoutStack(
+        warning(
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',
         );

commit 0cf22a56a18790ef34c71bef14f64695c0498619
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat Dec 14 18:09:25 2019 +0000

    Use console directly instead of warning() modules (#17599)
    
    * Replace all warning/lowPriWarning with console calls
    
    * Replace console.warn/error with a custom wrapper at build time
    
    * Fail the build for console.error/warn() where we can't read the stack

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index dcc75e06a5..ac7fdd7985 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -28,7 +28,6 @@ import {
 } from 'shared/ReactWorkTags';
 
 import invariant from 'shared/invariant';
-import warning from 'shared/warning';
 import is from 'shared/objectIs';
 import {
   createUpdate,
@@ -89,7 +88,7 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
         context._currentRenderer !== null &&
         context._currentRenderer !== rendererSigil
       ) {
-        warning(
+        console.error(
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',
         );
@@ -106,7 +105,7 @@ export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
         context._currentRenderer2 !== null &&
         context._currentRenderer2 !== rendererSigil
       ) {
-        warning(
+        console.error(
           'Detected multiple renderers concurrently rendering the ' +
             'same context provider. This is currently unsupported.',
         );
@@ -145,7 +144,7 @@ export function calculateChangedBits<T>(
 
     if (__DEV__) {
       if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
-        warning(
+        console.error(
           'calculateChangedBits: Expected the return value to be a ' +
             '31-bit integer. Instead received: %s',
           changedBits,
@@ -343,7 +342,7 @@ export function readContext<T>(
     // This warning would fire if you read context inside a Hook like useMemo.
     // Unlike the class check below, it's not enforced in production for perf.
     if (isDisallowedContextReadInDEV) {
-      warning(
+      console.error(
         'Context can only be read while React is rendering. ' +
           'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
           'In function components, you can read it directly in the function body, but not ' +

commit e706721490e50d0bd6af2cd933dbf857fd8b61ed
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 14:50:44 2020 +0000

    Update Flow to 0.84 (#17805)
    
    * Update Flow to 0.84
    
    * Fix violations
    
    * Use inexact object syntax in files from fbsource
    
    * Fix warning extraction to use a modern parser
    
    * Codemod inexact objects to new syntax
    
    * Tighten types that can be exact
    
    * Revert unintentional formatting changes from codemod

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index ac7fdd7985..510c1eb674 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -16,6 +16,7 @@ export type ContextDependency<T> = {
   context: ReactContext<T>,
   observedBits: number,
   next: ContextDependency<mixed> | null,
+  ...
 };
 
 import {isPrimaryRenderer} from './ReactFiberHostConfig';

commit c5d2fc7127654e43de59fff865b74765a103c4a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 21 15:22:01 2020 -0700

    Move some files out of /shared and rename to upper case (#18363)
    
    * Rename lower case isomorphic default exports modules to upper case named exports
    
    We're somewhat inconsistent here between e.g. ReactLazy and memo.
    
    Let's pick one.
    
    This also moves the responder, fundamental, scope creators from shared
    since they're isomorphic and same as the other creators.
    
    * Move some files that are specific to the react-reconciler from shared
    
    Individual renderers are allowed to deep require into the reconciler.
    
    * Move files specific to react-dom from shared
    
    react-interactions is right now dom specific (it wasn't before) so we can
    type check it together with other dom stuff. Avoids the need for
    a shared ReactDOMTypes to be checked by RN for example.
    
    * Move ReactWorkTags to the reconciler
    
    * Move createPortal to export from reconciler
    
    Otherwise Noop can't access it since it's not allowed deep requires.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 510c1eb674..ba0ffc34cb 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -21,12 +21,12 @@ export type ContextDependency<T> = {
 
 import {isPrimaryRenderer} from './ReactFiberHostConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
-import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';
+import {MAX_SIGNED_31_BIT_INT} from './MaxInts';
 import {
   ContextProvider,
   ClassComponent,
   DehydratedFragment,
-} from 'shared/ReactWorkTags';
+} from './ReactWorkTags';
 
 import invariant from 'shared/invariant';
 import is from 'shared/objectIs';

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index ba0ffc34cb..ef23f68dfa 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -164,7 +164,7 @@ export function scheduleWorkOnParentPath(
   // the alternates.
   let node = parent;
   while (node !== null) {
-    let alternate = node.alternate;
+    const alternate = node.alternate;
     if (node.childExpirationTime < renderExpirationTime) {
       node.childExpirationTime = renderExpirationTime;
       if (
@@ -229,7 +229,7 @@ export function propagateContextChange(
           if (fiber.expirationTime < renderExpirationTime) {
             fiber.expirationTime = renderExpirationTime;
           }
-          let alternate = fiber.alternate;
+          const alternate = fiber.alternate;
           if (
             alternate !== null &&
             alternate.expirationTime < renderExpirationTime
@@ -260,7 +260,7 @@ export function propagateContextChange(
       // If a dehydrated suspense bounudary is in this subtree, we don't know
       // if it will have any context consumers in it. The best we can do is
       // mark it as having updates.
-      let parentSuspense = fiber.return;
+      const parentSuspense = fiber.return;
       invariant(
         parentSuspense !== null,
         'We just came from a parent so we must have had a parent. This is a bug in React.',
@@ -268,7 +268,7 @@ export function propagateContextChange(
       if (parentSuspense.expirationTime < renderExpirationTime) {
         parentSuspense.expirationTime = renderExpirationTime;
       }
-      let alternate = parentSuspense.alternate;
+      const alternate = parentSuspense.alternate;
       if (
         alternate !== null &&
         alternate.expirationTime < renderExpirationTime
@@ -298,7 +298,7 @@ export function propagateContextChange(
           nextFiber = null;
           break;
         }
-        let sibling = nextFiber.sibling;
+        const sibling = nextFiber.sibling;
         if (sibling !== null) {
           // Set the return pointer of the sibling to the work-in-progress fiber.
           sibling.return = nextFiber.return;
@@ -369,7 +369,7 @@ export function readContext<T>(
       resolvedObservedBits = observedBits;
     }
 
-    let contextItem = {
+    const contextItem = {
       context: ((context: any): ReactContext<mixed>),
       observedBits: resolvedObservedBits,
       next: null,

commit d686f3f16a796025ce32cfb431b70eef6de1934e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 19:44:52 2020 -0700

    Add `.old` prefix to reconciler modules

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
deleted file mode 100644
index ef23f68dfa..0000000000
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ /dev/null
@@ -1,400 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- */
-
-import type {ReactContext} from 'shared/ReactTypes';
-import type {Fiber} from './ReactFiber';
-import type {StackCursor} from './ReactFiberStack';
-import type {ExpirationTime} from './ReactFiberExpirationTime';
-
-export type ContextDependency<T> = {
-  context: ReactContext<T>,
-  observedBits: number,
-  next: ContextDependency<mixed> | null,
-  ...
-};
-
-import {isPrimaryRenderer} from './ReactFiberHostConfig';
-import {createCursor, push, pop} from './ReactFiberStack';
-import {MAX_SIGNED_31_BIT_INT} from './MaxInts';
-import {
-  ContextProvider,
-  ClassComponent,
-  DehydratedFragment,
-} from './ReactWorkTags';
-
-import invariant from 'shared/invariant';
-import is from 'shared/objectIs';
-import {
-  createUpdate,
-  enqueueUpdate,
-  ForceUpdate,
-} from 'react-reconciler/src/ReactUpdateQueue';
-import {NoWork} from './ReactFiberExpirationTime';
-import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
-import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
-
-const valueCursor: StackCursor<mixed> = createCursor(null);
-
-let rendererSigil;
-if (__DEV__) {
-  // Use this to detect multiple renderers using the same context
-  rendererSigil = {};
-}
-
-let currentlyRenderingFiber: Fiber | null = null;
-let lastContextDependency: ContextDependency<mixed> | null = null;
-let lastContextWithAllBitsObserved: ReactContext<any> | null = null;
-
-let isDisallowedContextReadInDEV: boolean = false;
-
-export function resetContextDependencies(): void {
-  // This is called right before React yields execution, to ensure `readContext`
-  // cannot be called outside the render phase.
-  currentlyRenderingFiber = null;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
-  if (__DEV__) {
-    isDisallowedContextReadInDEV = false;
-  }
-}
-
-export function enterDisallowedContextReadInDEV(): void {
-  if (__DEV__) {
-    isDisallowedContextReadInDEV = true;
-  }
-}
-
-export function exitDisallowedContextReadInDEV(): void {
-  if (__DEV__) {
-    isDisallowedContextReadInDEV = false;
-  }
-}
-
-export function pushProvider<T>(providerFiber: Fiber, nextValue: T): void {
-  const context: ReactContext<T> = providerFiber.type._context;
-
-  if (isPrimaryRenderer) {
-    push(valueCursor, context._currentValue, providerFiber);
-
-    context._currentValue = nextValue;
-    if (__DEV__) {
-      if (
-        context._currentRenderer !== undefined &&
-        context._currentRenderer !== null &&
-        context._currentRenderer !== rendererSigil
-      ) {
-        console.error(
-          'Detected multiple renderers concurrently rendering the ' +
-            'same context provider. This is currently unsupported.',
-        );
-      }
-      context._currentRenderer = rendererSigil;
-    }
-  } else {
-    push(valueCursor, context._currentValue2, providerFiber);
-
-    context._currentValue2 = nextValue;
-    if (__DEV__) {
-      if (
-        context._currentRenderer2 !== undefined &&
-        context._currentRenderer2 !== null &&
-        context._currentRenderer2 !== rendererSigil
-      ) {
-        console.error(
-          'Detected multiple renderers concurrently rendering the ' +
-            'same context provider. This is currently unsupported.',
-        );
-      }
-      context._currentRenderer2 = rendererSigil;
-    }
-  }
-}
-
-export function popProvider(providerFiber: Fiber): void {
-  const currentValue = valueCursor.current;
-
-  pop(valueCursor, providerFiber);
-
-  const context: ReactContext<any> = providerFiber.type._context;
-  if (isPrimaryRenderer) {
-    context._currentValue = currentValue;
-  } else {
-    context._currentValue2 = currentValue;
-  }
-}
-
-export function calculateChangedBits<T>(
-  context: ReactContext<T>,
-  newValue: T,
-  oldValue: T,
-) {
-  if (is(oldValue, newValue)) {
-    // No change
-    return 0;
-  } else {
-    const changedBits =
-      typeof context._calculateChangedBits === 'function'
-        ? context._calculateChangedBits(oldValue, newValue)
-        : MAX_SIGNED_31_BIT_INT;
-
-    if (__DEV__) {
-      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
-        console.error(
-          'calculateChangedBits: Expected the return value to be a ' +
-            '31-bit integer. Instead received: %s',
-          changedBits,
-        );
-      }
-    }
-    return changedBits | 0;
-  }
-}
-
-export function scheduleWorkOnParentPath(
-  parent: Fiber | null,
-  renderExpirationTime: ExpirationTime,
-) {
-  // Update the child expiration time of all the ancestors, including
-  // the alternates.
-  let node = parent;
-  while (node !== null) {
-    const alternate = node.alternate;
-    if (node.childExpirationTime < renderExpirationTime) {
-      node.childExpirationTime = renderExpirationTime;
-      if (
-        alternate !== null &&
-        alternate.childExpirationTime < renderExpirationTime
-      ) {
-        alternate.childExpirationTime = renderExpirationTime;
-      }
-    } else if (
-      alternate !== null &&
-      alternate.childExpirationTime < renderExpirationTime
-    ) {
-      alternate.childExpirationTime = renderExpirationTime;
-    } else {
-      // Neither alternate was updated, which means the rest of the
-      // ancestor path already has sufficient priority.
-      break;
-    }
-    node = node.return;
-  }
-}
-
-export function propagateContextChange(
-  workInProgress: Fiber,
-  context: ReactContext<mixed>,
-  changedBits: number,
-  renderExpirationTime: ExpirationTime,
-): void {
-  let fiber = workInProgress.child;
-  if (fiber !== null) {
-    // Set the return pointer of the child to the work-in-progress fiber.
-    fiber.return = workInProgress;
-  }
-  while (fiber !== null) {
-    let nextFiber;
-
-    // Visit this fiber.
-    const list = fiber.dependencies;
-    if (list !== null) {
-      nextFiber = fiber.child;
-
-      let dependency = list.firstContext;
-      while (dependency !== null) {
-        // Check if the context matches.
-        if (
-          dependency.context === context &&
-          (dependency.observedBits & changedBits) !== 0
-        ) {
-          // Match! Schedule an update on this fiber.
-
-          if (fiber.tag === ClassComponent) {
-            // Schedule a force update on the work-in-progress.
-            const update = createUpdate(renderExpirationTime, null);
-            update.tag = ForceUpdate;
-            // TODO: Because we don't have a work-in-progress, this will add the
-            // update to the current fiber, too, which means it will persist even if
-            // this render is thrown away. Since it's a race condition, not sure it's
-            // worth fixing.
-            enqueueUpdate(fiber, update);
-          }
-
-          if (fiber.expirationTime < renderExpirationTime) {
-            fiber.expirationTime = renderExpirationTime;
-          }
-          const alternate = fiber.alternate;
-          if (
-            alternate !== null &&
-            alternate.expirationTime < renderExpirationTime
-          ) {
-            alternate.expirationTime = renderExpirationTime;
-          }
-
-          scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
-
-          // Mark the expiration time on the list, too.
-          if (list.expirationTime < renderExpirationTime) {
-            list.expirationTime = renderExpirationTime;
-          }
-
-          // Since we already found a match, we can stop traversing the
-          // dependency list.
-          break;
-        }
-        dependency = dependency.next;
-      }
-    } else if (fiber.tag === ContextProvider) {
-      // Don't scan deeper if this is a matching provider
-      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
-    } else if (
-      enableSuspenseServerRenderer &&
-      fiber.tag === DehydratedFragment
-    ) {
-      // If a dehydrated suspense bounudary is in this subtree, we don't know
-      // if it will have any context consumers in it. The best we can do is
-      // mark it as having updates.
-      const parentSuspense = fiber.return;
-      invariant(
-        parentSuspense !== null,
-        'We just came from a parent so we must have had a parent. This is a bug in React.',
-      );
-      if (parentSuspense.expirationTime < renderExpirationTime) {
-        parentSuspense.expirationTime = renderExpirationTime;
-      }
-      const alternate = parentSuspense.alternate;
-      if (
-        alternate !== null &&
-        alternate.expirationTime < renderExpirationTime
-      ) {
-        alternate.expirationTime = renderExpirationTime;
-      }
-      // This is intentionally passing this fiber as the parent
-      // because we want to schedule this fiber as having work
-      // on its children. We'll use the childExpirationTime on
-      // this fiber to indicate that a context has changed.
-      scheduleWorkOnParentPath(parentSuspense, renderExpirationTime);
-      nextFiber = fiber.sibling;
-    } else {
-      // Traverse down.
-      nextFiber = fiber.child;
-    }
-
-    if (nextFiber !== null) {
-      // Set the return pointer of the child to the work-in-progress fiber.
-      nextFiber.return = fiber;
-    } else {
-      // No child. Traverse to next sibling.
-      nextFiber = fiber;
-      while (nextFiber !== null) {
-        if (nextFiber === workInProgress) {
-          // We're back to the root of this subtree. Exit.
-          nextFiber = null;
-          break;
-        }
-        const sibling = nextFiber.sibling;
-        if (sibling !== null) {
-          // Set the return pointer of the sibling to the work-in-progress fiber.
-          sibling.return = nextFiber.return;
-          nextFiber = sibling;
-          break;
-        }
-        // No more siblings. Traverse up.
-        nextFiber = nextFiber.return;
-      }
-    }
-    fiber = nextFiber;
-  }
-}
-
-export function prepareToReadContext(
-  workInProgress: Fiber,
-  renderExpirationTime: ExpirationTime,
-): void {
-  currentlyRenderingFiber = workInProgress;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
-
-  const dependencies = workInProgress.dependencies;
-  if (dependencies !== null) {
-    const firstContext = dependencies.firstContext;
-    if (firstContext !== null) {
-      if (dependencies.expirationTime >= renderExpirationTime) {
-        // Context list has a pending update. Mark that this fiber performed work.
-        markWorkInProgressReceivedUpdate();
-      }
-      // Reset the work-in-progress list
-      dependencies.firstContext = null;
-    }
-  }
-}
-
-export function readContext<T>(
-  context: ReactContext<T>,
-  observedBits: void | number | boolean,
-): T {
-  if (__DEV__) {
-    // This warning would fire if you read context inside a Hook like useMemo.
-    // Unlike the class check below, it's not enforced in production for perf.
-    if (isDisallowedContextReadInDEV) {
-      console.error(
-        'Context can only be read while React is rendering. ' +
-          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-          'In function components, you can read it directly in the function body, but not ' +
-          'inside Hooks like useReducer() or useMemo().',
-      );
-    }
-  }
-
-  if (lastContextWithAllBitsObserved === context) {
-    // Nothing to do. We already observe everything in this context.
-  } else if (observedBits === false || observedBits === 0) {
-    // Do not observe any updates.
-  } else {
-    let resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.
-    if (
-      typeof observedBits !== 'number' ||
-      observedBits === MAX_SIGNED_31_BIT_INT
-    ) {
-      // Observe all updates.
-      lastContextWithAllBitsObserved = ((context: any): ReactContext<mixed>);
-      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
-    } else {
-      resolvedObservedBits = observedBits;
-    }
-
-    const contextItem = {
-      context: ((context: any): ReactContext<mixed>),
-      observedBits: resolvedObservedBits,
-      next: null,
-    };
-
-    if (lastContextDependency === null) {
-      invariant(
-        currentlyRenderingFiber !== null,
-        'Context can only be read while React is rendering. ' +
-          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-          'In function components, you can read it directly in the function body, but not ' +
-          'inside Hooks like useReducer() or useMemo().',
-      );
-
-      // This is the first dependency for this component. Create a new list.
-      lastContextDependency = contextItem;
-      currentlyRenderingFiber.dependencies = {
-        expirationTime: NoWork,
-        firstContext: contextItem,
-        responders: null,
-      };
-    } else {
-      // Append a new context item.
-      lastContextDependency = lastContextDependency.next = contextItem;
-    }
-  }
-  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
-}

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
new file mode 100644
index 0000000000..acaafbce15
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -0,0 +1,706 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
+import type {
+  Fiber,
+  ContextDependency,
+  Dependencies,
+} from './ReactInternalTypes';
+import type {StackCursor} from './ReactFiberStack';
+import type {Lanes} from './ReactFiberLane';
+import type {SharedQueue} from './ReactFiberClassUpdateQueue';
+
+import {isPrimaryRenderer} from './ReactFiberHostConfig';
+import {createCursor, push, pop} from './ReactFiberStack';
+import {
+  ContextProvider,
+  ClassComponent,
+  DehydratedFragment,
+} from './ReactWorkTags';
+import {
+  NoLanes,
+  NoTimestamp,
+  isSubsetOfLanes,
+  includesSomeLane,
+  mergeLanes,
+  pickArbitraryLane,
+} from './ReactFiberLane';
+import {
+  NoFlags,
+  DidPropagateContext,
+  NeedsPropagation,
+} from './ReactFiberFlags';
+
+import is from 'shared/objectIs';
+import {createUpdate, ForceUpdate} from './ReactFiberClassUpdateQueue';
+import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
+import {
+  enableLazyContextPropagation,
+  enableServerContext,
+} from 'shared/ReactFeatureFlags';
+import {REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED} from 'shared/ReactSymbols';
+
+const valueCursor: StackCursor<mixed> = createCursor(null);
+
+let rendererSigil;
+if (__DEV__) {
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+}
+
+let currentlyRenderingFiber: Fiber | null = null;
+let lastContextDependency: ContextDependency<mixed> | null = null;
+let lastFullyObservedContext: ReactContext<any> | null = null;
+
+let isDisallowedContextReadInDEV: boolean = false;
+
+export function resetContextDependencies(): void {
+  // This is called right before React yields execution, to ensure `readContext`
+  // cannot be called outside the render phase.
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastFullyObservedContext = null;
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = false;
+  }
+}
+
+export function enterDisallowedContextReadInDEV(): void {
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = true;
+  }
+}
+
+export function exitDisallowedContextReadInDEV(): void {
+  if (__DEV__) {
+    isDisallowedContextReadInDEV = false;
+  }
+}
+
+export function pushProvider<T>(
+  providerFiber: Fiber,
+  context: ReactContext<T>,
+  nextValue: T,
+): void {
+  if (isPrimaryRenderer) {
+    push(valueCursor, context._currentValue, providerFiber);
+
+    context._currentValue = nextValue;
+    if (__DEV__) {
+      if (
+        context._currentRenderer !== undefined &&
+        context._currentRenderer !== null &&
+        context._currentRenderer !== rendererSigil
+      ) {
+        console.error(
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+      }
+      context._currentRenderer = rendererSigil;
+    }
+  } else {
+    push(valueCursor, context._currentValue2, providerFiber);
+
+    context._currentValue2 = nextValue;
+    if (__DEV__) {
+      if (
+        context._currentRenderer2 !== undefined &&
+        context._currentRenderer2 !== null &&
+        context._currentRenderer2 !== rendererSigil
+      ) {
+        console.error(
+          'Detected multiple renderers concurrently rendering the ' +
+            'same context provider. This is currently unsupported.',
+        );
+      }
+      context._currentRenderer2 = rendererSigil;
+    }
+  }
+}
+
+export function popProvider(
+  context: ReactContext<any>,
+  providerFiber: Fiber,
+): void {
+  const currentValue = valueCursor.current;
+  pop(valueCursor, providerFiber);
+  if (isPrimaryRenderer) {
+    if (
+      enableServerContext &&
+      currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED
+    ) {
+      context._currentValue = context._defaultValue;
+    } else {
+      context._currentValue = currentValue;
+    }
+  } else {
+    if (
+      enableServerContext &&
+      currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED
+    ) {
+      context._currentValue2 = context._defaultValue;
+    } else {
+      context._currentValue2 = currentValue;
+    }
+  }
+}
+
+export function scheduleContextWorkOnParentPath(
+  parent: Fiber | null,
+  renderLanes: Lanes,
+  propagationRoot: Fiber,
+) {
+  // Update the child lanes of all the ancestors, including the alternates.
+  let node = parent;
+  while (node !== null) {
+    const alternate = node.alternate;
+    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
+      node.childLanes = mergeLanes(node.childLanes, renderLanes);
+      if (alternate !== null) {
+        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
+      }
+    } else if (
+      alternate !== null &&
+      !isSubsetOfLanes(alternate.childLanes, renderLanes)
+    ) {
+      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
+    } else {
+      // Neither alternate was updated.
+      // Normally, this would mean that the rest of the
+      // ancestor path already has sufficient priority.
+      // However, this is not necessarily true inside offscreen
+      // or fallback trees because childLanes may be inconsistent
+      // with the surroundings. This is why we continue the loop.
+    }
+    if (node === propagationRoot) {
+      break;
+    }
+    node = node.return;
+  }
+  if (__DEV__) {
+    if (node !== propagationRoot) {
+      console.error(
+        'Expected to find the propagation root when scheduling context work. ' +
+          'This error is likely caused by a bug in React. Please file an issue.',
+      );
+    }
+  }
+}
+
+export function propagateContextChange<T>(
+  workInProgress: Fiber,
+  context: ReactContext<T>,
+  renderLanes: Lanes,
+): void {
+  if (enableLazyContextPropagation) {
+    // TODO: This path is only used by Cache components. Update
+    // lazilyPropagateParentContextChanges to look for Cache components so they
+    // can take advantage of lazy propagation.
+    const forcePropagateEntireTree = true;
+    propagateContextChanges(
+      workInProgress,
+      [context],
+      renderLanes,
+      forcePropagateEntireTree,
+    );
+  } else {
+    propagateContextChange_eager(workInProgress, context, renderLanes);
+  }
+}
+
+function propagateContextChange_eager<T>(
+  workInProgress: Fiber,
+  context: ReactContext<T>,
+  renderLanes: Lanes,
+): void {
+  // Only used by eager implementation
+  if (enableLazyContextPropagation) {
+    return;
+  }
+  let fiber = workInProgress.child;
+  if (fiber !== null) {
+    // Set the return pointer of the child to the work-in-progress fiber.
+    fiber.return = workInProgress;
+  }
+  while (fiber !== null) {
+    let nextFiber;
+
+    // Visit this fiber.
+    const list = fiber.dependencies;
+    if (list !== null) {
+      nextFiber = fiber.child;
+
+      let dependency = list.firstContext;
+      while (dependency !== null) {
+        // Check if the context matches.
+        if (dependency.context === context) {
+          // Match! Schedule an update on this fiber.
+          if (fiber.tag === ClassComponent) {
+            // Schedule a force update on the work-in-progress.
+            const lane = pickArbitraryLane(renderLanes);
+            const update = createUpdate(NoTimestamp, lane);
+            update.tag = ForceUpdate;
+            // TODO: Because we don't have a work-in-progress, this will add the
+            // update to the current fiber, too, which means it will persist even if
+            // this render is thrown away. Since it's a race condition, not sure it's
+            // worth fixing.
+
+            // Inlined `enqueueUpdate` to remove interleaved update check
+            const updateQueue = fiber.updateQueue;
+            if (updateQueue === null) {
+              // Only occurs if the fiber has been unmounted.
+            } else {
+              const sharedQueue: SharedQueue<any> = (updateQueue: any).shared;
+              const pending = sharedQueue.pending;
+              if (pending === null) {
+                // This is the first update. Create a circular list.
+                update.next = update;
+              } else {
+                update.next = pending.next;
+                pending.next = update;
+              }
+              sharedQueue.pending = update;
+            }
+          }
+
+          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
+          const alternate = fiber.alternate;
+          if (alternate !== null) {
+            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
+          }
+          scheduleContextWorkOnParentPath(
+            fiber.return,
+            renderLanes,
+            workInProgress,
+          );
+
+          // Mark the updated lanes on the list, too.
+          list.lanes = mergeLanes(list.lanes, renderLanes);
+
+          // Since we already found a match, we can stop traversing the
+          // dependency list.
+          break;
+        }
+        dependency = dependency.next;
+      }
+    } else if (fiber.tag === ContextProvider) {
+      // Don't scan deeper if this is a matching provider
+      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
+    } else if (fiber.tag === DehydratedFragment) {
+      // If a dehydrated suspense boundary is in this subtree, we don't know
+      // if it will have any context consumers in it. The best we can do is
+      // mark it as having updates.
+      const parentSuspense = fiber.return;
+
+      if (parentSuspense === null) {
+        throw new Error(
+          'We just came from a parent so we must have had a parent. This is a bug in React.',
+        );
+      }
+
+      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);
+      const alternate = parentSuspense.alternate;
+      if (alternate !== null) {
+        alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
+      }
+      // This is intentionally passing this fiber as the parent
+      // because we want to schedule this fiber as having work
+      // on its children. We'll use the childLanes on
+      // this fiber to indicate that a context has changed.
+      scheduleContextWorkOnParentPath(
+        parentSuspense,
+        renderLanes,
+        workInProgress,
+      );
+      nextFiber = fiber.sibling;
+    } else {
+      // Traverse down.
+      nextFiber = fiber.child;
+    }
+
+    if (nextFiber !== null) {
+      // Set the return pointer of the child to the work-in-progress fiber.
+      nextFiber.return = fiber;
+    } else {
+      // No child. Traverse to next sibling.
+      nextFiber = fiber;
+      while (nextFiber !== null) {
+        if (nextFiber === workInProgress) {
+          // We're back to the root of this subtree. Exit.
+          nextFiber = null;
+          break;
+        }
+        const sibling = nextFiber.sibling;
+        if (sibling !== null) {
+          // Set the return pointer of the sibling to the work-in-progress fiber.
+          sibling.return = nextFiber.return;
+          nextFiber = sibling;
+          break;
+        }
+        // No more siblings. Traverse up.
+        nextFiber = nextFiber.return;
+      }
+    }
+    fiber = nextFiber;
+  }
+}
+
+function propagateContextChanges<T>(
+  workInProgress: Fiber,
+  contexts: Array<any>,
+  renderLanes: Lanes,
+  forcePropagateEntireTree: boolean,
+): void {
+  // Only used by lazy implementation
+  if (!enableLazyContextPropagation) {
+    return;
+  }
+  let fiber = workInProgress.child;
+  if (fiber !== null) {
+    // Set the return pointer of the child to the work-in-progress fiber.
+    fiber.return = workInProgress;
+  }
+  while (fiber !== null) {
+    let nextFiber;
+
+    // Visit this fiber.
+    const list = fiber.dependencies;
+    if (list !== null) {
+      nextFiber = fiber.child;
+
+      let dep = list.firstContext;
+      findChangedDep: while (dep !== null) {
+        // Assigning these to constants to help Flow
+        const dependency = dep;
+        const consumer = fiber;
+        findContext: for (let i = 0; i < contexts.length; i++) {
+          const context: ReactContext<T> = contexts[i];
+          // Check if the context matches.
+          // TODO: Compare selected values to bail out early.
+          if (dependency.context === context) {
+            // Match! Schedule an update on this fiber.
+
+            // In the lazy implementation, don't mark a dirty flag on the
+            // dependency itself. Not all changes are propagated, so we can't
+            // rely on the propagation function alone to determine whether
+            // something has changed; the consumer will check. In the future, we
+            // could add back a dirty flag as an optimization to avoid double
+            // checking, but until we have selectors it's not really worth
+            // the trouble.
+            consumer.lanes = mergeLanes(consumer.lanes, renderLanes);
+            const alternate = consumer.alternate;
+            if (alternate !== null) {
+              alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
+            }
+            scheduleContextWorkOnParentPath(
+              consumer.return,
+              renderLanes,
+              workInProgress,
+            );
+
+            if (!forcePropagateEntireTree) {
+              // During lazy propagation, when we find a match, we can defer
+              // propagating changes to the children, because we're going to
+              // visit them during render. We should continue propagating the
+              // siblings, though
+              nextFiber = null;
+            }
+
+            // Since we already found a match, we can stop traversing the
+            // dependency list.
+            break findChangedDep;
+          }
+        }
+        dep = dependency.next;
+      }
+    } else if (fiber.tag === DehydratedFragment) {
+      // If a dehydrated suspense boundary is in this subtree, we don't know
+      // if it will have any context consumers in it. The best we can do is
+      // mark it as having updates.
+      const parentSuspense = fiber.return;
+
+      if (parentSuspense === null) {
+        throw new Error(
+          'We just came from a parent so we must have had a parent. This is a bug in React.',
+        );
+      }
+
+      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);
+      const alternate = parentSuspense.alternate;
+      if (alternate !== null) {
+        alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
+      }
+      // This is intentionally passing this fiber as the parent
+      // because we want to schedule this fiber as having work
+      // on its children. We'll use the childLanes on
+      // this fiber to indicate that a context has changed.
+      scheduleContextWorkOnParentPath(
+        parentSuspense,
+        renderLanes,
+        workInProgress,
+      );
+      nextFiber = null;
+    } else {
+      // Traverse down.
+      nextFiber = fiber.child;
+    }
+
+    if (nextFiber !== null) {
+      // Set the return pointer of the child to the work-in-progress fiber.
+      nextFiber.return = fiber;
+    } else {
+      // No child. Traverse to next sibling.
+      nextFiber = fiber;
+      while (nextFiber !== null) {
+        if (nextFiber === workInProgress) {
+          // We're back to the root of this subtree. Exit.
+          nextFiber = null;
+          break;
+        }
+        const sibling = nextFiber.sibling;
+        if (sibling !== null) {
+          // Set the return pointer of the sibling to the work-in-progress fiber.
+          sibling.return = nextFiber.return;
+          nextFiber = sibling;
+          break;
+        }
+        // No more siblings. Traverse up.
+        nextFiber = nextFiber.return;
+      }
+    }
+    fiber = nextFiber;
+  }
+}
+
+export function lazilyPropagateParentContextChanges(
+  current: Fiber,
+  workInProgress: Fiber,
+  renderLanes: Lanes,
+) {
+  const forcePropagateEntireTree = false;
+  propagateParentContextChanges(
+    current,
+    workInProgress,
+    renderLanes,
+    forcePropagateEntireTree,
+  );
+}
+
+// Used for propagating a deferred tree (Suspense, Offscreen). We must propagate
+// to the entire subtree, because we won't revisit it until after the current
+// render has completed, at which point we'll have lost track of which providers
+// have changed.
+export function propagateParentContextChangesToDeferredTree(
+  current: Fiber,
+  workInProgress: Fiber,
+  renderLanes: Lanes,
+) {
+  const forcePropagateEntireTree = true;
+  propagateParentContextChanges(
+    current,
+    workInProgress,
+    renderLanes,
+    forcePropagateEntireTree,
+  );
+}
+
+function propagateParentContextChanges(
+  current: Fiber,
+  workInProgress: Fiber,
+  renderLanes: Lanes,
+  forcePropagateEntireTree: boolean,
+) {
+  if (!enableLazyContextPropagation) {
+    return;
+  }
+
+  // Collect all the parent providers that changed. Since this is usually small
+  // number, we use an Array instead of Set.
+  let contexts = null;
+  let parent: null | Fiber = workInProgress;
+  let isInsidePropagationBailout = false;
+  while (parent !== null) {
+    if (!isInsidePropagationBailout) {
+      if ((parent.flags & NeedsPropagation) !== NoFlags) {
+        isInsidePropagationBailout = true;
+      } else if ((parent.flags & DidPropagateContext) !== NoFlags) {
+        break;
+      }
+    }
+
+    if (parent.tag === ContextProvider) {
+      const currentParent = parent.alternate;
+
+      if (currentParent === null) {
+        throw new Error('Should have a current fiber. This is a bug in React.');
+      }
+
+      const oldProps = currentParent.memoizedProps;
+      if (oldProps !== null) {
+        const providerType: ReactProviderType<any> = parent.type;
+        const context: ReactContext<any> = providerType._context;
+
+        const newProps = parent.pendingProps;
+        const newValue = newProps.value;
+
+        const oldValue = oldProps.value;
+
+        if (!is(newValue, oldValue)) {
+          if (contexts !== null) {
+            contexts.push(context);
+          } else {
+            contexts = [context];
+          }
+        }
+      }
+    }
+    parent = parent.return;
+  }
+
+  if (contexts !== null) {
+    // If there were any changed providers, search through the children and
+    // propagate their changes.
+    propagateContextChanges(
+      workInProgress,
+      contexts,
+      renderLanes,
+      forcePropagateEntireTree,
+    );
+  }
+
+  // This is an optimization so that we only propagate once per subtree. If a
+  // deeply nested child bails out, and it calls this propagation function, it
+  // uses this flag to know that the remaining ancestor providers have already
+  // been propagated.
+  //
+  // NOTE: This optimization is only necessary because we sometimes enter the
+  // begin phase of nodes that don't have any work scheduled on them —
+  // specifically, the siblings of a node that _does_ have scheduled work. The
+  // siblings will bail out and call this function again, even though we already
+  // propagated content changes to it and its subtree. So we use this flag to
+  // mark that the parent providers already propagated.
+  //
+  // Unfortunately, though, we need to ignore this flag when we're inside a
+  // tree whose context propagation was deferred — that's what the
+  // `NeedsPropagation` flag is for.
+  //
+  // If we could instead bail out before entering the siblings' begin phase,
+  // then we could remove both `DidPropagateContext` and `NeedsPropagation`.
+  // Consider this as part of the next refactor to the fiber tree structure.
+  workInProgress.flags |= DidPropagateContext;
+}
+
+export function checkIfContextChanged(
+  currentDependencies: Dependencies,
+): boolean {
+  if (!enableLazyContextPropagation) {
+    return false;
+  }
+  // Iterate over the current dependencies to see if something changed. This
+  // only gets called if props and state has already bailed out, so it's a
+  // relatively uncommon path, except at the root of a changed subtree.
+  // Alternatively, we could move these comparisons into `readContext`, but
+  // that's a much hotter path, so I think this is an appropriate trade off.
+  let dependency = currentDependencies.firstContext;
+  while (dependency !== null) {
+    const context = dependency.context;
+    const newValue = isPrimaryRenderer
+      ? context._currentValue
+      : context._currentValue2;
+    const oldValue = dependency.memoizedValue;
+    if (!is(newValue, oldValue)) {
+      return true;
+    }
+    dependency = dependency.next;
+  }
+  return false;
+}
+
+export function prepareToReadContext(
+  workInProgress: Fiber,
+  renderLanes: Lanes,
+): void {
+  currentlyRenderingFiber = workInProgress;
+  lastContextDependency = null;
+  lastFullyObservedContext = null;
+
+  const dependencies = workInProgress.dependencies;
+  if (dependencies !== null) {
+    if (enableLazyContextPropagation) {
+      // Reset the work-in-progress list
+      dependencies.firstContext = null;
+    } else {
+      const firstContext = dependencies.firstContext;
+      if (firstContext !== null) {
+        if (includesSomeLane(dependencies.lanes, renderLanes)) {
+          // Context list has a pending update. Mark that this fiber performed work.
+          markWorkInProgressReceivedUpdate();
+        }
+        // Reset the work-in-progress list
+        dependencies.firstContext = null;
+      }
+    }
+  }
+}
+
+export function readContext<T>(context: ReactContext<T>): T {
+  if (__DEV__) {
+    // This warning would fire if you read context inside a Hook like useMemo.
+    // Unlike the class check below, it's not enforced in production for perf.
+    if (isDisallowedContextReadInDEV) {
+      console.error(
+        'Context can only be read while React is rendering. ' +
+          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+          'In function components, you can read it directly in the function body, but not ' +
+          'inside Hooks like useReducer() or useMemo().',
+      );
+    }
+  }
+
+  const value = isPrimaryRenderer
+    ? context._currentValue
+    : context._currentValue2;
+
+  if (lastFullyObservedContext === context) {
+    // Nothing to do. We already observe everything in this context.
+  } else {
+    const contextItem = {
+      context: ((context: any): ReactContext<mixed>),
+      memoizedValue: value,
+      next: null,
+    };
+
+    if (lastContextDependency === null) {
+      if (currentlyRenderingFiber === null) {
+        throw new Error(
+          'Context can only be read while React is rendering. ' +
+            'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+            'In function components, you can read it directly in the function body, but not ' +
+            'inside Hooks like useReducer() or useMemo().',
+        );
+      }
+
+      // This is the first dependency for this component. Create a new list.
+      lastContextDependency = contextItem;
+      currentlyRenderingFiber.dependencies = {
+        lanes: NoLanes,
+        firstContext: contextItem,
+      };
+      if (enableLazyContextPropagation) {
+        currentlyRenderingFiber.flags |= NeedsPropagation;
+      }
+    } else {
+      // Append a new context item.
+      lastContextDependency = lastContextDependency.next = contextItem;
+    }
+  }
+  return value;
+}

commit 555ece0cd14779abd5a1fc50f71625f9ada42bef
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Jan 12 13:17:15 2023 +0100

    Don't warn about concurrently rendering contexts if we finished rendering (#22797)
    
    Closes https://github.com/facebook/react/issues/22796

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index acaafbce15..9e9abfb620 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -49,6 +49,15 @@ import {REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED} from 'shared/ReactSymbols
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
+let rendererCursorDEV: StackCursor<Object | null>;
+if (__DEV__) {
+  rendererCursorDEV = createCursor(null);
+}
+let renderer2CursorDEV: StackCursor<Object | null>;
+if (__DEV__) {
+  renderer2CursorDEV = createCursor(null);
+}
+
 let rendererSigil;
 if (__DEV__) {
   // Use this to detect multiple renderers using the same context
@@ -94,6 +103,8 @@ export function pushProvider<T>(
 
     context._currentValue = nextValue;
     if (__DEV__) {
+      push(rendererCursorDEV, context._currentRenderer, providerFiber);
+
       if (
         context._currentRenderer !== undefined &&
         context._currentRenderer !== null &&
@@ -111,6 +122,8 @@ export function pushProvider<T>(
 
     context._currentValue2 = nextValue;
     if (__DEV__) {
+      push(renderer2CursorDEV, context._currentRenderer2, providerFiber);
+
       if (
         context._currentRenderer2 !== undefined &&
         context._currentRenderer2 !== null &&
@@ -131,7 +144,7 @@ export function popProvider(
   providerFiber: Fiber,
 ): void {
   const currentValue = valueCursor.current;
-  pop(valueCursor, providerFiber);
+
   if (isPrimaryRenderer) {
     if (
       enableServerContext &&
@@ -141,6 +154,11 @@ export function popProvider(
     } else {
       context._currentValue = currentValue;
     }
+    if (__DEV__) {
+      const currentRenderer = rendererCursorDEV.current;
+      pop(rendererCursorDEV, providerFiber);
+      context._currentRenderer = currentRenderer;
+    }
   } else {
     if (
       enableServerContext &&
@@ -150,7 +168,14 @@ export function popProvider(
     } else {
       context._currentValue2 = currentValue;
     }
+    if (__DEV__) {
+      const currentRenderer2 = renderer2CursorDEV.current;
+      pop(renderer2CursorDEV, providerFiber);
+      context._currentRenderer2 = currentRenderer2;
+    }
   }
+
+  pop(valueCursor, providerFiber);
 }
 
 export function scheduleContextWorkOnParentPath(

commit c04b18070145b82111e1162729f4776f4d2c6112
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Feb 22 15:32:09 2023 -0500

    Remove eventTime field from class Update type (#26219)
    
    `eventTime` is a vestigial field that can be cleaned up. It was
    originally used as part of the starvation mechanism but it's since been
    replaced by a per-lane field on the root.
    
    This is a part of a series of smaller refactors I'm doing to
    simplify/speed up the `setState` path, related to the Sync Unification
    project that @tyao1 has been working on.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 9e9abfb620..80bade220d 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -26,7 +26,6 @@ import {
 } from './ReactWorkTags';
 import {
   NoLanes,
-  NoTimestamp,
   isSubsetOfLanes,
   includesSomeLane,
   mergeLanes,
@@ -271,7 +270,7 @@ function propagateContextChange_eager<T>(
           if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
             const lane = pickArbitraryLane(renderLanes);
-            const update = createUpdate(NoTimestamp, lane);
+            const update = createUpdate(lane);
             update.tag = ForceUpdate;
             // TODO: Because we don't have a work-in-progress, this will add the
             // update to the current fiber, too, which means it will persist even if

commit 131768166b60b3bc271b54a3f93f011f310519de
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 11 17:34:31 2023 -0500

    Support Context as renderable node (#25641)
    
    ## Based on #25634
    
    Like promises, this adds support for Context as a React node.
    
    In this initial implementation, the context dependency is added to the
    parent of child node. This allows the parent to re-reconcile its
    children when the context updates, so that it can delete the old node if
    the identity of the child has changed (i.e. if the key or type of an
    element has changed). But it also means that the parent will replay its
    entire begin phase. Ideally React would delete the old node and mount
    the new node without reconciling all the children. I'll leave this for a
    future optimization.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 80bade220d..9987d8fd6a 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -688,7 +688,24 @@ export function readContext<T>(context: ReactContext<T>): T {
       );
     }
   }
+  return readContextForConsumer(currentlyRenderingFiber, context);
+}
 
+export function readContextDuringReconcilation<T>(
+  consumer: Fiber,
+  context: ReactContext<T>,
+  renderLanes: Lanes,
+): T {
+  if (currentlyRenderingFiber === null) {
+    prepareToReadContext(consumer, renderLanes);
+  }
+  return readContextForConsumer(consumer, context);
+}
+
+function readContextForConsumer<T>(
+  consumer: Fiber | null,
+  context: ReactContext<T>,
+): T {
   const value = isPrimaryRenderer
     ? context._currentValue
     : context._currentValue2;
@@ -703,7 +720,7 @@ export function readContext<T>(context: ReactContext<T>): T {
     };
 
     if (lastContextDependency === null) {
-      if (currentlyRenderingFiber === null) {
+      if (consumer === null) {
         throw new Error(
           'Context can only be read while React is rendering. ' +
             'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
@@ -714,12 +731,12 @@ export function readContext<T>(context: ReactContext<T>): T {
 
       // This is the first dependency for this component. Create a new list.
       lastContextDependency = contextItem;
-      currentlyRenderingFiber.dependencies = {
+      consumer.dependencies = {
         lanes: NoLanes,
         firstContext: contextItem,
       };
       if (enableLazyContextPropagation) {
-        currentlyRenderingFiber.flags |= NeedsPropagation;
+        consumer.flags |= NeedsPropagation;
       }
     } else {
       // Append a new context item.

commit b55d31955982851284bb437a5187a6c56e366539
Author: Josh Story <story@hey.com>
Date:   Mon Apr 10 14:58:44 2023 -0700

    Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)
    
    part of https://github.com/facebook/react/pull/26571
    
    merging separately to improve tracking of files renames in git
    
    Rename HostConfig files to FiberConfig to clarify they are configs for
    Fiber and not Fizz/Flight. This better conforms to the naming used in
    Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 9987d8fd6a..003022a9c6 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -17,7 +17,7 @@ import type {StackCursor} from './ReactFiberStack';
 import type {Lanes} from './ReactFiberLane';
 import type {SharedQueue} from './ReactFiberClassUpdateQueue';
 
-import {isPrimaryRenderer} from './ReactFiberHostConfig';
+import {isPrimaryRenderer} from './ReactFiberConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import {
   ContextProvider,

commit 540bab085d571789f4562565eebfd0db9f36345c
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 26 18:19:58 2023 -0400

    Implement experimental_useFormStatus (#26722)
    
    This hook reads the status of its ancestor form component, if it exists.
    
    ```js
    const {pending, data, action, method} = useFormStatus();
    ```
    
    It can be used to implement a loading indicator, for example. You can
    think of it as a shortcut for implementing a loading state with the
    useTransition hook.
    
    For now, it's only available in the experimental channel. We'll share
    docs once its closer to being stable. There are additional APIs that
    will ship alongside it.
    
    Internally it's implemented using startTransition + a context object.
    That's a good way to think about its behavior, but the actual
    implementation details may change in the future.
    
    Because form elements cannot be nested, the implementation in the
    reconciler does not bother to keep track of multiple nested "transition
    providers". So although it's implemented using generic Fiber config
    methods, it does currently make some assumptions based on React DOM's
    requirements.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 003022a9c6..d4f4eb048e 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -16,6 +16,8 @@ import type {
 import type {StackCursor} from './ReactFiberStack';
 import type {Lanes} from './ReactFiberLane';
 import type {SharedQueue} from './ReactFiberClassUpdateQueue';
+import type {TransitionStatus} from './ReactFiberConfig';
+import type {Hook} from './ReactFiberHooks';
 
 import {isPrimaryRenderer} from './ReactFiberConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
@@ -43,8 +45,14 @@ import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
 import {
   enableLazyContextPropagation,
   enableServerContext,
+  enableFormActions,
+  enableAsyncActions,
 } from 'shared/ReactFeatureFlags';
 import {REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED} from 'shared/ReactSymbols';
+import {
+  getHostTransitionProvider,
+  HostTransitionContext,
+} from './ReactFiberHostContext';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
@@ -585,6 +593,33 @@ function propagateParentContextChanges(
           }
         }
       }
+    } else if (
+      enableFormActions &&
+      enableAsyncActions &&
+      parent === getHostTransitionProvider()
+    ) {
+      // During a host transition, a host component can act like a context
+      // provider. E.g. in React DOM, this would be a <form />.
+      const currentParent = parent.alternate;
+      if (currentParent === null) {
+        throw new Error('Should have a current fiber. This is a bug in React.');
+      }
+
+      const oldStateHook: Hook = currentParent.memoizedState;
+      const oldState: TransitionStatus = oldStateHook.memoizedState;
+
+      const newStateHook: Hook = parent.memoizedState;
+      const newState: TransitionStatus = newStateHook.memoizedState;
+
+      // This uses regular equality instead of Object.is because we assume that
+      // host transition state doesn't include NaN as a valid type.
+      if (oldState !== newState) {
+        if (contexts !== null) {
+          contexts.push(HostTransitionContext);
+        } else {
+          contexts = [HostTransitionContext];
+        }
+      }
     }
     parent = parent.return;
   }

commit 472854820bfd0058dfc85524051171c7b7c998c1
Author: dan <dan.abramov@me.com>
Date:   Mon Feb 5 22:39:15 2024 +0000

    [Flight] Delete Server Context (#28225)
    
    Server Context was never documented, and has been deprecated in
    https://github.com/facebook/react/pull/27424.
    
    This PR removes it completely, including the implementation code.
    
    Notably, `useContext` is removed from the shared subset, so importing it
    from a React Server environment would now should be a build error in
    environments that are able to enforce that.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index d4f4eb048e..0aec54348c 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -44,11 +44,9 @@ import {createUpdate, ForceUpdate} from './ReactFiberClassUpdateQueue';
 import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
 import {
   enableLazyContextPropagation,
-  enableServerContext,
   enableFormActions,
   enableAsyncActions,
 } from 'shared/ReactFeatureFlags';
-import {REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED} from 'shared/ReactSymbols';
 import {
   getHostTransitionProvider,
   HostTransitionContext,
@@ -153,28 +151,14 @@ export function popProvider(
   const currentValue = valueCursor.current;
 
   if (isPrimaryRenderer) {
-    if (
-      enableServerContext &&
-      currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED
-    ) {
-      context._currentValue = context._defaultValue;
-    } else {
-      context._currentValue = currentValue;
-    }
+    context._currentValue = currentValue;
     if (__DEV__) {
       const currentRenderer = rendererCursorDEV.current;
       pop(rendererCursorDEV, providerFiber);
       context._currentRenderer = currentRenderer;
     }
   } else {
-    if (
-      enableServerContext &&
-      currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED
-    ) {
-      context._currentValue2 = context._defaultValue;
-    } else {
-      context._currentValue2 = currentValue;
-    }
+    context._currentValue2 = currentValue;
     if (__DEV__) {
       const currentRenderer2 = renderer2CursorDEV.current;
       pop(renderer2CursorDEV, providerFiber);

commit 14fd9630ee04387f4361da289393234e2b7d93b6
Author: dan <dan.abramov@me.com>
Date:   Tue Feb 13 15:04:49 2024 +0000

    Switch <Context> to mean <Context.Provider> (#28226)
    
    Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
    since the introduction of Hooks, the `<Context.Consumer>` API is rarely
    used. The goal here is to make the common case cleaner:
    
    ```js
    const ThemeContext = createContext('light')
    
    function App() {
      return (
        <ThemeContext value="dark">
          ...
        </ThemeContext>
      )
    }
    
    function Button() {
      const theme = use(ThemeContext)
      // ...
    }
    ```
    
    This is technically a breaking change, but we've been warning about
    rendering `<Context>` directly for several years by now, so it's
    unlikely much code in the wild depends on the old behavior. [Proof that
    it warns today (check
    console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)
    
    ---
    
    **The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
    switches `createContext` implementation so that `Context.Provider ===
    Context`.
    
    The main assumption that changed is that a Provider's fiber type is now
    the context itself (rather than an intermediate object). Whereas a
    Consumer's fiber type is now always an intermediate object (rather than
    it being sometimes the context itself and sometimes an intermediate
    object).
    
    My methodology was to start with the relevant symbols, work tags, and
    types, and work my way backwards to all usages.
    
    This might break tooling that depends on inspecting React's internal
    fields. I've added DevTools support in the second commit. This didn't
    need explicit versioning—the structure tells us enough.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 0aec54348c..5d9b165635 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -7,7 +7,7 @@
  * @flow
  */
 
-import type {ReactContext, ReactProviderType} from 'shared/ReactTypes';
+import type {ReactContext} from 'shared/ReactTypes';
 import type {
   Fiber,
   ContextDependency,
@@ -46,6 +46,7 @@ import {
   enableLazyContextPropagation,
   enableFormActions,
   enableAsyncActions,
+  enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
 import {
   getHostTransitionProvider,
@@ -561,8 +562,12 @@ function propagateParentContextChanges(
 
       const oldProps = currentParent.memoizedProps;
       if (oldProps !== null) {
-        const providerType: ReactProviderType<any> = parent.type;
-        const context: ReactContext<any> = providerType._context;
+        let context: ReactContext<any>;
+        if (enableRenderableContext) {
+          context = parent.type;
+        } else {
+          context = parent.type._context;
+        }
 
         const newProps = parent.pendingProps;
         const newValue = newProps.value;

commit 9ffe9102ffd08ca7a56c60aa6952208890d213ce
Author: bubucuo <bubucuo@users.noreply.github.com>
Date:   Thu Mar 14 22:04:44 2024 +0800

    Fix a spelling mistake. (#28555)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 5d9b165635..cb9ada3dee 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -715,7 +715,7 @@ export function readContext<T>(context: ReactContext<T>): T {
   return readContextForConsumer(currentlyRenderingFiber, context);
 }
 
-export function readContextDuringReconcilation<T>(
+export function readContextDuringReconciliation<T>(
   consumer: Fiber,
   context: ReactContext<T>,
   renderLanes: Lanes,

commit 527ed72bfd9f5c0045da468ad01db968a9961ad7
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Mar 25 13:25:14 2024 -0400

    Cleanup enableFormActions flag (#28614)
    
    Cleanup enableFormActions flag

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index cb9ada3dee..c19e056b0a 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -44,7 +44,6 @@ import {createUpdate, ForceUpdate} from './ReactFiberClassUpdateQueue';
 import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
 import {
   enableLazyContextPropagation,
-  enableFormActions,
   enableAsyncActions,
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
@@ -582,11 +581,7 @@ function propagateParentContextChanges(
           }
         }
       }
-    } else if (
-      enableFormActions &&
-      enableAsyncActions &&
-      parent === getHostTransitionProvider()
-    ) {
+    } else if (enableAsyncActions && parent === getHostTransitionProvider()) {
       // During a host transition, a host component can act like a context
       // provider. E.g. in React DOM, this would be a <form />.
       const currentParent = parent.alternate;

commit 1350a85980d1bf5e63c16a4a889861246f4cc107
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Jul 26 14:38:24 2024 -0400

    Add unstable context bailout for profiling (#30407)
    
    **This API is not intended to ship. This is a temporary unstable hook
    for internal performance profiling.**
    
    This PR exposes `unstable_useContextWithBailout`, which takes a compare
    function in addition to Context. The comparison function is run to
    determine if Context propagation and render should bail out earlier.
    `unstable_useContextWithBailout` returns the full Context value, same as
    `useContext`.
    
    We can profile this API against `useContext` to better measure the cost
    of Context value updates and gather more data around propagation and
    render performance.
    
    The bailout logic and test cases are based on
    https://github.com/facebook/react/pull/20646
    
    Additionally, this implementation allows multiple values to be compared
    in one hook by returning a tuple to avoid requiring additional Context
    consumer hooks.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index c19e056b0a..cc908167e1 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -12,6 +12,7 @@ import type {
   Fiber,
   ContextDependency,
   Dependencies,
+  ContextDependencyWithSelect,
 } from './ReactInternalTypes';
 import type {StackCursor} from './ReactFiberStack';
 import type {Lanes} from './ReactFiberLane';
@@ -51,6 +52,8 @@ import {
   getHostTransitionProvider,
   HostTransitionContext,
 } from './ReactFiberHostContext';
+import isArray from '../../shared/isArray';
+import {enableContextProfiling} from '../../shared/ReactFeatureFlags';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
@@ -70,7 +73,10 @@ if (__DEV__) {
 }
 
 let currentlyRenderingFiber: Fiber | null = null;
-let lastContextDependency: ContextDependency<mixed> | null = null;
+let lastContextDependency:
+  | ContextDependency<mixed>
+  | ContextDependencyWithSelect<mixed>
+  | null = null;
 let lastFullyObservedContext: ReactContext<any> | null = null;
 
 let isDisallowedContextReadInDEV: boolean = false;
@@ -400,8 +406,24 @@ function propagateContextChanges<T>(
         findContext: for (let i = 0; i < contexts.length; i++) {
           const context: ReactContext<T> = contexts[i];
           // Check if the context matches.
-          // TODO: Compare selected values to bail out early.
           if (dependency.context === context) {
+            if (enableContextProfiling) {
+              const select = dependency.select;
+              if (select != null && dependency.lastSelectedValue != null) {
+                const newValue = isPrimaryRenderer
+                  ? dependency.context._currentValue
+                  : dependency.context._currentValue2;
+                if (
+                  !checkIfSelectedContextValuesChanged(
+                    dependency.lastSelectedValue,
+                    select(newValue),
+                  )
+                ) {
+                  // Compared value hasn't changed. Bail out early.
+                  continue findContext;
+                }
+              }
+            }
             // Match! Schedule an update on this fiber.
 
             // In the lazy implementation, don't mark a dirty flag on the
@@ -641,6 +663,29 @@ function propagateParentContextChanges(
   workInProgress.flags |= DidPropagateContext;
 }
 
+function checkIfSelectedContextValuesChanged(
+  oldComparedValue: Array<mixed>,
+  newComparedValue: Array<mixed>,
+): boolean {
+  // We have an implicit contract that compare functions must return arrays.
+  // This allows us to compare multiple values in the same context access
+  // since compiling to additional hook calls regresses perf.
+  if (isArray(oldComparedValue) && isArray(newComparedValue)) {
+    if (oldComparedValue.length !== newComparedValue.length) {
+      return true;
+    }
+
+    for (let i = 0; i < oldComparedValue.length; i++) {
+      if (!is(newComparedValue[i], oldComparedValue[i])) {
+        return true;
+      }
+    }
+  } else {
+    throw new Error('Compared context values must be arrays');
+  }
+  return false;
+}
+
 export function checkIfContextChanged(
   currentDependencies: Dependencies,
 ): boolean {
@@ -659,8 +704,23 @@ export function checkIfContextChanged(
       ? context._currentValue
       : context._currentValue2;
     const oldValue = dependency.memoizedValue;
-    if (!is(newValue, oldValue)) {
-      return true;
+    if (
+      enableContextProfiling &&
+      dependency.select != null &&
+      dependency.lastSelectedValue != null
+    ) {
+      if (
+        checkIfSelectedContextValuesChanged(
+          dependency.lastSelectedValue,
+          dependency.select(newValue),
+        )
+      ) {
+        return true;
+      }
+    } else {
+      if (!is(newValue, oldValue)) {
+        return true;
+      }
     }
     dependency = dependency.next;
   }
@@ -694,6 +754,21 @@ export function prepareToReadContext(
   }
 }
 
+export function readContextAndCompare<C>(
+  context: ReactContext<C>,
+  select: C => Array<mixed>,
+): C {
+  if (!(enableLazyContextPropagation && enableContextProfiling)) {
+    throw new Error('Not implemented.');
+  }
+
+  return readContextForConsumer_withSelect(
+    currentlyRenderingFiber,
+    context,
+    select,
+  );
+}
+
 export function readContext<T>(context: ReactContext<T>): T {
   if (__DEV__) {
     // This warning would fire if you read context inside a Hook like useMemo.
@@ -721,10 +796,57 @@ export function readContextDuringReconciliation<T>(
   return readContextForConsumer(consumer, context);
 }
 
-function readContextForConsumer<T>(
+function readContextForConsumer_withSelect<C>(
   consumer: Fiber | null,
-  context: ReactContext<T>,
-): T {
+  context: ReactContext<C>,
+  select: C => Array<mixed>,
+): C {
+  const value = isPrimaryRenderer
+    ? context._currentValue
+    : context._currentValue2;
+
+  if (lastFullyObservedContext === context) {
+    // Nothing to do. We already observe everything in this context.
+  } else {
+    const contextItem = {
+      context: ((context: any): ReactContext<mixed>),
+      memoizedValue: value,
+      next: null,
+      select: ((select: any): (context: mixed) => Array<mixed>),
+      lastSelectedValue: select(value),
+    };
+
+    if (lastContextDependency === null) {
+      if (consumer === null) {
+        throw new Error(
+          'Context can only be read while React is rendering. ' +
+            'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+            'In function components, you can read it directly in the function body, but not ' +
+            'inside Hooks like useReducer() or useMemo().',
+        );
+      }
+
+      // This is the first dependency for this component. Create a new list.
+      lastContextDependency = contextItem;
+      consumer.dependencies = {
+        lanes: NoLanes,
+        firstContext: contextItem,
+      };
+      if (enableLazyContextPropagation) {
+        consumer.flags |= NeedsPropagation;
+      }
+    } else {
+      // Append a new context item.
+      lastContextDependency = lastContextDependency.next = contextItem;
+    }
+  }
+  return value;
+}
+
+function readContextForConsumer<C>(
+  consumer: Fiber | null,
+  context: ReactContext<C>,
+): C {
   const value = isPrimaryRenderer
     ? context._currentValue
     : context._currentValue2;

commit 88ee14ffa57beb0689f26f0c52c357e3ac446af8
Author: Sebastian Silbermann <sebastian.silbermann@vercel.com>
Date:   Thu Aug 1 10:55:53 2024 +0200

    [Devtools] Ensure initial read of `useFormStatus` returns `NotPendingTransition` (#28728)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index cc908167e1..57004e499b 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -20,7 +20,7 @@ import type {SharedQueue} from './ReactFiberClassUpdateQueue';
 import type {TransitionStatus} from './ReactFiberConfig';
 import type {Hook} from './ReactFiberHooks';
 
-import {isPrimaryRenderer} from './ReactFiberConfig';
+import {isPrimaryRenderer, HostTransitionContext} from './ReactFiberConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
 import {
   ContextProvider,
@@ -48,10 +48,7 @@ import {
   enableAsyncActions,
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
-import {
-  getHostTransitionProvider,
-  HostTransitionContext,
-} from './ReactFiberHostContext';
+import {getHostTransitionProvider} from './ReactFiberHostContext';
 import isArray from '../../shared/isArray';
 import {enableContextProfiling} from '../../shared/ReactFeatureFlags';
 

commit 8d68da3f7396064614f34b84881fe8833b6039ac
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Sep 3 16:04:24 2024 -0400

    [Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)
    
    This lets us track what a Component might suspend on from DevTools. We
    could already collect this by replaying a component's Hooks but that
    would be expensive to collect from a whole tree.
    
    The thenables themselves might contain useful information but mainly
    we'd want access to the `_debugInfo` on the thenables which might
    contain additional information from the server.
    
    
    https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114
    
    In a follow up we should really do something similar in Flight to
    transfer `use()` on the debugInfo of that Server Component.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 57004e499b..bf28da19ce 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -825,10 +825,16 @@ function readContextForConsumer_withSelect<C>(
 
       // This is the first dependency for this component. Create a new list.
       lastContextDependency = contextItem;
-      consumer.dependencies = {
-        lanes: NoLanes,
-        firstContext: contextItem,
-      };
+      consumer.dependencies = __DEV__
+        ? {
+            lanes: NoLanes,
+            firstContext: contextItem,
+            _debugThenableState: null,
+          }
+        : {
+            lanes: NoLanes,
+            firstContext: contextItem,
+          };
       if (enableLazyContextPropagation) {
         consumer.flags |= NeedsPropagation;
       }
@@ -869,10 +875,16 @@ function readContextForConsumer<C>(
 
       // This is the first dependency for this component. Create a new list.
       lastContextDependency = contextItem;
-      consumer.dependencies = {
-        lanes: NoLanes,
-        firstContext: contextItem,
-      };
+      consumer.dependencies = __DEV__
+        ? {
+            lanes: NoLanes,
+            firstContext: contextItem,
+            _debugThenableState: null,
+          }
+        : {
+            lanes: NoLanes,
+            firstContext: contextItem,
+          };
       if (enableLazyContextPropagation) {
         consumer.flags |= NeedsPropagation;
       }

commit 66855b96378daedb1405e83f2365e0d90966ea0e
Author: Sophie Alpert <git@sophiebits.com>
Date:   Wed Nov 6 07:35:23 2024 -0800

    Remove unused lastFullyObservedContext (#31435)

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index bf28da19ce..2e8d01e99e 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -74,7 +74,6 @@ let lastContextDependency:
   | ContextDependency<mixed>
   | ContextDependencyWithSelect<mixed>
   | null = null;
-let lastFullyObservedContext: ReactContext<any> | null = null;
 
 let isDisallowedContextReadInDEV: boolean = false;
 
@@ -83,7 +82,6 @@ export function resetContextDependencies(): void {
   // cannot be called outside the render phase.
   currentlyRenderingFiber = null;
   lastContextDependency = null;
-  lastFullyObservedContext = null;
   if (__DEV__) {
     isDisallowedContextReadInDEV = false;
   }
@@ -730,7 +728,6 @@ export function prepareToReadContext(
 ): void {
   currentlyRenderingFiber = workInProgress;
   lastContextDependency = null;
-  lastFullyObservedContext = null;
 
   const dependencies = workInProgress.dependencies;
   if (dependencies !== null) {
@@ -802,46 +799,42 @@ function readContextForConsumer_withSelect<C>(
     ? context._currentValue
     : context._currentValue2;
 
-  if (lastFullyObservedContext === context) {
-    // Nothing to do. We already observe everything in this context.
-  } else {
-    const contextItem = {
-      context: ((context: any): ReactContext<mixed>),
-      memoizedValue: value,
-      next: null,
-      select: ((select: any): (context: mixed) => Array<mixed>),
-      lastSelectedValue: select(value),
-    };
-
-    if (lastContextDependency === null) {
-      if (consumer === null) {
-        throw new Error(
-          'Context can only be read while React is rendering. ' +
-            'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-            'In function components, you can read it directly in the function body, but not ' +
-            'inside Hooks like useReducer() or useMemo().',
-        );
-      }
+  const contextItem = {
+    context: ((context: any): ReactContext<mixed>),
+    memoizedValue: value,
+    next: null,
+    select: ((select: any): (context: mixed) => Array<mixed>),
+    lastSelectedValue: select(value),
+  };
+
+  if (lastContextDependency === null) {
+    if (consumer === null) {
+      throw new Error(
+        'Context can only be read while React is rendering. ' +
+          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+          'In function components, you can read it directly in the function body, but not ' +
+          'inside Hooks like useReducer() or useMemo().',
+      );
+    }
 
-      // This is the first dependency for this component. Create a new list.
-      lastContextDependency = contextItem;
-      consumer.dependencies = __DEV__
-        ? {
-            lanes: NoLanes,
-            firstContext: contextItem,
-            _debugThenableState: null,
-          }
-        : {
-            lanes: NoLanes,
-            firstContext: contextItem,
-          };
-      if (enableLazyContextPropagation) {
-        consumer.flags |= NeedsPropagation;
-      }
-    } else {
-      // Append a new context item.
-      lastContextDependency = lastContextDependency.next = contextItem;
+    // This is the first dependency for this component. Create a new list.
+    lastContextDependency = contextItem;
+    consumer.dependencies = __DEV__
+      ? {
+          lanes: NoLanes,
+          firstContext: contextItem,
+          _debugThenableState: null,
+        }
+      : {
+          lanes: NoLanes,
+          firstContext: contextItem,
+        };
+    if (enableLazyContextPropagation) {
+      consumer.flags |= NeedsPropagation;
     }
+  } else {
+    // Append a new context item.
+    lastContextDependency = lastContextDependency.next = contextItem;
   }
   return value;
 }
@@ -854,44 +847,40 @@ function readContextForConsumer<C>(
     ? context._currentValue
     : context._currentValue2;
 
-  if (lastFullyObservedContext === context) {
-    // Nothing to do. We already observe everything in this context.
-  } else {
-    const contextItem = {
-      context: ((context: any): ReactContext<mixed>),
-      memoizedValue: value,
-      next: null,
-    };
-
-    if (lastContextDependency === null) {
-      if (consumer === null) {
-        throw new Error(
-          'Context can only be read while React is rendering. ' +
-            'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-            'In function components, you can read it directly in the function body, but not ' +
-            'inside Hooks like useReducer() or useMemo().',
-        );
-      }
+  const contextItem = {
+    context: ((context: any): ReactContext<mixed>),
+    memoizedValue: value,
+    next: null,
+  };
 
-      // This is the first dependency for this component. Create a new list.
-      lastContextDependency = contextItem;
-      consumer.dependencies = __DEV__
-        ? {
-            lanes: NoLanes,
-            firstContext: contextItem,
-            _debugThenableState: null,
-          }
-        : {
-            lanes: NoLanes,
-            firstContext: contextItem,
-          };
-      if (enableLazyContextPropagation) {
-        consumer.flags |= NeedsPropagation;
-      }
-    } else {
-      // Append a new context item.
-      lastContextDependency = lastContextDependency.next = contextItem;
+  if (lastContextDependency === null) {
+    if (consumer === null) {
+      throw new Error(
+        'Context can only be read while React is rendering. ' +
+          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
+          'In function components, you can read it directly in the function body, but not ' +
+          'inside Hooks like useReducer() or useMemo().',
+      );
+    }
+
+    // This is the first dependency for this component. Create a new list.
+    lastContextDependency = contextItem;
+    consumer.dependencies = __DEV__
+      ? {
+          lanes: NoLanes,
+          firstContext: contextItem,
+          _debugThenableState: null,
+        }
+      : {
+          lanes: NoLanes,
+          firstContext: contextItem,
+        };
+    if (enableLazyContextPropagation) {
+      consumer.flags |= NeedsPropagation;
     }
+  } else {
+    // Append a new context item.
+    lastContextDependency = lastContextDependency.next = contextItem;
   }
   return value;
 }

commit ef63718a27407b6d6b262d6be92e6bf0a87ff1a3
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Dec 13 13:58:18 2024 -0500

    Remove enableAsyncActions (#31757)
    
    Based on https://github.com/facebook/react/pull/31756
    
    This is landed everywhere

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 2e8d01e99e..190475519e 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -45,7 +45,6 @@ import {createUpdate, ForceUpdate} from './ReactFiberClassUpdateQueue';
 import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
 import {
   enableLazyContextPropagation,
-  enableAsyncActions,
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
 import {getHostTransitionProvider} from './ReactFiberHostContext';
@@ -598,7 +597,7 @@ function propagateParentContextChanges(
           }
         }
       }
-    } else if (enableAsyncActions && parent === getHostTransitionProvider()) {
+    } else if (parent === getHostTransitionProvider()) {
       // During a host transition, a host component can act like a context
       // provider. E.g. in React DOM, this would be a <form />.
       const currentParent = parent.alternate;

commit 909ed63e0adc162a95a4704d3ed07a956dcf9cd1
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Dec 16 12:32:07 2024 -0500

    Clean up context access profiling experiment (#31806)
    
    We introduced the `unstable_useContextWithBailout` API to run compiler
    based experiments. This API was designed to be an experiment proxy for
    alternative approaches which would be heavier to implement. The
    experiment turned out to be inconclusive. Since most of our performance
    critical usage is already optimized, we weren't able to find a clear win
    with this approach.
    
    Since we don't have further plans for this API, let's clean it up.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 190475519e..6a779cfd4a 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -12,7 +12,6 @@ import type {
   Fiber,
   ContextDependency,
   Dependencies,
-  ContextDependencyWithSelect,
 } from './ReactInternalTypes';
 import type {StackCursor} from './ReactFiberStack';
 import type {Lanes} from './ReactFiberLane';
@@ -48,8 +47,6 @@ import {
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
 import {getHostTransitionProvider} from './ReactFiberHostContext';
-import isArray from '../../shared/isArray';
-import {enableContextProfiling} from '../../shared/ReactFeatureFlags';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
 
@@ -69,10 +66,7 @@ if (__DEV__) {
 }
 
 let currentlyRenderingFiber: Fiber | null = null;
-let lastContextDependency:
-  | ContextDependency<mixed>
-  | ContextDependencyWithSelect<mixed>
-  | null = null;
+let lastContextDependency: ContextDependency<mixed> | null = null;
 
 let isDisallowedContextReadInDEV: boolean = false;
 
@@ -401,23 +395,6 @@ function propagateContextChanges<T>(
           const context: ReactContext<T> = contexts[i];
           // Check if the context matches.
           if (dependency.context === context) {
-            if (enableContextProfiling) {
-              const select = dependency.select;
-              if (select != null && dependency.lastSelectedValue != null) {
-                const newValue = isPrimaryRenderer
-                  ? dependency.context._currentValue
-                  : dependency.context._currentValue2;
-                if (
-                  !checkIfSelectedContextValuesChanged(
-                    dependency.lastSelectedValue,
-                    select(newValue),
-                  )
-                ) {
-                  // Compared value hasn't changed. Bail out early.
-                  continue findContext;
-                }
-              }
-            }
             // Match! Schedule an update on this fiber.
 
             // In the lazy implementation, don't mark a dirty flag on the
@@ -657,29 +634,6 @@ function propagateParentContextChanges(
   workInProgress.flags |= DidPropagateContext;
 }
 
-function checkIfSelectedContextValuesChanged(
-  oldComparedValue: Array<mixed>,
-  newComparedValue: Array<mixed>,
-): boolean {
-  // We have an implicit contract that compare functions must return arrays.
-  // This allows us to compare multiple values in the same context access
-  // since compiling to additional hook calls regresses perf.
-  if (isArray(oldComparedValue) && isArray(newComparedValue)) {
-    if (oldComparedValue.length !== newComparedValue.length) {
-      return true;
-    }
-
-    for (let i = 0; i < oldComparedValue.length; i++) {
-      if (!is(newComparedValue[i], oldComparedValue[i])) {
-        return true;
-      }
-    }
-  } else {
-    throw new Error('Compared context values must be arrays');
-  }
-  return false;
-}
-
 export function checkIfContextChanged(
   currentDependencies: Dependencies,
 ): boolean {
@@ -698,23 +652,8 @@ export function checkIfContextChanged(
       ? context._currentValue
       : context._currentValue2;
     const oldValue = dependency.memoizedValue;
-    if (
-      enableContextProfiling &&
-      dependency.select != null &&
-      dependency.lastSelectedValue != null
-    ) {
-      if (
-        checkIfSelectedContextValuesChanged(
-          dependency.lastSelectedValue,
-          dependency.select(newValue),
-        )
-      ) {
-        return true;
-      }
-    } else {
-      if (!is(newValue, oldValue)) {
-        return true;
-      }
+    if (!is(newValue, oldValue)) {
+      return true;
     }
     dependency = dependency.next;
   }
@@ -747,21 +686,6 @@ export function prepareToReadContext(
   }
 }
 
-export function readContextAndCompare<C>(
-  context: ReactContext<C>,
-  select: C => Array<mixed>,
-): C {
-  if (!(enableLazyContextPropagation && enableContextProfiling)) {
-    throw new Error('Not implemented.');
-  }
-
-  return readContextForConsumer_withSelect(
-    currentlyRenderingFiber,
-    context,
-    select,
-  );
-}
-
 export function readContext<T>(context: ReactContext<T>): T {
   if (__DEV__) {
     // This warning would fire if you read context inside a Hook like useMemo.
@@ -789,59 +713,10 @@ export function readContextDuringReconciliation<T>(
   return readContextForConsumer(consumer, context);
 }
 
-function readContextForConsumer_withSelect<C>(
-  consumer: Fiber | null,
-  context: ReactContext<C>,
-  select: C => Array<mixed>,
-): C {
-  const value = isPrimaryRenderer
-    ? context._currentValue
-    : context._currentValue2;
-
-  const contextItem = {
-    context: ((context: any): ReactContext<mixed>),
-    memoizedValue: value,
-    next: null,
-    select: ((select: any): (context: mixed) => Array<mixed>),
-    lastSelectedValue: select(value),
-  };
-
-  if (lastContextDependency === null) {
-    if (consumer === null) {
-      throw new Error(
-        'Context can only be read while React is rendering. ' +
-          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +
-          'In function components, you can read it directly in the function body, but not ' +
-          'inside Hooks like useReducer() or useMemo().',
-      );
-    }
-
-    // This is the first dependency for this component. Create a new list.
-    lastContextDependency = contextItem;
-    consumer.dependencies = __DEV__
-      ? {
-          lanes: NoLanes,
-          firstContext: contextItem,
-          _debugThenableState: null,
-        }
-      : {
-          lanes: NoLanes,
-          firstContext: contextItem,
-        };
-    if (enableLazyContextPropagation) {
-      consumer.flags |= NeedsPropagation;
-    }
-  } else {
-    // Append a new context item.
-    lastContextDependency = lastContextDependency.next = contextItem;
-  }
-  return value;
-}
-
-function readContextForConsumer<C>(
+function readContextForConsumer<T>(
   consumer: Fiber | null,
-  context: ReactContext<C>,
-): C {
+  context: ReactContext<T>,
+): T {
   const value = isPrimaryRenderer
     ? context._currentValue
     : context._currentValue2;

commit 34ee3919c39bc9b149462322713a9811db4b8498
Author: Jack Pope <jackpope1@gmail.com>
Date:   Tue Dec 17 11:56:00 2024 -0500

    Clean up enableLazyContextPropagation (#31810)
    
    This flag has shipped everywhere, let's clean it up.

diff --git a/packages/react-reconciler/src/ReactFiberNewContext.js b/packages/react-reconciler/src/ReactFiberNewContext.js
index 6a779cfd4a..b10dc5ce54 100644
--- a/packages/react-reconciler/src/ReactFiberNewContext.js
+++ b/packages/react-reconciler/src/ReactFiberNewContext.js
@@ -15,24 +15,13 @@ import type {
 } from './ReactInternalTypes';
 import type {StackCursor} from './ReactFiberStack';
 import type {Lanes} from './ReactFiberLane';
-import type {SharedQueue} from './ReactFiberClassUpdateQueue';
 import type {TransitionStatus} from './ReactFiberConfig';
 import type {Hook} from './ReactFiberHooks';
 
 import {isPrimaryRenderer, HostTransitionContext} from './ReactFiberConfig';
 import {createCursor, push, pop} from './ReactFiberStack';
-import {
-  ContextProvider,
-  ClassComponent,
-  DehydratedFragment,
-} from './ReactWorkTags';
-import {
-  NoLanes,
-  isSubsetOfLanes,
-  includesSomeLane,
-  mergeLanes,
-  pickArbitraryLane,
-} from './ReactFiberLane';
+import {ContextProvider, DehydratedFragment} from './ReactWorkTags';
+import {NoLanes, isSubsetOfLanes, mergeLanes} from './ReactFiberLane';
 import {
   NoFlags,
   DidPropagateContext,
@@ -40,12 +29,7 @@ import {
 } from './ReactFiberFlags';
 
 import is from 'shared/objectIs';
-import {createUpdate, ForceUpdate} from './ReactFiberClassUpdateQueue';
-import {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';
-import {
-  enableLazyContextPropagation,
-  enableRenderableContext,
-} from 'shared/ReactFeatureFlags';
+import {enableRenderableContext} from 'shared/ReactFeatureFlags';
 import {getHostTransitionProvider} from './ReactFiberHostContext';
 
 const valueCursor: StackCursor<mixed> = createCursor(null);
@@ -210,157 +194,16 @@ export function propagateContextChange<T>(
   context: ReactContext<T>,
   renderLanes: Lanes,
 ): void {
-  if (enableLazyContextPropagation) {
-    // TODO: This path is only used by Cache components. Update
-    // lazilyPropagateParentContextChanges to look for Cache components so they
-    // can take advantage of lazy propagation.
-    const forcePropagateEntireTree = true;
-    propagateContextChanges(
-      workInProgress,
-      [context],
-      renderLanes,
-      forcePropagateEntireTree,
-    );
-  } else {
-    propagateContextChange_eager(workInProgress, context, renderLanes);
-  }
-}
-
-function propagateContextChange_eager<T>(
-  workInProgress: Fiber,
-  context: ReactContext<T>,
-  renderLanes: Lanes,
-): void {
-  // Only used by eager implementation
-  if (enableLazyContextPropagation) {
-    return;
-  }
-  let fiber = workInProgress.child;
-  if (fiber !== null) {
-    // Set the return pointer of the child to the work-in-progress fiber.
-    fiber.return = workInProgress;
-  }
-  while (fiber !== null) {
-    let nextFiber;
-
-    // Visit this fiber.
-    const list = fiber.dependencies;
-    if (list !== null) {
-      nextFiber = fiber.child;
-
-      let dependency = list.firstContext;
-      while (dependency !== null) {
-        // Check if the context matches.
-        if (dependency.context === context) {
-          // Match! Schedule an update on this fiber.
-          if (fiber.tag === ClassComponent) {
-            // Schedule a force update on the work-in-progress.
-            const lane = pickArbitraryLane(renderLanes);
-            const update = createUpdate(lane);
-            update.tag = ForceUpdate;
-            // TODO: Because we don't have a work-in-progress, this will add the
-            // update to the current fiber, too, which means it will persist even if
-            // this render is thrown away. Since it's a race condition, not sure it's
-            // worth fixing.
-
-            // Inlined `enqueueUpdate` to remove interleaved update check
-            const updateQueue = fiber.updateQueue;
-            if (updateQueue === null) {
-              // Only occurs if the fiber has been unmounted.
-            } else {
-              const sharedQueue: SharedQueue<any> = (updateQueue: any).shared;
-              const pending = sharedQueue.pending;
-              if (pending === null) {
-                // This is the first update. Create a circular list.
-                update.next = update;
-              } else {
-                update.next = pending.next;
-                pending.next = update;
-              }
-              sharedQueue.pending = update;
-            }
-          }
-
-          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
-          const alternate = fiber.alternate;
-          if (alternate !== null) {
-            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
-          }
-          scheduleContextWorkOnParentPath(
-            fiber.return,
-            renderLanes,
-            workInProgress,
-          );
-
-          // Mark the updated lanes on the list, too.
-          list.lanes = mergeLanes(list.lanes, renderLanes);
-
-          // Since we already found a match, we can stop traversing the
-          // dependency list.
-          break;
-        }
-        dependency = dependency.next;
-      }
-    } else if (fiber.tag === ContextProvider) {
-      // Don't scan deeper if this is a matching provider
-      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
-    } else if (fiber.tag === DehydratedFragment) {
-      // If a dehydrated suspense boundary is in this subtree, we don't know
-      // if it will have any context consumers in it. The best we can do is
-      // mark it as having updates.
-      const parentSuspense = fiber.return;
-
-      if (parentSuspense === null) {
-        throw new Error(
-          'We just came from a parent so we must have had a parent. This is a bug in React.',
-        );
-      }
-
-      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);
-      const alternate = parentSuspense.alternate;
-      if (alternate !== null) {
-        alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
-      }
-      // This is intentionally passing this fiber as the parent
-      // because we want to schedule this fiber as having work
-      // on its children. We'll use the childLanes on
-      // this fiber to indicate that a context has changed.
-      scheduleContextWorkOnParentPath(
-        parentSuspense,
-        renderLanes,
-        workInProgress,
-      );
-      nextFiber = fiber.sibling;
-    } else {
-      // Traverse down.
-      nextFiber = fiber.child;
-    }
-
-    if (nextFiber !== null) {
-      // Set the return pointer of the child to the work-in-progress fiber.
-      nextFiber.return = fiber;
-    } else {
-      // No child. Traverse to next sibling.
-      nextFiber = fiber;
-      while (nextFiber !== null) {
-        if (nextFiber === workInProgress) {
-          // We're back to the root of this subtree. Exit.
-          nextFiber = null;
-          break;
-        }
-        const sibling = nextFiber.sibling;
-        if (sibling !== null) {
-          // Set the return pointer of the sibling to the work-in-progress fiber.
-          sibling.return = nextFiber.return;
-          nextFiber = sibling;
-          break;
-        }
-        // No more siblings. Traverse up.
-        nextFiber = nextFiber.return;
-      }
-    }
-    fiber = nextFiber;
-  }
+  // TODO: This path is only used by Cache components. Update
+  // lazilyPropagateParentContextChanges to look for Cache components so they
+  // can take advantage of lazy propagation.
+  const forcePropagateEntireTree = true;
+  propagateContextChanges(
+    workInProgress,
+    [context],
+    renderLanes,
+    forcePropagateEntireTree,
+  );
 }
 
 function propagateContextChanges<T>(
@@ -369,10 +212,6 @@ function propagateContextChanges<T>(
   renderLanes: Lanes,
   forcePropagateEntireTree: boolean,
 ): void {
-  // Only used by lazy implementation
-  if (!enableLazyContextPropagation) {
-    return;
-  }
   let fiber = workInProgress.child;
   if (fiber !== null) {
     // Set the return pointer of the child to the work-in-progress fiber.
@@ -527,10 +366,6 @@ function propagateParentContextChanges(
   renderLanes: Lanes,
   forcePropagateEntireTree: boolean,
 ) {
-  if (!enableLazyContextPropagation) {
-    return;
-  }
-
   // Collect all the parent providers that changed. Since this is usually small
   // number, we use an Array instead of Set.
   let contexts = null;
@@ -637,9 +472,6 @@ function propagateParentContextChanges(
 export function checkIfContextChanged(
   currentDependencies: Dependencies,
 ): boolean {
-  if (!enableLazyContextPropagation) {
-    return false;
-  }
   // Iterate over the current dependencies to see if something changed. This
   // only gets called if props and state has already bailed out, so it's a
   // relatively uncommon path, except at the root of a changed subtree.
@@ -669,20 +501,8 @@ export function prepareToReadContext(
 
   const dependencies = workInProgress.dependencies;
   if (dependencies !== null) {
-    if (enableLazyContextPropagation) {
-      // Reset the work-in-progress list
-      dependencies.firstContext = null;
-    } else {
-      const firstContext = dependencies.firstContext;
-      if (firstContext !== null) {
-        if (includesSomeLane(dependencies.lanes, renderLanes)) {
-          // Context list has a pending update. Mark that this fiber performed work.
-          markWorkInProgressReceivedUpdate();
-        }
-        // Reset the work-in-progress list
-        dependencies.firstContext = null;
-      }
-    }
+    // Reset the work-in-progress list
+    dependencies.firstContext = null;
   }
 }
 
@@ -749,9 +569,7 @@ function readContextForConsumer<T>(
           lanes: NoLanes,
           firstContext: contextItem,
         };
-    if (enableLazyContextPropagation) {
-      consumer.flags |= NeedsPropagation;
-    }
+    consumer.flags |= NeedsPropagation;
   } else {
     // Append a new context item.
     lastContextDependency = lastContextDependency.next = contextItem;

