# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/__tests__/ReactCache-test.js

commit efc57e5cbbd618f3c98d941c48eec859026c2dcb
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Dec 18 12:57:24 2020 -0600

    Add built-in Suspense cache with support for invalidation (refreshing) (#20456)

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
new file mode 100644
index 0000000000..1574fc2228
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -0,0 +1,916 @@
+let React;
+let ReactNoop;
+let Cache;
+let getCacheForType;
+let Scheduler;
+let Suspense;
+let useCacheRefresh;
+let startTransition;
+let useState;
+
+let textService;
+let textServiceVersion;
+
+describe('ReactCache', () => {
+  beforeEach(() => {
+    jest.resetModules();
+
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+    Cache = React.unstable_Cache;
+    Scheduler = require('scheduler');
+    Suspense = React.Suspense;
+    getCacheForType = React.unstable_getCacheForType;
+    useCacheRefresh = React.unstable_useCacheRefresh;
+    startTransition = React.unstable_startTransition;
+    useState = React.useState;
+
+    // Represents some data service that returns text. It likely has additional
+    // caching layers, like a CDN or the local browser cache. It can be mutated
+    // or emptied independently of the React cache.
+    textService = new Map();
+    textServiceVersion = 1;
+  });
+
+  function createTextCache() {
+    return new Map();
+  }
+
+  function readText(text) {
+    const textCache = getCacheForType(createTextCache);
+    const record = textCache.get(text);
+    if (record !== undefined) {
+      switch (record.status) {
+        case 'pending':
+          throw record.value;
+        case 'rejected':
+          throw record.value;
+        case 'resolved':
+          return record.value;
+      }
+    } else {
+      Scheduler.unstable_yieldValue(`Cache miss! [${text}]`);
+
+      let request = textService.get(text);
+      if (request === undefined) {
+        let resolve;
+        let reject;
+        request = new Promise((res, rej) => {
+          resolve = res;
+          reject = rej;
+        });
+        request.resolve = resolve;
+        request.reject = reject;
+
+        // Add the request to a backing cache. This may outlive the lifetime
+        // of the component that is currently reading the data.
+        textService.set(text, request);
+      }
+
+      const thenable = request.then(
+        value => {
+          if (newRecord.status === 'pending') {
+            newRecord.status = 'resolved';
+            newRecord.value = value;
+          }
+        },
+        error => {
+          if (newRecord.status === 'pending') {
+            newRecord.status = 'rejected';
+            newRecord.value = error;
+          }
+        },
+      );
+
+      const newRecord = {
+        ping: null,
+        status: 'pending',
+        value: thenable,
+      };
+      textCache.set(text, newRecord);
+
+      throw thenable;
+    }
+  }
+
+  function mutateRemoteTextService() {
+    textService = new Map();
+    textServiceVersion++;
+  }
+
+  function resolveText(text) {
+    const request = textService.get(text);
+    if (request !== undefined) {
+      request.resolve(textServiceVersion);
+      return request;
+    } else {
+      const newRequest = Promise.resolve(textServiceVersion);
+      newRequest.resolve = newRequest.reject = () => {};
+      textService.set(text, newRequest);
+      return newRequest;
+    }
+  }
+
+  function Text({text}) {
+    Scheduler.unstable_yieldValue(text);
+    return text;
+  }
+
+  function AsyncText({text, showVersion}) {
+    const version = readText(text);
+    const fullText = showVersion ? `${text} [v${version}]` : text;
+    Scheduler.unstable_yieldValue(fullText);
+    return fullText;
+  }
+
+  // @gate experimental
+  test('render Cache component', async () => {
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<Cache>Hi</Cache>);
+    });
+    expect(root).toMatchRenderedOutput('Hi');
+  });
+
+  // @gate experimental
+  test('mount new data', async () => {
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Cache>
+          <Suspense fallback={<Text text="Loading..." />}>
+            <AsyncText text="A" />
+          </Suspense>
+        </Cache>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A']);
+    expect(root).toMatchRenderedOutput('A');
+  });
+
+  // @gate experimental
+  test('root acts as implicit cache boundary', async () => {
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Suspense fallback={<Text text="Loading..." />}>
+          <AsyncText text="A" />
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A']);
+    expect(root).toMatchRenderedOutput('A');
+  });
+
+  // @gate experimental
+  test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
+    function App({text}) {
+      return (
+        <>
+          <Cache>
+            <Suspense fallback={<Text text="Loading..." />}>
+              <AsyncText text="A" />
+            </Suspense>
+          </Cache>
+          <Cache>
+            <Suspense fallback={<Text text="Loading..." />}>
+              <AsyncText text="A" />
+            </Suspense>
+          </Cache>
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App showMore={false} />);
+    });
+    // Even though there are two new <Cache /> trees, they should share the same
+    // data cache. So there should be only a single cache miss for A.
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'Loading...',
+    ]);
+    expect(root).toMatchRenderedOutput('Loading...Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A', 'A']);
+    expect(root).toMatchRenderedOutput('AA');
+  });
+
+  // @gate experimental
+  test(
+    'nested cache boundaries share the same cache as the root during ' +
+      'the initial render',
+    async () => {
+      function App() {
+        return (
+          <Suspense fallback={<Text text="Loading..." />}>
+            <AsyncText text="A" />
+            <Cache>
+              <AsyncText text="A" />
+            </Cache>
+          </Suspense>
+        );
+      }
+
+      const root = ReactNoop.createRoot();
+      await ReactNoop.act(async () => {
+        root.render(<App />);
+      });
+      // Even though there are two new <Cache /> trees, they should share the same
+      // data cache. So there should be only a single cache miss for A.
+      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+      expect(root).toMatchRenderedOutput('Loading...');
+
+      await ReactNoop.act(async () => {
+        await resolveText('A');
+      });
+      expect(Scheduler).toHaveYielded(['A', 'A']);
+      expect(root).toMatchRenderedOutput('AA');
+    },
+  );
+
+  // @gate experimental
+  test('new content inside an existing Cache boundary should re-use already cached data', async () => {
+    function App({showMore}) {
+      return (
+        <Cache>
+          <Suspense fallback={<Text text="Loading..." />}>
+            <AsyncText showVersion={true} text="A" />
+          </Suspense>
+          {showMore ? (
+            <Suspense fallback={<Text text="Loading..." />}>
+              <AsyncText showVersion={true} text="A" />
+            </Suspense>
+          ) : null}
+        </Cache>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'A [v1]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Simulate a server mutation.
+    mutateRemoteTextService();
+
+    // Add a new cache boundary
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={true} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'A [v1]',
+      // New tree should use already cached data
+      'A [v1]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
+  });
+
+  // @gate experimental
+  test('a new Cache boundary uses fresh cache', async () => {
+    // The only difference from the previous test is that the "Show More"
+    // content is wrapped in a nested <Cache /> boundary
+    function App({showMore}) {
+      return (
+        <Cache>
+          <Suspense fallback={<Text text="Loading..." />}>
+            <AsyncText showVersion={true} text="A" />
+          </Suspense>
+          {showMore ? (
+            <Cache>
+              <Suspense fallback={<Text text="Loading..." />}>
+                <AsyncText showVersion={true} text="A" />
+              </Suspense>
+            </Cache>
+          ) : null}
+        </Cache>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'A [v1]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Simulate a server mutation.
+    mutateRemoteTextService();
+
+    // Add a new cache boundary
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={true} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'A [v1]',
+      // New tree should load fresh data.
+      'Cache miss! [A]',
+      'Loading...',
+      'A [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
+  });
+
+  // @gate experimental
+  test('inner content uses same cache as shell if spawned by the same transition', async () => {
+    const root = ReactNoop.createRoot();
+
+    function App() {
+      return (
+        <Cache>
+          <Suspense fallback={<Text text="Loading shell..." />}>
+            {/* The shell reads A */}
+            <Shell>
+              {/* The inner content reads both A and B */}
+              <Suspense fallback={<Text text="Loading content..." />}>
+                <Cache>
+                  <Content />
+                </Cache>
+              </Suspense>
+            </Shell>
+          </Suspense>
+        </Cache>
+      );
+    }
+
+    function Shell({children}) {
+      readText('A');
+      return (
+        <>
+          <div>
+            <Text text="Shell" />
+          </div>
+          <div>{children}</div>
+        </>
+      );
+    }
+
+    function Content() {
+      readText('A');
+      readText('B');
+      return <Text text="Content" />;
+    }
+
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);
+    expect(root).toMatchRenderedOutput('Loading shell...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Shell',
+      // There's a cache miss for B, because it hasn't been read yet. But not
+      // A, because it was cached when we rendered the shell.
+      'Cache miss! [B]',
+      'Loading content...',
+    ]);
+    expect(root).toMatchRenderedOutput(
+      <>
+        <div>Shell</div>
+        <div>Loading content...</div>
+      </>,
+    );
+
+    await ReactNoop.act(async () => {
+      await resolveText('B');
+    });
+    expect(Scheduler).toHaveYielded(['Content']);
+    expect(root).toMatchRenderedOutput(
+      <>
+        <div>Shell</div>
+        <div>Content</div>
+      </>,
+    );
+  });
+
+  // @gate experimental
+  test('refresh a cache', async () => {
+    let refresh;
+    function App() {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text="A" />;
+    }
+
+    // Mount initial data
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Cache>
+          <Suspense fallback={<Text text="Loading..." />}>
+            <App />
+          </Suspense>
+        </Cache>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Mutate the text service, then refresh for new data.
+    mutateRemoteTextService();
+    await ReactNoop.act(async () => {
+      startTransition(() => refresh());
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    // Note that the version has updated
+    expect(Scheduler).toHaveYielded(['A [v2]']);
+    expect(root).toMatchRenderedOutput('A [v2]');
+  });
+
+  // @gate experimental
+  test('refresh the root cache', async () => {
+    let refresh;
+    function App() {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text="A" />;
+    }
+
+    // Mount initial data
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Suspense fallback={<Text text="Loading..." />}>
+          <App />
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Mutate the text service, then refresh for new data.
+    mutateRemoteTextService();
+    await ReactNoop.act(async () => {
+      startTransition(() => refresh());
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    // Note that the version has updated
+    expect(Scheduler).toHaveYielded(['A [v2]']);
+    expect(root).toMatchRenderedOutput('A [v2]');
+  });
+
+  // @gate experimental
+  test('refresh a cache with seed data', async () => {
+    let refresh;
+    function App() {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text="A" />;
+    }
+
+    // Mount initial data
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Cache>
+          <Suspense fallback={<Text text="Loading..." />}>
+            <App />
+          </Suspense>
+        </Cache>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Mutate the text service, then refresh for new data.
+    mutateRemoteTextService();
+    await ReactNoop.act(async () => {
+      // Refresh the cache with seeded data, like you would receive from a
+      // server mutation.
+      // TODO: Seeding multiple typed caches. Should work by calling `refresh`
+      // multiple times with different key/value pairs
+      const seededCache = new Map();
+      seededCache.set('A', {
+        ping: null,
+        status: 'resolved',
+        value: textServiceVersion,
+      });
+      startTransition(() => refresh(createTextCache, seededCache));
+    });
+    // The root should re-render without a cache miss.
+    expect(Scheduler).toHaveYielded(['A [v2]']);
+    expect(root).toMatchRenderedOutput('A [v2]');
+  });
+
+  // @gate experimental
+  test('refreshing a parent cache also refreshes its children', async () => {
+    let refreshShell;
+    function RefreshShell() {
+      refreshShell = useCacheRefresh();
+      return null;
+    }
+
+    function App({showMore}) {
+      return (
+        <Cache>
+          <RefreshShell />
+          <Suspense fallback={<Text text="Loading..." />}>
+            <AsyncText showVersion={true} text="A" />
+          </Suspense>
+          {showMore ? (
+            <Cache>
+              <Suspense fallback={<Text text="Loading..." />}>
+                <AsyncText showVersion={true} text="A" />
+              </Suspense>
+            </Cache>
+          ) : null}
+        </Cache>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'A [v1]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Simulate a server mutation.
+    mutateRemoteTextService();
+
+    // Add a new cache boundary
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App showMore={true} />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'A [v1]',
+      // New tree should load fresh data.
+      'Cache miss! [A]',
+      'Loading...',
+      'A [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
+
+    // Now refresh the shell. This should also cause the "Show More" contents to
+    // refresh, since its cache is nested inside the outer one.
+    mutateRemoteTextService();
+    await ReactNoop.act(async () => {
+      startTransition(() => refreshShell());
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'Loading...',
+    ]);
+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
+
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v3]', 'A [v3]']);
+    expect(root).toMatchRenderedOutput('A [v3]A [v3]');
+  });
+
+  // @gate experimental
+  test(
+    'refreshing a cache boundary does not refresh the other boundaries ' +
+      'that mounted at the same time (i.e. the ones that share the same cache)',
+    async () => {
+      let refreshFirstBoundary;
+      function RefreshFirstBoundary() {
+        refreshFirstBoundary = useCacheRefresh();
+        return null;
+      }
+
+      function App({showMore}) {
+        return showMore ? (
+          <>
+            <Cache>
+              <Suspense fallback={<Text text="Loading..." />}>
+                <RefreshFirstBoundary />
+                <AsyncText showVersion={true} text="A" />
+              </Suspense>
+            </Cache>
+            <Cache>
+              <Suspense fallback={<Text text="Loading..." />}>
+                <AsyncText showVersion={true} text="A" />
+              </Suspense>
+            </Cache>
+          </>
+        ) : null;
+      }
+
+      // First mount the initial shell without the nested boundaries. This is
+      // necessary for this test because we want the two inner boundaries to be
+      // treated like sibling providers that happen to share an underlying
+      // cache, as opposed to consumers of the root-level cache.
+      const root = ReactNoop.createRoot();
+      await ReactNoop.act(async () => {
+        root.render(<App showMore={false} />);
+      });
+
+      // Now reveal the boundaries. In a real app  this would be a navigation.
+      await ReactNoop.act(async () => {
+        root.render(<App showMore={true} />);
+      });
+
+      // Even though there are two new <Cache /> trees, they should share the same
+      // data cache. So there should be only a single cache miss for A.
+      expect(Scheduler).toHaveYielded([
+        'Cache miss! [A]',
+        'Loading...',
+        'Loading...',
+      ]);
+      expect(root).toMatchRenderedOutput('Loading...Loading...');
+
+      await ReactNoop.act(async () => {
+        await resolveText('A');
+      });
+      expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
+      expect(root).toMatchRenderedOutput('A [v1]A [v1]');
+
+      // Refresh the first boundary. It should not refresh the second boundary,
+      // even though they previously shared the same underlying cache.
+      mutateRemoteTextService();
+      await ReactNoop.act(async () => {
+        await refreshFirstBoundary();
+      });
+      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+
+      await ReactNoop.act(async () => {
+        await resolveText('A');
+      });
+      expect(Scheduler).toHaveYielded(['A [v2]']);
+      expect(root).toMatchRenderedOutput('A [v2]A [v1]');
+    },
+  );
+
+  // @gate experimental
+  test(
+    'mount a new Cache boundary in a sibling while simultaneously ' +
+      'resolving a Suspense boundary',
+    async () => {
+      function App({showMore}) {
+        return (
+          <>
+            {showMore ? (
+              <Suspense fallback={<Text text="Loading..." />}>
+                <Cache>
+                  <AsyncText showVersion={true} text="A" />
+                </Cache>
+              </Suspense>
+            ) : null}
+            <Suspense fallback={<Text text="Loading..." />}>
+              <Cache>
+                {' '}
+                <AsyncText showVersion={true} text="A" />{' '}
+                <AsyncText showVersion={true} text="B" />
+              </Cache>
+            </Suspense>
+          </>
+        );
+      }
+
+      const root = ReactNoop.createRoot();
+      await ReactNoop.act(async () => {
+        root.render(<App showMore={false} />);
+      });
+      expect(Scheduler).toHaveYielded([
+        'Cache miss! [A]',
+        'Cache miss! [B]',
+        'Loading...',
+      ]);
+
+      await ReactNoop.act(async () => {
+        // This will resolve the content in the first cache
+        resolveText('A');
+        resolveText('B');
+        // Now let's simulate a mutation
+        mutateRemoteTextService();
+        // And mount the second tree, which includes new content
+        root.render(<App showMore={true} />);
+      });
+      expect(Scheduler).toHaveYielded([
+        // The new tree should use a fresh cache
+        'Cache miss! [A]',
+        'Loading...',
+        // The other tree uses the cached responses. This demonstrates that the
+        // requests are not dropped.
+        'A [v1]',
+        'B [v1]',
+      ]);
+
+      // Now resolve the second tree
+      await ReactNoop.act(async () => {
+        resolveText('A');
+      });
+      expect(Scheduler).toHaveYielded(['A [v2]']);
+      expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
+    },
+  );
+
+  // @gate experimental
+  test('cache pool is cleared once transitions that depend on it commit their shell', async () => {
+    function Child({text}) {
+      return (
+        <Cache>
+          <AsyncText text={text} />
+        </Cache>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(
+        <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('(empty)');
+
+    await ReactNoop.act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback={<Text text="Loading..." />}>
+            <Child text="A" />
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('(empty)');
+
+    await ReactNoop.act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback={<Text text="Loading..." />}>
+            <Child text="A" />
+            <Child text="A" />
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded([
+      // No cache miss, because it uses the pooled cache
+      'Loading...',
+    ]);
+    expect(root).toMatchRenderedOutput('(empty)');
+
+    // Resolve the request
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+    });
+    expect(Scheduler).toHaveYielded(['A', 'A']);
+    expect(root).toMatchRenderedOutput('AA');
+
+    // Now do another transition
+    await ReactNoop.act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback={<Text text="Loading..." />}>
+            <Child text="A" />
+            <Child text="A" />
+            <Child text="A" />
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded([
+      // First two children use the old cache because they already finished
+      'A',
+      'A',
+      // The new child uses a fresh cache
+      'Cache miss! [A]',
+      'Loading...',
+      'A',
+      'A',
+      'A',
+    ]);
+    expect(root).toMatchRenderedOutput('AAA');
+  });
+
+  // @gate experimental
+  test('cache pool is not cleared by arbitrary commits', async () => {
+    function App() {
+      return (
+        <>
+          <ShowMore />
+          <Unrelated />
+        </>
+      );
+    }
+
+    let showMore;
+    function ShowMore() {
+      const [shouldShow, _showMore] = useState(false);
+      showMore = () => _showMore(true);
+      return (
+        <>
+          <Suspense fallback={<Text text="Loading..." />}>
+            {shouldShow ? (
+              <Cache>
+                <AsyncText text="A" />
+              </Cache>
+            ) : null}
+          </Suspense>
+        </>
+      );
+    }
+
+    let updateUnrelated;
+    function Unrelated() {
+      const [count, _updateUnrelated] = useState(0);
+      updateUnrelated = _updateUnrelated;
+      return <Text text={count + ''} />;
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App showMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded(['0']);
+    expect(root).toMatchRenderedOutput('0');
+
+    await ReactNoop.act(async () => {
+      startTransition(() => {
+        showMore();
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('0');
+
+    await ReactNoop.act(async () => {
+      updateUnrelated(1);
+    });
+    expect(Scheduler).toHaveYielded([
+      '1',
+
+      // Happens to re-render the fallback. Doesn't need to, but not relevant
+      // to this test.
+      'Loading...',
+    ]);
+    expect(root).toMatchRenderedOutput('1');
+
+    await ReactNoop.act(async () => {
+      resolveText('A');
+      mutateRemoteTextService();
+    });
+    expect(Scheduler).toHaveYielded(['A']);
+    expect(root).toMatchRenderedOutput('A1');
+  });
+});

commit 9043626f09c7d02a81b1ed89236e8f88d44fdc7e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jan 19 15:54:45 2021 -0600

    Cache tests: Make it easier to test many caches (#20600)
    
    Some rearranging to make it easier to write tests that assert on the
    output of multiple caches.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 1574fc2228..ef14b6588e 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -8,8 +8,8 @@ let useCacheRefresh;
 let startTransition;
 let useState;
 
-let textService;
-let textServiceVersion;
+let caches;
+let seededCache;
 
 describe('ReactCache', () => {
   beforeEach(() => {
@@ -25,20 +25,57 @@ describe('ReactCache', () => {
     startTransition = React.unstable_startTransition;
     useState = React.useState;
 
-    // Represents some data service that returns text. It likely has additional
-    // caching layers, like a CDN or the local browser cache. It can be mutated
-    // or emptied independently of the React cache.
-    textService = new Map();
-    textServiceVersion = 1;
+    caches = [];
+    seededCache = null;
   });
 
   function createTextCache() {
-    return new Map();
+    if (seededCache !== null) {
+      // Trick to seed a cache before it exists.
+      // TODO: Need a built-in API to seed data before the initial render (i.e.
+      // not a refresh because nothing has mounted yet).
+      const cache = seededCache;
+      seededCache = null;
+      return cache;
+    }
+
+    const data = new Map();
+    const version = caches.length + 1;
+    const cache = {
+      version,
+      data,
+      resolve(text) {
+        const record = data.get(text);
+        if (record === undefined) {
+          const newRecord = {
+            status: 'resolved',
+            value: text,
+          };
+          data.set(text, newRecord);
+        } else if (record.status === 'pending') {
+          record.value.resolve();
+        }
+      },
+      reject(text, error) {
+        const record = data.get(text);
+        if (record === undefined) {
+          const newRecord = {
+            status: 'rejected',
+            value: error,
+          };
+          data.set(text, newRecord);
+        } else if (record.status === 'pending') {
+          record.value.reject();
+        }
+      },
+    };
+    caches.push(cache);
+    return cache;
   }
 
   function readText(text) {
     const textCache = getCacheForType(createTextCache);
-    const record = textCache.get(text);
+    const record = textCache.data.get(text);
     if (record !== undefined) {
       switch (record.status) {
         case 'pending':
@@ -46,28 +83,17 @@ describe('ReactCache', () => {
         case 'rejected':
           throw record.value;
         case 'resolved':
-          return record.value;
+          return textCache.version;
       }
     } else {
       Scheduler.unstable_yieldValue(`Cache miss! [${text}]`);
 
-      let request = textService.get(text);
-      if (request === undefined) {
-        let resolve;
-        let reject;
-        request = new Promise((res, rej) => {
-          resolve = res;
-          reject = rej;
-        });
-        request.resolve = resolve;
-        request.reject = reject;
-
-        // Add the request to a backing cache. This may outlive the lifetime
-        // of the component that is currently reading the data.
-        textService.set(text, request);
-      }
-
-      const thenable = request.then(
+      let resolve;
+      let reject;
+      const thenable = new Promise((res, rej) => {
+        resolve = res;
+        reject = rej;
+      }).then(
         value => {
           if (newRecord.status === 'pending') {
             newRecord.status = 'resolved';
@@ -81,36 +107,19 @@ describe('ReactCache', () => {
           }
         },
       );
+      thenable.resolve = resolve;
+      thenable.reject = reject;
 
       const newRecord = {
-        ping: null,
         status: 'pending',
         value: thenable,
       };
-      textCache.set(text, newRecord);
+      textCache.data.set(text, newRecord);
 
       throw thenable;
     }
   }
 
-  function mutateRemoteTextService() {
-    textService = new Map();
-    textServiceVersion++;
-  }
-
-  function resolveText(text) {
-    const request = textService.get(text);
-    if (request !== undefined) {
-      request.resolve(textServiceVersion);
-      return request;
-    } else {
-      const newRequest = Promise.resolve(textServiceVersion);
-      newRequest.resolve = newRequest.reject = () => {};
-      textService.set(text, newRequest);
-      return newRequest;
-    }
-  }
-
   function Text({text}) {
     Scheduler.unstable_yieldValue(text);
     return text;
@@ -123,6 +132,23 @@ describe('ReactCache', () => {
     return fullText;
   }
 
+  function seedNextTextCache(text) {
+    if (seededCache === null) {
+      seededCache = createTextCache();
+    }
+    seededCache.resolve(text);
+  }
+
+  function resolveMostRecentTextCache(text) {
+    if (caches.length === 0) {
+      throw Error('Cache does not exist.');
+    } else {
+      // Resolve the most recently created cache. An older cache can by
+      // resolved with `caches[index].resolve(text)`.
+      caches[caches.length - 1].resolve(text);
+    }
+  }
+
   // @gate experimental
   test('render Cache component', async () => {
     const root = ReactNoop.createRoot();
@@ -148,7 +174,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);
     expect(root).toMatchRenderedOutput('A');
@@ -168,7 +194,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);
     expect(root).toMatchRenderedOutput('A');
@@ -207,7 +233,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
@@ -239,7 +265,7 @@ describe('ReactCache', () => {
       expect(root).toMatchRenderedOutput('Loading...');
 
       await ReactNoop.act(async () => {
-        await resolveText('A');
+        resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A', 'A']);
       expect(root).toMatchRenderedOutput('AA');
@@ -265,22 +291,14 @@ describe('ReactCache', () => {
 
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'A [v1]',
-    ]);
+    expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Simulate a server mutation.
-    mutateRemoteTextService();
-
     // Add a new cache boundary
     await ReactNoop.act(async () => {
-      await resolveText('A');
       root.render(<App showMore={true} />);
     });
     expect(Scheduler).toHaveYielded([
@@ -314,22 +332,14 @@ describe('ReactCache', () => {
 
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'A [v1]',
-    ]);
+    expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Simulate a server mutation.
-    mutateRemoteTextService();
-
     // Add a new cache boundary
     await ReactNoop.act(async () => {
-      await resolveText('A');
       root.render(<App showMore={true} />);
     });
     expect(Scheduler).toHaveYielded([
@@ -337,8 +347,12 @@ describe('ReactCache', () => {
       // New tree should load fresh data.
       'Cache miss! [A]',
       'Loading...',
-      'A [v2]',
     ]);
+    expect(root).toMatchRenderedOutput('A [v1]Loading...');
+    await ReactNoop.act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
   });
 
@@ -389,7 +403,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading shell...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded([
       'Shell',
@@ -406,7 +420,7 @@ describe('ReactCache', () => {
     );
 
     await ReactNoop.act(async () => {
-      await resolveText('B');
+      resolveMostRecentTextCache('B');
     });
     expect(Scheduler).toHaveYielded(['Content']);
     expect(root).toMatchRenderedOutput(
@@ -440,13 +454,12 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Mutate the text service, then refresh for new data.
-    mutateRemoteTextService();
+    // Fefresh for new data.
     await ReactNoop.act(async () => {
       startTransition(() => refresh());
     });
@@ -454,7 +467,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
     expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -482,13 +495,12 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Mutate the text service, then refresh for new data.
-    mutateRemoteTextService();
+    // Refresh for new data.
     await ReactNoop.act(async () => {
       startTransition(() => refresh());
     });
@@ -496,7 +508,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
     expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -526,25 +538,20 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Loading...');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Mutate the text service, then refresh for new data.
-    mutateRemoteTextService();
+    // Refresh for new data.
     await ReactNoop.act(async () => {
       // Refresh the cache with seeded data, like you would receive from a
       // server mutation.
       // TODO: Seeding multiple typed caches. Should work by calling `refresh`
       // multiple times with different key/value pairs
-      const seededCache = new Map();
-      seededCache.set('A', {
-        ping: null,
-        status: 'resolved',
-        value: textServiceVersion,
-      });
-      startTransition(() => refresh(createTextCache, seededCache));
+      const cache = createTextCache();
+      cache.resolve('A');
+      startTransition(() => refresh(createTextCache, cache));
     });
     // The root should re-render without a cache miss.
     expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -579,36 +586,26 @@ describe('ReactCache', () => {
 
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'A [v1]',
-    ]);
+    expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Simulate a server mutation.
-    mutateRemoteTextService();
-
     // Add a new cache boundary
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      seedNextTextCache('A');
       root.render(<App showMore={true} />);
     });
     expect(Scheduler).toHaveYielded([
       'A [v1]',
       // New tree should load fresh data.
-      'Cache miss! [A]',
-      'Loading...',
       'A [v2]',
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
     // Now refresh the shell. This should also cause the "Show More" contents to
     // refresh, since its cache is nested inside the outer one.
-    mutateRemoteTextService();
     await ReactNoop.act(async () => {
       startTransition(() => refreshShell());
     });
@@ -620,7 +617,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v3]', 'A [v3]']);
     expect(root).toMatchRenderedOutput('A [v3]A [v3]');
@@ -679,21 +676,20 @@ describe('ReactCache', () => {
       expect(root).toMatchRenderedOutput('Loading...Loading...');
 
       await ReactNoop.act(async () => {
-        await resolveText('A');
+        resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
       expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
       // Refresh the first boundary. It should not refresh the second boundary,
       // even though they previously shared the same underlying cache.
-      mutateRemoteTextService();
       await ReactNoop.act(async () => {
         await refreshFirstBoundary();
       });
       expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
 
       await ReactNoop.act(async () => {
-        await resolveText('A');
+        resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2]A [v1]');
@@ -738,10 +734,8 @@ describe('ReactCache', () => {
 
       await ReactNoop.act(async () => {
         // This will resolve the content in the first cache
-        resolveText('A');
-        resolveText('B');
-        // Now let's simulate a mutation
-        mutateRemoteTextService();
+        resolveMostRecentTextCache('A');
+        resolveMostRecentTextCache('B');
         // And mount the second tree, which includes new content
         root.render(<App showMore={true} />);
       });
@@ -757,7 +751,7 @@ describe('ReactCache', () => {
 
       // Now resolve the second tree
       await ReactNoop.act(async () => {
-        resolveText('A');
+        resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
@@ -769,7 +763,7 @@ describe('ReactCache', () => {
     function Child({text}) {
       return (
         <Cache>
-          <AsyncText text={text} />
+          <AsyncText showVersion={true} text={text} />
         </Cache>
       );
     }
@@ -813,10 +807,10 @@ describe('ReactCache', () => {
 
     // Resolve the request
     await ReactNoop.act(async () => {
-      await resolveText('A');
+      resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A', 'A']);
-    expect(root).toMatchRenderedOutput('AA');
+    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
     // Now do another transition
     await ReactNoop.act(async () => {
@@ -832,16 +826,19 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded([
       // First two children use the old cache because they already finished
-      'A',
-      'A',
+      'A [v1]',
+      'A [v1]',
       // The new child uses a fresh cache
       'Cache miss! [A]',
       'Loading...',
-      'A',
-      'A',
-      'A',
     ]);
-    expect(root).toMatchRenderedOutput('AAA');
+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
+
+    await ReactNoop.act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]', 'A [v2]']);
+    expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');
   });
 
   // @gate experimental
@@ -907,8 +904,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('1');
 
     await ReactNoop.act(async () => {
-      resolveText('A');
-      mutateRemoteTextService();
+      resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);
     expect(root).toMatchRenderedOutput('A1');

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index ef14b6588e..33f4353649 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -22,7 +22,7 @@ describe('ReactCache', () => {
     Suspense = React.Suspense;
     getCacheForType = React.unstable_getCacheForType;
     useCacheRefresh = React.unstable_useCacheRefresh;
-    startTransition = React.unstable_startTransition;
+    startTransition = React.startTransition;
     useState = React.useState;
 
     caches = [];

commit 86715efa23c02dd156e61a4476f28045bb5f4654
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Wed Jun 2 21:03:29 2021 -0400

    Resolve the true entry point during tests (#21505)
    
    * Resolve the entry point for tests the same way builds do
    
    This way the source tests, test the same entry point configuration.
    
    * Gate test selectors on www
    
    These are currently only exposed in www builds
    
    * Gate createEventHandle / useFocus on www
    
    These are enabled in both www variants but not OSS experimental.
    
    * Temporarily disable www-modern entry point
    
    Use the main one that has all the exports until we fix more tests.
    
    * Remove enableCache override that's no longer correct
    
    * Open gates for www
    
    These used to not be covered because they used Cache which wasn't exposed.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 33f4353649..01488a8b3a 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -149,7 +149,7 @@ describe('ReactCache', () => {
     }
   }
 
-  // @gate experimental
+  // @gate experimental || www
   test('render Cache component', async () => {
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
@@ -158,7 +158,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Hi');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('mount new data', async () => {
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
@@ -180,7 +180,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('root acts as implicit cache boundary', async () => {
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
@@ -200,7 +200,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
     function App({text}) {
       return (
@@ -239,7 +239,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('AA');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test(
     'nested cache boundaries share the same cache as the root during ' +
       'the initial render',
@@ -272,7 +272,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental
+  // @gate experimental || www
   test('new content inside an existing Cache boundary should re-use already cached data', async () => {
     function App({showMore}) {
       return (
@@ -309,7 +309,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('a new Cache boundary uses fresh cache', async () => {
     // The only difference from the previous test is that the "Show More"
     // content is wrapped in a nested <Cache /> boundary
@@ -356,7 +356,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('inner content uses same cache as shell if spawned by the same transition', async () => {
     const root = ReactNoop.createRoot();
 
@@ -431,7 +431,7 @@ describe('ReactCache', () => {
     );
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('refresh a cache', async () => {
     let refresh;
     function App() {
@@ -474,7 +474,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v2]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('refresh the root cache', async () => {
     let refresh;
     function App() {
@@ -515,7 +515,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v2]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('refresh a cache with seed data', async () => {
     let refresh;
     function App() {
@@ -558,7 +558,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v2]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('refreshing a parent cache also refreshes its children', async () => {
     let refreshShell;
     function RefreshShell() {
@@ -623,7 +623,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v3]A [v3]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test(
     'refreshing a cache boundary does not refresh the other boundaries ' +
       'that mounted at the same time (i.e. the ones that share the same cache)',
@@ -696,7 +696,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental
+  // @gate experimental || www
   test(
     'mount a new Cache boundary in a sibling while simultaneously ' +
       'resolving a Suspense boundary',
@@ -758,7 +758,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental
+  // @gate experimental || www
   test('cache pool is cleared once transitions that depend on it commit their shell', async () => {
     function Child({text}) {
       return (
@@ -841,7 +841,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');
   });
 
-  // @gate experimental
+  // @gate experimental || www
   test('cache pool is not cleared by arbitrary commits', async () => {
     function App() {
       return (

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 01488a8b3a..4f6caa4c6a 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -3,6 +3,7 @@ let ReactNoop;
 let Cache;
 let getCacheForType;
 let Scheduler;
+let act;
 let Suspense;
 let useCacheRefresh;
 let startTransition;
@@ -19,6 +20,7 @@ describe('ReactCache', () => {
     ReactNoop = require('react-noop-renderer');
     Cache = React.unstable_Cache;
     Scheduler = require('scheduler');
+    act = require('jest-react').act;
     Suspense = React.Suspense;
     getCacheForType = React.unstable_getCacheForType;
     useCacheRefresh = React.unstable_useCacheRefresh;
@@ -152,7 +154,7 @@ describe('ReactCache', () => {
   // @gate experimental || www
   test('render Cache component', async () => {
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<Cache>Hi</Cache>);
     });
     expect(root).toMatchRenderedOutput('Hi');
@@ -161,7 +163,7 @@ describe('ReactCache', () => {
   // @gate experimental || www
   test('mount new data', async () => {
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Cache>
           <Suspense fallback={<Text text="Loading..." />}>
@@ -173,7 +175,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);
@@ -183,7 +185,7 @@ describe('ReactCache', () => {
   // @gate experimental || www
   test('root acts as implicit cache boundary', async () => {
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <AsyncText text="A" />
@@ -193,7 +195,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);
@@ -220,7 +222,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App showMore={false} />);
     });
     // Even though there are two new <Cache /> trees, they should share the same
@@ -232,7 +234,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A', 'A']);
@@ -256,7 +258,7 @@ describe('ReactCache', () => {
       }
 
       const root = ReactNoop.createRoot();
-      await ReactNoop.act(async () => {
+      await act(async () => {
         root.render(<App />);
       });
       // Even though there are two new <Cache /> trees, they should share the same
@@ -264,7 +266,7 @@ describe('ReactCache', () => {
       expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
-      await ReactNoop.act(async () => {
+      await act(async () => {
         resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A', 'A']);
@@ -290,7 +292,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -298,7 +300,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App showMore={true} />);
     });
     expect(Scheduler).toHaveYielded([
@@ -331,7 +333,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -339,7 +341,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App showMore={true} />);
     });
     expect(Scheduler).toHaveYielded([
@@ -349,7 +351,7 @@ describe('ReactCache', () => {
       'Loading...',
     ]);
     expect(root).toMatchRenderedOutput('A [v1]Loading...');
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -396,13 +398,13 @@ describe('ReactCache', () => {
       return <Text text="Content" />;
     }
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);
     expect(root).toMatchRenderedOutput('Loading shell...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded([
@@ -419,7 +421,7 @@ describe('ReactCache', () => {
       </>,
     );
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('B');
     });
     expect(Scheduler).toHaveYielded(['Content']);
@@ -441,7 +443,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Cache>
           <Suspense fallback={<Text text="Loading..." />}>
@@ -453,20 +455,20 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Fefresh for new data.
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => refresh());
     });
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
@@ -484,7 +486,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <App />
@@ -494,20 +496,20 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => refresh());
     });
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
@@ -525,7 +527,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Cache>
           <Suspense fallback={<Text text="Loading..." />}>
@@ -537,14 +539,14 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await ReactNoop.act(async () => {
+    await act(async () => {
       // Refresh the cache with seeded data, like you would receive from a
       // server mutation.
       // TODO: Seeding multiple typed caches. Should work by calling `refresh`
@@ -585,7 +587,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -593,7 +595,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await ReactNoop.act(async () => {
+    await act(async () => {
       seedNextTextCache('A');
       root.render(<App showMore={true} />);
     });
@@ -606,7 +608,7 @@ describe('ReactCache', () => {
 
     // Now refresh the shell. This should also cause the "Show More" contents to
     // refresh, since its cache is nested inside the outer one.
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => refreshShell());
     });
     expect(Scheduler).toHaveYielded([
@@ -616,7 +618,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v3]', 'A [v3]']);
@@ -657,12 +659,12 @@ describe('ReactCache', () => {
       // treated like sibling providers that happen to share an underlying
       // cache, as opposed to consumers of the root-level cache.
       const root = ReactNoop.createRoot();
-      await ReactNoop.act(async () => {
+      await act(async () => {
         root.render(<App showMore={false} />);
       });
 
       // Now reveal the boundaries. In a real app  this would be a navigation.
-      await ReactNoop.act(async () => {
+      await act(async () => {
         root.render(<App showMore={true} />);
       });
 
@@ -675,7 +677,7 @@ describe('ReactCache', () => {
       ]);
       expect(root).toMatchRenderedOutput('Loading...Loading...');
 
-      await ReactNoop.act(async () => {
+      await act(async () => {
         resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
@@ -683,12 +685,12 @@ describe('ReactCache', () => {
 
       // Refresh the first boundary. It should not refresh the second boundary,
       // even though they previously shared the same underlying cache.
-      await ReactNoop.act(async () => {
+      await act(async () => {
         await refreshFirstBoundary();
       });
       expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
 
-      await ReactNoop.act(async () => {
+      await act(async () => {
         resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -723,7 +725,7 @@ describe('ReactCache', () => {
       }
 
       const root = ReactNoop.createRoot();
-      await ReactNoop.act(async () => {
+      await act(async () => {
         root.render(<App showMore={false} />);
       });
       expect(Scheduler).toHaveYielded([
@@ -732,7 +734,7 @@ describe('ReactCache', () => {
         'Loading...',
       ]);
 
-      await ReactNoop.act(async () => {
+      await act(async () => {
         // This will resolve the content in the first cache
         resolveMostRecentTextCache('A');
         resolveMostRecentTextCache('B');
@@ -750,7 +752,7 @@ describe('ReactCache', () => {
       ]);
 
       // Now resolve the second tree
-      await ReactNoop.act(async () => {
+      await act(async () => {
         resolveMostRecentTextCache('A');
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
@@ -769,7 +771,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,
       );
@@ -777,7 +779,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -789,7 +791,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -806,14 +808,14 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('(empty)');
 
     // Resolve the request
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
     // Now do another transition
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -834,7 +836,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]', 'A [v2]']);
@@ -877,13 +879,13 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App showMore={false} />);
     });
     expect(Scheduler).toHaveYielded(['0']);
     expect(root).toMatchRenderedOutput('0');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         showMore();
       });
@@ -891,7 +893,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('0');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       updateUnrelated(1);
     });
     expect(Scheduler).toHaveYielded([
@@ -903,7 +905,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('1');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       resolveMostRecentTextCache('A');
     });
     expect(Scheduler).toHaveYielded(['A']);

commit 48d475c9ed20ab4344b3f1969716b76d8a476171
Author: Bowen <bowen31337@users.noreply.github.com>
Date:   Wed Sep 22 01:05:41 2021 +1000

    correct typos (#22294)
    
    Co-authored-by: Bowen Li <bowen31337@gmail.com>

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 4f6caa4c6a..77b77869c7 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -461,7 +461,7 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    // Fefresh for new data.
+    // Refresh for new data.
     await act(async () => {
       startTransition(() => refresh());
     });

commit c88fb49d37fd01024e0a254a37b7810d107bdd1d
Author: Justin Grant <justingrant@users.noreply.github.com>
Date:   Mon Sep 27 10:05:07 2021 -0700

    Improve DEV errors if string coercion throws (Temporal.*, Symbol, etc.) (#22064)
    
    * Revise ESLint rules for string coercion
    
    Currently, react uses `'' + value` to coerce mixed values to strings.
    This code will throw for Temporal objects or symbols.
    
    To make string-coercion safer and to improve user-facing error messages,
    This commit adds a new ESLint rule called `safe-string-coercion`.
    
    This rule has two modes: a production mode and a non-production mode.
    * If the `isProductionUserAppCode` option is true, then `'' + value`
      coercions are allowed (because they're faster, although they may
      throw) and `String(value)` coercions are disallowed. Exception:
      when building error messages or running DEV-only code in prod
      files, `String()` should be used because it won't throw.
    * If the `isProductionUserAppCode` option is false, then `'' + value`
      coercions are disallowed (because they may throw, and in non-prod
      code it's not worth the risk) and `String(value)` are allowed.
    
    Production mode is used for all files which will be bundled with
    developers' userland apps. Non-prod mode is used for all other React
    code: tests, DEV blocks, devtools extension, etc.
    
    In production mode, in addiiton to flagging `String(value)` calls,
    the rule will also flag `'' + value` or `value + ''` coercions that may
    throw. The rule is smart enough to silence itself in the following
    "will never throw" cases:
    * When the coercion is wrapped in a `typeof` test that restricts to safe
      (non-symbol, non-object) types. Example:
        if (typeof value === 'string' || typeof value === 'number') {
          thisWontReport('' + value);
        }
    * When what's being coerced is a unary function result, because unary
       functions never return an object or a symbol.
    * When the coerced value is a commonly-used numeric identifier:
      `i`, `idx`, or `lineNumber`.
    * When the statement immeidately before the coercion is a DEV-only
      call to a function from shared/CheckStringCoercion.js. This call is a
      no-op in production, but in DEV it will show a console error
      explaining the problem, then will throw right after a long explanatory
      code comment so that debugger users will have an idea what's going on.
      The check function call must be in the following format:
        if (__DEV__) {
          checkXxxxxStringCoercion(value);
        };
    
    Manually disabling the rule is usually not necessary because almost all
    prod use of the `'' + value` pattern falls into one of the categories
    above. But in the rare cases where the rule isn't smart enough to detect
    safe usage (e.g. when a coercion is inside a nested ternary operator),
    manually disabling the rule will be needed.
    
    The rule should also be manually disabled in prod error handling code
    where `String(value)` should be used for coercions, because it'd be
    bad to throw while building an error message or stack trace!
    
    The prod and non-prod modes have differentiated error messages to
    explain how to do a proper coercion in that mode.
    
    If a production check call is needed but is missing or incorrect
    (e.g. not in a DEV block or not immediately before the coercion), then
    a context-sensitive error message will be reported so that developers
    can figure out what's wrong and how to fix the problem.
    
    Because string coercions are now handled by the `safe-string-coercion`
    rule, the `no-primitive-constructor` rule no longer flags `String()`
    usage. It still flags `new String(value)` because that usage is almost
    always a bug.
    
    * Add DEV-only string coercion check functions
    
    This commit adds DEV-only functions to check whether coercing
    values to strings using the `'' + value` pattern will throw. If it will
    throw, these functions will:
    1. Display a console error with a friendly error message describing
       the problem and the developer can fix it.
    2. Perform the coercion, which will throw. Right before the line where
       the throwing happens, there's a long code comment that will help
       debugger users (or others looking at the exception call stack) figure
       out what happened and how to fix the problem.
    
    One of these check functions should be called before all string coercion
    of user-provided values, except when the the coercion is guaranteed not
    to throw, e.g.
    * if inside a typeof check like `if (typeof value === 'string')`
    * if coercing the result of a unary function like `+value` or `value++`
    * if coercing a variable named in a whitelist of numeric identifiers:
      `i`, `idx`, or `lineNumber`.
    
    The new `safe-string-coercion` internal ESLint rule enforces that
    these check functions are called when they are required.
    
    Only use these check functions in production code that will be bundled
    with user apps.  For non-prod code (and for production error-handling
    code), use `String(value)` instead which may be a little slower but will
    never throw.
    
    * Add failing tests for string coercion
    
    Added failing tests to verify:
    * That input, select, and textarea elements with value and defaultValue
      set to Temporal-like objects which will throw when coerced to string
      using the `'' + value` pattern.
    * That text elements will throw for Temporal-like objects
    * That dangerouslySetInnerHTML will *not* throw for Temporal-like
      objects because this value is not cast to a string before passing to
      the DOM.
    * That keys that are Temporal-like objects will throw
    
    All tests above validate the friendly error messages thrown.
    
    * Use `String(value)` for coercion in non-prod files
    
    This commit switches non-production code from `'' + value` (which
    throws for Temporal objects and symbols) to instead use `String(value)`
    which won't throw for these or other future plus-phobic types.
    
    "Non-produciton code" includes anything not bundled into user apps:
    * Tests and test utilities. Note that I didn't change legacy React
      test fixtures because I assumed it was good for those files to
      act just like old React, including coercion behavior.
    * Build scripts
    * Dev tools package - In addition to switching to `String`, I also
      removed special-case code for coercing symbols which is now
      unnecessary.
    
    * Add DEV-only string coercion checks to prod files
    
    This commit adds DEV-only function calls to to check if string coercion
    using `'' + value` will throw, which it will if the value is a Temporal
    object or a symbol because those types can't be added with `+`.
    
    If it will throw, then in DEV these checks will show a console error
    to help the user undertsand what went wrong and how to fix the
    problem. After emitting the console error, the check functions will
    retry the coercion which will throw with a call stack that's easy (or
    at least easier!) to troubleshoot because the exception happens right
    after a long comment explaining the issue. So whether the user is in
    a debugger, looking at the browser console, or viewing the in-browser
    DEV call stack, it should be easy to understand and fix the problem.
    
    In most cases, the safe-string-coercion ESLint rule is smart enough to
    detect when a coercion is safe. But in rare cases (e.g. when a coercion
    is inside a ternary) this rule will have to be manually disabled.
    
    This commit also switches error-handling code to use `String(value)`
    for coercion, because it's bad to crash when you're trying to build
    an error message or a call stack!  Because `String()` is usually
    disallowed by the `safe-string-coercion` ESLint rule in production
    code, the rule must be disabled when `String()` is used.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 77b77869c7..31321eb07a 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -875,7 +875,7 @@ describe('ReactCache', () => {
     function Unrelated() {
       const [count, _updateUnrelated] = useState(0);
       updateUnrelated = _updateUnrelated;
-      return <Text text={count + ''} />;
+      return <Text text={String(count)} />;
     }
 
     const root = ReactNoop.createRoot();

commit fa9bea0c41ccfef5b528ef9b5517607f9f94c52a
Author: Joseph Savona <joesavona@fb.com>
Date:   Thu Oct 21 14:11:42 2021 -0700

    Initial implementation of cache cleanup (#22510)
    
    This is an initial, partial implementation of a cleanup mechanism for the experimental Cache API. The idea is that consumers of the Cache API can register to be informed when a given Cache instance is no longer needed so that they can perform associated cleanup tasks to free resources stored in the cache. A canonical example would be cancelling pending network requests.
    
    An overview of the high-level changes:
    
    * Changes the `Cache` type from a Map of cache instances to be an object with the original Map of instances, a reference count (to count roughly "active references" to the cache instances - more below), and an AbortController.
    * Adds a new public API, `unstable_getCacheSignal(): AbortSignal`, which is callable during render. It returns an AbortSignal tied to the lifetime of the cache - developers can listen for the 'abort' event on the signal, which React now triggers when a given cache instance is no longer referenced.
      * Note that `AbortSignal` is a web standard that is supported by other platform APIs; for example a signal can be passed to `fetch()` to trigger cancellation of an HTTP request.
    * Implements the above - triggering the 'abort' event - by handling passive mount/unmount for HostRoot and CacheComponent fiber nodes.
    
    Cases handled:
    * Aborted transitions: we clean up a new cache created for an aborted transition
    * Suspense: we retain a fresh cache instance until a suspended tree resolves
    
    For follow-ups:
    * When a subsequent cache refresh is issued before a previous refresh completes, the refreshes are queued. Fresh cache instances for previous refreshes in the queue should be cleared, retaining only the most recent cache. I plan to address this in a follow-up PR.
    * If a refresh is cancelled, the fresh cache should be cleaned up.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 31321eb07a..7ef18875e0 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -1,6 +1,7 @@
 let React;
 let ReactNoop;
 let Cache;
+let getCacheSignal;
 let getCacheForType;
 let Scheduler;
 let act;
@@ -22,6 +23,7 @@ describe('ReactCache', () => {
     Scheduler = require('scheduler');
     act = require('jest-react').act;
     Suspense = React.Suspense;
+    getCacheSignal = React.unstable_getCacheSignal;
     getCacheForType = React.unstable_getCacheForType;
     useCacheRefresh = React.unstable_useCacheRefresh;
     startTransition = React.startTransition;
@@ -52,6 +54,7 @@ describe('ReactCache', () => {
           const newRecord = {
             status: 'resolved',
             value: text,
+            cleanupScheduled: false,
           };
           data.set(text, newRecord);
         } else if (record.status === 'pending') {
@@ -64,6 +67,7 @@ describe('ReactCache', () => {
           const newRecord = {
             status: 'rejected',
             value: error,
+            cleanupScheduled: false,
           };
           data.set(text, newRecord);
         } else if (record.status === 'pending') {
@@ -76,9 +80,21 @@ describe('ReactCache', () => {
   }
 
   function readText(text) {
+    const signal = getCacheSignal();
     const textCache = getCacheForType(createTextCache);
     const record = textCache.data.get(text);
     if (record !== undefined) {
+      if (!record.cleanupScheduled) {
+        // This record was seeded prior to the abort signal being available:
+        // schedule a cleanup function for it.
+        // TODO: Add ability to cleanup entries seeded w useCacheRefresh()
+        record.cleanupScheduled = true;
+        signal.addEventListener('abort', () => {
+          Scheduler.unstable_yieldValue(
+            `Cache cleanup: ${text} [v${textCache.version}]`,
+          );
+        });
+      }
       switch (record.status) {
         case 'pending':
           throw record.value;
@@ -115,9 +131,15 @@ describe('ReactCache', () => {
       const newRecord = {
         status: 'pending',
         value: thenable,
+        cleanupScheduled: true,
       };
       textCache.data.set(text, newRecord);
 
+      signal.addEventListener('abort', () => {
+        Scheduler.unstable_yieldValue(
+          `Cache cleanup: ${text} [v${textCache.version}]`,
+        );
+      });
       throw thenable;
     }
   }
@@ -180,6 +202,13 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded(['A']);
     expect(root).toMatchRenderedOutput('A');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // no cleanup: cache is still retained at the root
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -200,12 +229,19 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded(['A']);
     expect(root).toMatchRenderedOutput('A');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // no cleanup: cache is still retained at the root
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
   test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
-    function App({text}) {
-      return (
+    function App({showMore}) {
+      return showMore ? (
         <>
           <Cache>
             <Suspense fallback={<Text text="Loading..." />}>
@@ -218,6 +254,8 @@ describe('ReactCache', () => {
             </Suspense>
           </Cache>
         </>
+      ) : (
+        '(empty)'
       );
     }
 
@@ -225,6 +263,12 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App showMore={false} />);
     });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('(empty)');
+
+    await act(async () => {
+      root.render(<App showMore={true} />);
+    });
     // Even though there are two new <Cache /> trees, they should share the same
     // data cache. So there should be only a single cache miss for A.
     expect(Scheduler).toHaveYielded([
@@ -239,6 +283,15 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // cleanup occurs for the cache shared by the inner cache boundaries (which
+    // are not shared w the root because they were added in an update)
+    // note that no cache is created for the root since the cache is never accessed
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -261,8 +314,8 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render(<App />);
       });
-      // Even though there are two new <Cache /> trees, they should share the same
-      // data cache. So there should be only a single cache miss for A.
+      // Even though there is a nested <Cache /> boundary, it should share the same
+      // data cache as the root. So there should be only a single cache miss for A.
       expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
@@ -271,6 +324,13 @@ describe('ReactCache', () => {
       });
       expect(Scheduler).toHaveYielded(['A', 'A']);
       expect(root).toMatchRenderedOutput('AA');
+
+      await act(async () => {
+        root.render('Bye');
+      });
+      // no cleanup: cache is still retained at the root
+      expect(Scheduler).toHaveYielded([]);
+      expect(root).toMatchRenderedOutput('Bye');
     },
   );
 
@@ -309,6 +369,13 @@ describe('ReactCache', () => {
       'A [v1]',
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // no cleanup: cache is still retained at the root
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -356,10 +423,21 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
+
+    // Replace all the children: this should retain the root Cache instance,
+    // but cleanup the separate cache instance created for the fresh cache
+    // boundary
+    await act(async () => {
+      root.render('Bye!');
+    });
+    // Cleanup occurs for the *second* cache instance: the first is still
+    // referenced by the root
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+    expect(root).toMatchRenderedOutput('Bye!');
   });
 
   // @gate experimental || www
-  test('inner content uses same cache as shell if spawned by the same transition', async () => {
+  test('inner/outer cache boundaries uses the same cache instance on initial render', async () => {
     const root = ReactNoop.createRoot();
 
     function App() {
@@ -431,10 +509,109 @@ describe('ReactCache', () => {
         <div>Content</div>
       </>,
     );
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // no cleanup: cache is still retained at the root
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
+  });
+
+  // @gate experimental || www
+  test('inner/ outer cache boundaries added in the same update use the same cache instance', async () => {
+    const root = ReactNoop.createRoot();
+
+    function App({showMore}) {
+      return showMore ? (
+        <Cache>
+          <Suspense fallback={<Text text="Loading shell..." />}>
+            {/* The shell reads A */}
+            <Shell>
+              {/* The inner content reads both A and B */}
+              <Suspense fallback={<Text text="Loading content..." />}>
+                <Cache>
+                  <Content />
+                </Cache>
+              </Suspense>
+            </Shell>
+          </Suspense>
+        </Cache>
+      ) : (
+        '(empty)'
+      );
+    }
+
+    function Shell({children}) {
+      readText('A');
+      return (
+        <>
+          <div>
+            <Text text="Shell" />
+          </div>
+          <div>{children}</div>
+        </>
+      );
+    }
+
+    function Content() {
+      readText('A');
+      readText('B');
+      return <Text text="Content" />;
+    }
+
+    await act(async () => {
+      root.render(<App showMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('(empty)');
+
+    await act(async () => {
+      root.render(<App showMore={true} />);
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);
+    expect(root).toMatchRenderedOutput('Loading shell...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Shell',
+      // There's a cache miss for B, because it hasn't been read yet. But not
+      // A, because it was cached when we rendered the shell.
+      'Cache miss! [B]',
+      'Loading content...',
+    ]);
+    expect(root).toMatchRenderedOutput(
+      <>
+        <div>Shell</div>
+        <div>Loading content...</div>
+      </>,
+    );
+
+    await act(async () => {
+      resolveMostRecentTextCache('B');
+    });
+    expect(Scheduler).toHaveYielded(['Content']);
+    expect(root).toMatchRenderedOutput(
+      <>
+        <div>Shell</div>
+        <div>Content</div>
+      </>,
+    );
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache cleanup: A [v1]',
+      'Cache cleanup: B [v1]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
-  test('refresh a cache', async () => {
+  test('refresh a cache boundary', async () => {
     let refresh;
     function App() {
       refresh = useCacheRefresh();
@@ -474,6 +651,14 @@ describe('ReactCache', () => {
     // Note that the version has updated
     expect(Scheduler).toHaveYielded(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // the original cache instance does not cleanup since it is still referenced
+    // by the root, but the refreshed inner cache does cleanup
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -512,9 +697,64 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    // Note that the version has updated
-    expect(Scheduler).toHaveYielded(['A [v2]']);
+    // Note that the version has updated, and the previous cache is cleared
+    expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('A [v2]');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // the original root cache already cleaned up when the refresh completed
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
+  });
+
+  // @gate experimental || www
+  test('refresh the root cache without a transition', async () => {
+    let refresh;
+    function App() {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text="A" />;
+    }
+
+    // Mount initial data
+    const root = ReactNoop.createRoot();
+    await act(async () => {
+      root.render(
+        <Suspense fallback={<Text text="Loading..." />}>
+          <App />
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Refresh for new data.
+    await act(async () => {
+      refresh();
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    // Note that the version has updated, and the previous cache is cleared
+    expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v2]');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // the original root cache already cleaned up when the refresh completed
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -556,8 +796,16 @@ describe('ReactCache', () => {
       startTransition(() => refresh(createTextCache, cache));
     });
     // The root should re-render without a cache miss.
+    // The cache is not cleared up yet, since it's still reference by the root
     expect(Scheduler).toHaveYielded(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // the refreshed cache boundary is unmounted and cleans up
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+    expect(root).toMatchRenderedOutput('Bye');
   });
 
   // @gate experimental || www
@@ -621,8 +869,22 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v3]', 'A [v3]']);
+    expect(Scheduler).toHaveYielded([
+      'A [v3]',
+      'A [v3]',
+      // once the refresh completes the inner showMore boundary frees its previous
+      // cache instance, since it is now using the refreshed parent instance.
+      'Cache cleanup: A [v2]',
+    ]);
     expect(root).toMatchRenderedOutput('A [v3]A [v3]');
+
+    await act(async () => {
+      root.render('Bye!');
+    });
+    // Unmounting children releases the refreshed cache instance only; the root
+    // still retains the original cache instance used for the first render
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v3]']);
+    expect(root).toMatchRenderedOutput('Bye!');
   });
 
   // @gate experimental || www
@@ -695,6 +957,21 @@ describe('ReactCache', () => {
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2]A [v1]');
+
+      // Unmount children: this should clear *both* cache instances:
+      // the root doesn't have a cache instance (since it wasn't accessed
+      // during the initial render, and all subsequent cache accesses were within
+      // a fresh boundary). Therefore this causes cleanup for both the fresh cache
+      // instance in the refreshed first boundary and cleanup for the non-refreshed
+      // sibling boundary.
+      await act(async () => {
+        root.render('Bye!');
+      });
+      expect(Scheduler).toHaveYielded([
+        'Cache cleanup: A [v2]',
+        'Cache cleanup: A [v1]',
+      ]);
+      expect(root).toMatchRenderedOutput('Bye!');
     },
   );
 
@@ -733,6 +1010,7 @@ describe('ReactCache', () => {
         'Cache miss! [B]',
         'Loading...',
       ]);
+      expect(root).toMatchRenderedOutput('Loading...');
 
       await act(async () => {
         // This will resolve the content in the first cache
@@ -750,6 +1028,7 @@ describe('ReactCache', () => {
         'A [v1]',
         'B [v1]',
       ]);
+      expect(root).toMatchRenderedOutput('Loading... A [v1] B [v1]');
 
       // Now resolve the second tree
       await act(async () => {
@@ -757,6 +1036,15 @@ describe('ReactCache', () => {
       });
       expect(Scheduler).toHaveYielded(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
+
+      await act(async () => {
+        root.render('Bye!');
+      });
+      // Unmounting children releases both cache boundaries, but the original
+      // cache instance (used by second boundary) is still referenced by the root.
+      // only the second cache instance is freed.
+      expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+      expect(root).toMatchRenderedOutput('Bye!');
     },
   );
 
@@ -841,6 +1129,19 @@ describe('ReactCache', () => {
     });
     expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]', 'A [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');
+
+    // Unmount children: the first text cache instance is created only after the root
+    // commits, so both fresh cache instances are released by their cache boundaries,
+    // cleaning up v1 (used for the first two children which render togeether) and
+    // v2 (used for the third boundary added later).
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache cleanup: A [v1]',
+      'Cache cleanup: A [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye!');
   });
 
   // @gate experimental || www
@@ -863,7 +1164,7 @@ describe('ReactCache', () => {
           <Suspense fallback={<Text text="Loading..." />}>
             {shouldShow ? (
               <Cache>
-                <AsyncText text="A" />
+                <AsyncText showVersion={true} text="A" />
               </Cache>
             ) : null}
           </Suspense>
@@ -880,7 +1181,7 @@ describe('ReactCache', () => {
 
     const root = ReactNoop.createRoot();
     await act(async () => {
-      root.render(<App showMore={false} />);
+      root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['0']);
     expect(root).toMatchRenderedOutput('0');
@@ -908,7 +1209,331 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A']);
-    expect(root).toMatchRenderedOutput('A1');
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]1');
+
+    // Unmount children: the first text cache instance is created only after initial
+    // render after calling showMore(). This instance is cleaned up when that boundary
+    // is unmounted. Bc root cache instance is never accessed, the inner cache
+    // boundary ends up at v1.
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test('cache boundary uses a fresh cache when its key changes', async () => {
+    const root = ReactNoop.createRoot();
+    seedNextTextCache('A');
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="A">
+            <AsyncText showVersion={true} text="A" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    seedNextTextCache('B');
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="B">
+            <AsyncText showVersion={true} text="B" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['B [v2]']);
+    expect(root).toMatchRenderedOutput('B [v2]');
+
+    // Unmount children: the fresh cache instance for B cleans up since the cache boundary
+    // is the only owner, while the original cache instance (for A) is still retained by
+    // the root.
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded(['Cache cleanup: B [v2]']);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test('overlapping transitions after an initial mount use the same fresh cache', async () => {
+    const root = ReactNoop.createRoot();
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="A">
+            <AsyncText showVersion={true} text="A" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // After a mount, subsequent transitions use a fresh cache
+    await act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback="Loading...">
+            <Cache key="B">
+              <AsyncText showVersion={true} text="B" />
+            </Cache>
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Update to a different text and with a different key for the cache
+    // boundary: this should still use the fresh cache instance created
+    // for the earlier transition
+    await act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback="Loading...">
+            <Cache key="C">
+              <AsyncText showVersion={true} text="C" />
+            </Cache>
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await act(async () => {
+      resolveMostRecentTextCache('C');
+    });
+    expect(Scheduler).toHaveYielded(['C [v2]']);
+    expect(root).toMatchRenderedOutput('C [v2]');
+
+    // Unmount children: the fresh cache used for the updates is freed, while the
+    // original cache (with A) is still retained at the root.
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache cleanup: B [v2]',
+      'Cache cleanup: C [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test('overlapping updates after an initial mount use the same fresh cache', async () => {
+    const root = ReactNoop.createRoot();
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="A">
+            <AsyncText showVersion={true} text="A" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // After a mount, subsequent updates use a fresh cache
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="B">
+            <AsyncText showVersion={true} text="B" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    // A second update uses the same fresh cache: even though this is a new
+    // Cache boundary, the render uses the fresh cache from the pending update.
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="C">
+            <AsyncText showVersion={true} text="C" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);
+    expect(root).toMatchRenderedOutput('Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('C');
+    });
+    expect(Scheduler).toHaveYielded(['C [v2]']);
+    expect(root).toMatchRenderedOutput('C [v2]');
+
+    // Unmount children: the fresh cache used for the updates is freed, while the
+    // original cache (with A) is still retained at the root.
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([
+      'Cache cleanup: B [v2]',
+      'Cache cleanup: C [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test('cleans up cache only used in an aborted transition', async () => {
+    const root = ReactNoop.createRoot();
+    seedNextTextCache('A');
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache key="A">
+            <AsyncText showVersion={true} text="A" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Start a transition from A -> B..., which should create a fresh cache
+    // for the new cache boundary (bc of the different key)
+    await act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback="Loading...">
+            <Cache key="B">
+              <AsyncText showVersion={true} text="B" />
+            </Cache>
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // ...but cancel by transitioning "back" to A (which we never really left)
+    await act(async () => {
+      startTransition(() => {
+        root.render(
+          <Suspense fallback="Loading...">
+            <Cache key="A">
+              <AsyncText showVersion={true} text="A" />
+            </Cache>
+          </Suspense>,
+        );
+      });
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]', 'Cache cleanup: B [v2]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Unmount children: ...
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test.skip('if a root cache refresh never commits its fresh cache is released', async () => {
+    const root = ReactNoop.createRoot();
+    let refresh;
+    function Example({text}) {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text={text} />;
+    }
+    seedNextTextCache('A');
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Example text="A" />
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await act(async () => {
+      startTransition(() => {
+        refresh();
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([
+      // TODO: the v1 cache should *not* be cleaned up, it is still retained by the root
+      // The following line is presently yielded but should not be:
+      // 'Cache cleanup: A [v1]',
+
+      // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh
+      // The following line is presently not yielded but should be:
+      'Cache cleanup: A [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye!');
+  });
+
+  // @gate experimental || www
+  test.skip('if a cache boundary refresh never commits its fresh cache is released', async () => {
+    const root = ReactNoop.createRoot();
+    let refresh;
+    function Example({text}) {
+      refresh = useCacheRefresh();
+      return <AsyncText showVersion={true} text={text} />;
+    }
+    seedNextTextCache('A');
+    await act(async () => {
+      root.render(
+        <Suspense fallback="Loading...">
+          <Cache>
+            <Example text="A" />
+          </Cache>
+        </Suspense>,
+      );
+    });
+    expect(Scheduler).toHaveYielded(['A [v1]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    await act(async () => {
+      startTransition(() => {
+        refresh();
+      });
+    });
+    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    expect(root).toMatchRenderedOutput('A [v1]');
+
+    // Unmount the boundary before the refresh can complete
+    await act(async () => {
+      root.render('Bye!');
+    });
+    expect(Scheduler).toHaveYielded([
+      // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh
+      // The following line is presently not yielded but should be:
+      'Cache cleanup: A [v2]',
+    ]);
+    expect(root).toMatchRenderedOutput('Bye!');
   });
 });

commit 0b329511b9aaff7e27990fc16354db8ea0a16de8
Author: Han Han <haannn@qq.com>
Date:   Mon Nov 15 23:58:30 2021 +0800

    chore: fix comment typo (#22657)

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 7ef18875e0..ed6b9fadf6 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -1132,7 +1132,7 @@ describe('ReactCache', () => {
 
     // Unmount children: the first text cache instance is created only after the root
     // commits, so both fresh cache instances are released by their cache boundaries,
-    // cleaning up v1 (used for the first two children which render togeether) and
+    // cleaning up v1 (used for the first two children which render together) and
     // v2 (used for the third boundary added later).
     await act(async () => {
       root.render('Bye!');

commit 27b5699694f20220e0448f0ba3eb6bfa0d3a64ed
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Feb 11 17:51:57 2022 -0500

    Simplify cache pool contexts (#23280)
    
    The `pooledCache` variable always points to either `root.pooledCache`
    or the stack cursor that is used to track caches that were resumed from
    a previous render. We can get rid of it by reading from those instead.
    This simplifies the code a lot and is harder to mess up, I think.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index ed6b9fadf6..6a20f738af 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -739,14 +739,21 @@ describe('ReactCache', () => {
     await act(async () => {
       refresh();
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      // The v1 cache can be cleaned up since everything that references it has
+      // been replaced by a fallback. When the boundary switches back to visible
+      // it will use the v2 cache.
+      'Cache cleanup: A [v1]',
+    ]);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated, and the previous cache is cleared
-    expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
+    expect(Scheduler).toHaveYielded(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {

commit b86baa1cb7b0838169eb762873d53442b9075c94
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Apr 8 15:34:41 2022 -0400

    Add back lost cache test (#24317)

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 6a20f738af..804486721f 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -238,6 +238,53 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
+  // @gate experimental || www
+  test('multiple new Cache boundaries in the same mount share the same, fresh root cache', async () => {
+    function App() {
+      return (
+        <>
+          <Cache>
+            <Suspense fallback={<Text text="Loading..." />}>
+              <AsyncText text="A" />
+            </Suspense>
+          </Cache>
+          <Cache>
+            <Suspense fallback={<Text text="Loading..." />}>
+              <AsyncText text="A" />
+            </Suspense>
+          </Cache>
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await act(async () => {
+      root.render(<App showMore={false} />);
+    });
+
+    // Even though there are two new <Cache /> trees, they should share the same
+    // data cache. So there should be only a single cache miss for A.
+    expect(Scheduler).toHaveYielded([
+      'Cache miss! [A]',
+      'Loading...',
+      'Loading...',
+    ]);
+    expect(root).toMatchRenderedOutput('Loading...Loading...');
+
+    await act(async () => {
+      resolveMostRecentTextCache('A');
+    });
+    expect(Scheduler).toHaveYielded(['A', 'A']);
+    expect(root).toMatchRenderedOutput('AA');
+
+    await act(async () => {
+      root.render('Bye');
+    });
+    // no cleanup: cache is still retained at the root
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('Bye');
+  });
+
   // @gate experimental || www
   test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
     function App({showMore}) {

commit 4ea064eb0915b355b584bff376e90dbae0e8b169
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jul 29 19:22:57 2022 -0400

    Don't fire passive effects during initial mount of a hidden Offscreen tree (#24967)
    
    * Change OffscreenInstance isHidden to bitmask
    
    The isHidden field of OffscreenInstance is a boolean that represents
    whether the tree is currently hidden. To implement resuable effects, we
    need to also track whether the passive effects are currently connected.
    So I've changed this field to a bitmask.
    
    No other behavior has changed in this commit. I'll update the effects
    behavior in the following steps.
    
    * Extract passive mount effects to separate functions
    
    I'm about to add a "reappear passive effects" function that will share
    much of the same code as commitPassiveMountEffectOnFiber. To minimize
    the duplicated code, I've extracted the shared parts into separate
    functions, similar to what I did for commitLayoutEffectOnFiber and
    reappearLayoutEffects.
    
    This may not save much on code size because Closure will likely inline
    some of it, anyway, but it makes it harder for the two paths to
    accidentally diverge.
    
    * Don't mount passive effects in a new hidden tree
    
    This changes the behavior of Offscreen so that passive effects do not
    fire when prerendering a brand new tree. Previously, Offscreen did not
    affect passive effects at all ‚Äî only layout effects, which mount or
    unmount whenever the visibility of the tree changes.
    
    When hiding an already visible tree, the behavior of passive effects is
    unchanged, for now; unlike layout effects, the passive effects will not
    get unmounted. Pre-rendered updates to a hidden tree in this state will
    also fire normally. This is only temporary, though ‚Äî the plan is for
    passive effects to act more like layout effects, and unmount them when
    the tree is hidden. Perhaps after a delay so that if the visibility
    toggles quickly back and forth, the effects don't need to remount. I'll
    implement this separately.
    
    * "Atomic" passive commit effects must always fire
    
    There are a few cases where commit phase logic always needs to fire even
    inside a hidden tree. In general, we should try to design algorithms
    that don't depend on a commit effect running during prerendering, but
    there's at least one case where I think it makes sense.
    
    The experimental Cache component uses reference counting to keep track
    of the lifetime of a cache instance. This allows us to expose an
    AbortSignal object that data frameworks can use to cancel aborted
    requests. These cache objects are considered alive even inside a
    prerendered tree.
    
    To implement this I added an "atomic" passive effect traversal that runs
    even when a tree is hidden. (As a follow up, we should add a special
    subtree flag so that we can skip over nodes that don't have them. There
    are a number of similar subtree flag optimizations that we have planned,
    so I'll leave them for a later refactor.)
    
    The only other feature that currently depends on this behavior is
    Transition Tracing. I did not add a test for this because Transition
    Tracing is still in development and doesn't yet work with Offscreen.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 804486721f..970bf940f2 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -6,6 +6,7 @@ let getCacheForType;
 let Scheduler;
 let act;
 let Suspense;
+let Offscreen;
 let useCacheRefresh;
 let startTransition;
 let useState;
@@ -23,6 +24,7 @@ describe('ReactCache', () => {
     Scheduler = require('scheduler');
     act = require('jest-react').act;
     Suspense = React.Suspense;
+    Offscreen = React.unstable_Offscreen;
     getCacheSignal = React.unstable_getCacheSignal;
     getCacheForType = React.unstable_getCacheForType;
     useCacheRefresh = React.unstable_useCacheRefresh;
@@ -1590,4 +1592,36 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('Bye!');
   });
+
+  // @gate enableOffscreen
+  // @gate enableCache
+  test('prerender a new cache boundary inside an Offscreen tree', async () => {
+    function App({prerenderMore}) {
+      return (
+        <Offscreen mode="hidden">
+          <div>
+            {prerenderMore ? (
+              <Cache>
+                <AsyncText text="More" />
+              </Cache>
+            ) : null}
+          </div>
+        </Offscreen>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await act(async () => {
+      root.render(<App prerenderMore={false} />);
+    });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput(<div hidden={true} />);
+
+    seedNextTextCache('More');
+    await act(async () => {
+      root.render(<App prerenderMore={true} />);
+    });
+    expect(Scheduler).toHaveYielded(['More']);
+    expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);
+  });
 });

commit 8e2bde6f2751aa6335f3cef488c05c3ea08e074a
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue Oct 18 16:55:06 2022 -0400

    Add cache() API (#25506)
    
    Like memo() but longer lived.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 970bf940f2..6bf494b1e0 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -2,7 +2,6 @@ let React;
 let ReactNoop;
 let Cache;
 let getCacheSignal;
-let getCacheForType;
 let Scheduler;
 let act;
 let Suspense;
@@ -10,8 +9,10 @@ let Offscreen;
 let useCacheRefresh;
 let startTransition;
 let useState;
+let cache;
 
-let caches;
+let getTextCache;
+let textCaches;
 let seededCache;
 
 describe('ReactCache', () => {
@@ -24,66 +25,68 @@ describe('ReactCache', () => {
     Scheduler = require('scheduler');
     act = require('jest-react').act;
     Suspense = React.Suspense;
+    cache = React.experimental_cache;
     Offscreen = React.unstable_Offscreen;
     getCacheSignal = React.unstable_getCacheSignal;
-    getCacheForType = React.unstable_getCacheForType;
     useCacheRefresh = React.unstable_useCacheRefresh;
     startTransition = React.startTransition;
     useState = React.useState;
 
-    caches = [];
+    textCaches = [];
     seededCache = null;
-  });
-
-  function createTextCache() {
-    if (seededCache !== null) {
-      // Trick to seed a cache before it exists.
-      // TODO: Need a built-in API to seed data before the initial render (i.e.
-      // not a refresh because nothing has mounted yet).
-      const cache = seededCache;
-      seededCache = null;
-      return cache;
-    }
 
-    const data = new Map();
-    const version = caches.length + 1;
-    const cache = {
-      version,
-      data,
-      resolve(text) {
-        const record = data.get(text);
-        if (record === undefined) {
-          const newRecord = {
-            status: 'resolved',
-            value: text,
-            cleanupScheduled: false,
-          };
-          data.set(text, newRecord);
-        } else if (record.status === 'pending') {
-          record.value.resolve();
+    if (gate(flags => flags.enableCache)) {
+      getTextCache = cache(() => {
+        if (seededCache !== null) {
+          // Trick to seed a cache before it exists.
+          // TODO: Need a built-in API to seed data before the initial render (i.e.
+          // not a refresh because nothing has mounted yet).
+          const textCache = seededCache;
+          seededCache = null;
+          return textCache;
         }
-      },
-      reject(text, error) {
-        const record = data.get(text);
-        if (record === undefined) {
-          const newRecord = {
-            status: 'rejected',
-            value: error,
-            cleanupScheduled: false,
-          };
-          data.set(text, newRecord);
-        } else if (record.status === 'pending') {
-          record.value.reject();
-        }
-      },
-    };
-    caches.push(cache);
-    return cache;
-  }
+
+        const data = new Map();
+        const version = textCaches.length + 1;
+        const textCache = {
+          version,
+          data,
+          resolve(text) {
+            const record = data.get(text);
+            if (record === undefined) {
+              const newRecord = {
+                status: 'resolved',
+                value: text,
+                cleanupScheduled: false,
+              };
+              data.set(text, newRecord);
+            } else if (record.status === 'pending') {
+              record.value.resolve();
+            }
+          },
+          reject(text, error) {
+            const record = data.get(text);
+            if (record === undefined) {
+              const newRecord = {
+                status: 'rejected',
+                value: error,
+                cleanupScheduled: false,
+              };
+              data.set(text, newRecord);
+            } else if (record.status === 'pending') {
+              record.value.reject();
+            }
+          },
+        };
+        textCaches.push(textCache);
+        return textCache;
+      });
+    }
+  });
 
   function readText(text) {
     const signal = getCacheSignal();
-    const textCache = getCacheForType(createTextCache);
+    const textCache = getTextCache();
     const record = textCache.data.get(text);
     if (record !== undefined) {
       if (!record.cleanupScheduled) {
@@ -160,18 +163,18 @@ describe('ReactCache', () => {
 
   function seedNextTextCache(text) {
     if (seededCache === null) {
-      seededCache = createTextCache();
+      seededCache = getTextCache();
     }
     seededCache.resolve(text);
   }
 
   function resolveMostRecentTextCache(text) {
-    if (caches.length === 0) {
+    if (textCaches.length === 0) {
       throw Error('Cache does not exist.');
     } else {
       // Resolve the most recently created cache. An older cache can by
-      // resolved with `caches[index].resolve(text)`.
-      caches[caches.length - 1].resolve(text);
+      // resolved with `textCaches[index].resolve(text)`.
+      textCaches[textCaches.length - 1].resolve(text);
     }
   }
 
@@ -815,9 +818,18 @@ describe('ReactCache', () => {
 
   // @gate experimental || www
   test('refresh a cache with seed data', async () => {
-    let refresh;
+    let refreshWithSeed;
     function App() {
-      refresh = useCacheRefresh();
+      const refresh = useCacheRefresh();
+      const [seed, setSeed] = useState({fn: null});
+      if (seed.fn) {
+        seed.fn();
+        seed.fn = null;
+      }
+      refreshWithSeed = fn => {
+        setSeed({fn});
+        refresh();
+      };
       return <AsyncText showVersion={true} text="A" />;
     }
 
@@ -845,11 +857,14 @@ describe('ReactCache', () => {
     await act(async () => {
       // Refresh the cache with seeded data, like you would receive from a
       // server mutation.
-      // TODO: Seeding multiple typed caches. Should work by calling `refresh`
+      // TODO: Seeding multiple typed textCaches. Should work by calling `refresh`
       // multiple times with different key/value pairs
-      const cache = createTextCache();
-      cache.resolve('A');
-      startTransition(() => refresh(createTextCache, cache));
+      startTransition(() =>
+        refreshWithSeed(() => {
+          const textCache = getTextCache();
+          textCache.resolve('A');
+        }),
+      );
     });
     // The root should re-render without a cache miss.
     // The cache is not cleared up yet, since it's still reference by the root
@@ -1624,4 +1639,152 @@ describe('ReactCache', () => {
     expect(Scheduler).toHaveYielded(['More']);
     expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);
   });
+
+  // @gate enableCache
+  it('cache objects and primitive arguments and a mix of them', async () => {
+    const root = ReactNoop.createRoot();
+    const types = cache((a, b) => ({a: typeof a, b: typeof b}));
+    function Print({a, b}) {
+      return types(a, b).a + ' ' + types(a, b).b + ' ';
+    }
+    function Same({a, b}) {
+      const x = types(a, b);
+      const y = types(a, b);
+      return (x === y).toString() + ' ';
+    }
+    function FlippedOrder({a, b}) {
+      return (types(a, b) === types(b, a)).toString() + ' ';
+    }
+    function FewerArgs({a, b}) {
+      return (types(a, b) === types(a)).toString() + ' ';
+    }
+    function MoreArgs({a, b}) {
+      return (types(a) === types(a, b)).toString() + ' ';
+    }
+    await act(async () => {
+      root.render(
+        <>
+          <Print a="e" b="f" />
+          <Same a="a" b="b" />
+          <FlippedOrder a="c" b="d" />
+          <FewerArgs a="e" b="f" />
+          <MoreArgs a="g" b="h" />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('string string true false false false ');
+    await act(async () => {
+      root.render(
+        <>
+          <Print a="e" b={null} />
+          <Same a="a" b={null} />
+          <FlippedOrder a="c" b={null} />
+          <FewerArgs a="e" b={null} />
+          <MoreArgs a="g" b={null} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('string object true false false false ');
+    const obj = {};
+    await act(async () => {
+      root.render(
+        <>
+          <Print a="e" b={obj} />
+          <Same a="a" b={obj} />
+          <FlippedOrder a="c" b={obj} />
+          <FewerArgs a="e" b={obj} />
+          <MoreArgs a="g" b={obj} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('string object true false false false ');
+    const sameObj = {};
+    await act(async () => {
+      root.render(
+        <>
+          <Print a={sameObj} b={sameObj} />
+          <Same a={sameObj} b={sameObj} />
+          <FlippedOrder a={sameObj} b={sameObj} />
+          <FewerArgs a={sameObj} b={sameObj} />
+          <MoreArgs a={sameObj} b={sameObj} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('object object true true false false ');
+    const objA = {};
+    const objB = {};
+    await act(async () => {
+      root.render(
+        <>
+          <Print a={objA} b={objB} />
+          <Same a={objA} b={objB} />
+          <FlippedOrder a={objA} b={objB} />
+          <FewerArgs a={objA} b={objB} />
+          <MoreArgs a={objA} b={objB} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('object object true false false false ');
+    const sameSymbol = Symbol();
+    await act(async () => {
+      root.render(
+        <>
+          <Print a={sameSymbol} b={sameSymbol} />
+          <Same a={sameSymbol} b={sameSymbol} />
+          <FlippedOrder a={sameSymbol} b={sameSymbol} />
+          <FewerArgs a={sameSymbol} b={sameSymbol} />
+          <MoreArgs a={sameSymbol} b={sameSymbol} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('symbol symbol true true false false ');
+    const notANumber = +'nan';
+    await act(async () => {
+      root.render(
+        <>
+          <Print a={1} b={notANumber} />
+          <Same a={1} b={notANumber} />
+          <FlippedOrder a={1} b={notANumber} />
+          <FewerArgs a={1} b={notANumber} />
+          <MoreArgs a={1} b={notANumber} />
+        </>,
+      );
+    });
+    expect(root).toMatchRenderedOutput('number number true false false false ');
+  });
+
+  // @gate enableCache
+  it('cached functions that throw should cache the error', async () => {
+    const root = ReactNoop.createRoot();
+    const throws = cache(v => {
+      throw new Error(v);
+    });
+    let x;
+    let y;
+    let z;
+    function Test() {
+      try {
+        throws(1);
+      } catch (e) {
+        x = e;
+      }
+      try {
+        throws(1);
+      } catch (e) {
+        y = e;
+      }
+      try {
+        throws(2);
+      } catch (e) {
+        z = e;
+      }
+
+      return 'Blank';
+    }
+    await act(async () => {
+      root.render(<Test />);
+    });
+    expect(x).toBe(y);
+    expect(z).not.toBe(x);
+  });
 });

commit e7c5af45ceb8fa2b64d39ec68345254ce9abd65e
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Sun Oct 23 23:20:52 2022 -0400

    Update cache() and use() to the canary aka next channel (#25502)
    
    Testing what it would look like to move this to the `next` channel.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 6bf494b1e0..7b1eda50ff 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -25,7 +25,7 @@ describe('ReactCache', () => {
     Scheduler = require('scheduler');
     act = require('jest-react').act;
     Suspense = React.Suspense;
-    cache = React.experimental_cache;
+    cache = React.cache;
     Offscreen = React.unstable_Offscreen;
     getCacheSignal = React.unstable_getCacheSignal;
     useCacheRefresh = React.unstable_useCacheRefresh;
@@ -85,7 +85,7 @@ describe('ReactCache', () => {
   });
 
   function readText(text) {
-    const signal = getCacheSignal();
+    const signal = getCacheSignal ? getCacheSignal() : null;
     const textCache = getTextCache();
     const record = textCache.data.get(text);
     if (record !== undefined) {
@@ -94,11 +94,13 @@ describe('ReactCache', () => {
         // schedule a cleanup function for it.
         // TODO: Add ability to cleanup entries seeded w useCacheRefresh()
         record.cleanupScheduled = true;
-        signal.addEventListener('abort', () => {
-          Scheduler.unstable_yieldValue(
-            `Cache cleanup: ${text} [v${textCache.version}]`,
-          );
-        });
+        if (getCacheSignal) {
+          signal.addEventListener('abort', () => {
+            Scheduler.unstable_yieldValue(
+              `Cache cleanup: ${text} [v${textCache.version}]`,
+            );
+          });
+        }
       }
       switch (record.status) {
         case 'pending':
@@ -140,11 +142,13 @@ describe('ReactCache', () => {
       };
       textCache.data.set(text, newRecord);
 
-      signal.addEventListener('abort', () => {
-        Scheduler.unstable_yieldValue(
-          `Cache cleanup: ${text} [v${textCache.version}]`,
-        );
-      });
+      if (getCacheSignal) {
+        signal.addEventListener('abort', () => {
+          Scheduler.unstable_yieldValue(
+            `Cache cleanup: ${text} [v${textCache.version}]`,
+          );
+        });
+      }
       throw thenable;
     }
   }
@@ -178,7 +182,7 @@ describe('ReactCache', () => {
     }
   }
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('render Cache component', async () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
@@ -187,7 +191,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Hi');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('mount new data', async () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
@@ -216,7 +220,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCache
   test('root acts as implicit cache boundary', async () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
@@ -243,7 +247,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('multiple new Cache boundaries in the same mount share the same, fresh root cache', async () => {
     function App() {
       return (
@@ -290,7 +294,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
     function App({showMore}) {
       return showMore ? (
@@ -346,7 +350,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test(
     'nested cache boundaries share the same cache as the root during ' +
       'the initial render',
@@ -386,7 +390,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('new content inside an existing Cache boundary should re-use already cached data', async () => {
     function App({showMore}) {
       return (
@@ -430,7 +434,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('a new Cache boundary uses fresh cache', async () => {
     // The only difference from the previous test is that the "Show More"
     // content is wrapped in a nested <Cache /> boundary
@@ -488,7 +492,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('inner/outer cache boundaries uses the same cache instance on initial render', async () => {
     const root = ReactNoop.createRoot();
 
@@ -570,7 +574,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('inner/ outer cache boundaries added in the same update use the same cache instance', async () => {
     const root = ReactNoop.createRoot();
 
@@ -662,7 +666,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCache
   test('refresh a cache boundary', async () => {
     let refresh;
     function App() {
@@ -674,11 +678,9 @@ describe('ReactCache', () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
       root.render(
-        <Cache>
-          <Suspense fallback={<Text text="Loading..." />}>
-            <App />
-          </Suspense>
-        </Cache>,
+        <Suspense fallback={<Text text="Loading..." />}>
+          <App />
+        </Suspense>,
       );
     });
     expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
@@ -701,19 +703,20 @@ describe('ReactCache', () => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
-    expect(Scheduler).toHaveYielded(['A [v2]']);
+    if (getCacheSignal) {
+      expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
+    } else {
+      expect(Scheduler).toHaveYielded(['A [v2]']);
+    }
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
-    // the original cache instance does not cleanup since it is still referenced
-    // by the root, but the refreshed inner cache does cleanup
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('refresh the root cache', async () => {
     let refresh;
     function App() {
@@ -761,7 +764,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('refresh the root cache without a transition', async () => {
     let refresh;
     function App() {
@@ -816,7 +819,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('refresh a cache with seed data', async () => {
     let refreshWithSeed;
     function App() {
@@ -879,7 +882,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('refreshing a parent cache also refreshes its children', async () => {
     let refreshShell;
     function RefreshShell() {
@@ -958,7 +961,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test(
     'refreshing a cache boundary does not refresh the other boundaries ' +
       'that mounted at the same time (i.e. the ones that share the same cache)',
@@ -1046,7 +1049,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test(
     'mount a new Cache boundary in a sibling while simultaneously ' +
       'resolving a Suspense boundary',
@@ -1119,7 +1122,7 @@ describe('ReactCache', () => {
     },
   );
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('cache pool is cleared once transitions that depend on it commit their shell', async () => {
     function Child({text}) {
       return (
@@ -1215,7 +1218,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('cache pool is not cleared by arbitrary commits', async () => {
     function App() {
       return (
@@ -1294,7 +1297,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('cache boundary uses a fresh cache when its key changes', async () => {
     const root = ReactNoop.createRoot();
     seedNextTextCache('A');
@@ -1333,7 +1336,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('overlapping transitions after an initial mount use the same fresh cache', async () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
@@ -1404,7 +1407,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('overlapping updates after an initial mount use the same fresh cache', async () => {
     const root = ReactNoop.createRoot();
     await act(async () => {
@@ -1470,7 +1473,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test('cleans up cache only used in an aborted transition', async () => {
     const root = ReactNoop.createRoot();
     seedNextTextCache('A');
@@ -1525,7 +1528,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test.skip('if a root cache refresh never commits its fresh cache is released', async () => {
     const root = ReactNoop.createRoot();
     let refresh;
@@ -1567,7 +1570,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate experimental || www
+  // @gate enableCacheElement && enableCache
   test.skip('if a cache boundary refresh never commits its fresh cache is released', async () => {
     const root = ReactNoop.createRoot();
     let refresh;

commit 25a8b9735ce7c84210707d5eced7fe2c9abbd0e1
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 2 22:34:58 2023 -0500

    Codemod tests to waitFor pattern (1/?) (#26288)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 7b1eda50ff..47a9697126 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -3,6 +3,7 @@ let ReactNoop;
 let Cache;
 let getCacheSignal;
 let Scheduler;
+let assertLog;
 let act;
 let Suspense;
 let Offscreen;
@@ -32,6 +33,9 @@ describe('ReactCache', () => {
     startTransition = React.startTransition;
     useState = React.useState;
 
+    const InternalTestUtils = require('internal-test-utils');
+    assertLog = InternalTestUtils.assertLog;
+
     textCaches = [];
     seededCache = null;
 
@@ -203,20 +207,19 @@ describe('ReactCache', () => {
         </Cache>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A']);
+    assertLog(['A']);
     expect(root).toMatchRenderedOutput('A');
 
     await act(async () => {
       root.render('Bye');
     });
-    // no cleanup: cache is still retained at the root
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -230,20 +233,19 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A']);
+    assertLog(['A']);
     expect(root).toMatchRenderedOutput('A');
 
     await act(async () => {
       root.render('Bye');
     });
-    // no cleanup: cache is still retained at the root
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -271,26 +273,19 @@ describe('ReactCache', () => {
       root.render(<App showMore={false} />);
     });
 
-    // Even though there are two new <Cache /> trees, they should share the same
-    // data cache. So there should be only a single cache miss for A.
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'Loading...',
-    ]);
+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A', 'A']);
+    assertLog(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
 
     await act(async () => {
       root.render('Bye');
     });
-    // no cleanup: cache is still retained at the root
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -319,34 +314,25 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
     await act(async () => {
       root.render(<App showMore={true} />);
     });
-    // Even though there are two new <Cache /> trees, they should share the same
-    // data cache. So there should be only a single cache miss for A.
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'Loading...',
-    ]);
+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A', 'A']);
+    assertLog(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
 
     await act(async () => {
       root.render('Bye');
     });
-    // cleanup occurs for the cache shared by the inner cache boundaries (which
-    // are not shared w the root because they were added in an update)
-    // note that no cache is created for the root since the cache is never accessed
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);
+    assertLog(['Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -370,22 +356,19 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render(<App />);
       });
-      // Even though there is a nested <Cache /> boundary, it should share the same
-      // data cache as the root. So there should be only a single cache miss for A.
-      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+      assertLog(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
       await act(async () => {
         resolveMostRecentTextCache('A');
       });
-      expect(Scheduler).toHaveYielded(['A', 'A']);
+      assertLog(['A', 'A']);
       expect(root).toMatchRenderedOutput('AA');
 
       await act(async () => {
         root.render('Bye');
       });
-      // no cleanup: cache is still retained at the root
-      expect(Scheduler).toHaveYielded([]);
+      assertLog([]);
       expect(root).toMatchRenderedOutput('Bye');
     },
   );
@@ -412,14 +395,14 @@ describe('ReactCache', () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
     await act(async () => {
       root.render(<App showMore={true} />);
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'A [v1]',
       // New tree should use already cached data
       'A [v1]',
@@ -429,8 +412,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
-    // no cleanup: cache is still retained at the root
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -460,14 +442,14 @@ describe('ReactCache', () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
     await act(async () => {
       root.render(<App showMore={true} />);
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'A [v1]',
       // New tree should load fresh data.
       'Cache miss! [A]',
@@ -477,7 +459,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v2]']);
+    assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
     // Replace all the children: this should retain the root Cache instance,
@@ -486,9 +468,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    // Cleanup occurs for the *second* cache instance: the first is still
-    // referenced by the root
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+    assertLog(['Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -535,13 +515,13 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);
+    assertLog(['Cache miss! [A]', 'Loading shell...']);
     expect(root).toMatchRenderedOutput('Loading shell...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'Shell',
       // There's a cache miss for B, because it hasn't been read yet. But not
       // A, because it was cached when we rendered the shell.
@@ -558,7 +538,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('B');
     });
-    expect(Scheduler).toHaveYielded(['Content']);
+    assertLog(['Content']);
     expect(root).toMatchRenderedOutput(
       <>
         <div>Shell</div>
@@ -569,8 +549,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
-    // no cleanup: cache is still retained at the root
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -619,19 +598,19 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
     await act(async () => {
       root.render(<App showMore={true} />);
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading shell...']);
+    assertLog(['Cache miss! [A]', 'Loading shell...']);
     expect(root).toMatchRenderedOutput('Loading shell...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'Shell',
       // There's a cache miss for B, because it hasn't been read yet. But not
       // A, because it was cached when we rendered the shell.
@@ -648,7 +627,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('B');
     });
-    expect(Scheduler).toHaveYielded(['Content']);
+    assertLog(['Content']);
     expect(root).toMatchRenderedOutput(
       <>
         <div>Shell</div>
@@ -659,10 +638,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache cleanup: A [v1]',
-      'Cache cleanup: B [v1]',
-    ]);
+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: B [v1]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -683,20 +659,20 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
     await act(async () => {
       startTransition(() => refresh());
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
@@ -704,9 +680,9 @@ describe('ReactCache', () => {
     });
     // Note that the version has updated
     if (getCacheSignal) {
-      expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
+      assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
     } else {
-      expect(Scheduler).toHaveYielded(['A [v2]']);
+      assertLog(['A [v2]']);
     }
     expect(root).toMatchRenderedOutput('A [v2]');
 
@@ -733,34 +709,32 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
     await act(async () => {
       startTransition(() => refresh());
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    // Note that the version has updated, and the previous cache is cleared
-    expect(Scheduler).toHaveYielded(['A [v2]', 'Cache cleanup: A [v1]']);
+    assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
-    // the original root cache already cleaned up when the refresh completed
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -781,20 +755,20 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
     await act(async () => {
       refresh();
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'Cache miss! [A]',
       'Loading...',
       // The v1 cache can be cleaned up since everything that references it has
@@ -807,15 +781,13 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    // Note that the version has updated, and the previous cache is cleared
-    expect(Scheduler).toHaveYielded(['A [v2]']);
+    assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
-    // the original root cache already cleaned up when the refresh completed
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -847,13 +819,13 @@ describe('ReactCache', () => {
         </Cache>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
@@ -869,16 +841,13 @@ describe('ReactCache', () => {
         }),
       );
     });
-    // The root should re-render without a cache miss.
-    // The cache is not cleared up yet, since it's still reference by the root
-    expect(Scheduler).toHaveYielded(['A [v2]']);
+    assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
-    // the refreshed cache boundary is unmounted and cleans up
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+    assertLog(['Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
 
@@ -913,7 +882,7 @@ describe('ReactCache', () => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
@@ -921,7 +890,7 @@ describe('ReactCache', () => {
       seedNextTextCache('A');
       root.render(<App showMore={true} />);
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'A [v1]',
       // New tree should load fresh data.
       'A [v2]',
@@ -933,17 +902,13 @@ describe('ReactCache', () => {
     await act(async () => {
       startTransition(() => refreshShell());
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache miss! [A]',
-      'Loading...',
-      'Loading...',
-    ]);
+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       'A [v3]',
       'A [v3]',
       // once the refresh completes the inner showMore boundary frees its previous
@@ -955,9 +920,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    // Unmounting children releases the refreshed cache instance only; the root
-    // still retains the original cache instance used for the first render
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v3]']);
+    assertLog(['Cache cleanup: A [v3]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1004,19 +967,13 @@ describe('ReactCache', () => {
         root.render(<App showMore={true} />);
       });
 
-      // Even though there are two new <Cache /> trees, they should share the same
-      // data cache. So there should be only a single cache miss for A.
-      expect(Scheduler).toHaveYielded([
-        'Cache miss! [A]',
-        'Loading...',
-        'Loading...',
-      ]);
+      assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...Loading...');
 
       await act(async () => {
         resolveMostRecentTextCache('A');
       });
-      expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
+      assertLog(['A [v1]', 'A [v1]']);
       expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
       // Refresh the first boundary. It should not refresh the second boundary,
@@ -1024,12 +981,12 @@ describe('ReactCache', () => {
       await act(async () => {
         await refreshFirstBoundary();
       });
-      expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+      assertLog(['Cache miss! [A]', 'Loading...']);
 
       await act(async () => {
         resolveMostRecentTextCache('A');
       });
-      expect(Scheduler).toHaveYielded(['A [v2]']);
+      assertLog(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2]A [v1]');
 
       // Unmount children: this should clear *both* cache instances:
@@ -1041,10 +998,7 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render('Bye!');
       });
-      expect(Scheduler).toHaveYielded([
-        'Cache cleanup: A [v2]',
-        'Cache cleanup: A [v1]',
-      ]);
+      assertLog(['Cache cleanup: A [v2]', 'Cache cleanup: A [v1]']);
       expect(root).toMatchRenderedOutput('Bye!');
     },
   );
@@ -1079,11 +1033,7 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render(<App showMore={false} />);
       });
-      expect(Scheduler).toHaveYielded([
-        'Cache miss! [A]',
-        'Cache miss! [B]',
-        'Loading...',
-      ]);
+      assertLog(['Cache miss! [A]', 'Cache miss! [B]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
       await act(async () => {
@@ -1093,7 +1043,7 @@ describe('ReactCache', () => {
         // And mount the second tree, which includes new content
         root.render(<App showMore={true} />);
       });
-      expect(Scheduler).toHaveYielded([
+      assertLog([
         // The new tree should use a fresh cache
         'Cache miss! [A]',
         'Loading...',
@@ -1108,16 +1058,13 @@ describe('ReactCache', () => {
       await act(async () => {
         resolveMostRecentTextCache('A');
       });
-      expect(Scheduler).toHaveYielded(['A [v2]']);
+      assertLog(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
 
       await act(async () => {
         root.render('Bye!');
       });
-      // Unmounting children releases both cache boundaries, but the original
-      // cache instance (used by second boundary) is still referenced by the root.
-      // only the second cache instance is freed.
-      expect(Scheduler).toHaveYielded(['Cache cleanup: A [v2]']);
+      assertLog(['Cache cleanup: A [v2]']);
       expect(root).toMatchRenderedOutput('Bye!');
     },
   );
@@ -1138,7 +1085,7 @@ describe('ReactCache', () => {
         <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
     await act(async () => {
@@ -1150,7 +1097,7 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('(empty)');
 
     await act(async () => {
@@ -1163,7 +1110,7 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // No cache miss, because it uses the pooled cache
       'Loading...',
     ]);
@@ -1173,7 +1120,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]']);
+    assertLog(['A [v1]', 'A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
     // Now do another transition
@@ -1188,7 +1135,7 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // First two children use the old cache because they already finished
       'A [v1]',
       'A [v1]',
@@ -1201,7 +1148,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]', 'A [v1]', 'A [v2]']);
+    assertLog(['A [v1]', 'A [v1]', 'A [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');
 
     // Unmount children: the first text cache instance is created only after the root
@@ -1211,10 +1158,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache cleanup: A [v1]',
-      'Cache cleanup: A [v2]',
-    ]);
+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1257,7 +1201,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['0']);
+    assertLog(['0']);
     expect(root).toMatchRenderedOutput('0');
 
     await act(async () => {
@@ -1265,13 +1209,13 @@ describe('ReactCache', () => {
         showMore();
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]', 'Loading...']);
+    assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('0');
 
     await act(async () => {
       updateUnrelated(1);
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       '1',
 
       // Happens to re-render the fallback. Doesn't need to, but not relevant
@@ -1283,7 +1227,7 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]1');
 
     // Unmount children: the first text cache instance is created only after initial
@@ -1293,7 +1237,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded(['Cache cleanup: A [v1]']);
+    assertLog(['Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1310,7 +1254,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     seedNextTextCache('B');
@@ -1323,7 +1267,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['B [v2]']);
+    assertLog(['B [v2]']);
     expect(root).toMatchRenderedOutput('B [v2]');
 
     // Unmount children: the fresh cache instance for B cleans up since the cache boundary
@@ -1332,7 +1276,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded(['Cache cleanup: B [v2]']);
+    assertLog(['Cache cleanup: B [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1348,13 +1292,13 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // After a mount, subsequent transitions use a fresh cache
@@ -1369,7 +1313,7 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    assertLog(['Cache miss! [B]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Update to a different text and with a different key for the cache
@@ -1386,13 +1330,13 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);
+    assertLog(['Cache miss! [C]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
       resolveMostRecentTextCache('C');
     });
-    expect(Scheduler).toHaveYielded(['C [v2]']);
+    assertLog(['C [v2]']);
     expect(root).toMatchRenderedOutput('C [v2]');
 
     // Unmount children: the fresh cache used for the updates is freed, while the
@@ -1400,10 +1344,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache cleanup: B [v2]',
-      'Cache cleanup: C [v2]',
-    ]);
+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1419,13 +1360,13 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // After a mount, subsequent updates use a fresh cache
@@ -1438,7 +1379,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    assertLog(['Cache miss! [B]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     // A second update uses the same fresh cache: even though this is a new
@@ -1452,13 +1393,13 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [C]']);
+    assertLog(['Cache miss! [C]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
     await act(async () => {
       resolveMostRecentTextCache('C');
     });
-    expect(Scheduler).toHaveYielded(['C [v2]']);
+    assertLog(['C [v2]']);
     expect(root).toMatchRenderedOutput('C [v2]');
 
     // Unmount children: the fresh cache used for the updates is freed, while the
@@ -1466,10 +1407,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([
-      'Cache cleanup: B [v2]',
-      'Cache cleanup: C [v2]',
-    ]);
+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1486,7 +1424,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Start a transition from A -> B..., which should create a fresh cache
@@ -1502,7 +1440,7 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [B]']);
+    assertLog(['Cache miss! [B]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // ...but cancel by transitioning "back" to A (which we never really left)
@@ -1517,14 +1455,14 @@ describe('ReactCache', () => {
         );
       });
     });
-    expect(Scheduler).toHaveYielded(['A [v1]', 'Cache cleanup: B [v2]']);
+    assertLog(['A [v1]', 'Cache cleanup: B [v2]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Unmount children: ...
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
@@ -1544,7 +1482,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
@@ -1552,13 +1490,13 @@ describe('ReactCache', () => {
         refresh();
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // TODO: the v1 cache should *not* be cleaned up, it is still retained by the root
       // The following line is presently yielded but should not be:
       // 'Cache cleanup: A [v1]',
@@ -1588,7 +1526,7 @@ describe('ReactCache', () => {
         </Suspense>,
       );
     });
-    expect(Scheduler).toHaveYielded(['A [v1]']);
+    assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     await act(async () => {
@@ -1596,14 +1534,14 @@ describe('ReactCache', () => {
         refresh();
       });
     });
-    expect(Scheduler).toHaveYielded(['Cache miss! [A]']);
+    assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Unmount the boundary before the refresh can complete
     await act(async () => {
       root.render('Bye!');
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh
       // The following line is presently not yielded but should be:
       'Cache cleanup: A [v2]',
@@ -1632,14 +1570,14 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App prerenderMore={false} />);
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput(<div hidden={true} />);
 
     seedNextTextCache('More');
     await act(async () => {
       root.render(<App prerenderMore={true} />);
     });
-    expect(Scheduler).toHaveYielded(['More']);
+    assertLog(['More']);
     expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);
   });
 

commit 5c633a48f9bdc212e27ae026c74148b42cc47efb
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 14:34:41 2023 -0500

    Add back accidentally deleted test comments (#26294)
    
    The codemod I used in #26288 accidentally caused some comments to be
    deleted. Because not all affected lines included comments, I didn't
    notice until after landing.
    
    This adds the comments back.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 47a9697126..25e0dbebb0 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -219,6 +219,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // no cleanup: cache is still retained at the root
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -245,6 +246,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // no cleanup: cache is still retained at the root
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -273,6 +275,8 @@ describe('ReactCache', () => {
       root.render(<App showMore={false} />);
     });
 
+    // Even though there are two new <Cache /> trees, they should share the same
+    // data cache. So there should be only a single cache miss for A.
     assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
@@ -285,6 +289,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // no cleanup: cache is still retained at the root
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -320,6 +325,8 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render(<App showMore={true} />);
     });
+    // Even though there are two new <Cache /> trees, they should share the same
+    // data cache. So there should be only a single cache miss for A.
     assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
@@ -332,6 +339,9 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // cleanup occurs for the cache shared by the inner cache boundaries (which
+    // are not shared w the root because they were added in an update)
+    // note that no cache is created for the root since the cache is never accessed
     assertLog(['Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -356,6 +366,8 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render(<App />);
       });
+      // Even though there is a nested <Cache /> boundary, it should share the same
+      // data cache as the root. So there should be only a single cache miss for A.
       assertLog(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
@@ -368,6 +380,7 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render('Bye');
       });
+      // no cleanup: cache is still retained at the root
       assertLog([]);
       expect(root).toMatchRenderedOutput('Bye');
     },
@@ -412,6 +425,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // no cleanup: cache is still retained at the root
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -468,6 +482,8 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
+    // Cleanup occurs for the *second* cache instance: the first is still
+    // referenced by the root
     assertLog(['Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
@@ -549,6 +565,7 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye');
     });
+    // no cleanup: cache is still retained at the root
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -728,12 +745,14 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
+    // Note that the version has updated, and the previous cache is cleared
     assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
+    // the original root cache already cleaned up when the refresh completed
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -781,12 +800,14 @@ describe('ReactCache', () => {
     await act(async () => {
       resolveMostRecentTextCache('A');
     });
+    // Note that the version has updated, and the previous cache is cleared
     assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
+    // the original root cache already cleaned up when the refresh completed
     assertLog([]);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -841,12 +862,15 @@ describe('ReactCache', () => {
         }),
       );
     });
+    // The root should re-render without a cache miss.
+    // The cache is not cleared up yet, since it's still reference by the root
     assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
     await act(async () => {
       root.render('Bye');
     });
+    // the refreshed cache boundary is unmounted and cleans up
     assertLog(['Cache cleanup: A [v2]']);
     expect(root).toMatchRenderedOutput('Bye');
   });
@@ -920,6 +944,8 @@ describe('ReactCache', () => {
     await act(async () => {
       root.render('Bye!');
     });
+    // Unmounting children releases the refreshed cache instance only; the root
+    // still retains the original cache instance used for the first render
     assertLog(['Cache cleanup: A [v3]']);
     expect(root).toMatchRenderedOutput('Bye!');
   });
@@ -967,6 +993,8 @@ describe('ReactCache', () => {
         root.render(<App showMore={true} />);
       });
 
+      // Even though there are two new <Cache /> trees, they should share the same
+      // data cache. So there should be only a single cache miss for A.
       assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...Loading...');
 
@@ -1064,6 +1092,9 @@ describe('ReactCache', () => {
       await act(async () => {
         root.render('Bye!');
       });
+      // Unmounting children releases both cache boundaries, but the original
+      // cache instance (used by second boundary) is still referenced by the root.
+      // only the second cache instance is freed.
       assertLog(['Cache cleanup: A [v2]']);
       expect(root).toMatchRenderedOutput('Bye!');
     },

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 25e0dbebb0..770ebaaac9 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -100,9 +100,7 @@ describe('ReactCache', () => {
         record.cleanupScheduled = true;
         if (getCacheSignal) {
           signal.addEventListener('abort', () => {
-            Scheduler.unstable_yieldValue(
-              `Cache cleanup: ${text} [v${textCache.version}]`,
-            );
+            Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);
           });
         }
       }
@@ -115,7 +113,7 @@ describe('ReactCache', () => {
           return textCache.version;
       }
     } else {
-      Scheduler.unstable_yieldValue(`Cache miss! [${text}]`);
+      Scheduler.log(`Cache miss! [${text}]`);
 
       let resolve;
       let reject;
@@ -148,9 +146,7 @@ describe('ReactCache', () => {
 
       if (getCacheSignal) {
         signal.addEventListener('abort', () => {
-          Scheduler.unstable_yieldValue(
-            `Cache cleanup: ${text} [v${textCache.version}]`,
-          );
+          Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);
         });
       }
       throw thenable;
@@ -158,14 +154,14 @@ describe('ReactCache', () => {
   }
 
   function Text({text}) {
-    Scheduler.unstable_yieldValue(text);
+    Scheduler.log(text);
     return text;
   }
 
   function AsyncText({text, showVersion}) {
     const version = readText(text);
     const fullText = showVersion ? `${text} [v${version}]` : text;
-    Scheduler.unstable_yieldValue(fullText);
+    Scheduler.log(fullText);
     return fullText;
   }
 

commit 44d3807945700de8bb6bdbbf5c4d1ba513303747
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 12:58:31 2023 -0500

    Move internalAct to internal-test-utils package (#26344)
    
    This is not a public API. We only use it for our internal tests, the
    ones in this repo. Let's move it to this private package. Practically
    speaking this will also let us use async/await in the implementation.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 770ebaaac9..a0ba653bfa 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -24,7 +24,7 @@ describe('ReactCache', () => {
     ReactNoop = require('react-noop-renderer');
     Cache = React.unstable_Cache;
     Scheduler = require('scheduler');
-    act = require('jest-react').act;
+    act = require('internal-test-utils').act;
     Suspense = React.Suspense;
     cache = React.cache;
     Offscreen = React.unstable_Offscreen;

commit 62cd5af08e2ac8b1d4691e75252487083cf7a4aa
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 16:40:23 2023 -0500

    Codemod redundant async act scopes (#26350)
    
    Prior to #26347, our internal `act` API (not the public API) behaved
    differently depending on whether the scope function returned a promise
    (i.e. was an async function), for historical reasons that no longer
    apply. Now that this is fixed, I've codemodded all async act scopes that
    don't contain an await to be sync.
    
    No pressing motivation other than it looks nicer and the codemod was
    easy. Might help avoid confusion for new contributors who see async act
    scopes with nothing async inside and infer it must be like that for a
    reason.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index a0ba653bfa..6b1cb7423a 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -185,7 +185,7 @@ describe('ReactCache', () => {
   // @gate enableCacheElement && enableCache
   test('render Cache component', async () => {
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<Cache>Hi</Cache>);
     });
     expect(root).toMatchRenderedOutput('Hi');
@@ -194,7 +194,7 @@ describe('ReactCache', () => {
   // @gate enableCacheElement && enableCache
   test('mount new data', async () => {
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Cache>
           <Suspense fallback={<Text text="Loading..." />}>
@@ -206,13 +206,13 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A']);
     expect(root).toMatchRenderedOutput('A');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // no cleanup: cache is still retained at the root
@@ -223,7 +223,7 @@ describe('ReactCache', () => {
   // @gate enableCache
   test('root acts as implicit cache boundary', async () => {
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <AsyncText text="A" />
@@ -233,13 +233,13 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A']);
     expect(root).toMatchRenderedOutput('A');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // no cleanup: cache is still retained at the root
@@ -267,7 +267,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={false} />);
     });
 
@@ -276,13 +276,13 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // no cleanup: cache is still retained at the root
@@ -312,13 +312,13 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={false} />);
     });
     assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={true} />);
     });
     // Even though there are two new <Cache /> trees, they should share the same
@@ -326,13 +326,13 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A', 'A']);
     expect(root).toMatchRenderedOutput('AA');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // cleanup occurs for the cache shared by the inner cache boundaries (which
@@ -359,7 +359,7 @@ describe('ReactCache', () => {
       }
 
       const root = ReactNoop.createRoot();
-      await act(async () => {
+      await act(() => {
         root.render(<App />);
       });
       // Even though there is a nested <Cache /> boundary, it should share the same
@@ -367,13 +367,13 @@ describe('ReactCache', () => {
       assertLog(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
-      await act(async () => {
+      await act(() => {
         resolveMostRecentTextCache('A');
       });
       assertLog(['A', 'A']);
       expect(root).toMatchRenderedOutput('AA');
 
-      await act(async () => {
+      await act(() => {
         root.render('Bye');
       });
       // no cleanup: cache is still retained at the root
@@ -400,7 +400,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -408,7 +408,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={true} />);
     });
     assertLog([
@@ -418,7 +418,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // no cleanup: cache is still retained at the root
@@ -448,7 +448,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -456,7 +456,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={true} />);
     });
     assertLog([
@@ -466,7 +466,7 @@ describe('ReactCache', () => {
       'Loading...',
     ]);
     expect(root).toMatchRenderedOutput('A [v1]Loading...');
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v2]']);
@@ -475,7 +475,7 @@ describe('ReactCache', () => {
     // Replace all the children: this should retain the root Cache instance,
     // but cleanup the separate cache instance created for the fresh cache
     // boundary
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     // Cleanup occurs for the *second* cache instance: the first is still
@@ -524,13 +524,13 @@ describe('ReactCache', () => {
       return <Text text="Content" />;
     }
 
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['Cache miss! [A]', 'Loading shell...']);
     expect(root).toMatchRenderedOutput('Loading shell...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog([
@@ -547,7 +547,7 @@ describe('ReactCache', () => {
       </>,
     );
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('B');
     });
     assertLog(['Content']);
@@ -558,7 +558,7 @@ describe('ReactCache', () => {
       </>,
     );
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // no cleanup: cache is still retained at the root
@@ -608,19 +608,19 @@ describe('ReactCache', () => {
       return <Text text="Content" />;
     }
 
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={false} />);
     });
     assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await act(async () => {
+    await act(() => {
       root.render(<App showMore={true} />);
     });
     assertLog(['Cache miss! [A]', 'Loading shell...']);
     expect(root).toMatchRenderedOutput('Loading shell...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog([
@@ -637,7 +637,7 @@ describe('ReactCache', () => {
       </>,
     );
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('B');
     });
     assertLog(['Content']);
@@ -648,7 +648,7 @@ describe('ReactCache', () => {
       </>,
     );
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: B [v1]']);
@@ -665,7 +665,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <App />
@@ -675,20 +675,20 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await act(async () => {
+    await act(() => {
       startTransition(() => refresh());
     });
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated
@@ -699,7 +699,7 @@ describe('ReactCache', () => {
     }
     expect(root).toMatchRenderedOutput('A [v2]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     expect(root).toMatchRenderedOutput('Bye');
@@ -715,7 +715,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <App />
@@ -725,27 +725,27 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await act(async () => {
+    await act(() => {
       startTransition(() => refresh());
     });
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated, and the previous cache is cleared
     assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // the original root cache already cleaned up when the refresh completed
@@ -763,7 +763,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>
           <App />
@@ -773,14 +773,14 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await act(async () => {
+    await act(() => {
       refresh();
     });
     assertLog([
@@ -793,14 +793,14 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     // Note that the version has updated, and the previous cache is cleared
     assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // the original root cache already cleaned up when the refresh completed
@@ -827,7 +827,7 @@ describe('ReactCache', () => {
 
     // Mount initial data
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Cache>
           <Suspense fallback={<Text text="Loading..." />}>
@@ -839,14 +839,14 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Refresh for new data.
-    await act(async () => {
+    await act(() => {
       // Refresh the cache with seeded data, like you would receive from a
       // server mutation.
       // TODO: Seeding multiple typed textCaches. Should work by calling `refresh`
@@ -863,7 +863,7 @@ describe('ReactCache', () => {
     assertLog(['A [v2]']);
     expect(root).toMatchRenderedOutput('A [v2]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye');
     });
     // the refreshed cache boundary is unmounted and cleans up
@@ -898,7 +898,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       seedNextTextCache('A');
       root.render(<App showMore={false} />);
     });
@@ -906,7 +906,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Add a new cache boundary
-    await act(async () => {
+    await act(() => {
       seedNextTextCache('A');
       root.render(<App showMore={true} />);
     });
@@ -919,13 +919,13 @@ describe('ReactCache', () => {
 
     // Now refresh the shell. This should also cause the "Show More" contents to
     // refresh, since its cache is nested inside the outer one.
-    await act(async () => {
+    await act(() => {
       startTransition(() => refreshShell());
     });
     assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
     expect(root).toMatchRenderedOutput('A [v1]A [v2]');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog([
@@ -937,7 +937,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('A [v3]A [v3]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     // Unmounting children releases the refreshed cache instance only; the root
@@ -980,12 +980,12 @@ describe('ReactCache', () => {
       // treated like sibling providers that happen to share an underlying
       // cache, as opposed to consumers of the root-level cache.
       const root = ReactNoop.createRoot();
-      await act(async () => {
+      await act(() => {
         root.render(<App showMore={false} />);
       });
 
       // Now reveal the boundaries. In a real app  this would be a navigation.
-      await act(async () => {
+      await act(() => {
         root.render(<App showMore={true} />);
       });
 
@@ -994,7 +994,7 @@ describe('ReactCache', () => {
       assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...Loading...');
 
-      await act(async () => {
+      await act(() => {
         resolveMostRecentTextCache('A');
       });
       assertLog(['A [v1]', 'A [v1]']);
@@ -1007,7 +1007,7 @@ describe('ReactCache', () => {
       });
       assertLog(['Cache miss! [A]', 'Loading...']);
 
-      await act(async () => {
+      await act(() => {
         resolveMostRecentTextCache('A');
       });
       assertLog(['A [v2]']);
@@ -1019,7 +1019,7 @@ describe('ReactCache', () => {
       // a fresh boundary). Therefore this causes cleanup for both the fresh cache
       // instance in the refreshed first boundary and cleanup for the non-refreshed
       // sibling boundary.
-      await act(async () => {
+      await act(() => {
         root.render('Bye!');
       });
       assertLog(['Cache cleanup: A [v2]', 'Cache cleanup: A [v1]']);
@@ -1054,13 +1054,13 @@ describe('ReactCache', () => {
       }
 
       const root = ReactNoop.createRoot();
-      await act(async () => {
+      await act(() => {
         root.render(<App showMore={false} />);
       });
       assertLog(['Cache miss! [A]', 'Cache miss! [B]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
-      await act(async () => {
+      await act(() => {
         // This will resolve the content in the first cache
         resolveMostRecentTextCache('A');
         resolveMostRecentTextCache('B');
@@ -1079,13 +1079,13 @@ describe('ReactCache', () => {
       expect(root).toMatchRenderedOutput('Loading... A [v1] B [v1]');
 
       // Now resolve the second tree
-      await act(async () => {
+      await act(() => {
         resolveMostRecentTextCache('A');
       });
       assertLog(['A [v2]']);
       expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
 
-      await act(async () => {
+      await act(() => {
         root.render('Bye!');
       });
       // Unmounting children releases both cache boundaries, but the original
@@ -1107,7 +1107,7 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,
       );
@@ -1115,7 +1115,7 @@ describe('ReactCache', () => {
     assertLog([]);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -1127,7 +1127,7 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('(empty)');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -1144,14 +1144,14 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('(empty)');
 
     // Resolve the request
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]', 'A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
     // Now do another transition
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback={<Text text="Loading..." />}>
@@ -1172,7 +1172,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('A [v1]A [v1]');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]', 'A [v1]', 'A [v2]']);
@@ -1182,7 +1182,7 @@ describe('ReactCache', () => {
     // commits, so both fresh cache instances are released by their cache boundaries,
     // cleaning up v1 (used for the first two children which render together) and
     // v2 (used for the third boundary added later).
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: A [v2]']);
@@ -1225,13 +1225,13 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['0']);
     expect(root).toMatchRenderedOutput('0');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         showMore();
       });
@@ -1239,7 +1239,7 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]', 'Loading...']);
     expect(root).toMatchRenderedOutput('0');
 
-    await act(async () => {
+    await act(() => {
       updateUnrelated(1);
     });
     assertLog([
@@ -1251,7 +1251,7 @@ describe('ReactCache', () => {
     ]);
     expect(root).toMatchRenderedOutput('1');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
@@ -1261,7 +1261,7 @@ describe('ReactCache', () => {
     // render after calling showMore(). This instance is cleaned up when that boundary
     // is unmounted. Bc root cache instance is never accessed, the inner cache
     // boundary ends up at v1.
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog(['Cache cleanup: A [v1]']);
@@ -1272,7 +1272,7 @@ describe('ReactCache', () => {
   test('cache boundary uses a fresh cache when its key changes', async () => {
     const root = ReactNoop.createRoot();
     seedNextTextCache('A');
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="A">
@@ -1285,7 +1285,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     seedNextTextCache('B');
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="B">
@@ -1300,7 +1300,7 @@ describe('ReactCache', () => {
     // Unmount children: the fresh cache instance for B cleans up since the cache boundary
     // is the only owner, while the original cache instance (for A) is still retained by
     // the root.
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog(['Cache cleanup: B [v2]']);
@@ -1310,7 +1310,7 @@ describe('ReactCache', () => {
   // @gate enableCacheElement && enableCache
   test('overlapping transitions after an initial mount use the same fresh cache', async () => {
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="A">
@@ -1322,14 +1322,14 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // After a mount, subsequent transitions use a fresh cache
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback="Loading...">
@@ -1346,7 +1346,7 @@ describe('ReactCache', () => {
     // Update to a different text and with a different key for the cache
     // boundary: this should still use the fresh cache instance created
     // for the earlier transition
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback="Loading...">
@@ -1360,7 +1360,7 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [C]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('C');
     });
     assertLog(['C [v2]']);
@@ -1368,7 +1368,7 @@ describe('ReactCache', () => {
 
     // Unmount children: the fresh cache used for the updates is freed, while the
     // original cache (with A) is still retained at the root.
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
@@ -1378,7 +1378,7 @@ describe('ReactCache', () => {
   // @gate enableCacheElement && enableCache
   test('overlapping updates after an initial mount use the same fresh cache', async () => {
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="A">
@@ -1390,14 +1390,14 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('A');
     });
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // After a mount, subsequent updates use a fresh cache
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="B">
@@ -1411,7 +1411,7 @@ describe('ReactCache', () => {
 
     // A second update uses the same fresh cache: even though this is a new
     // Cache boundary, the render uses the fresh cache from the pending update.
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="C">
@@ -1423,7 +1423,7 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [C]']);
     expect(root).toMatchRenderedOutput('Loading...');
 
-    await act(async () => {
+    await act(() => {
       resolveMostRecentTextCache('C');
     });
     assertLog(['C [v2]']);
@@ -1431,7 +1431,7 @@ describe('ReactCache', () => {
 
     // Unmount children: the fresh cache used for the updates is freed, while the
     // original cache (with A) is still retained at the root.
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
@@ -1442,7 +1442,7 @@ describe('ReactCache', () => {
   test('cleans up cache only used in an aborted transition', async () => {
     const root = ReactNoop.createRoot();
     seedNextTextCache('A');
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache key="A">
@@ -1456,7 +1456,7 @@ describe('ReactCache', () => {
 
     // Start a transition from A -> B..., which should create a fresh cache
     // for the new cache boundary (bc of the different key)
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback="Loading...">
@@ -1471,7 +1471,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // ...but cancel by transitioning "back" to A (which we never really left)
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(
           <Suspense fallback="Loading...">
@@ -1486,7 +1486,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Unmount children: ...
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog([]);
@@ -1502,7 +1502,7 @@ describe('ReactCache', () => {
       return <AsyncText showVersion={true} text={text} />;
     }
     seedNextTextCache('A');
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Example text="A" />
@@ -1512,7 +1512,7 @@ describe('ReactCache', () => {
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         refresh();
       });
@@ -1520,7 +1520,7 @@ describe('ReactCache', () => {
     assertLog(['Cache miss! [A]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog([
@@ -1544,7 +1544,7 @@ describe('ReactCache', () => {
       return <AsyncText showVersion={true} text={text} />;
     }
     seedNextTextCache('A');
-    await act(async () => {
+    await act(() => {
       root.render(
         <Suspense fallback="Loading...">
           <Cache>
@@ -1556,7 +1556,7 @@ describe('ReactCache', () => {
     assertLog(['A [v1]']);
     expect(root).toMatchRenderedOutput('A [v1]');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         refresh();
       });
@@ -1565,7 +1565,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('A [v1]');
 
     // Unmount the boundary before the refresh can complete
-    await act(async () => {
+    await act(() => {
       root.render('Bye!');
     });
     assertLog([
@@ -1594,14 +1594,14 @@ describe('ReactCache', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App prerenderMore={false} />);
     });
     assertLog([]);
     expect(root).toMatchRenderedOutput(<div hidden={true} />);
 
     seedNextTextCache('More');
-    await act(async () => {
+    await act(() => {
       root.render(<App prerenderMore={true} />);
     });
     assertLog(['More']);
@@ -1629,7 +1629,7 @@ describe('ReactCache', () => {
     function MoreArgs({a, b}) {
       return (types(a) === types(a, b)).toString() + ' ';
     }
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a="e" b="f" />
@@ -1641,7 +1641,7 @@ describe('ReactCache', () => {
       );
     });
     expect(root).toMatchRenderedOutput('string string true false false false ');
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a="e" b={null} />
@@ -1654,7 +1654,7 @@ describe('ReactCache', () => {
     });
     expect(root).toMatchRenderedOutput('string object true false false false ');
     const obj = {};
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a="e" b={obj} />
@@ -1667,7 +1667,7 @@ describe('ReactCache', () => {
     });
     expect(root).toMatchRenderedOutput('string object true false false false ');
     const sameObj = {};
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a={sameObj} b={sameObj} />
@@ -1681,7 +1681,7 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('object object true true false false ');
     const objA = {};
     const objB = {};
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a={objA} b={objB} />
@@ -1694,7 +1694,7 @@ describe('ReactCache', () => {
     });
     expect(root).toMatchRenderedOutput('object object true false false false ');
     const sameSymbol = Symbol();
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a={sameSymbol} b={sameSymbol} />
@@ -1707,7 +1707,7 @@ describe('ReactCache', () => {
     });
     expect(root).toMatchRenderedOutput('symbol symbol true true false false ');
     const notANumber = +'nan';
-    await act(async () => {
+    await act(() => {
       root.render(
         <>
           <Print a={1} b={notANumber} />
@@ -1749,7 +1749,7 @@ describe('ReactCache', () => {
 
       return 'Blank';
     }
-    await act(async () => {
+    await act(() => {
       root.render(<Test />);
     });
     expect(x).toBe(y);

commit 12a1d140e366aa8d95338e4412117f16da79a078
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 21 10:24:56 2023 -0400

    Don't prerender siblings of suspended component  (#26380)
    
    Today if something suspends, React will continue rendering the siblings
    of that component.
    
    Our original rationale for prerendering the siblings of a suspended
    component was to initiate any lazy fetches that they might contain. This
    was when we were more bullish about lazy fetching being a good idea some
    of the time (when combined with prefetching), as opposed to our latest
    thinking, which is that it's almost always a bad idea.
    
    Another rationale for the original behavior was that the render was I/O
    bound, anyway, so we might as do some extra work in the meantime. But
    this was before we had the concept of instant loading states: when
    navigating to a new screen, it's better to show a loading state as soon
    as you can (often a skeleton UI), rather than delay the transition.
    (There are still cases where we block the render, when a suitable
    loading state is not available; it's just not _all_ cases where
    something suspends.) So the biggest issue with our existing
    implementation is that the prerendering of the siblings happens within
    the same render pass as the one that suspended ‚Äî _before_ the loading
    state appears.
    
    What we should do instead is immediately unwind the stack as soon as
    something suspends, to unblock the loading state.
    
    If we want to preserve the ability to prerender the siblings, what we
    could do is schedule special render pass immediately after the fallback
    is displayed. This is likely what we'll do in the future. However, in
    the new implementation of `use`, there's another reason we don't
    prerender siblings: so we can preserve the state of the stack when
    something suspends, and resume where we left of when the promise
    resolves without replaying the parents. The only way to do this
    currently is to suspend the entire work loop. Fiber does not currently
    support rendering multiple siblings in "parallel". Once you move onto
    the next sibling, the stack of the previous sibling is discarded and
    cannot be restored. We do plan to implement this feature, but it will
    require a not-insignificant refactor.
    
    Given that lazy data fetching is already bad for performance, the best
    trade off for now seems to be to disable prerendering of siblings. This
    gives us the best performance characteristics when you're following best
    practices (i.e. hoist data fetches to Server Components or route
    loaders), at the expense of making an already bad pattern a bit worse.
    
    Later, when we implement resumable context stacks, we can reenable
    sibling prerendering. Though even then the use case will mostly be to
    prerender the CPU-bound work, not lazy fetches.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 6b1cb7423a..7709652467 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -1057,7 +1057,7 @@ describe('ReactCache', () => {
       await act(() => {
         root.render(<App showMore={false} />);
       });
-      assertLog(['Cache miss! [A]', 'Cache miss! [B]', 'Loading...']);
+      assertLog(['Cache miss! [A]', 'Loading...']);
       expect(root).toMatchRenderedOutput('Loading...');
 
       await act(() => {

commit ce2bc58a9f6f3b0bfc8c738a0d8e2a5f3a332ff5
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Nov 2 16:13:21 2023 -0400

    [activity] rename unstable_Offscreen to unstable_Activity (#27640)
    
    `Activity` is the current candidate name. This PR starts the rename work
    by renaming the exported unstable component name.
    
    NOTE: downstream consumers need to rename the import when updating to
    this commit.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 7709652467..dd4a7c5d5f 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -6,7 +6,7 @@ let Scheduler;
 let assertLog;
 let act;
 let Suspense;
-let Offscreen;
+let Activity;
 let useCacheRefresh;
 let startTransition;
 let useState;
@@ -27,7 +27,7 @@ describe('ReactCache', () => {
     act = require('internal-test-utils').act;
     Suspense = React.Suspense;
     cache = React.cache;
-    Offscreen = React.unstable_Offscreen;
+    Activity = React.unstable_Activity;
     getCacheSignal = React.unstable_getCacheSignal;
     useCacheRefresh = React.unstable_useCacheRefresh;
     startTransition = React.startTransition;
@@ -1576,12 +1576,12 @@ describe('ReactCache', () => {
     expect(root).toMatchRenderedOutput('Bye!');
   });
 
-  // @gate enableOffscreen
+  // @gate enableActivity
   // @gate enableCache
-  test('prerender a new cache boundary inside an Offscreen tree', async () => {
+  test('prerender a new cache boundary inside an Activity tree', async () => {
     function App({prerenderMore}) {
       return (
-        <Offscreen mode="hidden">
+        <Activity mode="hidden">
           <div>
             {prerenderMore ? (
               <Cache>
@@ -1589,7 +1589,7 @@ describe('ReactCache', () => {
               </Cache>
             ) : null}
           </div>
-        </Offscreen>
+        </Activity>
       );
     }
 

commit 5c607369ceebe56d85175df84b7b6ad58dd25e1f
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jan 16 20:27:15 2024 -0500

    Remove client caching from cache() API (#27977)
    
    We haven't yet decided how we want `cache` to work on the client. The
    lifetime of the cache is more complex than on the server, where it only
    has to live as long as a single request.
    
    Since it's more important to ship this on the server, we're removing the
    existing behavior from the client for now. On the client (i.e. not a
    Server Components environment) `cache` will have not have any caching
    behavior. `cache(fn)` will return the function as-is.
    
    We intend to implement client caching in a future major release. In the
    meantime, it's only exposed as an API so that Shared Components can use
    per-request caching on the server without breaking on the client.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index dd4a7c5d5f..b32479b70b 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -1,1616 +1,34 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ * @jest-environment node
+ */
+
+'use strict';
+
 let React;
-let ReactNoop;
-let Cache;
-let getCacheSignal;
-let Scheduler;
-let assertLog;
-let act;
-let Suspense;
-let Activity;
-let useCacheRefresh;
-let startTransition;
-let useState;
+let ReactNoopFlightServer;
+let ReactNoopFlightClient;
 let cache;
 
-let getTextCache;
-let textCaches;
-let seededCache;
-
 describe('ReactCache', () => {
   beforeEach(() => {
     jest.resetModules();
-
+    jest.mock('react', () => require('react/react.react-server'));
     React = require('react');
-    ReactNoop = require('react-noop-renderer');
-    Cache = React.unstable_Cache;
-    Scheduler = require('scheduler');
-    act = require('internal-test-utils').act;
-    Suspense = React.Suspense;
-    cache = React.cache;
-    Activity = React.unstable_Activity;
-    getCacheSignal = React.unstable_getCacheSignal;
-    useCacheRefresh = React.unstable_useCacheRefresh;
-    startTransition = React.startTransition;
-    useState = React.useState;
-
-    const InternalTestUtils = require('internal-test-utils');
-    assertLog = InternalTestUtils.assertLog;
-
-    textCaches = [];
-    seededCache = null;
-
-    if (gate(flags => flags.enableCache)) {
-      getTextCache = cache(() => {
-        if (seededCache !== null) {
-          // Trick to seed a cache before it exists.
-          // TODO: Need a built-in API to seed data before the initial render (i.e.
-          // not a refresh because nothing has mounted yet).
-          const textCache = seededCache;
-          seededCache = null;
-          return textCache;
-        }
-
-        const data = new Map();
-        const version = textCaches.length + 1;
-        const textCache = {
-          version,
-          data,
-          resolve(text) {
-            const record = data.get(text);
-            if (record === undefined) {
-              const newRecord = {
-                status: 'resolved',
-                value: text,
-                cleanupScheduled: false,
-              };
-              data.set(text, newRecord);
-            } else if (record.status === 'pending') {
-              record.value.resolve();
-            }
-          },
-          reject(text, error) {
-            const record = data.get(text);
-            if (record === undefined) {
-              const newRecord = {
-                status: 'rejected',
-                value: error,
-                cleanupScheduled: false,
-              };
-              data.set(text, newRecord);
-            } else if (record.status === 'pending') {
-              record.value.reject();
-            }
-          },
-        };
-        textCaches.push(textCache);
-        return textCache;
-      });
-    }
-  });
-
-  function readText(text) {
-    const signal = getCacheSignal ? getCacheSignal() : null;
-    const textCache = getTextCache();
-    const record = textCache.data.get(text);
-    if (record !== undefined) {
-      if (!record.cleanupScheduled) {
-        // This record was seeded prior to the abort signal being available:
-        // schedule a cleanup function for it.
-        // TODO: Add ability to cleanup entries seeded w useCacheRefresh()
-        record.cleanupScheduled = true;
-        if (getCacheSignal) {
-          signal.addEventListener('abort', () => {
-            Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);
-          });
-        }
-      }
-      switch (record.status) {
-        case 'pending':
-          throw record.value;
-        case 'rejected':
-          throw record.value;
-        case 'resolved':
-          return textCache.version;
-      }
-    } else {
-      Scheduler.log(`Cache miss! [${text}]`);
-
-      let resolve;
-      let reject;
-      const thenable = new Promise((res, rej) => {
-        resolve = res;
-        reject = rej;
-      }).then(
-        value => {
-          if (newRecord.status === 'pending') {
-            newRecord.status = 'resolved';
-            newRecord.value = value;
-          }
-        },
-        error => {
-          if (newRecord.status === 'pending') {
-            newRecord.status = 'rejected';
-            newRecord.value = error;
-          }
-        },
-      );
-      thenable.resolve = resolve;
-      thenable.reject = reject;
-
-      const newRecord = {
-        status: 'pending',
-        value: thenable,
-        cleanupScheduled: true,
-      };
-      textCache.data.set(text, newRecord);
-
-      if (getCacheSignal) {
-        signal.addEventListener('abort', () => {
-          Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);
-        });
-      }
-      throw thenable;
-    }
-  }
-
-  function Text({text}) {
-    Scheduler.log(text);
-    return text;
-  }
-
-  function AsyncText({text, showVersion}) {
-    const version = readText(text);
-    const fullText = showVersion ? `${text} [v${version}]` : text;
-    Scheduler.log(fullText);
-    return fullText;
-  }
-
-  function seedNextTextCache(text) {
-    if (seededCache === null) {
-      seededCache = getTextCache();
-    }
-    seededCache.resolve(text);
-  }
-
-  function resolveMostRecentTextCache(text) {
-    if (textCaches.length === 0) {
-      throw Error('Cache does not exist.');
-    } else {
-      // Resolve the most recently created cache. An older cache can by
-      // resolved with `textCaches[index].resolve(text)`.
-      textCaches[textCaches.length - 1].resolve(text);
-    }
-  }
-
-  // @gate enableCacheElement && enableCache
-  test('render Cache component', async () => {
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(<Cache>Hi</Cache>);
-    });
-    expect(root).toMatchRenderedOutput('Hi');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('mount new data', async () => {
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Cache>
-          <Suspense fallback={<Text text="Loading..." />}>
-            <AsyncText text="A" />
-          </Suspense>
-        </Cache>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A']);
-    expect(root).toMatchRenderedOutput('A');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // no cleanup: cache is still retained at the root
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCache
-  test('root acts as implicit cache boundary', async () => {
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback={<Text text="Loading..." />}>
-          <AsyncText text="A" />
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A']);
-    expect(root).toMatchRenderedOutput('A');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // no cleanup: cache is still retained at the root
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('multiple new Cache boundaries in the same mount share the same, fresh root cache', async () => {
-    function App() {
-      return (
-        <>
-          <Cache>
-            <Suspense fallback={<Text text="Loading..." />}>
-              <AsyncText text="A" />
-            </Suspense>
-          </Cache>
-          <Cache>
-            <Suspense fallback={<Text text="Loading..." />}>
-              <AsyncText text="A" />
-            </Suspense>
-          </Cache>
-        </>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(<App showMore={false} />);
-    });
-
-    // Even though there are two new <Cache /> trees, they should share the same
-    // data cache. So there should be only a single cache miss for A.
-    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A', 'A']);
-    expect(root).toMatchRenderedOutput('AA');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // no cleanup: cache is still retained at the root
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {
-    function App({showMore}) {
-      return showMore ? (
-        <>
-          <Cache>
-            <Suspense fallback={<Text text="Loading..." />}>
-              <AsyncText text="A" />
-            </Suspense>
-          </Cache>
-          <Cache>
-            <Suspense fallback={<Text text="Loading..." />}>
-              <AsyncText text="A" />
-            </Suspense>
-          </Cache>
-        </>
-      ) : (
-        '(empty)'
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(<App showMore={false} />);
-    });
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('(empty)');
-
-    await act(() => {
-      root.render(<App showMore={true} />);
-    });
-    // Even though there are two new <Cache /> trees, they should share the same
-    // data cache. So there should be only a single cache miss for A.
-    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A', 'A']);
-    expect(root).toMatchRenderedOutput('AA');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // cleanup occurs for the cache shared by the inner cache boundaries (which
-    // are not shared w the root because they were added in an update)
-    // note that no cache is created for the root since the cache is never accessed
-    assertLog(['Cache cleanup: A [v1]']);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test(
-    'nested cache boundaries share the same cache as the root during ' +
-      'the initial render',
-    async () => {
-      function App() {
-        return (
-          <Suspense fallback={<Text text="Loading..." />}>
-            <AsyncText text="A" />
-            <Cache>
-              <AsyncText text="A" />
-            </Cache>
-          </Suspense>
-        );
-      }
-
-      const root = ReactNoop.createRoot();
-      await act(() => {
-        root.render(<App />);
-      });
-      // Even though there is a nested <Cache /> boundary, it should share the same
-      // data cache as the root. So there should be only a single cache miss for A.
-      assertLog(['Cache miss! [A]', 'Loading...']);
-      expect(root).toMatchRenderedOutput('Loading...');
-
-      await act(() => {
-        resolveMostRecentTextCache('A');
-      });
-      assertLog(['A', 'A']);
-      expect(root).toMatchRenderedOutput('AA');
-
-      await act(() => {
-        root.render('Bye');
-      });
-      // no cleanup: cache is still retained at the root
-      assertLog([]);
-      expect(root).toMatchRenderedOutput('Bye');
-    },
-  );
-
-  // @gate enableCacheElement && enableCache
-  test('new content inside an existing Cache boundary should re-use already cached data', async () => {
-    function App({showMore}) {
-      return (
-        <Cache>
-          <Suspense fallback={<Text text="Loading..." />}>
-            <AsyncText showVersion={true} text="A" />
-          </Suspense>
-          {showMore ? (
-            <Suspense fallback={<Text text="Loading..." />}>
-              <AsyncText showVersion={true} text="A" />
-            </Suspense>
-          ) : null}
-        </Cache>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      seedNextTextCache('A');
-      root.render(<App showMore={false} />);
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Add a new cache boundary
-    await act(() => {
-      root.render(<App showMore={true} />);
-    });
-    assertLog([
-      'A [v1]',
-      // New tree should use already cached data
-      'A [v1]',
-    ]);
-    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // no cleanup: cache is still retained at the root
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('a new Cache boundary uses fresh cache', async () => {
-    // The only difference from the previous test is that the "Show More"
-    // content is wrapped in a nested <Cache /> boundary
-    function App({showMore}) {
-      return (
-        <Cache>
-          <Suspense fallback={<Text text="Loading..." />}>
-            <AsyncText showVersion={true} text="A" />
-          </Suspense>
-          {showMore ? (
-            <Cache>
-              <Suspense fallback={<Text text="Loading..." />}>
-                <AsyncText showVersion={true} text="A" />
-              </Suspense>
-            </Cache>
-          ) : null}
-        </Cache>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      seedNextTextCache('A');
-      root.render(<App showMore={false} />);
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Add a new cache boundary
-    await act(() => {
-      root.render(<App showMore={true} />);
-    });
-    assertLog([
-      'A [v1]',
-      // New tree should load fresh data.
-      'Cache miss! [A]',
-      'Loading...',
-    ]);
-    expect(root).toMatchRenderedOutput('A [v1]Loading...');
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v2]']);
-    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
-
-    // Replace all the children: this should retain the root Cache instance,
-    // but cleanup the separate cache instance created for the fresh cache
-    // boundary
-    await act(() => {
-      root.render('Bye!');
-    });
-    // Cleanup occurs for the *second* cache instance: the first is still
-    // referenced by the root
-    assertLog(['Cache cleanup: A [v2]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('inner/outer cache boundaries uses the same cache instance on initial render', async () => {
-    const root = ReactNoop.createRoot();
-
-    function App() {
-      return (
-        <Cache>
-          <Suspense fallback={<Text text="Loading shell..." />}>
-            {/* The shell reads A */}
-            <Shell>
-              {/* The inner content reads both A and B */}
-              <Suspense fallback={<Text text="Loading content..." />}>
-                <Cache>
-                  <Content />
-                </Cache>
-              </Suspense>
-            </Shell>
-          </Suspense>
-        </Cache>
-      );
-    }
-
-    function Shell({children}) {
-      readText('A');
-      return (
-        <>
-          <div>
-            <Text text="Shell" />
-          </div>
-          <div>{children}</div>
-        </>
-      );
-    }
-
-    function Content() {
-      readText('A');
-      readText('B');
-      return <Text text="Content" />;
-    }
-
-    await act(() => {
-      root.render(<App />);
-    });
-    assertLog(['Cache miss! [A]', 'Loading shell...']);
-    expect(root).toMatchRenderedOutput('Loading shell...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog([
-      'Shell',
-      // There's a cache miss for B, because it hasn't been read yet. But not
-      // A, because it was cached when we rendered the shell.
-      'Cache miss! [B]',
-      'Loading content...',
-    ]);
-    expect(root).toMatchRenderedOutput(
-      <>
-        <div>Shell</div>
-        <div>Loading content...</div>
-      </>,
-    );
-
-    await act(() => {
-      resolveMostRecentTextCache('B');
-    });
-    assertLog(['Content']);
-    expect(root).toMatchRenderedOutput(
-      <>
-        <div>Shell</div>
-        <div>Content</div>
-      </>,
-    );
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // no cleanup: cache is still retained at the root
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('inner/ outer cache boundaries added in the same update use the same cache instance', async () => {
-    const root = ReactNoop.createRoot();
-
-    function App({showMore}) {
-      return showMore ? (
-        <Cache>
-          <Suspense fallback={<Text text="Loading shell..." />}>
-            {/* The shell reads A */}
-            <Shell>
-              {/* The inner content reads both A and B */}
-              <Suspense fallback={<Text text="Loading content..." />}>
-                <Cache>
-                  <Content />
-                </Cache>
-              </Suspense>
-            </Shell>
-          </Suspense>
-        </Cache>
-      ) : (
-        '(empty)'
-      );
-    }
-
-    function Shell({children}) {
-      readText('A');
-      return (
-        <>
-          <div>
-            <Text text="Shell" />
-          </div>
-          <div>{children}</div>
-        </>
-      );
-    }
-
-    function Content() {
-      readText('A');
-      readText('B');
-      return <Text text="Content" />;
-    }
-
-    await act(() => {
-      root.render(<App showMore={false} />);
-    });
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('(empty)');
-
-    await act(() => {
-      root.render(<App showMore={true} />);
-    });
-    assertLog(['Cache miss! [A]', 'Loading shell...']);
-    expect(root).toMatchRenderedOutput('Loading shell...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog([
-      'Shell',
-      // There's a cache miss for B, because it hasn't been read yet. But not
-      // A, because it was cached when we rendered the shell.
-      'Cache miss! [B]',
-      'Loading content...',
-    ]);
-    expect(root).toMatchRenderedOutput(
-      <>
-        <div>Shell</div>
-        <div>Loading content...</div>
-      </>,
-    );
-
-    await act(() => {
-      resolveMostRecentTextCache('B');
-    });
-    assertLog(['Content']);
-    expect(root).toMatchRenderedOutput(
-      <>
-        <div>Shell</div>
-        <div>Content</div>
-      </>,
-    );
-
-    await act(() => {
-      root.render('Bye');
-    });
-    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: B [v1]']);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCache
-  test('refresh a cache boundary', async () => {
-    let refresh;
-    function App() {
-      refresh = useCacheRefresh();
-      return <AsyncText showVersion={true} text="A" />;
-    }
-
-    // Mount initial data
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback={<Text text="Loading..." />}>
-          <App />
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Refresh for new data.
-    await act(() => {
-      startTransition(() => refresh());
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    // Note that the version has updated
-    if (getCacheSignal) {
-      assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
-    } else {
-      assertLog(['A [v2]']);
-    }
-    expect(root).toMatchRenderedOutput('A [v2]');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('refresh the root cache', async () => {
-    let refresh;
-    function App() {
-      refresh = useCacheRefresh();
-      return <AsyncText showVersion={true} text="A" />;
-    }
-
-    // Mount initial data
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback={<Text text="Loading..." />}>
-          <App />
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Refresh for new data.
-    await act(() => {
-      startTransition(() => refresh());
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    // Note that the version has updated, and the previous cache is cleared
-    assertLog(['A [v2]', 'Cache cleanup: A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v2]');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // the original root cache already cleaned up when the refresh completed
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('refresh the root cache without a transition', async () => {
-    let refresh;
-    function App() {
-      refresh = useCacheRefresh();
-      return <AsyncText showVersion={true} text="A" />;
-    }
-
-    // Mount initial data
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback={<Text text="Loading..." />}>
-          <App />
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Refresh for new data.
-    await act(() => {
-      refresh();
-    });
-    assertLog([
-      'Cache miss! [A]',
-      'Loading...',
-      // The v1 cache can be cleaned up since everything that references it has
-      // been replaced by a fallback. When the boundary switches back to visible
-      // it will use the v2 cache.
-      'Cache cleanup: A [v1]',
-    ]);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    // Note that the version has updated, and the previous cache is cleared
-    assertLog(['A [v2]']);
-    expect(root).toMatchRenderedOutput('A [v2]');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // the original root cache already cleaned up when the refresh completed
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('refresh a cache with seed data', async () => {
-    let refreshWithSeed;
-    function App() {
-      const refresh = useCacheRefresh();
-      const [seed, setSeed] = useState({fn: null});
-      if (seed.fn) {
-        seed.fn();
-        seed.fn = null;
-      }
-      refreshWithSeed = fn => {
-        setSeed({fn});
-        refresh();
-      };
-      return <AsyncText showVersion={true} text="A" />;
-    }
-
-    // Mount initial data
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Cache>
-          <Suspense fallback={<Text text="Loading..." />}>
-            <App />
-          </Suspense>
-        </Cache>,
-      );
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Refresh for new data.
-    await act(() => {
-      // Refresh the cache with seeded data, like you would receive from a
-      // server mutation.
-      // TODO: Seeding multiple typed textCaches. Should work by calling `refresh`
-      // multiple times with different key/value pairs
-      startTransition(() =>
-        refreshWithSeed(() => {
-          const textCache = getTextCache();
-          textCache.resolve('A');
-        }),
-      );
-    });
-    // The root should re-render without a cache miss.
-    // The cache is not cleared up yet, since it's still reference by the root
-    assertLog(['A [v2]']);
-    expect(root).toMatchRenderedOutput('A [v2]');
-
-    await act(() => {
-      root.render('Bye');
-    });
-    // the refreshed cache boundary is unmounted and cleans up
-    assertLog(['Cache cleanup: A [v2]']);
-    expect(root).toMatchRenderedOutput('Bye');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('refreshing a parent cache also refreshes its children', async () => {
-    let refreshShell;
-    function RefreshShell() {
-      refreshShell = useCacheRefresh();
-      return null;
-    }
-
-    function App({showMore}) {
-      return (
-        <Cache>
-          <RefreshShell />
-          <Suspense fallback={<Text text="Loading..." />}>
-            <AsyncText showVersion={true} text="A" />
-          </Suspense>
-          {showMore ? (
-            <Cache>
-              <Suspense fallback={<Text text="Loading..." />}>
-                <AsyncText showVersion={true} text="A" />
-              </Suspense>
-            </Cache>
-          ) : null}
-        </Cache>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      seedNextTextCache('A');
-      root.render(<App showMore={false} />);
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Add a new cache boundary
-    await act(() => {
-      seedNextTextCache('A');
-      root.render(<App showMore={true} />);
-    });
-    assertLog([
-      'A [v1]',
-      // New tree should load fresh data.
-      'A [v2]',
-    ]);
-    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
-
-    // Now refresh the shell. This should also cause the "Show More" contents to
-    // refresh, since its cache is nested inside the outer one.
-    await act(() => {
-      startTransition(() => refreshShell());
-    });
-    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
-    expect(root).toMatchRenderedOutput('A [v1]A [v2]');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog([
-      'A [v3]',
-      'A [v3]',
-      // once the refresh completes the inner showMore boundary frees its previous
-      // cache instance, since it is now using the refreshed parent instance.
-      'Cache cleanup: A [v2]',
-    ]);
-    expect(root).toMatchRenderedOutput('A [v3]A [v3]');
-
-    await act(() => {
-      root.render('Bye!');
-    });
-    // Unmounting children releases the refreshed cache instance only; the root
-    // still retains the original cache instance used for the first render
-    assertLog(['Cache cleanup: A [v3]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test(
-    'refreshing a cache boundary does not refresh the other boundaries ' +
-      'that mounted at the same time (i.e. the ones that share the same cache)',
-    async () => {
-      let refreshFirstBoundary;
-      function RefreshFirstBoundary() {
-        refreshFirstBoundary = useCacheRefresh();
-        return null;
-      }
-
-      function App({showMore}) {
-        return showMore ? (
-          <>
-            <Cache>
-              <Suspense fallback={<Text text="Loading..." />}>
-                <RefreshFirstBoundary />
-                <AsyncText showVersion={true} text="A" />
-              </Suspense>
-            </Cache>
-            <Cache>
-              <Suspense fallback={<Text text="Loading..." />}>
-                <AsyncText showVersion={true} text="A" />
-              </Suspense>
-            </Cache>
-          </>
-        ) : null;
-      }
-
-      // First mount the initial shell without the nested boundaries. This is
-      // necessary for this test because we want the two inner boundaries to be
-      // treated like sibling providers that happen to share an underlying
-      // cache, as opposed to consumers of the root-level cache.
-      const root = ReactNoop.createRoot();
-      await act(() => {
-        root.render(<App showMore={false} />);
-      });
-
-      // Now reveal the boundaries. In a real app  this would be a navigation.
-      await act(() => {
-        root.render(<App showMore={true} />);
-      });
-
-      // Even though there are two new <Cache /> trees, they should share the same
-      // data cache. So there should be only a single cache miss for A.
-      assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);
-      expect(root).toMatchRenderedOutput('Loading...Loading...');
-
-      await act(() => {
-        resolveMostRecentTextCache('A');
-      });
-      assertLog(['A [v1]', 'A [v1]']);
-      expect(root).toMatchRenderedOutput('A [v1]A [v1]');
-
-      // Refresh the first boundary. It should not refresh the second boundary,
-      // even though they previously shared the same underlying cache.
-      await act(async () => {
-        await refreshFirstBoundary();
-      });
-      assertLog(['Cache miss! [A]', 'Loading...']);
-
-      await act(() => {
-        resolveMostRecentTextCache('A');
-      });
-      assertLog(['A [v2]']);
-      expect(root).toMatchRenderedOutput('A [v2]A [v1]');
-
-      // Unmount children: this should clear *both* cache instances:
-      // the root doesn't have a cache instance (since it wasn't accessed
-      // during the initial render, and all subsequent cache accesses were within
-      // a fresh boundary). Therefore this causes cleanup for both the fresh cache
-      // instance in the refreshed first boundary and cleanup for the non-refreshed
-      // sibling boundary.
-      await act(() => {
-        root.render('Bye!');
-      });
-      assertLog(['Cache cleanup: A [v2]', 'Cache cleanup: A [v1]']);
-      expect(root).toMatchRenderedOutput('Bye!');
-    },
-  );
-
-  // @gate enableCacheElement && enableCache
-  test(
-    'mount a new Cache boundary in a sibling while simultaneously ' +
-      'resolving a Suspense boundary',
-    async () => {
-      function App({showMore}) {
-        return (
-          <>
-            {showMore ? (
-              <Suspense fallback={<Text text="Loading..." />}>
-                <Cache>
-                  <AsyncText showVersion={true} text="A" />
-                </Cache>
-              </Suspense>
-            ) : null}
-            <Suspense fallback={<Text text="Loading..." />}>
-              <Cache>
-                {' '}
-                <AsyncText showVersion={true} text="A" />{' '}
-                <AsyncText showVersion={true} text="B" />
-              </Cache>
-            </Suspense>
-          </>
-        );
-      }
-
-      const root = ReactNoop.createRoot();
-      await act(() => {
-        root.render(<App showMore={false} />);
-      });
-      assertLog(['Cache miss! [A]', 'Loading...']);
-      expect(root).toMatchRenderedOutput('Loading...');
-
-      await act(() => {
-        // This will resolve the content in the first cache
-        resolveMostRecentTextCache('A');
-        resolveMostRecentTextCache('B');
-        // And mount the second tree, which includes new content
-        root.render(<App showMore={true} />);
-      });
-      assertLog([
-        // The new tree should use a fresh cache
-        'Cache miss! [A]',
-        'Loading...',
-        // The other tree uses the cached responses. This demonstrates that the
-        // requests are not dropped.
-        'A [v1]',
-        'B [v1]',
-      ]);
-      expect(root).toMatchRenderedOutput('Loading... A [v1] B [v1]');
-
-      // Now resolve the second tree
-      await act(() => {
-        resolveMostRecentTextCache('A');
-      });
-      assertLog(['A [v2]']);
-      expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');
-
-      await act(() => {
-        root.render('Bye!');
-      });
-      // Unmounting children releases both cache boundaries, but the original
-      // cache instance (used by second boundary) is still referenced by the root.
-      // only the second cache instance is freed.
-      assertLog(['Cache cleanup: A [v2]']);
-      expect(root).toMatchRenderedOutput('Bye!');
-    },
-  );
-
-  // @gate enableCacheElement && enableCache
-  test('cache pool is cleared once transitions that depend on it commit their shell', async () => {
-    function Child({text}) {
-      return (
-        <Cache>
-          <AsyncText showVersion={true} text={text} />
-        </Cache>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,
-      );
-    });
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('(empty)');
-
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback={<Text text="Loading..." />}>
-            <Child text="A" />
-          </Suspense>,
-        );
-      });
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('(empty)');
-
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback={<Text text="Loading..." />}>
-            <Child text="A" />
-            <Child text="A" />
-          </Suspense>,
-        );
-      });
-    });
-    assertLog([
-      // No cache miss, because it uses the pooled cache
-      'Loading...',
-    ]);
-    expect(root).toMatchRenderedOutput('(empty)');
-
-    // Resolve the request
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]', 'A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
-
-    // Now do another transition
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback={<Text text="Loading..." />}>
-            <Child text="A" />
-            <Child text="A" />
-            <Child text="A" />
-          </Suspense>,
-        );
-      });
-    });
-    assertLog([
-      // First two children use the old cache because they already finished
-      'A [v1]',
-      'A [v1]',
-      // The new child uses a fresh cache
-      'Cache miss! [A]',
-      'Loading...',
-    ]);
-    expect(root).toMatchRenderedOutput('A [v1]A [v1]');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]', 'A [v1]', 'A [v2]']);
-    expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');
-
-    // Unmount children: the first text cache instance is created only after the root
-    // commits, so both fresh cache instances are released by their cache boundaries,
-    // cleaning up v1 (used for the first two children which render together) and
-    // v2 (used for the third boundary added later).
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: A [v2]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('cache pool is not cleared by arbitrary commits', async () => {
-    function App() {
-      return (
-        <>
-          <ShowMore />
-          <Unrelated />
-        </>
-      );
-    }
-
-    let showMore;
-    function ShowMore() {
-      const [shouldShow, _showMore] = useState(false);
-      showMore = () => _showMore(true);
-      return (
-        <>
-          <Suspense fallback={<Text text="Loading..." />}>
-            {shouldShow ? (
-              <Cache>
-                <AsyncText showVersion={true} text="A" />
-              </Cache>
-            ) : null}
-          </Suspense>
-        </>
-      );
-    }
-
-    let updateUnrelated;
-    function Unrelated() {
-      const [count, _updateUnrelated] = useState(0);
-      updateUnrelated = _updateUnrelated;
-      return <Text text={String(count)} />;
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(<App />);
-    });
-    assertLog(['0']);
-    expect(root).toMatchRenderedOutput('0');
-
-    await act(() => {
-      startTransition(() => {
-        showMore();
-      });
-    });
-    assertLog(['Cache miss! [A]', 'Loading...']);
-    expect(root).toMatchRenderedOutput('0');
-
-    await act(() => {
-      updateUnrelated(1);
-    });
-    assertLog([
-      '1',
-
-      // Happens to re-render the fallback. Doesn't need to, but not relevant
-      // to this test.
-      'Loading...',
-    ]);
-    expect(root).toMatchRenderedOutput('1');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]1');
-
-    // Unmount children: the first text cache instance is created only after initial
-    // render after calling showMore(). This instance is cleaned up when that boundary
-    // is unmounted. Bc root cache instance is never accessed, the inner cache
-    // boundary ends up at v1.
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog(['Cache cleanup: A [v1]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('cache boundary uses a fresh cache when its key changes', async () => {
-    const root = ReactNoop.createRoot();
-    seedNextTextCache('A');
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="A">
-            <AsyncText showVersion={true} text="A" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    seedNextTextCache('B');
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="B">
-            <AsyncText showVersion={true} text="B" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['B [v2]']);
-    expect(root).toMatchRenderedOutput('B [v2]');
-
-    // Unmount children: the fresh cache instance for B cleans up since the cache boundary
-    // is the only owner, while the original cache instance (for A) is still retained by
-    // the root.
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog(['Cache cleanup: B [v2]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('overlapping transitions after an initial mount use the same fresh cache', async () => {
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="A">
-            <AsyncText showVersion={true} text="A" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // After a mount, subsequent transitions use a fresh cache
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback="Loading...">
-            <Cache key="B">
-              <AsyncText showVersion={true} text="B" />
-            </Cache>
-          </Suspense>,
-        );
-      });
-    });
-    assertLog(['Cache miss! [B]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Update to a different text and with a different key for the cache
-    // boundary: this should still use the fresh cache instance created
-    // for the earlier transition
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback="Loading...">
-            <Cache key="C">
-              <AsyncText showVersion={true} text="C" />
-            </Cache>
-          </Suspense>,
-        );
-      });
-    });
-    assertLog(['Cache miss! [C]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      resolveMostRecentTextCache('C');
-    });
-    assertLog(['C [v2]']);
-    expect(root).toMatchRenderedOutput('C [v2]');
-
-    // Unmount children: the fresh cache used for the updates is freed, while the
-    // original cache (with A) is still retained at the root.
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('overlapping updates after an initial mount use the same fresh cache', async () => {
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="A">
-            <AsyncText showVersion={true} text="A" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [A]']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('A');
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // After a mount, subsequent updates use a fresh cache
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="B">
-            <AsyncText showVersion={true} text="B" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [B]']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    // A second update uses the same fresh cache: even though this is a new
-    // Cache boundary, the render uses the fresh cache from the pending update.
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="C">
-            <AsyncText showVersion={true} text="C" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['Cache miss! [C]']);
-    expect(root).toMatchRenderedOutput('Loading...');
-
-    await act(() => {
-      resolveMostRecentTextCache('C');
-    });
-    assertLog(['C [v2]']);
-    expect(root).toMatchRenderedOutput('C [v2]');
-
-    // Unmount children: the fresh cache used for the updates is freed, while the
-    // original cache (with A) is still retained at the root.
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test('cleans up cache only used in an aborted transition', async () => {
-    const root = ReactNoop.createRoot();
-    seedNextTextCache('A');
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache key="A">
-            <AsyncText showVersion={true} text="A" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Start a transition from A -> B..., which should create a fresh cache
-    // for the new cache boundary (bc of the different key)
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback="Loading...">
-            <Cache key="B">
-              <AsyncText showVersion={true} text="B" />
-            </Cache>
-          </Suspense>,
-        );
-      });
-    });
-    assertLog(['Cache miss! [B]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // ...but cancel by transitioning "back" to A (which we never really left)
-    await act(() => {
-      startTransition(() => {
-        root.render(
-          <Suspense fallback="Loading...">
-            <Cache key="A">
-              <AsyncText showVersion={true} text="A" />
-            </Cache>
-          </Suspense>,
-        );
-      });
-    });
-    assertLog(['A [v1]', 'Cache cleanup: B [v2]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Unmount children: ...
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog([]);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableCacheElement && enableCache
-  test.skip('if a root cache refresh never commits its fresh cache is released', async () => {
-    const root = ReactNoop.createRoot();
-    let refresh;
-    function Example({text}) {
-      refresh = useCacheRefresh();
-      return <AsyncText showVersion={true} text={text} />;
-    }
-    seedNextTextCache('A');
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Example text="A" />
-        </Suspense>,
-      );
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      startTransition(() => {
-        refresh();
-      });
-    });
-    assertLog(['Cache miss! [A]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog([
-      // TODO: the v1 cache should *not* be cleaned up, it is still retained by the root
-      // The following line is presently yielded but should not be:
-      // 'Cache cleanup: A [v1]',
 
-      // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh
-      // The following line is presently not yielded but should be:
-      'Cache cleanup: A [v2]',
-    ]);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
+    ReactNoopFlightServer = require('react-noop-renderer/flight-server');
+    ReactNoopFlightClient = require('react-noop-renderer/flight-client');
 
-  // @gate enableCacheElement && enableCache
-  test.skip('if a cache boundary refresh never commits its fresh cache is released', async () => {
-    const root = ReactNoop.createRoot();
-    let refresh;
-    function Example({text}) {
-      refresh = useCacheRefresh();
-      return <AsyncText showVersion={true} text={text} />;
-    }
-    seedNextTextCache('A');
-    await act(() => {
-      root.render(
-        <Suspense fallback="Loading...">
-          <Cache>
-            <Example text="A" />
-          </Cache>
-        </Suspense>,
-      );
-    });
-    assertLog(['A [v1]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    await act(() => {
-      startTransition(() => {
-        refresh();
-      });
-    });
-    assertLog(['Cache miss! [A]']);
-    expect(root).toMatchRenderedOutput('A [v1]');
-
-    // Unmount the boundary before the refresh can complete
-    await act(() => {
-      root.render('Bye!');
-    });
-    assertLog([
-      // TODO: the v2 cache *should* be cleaned up, it was created for the abandoned refresh
-      // The following line is presently not yielded but should be:
-      'Cache cleanup: A [v2]',
-    ]);
-    expect(root).toMatchRenderedOutput('Bye!');
-  });
-
-  // @gate enableActivity
-  // @gate enableCache
-  test('prerender a new cache boundary inside an Activity tree', async () => {
-    function App({prerenderMore}) {
-      return (
-        <Activity mode="hidden">
-          <div>
-            {prerenderMore ? (
-              <Cache>
-                <AsyncText text="More" />
-              </Cache>
-            ) : null}
-          </div>
-        </Activity>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await act(() => {
-      root.render(<App prerenderMore={false} />);
-    });
-    assertLog([]);
-    expect(root).toMatchRenderedOutput(<div hidden={true} />);
-
-    seedNextTextCache('More');
-    await act(() => {
-      root.render(<App prerenderMore={true} />);
-    });
-    assertLog(['More']);
-    expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);
+    cache = React.cache;
   });
 
   // @gate enableCache
   it('cache objects and primitive arguments and a mix of them', async () => {
-    const root = ReactNoop.createRoot();
     const types = cache((a, b) => ({a: typeof a, b: typeof b}));
     function Print({a, b}) {
       return types(a, b).a + ' ' + types(a, b).b + ' ';
@@ -1629,101 +47,128 @@ describe('ReactCache', () => {
     function MoreArgs({a, b}) {
       return (types(a) === types(a, b)).toString() + ' ';
     }
-    await act(() => {
-      root.render(
-        <>
-          <Print a="e" b="f" />
-          <Same a="a" b="b" />
-          <FlippedOrder a="c" b="d" />
-          <FewerArgs a="e" b="f" />
-          <MoreArgs a="g" b="h" />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('string string true false false false ');
-    await act(() => {
-      root.render(
-        <>
-          <Print a="e" b={null} />
-          <Same a="a" b={null} />
-          <FlippedOrder a="c" b={null} />
-          <FewerArgs a="e" b={null} />
-          <MoreArgs a="g" b={null} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('string object true false false false ');
+
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a="e" b="f" />
+              <Same a="a" b="b" />
+              <FlippedOrder a="c" b="d" />
+              <FewerArgs a="e" b="f" />
+              <MoreArgs a="g" b="h" />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('string string true false false false ');
+
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a="e" b={null} />
+              <Same a="a" b={null} />
+              <FlippedOrder a="c" b={null} />
+              <FewerArgs a="e" b={null} />
+              <MoreArgs a="g" b={null} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('string object true false false false ');
+
     const obj = {};
-    await act(() => {
-      root.render(
-        <>
-          <Print a="e" b={obj} />
-          <Same a="a" b={obj} />
-          <FlippedOrder a="c" b={obj} />
-          <FewerArgs a="e" b={obj} />
-          <MoreArgs a="g" b={obj} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('string object true false false false ');
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a="e" b={obj} />
+              <Same a="a" b={obj} />
+              <FlippedOrder a="c" b={obj} />
+              <FewerArgs a="e" b={obj} />
+              <MoreArgs a="g" b={obj} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('string object true false false false ');
+
     const sameObj = {};
-    await act(() => {
-      root.render(
-        <>
-          <Print a={sameObj} b={sameObj} />
-          <Same a={sameObj} b={sameObj} />
-          <FlippedOrder a={sameObj} b={sameObj} />
-          <FewerArgs a={sameObj} b={sameObj} />
-          <MoreArgs a={sameObj} b={sameObj} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('object object true true false false ');
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a={sameObj} b={sameObj} />
+              <Same a={sameObj} b={sameObj} />
+              <FlippedOrder a={sameObj} b={sameObj} />
+              <FewerArgs a={sameObj} b={sameObj} />
+              <MoreArgs a={sameObj} b={sameObj} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('object object true true false false ');
+
     const objA = {};
     const objB = {};
-    await act(() => {
-      root.render(
-        <>
-          <Print a={objA} b={objB} />
-          <Same a={objA} b={objB} />
-          <FlippedOrder a={objA} b={objB} />
-          <FewerArgs a={objA} b={objB} />
-          <MoreArgs a={objA} b={objB} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('object object true false false false ');
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a={objA} b={objB} />
+              <Same a={objA} b={objB} />
+              <FlippedOrder a={objA} b={objB} />
+              <FewerArgs a={objA} b={objB} />
+              <MoreArgs a={objA} b={objB} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('object object true false false false ');
+
     const sameSymbol = Symbol();
-    await act(() => {
-      root.render(
-        <>
-          <Print a={sameSymbol} b={sameSymbol} />
-          <Same a={sameSymbol} b={sameSymbol} />
-          <FlippedOrder a={sameSymbol} b={sameSymbol} />
-          <FewerArgs a={sameSymbol} b={sameSymbol} />
-          <MoreArgs a={sameSymbol} b={sameSymbol} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('symbol symbol true true false false ');
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a={sameSymbol} b={sameSymbol} />
+              <Same a={sameSymbol} b={sameSymbol} />
+              <FlippedOrder a={sameSymbol} b={sameSymbol} />
+              <FewerArgs a={sameSymbol} b={sameSymbol} />
+              <MoreArgs a={sameSymbol} b={sameSymbol} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('symbol symbol true true false false ');
+
     const notANumber = +'nan';
-    await act(() => {
-      root.render(
-        <>
-          <Print a={1} b={notANumber} />
-          <Same a={1} b={notANumber} />
-          <FlippedOrder a={1} b={notANumber} />
-          <FewerArgs a={1} b={notANumber} />
-          <MoreArgs a={1} b={notANumber} />
-        </>,
-      );
-    });
-    expect(root).toMatchRenderedOutput('number number true false false false ');
+    expect(
+      (
+        await ReactNoopFlightClient.read(
+          ReactNoopFlightServer.render(
+            <>
+              <Print a={1} b={notANumber} />
+              <Same a={1} b={notANumber} />
+              <FlippedOrder a={1} b={notANumber} />
+              <FewerArgs a={1} b={notANumber} />
+              <MoreArgs a={1} b={notANumber} />
+            </>,
+          ),
+        )
+      ).join(''),
+    ).toEqual('number number true false false false ');
   });
 
   // @gate enableCache
   it('cached functions that throw should cache the error', async () => {
-    const root = ReactNoop.createRoot();
     const throws = cache(v => {
       throw new Error(v);
     });
@@ -1749,10 +194,30 @@ describe('ReactCache', () => {
 
       return 'Blank';
     }
-    await act(() => {
-      root.render(<Test />);
-    });
+
+    ReactNoopFlightServer.render(<Test />);
     expect(x).toBe(y);
     expect(z).not.toBe(x);
   });
+
+  // @gate enableCache
+  it('introspection of returned wrapper function is same on client and server', async () => {
+    // When the variant flag is true, test the client version of `cache`.
+    if (gate(flags => flags.variant)) {
+      jest.resetModules();
+      jest.mock('react', () => jest.requireActual('react'));
+      const ClientReact = require('react');
+      cache = ClientReact.cache;
+    }
+
+    function foo(a, b, c) {
+      return a + b + c;
+    }
+    foo.displayName = 'Custom display name';
+
+    const cachedFoo = cache(foo);
+    expect(cachedFoo).not.toBe(foo);
+    expect(cachedFoo.length).toBe(0);
+    expect(cachedFoo.displayName).toBe(undefined);
+  });
 });

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index b32479b70b..7caf1e7e96 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -17,7 +17,6 @@ let cache;
 
 describe('ReactCache', () => {
   beforeEach(() => {
-    jest.resetModules();
     jest.mock('react', () => require('react/react.react-server'));
     React = require('react');
 
@@ -204,7 +203,6 @@ describe('ReactCache', () => {
   it('introspection of returned wrapper function is same on client and server', async () => {
     // When the variant flag is true, test the client version of `cache`.
     if (gate(flags => flags.variant)) {
-      jest.resetModules();
       jest.mock('react', () => jest.requireActual('react'));
       const ClientReact = require('react');
       cache = ClientReact.cache;

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 7caf1e7e96..b32479b70b 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -17,6 +17,7 @@ let cache;
 
 describe('ReactCache', () => {
   beforeEach(() => {
+    jest.resetModules();
     jest.mock('react', () => require('react/react.react-server'));
     React = require('react');
 
@@ -203,6 +204,7 @@ describe('ReactCache', () => {
   it('introspection of returned wrapper function is same on client and server', async () => {
     // When the variant flag is true, test the client version of `cache`.
     if (gate(flags => flags.variant)) {
+      jest.resetModules();
       jest.mock('react', () => jest.requireActual('react'));
       const ClientReact = require('react');
       cache = ClientReact.cache;

commit c771016e19384e4b6e42e1c275bdf03fe51c2907
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Mon Apr 8 22:34:59 2024 -0400

    Rename The Secret Export of Server Internals (#28786)
    
    We have a different set of dispatchers that Flight uses. This also
    includes the `jsx-runtime` which must also be aliased to use the right
    version.
    
    To ensure the right versions are used together we rename the export of
    the SharedInternals from 'react' and alias it in relevant bundles.

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index b32479b70b..7fd43b0b36 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -25,6 +25,9 @@ describe('ReactCache', () => {
     ReactNoopFlightClient = require('react-noop-renderer/flight-client');
 
     cache = React.cache;
+
+    jest.resetModules();
+    __unmockReact();
   });
 
   // @gate enableCache

commit e06c72fcf4632ad3117add713a25f6354631f037
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Dec 15 12:34:08 2024 -0500

    [flags] Cleanup enableCache (#31778)
    
    This is landed everywhere

diff --git a/packages/react-reconciler/src/__tests__/ReactCache-test.js b/packages/react-reconciler/src/__tests__/ReactCache-test.js
index 7fd43b0b36..e93b68cec3 100644
--- a/packages/react-reconciler/src/__tests__/ReactCache-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactCache-test.js
@@ -30,7 +30,6 @@ describe('ReactCache', () => {
     __unmockReact();
   });
 
-  // @gate enableCache
   it('cache objects and primitive arguments and a mix of them', async () => {
     const types = cache((a, b) => ({a: typeof a, b: typeof b}));
     function Print({a, b}) {
@@ -170,7 +169,6 @@ describe('ReactCache', () => {
     ).toEqual('number number true false false false ');
   });
 
-  // @gate enableCache
   it('cached functions that throw should cache the error', async () => {
     const throws = cache(v => {
       throw new Error(v);
@@ -203,7 +201,6 @@ describe('ReactCache', () => {
     expect(z).not.toBe(x);
   });
 
-  // @gate enableCache
   it('introspection of returned wrapper function is same on client and server', async () => {
     // When the variant flag is true, test the client version of `cache`.
     if (gate(flags => flags.variant)) {

