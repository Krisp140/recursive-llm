# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/termio/Termio.zig

commit c4484938c565030bd10b10a77a8e80602e3001ca
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 10:35:46 2024 -0700

    termio: wip but it builds

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
new file mode 100644
index 00000000..51a6b03c
--- /dev/null
+++ b/src/termio/Termio.zig
@@ -0,0 +1,2987 @@
+//! Primary terminal IO ("termio") state. This maintains the terminal state,
+//! pty, subprocess, etc. This is flexible enough to be used in environments
+//! that don't have a pty and simply provides the input/output using raw
+//! bytes.
+pub const Termio = @This();
+
+const std = @import("std");
+const builtin = @import("builtin");
+const build_config = @import("../build_config.zig");
+const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
+const ArenaAllocator = std.heap.ArenaAllocator;
+const EnvMap = std.process.EnvMap;
+const posix = std.posix;
+const termio = @import("../termio.zig");
+const Command = @import("../Command.zig");
+const Pty = @import("../pty.zig").Pty;
+const SegmentedPool = @import("../segmented_pool.zig").SegmentedPool;
+const terminal = @import("../terminal/main.zig");
+const terminfo = @import("../terminfo/main.zig");
+const xev = @import("xev");
+const renderer = @import("../renderer.zig");
+const apprt = @import("../apprt.zig");
+const fastmem = @import("../fastmem.zig");
+const internal_os = @import("../os/main.zig");
+const windows = internal_os.windows;
+const configpkg = @import("../config.zig");
+const shell_integration = @import("shell_integration.zig");
+
+const log = std.log.scoped(.io_exec);
+
+const c = @cImport({
+    @cInclude("errno.h");
+    @cInclude("signal.h");
+    @cInclude("unistd.h");
+});
+
+/// True if we should disable the kitty keyboard protocol. We have to
+/// disable this on GLFW because GLFW input events don't support the
+/// correct granularity of events.
+const disable_kitty_keyboard_protocol = apprt.runtime == apprt.glfw;
+
+/// Allocator
+alloc: Allocator,
+
+/// This is the pty fd created for the subcommand.
+subprocess: Subprocess,
+
+/// The derived configuration for this termio implementation.
+config: DerivedConfig,
+
+/// The terminal emulator internal state. This is the abstract "terminal"
+/// that manages input, grid updating, etc. and is renderer-agnostic. It
+/// just stores internal state about a grid.
+terminal: terminal.Terminal,
+
+/// The shared render state
+renderer_state: *renderer.State,
+
+/// A handle to wake up the renderer. This hints to the renderer that that
+/// a repaint should happen.
+renderer_wakeup: xev.Async,
+
+/// The mailbox for notifying the renderer of things.
+renderer_mailbox: *renderer.Thread.Mailbox,
+
+/// The mailbox for communicating with the surface.
+surface_mailbox: apprt.surface.Mailbox,
+
+/// The cached grid size whenever a resize is called.
+grid_size: renderer.GridSize,
+
+/// The data associated with the currently running thread.
+data: ?*EventData,
+
+/// The configuration for this IO that is derived from the main
+/// configuration. This must be exported so that we don't need to
+/// pass around Config pointers which makes memory management a pain.
+pub const DerivedConfig = struct {
+    arena: ArenaAllocator,
+
+    palette: terminal.color.Palette,
+    image_storage_limit: usize,
+    cursor_style: terminal.CursorStyle,
+    cursor_blink: ?bool,
+    cursor_color: ?configpkg.Config.Color,
+    foreground: configpkg.Config.Color,
+    background: configpkg.Config.Color,
+    osc_color_report_format: configpkg.Config.OSCColorReportFormat,
+    term: []const u8,
+    grapheme_width_method: configpkg.Config.GraphemeWidthMethod,
+    abnormal_runtime_threshold_ms: u32,
+    wait_after_command: bool,
+    enquiry_response: []const u8,
+
+    pub fn init(
+        alloc_gpa: Allocator,
+        config: *const configpkg.Config,
+    ) !DerivedConfig {
+        var arena = ArenaAllocator.init(alloc_gpa);
+        errdefer arena.deinit();
+        const alloc = arena.allocator();
+
+        return .{
+            .palette = config.palette.value,
+            .image_storage_limit = config.@"image-storage-limit",
+            .cursor_style = config.@"cursor-style",
+            .cursor_blink = config.@"cursor-style-blink",
+            .cursor_color = config.@"cursor-color",
+            .foreground = config.foreground,
+            .background = config.background,
+            .osc_color_report_format = config.@"osc-color-report-format",
+            .term = try alloc.dupe(u8, config.term),
+            .grapheme_width_method = config.@"grapheme-width-method",
+            .abnormal_runtime_threshold_ms = config.@"abnormal-command-exit-runtime",
+            .wait_after_command = config.@"wait-after-command",
+            .enquiry_response = try alloc.dupe(u8, config.@"enquiry-response"),
+
+            // This has to be last so that we copy AFTER the arena allocations
+            // above happen (Zig assigns in order).
+            .arena = arena,
+        };
+    }
+
+    pub fn deinit(self: *DerivedConfig) void {
+        self.arena.deinit();
+    }
+};
+
+/// Initialize the termio state.
+///
+/// This will also start the child process if the termio is configured
+/// to run a child process.
+pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
+    // Create our terminal
+    var term = try terminal.Terminal.init(alloc, .{
+        .cols = opts.grid_size.columns,
+        .rows = opts.grid_size.rows,
+        .max_scrollback = opts.full_config.@"scrollback-limit",
+    });
+    errdefer term.deinit(alloc);
+    term.default_palette = opts.config.palette;
+    term.color_palette.colors = opts.config.palette;
+
+    // Setup our initial grapheme cluster support if enabled. We use a
+    // switch to ensure we get a compiler error if more cases are added.
+    switch (opts.config.grapheme_width_method) {
+        .unicode => term.modes.set(.grapheme_cluster, true),
+        .legacy => {},
+    }
+
+    // Set the image size limits
+    try term.screen.kitty_images.setLimit(
+        alloc,
+        &term.screen,
+        opts.config.image_storage_limit,
+    );
+    try term.secondary_screen.kitty_images.setLimit(
+        alloc,
+        &term.secondary_screen,
+        opts.config.image_storage_limit,
+    );
+
+    // Set default cursor blink settings
+    term.modes.set(
+        .cursor_blinking,
+        opts.config.cursor_blink orelse true,
+    );
+
+    // Set our default cursor style
+    term.screen.cursor.cursor_style = opts.config.cursor_style;
+
+    var subprocess = try Subprocess.init(alloc, opts);
+    errdefer subprocess.deinit();
+
+    // If we have an initial pwd requested by the subprocess, then we
+    // set that on the terminal now. This allows rapidly initializing
+    // new surfaces to use the proper pwd.
+    if (subprocess.cwd) |cwd| term.setPwd(cwd) catch |err| {
+        log.warn("error setting initial pwd err={}", .{err});
+    };
+
+    // Initial width/height based on subprocess
+    term.width_px = subprocess.screen_size.width;
+    term.height_px = subprocess.screen_size.height;
+
+    return .{
+        .alloc = alloc,
+        .terminal = term,
+        .subprocess = subprocess,
+        .config = opts.config,
+        .renderer_state = opts.renderer_state,
+        .renderer_wakeup = opts.renderer_wakeup,
+        .renderer_mailbox = opts.renderer_mailbox,
+        .surface_mailbox = opts.surface_mailbox,
+        .grid_size = opts.grid_size,
+        .data = null,
+    };
+}
+
+pub fn deinit(self: *Termio) void {
+    self.subprocess.deinit();
+    self.terminal.deinit(self.alloc);
+    self.config.deinit();
+}
+
+pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
+    assert(self.data == null);
+    const alloc = self.alloc;
+
+    // Start our subprocess
+    const pty_fds = self.subprocess.start(alloc) catch |err| {
+        // If we specifically got this error then we are in the forked
+        // process and our child failed to execute. In that case
+        if (err != error.Termio) return err;
+
+        // Output an error message about the exec faililng and exit.
+        // This generally should NOT happen because we always wrap
+        // our command execution either in login (macOS) or /bin/sh
+        // (Linux) which are usually guaranteed to exist. Still, we
+        // want to handle this scenario.
+        self.execFailedInChild() catch {};
+        posix.exit(1);
+    };
+    errdefer self.subprocess.stop();
+    const pid = pid: {
+        const command = self.subprocess.command orelse return error.ProcessNotStarted;
+        break :pid command.pid orelse return error.ProcessNoPid;
+    };
+
+    // Track our process start time so we know how long it was
+    // running for.
+    const process_start = try std.time.Instant.now();
+
+    // Create our pipe that we'll use to kill our read thread.
+    // pipe[0] is the read end, pipe[1] is the write end.
+    const pipe = try internal_os.pipe();
+    errdefer posix.close(pipe[0]);
+    errdefer posix.close(pipe[1]);
+
+    // Setup our data that is used for callbacks
+    var ev_data_ptr = try alloc.create(EventData);
+    errdefer alloc.destroy(ev_data_ptr);
+
+    // Setup our stream so that we can write.
+    var stream = xev.Stream.initFd(pty_fds.write);
+    errdefer stream.deinit();
+
+    // Wakeup watcher for the writer thread.
+    var wakeup = try xev.Async.init();
+    errdefer wakeup.deinit();
+
+    // Watcher to detect subprocess exit
+    var process = try xev.Process.init(pid);
+    errdefer process.deinit();
+
+    // Setup our event data before we start
+    ev_data_ptr.* = .{
+        .writer_mailbox = thread.mailbox,
+        .writer_wakeup = thread.wakeup,
+        .surface_mailbox = self.surface_mailbox,
+        .renderer_state = self.renderer_state,
+        .renderer_wakeup = self.renderer_wakeup,
+        .renderer_mailbox = self.renderer_mailbox,
+        .process = process,
+        .data_stream = stream,
+        .loop = &thread.loop,
+        .terminal_stream = .{
+            .handler = StreamHandler.init(
+                self.alloc,
+                ev_data_ptr,
+                &self.grid_size,
+                &self.terminal,
+                &self.config,
+            ),
+            .parser = .{
+                .osc_parser = .{
+                    // Populate the OSC parser allocator (optional) because
+                    // we want to support large OSC payloads such as OSC 52.
+                    .alloc = self.alloc,
+                },
+            },
+        },
+    };
+    errdefer ev_data_ptr.deinit(self.alloc);
+
+    // Store our data so our callbacks can access it
+    self.data = ev_data_ptr;
+    errdefer self.data = null;
+
+    // Start our process watcher
+    process.wait(
+        ev_data_ptr.loop,
+        &ev_data_ptr.process_wait_c,
+        ThreadData,
+        data,
+        processExit,
+    );
+
+    // Start our reader thread
+    const read_thread = try std.Thread.spawn(
+        .{},
+        if (builtin.os.tag == .windows) ReadThread.threadMainWindows else ReadThread.threadMainPosix,
+        .{ pty_fds.read, ev_data_ptr, pipe[0] },
+    );
+    read_thread.setName("io-reader") catch {};
+
+    // Return our thread data
+    data.* = .{
+        .alloc = alloc,
+        .ev = ev_data_ptr,
+        .reader = .{ .exec = .{
+            .start = process_start,
+            .abnormal_runtime_threshold_ms = self.config.abnormal_runtime_threshold_ms,
+            .wait_after_command = self.config.wait_after_command,
+        } },
+        .read_thread = read_thread,
+        .read_thread_pipe = pipe[1],
+        .read_thread_fd = if (builtin.os.tag == .windows) pty_fds.read else {},
+    };
+}
+
+/// This outputs an error message when exec failed and we are the
+/// child process. This returns so the caller should probably exit
+/// after calling this.
+///
+/// Note that this usually is only called under very very rare
+/// circumstances because we wrap our command execution in login
+/// (macOS) or /bin/sh (Linux). So this output can be pretty crude
+/// because it should never happen. Notably, this is not the error
+/// users see when `command` is invalid.
+fn execFailedInChild(self: *Termio) !void {
+    _ = self;
+    const stderr = std.io.getStdErr().writer();
+    try stderr.writeAll("exec failed\n");
+    try stderr.writeAll("press any key to exit\n");
+
+    var buf: [1]u8 = undefined;
+    var reader = std.io.getStdIn().reader();
+    _ = try reader.read(&buf);
+}
+
+pub fn threadExit(self: *Termio, data: *ThreadData) void {
+    // Clear out our data since we're not active anymore.
+    self.data = null;
+
+    // Stop our reader
+    switch (data.reader) {
+        .manual => {},
+
+        .exec => |exec| {
+            if (exec.exited) self.subprocess.externalExit();
+            self.subprocess.stop();
+
+            // Quit our read thread after exiting the subprocess so that
+            // we don't get stuck waiting for data to stop flowing if it is
+            // a particularly noisy process.
+            _ = posix.write(data.read_thread_pipe, "x") catch |err|
+                log.warn("error writing to read thread quit pipe err={}", .{err});
+
+            if (comptime builtin.os.tag == .windows) {
+                // Interrupt the blocking read so the thread can see the quit message
+                if (windows.kernel32.CancelIoEx(data.read_thread_fd, null) == 0) {
+                    switch (windows.kernel32.GetLastError()) {
+                        .NOT_FOUND => {},
+                        else => |err| log.warn("error interrupting read thread err={}", .{err}),
+                    }
+                }
+            }
+
+            data.read_thread.join();
+        },
+    }
+}
+
+/// Update the configuration.
+pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !void {
+    // The remainder of this function is modifying terminal state or
+    // the read thread data, all of which requires holding the renderer
+    // state lock.
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+
+    // Deinit our old config. We do this in the lock because the
+    // stream handler may be referencing the old config (i.e. enquiry resp)
+    self.config.deinit();
+    self.config = config.*;
+
+    // Update our stream handler. The stream handler uses the same
+    // renderer mutex so this is safe to do despite being executed
+    // from another thread.
+    td.ev.terminal_stream.handler.changeConfig(&self.config);
+    switch (td.reader) {
+        .manual => {},
+        .exec => |*exec| {
+            exec.abnormal_runtime_threshold_ms = config.abnormal_runtime_threshold_ms;
+            exec.wait_after_command = config.wait_after_command;
+        },
+    }
+
+    // Update the configuration that we know about.
+    //
+    // Specific things we don't update:
+    //   - command, working-directory: we never restart the underlying
+    //   process so we don't care or need to know about these.
+
+    // Update the default palette. Note this will only apply to new colors drawn
+    // since we decode all palette colors to RGB on usage.
+    self.terminal.default_palette = config.palette;
+
+    // Update the active palette, except for any colors that were modified with
+    // OSC 4
+    for (0..config.palette.len) |i| {
+        if (!self.terminal.color_palette.mask.isSet(i)) {
+            self.terminal.color_palette.colors[i] = config.palette[i];
+            self.terminal.flags.dirty.palette = true;
+        }
+    }
+
+    // Set the image size limits
+    try self.terminal.screen.kitty_images.setLimit(
+        self.alloc,
+        &self.terminal.screen,
+        config.image_storage_limit,
+    );
+    try self.terminal.secondary_screen.kitty_images.setLimit(
+        self.alloc,
+        &self.terminal.secondary_screen,
+        config.image_storage_limit,
+    );
+}
+
+/// Resize the terminal.
+pub fn resize(
+    self: *Termio,
+    grid_size: renderer.GridSize,
+    screen_size: renderer.ScreenSize,
+    padding: renderer.Padding,
+) !void {
+    // Update the size of our pty.
+    const padded_size = screen_size.subPadding(padding);
+    try self.subprocess.resize(grid_size, padded_size);
+
+    // Update our cached grid size
+    self.grid_size = grid_size;
+
+    // Enter the critical area that we want to keep small
+    {
+        self.renderer_state.mutex.lock();
+        defer self.renderer_state.mutex.unlock();
+
+        // Update the size of our terminal state
+        try self.terminal.resize(
+            self.alloc,
+            grid_size.columns,
+            grid_size.rows,
+        );
+
+        // Update our pixel sizes
+        self.terminal.width_px = padded_size.width;
+        self.terminal.height_px = padded_size.height;
+
+        // Disable synchronized output mode so that we show changes
+        // immediately for a resize. This is allowed by the spec.
+        self.terminal.modes.set(.synchronized_output, false);
+
+        // Wake up our renderer so any changes will be shown asap
+        self.renderer_wakeup.notify() catch {};
+    }
+}
+
+/// Reset the synchronized output mode. This is usually called by timer
+/// expiration from the termio thread.
+pub fn resetSynchronizedOutput(self: *Termio) void {
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    self.terminal.modes.set(.synchronized_output, false);
+    self.renderer_wakeup.notify() catch {};
+}
+
+/// Clear the screen.
+pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
+    {
+        self.renderer_state.mutex.lock();
+        defer self.renderer_state.mutex.unlock();
+
+        // If we're on the alternate screen, we do not clear. Since this is an
+        // emulator-level screen clear, this messes up the running programs
+        // knowledge of where the cursor is and causes rendering issues. So,
+        // for alt screen, we do nothing.
+        if (self.terminal.active_screen == .alternate) return;
+
+        // Clear our scrollback
+        if (history) self.terminal.eraseDisplay(.scrollback, false);
+
+        // If we're not at a prompt, we just delete above the cursor.
+        if (!self.terminal.cursorIsAtPrompt()) {
+            if (self.terminal.screen.cursor.y > 0) {
+                self.terminal.screen.eraseRows(
+                    .{ .active = .{ .y = 0 } },
+                    .{ .active = .{ .y = self.terminal.screen.cursor.y - 1 } },
+                );
+            }
+
+            return;
+        }
+
+        // At a prompt, we want to first fully clear the screen, and then after
+        // send a FF (0x0C) to the shell so that it can repaint the screen.
+        // Mark the current row as a not a prompt so we can properly
+        // clear the full screen in the next eraseDisplay call.
+        self.terminal.markSemanticPrompt(.command);
+        assert(!self.terminal.cursorIsAtPrompt());
+        self.terminal.eraseDisplay(.complete, false);
+    }
+
+    // If we reached here it means we're at a prompt, so we send a form-feed.
+    try self.queueWrite(td, &[_]u8{0x0C}, false);
+}
+
+/// Scroll the viewport
+pub fn scrollViewport(self: *Termio, scroll: terminal.Terminal.ScrollViewport) !void {
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    try self.terminal.scrollViewport(scroll);
+}
+
+/// Jump the viewport to the prompt.
+pub fn jumpToPrompt(self: *Termio, delta: isize) !void {
+    {
+        self.renderer_state.mutex.lock();
+        defer self.renderer_state.mutex.unlock();
+        self.terminal.screen.scroll(.{ .delta_prompt = delta });
+    }
+
+    try self.renderer_wakeup.notify();
+}
+
+/// Called when the child process exited abnormally but before
+/// the surface is notified.
+pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !void {
+    var arena = ArenaAllocator.init(self.alloc);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    // Build up our command for the error message
+    const command = try std.mem.join(alloc, " ", self.subprocess.args);
+    const runtime_str = try std.fmt.allocPrint(alloc, "{d} ms", .{runtime_ms});
+
+    // Modify the terminal to show our error message. This
+    // requires grabbing the renderer state lock.
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    const t = self.renderer_state.terminal;
+
+    // No matter what move the cursor back to the column 0.
+    t.carriageReturn();
+
+    // Reset styles
+    try t.setAttribute(.{ .unset = {} });
+
+    // If there is data in the viewport, we want to scroll down
+    // a little bit and write a horizontal rule before writing
+    // our message. This lets the use see the error message the
+    // command may have output.
+    const viewport_str = try t.plainString(alloc);
+    if (viewport_str.len > 0) {
+        try t.linefeed();
+        for (0..t.cols) |_| try t.print(0x2501);
+        t.carriageReturn();
+        try t.linefeed();
+        try t.linefeed();
+    }
+
+    // Output our error message
+    try t.setAttribute(.{ .@"8_fg" = .bright_red });
+    try t.setAttribute(.{ .bold = {} });
+    try t.printString("Ghostty failed to launch the requested command:");
+    try t.setAttribute(.{ .unset = {} });
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString(command);
+    try t.setAttribute(.{ .unset = {} });
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString("Runtime: ");
+    try t.setAttribute(.{ .@"8_fg" = .red });
+    try t.printString(runtime_str);
+    try t.setAttribute(.{ .unset = {} });
+
+    // We don't print this on macOS because the exit code is always 0
+    // due to the way we launch the process.
+    if (comptime !builtin.target.isDarwin()) {
+        const exit_code_str = try std.fmt.allocPrint(alloc, "{d}", .{exit_code});
+        t.carriageReturn();
+        try t.linefeed();
+        try t.printString("Exit Code: ");
+        try t.setAttribute(.{ .@"8_fg" = .red });
+        try t.printString(exit_code_str);
+        try t.setAttribute(.{ .unset = {} });
+    }
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString("Press any key to close the window.");
+
+    // Hide the cursor
+    t.modes.set(.cursor_visible, false);
+}
+
+pub inline fn queueWrite(
+    self: *Termio,
+    td: *ThreadData,
+    data: []const u8,
+    linefeed: bool,
+) !void {
+    const ev = td.ev;
+
+    // If our process is exited then we send our surface a message
+    // about it but we don't queue any more writes.
+    switch (td.reader) {
+        .manual => {},
+        .exec => |exec| {
+            if (exec.exited) {
+                _ = ev.surface_mailbox.push(.{
+                    .child_exited = {},
+                }, .{ .forever = {} });
+                return;
+            }
+        },
+    }
+
+    // We go through and chunk the data if necessary to fit into
+    // our cached buffers that we can queue to the stream.
+    var i: usize = 0;
+    while (i < data.len) {
+        const req = try ev.write_req_pool.getGrow(self.alloc);
+        const buf = try ev.write_buf_pool.getGrow(self.alloc);
+        const slice = slice: {
+            // The maximum end index is either the end of our data or
+            // the end of our buffer, whichever is smaller.
+            const max = @min(data.len, i + buf.len);
+
+            // Fast
+            if (!linefeed) {
+                fastmem.copy(u8, buf, data[i..max]);
+                const len = max - i;
+                i = max;
+                break :slice buf[0..len];
+            }
+
+            // Slow, have to replace \r with \r\n
+            var buf_i: usize = 0;
+            while (i < data.len and buf_i < buf.len - 1) {
+                const ch = data[i];
+                i += 1;
+
+                if (ch != '\r') {
+                    buf[buf_i] = ch;
+                    buf_i += 1;
+                    continue;
+                }
+
+                // CRLF
+                buf[buf_i] = '\r';
+                buf[buf_i + 1] = '\n';
+                buf_i += 2;
+            }
+
+            break :slice buf[0..buf_i];
+        };
+
+        //for (slice) |b| log.warn("write: {x}", .{b});
+
+        ev.data_stream.queueWrite(
+            ev.loop,
+            &ev.write_queue,
+            req,
+            .{ .slice = slice },
+            EventData,
+            ev,
+            ttyWrite,
+        );
+    }
+}
+
+fn readInternal(
+    ev: *EventData,
+    buf: []const u8,
+) void {
+    // log.info("DATA: {d}", .{n});
+    // log.info("DATA: {any}", .{buf[0..@intCast(usize, n)]});
+
+    // We are modifying terminal state from here on out
+    ev.renderer_state.mutex.lock();
+    defer ev.renderer_state.mutex.unlock();
+
+    // Schedule a render. We can call this first because we have the lock.
+    ev.queueRender() catch unreachable;
+
+    // Whenever a character is typed, we ensure the cursor is in the
+    // non-blink state so it is rendered if visible. If we're under
+    // HEAVY read load, we don't want to send a ton of these so we
+    // use a timer under the covers
+    const now = ev.loop.now();
+    if (now - ev.last_cursor_reset > 500) {
+        ev.last_cursor_reset = now;
+        _ = ev.renderer_mailbox.push(.{
+            .reset_cursor_blink = {},
+        }, .{ .forever = {} });
+    }
+
+    // If we have an inspector, we enter SLOW MODE because we need to
+    // process a byte at a time alternating between the inspector handler
+    // and the termio handler. This is very slow compared to our optimizations
+    // below but at least users only pay for it if they're using the inspector.
+    if (ev.renderer_state.inspector) |insp| {
+        for (buf, 0..) |byte, i| {
+            insp.recordPtyRead(buf[i .. i + 1]) catch |err| {
+                log.err("error recording pty read in inspector err={}", .{err});
+            };
+
+            ev.terminal_stream.next(byte) catch |err|
+                log.err("error processing terminal data: {}", .{err});
+        }
+    } else {
+        ev.terminal_stream.nextSlice(buf) catch |err|
+            log.err("error processing terminal data: {}", .{err});
+    }
+
+    // If our stream handling caused messages to be sent to the writer
+    // thread, then we need to wake it up so that it processes them.
+    if (ev.terminal_stream.handler.writer_messaged) {
+        ev.terminal_stream.handler.writer_messaged = false;
+        ev.writer_wakeup.notify() catch |err| {
+            log.warn("failed to wake up writer thread err={}", .{err});
+        };
+    }
+}
+
+/// ThreadData is the data created and stored in the termio thread
+/// when the thread is started and destroyed when the thread is
+/// stopped.
+///
+/// All of the fields in this struct should only be read/written by
+/// the termio thread. As such, a lock is not necessary.
+pub const ThreadData = struct {
+    /// Allocator used for the event data
+    alloc: Allocator,
+
+    /// The data that is attached to the callbacks.
+    ev: *EventData,
+
+    /// Data associated with the reader implementation (i.e. pty/exec state)
+    reader: termio.reader.ThreadData,
+
+    /// Our read thread
+    read_thread: std.Thread,
+    read_thread_pipe: posix.fd_t,
+    read_thread_fd: if (builtin.os.tag == .windows) posix.fd_t else void,
+
+    pub fn deinit(self: *ThreadData) void {
+        posix.close(self.read_thread_pipe);
+        self.ev.deinit(self.alloc);
+        self.alloc.destroy(self.ev);
+        self.* = undefined;
+    }
+};
+
+const EventData = struct {
+    // The preallocation size for the write request pool. This should be big
+    // enough to satisfy most write requests. It must be a power of 2.
+    const WRITE_REQ_PREALLOC = std.math.pow(usize, 2, 5);
+
+    /// Mailbox for data to the writer thread.
+    writer_mailbox: *termio.Mailbox,
+    writer_wakeup: xev.Async,
+
+    /// Mailbox for the surface.
+    surface_mailbox: apprt.surface.Mailbox,
+
+    /// The stream parser. This parses the stream of escape codes and so on
+    /// from the child process and calls callbacks in the stream handler.
+    terminal_stream: terminal.Stream(StreamHandler),
+
+    /// The shared render state
+    renderer_state: *renderer.State,
+
+    /// A handle to wake up the renderer. This hints to the renderer that that
+    /// a repaint should happen.
+    renderer_wakeup: xev.Async,
+
+    /// The mailbox for notifying the renderer of things.
+    renderer_mailbox: *renderer.Thread.Mailbox,
+
+    /// The process watcher
+    process: xev.Process,
+
+    /// This is used for both waiting for the process to exit and then
+    /// subsequently to wait for the data_stream to close.
+    process_wait_c: xev.Completion = .{},
+
+    /// The data stream is the main IO for the pty.
+    data_stream: xev.Stream,
+
+    /// The event loop,
+    loop: *xev.Loop,
+
+    /// The write queue for the data stream.
+    write_queue: xev.Stream.WriteQueue = .{},
+
+    /// This is the pool of available (unused) write requests. If you grab
+    /// one from the pool, you must put it back when you're done!
+    write_req_pool: SegmentedPool(xev.Stream.WriteRequest, WRITE_REQ_PREALLOC) = .{},
+
+    /// The pool of available buffers for writing to the pty.
+    write_buf_pool: SegmentedPool([64]u8, WRITE_REQ_PREALLOC) = .{},
+
+    /// Last time the cursor was reset. This is used to prevent message
+    /// flooding with cursor resets.
+    last_cursor_reset: i64 = 0,
+
+    /// This is set to true when we've seen a title escape sequence. We use
+    /// this to determine if we need to default the window title.
+    seen_title: bool = false,
+
+    pub fn deinit(self: *EventData, alloc: Allocator) void {
+        // Clear our write pools. We know we aren't ever going to do
+        // any more IO since we stop our data stream below so we can just
+        // drop this.
+        self.write_req_pool.deinit(alloc);
+        self.write_buf_pool.deinit(alloc);
+
+        // Stop our data stream
+        self.data_stream.deinit();
+
+        // Stop our process watcher
+        self.process.deinit();
+
+        // Clear any StreamHandler state
+        self.terminal_stream.handler.deinit();
+        self.terminal_stream.deinit();
+    }
+
+    /// This queues a render operation with the renderer thread. The render
+    /// isn't guaranteed to happen immediately but it will happen as soon as
+    /// practical.
+    inline fn queueRender(self: *EventData) !void {
+        try self.renderer_wakeup.notify();
+    }
+};
+
+fn processExit(
+    td_: ?*ThreadData,
+    _: *xev.Loop,
+    _: *xev.Completion,
+    r: xev.Process.WaitError!u32,
+) xev.CallbackAction {
+    const exit_code = r catch unreachable;
+
+    const td = td_.?;
+    assert(td.reader == .exec);
+    const ev = td.ev;
+    const execdata = &td.reader.exec;
+    execdata.exited = true;
+
+    // Determine how long the process was running for.
+    const runtime_ms: ?u64 = runtime: {
+        const process_end = std.time.Instant.now() catch break :runtime null;
+        const runtime_ns = process_end.since(execdata.start);
+        const runtime_ms = runtime_ns / std.time.ns_per_ms;
+        break :runtime runtime_ms;
+    };
+    log.debug(
+        "child process exited status={} runtime={}ms",
+        .{ exit_code, runtime_ms orelse 0 },
+    );
+
+    // If our runtime was below some threshold then we assume that this
+    // was an abnormal exit and we show an error message.
+    if (runtime_ms) |runtime| runtime: {
+        // On macOS, our exit code detection doesn't work, possibly
+        // because of our `login` wrapper. More investigation required.
+        if (comptime !builtin.target.isDarwin()) {
+            // If our exit code is zero, then the command was successful
+            // and we don't ever consider it abnormal.
+            if (exit_code == 0) break :runtime;
+        }
+
+        // Our runtime always has to be under the threshold to be
+        // considered abnormal. This is because a user can always
+        // manually do something like `exit 1` in their shell to
+        // force the exit code to be non-zero. We only want to detect
+        // abnormal exits that happen so quickly the user can't react.
+        if (runtime > execdata.abnormal_runtime_threshold_ms) break :runtime;
+        log.warn("abnormal process exit detected, showing error message", .{});
+
+        // Notify our main writer thread which has access to more
+        // information so it can show a better error message.
+        _ = ev.writer_mailbox.push(.{
+            .child_exited_abnormally = .{
+                .exit_code = exit_code,
+                .runtime_ms = runtime,
+            },
+        }, .{ .forever = {} });
+        ev.writer_wakeup.notify() catch break :runtime;
+
+        return .disarm;
+    }
+
+    // If we're purposely waiting then we just return since the process
+    // exited flag is set to true. This allows the terminal window to remain
+    // open.
+    if (execdata.wait_after_command) {
+        // We output a message so that the user knows whats going on and
+        // doesn't think their terminal just froze.
+        terminal: {
+            ev.renderer_state.mutex.lock();
+            defer ev.renderer_state.mutex.unlock();
+            const t = ev.renderer_state.terminal;
+            t.carriageReturn();
+            t.linefeed() catch break :terminal;
+            t.printString("Process exited. Press any key to close the terminal.") catch
+                break :terminal;
+            t.modes.set(.cursor_visible, false);
+        }
+
+        return .disarm;
+    }
+
+    // Notify our surface we want to close
+    _ = ev.surface_mailbox.push(.{
+        .child_exited = {},
+    }, .{ .forever = {} });
+
+    return .disarm;
+}
+
+fn ttyWrite(
+    ev_: ?*EventData,
+    _: *xev.Loop,
+    _: *xev.Completion,
+    _: xev.Stream,
+    _: xev.WriteBuffer,
+    r: xev.Stream.WriteError!usize,
+) xev.CallbackAction {
+    const ev = ev_.?;
+    ev.write_req_pool.put();
+    ev.write_buf_pool.put();
+
+    const d = r catch |err| {
+        log.err("write error: {}", .{err});
+        return .disarm;
+    };
+    _ = d;
+    //log.info("WROTE: {d}", .{d});
+
+    return .disarm;
+}
+
+/// Subprocess manages the lifecycle of the shell subprocess.
+const Subprocess = struct {
+    /// If we build with flatpak support then we have to keep track of
+    /// a potential execution on the host.
+    const FlatpakHostCommand = if (build_config.flatpak) internal_os.FlatpakHostCommand else void;
+
+    arena: std.heap.ArenaAllocator,
+    cwd: ?[]const u8,
+    env: EnvMap,
+    args: [][]const u8,
+    grid_size: renderer.GridSize,
+    screen_size: renderer.ScreenSize,
+    pty: ?Pty = null,
+    command: ?Command = null,
+    flatpak_command: ?FlatpakHostCommand = null,
+    linux_cgroup: Command.LinuxCgroup = Command.linux_cgroup_default,
+
+    /// Initialize the subprocess. This will NOT start it, this only sets
+    /// up the internal state necessary to start it later.
+    pub fn init(gpa: Allocator, opts: termio.Options) !Subprocess {
+        // We have a lot of maybe-allocations that all share the same lifetime
+        // so use an arena so we don't end up in an accounting nightmare.
+        var arena = std.heap.ArenaAllocator.init(gpa);
+        errdefer arena.deinit();
+        const alloc = arena.allocator();
+
+        // Set our env vars. For Flatpak builds running in Flatpak we don't
+        // inherit our environment because the login shell on the host side
+        // will get it.
+        var env = env: {
+            if (comptime build_config.flatpak) {
+                if (internal_os.isFlatpak()) {
+                    break :env std.process.EnvMap.init(alloc);
+                }
+            }
+
+            break :env try std.process.getEnvMap(alloc);
+        };
+        errdefer env.deinit();
+
+        // If we have a resources dir then set our env var
+        if (opts.resources_dir) |dir| {
+            log.info("found Ghostty resources dir: {s}", .{dir});
+            try env.put("GHOSTTY_RESOURCES_DIR", dir);
+        }
+
+        // Set our TERM var. This is a bit complicated because we want to use
+        // the ghostty TERM value but we want to only do that if we have
+        // ghostty in the TERMINFO database.
+        //
+        // For now, we just look up a bundled dir but in the future we should
+        // also load the terminfo database and look for it.
+        if (opts.resources_dir) |base| {
+            try env.put("TERM", opts.config.term);
+            try env.put("COLORTERM", "truecolor");
+
+            // Assume that the resources directory is adjacent to the terminfo
+            // database
+            var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            const dir = try std.fmt.bufPrint(&buf, "{s}/terminfo", .{
+                std.fs.path.dirname(base) orelse unreachable,
+            });
+            try env.put("TERMINFO", dir);
+        } else {
+            if (comptime builtin.target.isDarwin()) {
+                log.warn("ghostty terminfo not found, using xterm-256color", .{});
+                log.warn("the terminfo SHOULD exist on macos, please ensure", .{});
+                log.warn("you're using a valid app bundle.", .{});
+            }
+
+            try env.put("TERM", "xterm-256color");
+            try env.put("COLORTERM", "truecolor");
+        }
+
+        // Add our binary to the path if we can find it.
+        ghostty_path: {
+            var exe_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            const exe_bin_path = std.fs.selfExePath(&exe_buf) catch |err| {
+                log.warn("failed to get ghostty exe path err={}", .{err});
+                break :ghostty_path;
+            };
+            const exe_dir = std.fs.path.dirname(exe_bin_path) orelse break :ghostty_path;
+            log.debug("appending ghostty bin to path dir={s}", .{exe_dir});
+
+            // We always set this so that if the shell overwrites the path
+            // scripts still have a way to find the Ghostty binary when
+            // running in Ghostty.
+            try env.put("GHOSTTY_BIN_DIR", exe_dir);
+
+            // Append if we have a path. We want to append so that ghostty is
+            // the last priority in the path. If we don't have a path set
+            // then we just set it to the directory of the binary.
+            if (env.get("PATH")) |path| {
+                // Verify that our path doesn't already contain this entry
+                var it = std.mem.tokenizeScalar(u8, path, internal_os.PATH_SEP[0]);
+                while (it.next()) |entry| {
+                    if (std.mem.eql(u8, entry, exe_dir)) break :ghostty_path;
+                }
+
+                try env.put(
+                    "PATH",
+                    try internal_os.appendEnv(alloc, path, exe_dir),
+                );
+            } else {
+                try env.put("PATH", exe_dir);
+            }
+        }
+
+        // Add the man pages from our application bundle to MANPATH.
+        if (comptime builtin.target.isDarwin()) {
+            if (opts.resources_dir) |resources_dir| man: {
+                var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+                const dir = std.fmt.bufPrint(&buf, "{s}/../man", .{resources_dir}) catch |err| {
+                    log.warn("error building manpath, man pages may not be available err={}", .{err});
+                    break :man;
+                };
+
+                if (env.get("MANPATH")) |manpath| {
+                    // Append to the existing MANPATH. It's very unlikely that our bundle's
+                    // resources directory already appears here so we don't spend the time
+                    // searching for it.
+                    try env.put(
+                        "MANPATH",
+                        try internal_os.appendEnv(alloc, manpath, dir),
+                    );
+                } else {
+                    try env.put("MANPATH", dir);
+                }
+            }
+        }
+
+        // Set environment variables used by some programs (such as neovim) to detect
+        // which terminal emulator and version they're running under.
+        try env.put("TERM_PROGRAM", "ghostty");
+        try env.put("TERM_PROGRAM_VERSION", build_config.version_string);
+
+        // When embedding in macOS and running via XCode, XCode injects
+        // a bunch of things that break our shell process. We remove those.
+        if (comptime builtin.target.isDarwin() and build_config.artifact == .lib) {
+            if (env.get("__XCODE_BUILT_PRODUCTS_DIR_PATHS") != null) {
+                env.remove("__XCODE_BUILT_PRODUCTS_DIR_PATHS");
+                env.remove("__XPC_DYLD_LIBRARY_PATH");
+                env.remove("DYLD_FRAMEWORK_PATH");
+                env.remove("DYLD_INSERT_LIBRARIES");
+                env.remove("DYLD_LIBRARY_PATH");
+                env.remove("LD_LIBRARY_PATH");
+                env.remove("SECURITYSESSIONID");
+                env.remove("XPC_SERVICE_NAME");
+            }
+
+            // Remove this so that running `ghostty` within Ghostty works.
+            env.remove("GHOSTTY_MAC_APP");
+        }
+
+        // Don't leak these environment variables to child processes.
+        if (comptime build_config.app_runtime == .gtk) {
+            env.remove("GDK_DEBUG");
+            env.remove("GSK_RENDERER");
+        }
+
+        // Setup our shell integration, if we can.
+        const integrated_shell: ?shell_integration.Shell, const shell_command: []const u8 = shell: {
+            const default_shell_command = opts.full_config.command orelse switch (builtin.os.tag) {
+                .windows => "cmd.exe",
+                else => "sh",
+            };
+
+            const force: ?shell_integration.Shell = switch (opts.full_config.@"shell-integration") {
+                .none => break :shell .{ null, default_shell_command },
+                .detect => null,
+                .bash => .bash,
+                .elvish => .elvish,
+                .fish => .fish,
+                .zsh => .zsh,
+            };
+
+            const dir = opts.resources_dir orelse break :shell .{
+                null,
+                default_shell_command,
+            };
+
+            const integration = try shell_integration.setup(
+                alloc,
+                dir,
+                default_shell_command,
+                &env,
+                force,
+                opts.full_config.@"shell-integration-features",
+            ) orelse break :shell .{ null, default_shell_command };
+
+            break :shell .{ integration.shell, integration.command };
+        };
+
+        if (integrated_shell) |shell| {
+            log.info(
+                "shell integration automatically injected shell={}",
+                .{shell},
+            );
+        } else if (opts.full_config.@"shell-integration" != .none) {
+            log.warn("shell could not be detected, no automatic shell integration will be injected", .{});
+        }
+
+        // Build our args list
+        const args = args: {
+            const cap = 9; // the most we'll ever use
+            var args = try std.ArrayList([]const u8).initCapacity(alloc, cap);
+            defer args.deinit();
+
+            // If we're on macOS, we have to use `login(1)` to get all of
+            // the proper environment variables set, a login shell, and proper
+            // hushlogin behavior.
+            if (comptime builtin.target.isDarwin()) darwin: {
+                const passwd = internal_os.passwd.get(alloc) catch |err| {
+                    log.warn("failed to read passwd, not using a login shell err={}", .{err});
+                    break :darwin;
+                };
+
+                const username = passwd.name orelse {
+                    log.warn("failed to get username, not using a login shell", .{});
+                    break :darwin;
+                };
+
+                const hush = if (passwd.home) |home| hush: {
+                    var dir = std.fs.openDirAbsolute(home, .{}) catch |err| {
+                        log.warn(
+                            "failed to open home dir, not checking for hushlogin err={}",
+                            .{err},
+                        );
+                        break :hush false;
+                    };
+                    defer dir.close();
+
+                    break :hush if (dir.access(".hushlogin", .{})) true else |_| false;
+                } else false;
+
+                const cmd = try std.fmt.allocPrint(
+                    alloc,
+                    "exec -l {s}",
+                    .{shell_command},
+                );
+
+                // The reason for executing login this way is unclear. This
+                // comment will attempt to explain but prepare for a truly
+                // unhinged reality.
+                //
+                // The first major issue is that on macOS, a lot of users
+                // put shell configurations in ~/.bash_profile instead of
+                // ~/.bashrc (or equivalent for another shell). This file is only
+                // loaded for a login shell so macOS users expect all their terminals
+                // to be login shells. No other platform behaves this way and its
+                // totally braindead but somehow the entire dev community on
+                // macOS has cargo culted their way to this reality so we have to
+                // do it...
+                //
+                // To get a login shell, you COULD just prepend argv0 with a `-`
+                // but that doesn't fully work because `getlogin()` C API will
+                // return the wrong value, SHELL won't be set, and various
+                // other login behaviors that macOS users expect.
+                //
+                // The proper way is to use `login(1)`. But login(1) forces
+                // the working directory to change to the home directory,
+                // which we may not want. If we specify "-l" then we can avoid
+                // this behavior but now the shell isn't a login shell.
+                //
+                // There is another issue: `login(1)` only checks for ".hushlogin"
+                // in the working directory. This means that if we specify "-l"
+                // then we won't get hushlogin honored if its in the home
+                // directory (which is standard). To get around this, we
+                // check for hushlogin ourselves and if present specify the
+                // "-q" flag to login(1).
+                //
+                // So to get all the behaviors we want, we specify "-l" but
+                // execute "bash" (which is built-in to macOS). We then use
+                // the bash builtin "exec" to replace the process with a login
+                // shell ("-l" on exec) with the command we really want.
+                //
+                // We use "bash" instead of other shells that ship with macOS
+                // because as of macOS Sonoma, we found with a microbenchmark
+                // that bash can `exec` into the desired command ~2x faster
+                // than zsh.
+                //
+                // To figure out a lot of this logic I read the login.c
+                // source code in the OSS distribution Apple provides for
+                // macOS.
+                //
+                // Awesome.
+                try args.append("/usr/bin/login");
+                if (hush) try args.append("-q");
+                try args.append("-flp");
+
+                // We execute bash with "--noprofile --norc" so that it doesn't
+                // load startup files so that (1) our shell integration doesn't
+                // break and (2) user configuration doesn't mess this process
+                // up.
+                try args.append(username);
+                try args.append("/bin/bash");
+                try args.append("--noprofile");
+                try args.append("--norc");
+                try args.append("-c");
+                try args.append(cmd);
+                break :args try args.toOwnedSlice();
+            }
+
+            if (comptime builtin.os.tag == .windows) {
+                // We run our shell wrapped in `cmd.exe` so that we don't have
+                // to parse the command line ourselves if it has arguments.
+
+                // Note we don't free any of the memory below since it is
+                // allocated in the arena.
+                const windir = try std.process.getEnvVarOwned(alloc, "WINDIR");
+                const cmd = try std.fs.path.join(alloc, &[_][]const u8{
+                    windir,
+                    "System32",
+                    "cmd.exe",
+                });
+
+                try args.append(cmd);
+                try args.append("/C");
+            } else {
+                // We run our shell wrapped in `/bin/sh` so that we don't have
+                // to parse the command line ourselves if it has arguments.
+                // Additionally, some environments (NixOS, I found) use /bin/sh
+                // to setup some environment variables that are important to
+                // have set.
+                try args.append("/bin/sh");
+                if (internal_os.isFlatpak()) try args.append("-l");
+                try args.append("-c");
+            }
+
+            try args.append(shell_command);
+            break :args try args.toOwnedSlice();
+        };
+
+        // We have to copy the cwd because there is no guarantee that
+        // pointers in full_config remain valid.
+        const cwd: ?[]u8 = if (opts.full_config.@"working-directory") |cwd|
+            try alloc.dupe(u8, cwd)
+        else
+            null;
+
+        // If we have a cgroup, then we copy that into our arena so the
+        // memory remains valid when we start.
+        const linux_cgroup: Command.LinuxCgroup = cgroup: {
+            const default = Command.linux_cgroup_default;
+            if (comptime builtin.os.tag != .linux) break :cgroup default;
+            const path = opts.linux_cgroup orelse break :cgroup default;
+            break :cgroup try alloc.dupe(u8, path);
+        };
+
+        // Our screen size should be our padded size
+        const padded_size = opts.screen_size.subPadding(opts.padding);
+
+        return .{
+            .arena = arena,
+            .env = env,
+            .cwd = cwd,
+            .args = args,
+            .grid_size = opts.grid_size,
+            .screen_size = padded_size,
+            .linux_cgroup = linux_cgroup,
+        };
+    }
+
+    /// Clean up the subprocess. This will stop the subprocess if it is started.
+    pub fn deinit(self: *Subprocess) void {
+        self.stop();
+        if (self.pty) |*pty| pty.deinit();
+        self.arena.deinit();
+        self.* = undefined;
+    }
+
+    /// Start the subprocess. If the subprocess is already started this
+    /// will crash.
+    pub fn start(self: *Subprocess, alloc: Allocator) !struct {
+        read: Pty.Fd,
+        write: Pty.Fd,
+    } {
+        assert(self.pty == null and self.command == null);
+
+        // Create our pty
+        var pty = try Pty.open(.{
+            .ws_row = @intCast(self.grid_size.rows),
+            .ws_col = @intCast(self.grid_size.columns),
+            .ws_xpixel = @intCast(self.screen_size.width),
+            .ws_ypixel = @intCast(self.screen_size.height),
+        });
+        self.pty = pty;
+        errdefer {
+            pty.deinit();
+            self.pty = null;
+        }
+
+        log.debug("starting command command={s}", .{self.args});
+
+        // In flatpak, we use the HostCommand to execute our shell.
+        if (internal_os.isFlatpak()) flatpak: {
+            if (comptime !build_config.flatpak) {
+                log.warn("flatpak detected, but flatpak support not built-in", .{});
+                break :flatpak;
+            }
+
+            // Flatpak command must have a stable pointer.
+            self.flatpak_command = .{
+                .argv = self.args,
+                .env = &self.env,
+                .stdin = pty.slave,
+                .stdout = pty.slave,
+                .stderr = pty.slave,
+            };
+            var cmd = &self.flatpak_command.?;
+            const pid = try cmd.spawn(alloc);
+            errdefer killCommandFlatpak(cmd);
+
+            log.info("started subcommand on host via flatpak API path={s} pid={?}", .{
+                self.args[0],
+                pid,
+            });
+
+            // Once started, we can close the pty child side. We do this after
+            // wait right now but that is fine too. This lets us read the
+            // parent and detect EOF.
+            _ = posix.close(pty.slave);
+
+            return .{
+                .read = pty.master,
+                .write = pty.master,
+            };
+        }
+
+        // If we can't access the cwd, then don't set any cwd and inherit.
+        // This is important because our cwd can be set by the shell (OSC 7)
+        // and we don't want to break new windows.
+        const cwd: ?[]const u8 = if (self.cwd) |proposed| cwd: {
+            if (std.fs.accessAbsolute(proposed, .{})) {
+                break :cwd proposed;
+            } else |err| {
+                log.warn("cannot access cwd, ignoring: {}", .{err});
+                break :cwd null;
+            }
+        } else null;
+
+        // Build our subcommand
+        var cmd: Command = .{
+            .path = self.args[0],
+            .args = self.args,
+            .env = &self.env,
+            .cwd = cwd,
+            .stdin = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
+            .stdout = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
+            .stderr = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
+            .pseudo_console = if (builtin.os.tag == .windows) pty.pseudo_console else {},
+            .pre_exec = if (builtin.os.tag == .windows) null else (struct {
+                fn callback(cmd: *Command) void {
+                    const sp = cmd.getData(Subprocess) orelse unreachable;
+                    sp.childPreExec() catch |err| log.err(
+                        "error initializing child: {}",
+                        .{err},
+                    );
+                }
+            }).callback,
+            .data = self,
+            .linux_cgroup = self.linux_cgroup,
+        };
+        try cmd.start(alloc);
+        errdefer killCommand(&cmd) catch |err| {
+            log.warn("error killing command during cleanup err={}", .{err});
+        };
+        log.info("started subcommand path={s} pid={?}", .{ self.args[0], cmd.pid });
+        if (comptime builtin.os.tag == .linux) {
+            log.info("subcommand cgroup={s}", .{self.linux_cgroup orelse "-"});
+        }
+
+        self.command = cmd;
+        return switch (builtin.os.tag) {
+            .windows => .{
+                .read = pty.out_pipe,
+                .write = pty.in_pipe,
+            },
+
+            else => .{
+                .read = pty.master,
+                .write = pty.master,
+            },
+        };
+    }
+
+    /// This should be called after fork but before exec in the child process.
+    /// To repeat: this function RUNS IN THE FORKED CHILD PROCESS before
+    /// exec is called; it does NOT run in the main Ghostty process.
+    fn childPreExec(self: *Subprocess) !void {
+        // Setup our pty
+        try self.pty.?.childPreExec();
+    }
+
+    /// Called to notify that we exited externally so we can unset our
+    /// running state.
+    pub fn externalExit(self: *Subprocess) void {
+        self.command = null;
+    }
+
+    /// Stop the subprocess. This is safe to call anytime. This will wait
+    /// for the subprocess to register that it has been signalled, but not
+    /// for it to terminate, so it will not block.
+    /// This does not close the pty.
+    pub fn stop(self: *Subprocess) void {
+        // Kill our command
+        if (self.command) |*cmd| {
+            // Note: this will also wait for the command to exit, so
+            // DO NOT call cmd.wait
+            killCommand(cmd) catch |err|
+                log.err("error sending SIGHUP to command, may hang: {}", .{err});
+            self.command = null;
+        }
+
+        // Kill our Flatpak command
+        if (FlatpakHostCommand != void) {
+            if (self.flatpak_command) |*cmd| {
+                killCommandFlatpak(cmd) catch |err|
+                    log.err("error sending SIGHUP to command, may hang: {}", .{err});
+                _ = cmd.wait() catch |err|
+                    log.err("error waiting for command to exit: {}", .{err});
+                self.flatpak_command = null;
+            }
+        }
+    }
+
+    /// Resize the pty subprocess. This is safe to call anytime.
+    pub fn resize(
+        self: *Subprocess,
+        grid_size: renderer.GridSize,
+        screen_size: renderer.ScreenSize,
+    ) !void {
+        self.grid_size = grid_size;
+        self.screen_size = screen_size;
+
+        if (self.pty) |*pty| {
+            try pty.setSize(.{
+                .ws_row = @intCast(grid_size.rows),
+                .ws_col = @intCast(grid_size.columns),
+                .ws_xpixel = @intCast(screen_size.width),
+                .ws_ypixel = @intCast(screen_size.height),
+            });
+        }
+    }
+
+    /// Kill the underlying subprocess. This sends a SIGHUP to the child
+    /// process. This also waits for the command to exit and will return the
+    /// exit code.
+    fn killCommand(command: *Command) !void {
+        if (command.pid) |pid| {
+            switch (builtin.os.tag) {
+                .windows => {
+                    if (windows.kernel32.TerminateProcess(pid, 0) == 0) {
+                        return windows.unexpectedError(windows.kernel32.GetLastError());
+                    }
+
+                    _ = try command.wait(false);
+                },
+
+                else => if (getpgid(pid)) |pgid| {
+                    // It is possible to send a killpg between the time that
+                    // our child process calls setsid but before or simultaneous
+                    // to calling execve. In this case, the direct child dies
+                    // but grandchildren survive. To work around this, we loop
+                    // and repeatedly kill the process group until all
+                    // descendents are well and truly dead. We will not rest
+                    // until the entire family tree is obliterated.
+                    while (true) {
+                        if (c.killpg(pgid, c.SIGHUP) < 0) {
+                            log.warn("error killing process group pgid={}", .{pgid});
+                            return error.KillFailed;
+                        }
+
+                        // See Command.zig wait for why we specify WNOHANG.
+                        // The gist is that it lets us detect when children
+                        // are still alive without blocking so that we can
+                        // kill them again.
+                        const res = posix.waitpid(pid, std.c.W.NOHANG);
+                        if (res.pid != 0) break;
+                        std.time.sleep(10 * std.time.ns_per_ms);
+                    }
+                },
+            }
+        }
+    }
+
+    fn getpgid(pid: c.pid_t) ?c.pid_t {
+        // Get our process group ID. Before the child pid calls setsid
+        // the pgid will be ours because we forked it. Its possible that
+        // we may be calling this before setsid if we are killing a surface
+        // VERY quickly after starting it.
+        const my_pgid = c.getpgid(0);
+
+        // We loop while pgid == my_pgid. The expectation if we have a valid
+        // pid is that setsid will eventually be called because it is the
+        // FIRST thing the child process does and as far as I can tell,
+        // setsid cannot fail. I'm sure that's not true, but I'd rather
+        // have a bug reported than defensively program against it now.
+        while (true) {
+            const pgid = c.getpgid(pid);
+            if (pgid == my_pgid) {
+                log.warn("pgid is our own, retrying", .{});
+                std.time.sleep(10 * std.time.ns_per_ms);
+                continue;
+            }
+
+            // Don't know why it would be zero but its not a valid pid
+            if (pgid == 0) return null;
+
+            // If the pid doesn't exist then... we're done!
+            if (pgid == c.ESRCH) return null;
+
+            // If we have an error we're done.
+            if (pgid < 0) {
+                log.warn("error getting pgid for kill", .{});
+                return null;
+            }
+
+            return pgid;
+        }
+    }
+
+    /// Kill the underlying process started via Flatpak host command.
+    /// This sends a signal via the Flatpak API.
+    fn killCommandFlatpak(command: *FlatpakHostCommand) !void {
+        try command.signal(c.SIGHUP, true);
+    }
+};
+
+/// The read thread sits in a loop doing the following pseudo code:
+///
+///   while (true) { blocking_read(); exit_if_eof(); process(); }
+///
+/// Almost all terminal-modifying activity is from the pty read, so
+/// putting this on a dedicated thread keeps performance very predictable
+/// while also almost optimal. "Locking is fast, lock contention is slow."
+/// and since we rarely have contention, this is fast.
+///
+/// This is also empirically fast compared to putting the read into
+/// an async mechanism like io_uring/epoll because the reads are generally
+/// small.
+///
+/// We use a basic poll syscall here because we are only monitoring two
+/// fds and this is still much faster and lower overhead than any async
+/// mechanism.
+const ReadThread = struct {
+    fn threadMainPosix(fd: posix.fd_t, ev: *EventData, quit: posix.fd_t) void {
+        // Always close our end of the pipe when we exit.
+        defer posix.close(quit);
+
+        // First thing, we want to set the fd to non-blocking. We do this
+        // so that we can try to read from the fd in a tight loop and only
+        // check the quit fd occasionally.
+        if (posix.fcntl(fd, posix.F.GETFL, 0)) |flags| {
+            _ = posix.fcntl(
+                fd,
+                posix.F.SETFL,
+                flags | @as(u32, @bitCast(posix.O{ .NONBLOCK = true })),
+            ) catch |err| {
+                log.warn("read thread failed to set flags err={}", .{err});
+                log.warn("this isn't a fatal error, but may cause performance issues", .{});
+            };
+        } else |err| {
+            log.warn("read thread failed to get flags err={}", .{err});
+            log.warn("this isn't a fatal error, but may cause performance issues", .{});
+        }
+
+        // Build up the list of fds we're going to poll. We are looking
+        // for data on the pty and our quit notification.
+        var pollfds: [2]posix.pollfd = .{
+            .{ .fd = fd, .events = posix.POLL.IN, .revents = undefined },
+            .{ .fd = quit, .events = posix.POLL.IN, .revents = undefined },
+        };
+
+        var buf: [1024]u8 = undefined;
+        while (true) {
+            // We try to read from the file descriptor as long as possible
+            // to maximize performance. We only check the quit fd if the
+            // main fd blocks. This optimizes for the realistic scenario that
+            // the data will eventually stop while we're trying to quit. This
+            // is always true because we kill the process.
+            while (true) {
+                const n = posix.read(fd, &buf) catch |err| {
+                    switch (err) {
+                        // This means our pty is closed. We're probably
+                        // gracefully shutting down.
+                        error.NotOpenForReading,
+                        error.InputOutput,
+                        => {
+                            log.info("io reader exiting", .{});
+                            return;
+                        },
+
+                        // No more data, fall back to poll and check for
+                        // exit conditions.
+                        error.WouldBlock => break,
+
+                        else => {
+                            log.err("io reader error err={}", .{err});
+                            unreachable;
+                        },
+                    }
+                };
+
+                // This happens on macOS instead of WouldBlock when the
+                // child process dies. To be safe, we just break the loop
+                // and let our poll happen.
+                if (n == 0) break;
+
+                // log.info("DATA: {d}", .{n});
+                @call(.always_inline, readInternal, .{ ev, buf[0..n] });
+            }
+
+            // Wait for data.
+            _ = posix.poll(&pollfds, -1) catch |err| {
+                log.warn("poll failed on read thread, exiting early err={}", .{err});
+                return;
+            };
+
+            // If our quit fd is set, we're done.
+            if (pollfds[1].revents & posix.POLL.IN != 0) {
+                log.info("read thread got quit signal", .{});
+                return;
+            }
+        }
+    }
+
+    fn threadMainWindows(fd: posix.fd_t, ev: *EventData, quit: posix.fd_t) void {
+        // Always close our end of the pipe when we exit.
+        defer posix.close(quit);
+
+        var buf: [1024]u8 = undefined;
+        while (true) {
+            while (true) {
+                var n: windows.DWORD = 0;
+                if (windows.kernel32.ReadFile(fd, &buf, buf.len, &n, null) == 0) {
+                    const err = windows.kernel32.GetLastError();
+                    switch (err) {
+                        // Check for a quit signal
+                        .OPERATION_ABORTED => break,
+
+                        else => {
+                            log.err("io reader error err={}", .{err});
+                            unreachable;
+                        },
+                    }
+                }
+
+                @call(.always_inline, readInternal, .{ ev, buf[0..n] });
+            }
+
+            var quit_bytes: windows.DWORD = 0;
+            if (windows.exp.kernel32.PeekNamedPipe(quit, null, 0, null, &quit_bytes, null) == 0) {
+                const err = windows.kernel32.GetLastError();
+                log.err("quit pipe reader error err={}", .{err});
+                unreachable;
+            }
+
+            if (quit_bytes > 0) {
+                log.info("read thread got quit signal", .{});
+                return;
+            }
+        }
+    }
+};
+
+/// This is used as the handler for the terminal.Stream type. This is
+/// stateful and is expected to live for the entire lifetime of the terminal.
+/// It is NOT VALID to stop a stream handler, create a new one, and use that
+/// unless all of the member fields are copied.
+const StreamHandler = struct {
+    ev: *EventData,
+    alloc: Allocator,
+    grid_size: *renderer.GridSize,
+    terminal: *terminal.Terminal,
+
+    /// The APC command handler maintains the APC state. APC is like
+    /// CSI or OSC, but it is a private escape sequence that is used
+    /// to send commands to the terminal emulator. This is used by
+    /// the kitty graphics protocol.
+    apc: terminal.apc.Handler = .{},
+
+    /// The DCS handler maintains DCS state. DCS is like CSI or OSC,
+    /// but requires more stateful parsing. This is used by functionality
+    /// such as XTGETTCAP.
+    dcs: terminal.dcs.Handler = .{},
+
+    /// This is set to true when a message was written to the writer
+    /// mailbox. This can be used by callers to determine if they need
+    /// to wake up the writer.
+    writer_messaged: bool = false,
+
+    /// The default cursor state. This is used with CSI q. This is
+    /// set to true when we're currently in the default cursor state.
+    default_cursor: bool = true,
+    default_cursor_style: terminal.CursorStyle,
+    default_cursor_blink: ?bool,
+    default_cursor_color: ?terminal.color.RGB,
+
+    /// Actual cursor color. This can be changed with OSC 12.
+    cursor_color: ?terminal.color.RGB,
+
+    /// The default foreground and background color are those set by the user's
+    /// config file. These can be overridden by terminal applications using OSC
+    /// 10 and OSC 11, respectively.
+    default_foreground_color: terminal.color.RGB,
+    default_background_color: terminal.color.RGB,
+
+    /// The actual foreground and background color. Normally this will be the
+    /// same as the default foreground and background color, unless changed by a
+    /// terminal application.
+    foreground_color: terminal.color.RGB,
+    background_color: terminal.color.RGB,
+
+    /// The response to use for ENQ requests. The memory is owned by
+    /// whoever owns StreamHandler.
+    enquiry_response: []const u8,
+
+    osc_color_report_format: configpkg.Config.OSCColorReportFormat,
+
+    pub fn init(
+        alloc: Allocator,
+        ev: *EventData,
+        grid_size: *renderer.GridSize,
+        t: *terminal.Terminal,
+        config: *const DerivedConfig,
+    ) StreamHandler {
+        const default_cursor_color = if (config.cursor_color) |col|
+            col.toTerminalRGB()
+        else
+            null;
+
+        return .{
+            .alloc = alloc,
+            .ev = ev,
+            .grid_size = grid_size,
+            .terminal = t,
+            .osc_color_report_format = config.osc_color_report_format,
+            .enquiry_response = config.enquiry_response,
+            .default_foreground_color = config.foreground.toTerminalRGB(),
+            .default_background_color = config.background.toTerminalRGB(),
+            .default_cursor_style = config.cursor_style,
+            .default_cursor_blink = config.cursor_blink,
+            .default_cursor_color = default_cursor_color,
+            .cursor_color = default_cursor_color,
+            .foreground_color = config.foreground.toTerminalRGB(),
+            .background_color = config.background.toTerminalRGB(),
+        };
+    }
+
+    pub fn deinit(self: *StreamHandler) void {
+        self.apc.deinit();
+        self.dcs.deinit();
+    }
+
+    /// Change the configuration for this handler.
+    pub fn changeConfig(self: *StreamHandler, config: *DerivedConfig) void {
+        self.osc_color_report_format = config.osc_color_report_format;
+        self.enquiry_response = config.enquiry_response;
+        self.default_foreground_color = config.foreground.toTerminalRGB();
+        self.default_background_color = config.background.toTerminalRGB();
+        self.default_cursor_style = config.cursor_style;
+        self.default_cursor_blink = config.cursor_blink;
+        self.default_cursor_color = if (config.cursor_color) |col|
+            col.toTerminalRGB()
+        else
+            null;
+
+        // If our cursor is the default, then we update it immediately.
+        if (self.default_cursor) self.setCursorStyle(.default) catch |err| {
+            log.warn("failed to set default cursor style: {}", .{err});
+        };
+    }
+
+    inline fn queueRender(self: *StreamHandler) !void {
+        try self.ev.queueRender();
+    }
+
+    inline fn surfaceMessageWriter(
+        self: *StreamHandler,
+        msg: apprt.surface.Message,
+    ) void {
+        // See messageWriter which has similar logic and explains why
+        // we may have to do this.
+        if (self.ev.surface_mailbox.push(msg, .{ .instant = {} }) == 0) {
+            self.ev.renderer_state.mutex.unlock();
+            defer self.ev.renderer_state.mutex.lock();
+            _ = self.ev.surface_mailbox.push(msg, .{ .forever = {} });
+        }
+    }
+
+    inline fn messageWriter(self: *StreamHandler, msg: termio.Message) void {
+        // Try to write to the mailbox with an instant timeout. This is the
+        // fast path because we can queue without a lock.
+        if (self.ev.writer_mailbox.push(msg, .{ .instant = {} }) == 0) {
+            // If we enter this conditional, the mailbox is full. We wake up
+            // the writer thread so that it can process messages to clear up
+            // space. However, the writer thread may require the renderer
+            // lock so we need to unlock.
+            self.ev.writer_wakeup.notify() catch |err| {
+                log.warn("failed to wake up writer, data will be dropped err={}", .{err});
+                return;
+            };
+
+            // Unlock the renderer state so the writer thread can acquire it.
+            // Then try to queue our message before continuing. This is a very
+            // slow path because we are having a lot of contention for data.
+            // But this only gets triggered in certain pathological cases.
+            //
+            // Note that writes themselves don't require a lock, but there
+            // are other messages in the writer mailbox (resize, focus) that
+            // could acquire the lock. This is why we have to release our lock
+            // here.
+            self.ev.renderer_state.mutex.unlock();
+            defer self.ev.renderer_state.mutex.lock();
+            _ = self.ev.writer_mailbox.push(msg, .{ .forever = {} });
+        }
+
+        // Normally, we just flag this true to wake up the writer thread
+        // once per batch of data.
+        self.writer_messaged = true;
+    }
+
+    pub fn dcsHook(self: *StreamHandler, dcs: terminal.DCS) !void {
+        self.dcs.hook(self.alloc, dcs);
+    }
+
+    pub fn dcsPut(self: *StreamHandler, byte: u8) !void {
+        self.dcs.put(byte);
+    }
+
+    pub fn dcsUnhook(self: *StreamHandler) !void {
+        var cmd = self.dcs.unhook() orelse return;
+        defer cmd.deinit();
+
+        // log.warn("DCS command: {}", .{cmd});
+        switch (cmd) {
+            .xtgettcap => |*gettcap| {
+                const map = comptime terminfo.ghostty.xtgettcapMap();
+                while (gettcap.next()) |key| {
+                    const response = map.get(key) orelse continue;
+                    self.messageWriter(.{ .write_stable = response });
+                }
+            },
+            .decrqss => |decrqss| {
+                var response: [128]u8 = undefined;
+                var stream = std.io.fixedBufferStream(&response);
+                const writer = stream.writer();
+
+                // Offset the stream position to just past the response prefix.
+                // We will write the "payload" (if any) below. If no payload is
+                // written then we send an invalid DECRPSS response.
+                const prefix_fmt = "\x1bP{d}$r";
+                const prefix_len = std.fmt.comptimePrint(prefix_fmt, .{0}).len;
+                stream.pos = prefix_len;
+
+                switch (decrqss) {
+                    // Invalid or unhandled request
+                    .none => {},
+
+                    .sgr => {
+                        const buf = try self.terminal.printAttributes(stream.buffer[stream.pos..]);
+
+                        // printAttributes wrote into our buffer, so adjust the stream
+                        // position
+                        stream.pos += buf.len;
+
+                        try writer.writeByte('m');
+                    },
+
+                    .decscusr => {
+                        const blink = self.terminal.modes.get(.cursor_blinking);
+                        const style: u8 = switch (self.terminal.screen.cursor.cursor_style) {
+                            .block => if (blink) 1 else 2,
+                            .underline => if (blink) 3 else 4,
+                            .bar => if (blink) 5 else 6,
+                        };
+                        try writer.print("{d} q", .{style});
+                    },
+
+                    .decstbm => {
+                        try writer.print("{d};{d}r", .{
+                            self.terminal.scrolling_region.top + 1,
+                            self.terminal.scrolling_region.bottom + 1,
+                        });
+                    },
+
+                    .decslrm => {
+                        // We only send a valid response when left and right
+                        // margin mode (DECLRMM) is enabled.
+                        if (self.terminal.modes.get(.enable_left_and_right_margin)) {
+                            try writer.print("{d};{d}s", .{
+                                self.terminal.scrolling_region.left + 1,
+                                self.terminal.scrolling_region.right + 1,
+                            });
+                        }
+                    },
+                }
+
+                // Our response is valid if we have a response payload
+                const valid = stream.pos > prefix_len;
+
+                // Write the terminator
+                try writer.writeAll("\x1b\\");
+
+                // Write the response prefix into the buffer
+                _ = try std.fmt.bufPrint(response[0..prefix_len], prefix_fmt, .{@intFromBool(valid)});
+                const msg = try termio.Message.writeReq(self.alloc, response[0..stream.pos]);
+                self.messageWriter(msg);
+            },
+        }
+    }
+
+    pub fn apcStart(self: *StreamHandler) !void {
+        self.apc.start();
+    }
+
+    pub fn apcPut(self: *StreamHandler, byte: u8) !void {
+        self.apc.feed(self.alloc, byte);
+    }
+
+    pub fn apcEnd(self: *StreamHandler) !void {
+        var cmd = self.apc.end() orelse return;
+        defer cmd.deinit(self.alloc);
+
+        // log.warn("APC command: {}", .{cmd});
+        switch (cmd) {
+            .kitty => |*kitty_cmd| {
+                if (self.terminal.kittyGraphics(self.alloc, kitty_cmd)) |resp| {
+                    var buf: [1024]u8 = undefined;
+                    var buf_stream = std.io.fixedBufferStream(&buf);
+                    try resp.encode(buf_stream.writer());
+                    const final = buf_stream.getWritten();
+                    if (final.len > 2) {
+                        // log.warn("kitty graphics response: {s}", .{std.fmt.fmtSliceHexLower(final)});
+                        self.messageWriter(try termio.Message.writeReq(self.alloc, final));
+                    }
+                }
+            },
+        }
+    }
+
+    pub fn print(self: *StreamHandler, ch: u21) !void {
+        try self.terminal.print(ch);
+    }
+
+    pub fn printRepeat(self: *StreamHandler, count: usize) !void {
+        try self.terminal.printRepeat(count);
+    }
+
+    pub fn bell(self: StreamHandler) !void {
+        _ = self;
+        log.info("BELL", .{});
+    }
+
+    pub fn backspace(self: *StreamHandler) !void {
+        self.terminal.backspace();
+    }
+
+    pub fn horizontalTab(self: *StreamHandler, count: u16) !void {
+        for (0..count) |_| {
+            const x = self.terminal.screen.cursor.x;
+            try self.terminal.horizontalTab();
+            if (x == self.terminal.screen.cursor.x) break;
+        }
+    }
+
+    pub fn horizontalTabBack(self: *StreamHandler, count: u16) !void {
+        for (0..count) |_| {
+            const x = self.terminal.screen.cursor.x;
+            try self.terminal.horizontalTabBack();
+            if (x == self.terminal.screen.cursor.x) break;
+        }
+    }
+
+    pub fn linefeed(self: *StreamHandler) !void {
+        // Small optimization: call index instead of linefeed because they're
+        // identical and this avoids one layer of function call overhead.
+        try self.terminal.index();
+    }
+
+    pub fn carriageReturn(self: *StreamHandler) !void {
+        self.terminal.carriageReturn();
+    }
+
+    pub fn setCursorLeft(self: *StreamHandler, amount: u16) !void {
+        self.terminal.cursorLeft(amount);
+    }
+
+    pub fn setCursorRight(self: *StreamHandler, amount: u16) !void {
+        self.terminal.cursorRight(amount);
+    }
+
+    pub fn setCursorDown(self: *StreamHandler, amount: u16, carriage: bool) !void {
+        self.terminal.cursorDown(amount);
+        if (carriage) self.terminal.carriageReturn();
+    }
+
+    pub fn setCursorUp(self: *StreamHandler, amount: u16, carriage: bool) !void {
+        self.terminal.cursorUp(amount);
+        if (carriage) self.terminal.carriageReturn();
+    }
+
+    pub fn setCursorCol(self: *StreamHandler, col: u16) !void {
+        self.terminal.setCursorPos(self.terminal.screen.cursor.y + 1, col);
+    }
+
+    pub fn setCursorColRelative(self: *StreamHandler, offset: u16) !void {
+        self.terminal.setCursorPos(
+            self.terminal.screen.cursor.y + 1,
+            self.terminal.screen.cursor.x + 1 +| offset,
+        );
+    }
+
+    pub fn setCursorRow(self: *StreamHandler, row: u16) !void {
+        self.terminal.setCursorPos(row, self.terminal.screen.cursor.x + 1);
+    }
+
+    pub fn setCursorRowRelative(self: *StreamHandler, offset: u16) !void {
+        self.terminal.setCursorPos(
+            self.terminal.screen.cursor.y + 1 +| offset,
+            self.terminal.screen.cursor.x + 1,
+        );
+    }
+
+    pub fn setCursorPos(self: *StreamHandler, row: u16, col: u16) !void {
+        self.terminal.setCursorPos(row, col);
+    }
+
+    pub fn eraseDisplay(self: *StreamHandler, mode: terminal.EraseDisplay, protected: bool) !void {
+        if (mode == .complete) {
+            // Whenever we erase the full display, scroll to bottom.
+            try self.terminal.scrollViewport(.{ .bottom = {} });
+            try self.queueRender();
+        }
+
+        self.terminal.eraseDisplay(mode, protected);
+    }
+
+    pub fn eraseLine(self: *StreamHandler, mode: terminal.EraseLine, protected: bool) !void {
+        self.terminal.eraseLine(mode, protected);
+    }
+
+    pub fn deleteChars(self: *StreamHandler, count: usize) !void {
+        self.terminal.deleteChars(count);
+    }
+
+    pub fn eraseChars(self: *StreamHandler, count: usize) !void {
+        self.terminal.eraseChars(count);
+    }
+
+    pub fn insertLines(self: *StreamHandler, count: usize) !void {
+        self.terminal.insertLines(count);
+    }
+
+    pub fn insertBlanks(self: *StreamHandler, count: usize) !void {
+        self.terminal.insertBlanks(count);
+    }
+
+    pub fn deleteLines(self: *StreamHandler, count: usize) !void {
+        self.terminal.deleteLines(count);
+    }
+
+    pub fn reverseIndex(self: *StreamHandler) !void {
+        self.terminal.reverseIndex();
+    }
+
+    pub fn index(self: *StreamHandler) !void {
+        try self.terminal.index();
+    }
+
+    pub fn nextLine(self: *StreamHandler) !void {
+        try self.terminal.index();
+        self.terminal.carriageReturn();
+    }
+
+    pub fn setTopAndBottomMargin(self: *StreamHandler, top: u16, bot: u16) !void {
+        self.terminal.setTopAndBottomMargin(top, bot);
+    }
+
+    pub fn setLeftAndRightMarginAmbiguous(self: *StreamHandler) !void {
+        if (self.terminal.modes.get(.enable_left_and_right_margin)) {
+            try self.setLeftAndRightMargin(0, 0);
+        } else {
+            try self.saveCursor();
+        }
+    }
+
+    pub fn setLeftAndRightMargin(self: *StreamHandler, left: u16, right: u16) !void {
+        self.terminal.setLeftAndRightMargin(left, right);
+    }
+
+    pub fn setModifyKeyFormat(self: *StreamHandler, format: terminal.ModifyKeyFormat) !void {
+        self.terminal.flags.modify_other_keys_2 = false;
+        switch (format) {
+            .other_keys => |v| switch (v) {
+                .numeric => self.terminal.flags.modify_other_keys_2 = true,
+                else => {},
+            },
+            else => {},
+        }
+    }
+
+    pub fn requestMode(self: *StreamHandler, mode_raw: u16, ansi: bool) !void {
+        // Get the mode value and respond.
+        const code: u8 = code: {
+            const mode = terminal.modes.modeFromInt(mode_raw, ansi) orelse break :code 0;
+            if (self.terminal.modes.get(mode)) break :code 1;
+            break :code 2;
+        };
+
+        var msg: termio.Message = .{ .write_small = .{} };
+        const resp = try std.fmt.bufPrint(
+            &msg.write_small.data,
+            "\x1B[{s}{};{}$y",
+            .{
+                if (ansi) "" else "?",
+                mode_raw,
+                code,
+            },
+        );
+        msg.write_small.len = @intCast(resp.len);
+        self.messageWriter(msg);
+    }
+
+    pub fn saveMode(self: *StreamHandler, mode: terminal.Mode) !void {
+        // log.debug("save mode={}", .{mode});
+        self.terminal.modes.save(mode);
+    }
+
+    pub fn restoreMode(self: *StreamHandler, mode: terminal.Mode) !void {
+        // For restore mode we have to restore but if we set it, we
+        // always have to call setMode because setting some modes have
+        // side effects and we want to make sure we process those.
+        const v = self.terminal.modes.restore(mode);
+        // log.debug("restore mode={} v={}", .{ mode, v });
+        try self.setMode(mode, v);
+    }
+
+    pub fn setMode(self: *StreamHandler, mode: terminal.Mode, enabled: bool) !void {
+        // Note: this function doesn't need to grab the render state or
+        // terminal locks because it is only called from process() which
+        // grabs the lock.
+
+        // If we are setting cursor blinking, we ignore it if we have
+        // a default cursor blink setting set. This is a really weird
+        // behavior so this comment will go deep into trying to explain it.
+        //
+        // There are two ways to set cursor blinks: DECSCUSR (CSI _ q)
+        // and DEC mode 12. DECSCUSR is the modern approach and has a
+        // way to revert to the "default" (as defined by the terminal)
+        // cursor style and blink by doing "CSI 0 q". DEC mode 12 controls
+        // blinking and is either on or off and has no way to set a
+        // default. DEC mode 12 is also the more antiquated approach.
+        //
+        // The problem is that if the user specifies a desired default
+        // cursor blink with `cursor-style-blink`, the moment a running
+        // program uses DEC mode 12, the cursor blink can never be reset
+        // to the default without an explicit DECSCUSR. But if a program
+        // is using mode 12, it is by definition not using DECSCUSR.
+        // This makes for somewhat annoying interactions where a poorly
+        // (or legacy) behaved program will stop blinking, and it simply
+        // never restarts.
+        //
+        // To get around this, we have a special case where if the user
+        // specifies some explicit default cursor blink desire, we ignore
+        // DEC mode 12. We allow DECSCUSR to still set the cursor blink
+        // because programs using DECSCUSR usually are well behaved and
+        // reset the cursor blink to the default when they exit.
+        //
+        // To be extra safe, users can also add a manual `CSI 0 q` to
+        // their shell config when they render prompts to ensure the
+        // cursor is exactly as they request.
+        if (mode == .cursor_blinking and
+            self.default_cursor_blink != null)
+        {
+            return;
+        }
+
+        // We first always set the raw mode on our mode state.
+        self.terminal.modes.set(mode, enabled);
+
+        // And then some modes require additional processing.
+        switch (mode) {
+            // Just noting here that autorepeat has no effect on
+            // the terminal. xterm ignores this mode and so do we.
+            // We know about just so that we don't log that it is
+            // an unknown mode.
+            .autorepeat => {},
+
+            // Schedule a render since we changed colors
+            .reverse_colors => {
+                self.terminal.flags.dirty.reverse_colors = true;
+                try self.queueRender();
+            },
+
+            // Origin resets cursor pos. This is called whether or not
+            // we're enabling or disabling origin mode and whether or
+            // not the value changed.
+            .origin => self.terminal.setCursorPos(1, 1),
+
+            .enable_left_and_right_margin => if (!enabled) {
+                // When we disable left/right margin mode we need to
+                // reset the left/right margins.
+                self.terminal.scrolling_region.left = 0;
+                self.terminal.scrolling_region.right = self.terminal.cols - 1;
+            },
+
+            .alt_screen => {
+                const opts: terminal.Terminal.AlternateScreenOptions = .{
+                    .cursor_save = false,
+                    .clear_on_enter = false,
+                };
+
+                if (enabled)
+                    self.terminal.alternateScreen(opts)
+                else
+                    self.terminal.primaryScreen(opts);
+
+                // Schedule a render since we changed screens
+                try self.queueRender();
+            },
+
+            .alt_screen_save_cursor_clear_enter => {
+                const opts: terminal.Terminal.AlternateScreenOptions = .{
+                    .cursor_save = true,
+                    .clear_on_enter = true,
+                };
+
+                if (enabled)
+                    self.terminal.alternateScreen(opts)
+                else
+                    self.terminal.primaryScreen(opts);
+
+                // Schedule a render since we changed screens
+                try self.queueRender();
+            },
+
+            // Force resize back to the window size
+            .enable_mode_3 => self.terminal.resize(
+                self.alloc,
+                self.grid_size.columns,
+                self.grid_size.rows,
+            ) catch |err| {
+                log.err("error updating terminal size: {}", .{err});
+            },
+
+            .@"132_column" => try self.terminal.deccolm(
+                self.alloc,
+                if (enabled) .@"132_cols" else .@"80_cols",
+            ),
+
+            // We need to start a timer to prevent the emulator being hung
+            // forever.
+            .synchronized_output => {
+                if (enabled) self.messageWriter(.{ .start_synchronized_output = {} });
+                try self.queueRender();
+            },
+
+            .linefeed => {
+                self.messageWriter(.{ .linefeed_mode = enabled });
+            },
+
+            .mouse_event_x10 => {
+                if (enabled) {
+                    self.terminal.flags.mouse_event = .x10;
+                    try self.setMouseShape(.default);
+                } else {
+                    self.terminal.flags.mouse_event = .none;
+                    try self.setMouseShape(.text);
+                }
+            },
+            .mouse_event_normal => {
+                if (enabled) {
+                    self.terminal.flags.mouse_event = .normal;
+                    try self.setMouseShape(.default);
+                } else {
+                    self.terminal.flags.mouse_event = .none;
+                    try self.setMouseShape(.text);
+                }
+            },
+            .mouse_event_button => {
+                if (enabled) {
+                    self.terminal.flags.mouse_event = .button;
+                    try self.setMouseShape(.default);
+                } else {
+                    self.terminal.flags.mouse_event = .none;
+                    try self.setMouseShape(.text);
+                }
+            },
+            .mouse_event_any => {
+                if (enabled) {
+                    self.terminal.flags.mouse_event = .any;
+                    try self.setMouseShape(.default);
+                } else {
+                    self.terminal.flags.mouse_event = .none;
+                    try self.setMouseShape(.text);
+                }
+            },
+
+            .mouse_format_utf8 => self.terminal.flags.mouse_format = if (enabled) .utf8 else .x10,
+            .mouse_format_sgr => self.terminal.flags.mouse_format = if (enabled) .sgr else .x10,
+            .mouse_format_urxvt => self.terminal.flags.mouse_format = if (enabled) .urxvt else .x10,
+            .mouse_format_sgr_pixels => self.terminal.flags.mouse_format = if (enabled) .sgr_pixels else .x10,
+
+            else => {},
+        }
+    }
+
+    pub fn setMouseShiftCapture(self: *StreamHandler, v: bool) !void {
+        self.terminal.flags.mouse_shift_capture = if (v) .true else .false;
+    }
+
+    pub fn setAttribute(self: *StreamHandler, attr: terminal.Attribute) !void {
+        switch (attr) {
+            .unknown => |unk| log.warn("unimplemented or unknown SGR attribute: {any}", .{unk}),
+
+            else => self.terminal.setAttribute(attr) catch |err|
+                log.warn("error setting attribute {}: {}", .{ attr, err }),
+        }
+    }
+
+    pub fn startHyperlink(self: *StreamHandler, uri: []const u8, id: ?[]const u8) !void {
+        try self.terminal.screen.startHyperlink(uri, id);
+    }
+
+    pub fn endHyperlink(self: *StreamHandler) !void {
+        self.terminal.screen.endHyperlink();
+    }
+
+    pub fn deviceAttributes(
+        self: *StreamHandler,
+        req: terminal.DeviceAttributeReq,
+        params: []const u16,
+    ) !void {
+        _ = params;
+
+        // For the below, we quack as a VT220. We don't quack as
+        // a 420 because we don't support DCS sequences.
+        switch (req) {
+            .primary => self.messageWriter(.{
+                .write_stable = "\x1B[?62;22c",
+            }),
+
+            .secondary => self.messageWriter(.{
+                .write_stable = "\x1B[>1;10;0c",
+            }),
+
+            else => log.warn("unimplemented device attributes req: {}", .{req}),
+        }
+    }
+
+    pub fn deviceStatusReport(
+        self: *StreamHandler,
+        req: terminal.device_status.Request,
+    ) !void {
+        switch (req) {
+            .operating_status => self.messageWriter(.{ .write_stable = "\x1B[0n" }),
+
+            .cursor_position => {
+                const pos: struct {
+                    x: usize,
+                    y: usize,
+                } = if (self.terminal.modes.get(.origin)) .{
+                    .x = self.terminal.screen.cursor.x -| self.terminal.scrolling_region.left,
+                    .y = self.terminal.screen.cursor.y -| self.terminal.scrolling_region.top,
+                } else .{
+                    .x = self.terminal.screen.cursor.x,
+                    .y = self.terminal.screen.cursor.y,
+                };
+
+                // Response always is at least 4 chars, so this leaves the
+                // remainder for the row/column as base-10 numbers. This
+                // will support a very large terminal.
+                var msg: termio.Message = .{ .write_small = .{} };
+                const resp = try std.fmt.bufPrint(&msg.write_small.data, "\x1B[{};{}R", .{
+                    pos.y + 1,
+                    pos.x + 1,
+                });
+                msg.write_small.len = @intCast(resp.len);
+
+                self.messageWriter(msg);
+            },
+
+            .color_scheme => self.surfaceMessageWriter(.{ .report_color_scheme = {} }),
+        }
+    }
+
+    pub fn setCursorStyle(
+        self: *StreamHandler,
+        style: terminal.CursorStyleReq,
+    ) !void {
+        // Assume we're setting to a non-default.
+        self.default_cursor = false;
+
+        switch (style) {
+            .default => {
+                self.default_cursor = true;
+                self.terminal.screen.cursor.cursor_style = self.default_cursor_style;
+                self.terminal.modes.set(
+                    .cursor_blinking,
+                    self.default_cursor_blink orelse true,
+                );
+            },
+
+            .blinking_block => {
+                self.terminal.screen.cursor.cursor_style = .block;
+                self.terminal.modes.set(.cursor_blinking, true);
+            },
+
+            .steady_block => {
+                self.terminal.screen.cursor.cursor_style = .block;
+                self.terminal.modes.set(.cursor_blinking, false);
+            },
+
+            .blinking_underline => {
+                self.terminal.screen.cursor.cursor_style = .underline;
+                self.terminal.modes.set(.cursor_blinking, true);
+            },
+
+            .steady_underline => {
+                self.terminal.screen.cursor.cursor_style = .underline;
+                self.terminal.modes.set(.cursor_blinking, false);
+            },
+
+            .blinking_bar => {
+                self.terminal.screen.cursor.cursor_style = .bar;
+                self.terminal.modes.set(.cursor_blinking, true);
+            },
+
+            .steady_bar => {
+                self.terminal.screen.cursor.cursor_style = .bar;
+                self.terminal.modes.set(.cursor_blinking, false);
+            },
+
+            else => log.warn("unimplemented cursor style: {}", .{style}),
+        }
+    }
+
+    pub fn setProtectedMode(self: *StreamHandler, mode: terminal.ProtectedMode) !void {
+        self.terminal.setProtectedMode(mode);
+    }
+
+    pub fn decaln(self: *StreamHandler) !void {
+        try self.terminal.decaln();
+    }
+
+    pub fn tabClear(self: *StreamHandler, cmd: terminal.TabClear) !void {
+        self.terminal.tabClear(cmd);
+    }
+
+    pub fn tabSet(self: *StreamHandler) !void {
+        self.terminal.tabSet();
+    }
+
+    pub fn tabReset(self: *StreamHandler) !void {
+        self.terminal.tabReset();
+    }
+
+    pub fn saveCursor(self: *StreamHandler) !void {
+        self.terminal.saveCursor();
+    }
+
+    pub fn restoreCursor(self: *StreamHandler) !void {
+        try self.terminal.restoreCursor();
+    }
+
+    pub fn enquiry(self: *StreamHandler) !void {
+        log.debug("sending enquiry response={s}", .{self.enquiry_response});
+        self.messageWriter(try termio.Message.writeReq(self.alloc, self.enquiry_response));
+    }
+
+    pub fn scrollDown(self: *StreamHandler, count: usize) !void {
+        self.terminal.scrollDown(count);
+    }
+
+    pub fn scrollUp(self: *StreamHandler, count: usize) !void {
+        self.terminal.scrollUp(count);
+    }
+
+    pub fn setActiveStatusDisplay(
+        self: *StreamHandler,
+        req: terminal.StatusDisplay,
+    ) !void {
+        self.terminal.status_display = req;
+    }
+
+    pub fn configureCharset(
+        self: *StreamHandler,
+        slot: terminal.CharsetSlot,
+        set: terminal.Charset,
+    ) !void {
+        self.terminal.configureCharset(slot, set);
+    }
+
+    pub fn invokeCharset(
+        self: *StreamHandler,
+        active: terminal.CharsetActiveSlot,
+        slot: terminal.CharsetSlot,
+        single: bool,
+    ) !void {
+        self.terminal.invokeCharset(active, slot, single);
+    }
+
+    pub fn fullReset(
+        self: *StreamHandler,
+    ) !void {
+        self.terminal.fullReset();
+        try self.setMouseShape(.text);
+    }
+
+    pub fn queryKittyKeyboard(self: *StreamHandler) !void {
+        if (comptime disable_kitty_keyboard_protocol) return;
+
+        log.debug("querying kitty keyboard mode", .{});
+        var data: termio.Message.WriteReq.Small.Array = undefined;
+        const resp = try std.fmt.bufPrint(&data, "\x1b[?{}u", .{
+            self.terminal.screen.kitty_keyboard.current().int(),
+        });
+
+        self.messageWriter(.{
+            .write_small = .{
+                .data = data,
+                .len = @intCast(resp.len),
+            },
+        });
+    }
+
+    pub fn pushKittyKeyboard(
+        self: *StreamHandler,
+        flags: terminal.kitty.KeyFlags,
+    ) !void {
+        if (comptime disable_kitty_keyboard_protocol) return;
+
+        log.debug("pushing kitty keyboard mode: {}", .{flags});
+        self.terminal.screen.kitty_keyboard.push(flags);
+    }
+
+    pub fn popKittyKeyboard(self: *StreamHandler, n: u16) !void {
+        if (comptime disable_kitty_keyboard_protocol) return;
+
+        log.debug("popping kitty keyboard mode n={}", .{n});
+        self.terminal.screen.kitty_keyboard.pop(@intCast(n));
+    }
+
+    pub fn setKittyKeyboard(
+        self: *StreamHandler,
+        mode: terminal.kitty.KeySetMode,
+        flags: terminal.kitty.KeyFlags,
+    ) !void {
+        if (comptime disable_kitty_keyboard_protocol) return;
+
+        log.debug("setting kitty keyboard mode: {} {}", .{ mode, flags });
+        self.terminal.screen.kitty_keyboard.set(mode, flags);
+    }
+
+    pub fn reportXtversion(
+        self: *StreamHandler,
+    ) !void {
+        log.debug("reporting XTVERSION: ghostty {s}", .{build_config.version_string});
+        var buf: [288]u8 = undefined;
+        const resp = try std.fmt.bufPrint(
+            &buf,
+            "\x1BP>|{s} {s}\x1B\\",
+            .{
+                "ghostty",
+                build_config.version_string,
+            },
+        );
+        const msg = try termio.Message.writeReq(self.alloc, resp);
+        self.messageWriter(msg);
+    }
+
+    //-------------------------------------------------------------------------
+    // OSC
+
+    pub fn changeWindowTitle(self: *StreamHandler, title: []const u8) !void {
+        var buf: [256]u8 = undefined;
+        if (title.len >= buf.len) {
+            log.warn("change title requested larger than our buffer size, ignoring", .{});
+            return;
+        }
+
+        @memcpy(buf[0..title.len], title);
+        buf[title.len] = 0;
+
+        // Mark that we've seen a title
+        self.ev.seen_title = true;
+        self.surfaceMessageWriter(.{ .set_title = buf });
+    }
+
+    pub fn setMouseShape(
+        self: *StreamHandler,
+        shape: terminal.MouseShape,
+    ) !void {
+        // Avoid changing the shape it it is already set to avoid excess
+        // cross-thread messaging.
+        if (self.terminal.mouse_shape == shape) return;
+
+        self.terminal.mouse_shape = shape;
+        self.surfaceMessageWriter(.{ .set_mouse_shape = shape });
+    }
+
+    pub fn clipboardContents(self: *StreamHandler, kind: u8, data: []const u8) !void {
+        // Note: we ignore the "kind" field and always use the standard clipboard.
+        // iTerm also appears to do this but other terminals seem to only allow
+        // certain. Let's investigate more.
+
+        const clipboard_type: apprt.Clipboard = switch (kind) {
+            'c' => .standard,
+            's' => .selection,
+            'p' => .primary,
+            else => .standard,
+        };
+
+        // Get clipboard contents
+        if (data.len == 1 and data[0] == '?') {
+            self.surfaceMessageWriter(.{ .clipboard_read = clipboard_type });
+            return;
+        }
+
+        // Write clipboard contents
+        self.surfaceMessageWriter(.{
+            .clipboard_write = .{
+                .req = try apprt.surface.Message.WriteReq.init(
+                    self.alloc,
+                    data,
+                ),
+                .clipboard_type = clipboard_type,
+            },
+        });
+    }
+
+    pub fn promptStart(self: *StreamHandler, aid: ?[]const u8, redraw: bool) !void {
+        _ = aid;
+        self.terminal.markSemanticPrompt(.prompt);
+        self.terminal.flags.shell_redraws_prompt = redraw;
+    }
+
+    pub fn promptContinuation(self: *StreamHandler, aid: ?[]const u8) !void {
+        _ = aid;
+        self.terminal.markSemanticPrompt(.prompt_continuation);
+    }
+
+    pub fn promptEnd(self: *StreamHandler) !void {
+        self.terminal.markSemanticPrompt(.input);
+    }
+
+    pub fn endOfInput(self: *StreamHandler) !void {
+        self.terminal.markSemanticPrompt(.command);
+    }
+
+    pub fn reportPwd(self: *StreamHandler, url: []const u8) !void {
+        if (builtin.os.tag == .windows) {
+            log.warn("reportPwd unimplemented on windows", .{});
+            return;
+        }
+
+        const uri = std.Uri.parse(url) catch |e| {
+            log.warn("invalid url in OSC 7: {}", .{e});
+            return;
+        };
+
+        if (!std.mem.eql(u8, "file", uri.scheme) and
+            !std.mem.eql(u8, "kitty-shell-cwd", uri.scheme))
+        {
+            log.warn("OSC 7 scheme must be file, got: {s}", .{uri.scheme});
+            return;
+        }
+
+        // OSC 7 is a little sketchy because anyone can send any value from
+        // any host (such an SSH session). The best practice terminals follow
+        // is to valid the hostname to be local.
+        const host_valid = host_valid: {
+            const host_component = uri.host orelse break :host_valid false;
+
+            // Get the raw string of the URI. Its unclear to me if the various
+            // tags of this enum guarantee no percent-encoding so we just
+            // check all of it. This isn't a performance critical path.
+            const host = switch (host_component) {
+                .raw => |v| v,
+                .percent_encoded => |v| v,
+            };
+            if (host.len == 0 or std.mem.eql(u8, "localhost", host)) {
+                break :host_valid true;
+            }
+
+            // Otherwise, it must match our hostname.
+            var buf: [posix.HOST_NAME_MAX]u8 = undefined;
+            const hostname = posix.gethostname(&buf) catch |err| {
+                log.warn("failed to get hostname for OSC 7 validation: {}", .{err});
+                break :host_valid false;
+            };
+
+            break :host_valid std.mem.eql(u8, host, hostname);
+        };
+        if (!host_valid) {
+            log.warn("OSC 7 host must be local", .{});
+            return;
+        }
+
+        // We need to unescape the path. We first try to unescape onto
+        // the stack and fall back to heap allocation if we have to.
+        var pathBuf: [1024]u8 = undefined;
+        const path, const heap = path: {
+            // Get the raw string of the URI. Its unclear to me if the various
+            // tags of this enum guarantee no percent-encoding so we just
+            // check all of it. This isn't a performance critical path.
+            const path = switch (uri.path) {
+                .raw => |v| v,
+                .percent_encoded => |v| v,
+            };
+
+            // If the path doesn't have any escapes, we can use it directly.
+            if (std.mem.indexOfScalar(u8, path, '%') == null)
+                break :path .{ path, false };
+
+            // First try to stack-allocate
+            var fba = std.heap.FixedBufferAllocator.init(&pathBuf);
+            if (std.fmt.allocPrint(fba.allocator(), "{raw}", .{uri.path})) |v|
+                break :path .{ v, false }
+            else |_| {}
+
+            // Fall back to heap
+            if (std.fmt.allocPrint(self.alloc, "{raw}", .{uri.path})) |v|
+                break :path .{ v, true }
+            else |_| {}
+
+            // Fall back to using it directly...
+            log.warn("failed to unescape OSC 7 path, using it directly path={s}", .{path});
+            break :path .{ path, false };
+        };
+        defer if (heap) self.alloc.free(path);
+
+        log.debug("terminal pwd: {s}", .{path});
+        try self.terminal.setPwd(path);
+
+        // If we haven't seen a title, use our pwd as the title.
+        if (!self.ev.seen_title) {
+            try self.changeWindowTitle(path);
+            self.ev.seen_title = false;
+        }
+    }
+
+    /// Implements OSC 4, OSC 10, and OSC 11, which reports palette color,
+    /// default foreground color, and background color respectively.
+    pub fn reportColor(
+        self: *StreamHandler,
+        kind: terminal.osc.Command.ColorKind,
+        terminator: terminal.osc.Terminator,
+    ) !void {
+        if (self.osc_color_report_format == .none) return;
+
+        const color = switch (kind) {
+            .palette => |i| self.terminal.color_palette.colors[i],
+            .foreground => self.foreground_color,
+            .background => self.background_color,
+            .cursor => self.cursor_color orelse self.foreground_color,
+        };
+
+        var msg: termio.Message = .{ .write_small = .{} };
+        const resp = switch (self.osc_color_report_format) {
+            .@"16-bit" => switch (kind) {
+                .palette => |i| try std.fmt.bufPrint(
+                    &msg.write_small.data,
+                    "\x1B]{s};{d};rgb:{x:0>4}/{x:0>4}/{x:0>4}{s}",
+                    .{
+                        kind.code(),
+                        i,
+                        @as(u16, color.r) * 257,
+                        @as(u16, color.g) * 257,
+                        @as(u16, color.b) * 257,
+                        terminator.string(),
+                    },
+                ),
+                else => try std.fmt.bufPrint(
+                    &msg.write_small.data,
+                    "\x1B]{s};rgb:{x:0>4}/{x:0>4}/{x:0>4}{s}",
+                    .{
+                        kind.code(),
+                        @as(u16, color.r) * 257,
+                        @as(u16, color.g) * 257,
+                        @as(u16, color.b) * 257,
+                        terminator.string(),
+                    },
+                ),
+            },
+
+            .@"8-bit" => switch (kind) {
+                .palette => |i| try std.fmt.bufPrint(
+                    &msg.write_small.data,
+                    "\x1B]{s};{d};rgb:{x:0>2}/{x:0>2}/{x:0>2}{s}",
+                    .{
+                        kind.code(),
+                        i,
+                        @as(u16, color.r),
+                        @as(u16, color.g),
+                        @as(u16, color.b),
+                        terminator.string(),
+                    },
+                ),
+                else => try std.fmt.bufPrint(
+                    &msg.write_small.data,
+                    "\x1B]{s};rgb:{x:0>2}/{x:0>2}/{x:0>2}{s}",
+                    .{
+                        kind.code(),
+                        @as(u16, color.r),
+                        @as(u16, color.g),
+                        @as(u16, color.b),
+                        terminator.string(),
+                    },
+                ),
+            },
+            .none => unreachable, // early return above
+        };
+        msg.write_small.len = @intCast(resp.len);
+        self.messageWriter(msg);
+    }
+
+    pub fn setColor(
+        self: *StreamHandler,
+        kind: terminal.osc.Command.ColorKind,
+        value: []const u8,
+    ) !void {
+        const color = try terminal.color.RGB.parse(value);
+
+        switch (kind) {
+            .palette => |i| {
+                self.terminal.flags.dirty.palette = true;
+                self.terminal.color_palette.colors[i] = color;
+                self.terminal.color_palette.mask.set(i);
+            },
+            .foreground => {
+                self.foreground_color = color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .foreground_color = color,
+                }, .{ .forever = {} });
+            },
+            .background => {
+                self.background_color = color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .background_color = color,
+                }, .{ .forever = {} });
+            },
+            .cursor => {
+                self.cursor_color = color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .cursor_color = color,
+                }, .{ .forever = {} });
+            },
+        }
+    }
+
+    pub fn resetColor(
+        self: *StreamHandler,
+        kind: terminal.osc.Command.ColorKind,
+        value: []const u8,
+    ) !void {
+        switch (kind) {
+            .palette => {
+                const mask = &self.terminal.color_palette.mask;
+                if (value.len == 0) {
+                    // Find all bit positions in the mask which are set and
+                    // reset those indices to the default palette
+                    var it = mask.iterator(.{});
+                    while (it.next()) |i| {
+                        self.terminal.flags.dirty.palette = true;
+                        self.terminal.color_palette.colors[i] = self.terminal.default_palette[i];
+                        mask.unset(i);
+                    }
+                } else {
+                    var it = std.mem.tokenizeScalar(u8, value, ';');
+                    while (it.next()) |param| {
+                        // Skip invalid parameters
+                        const i = std.fmt.parseUnsigned(u8, param, 10) catch continue;
+                        if (mask.isSet(i)) {
+                            self.terminal.flags.dirty.palette = true;
+                            self.terminal.color_palette.colors[i] = self.terminal.default_palette[i];
+                            mask.unset(i);
+                        }
+                    }
+                }
+            },
+            .foreground => {
+                self.foreground_color = self.default_foreground_color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .foreground_color = self.foreground_color,
+                }, .{ .forever = {} });
+            },
+            .background => {
+                self.background_color = self.default_background_color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .background_color = self.background_color,
+                }, .{ .forever = {} });
+            },
+            .cursor => {
+                self.cursor_color = self.default_cursor_color;
+                _ = self.ev.renderer_mailbox.push(.{
+                    .cursor_color = self.cursor_color,
+                }, .{ .forever = {} });
+            },
+        }
+    }
+
+    pub fn showDesktopNotification(
+        self: *StreamHandler,
+        title: []const u8,
+        body: []const u8,
+    ) !void {
+        var message = apprt.surface.Message{ .desktop_notification = undefined };
+
+        const title_len = @min(title.len, message.desktop_notification.title.len);
+        @memcpy(message.desktop_notification.title[0..title_len], title[0..title_len]);
+        message.desktop_notification.title[title_len] = 0;
+
+        const body_len = @min(body.len, message.desktop_notification.body.len);
+        @memcpy(message.desktop_notification.body[0..body_len], body[0..body_len]);
+        message.desktop_notification.body[body_len] = 0;
+
+        self.surfaceMessageWriter(message);
+    }
+};

commit 4e6e0f90c755790d97f1a3e84e2459fbc20d9874
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 10:42:55 2024 -0700

    termio: remove data field

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 51a6b03c..f1c500f0 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -70,9 +70,6 @@ surface_mailbox: apprt.surface.Mailbox,
 /// The cached grid size whenever a resize is called.
 grid_size: renderer.GridSize,
 
-/// The data associated with the currently running thread.
-data: ?*EventData,
-
 /// The configuration for this IO that is derived from the main
 /// configuration. This must be exported so that we don't need to
 /// pass around Config pointers which makes memory management a pain.
@@ -194,7 +191,6 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
-        .data = null,
     };
 }
 
@@ -205,7 +201,6 @@ pub fn deinit(self: *Termio) void {
 }
 
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
-    assert(self.data == null);
     const alloc = self.alloc;
 
     // Start our subprocess
@@ -284,10 +279,6 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     };
     errdefer ev_data_ptr.deinit(self.alloc);
 
-    // Store our data so our callbacks can access it
-    self.data = ev_data_ptr;
-    errdefer self.data = null;
-
     // Start our process watcher
     process.wait(
         ev_data_ptr.loop,
@@ -341,9 +332,6 @@ fn execFailedInChild(self: *Termio) !void {
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
-    // Clear out our data since we're not active anymore.
-    self.data = null;
-
     // Stop our reader
     switch (data.reader) {
         .manual => {},

commit e51180e4a9bfde747aa268a43a19ad5996055acb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 10:54:04 2024 -0700

    termio: changeConfig on reader data

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index f1c500f0..432ce158 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -378,13 +378,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
     // renderer mutex so this is safe to do despite being executed
     // from another thread.
     td.ev.terminal_stream.handler.changeConfig(&self.config);
-    switch (td.reader) {
-        .manual => {},
-        .exec => |*exec| {
-            exec.abnormal_runtime_threshold_ms = config.abnormal_runtime_threshold_ms;
-            exec.wait_after_command = config.wait_after_command;
-        },
-    }
+    td.reader.changeConfig(&self.config);
 
     // Update the configuration that we know about.
     //

commit ffaf020576e76e67def887a02bb297744c774863
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 14:29:47 2024 -0700

    termio: move stream handler to dedicated file, remove dep on EventData

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 432ce158..0481a312 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -27,6 +27,8 @@ const windows = internal_os.windows;
 const configpkg = @import("../config.zig");
 const shell_integration = @import("shell_integration.zig");
 
+const StreamHandler = @import("stream_handler.zig").StreamHandler;
+
 const log = std.log.scoped(.io_exec);
 
 const c = @cImport({
@@ -249,6 +251,36 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     var process = try xev.Process.init(pid);
     errdefer process.deinit();
 
+    // Create our stream handler
+    const handler: StreamHandler = handler: {
+        const default_cursor_color = if (self.config.cursor_color) |col|
+            col.toTerminalRGB()
+        else
+            null;
+
+        break :handler .{
+            .alloc = self.alloc,
+            .writer_mailbox = thread.mailbox,
+            .writer_wakeup = thread.wakeup,
+            .surface_mailbox = self.surface_mailbox,
+            .renderer_state = self.renderer_state,
+            .renderer_wakeup = self.renderer_wakeup,
+            .renderer_mailbox = self.renderer_mailbox,
+            .grid_size = &self.grid_size,
+            .terminal = &self.terminal,
+            .osc_color_report_format = self.config.osc_color_report_format,
+            .enquiry_response = self.config.enquiry_response,
+            .default_foreground_color = self.config.foreground.toTerminalRGB(),
+            .default_background_color = self.config.background.toTerminalRGB(),
+            .default_cursor_style = self.config.cursor_style,
+            .default_cursor_blink = self.config.cursor_blink,
+            .default_cursor_color = default_cursor_color,
+            .cursor_color = default_cursor_color,
+            .foreground_color = self.config.foreground.toTerminalRGB(),
+            .background_color = self.config.background.toTerminalRGB(),
+        };
+    };
+
     // Setup our event data before we start
     ev_data_ptr.* = .{
         .writer_mailbox = thread.mailbox,
@@ -261,13 +293,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .data_stream = stream,
         .loop = &thread.loop,
         .terminal_stream = .{
-            .handler = StreamHandler.init(
-                self.alloc,
-                ev_data_ptr,
-                &self.grid_size,
-                &self.terminal,
-                &self.config,
-            ),
+            .handler = handler,
             .parser = .{
                 .osc_parser = .{
                     // Populate the OSC parser allocator (optional) because
@@ -754,7 +780,7 @@ pub const ThreadData = struct {
     }
 };
 
-const EventData = struct {
+pub const EventData = struct {
     // The preallocation size for the write request pool. This should be big
     // enough to satisfy most write requests. It must be a power of 2.
     const WRITE_REQ_PREALLOC = std.math.pow(usize, 2, 5);
@@ -807,10 +833,6 @@ const EventData = struct {
     /// flooding with cursor resets.
     last_cursor_reset: i64 = 0,
 
-    /// This is set to true when we've seen a title escape sequence. We use
-    /// this to determine if we need to default the window title.
-    seen_title: bool = false,
-
     pub fn deinit(self: *EventData, alloc: Allocator) void {
         // Clear our write pools. We know we aren't ever going to do
         // any more IO since we stop our data stream below so we can just
@@ -832,7 +854,7 @@ const EventData = struct {
     /// This queues a render operation with the renderer thread. The render
     /// isn't guaranteed to happen immediately but it will happen as soon as
     /// practical.
-    inline fn queueRender(self: *EventData) !void {
+    pub inline fn queueRender(self: *EventData) !void {
         try self.renderer_wakeup.notify();
     }
 };
@@ -1710,1260 +1732,3 @@ const ReadThread = struct {
         }
     }
 };
-
-/// This is used as the handler for the terminal.Stream type. This is
-/// stateful and is expected to live for the entire lifetime of the terminal.
-/// It is NOT VALID to stop a stream handler, create a new one, and use that
-/// unless all of the member fields are copied.
-const StreamHandler = struct {
-    ev: *EventData,
-    alloc: Allocator,
-    grid_size: *renderer.GridSize,
-    terminal: *terminal.Terminal,
-
-    /// The APC command handler maintains the APC state. APC is like
-    /// CSI or OSC, but it is a private escape sequence that is used
-    /// to send commands to the terminal emulator. This is used by
-    /// the kitty graphics protocol.
-    apc: terminal.apc.Handler = .{},
-
-    /// The DCS handler maintains DCS state. DCS is like CSI or OSC,
-    /// but requires more stateful parsing. This is used by functionality
-    /// such as XTGETTCAP.
-    dcs: terminal.dcs.Handler = .{},
-
-    /// This is set to true when a message was written to the writer
-    /// mailbox. This can be used by callers to determine if they need
-    /// to wake up the writer.
-    writer_messaged: bool = false,
-
-    /// The default cursor state. This is used with CSI q. This is
-    /// set to true when we're currently in the default cursor state.
-    default_cursor: bool = true,
-    default_cursor_style: terminal.CursorStyle,
-    default_cursor_blink: ?bool,
-    default_cursor_color: ?terminal.color.RGB,
-
-    /// Actual cursor color. This can be changed with OSC 12.
-    cursor_color: ?terminal.color.RGB,
-
-    /// The default foreground and background color are those set by the user's
-    /// config file. These can be overridden by terminal applications using OSC
-    /// 10 and OSC 11, respectively.
-    default_foreground_color: terminal.color.RGB,
-    default_background_color: terminal.color.RGB,
-
-    /// The actual foreground and background color. Normally this will be the
-    /// same as the default foreground and background color, unless changed by a
-    /// terminal application.
-    foreground_color: terminal.color.RGB,
-    background_color: terminal.color.RGB,
-
-    /// The response to use for ENQ requests. The memory is owned by
-    /// whoever owns StreamHandler.
-    enquiry_response: []const u8,
-
-    osc_color_report_format: configpkg.Config.OSCColorReportFormat,
-
-    pub fn init(
-        alloc: Allocator,
-        ev: *EventData,
-        grid_size: *renderer.GridSize,
-        t: *terminal.Terminal,
-        config: *const DerivedConfig,
-    ) StreamHandler {
-        const default_cursor_color = if (config.cursor_color) |col|
-            col.toTerminalRGB()
-        else
-            null;
-
-        return .{
-            .alloc = alloc,
-            .ev = ev,
-            .grid_size = grid_size,
-            .terminal = t,
-            .osc_color_report_format = config.osc_color_report_format,
-            .enquiry_response = config.enquiry_response,
-            .default_foreground_color = config.foreground.toTerminalRGB(),
-            .default_background_color = config.background.toTerminalRGB(),
-            .default_cursor_style = config.cursor_style,
-            .default_cursor_blink = config.cursor_blink,
-            .default_cursor_color = default_cursor_color,
-            .cursor_color = default_cursor_color,
-            .foreground_color = config.foreground.toTerminalRGB(),
-            .background_color = config.background.toTerminalRGB(),
-        };
-    }
-
-    pub fn deinit(self: *StreamHandler) void {
-        self.apc.deinit();
-        self.dcs.deinit();
-    }
-
-    /// Change the configuration for this handler.
-    pub fn changeConfig(self: *StreamHandler, config: *DerivedConfig) void {
-        self.osc_color_report_format = config.osc_color_report_format;
-        self.enquiry_response = config.enquiry_response;
-        self.default_foreground_color = config.foreground.toTerminalRGB();
-        self.default_background_color = config.background.toTerminalRGB();
-        self.default_cursor_style = config.cursor_style;
-        self.default_cursor_blink = config.cursor_blink;
-        self.default_cursor_color = if (config.cursor_color) |col|
-            col.toTerminalRGB()
-        else
-            null;
-
-        // If our cursor is the default, then we update it immediately.
-        if (self.default_cursor) self.setCursorStyle(.default) catch |err| {
-            log.warn("failed to set default cursor style: {}", .{err});
-        };
-    }
-
-    inline fn queueRender(self: *StreamHandler) !void {
-        try self.ev.queueRender();
-    }
-
-    inline fn surfaceMessageWriter(
-        self: *StreamHandler,
-        msg: apprt.surface.Message,
-    ) void {
-        // See messageWriter which has similar logic and explains why
-        // we may have to do this.
-        if (self.ev.surface_mailbox.push(msg, .{ .instant = {} }) == 0) {
-            self.ev.renderer_state.mutex.unlock();
-            defer self.ev.renderer_state.mutex.lock();
-            _ = self.ev.surface_mailbox.push(msg, .{ .forever = {} });
-        }
-    }
-
-    inline fn messageWriter(self: *StreamHandler, msg: termio.Message) void {
-        // Try to write to the mailbox with an instant timeout. This is the
-        // fast path because we can queue without a lock.
-        if (self.ev.writer_mailbox.push(msg, .{ .instant = {} }) == 0) {
-            // If we enter this conditional, the mailbox is full. We wake up
-            // the writer thread so that it can process messages to clear up
-            // space. However, the writer thread may require the renderer
-            // lock so we need to unlock.
-            self.ev.writer_wakeup.notify() catch |err| {
-                log.warn("failed to wake up writer, data will be dropped err={}", .{err});
-                return;
-            };
-
-            // Unlock the renderer state so the writer thread can acquire it.
-            // Then try to queue our message before continuing. This is a very
-            // slow path because we are having a lot of contention for data.
-            // But this only gets triggered in certain pathological cases.
-            //
-            // Note that writes themselves don't require a lock, but there
-            // are other messages in the writer mailbox (resize, focus) that
-            // could acquire the lock. This is why we have to release our lock
-            // here.
-            self.ev.renderer_state.mutex.unlock();
-            defer self.ev.renderer_state.mutex.lock();
-            _ = self.ev.writer_mailbox.push(msg, .{ .forever = {} });
-        }
-
-        // Normally, we just flag this true to wake up the writer thread
-        // once per batch of data.
-        self.writer_messaged = true;
-    }
-
-    pub fn dcsHook(self: *StreamHandler, dcs: terminal.DCS) !void {
-        self.dcs.hook(self.alloc, dcs);
-    }
-
-    pub fn dcsPut(self: *StreamHandler, byte: u8) !void {
-        self.dcs.put(byte);
-    }
-
-    pub fn dcsUnhook(self: *StreamHandler) !void {
-        var cmd = self.dcs.unhook() orelse return;
-        defer cmd.deinit();
-
-        // log.warn("DCS command: {}", .{cmd});
-        switch (cmd) {
-            .xtgettcap => |*gettcap| {
-                const map = comptime terminfo.ghostty.xtgettcapMap();
-                while (gettcap.next()) |key| {
-                    const response = map.get(key) orelse continue;
-                    self.messageWriter(.{ .write_stable = response });
-                }
-            },
-            .decrqss => |decrqss| {
-                var response: [128]u8 = undefined;
-                var stream = std.io.fixedBufferStream(&response);
-                const writer = stream.writer();
-
-                // Offset the stream position to just past the response prefix.
-                // We will write the "payload" (if any) below. If no payload is
-                // written then we send an invalid DECRPSS response.
-                const prefix_fmt = "\x1bP{d}$r";
-                const prefix_len = std.fmt.comptimePrint(prefix_fmt, .{0}).len;
-                stream.pos = prefix_len;
-
-                switch (decrqss) {
-                    // Invalid or unhandled request
-                    .none => {},
-
-                    .sgr => {
-                        const buf = try self.terminal.printAttributes(stream.buffer[stream.pos..]);
-
-                        // printAttributes wrote into our buffer, so adjust the stream
-                        // position
-                        stream.pos += buf.len;
-
-                        try writer.writeByte('m');
-                    },
-
-                    .decscusr => {
-                        const blink = self.terminal.modes.get(.cursor_blinking);
-                        const style: u8 = switch (self.terminal.screen.cursor.cursor_style) {
-                            .block => if (blink) 1 else 2,
-                            .underline => if (blink) 3 else 4,
-                            .bar => if (blink) 5 else 6,
-                        };
-                        try writer.print("{d} q", .{style});
-                    },
-
-                    .decstbm => {
-                        try writer.print("{d};{d}r", .{
-                            self.terminal.scrolling_region.top + 1,
-                            self.terminal.scrolling_region.bottom + 1,
-                        });
-                    },
-
-                    .decslrm => {
-                        // We only send a valid response when left and right
-                        // margin mode (DECLRMM) is enabled.
-                        if (self.terminal.modes.get(.enable_left_and_right_margin)) {
-                            try writer.print("{d};{d}s", .{
-                                self.terminal.scrolling_region.left + 1,
-                                self.terminal.scrolling_region.right + 1,
-                            });
-                        }
-                    },
-                }
-
-                // Our response is valid if we have a response payload
-                const valid = stream.pos > prefix_len;
-
-                // Write the terminator
-                try writer.writeAll("\x1b\\");
-
-                // Write the response prefix into the buffer
-                _ = try std.fmt.bufPrint(response[0..prefix_len], prefix_fmt, .{@intFromBool(valid)});
-                const msg = try termio.Message.writeReq(self.alloc, response[0..stream.pos]);
-                self.messageWriter(msg);
-            },
-        }
-    }
-
-    pub fn apcStart(self: *StreamHandler) !void {
-        self.apc.start();
-    }
-
-    pub fn apcPut(self: *StreamHandler, byte: u8) !void {
-        self.apc.feed(self.alloc, byte);
-    }
-
-    pub fn apcEnd(self: *StreamHandler) !void {
-        var cmd = self.apc.end() orelse return;
-        defer cmd.deinit(self.alloc);
-
-        // log.warn("APC command: {}", .{cmd});
-        switch (cmd) {
-            .kitty => |*kitty_cmd| {
-                if (self.terminal.kittyGraphics(self.alloc, kitty_cmd)) |resp| {
-                    var buf: [1024]u8 = undefined;
-                    var buf_stream = std.io.fixedBufferStream(&buf);
-                    try resp.encode(buf_stream.writer());
-                    const final = buf_stream.getWritten();
-                    if (final.len > 2) {
-                        // log.warn("kitty graphics response: {s}", .{std.fmt.fmtSliceHexLower(final)});
-                        self.messageWriter(try termio.Message.writeReq(self.alloc, final));
-                    }
-                }
-            },
-        }
-    }
-
-    pub fn print(self: *StreamHandler, ch: u21) !void {
-        try self.terminal.print(ch);
-    }
-
-    pub fn printRepeat(self: *StreamHandler, count: usize) !void {
-        try self.terminal.printRepeat(count);
-    }
-
-    pub fn bell(self: StreamHandler) !void {
-        _ = self;
-        log.info("BELL", .{});
-    }
-
-    pub fn backspace(self: *StreamHandler) !void {
-        self.terminal.backspace();
-    }
-
-    pub fn horizontalTab(self: *StreamHandler, count: u16) !void {
-        for (0..count) |_| {
-            const x = self.terminal.screen.cursor.x;
-            try self.terminal.horizontalTab();
-            if (x == self.terminal.screen.cursor.x) break;
-        }
-    }
-
-    pub fn horizontalTabBack(self: *StreamHandler, count: u16) !void {
-        for (0..count) |_| {
-            const x = self.terminal.screen.cursor.x;
-            try self.terminal.horizontalTabBack();
-            if (x == self.terminal.screen.cursor.x) break;
-        }
-    }
-
-    pub fn linefeed(self: *StreamHandler) !void {
-        // Small optimization: call index instead of linefeed because they're
-        // identical and this avoids one layer of function call overhead.
-        try self.terminal.index();
-    }
-
-    pub fn carriageReturn(self: *StreamHandler) !void {
-        self.terminal.carriageReturn();
-    }
-
-    pub fn setCursorLeft(self: *StreamHandler, amount: u16) !void {
-        self.terminal.cursorLeft(amount);
-    }
-
-    pub fn setCursorRight(self: *StreamHandler, amount: u16) !void {
-        self.terminal.cursorRight(amount);
-    }
-
-    pub fn setCursorDown(self: *StreamHandler, amount: u16, carriage: bool) !void {
-        self.terminal.cursorDown(amount);
-        if (carriage) self.terminal.carriageReturn();
-    }
-
-    pub fn setCursorUp(self: *StreamHandler, amount: u16, carriage: bool) !void {
-        self.terminal.cursorUp(amount);
-        if (carriage) self.terminal.carriageReturn();
-    }
-
-    pub fn setCursorCol(self: *StreamHandler, col: u16) !void {
-        self.terminal.setCursorPos(self.terminal.screen.cursor.y + 1, col);
-    }
-
-    pub fn setCursorColRelative(self: *StreamHandler, offset: u16) !void {
-        self.terminal.setCursorPos(
-            self.terminal.screen.cursor.y + 1,
-            self.terminal.screen.cursor.x + 1 +| offset,
-        );
-    }
-
-    pub fn setCursorRow(self: *StreamHandler, row: u16) !void {
-        self.terminal.setCursorPos(row, self.terminal.screen.cursor.x + 1);
-    }
-
-    pub fn setCursorRowRelative(self: *StreamHandler, offset: u16) !void {
-        self.terminal.setCursorPos(
-            self.terminal.screen.cursor.y + 1 +| offset,
-            self.terminal.screen.cursor.x + 1,
-        );
-    }
-
-    pub fn setCursorPos(self: *StreamHandler, row: u16, col: u16) !void {
-        self.terminal.setCursorPos(row, col);
-    }
-
-    pub fn eraseDisplay(self: *StreamHandler, mode: terminal.EraseDisplay, protected: bool) !void {
-        if (mode == .complete) {
-            // Whenever we erase the full display, scroll to bottom.
-            try self.terminal.scrollViewport(.{ .bottom = {} });
-            try self.queueRender();
-        }
-
-        self.terminal.eraseDisplay(mode, protected);
-    }
-
-    pub fn eraseLine(self: *StreamHandler, mode: terminal.EraseLine, protected: bool) !void {
-        self.terminal.eraseLine(mode, protected);
-    }
-
-    pub fn deleteChars(self: *StreamHandler, count: usize) !void {
-        self.terminal.deleteChars(count);
-    }
-
-    pub fn eraseChars(self: *StreamHandler, count: usize) !void {
-        self.terminal.eraseChars(count);
-    }
-
-    pub fn insertLines(self: *StreamHandler, count: usize) !void {
-        self.terminal.insertLines(count);
-    }
-
-    pub fn insertBlanks(self: *StreamHandler, count: usize) !void {
-        self.terminal.insertBlanks(count);
-    }
-
-    pub fn deleteLines(self: *StreamHandler, count: usize) !void {
-        self.terminal.deleteLines(count);
-    }
-
-    pub fn reverseIndex(self: *StreamHandler) !void {
-        self.terminal.reverseIndex();
-    }
-
-    pub fn index(self: *StreamHandler) !void {
-        try self.terminal.index();
-    }
-
-    pub fn nextLine(self: *StreamHandler) !void {
-        try self.terminal.index();
-        self.terminal.carriageReturn();
-    }
-
-    pub fn setTopAndBottomMargin(self: *StreamHandler, top: u16, bot: u16) !void {
-        self.terminal.setTopAndBottomMargin(top, bot);
-    }
-
-    pub fn setLeftAndRightMarginAmbiguous(self: *StreamHandler) !void {
-        if (self.terminal.modes.get(.enable_left_and_right_margin)) {
-            try self.setLeftAndRightMargin(0, 0);
-        } else {
-            try self.saveCursor();
-        }
-    }
-
-    pub fn setLeftAndRightMargin(self: *StreamHandler, left: u16, right: u16) !void {
-        self.terminal.setLeftAndRightMargin(left, right);
-    }
-
-    pub fn setModifyKeyFormat(self: *StreamHandler, format: terminal.ModifyKeyFormat) !void {
-        self.terminal.flags.modify_other_keys_2 = false;
-        switch (format) {
-            .other_keys => |v| switch (v) {
-                .numeric => self.terminal.flags.modify_other_keys_2 = true,
-                else => {},
-            },
-            else => {},
-        }
-    }
-
-    pub fn requestMode(self: *StreamHandler, mode_raw: u16, ansi: bool) !void {
-        // Get the mode value and respond.
-        const code: u8 = code: {
-            const mode = terminal.modes.modeFromInt(mode_raw, ansi) orelse break :code 0;
-            if (self.terminal.modes.get(mode)) break :code 1;
-            break :code 2;
-        };
-
-        var msg: termio.Message = .{ .write_small = .{} };
-        const resp = try std.fmt.bufPrint(
-            &msg.write_small.data,
-            "\x1B[{s}{};{}$y",
-            .{
-                if (ansi) "" else "?",
-                mode_raw,
-                code,
-            },
-        );
-        msg.write_small.len = @intCast(resp.len);
-        self.messageWriter(msg);
-    }
-
-    pub fn saveMode(self: *StreamHandler, mode: terminal.Mode) !void {
-        // log.debug("save mode={}", .{mode});
-        self.terminal.modes.save(mode);
-    }
-
-    pub fn restoreMode(self: *StreamHandler, mode: terminal.Mode) !void {
-        // For restore mode we have to restore but if we set it, we
-        // always have to call setMode because setting some modes have
-        // side effects and we want to make sure we process those.
-        const v = self.terminal.modes.restore(mode);
-        // log.debug("restore mode={} v={}", .{ mode, v });
-        try self.setMode(mode, v);
-    }
-
-    pub fn setMode(self: *StreamHandler, mode: terminal.Mode, enabled: bool) !void {
-        // Note: this function doesn't need to grab the render state or
-        // terminal locks because it is only called from process() which
-        // grabs the lock.
-
-        // If we are setting cursor blinking, we ignore it if we have
-        // a default cursor blink setting set. This is a really weird
-        // behavior so this comment will go deep into trying to explain it.
-        //
-        // There are two ways to set cursor blinks: DECSCUSR (CSI _ q)
-        // and DEC mode 12. DECSCUSR is the modern approach and has a
-        // way to revert to the "default" (as defined by the terminal)
-        // cursor style and blink by doing "CSI 0 q". DEC mode 12 controls
-        // blinking and is either on or off and has no way to set a
-        // default. DEC mode 12 is also the more antiquated approach.
-        //
-        // The problem is that if the user specifies a desired default
-        // cursor blink with `cursor-style-blink`, the moment a running
-        // program uses DEC mode 12, the cursor blink can never be reset
-        // to the default without an explicit DECSCUSR. But if a program
-        // is using mode 12, it is by definition not using DECSCUSR.
-        // This makes for somewhat annoying interactions where a poorly
-        // (or legacy) behaved program will stop blinking, and it simply
-        // never restarts.
-        //
-        // To get around this, we have a special case where if the user
-        // specifies some explicit default cursor blink desire, we ignore
-        // DEC mode 12. We allow DECSCUSR to still set the cursor blink
-        // because programs using DECSCUSR usually are well behaved and
-        // reset the cursor blink to the default when they exit.
-        //
-        // To be extra safe, users can also add a manual `CSI 0 q` to
-        // their shell config when they render prompts to ensure the
-        // cursor is exactly as they request.
-        if (mode == .cursor_blinking and
-            self.default_cursor_blink != null)
-        {
-            return;
-        }
-
-        // We first always set the raw mode on our mode state.
-        self.terminal.modes.set(mode, enabled);
-
-        // And then some modes require additional processing.
-        switch (mode) {
-            // Just noting here that autorepeat has no effect on
-            // the terminal. xterm ignores this mode and so do we.
-            // We know about just so that we don't log that it is
-            // an unknown mode.
-            .autorepeat => {},
-
-            // Schedule a render since we changed colors
-            .reverse_colors => {
-                self.terminal.flags.dirty.reverse_colors = true;
-                try self.queueRender();
-            },
-
-            // Origin resets cursor pos. This is called whether or not
-            // we're enabling or disabling origin mode and whether or
-            // not the value changed.
-            .origin => self.terminal.setCursorPos(1, 1),
-
-            .enable_left_and_right_margin => if (!enabled) {
-                // When we disable left/right margin mode we need to
-                // reset the left/right margins.
-                self.terminal.scrolling_region.left = 0;
-                self.terminal.scrolling_region.right = self.terminal.cols - 1;
-            },
-
-            .alt_screen => {
-                const opts: terminal.Terminal.AlternateScreenOptions = .{
-                    .cursor_save = false,
-                    .clear_on_enter = false,
-                };
-
-                if (enabled)
-                    self.terminal.alternateScreen(opts)
-                else
-                    self.terminal.primaryScreen(opts);
-
-                // Schedule a render since we changed screens
-                try self.queueRender();
-            },
-
-            .alt_screen_save_cursor_clear_enter => {
-                const opts: terminal.Terminal.AlternateScreenOptions = .{
-                    .cursor_save = true,
-                    .clear_on_enter = true,
-                };
-
-                if (enabled)
-                    self.terminal.alternateScreen(opts)
-                else
-                    self.terminal.primaryScreen(opts);
-
-                // Schedule a render since we changed screens
-                try self.queueRender();
-            },
-
-            // Force resize back to the window size
-            .enable_mode_3 => self.terminal.resize(
-                self.alloc,
-                self.grid_size.columns,
-                self.grid_size.rows,
-            ) catch |err| {
-                log.err("error updating terminal size: {}", .{err});
-            },
-
-            .@"132_column" => try self.terminal.deccolm(
-                self.alloc,
-                if (enabled) .@"132_cols" else .@"80_cols",
-            ),
-
-            // We need to start a timer to prevent the emulator being hung
-            // forever.
-            .synchronized_output => {
-                if (enabled) self.messageWriter(.{ .start_synchronized_output = {} });
-                try self.queueRender();
-            },
-
-            .linefeed => {
-                self.messageWriter(.{ .linefeed_mode = enabled });
-            },
-
-            .mouse_event_x10 => {
-                if (enabled) {
-                    self.terminal.flags.mouse_event = .x10;
-                    try self.setMouseShape(.default);
-                } else {
-                    self.terminal.flags.mouse_event = .none;
-                    try self.setMouseShape(.text);
-                }
-            },
-            .mouse_event_normal => {
-                if (enabled) {
-                    self.terminal.flags.mouse_event = .normal;
-                    try self.setMouseShape(.default);
-                } else {
-                    self.terminal.flags.mouse_event = .none;
-                    try self.setMouseShape(.text);
-                }
-            },
-            .mouse_event_button => {
-                if (enabled) {
-                    self.terminal.flags.mouse_event = .button;
-                    try self.setMouseShape(.default);
-                } else {
-                    self.terminal.flags.mouse_event = .none;
-                    try self.setMouseShape(.text);
-                }
-            },
-            .mouse_event_any => {
-                if (enabled) {
-                    self.terminal.flags.mouse_event = .any;
-                    try self.setMouseShape(.default);
-                } else {
-                    self.terminal.flags.mouse_event = .none;
-                    try self.setMouseShape(.text);
-                }
-            },
-
-            .mouse_format_utf8 => self.terminal.flags.mouse_format = if (enabled) .utf8 else .x10,
-            .mouse_format_sgr => self.terminal.flags.mouse_format = if (enabled) .sgr else .x10,
-            .mouse_format_urxvt => self.terminal.flags.mouse_format = if (enabled) .urxvt else .x10,
-            .mouse_format_sgr_pixels => self.terminal.flags.mouse_format = if (enabled) .sgr_pixels else .x10,
-
-            else => {},
-        }
-    }
-
-    pub fn setMouseShiftCapture(self: *StreamHandler, v: bool) !void {
-        self.terminal.flags.mouse_shift_capture = if (v) .true else .false;
-    }
-
-    pub fn setAttribute(self: *StreamHandler, attr: terminal.Attribute) !void {
-        switch (attr) {
-            .unknown => |unk| log.warn("unimplemented or unknown SGR attribute: {any}", .{unk}),
-
-            else => self.terminal.setAttribute(attr) catch |err|
-                log.warn("error setting attribute {}: {}", .{ attr, err }),
-        }
-    }
-
-    pub fn startHyperlink(self: *StreamHandler, uri: []const u8, id: ?[]const u8) !void {
-        try self.terminal.screen.startHyperlink(uri, id);
-    }
-
-    pub fn endHyperlink(self: *StreamHandler) !void {
-        self.terminal.screen.endHyperlink();
-    }
-
-    pub fn deviceAttributes(
-        self: *StreamHandler,
-        req: terminal.DeviceAttributeReq,
-        params: []const u16,
-    ) !void {
-        _ = params;
-
-        // For the below, we quack as a VT220. We don't quack as
-        // a 420 because we don't support DCS sequences.
-        switch (req) {
-            .primary => self.messageWriter(.{
-                .write_stable = "\x1B[?62;22c",
-            }),
-
-            .secondary => self.messageWriter(.{
-                .write_stable = "\x1B[>1;10;0c",
-            }),
-
-            else => log.warn("unimplemented device attributes req: {}", .{req}),
-        }
-    }
-
-    pub fn deviceStatusReport(
-        self: *StreamHandler,
-        req: terminal.device_status.Request,
-    ) !void {
-        switch (req) {
-            .operating_status => self.messageWriter(.{ .write_stable = "\x1B[0n" }),
-
-            .cursor_position => {
-                const pos: struct {
-                    x: usize,
-                    y: usize,
-                } = if (self.terminal.modes.get(.origin)) .{
-                    .x = self.terminal.screen.cursor.x -| self.terminal.scrolling_region.left,
-                    .y = self.terminal.screen.cursor.y -| self.terminal.scrolling_region.top,
-                } else .{
-                    .x = self.terminal.screen.cursor.x,
-                    .y = self.terminal.screen.cursor.y,
-                };
-
-                // Response always is at least 4 chars, so this leaves the
-                // remainder for the row/column as base-10 numbers. This
-                // will support a very large terminal.
-                var msg: termio.Message = .{ .write_small = .{} };
-                const resp = try std.fmt.bufPrint(&msg.write_small.data, "\x1B[{};{}R", .{
-                    pos.y + 1,
-                    pos.x + 1,
-                });
-                msg.write_small.len = @intCast(resp.len);
-
-                self.messageWriter(msg);
-            },
-
-            .color_scheme => self.surfaceMessageWriter(.{ .report_color_scheme = {} }),
-        }
-    }
-
-    pub fn setCursorStyle(
-        self: *StreamHandler,
-        style: terminal.CursorStyleReq,
-    ) !void {
-        // Assume we're setting to a non-default.
-        self.default_cursor = false;
-
-        switch (style) {
-            .default => {
-                self.default_cursor = true;
-                self.terminal.screen.cursor.cursor_style = self.default_cursor_style;
-                self.terminal.modes.set(
-                    .cursor_blinking,
-                    self.default_cursor_blink orelse true,
-                );
-            },
-
-            .blinking_block => {
-                self.terminal.screen.cursor.cursor_style = .block;
-                self.terminal.modes.set(.cursor_blinking, true);
-            },
-
-            .steady_block => {
-                self.terminal.screen.cursor.cursor_style = .block;
-                self.terminal.modes.set(.cursor_blinking, false);
-            },
-
-            .blinking_underline => {
-                self.terminal.screen.cursor.cursor_style = .underline;
-                self.terminal.modes.set(.cursor_blinking, true);
-            },
-
-            .steady_underline => {
-                self.terminal.screen.cursor.cursor_style = .underline;
-                self.terminal.modes.set(.cursor_blinking, false);
-            },
-
-            .blinking_bar => {
-                self.terminal.screen.cursor.cursor_style = .bar;
-                self.terminal.modes.set(.cursor_blinking, true);
-            },
-
-            .steady_bar => {
-                self.terminal.screen.cursor.cursor_style = .bar;
-                self.terminal.modes.set(.cursor_blinking, false);
-            },
-
-            else => log.warn("unimplemented cursor style: {}", .{style}),
-        }
-    }
-
-    pub fn setProtectedMode(self: *StreamHandler, mode: terminal.ProtectedMode) !void {
-        self.terminal.setProtectedMode(mode);
-    }
-
-    pub fn decaln(self: *StreamHandler) !void {
-        try self.terminal.decaln();
-    }
-
-    pub fn tabClear(self: *StreamHandler, cmd: terminal.TabClear) !void {
-        self.terminal.tabClear(cmd);
-    }
-
-    pub fn tabSet(self: *StreamHandler) !void {
-        self.terminal.tabSet();
-    }
-
-    pub fn tabReset(self: *StreamHandler) !void {
-        self.terminal.tabReset();
-    }
-
-    pub fn saveCursor(self: *StreamHandler) !void {
-        self.terminal.saveCursor();
-    }
-
-    pub fn restoreCursor(self: *StreamHandler) !void {
-        try self.terminal.restoreCursor();
-    }
-
-    pub fn enquiry(self: *StreamHandler) !void {
-        log.debug("sending enquiry response={s}", .{self.enquiry_response});
-        self.messageWriter(try termio.Message.writeReq(self.alloc, self.enquiry_response));
-    }
-
-    pub fn scrollDown(self: *StreamHandler, count: usize) !void {
-        self.terminal.scrollDown(count);
-    }
-
-    pub fn scrollUp(self: *StreamHandler, count: usize) !void {
-        self.terminal.scrollUp(count);
-    }
-
-    pub fn setActiveStatusDisplay(
-        self: *StreamHandler,
-        req: terminal.StatusDisplay,
-    ) !void {
-        self.terminal.status_display = req;
-    }
-
-    pub fn configureCharset(
-        self: *StreamHandler,
-        slot: terminal.CharsetSlot,
-        set: terminal.Charset,
-    ) !void {
-        self.terminal.configureCharset(slot, set);
-    }
-
-    pub fn invokeCharset(
-        self: *StreamHandler,
-        active: terminal.CharsetActiveSlot,
-        slot: terminal.CharsetSlot,
-        single: bool,
-    ) !void {
-        self.terminal.invokeCharset(active, slot, single);
-    }
-
-    pub fn fullReset(
-        self: *StreamHandler,
-    ) !void {
-        self.terminal.fullReset();
-        try self.setMouseShape(.text);
-    }
-
-    pub fn queryKittyKeyboard(self: *StreamHandler) !void {
-        if (comptime disable_kitty_keyboard_protocol) return;
-
-        log.debug("querying kitty keyboard mode", .{});
-        var data: termio.Message.WriteReq.Small.Array = undefined;
-        const resp = try std.fmt.bufPrint(&data, "\x1b[?{}u", .{
-            self.terminal.screen.kitty_keyboard.current().int(),
-        });
-
-        self.messageWriter(.{
-            .write_small = .{
-                .data = data,
-                .len = @intCast(resp.len),
-            },
-        });
-    }
-
-    pub fn pushKittyKeyboard(
-        self: *StreamHandler,
-        flags: terminal.kitty.KeyFlags,
-    ) !void {
-        if (comptime disable_kitty_keyboard_protocol) return;
-
-        log.debug("pushing kitty keyboard mode: {}", .{flags});
-        self.terminal.screen.kitty_keyboard.push(flags);
-    }
-
-    pub fn popKittyKeyboard(self: *StreamHandler, n: u16) !void {
-        if (comptime disable_kitty_keyboard_protocol) return;
-
-        log.debug("popping kitty keyboard mode n={}", .{n});
-        self.terminal.screen.kitty_keyboard.pop(@intCast(n));
-    }
-
-    pub fn setKittyKeyboard(
-        self: *StreamHandler,
-        mode: terminal.kitty.KeySetMode,
-        flags: terminal.kitty.KeyFlags,
-    ) !void {
-        if (comptime disable_kitty_keyboard_protocol) return;
-
-        log.debug("setting kitty keyboard mode: {} {}", .{ mode, flags });
-        self.terminal.screen.kitty_keyboard.set(mode, flags);
-    }
-
-    pub fn reportXtversion(
-        self: *StreamHandler,
-    ) !void {
-        log.debug("reporting XTVERSION: ghostty {s}", .{build_config.version_string});
-        var buf: [288]u8 = undefined;
-        const resp = try std.fmt.bufPrint(
-            &buf,
-            "\x1BP>|{s} {s}\x1B\\",
-            .{
-                "ghostty",
-                build_config.version_string,
-            },
-        );
-        const msg = try termio.Message.writeReq(self.alloc, resp);
-        self.messageWriter(msg);
-    }
-
-    //-------------------------------------------------------------------------
-    // OSC
-
-    pub fn changeWindowTitle(self: *StreamHandler, title: []const u8) !void {
-        var buf: [256]u8 = undefined;
-        if (title.len >= buf.len) {
-            log.warn("change title requested larger than our buffer size, ignoring", .{});
-            return;
-        }
-
-        @memcpy(buf[0..title.len], title);
-        buf[title.len] = 0;
-
-        // Mark that we've seen a title
-        self.ev.seen_title = true;
-        self.surfaceMessageWriter(.{ .set_title = buf });
-    }
-
-    pub fn setMouseShape(
-        self: *StreamHandler,
-        shape: terminal.MouseShape,
-    ) !void {
-        // Avoid changing the shape it it is already set to avoid excess
-        // cross-thread messaging.
-        if (self.terminal.mouse_shape == shape) return;
-
-        self.terminal.mouse_shape = shape;
-        self.surfaceMessageWriter(.{ .set_mouse_shape = shape });
-    }
-
-    pub fn clipboardContents(self: *StreamHandler, kind: u8, data: []const u8) !void {
-        // Note: we ignore the "kind" field and always use the standard clipboard.
-        // iTerm also appears to do this but other terminals seem to only allow
-        // certain. Let's investigate more.
-
-        const clipboard_type: apprt.Clipboard = switch (kind) {
-            'c' => .standard,
-            's' => .selection,
-            'p' => .primary,
-            else => .standard,
-        };
-
-        // Get clipboard contents
-        if (data.len == 1 and data[0] == '?') {
-            self.surfaceMessageWriter(.{ .clipboard_read = clipboard_type });
-            return;
-        }
-
-        // Write clipboard contents
-        self.surfaceMessageWriter(.{
-            .clipboard_write = .{
-                .req = try apprt.surface.Message.WriteReq.init(
-                    self.alloc,
-                    data,
-                ),
-                .clipboard_type = clipboard_type,
-            },
-        });
-    }
-
-    pub fn promptStart(self: *StreamHandler, aid: ?[]const u8, redraw: bool) !void {
-        _ = aid;
-        self.terminal.markSemanticPrompt(.prompt);
-        self.terminal.flags.shell_redraws_prompt = redraw;
-    }
-
-    pub fn promptContinuation(self: *StreamHandler, aid: ?[]const u8) !void {
-        _ = aid;
-        self.terminal.markSemanticPrompt(.prompt_continuation);
-    }
-
-    pub fn promptEnd(self: *StreamHandler) !void {
-        self.terminal.markSemanticPrompt(.input);
-    }
-
-    pub fn endOfInput(self: *StreamHandler) !void {
-        self.terminal.markSemanticPrompt(.command);
-    }
-
-    pub fn reportPwd(self: *StreamHandler, url: []const u8) !void {
-        if (builtin.os.tag == .windows) {
-            log.warn("reportPwd unimplemented on windows", .{});
-            return;
-        }
-
-        const uri = std.Uri.parse(url) catch |e| {
-            log.warn("invalid url in OSC 7: {}", .{e});
-            return;
-        };
-
-        if (!std.mem.eql(u8, "file", uri.scheme) and
-            !std.mem.eql(u8, "kitty-shell-cwd", uri.scheme))
-        {
-            log.warn("OSC 7 scheme must be file, got: {s}", .{uri.scheme});
-            return;
-        }
-
-        // OSC 7 is a little sketchy because anyone can send any value from
-        // any host (such an SSH session). The best practice terminals follow
-        // is to valid the hostname to be local.
-        const host_valid = host_valid: {
-            const host_component = uri.host orelse break :host_valid false;
-
-            // Get the raw string of the URI. Its unclear to me if the various
-            // tags of this enum guarantee no percent-encoding so we just
-            // check all of it. This isn't a performance critical path.
-            const host = switch (host_component) {
-                .raw => |v| v,
-                .percent_encoded => |v| v,
-            };
-            if (host.len == 0 or std.mem.eql(u8, "localhost", host)) {
-                break :host_valid true;
-            }
-
-            // Otherwise, it must match our hostname.
-            var buf: [posix.HOST_NAME_MAX]u8 = undefined;
-            const hostname = posix.gethostname(&buf) catch |err| {
-                log.warn("failed to get hostname for OSC 7 validation: {}", .{err});
-                break :host_valid false;
-            };
-
-            break :host_valid std.mem.eql(u8, host, hostname);
-        };
-        if (!host_valid) {
-            log.warn("OSC 7 host must be local", .{});
-            return;
-        }
-
-        // We need to unescape the path. We first try to unescape onto
-        // the stack and fall back to heap allocation if we have to.
-        var pathBuf: [1024]u8 = undefined;
-        const path, const heap = path: {
-            // Get the raw string of the URI. Its unclear to me if the various
-            // tags of this enum guarantee no percent-encoding so we just
-            // check all of it. This isn't a performance critical path.
-            const path = switch (uri.path) {
-                .raw => |v| v,
-                .percent_encoded => |v| v,
-            };
-
-            // If the path doesn't have any escapes, we can use it directly.
-            if (std.mem.indexOfScalar(u8, path, '%') == null)
-                break :path .{ path, false };
-
-            // First try to stack-allocate
-            var fba = std.heap.FixedBufferAllocator.init(&pathBuf);
-            if (std.fmt.allocPrint(fba.allocator(), "{raw}", .{uri.path})) |v|
-                break :path .{ v, false }
-            else |_| {}
-
-            // Fall back to heap
-            if (std.fmt.allocPrint(self.alloc, "{raw}", .{uri.path})) |v|
-                break :path .{ v, true }
-            else |_| {}
-
-            // Fall back to using it directly...
-            log.warn("failed to unescape OSC 7 path, using it directly path={s}", .{path});
-            break :path .{ path, false };
-        };
-        defer if (heap) self.alloc.free(path);
-
-        log.debug("terminal pwd: {s}", .{path});
-        try self.terminal.setPwd(path);
-
-        // If we haven't seen a title, use our pwd as the title.
-        if (!self.ev.seen_title) {
-            try self.changeWindowTitle(path);
-            self.ev.seen_title = false;
-        }
-    }
-
-    /// Implements OSC 4, OSC 10, and OSC 11, which reports palette color,
-    /// default foreground color, and background color respectively.
-    pub fn reportColor(
-        self: *StreamHandler,
-        kind: terminal.osc.Command.ColorKind,
-        terminator: terminal.osc.Terminator,
-    ) !void {
-        if (self.osc_color_report_format == .none) return;
-
-        const color = switch (kind) {
-            .palette => |i| self.terminal.color_palette.colors[i],
-            .foreground => self.foreground_color,
-            .background => self.background_color,
-            .cursor => self.cursor_color orelse self.foreground_color,
-        };
-
-        var msg: termio.Message = .{ .write_small = .{} };
-        const resp = switch (self.osc_color_report_format) {
-            .@"16-bit" => switch (kind) {
-                .palette => |i| try std.fmt.bufPrint(
-                    &msg.write_small.data,
-                    "\x1B]{s};{d};rgb:{x:0>4}/{x:0>4}/{x:0>4}{s}",
-                    .{
-                        kind.code(),
-                        i,
-                        @as(u16, color.r) * 257,
-                        @as(u16, color.g) * 257,
-                        @as(u16, color.b) * 257,
-                        terminator.string(),
-                    },
-                ),
-                else => try std.fmt.bufPrint(
-                    &msg.write_small.data,
-                    "\x1B]{s};rgb:{x:0>4}/{x:0>4}/{x:0>4}{s}",
-                    .{
-                        kind.code(),
-                        @as(u16, color.r) * 257,
-                        @as(u16, color.g) * 257,
-                        @as(u16, color.b) * 257,
-                        terminator.string(),
-                    },
-                ),
-            },
-
-            .@"8-bit" => switch (kind) {
-                .palette => |i| try std.fmt.bufPrint(
-                    &msg.write_small.data,
-                    "\x1B]{s};{d};rgb:{x:0>2}/{x:0>2}/{x:0>2}{s}",
-                    .{
-                        kind.code(),
-                        i,
-                        @as(u16, color.r),
-                        @as(u16, color.g),
-                        @as(u16, color.b),
-                        terminator.string(),
-                    },
-                ),
-                else => try std.fmt.bufPrint(
-                    &msg.write_small.data,
-                    "\x1B]{s};rgb:{x:0>2}/{x:0>2}/{x:0>2}{s}",
-                    .{
-                        kind.code(),
-                        @as(u16, color.r),
-                        @as(u16, color.g),
-                        @as(u16, color.b),
-                        terminator.string(),
-                    },
-                ),
-            },
-            .none => unreachable, // early return above
-        };
-        msg.write_small.len = @intCast(resp.len);
-        self.messageWriter(msg);
-    }
-
-    pub fn setColor(
-        self: *StreamHandler,
-        kind: terminal.osc.Command.ColorKind,
-        value: []const u8,
-    ) !void {
-        const color = try terminal.color.RGB.parse(value);
-
-        switch (kind) {
-            .palette => |i| {
-                self.terminal.flags.dirty.palette = true;
-                self.terminal.color_palette.colors[i] = color;
-                self.terminal.color_palette.mask.set(i);
-            },
-            .foreground => {
-                self.foreground_color = color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .foreground_color = color,
-                }, .{ .forever = {} });
-            },
-            .background => {
-                self.background_color = color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .background_color = color,
-                }, .{ .forever = {} });
-            },
-            .cursor => {
-                self.cursor_color = color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .cursor_color = color,
-                }, .{ .forever = {} });
-            },
-        }
-    }
-
-    pub fn resetColor(
-        self: *StreamHandler,
-        kind: terminal.osc.Command.ColorKind,
-        value: []const u8,
-    ) !void {
-        switch (kind) {
-            .palette => {
-                const mask = &self.terminal.color_palette.mask;
-                if (value.len == 0) {
-                    // Find all bit positions in the mask which are set and
-                    // reset those indices to the default palette
-                    var it = mask.iterator(.{});
-                    while (it.next()) |i| {
-                        self.terminal.flags.dirty.palette = true;
-                        self.terminal.color_palette.colors[i] = self.terminal.default_palette[i];
-                        mask.unset(i);
-                    }
-                } else {
-                    var it = std.mem.tokenizeScalar(u8, value, ';');
-                    while (it.next()) |param| {
-                        // Skip invalid parameters
-                        const i = std.fmt.parseUnsigned(u8, param, 10) catch continue;
-                        if (mask.isSet(i)) {
-                            self.terminal.flags.dirty.palette = true;
-                            self.terminal.color_palette.colors[i] = self.terminal.default_palette[i];
-                            mask.unset(i);
-                        }
-                    }
-                }
-            },
-            .foreground => {
-                self.foreground_color = self.default_foreground_color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .foreground_color = self.foreground_color,
-                }, .{ .forever = {} });
-            },
-            .background => {
-                self.background_color = self.default_background_color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .background_color = self.background_color,
-                }, .{ .forever = {} });
-            },
-            .cursor => {
-                self.cursor_color = self.default_cursor_color;
-                _ = self.ev.renderer_mailbox.push(.{
-                    .cursor_color = self.cursor_color,
-                }, .{ .forever = {} });
-            },
-        }
-    }
-
-    pub fn showDesktopNotification(
-        self: *StreamHandler,
-        title: []const u8,
-        body: []const u8,
-    ) !void {
-        var message = apprt.surface.Message{ .desktop_notification = undefined };
-
-        const title_len = @min(title.len, message.desktop_notification.title.len);
-        @memcpy(message.desktop_notification.title[0..title_len], title[0..title_len]);
-        message.desktop_notification.title[title_len] = 0;
-
-        const body_len = @min(body.len, message.desktop_notification.body.len);
-        @memcpy(message.desktop_notification.body[0..body_len], body[0..body_len]);
-        message.desktop_notification.body[body_len] = 0;
-
-        self.surfaceMessageWriter(message);
-    }
-};

commit bfbbe1485e5a082e5459d75ec46e742320038cbc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 14:44:44 2024 -0700

    termio: queueWrite no longer uses EventData

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 0481a312..f2a501b6 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -290,7 +290,6 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .renderer_wakeup = self.renderer_wakeup,
         .renderer_mailbox = self.renderer_mailbox,
         .process = process,
-        .data_stream = stream,
         .loop = &thread.loop,
         .terminal_stream = .{
             .handler = handler,
@@ -326,10 +325,13 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     data.* = .{
         .alloc = alloc,
         .ev = ev_data_ptr,
+        .loop = &thread.loop,
+        .surface_mailbox = self.surface_mailbox,
         .reader = .{ .exec = .{
             .start = process_start,
             .abnormal_runtime_threshold_ms = self.config.abnormal_runtime_threshold_ms,
             .wait_after_command = self.config.wait_after_command,
+            .write_stream = stream,
         } },
         .read_thread = read_thread,
         .read_thread_pipe = pipe[1],
@@ -627,28 +629,39 @@ pub inline fn queueWrite(
     data: []const u8,
     linefeed: bool,
 ) !void {
-    const ev = td.ev;
+    switch (td.reader) {
+        .manual => {},
+        .exec => try self.queueWriteExec(
+            td,
+            data,
+            linefeed,
+        ),
+    }
+}
+
+fn queueWriteExec(
+    self: *Termio,
+    td: *ThreadData,
+    data: []const u8,
+    linefeed: bool,
+) !void {
+    const exec = &td.reader.exec;
 
     // If our process is exited then we send our surface a message
     // about it but we don't queue any more writes.
-    switch (td.reader) {
-        .manual => {},
-        .exec => |exec| {
-            if (exec.exited) {
-                _ = ev.surface_mailbox.push(.{
-                    .child_exited = {},
-                }, .{ .forever = {} });
-                return;
-            }
-        },
+    if (exec.exited) {
+        _ = td.surface_mailbox.push(.{
+            .child_exited = {},
+        }, .{ .forever = {} });
+        return;
     }
 
     // We go through and chunk the data if necessary to fit into
     // our cached buffers that we can queue to the stream.
     var i: usize = 0;
     while (i < data.len) {
-        const req = try ev.write_req_pool.getGrow(self.alloc);
-        const buf = try ev.write_buf_pool.getGrow(self.alloc);
+        const req = try exec.write_req_pool.getGrow(self.alloc);
+        const buf = try exec.write_buf_pool.getGrow(self.alloc);
         const slice = slice: {
             // The maximum end index is either the end of our data or
             // the end of our buffer, whichever is smaller.
@@ -685,13 +698,13 @@ pub inline fn queueWrite(
 
         //for (slice) |b| log.warn("write: {x}", .{b});
 
-        ev.data_stream.queueWrite(
-            ev.loop,
-            &ev.write_queue,
+        exec.write_stream.queueWrite(
+            td.loop,
+            &exec.write_queue,
             req,
             .{ .slice = slice },
-            EventData,
-            ev,
+            termio.reader.ThreadData.Exec,
+            exec,
             ttyWrite,
         );
     }
@@ -764,6 +777,13 @@ pub const ThreadData = struct {
     /// The data that is attached to the callbacks.
     ev: *EventData,
 
+    /// The event loop associated with this thread. This is owned by
+    /// the Thread but we have a pointer so we can queue new work to it.
+    loop: *xev.Loop,
+
+    /// Mailboxes for different threads
+    surface_mailbox: apprt.surface.Mailbox,
+
     /// Data associated with the reader implementation (i.e. pty/exec state)
     reader: termio.reader.ThreadData,
 
@@ -775,6 +795,7 @@ pub const ThreadData = struct {
     pub fn deinit(self: *ThreadData) void {
         posix.close(self.read_thread_pipe);
         self.ev.deinit(self.alloc);
+        self.reader.deinit(self.alloc);
         self.alloc.destroy(self.ev);
         self.* = undefined;
     }
@@ -813,35 +834,15 @@ pub const EventData = struct {
     /// subsequently to wait for the data_stream to close.
     process_wait_c: xev.Completion = .{},
 
-    /// The data stream is the main IO for the pty.
-    data_stream: xev.Stream,
-
     /// The event loop,
     loop: *xev.Loop,
 
-    /// The write queue for the data stream.
-    write_queue: xev.Stream.WriteQueue = .{},
-
-    /// This is the pool of available (unused) write requests. If you grab
-    /// one from the pool, you must put it back when you're done!
-    write_req_pool: SegmentedPool(xev.Stream.WriteRequest, WRITE_REQ_PREALLOC) = .{},
-
-    /// The pool of available buffers for writing to the pty.
-    write_buf_pool: SegmentedPool([64]u8, WRITE_REQ_PREALLOC) = .{},
-
     /// Last time the cursor was reset. This is used to prevent message
     /// flooding with cursor resets.
     last_cursor_reset: i64 = 0,
 
     pub fn deinit(self: *EventData, alloc: Allocator) void {
-        // Clear our write pools. We know we aren't ever going to do
-        // any more IO since we stop our data stream below so we can just
-        // drop this.
-        self.write_req_pool.deinit(alloc);
-        self.write_buf_pool.deinit(alloc);
-
-        // Stop our data stream
-        self.data_stream.deinit();
+        _ = alloc;
 
         // Stop our process watcher
         self.process.deinit();
@@ -946,16 +947,16 @@ fn processExit(
 }
 
 fn ttyWrite(
-    ev_: ?*EventData,
+    td_: ?*termio.reader.ThreadData.Exec,
     _: *xev.Loop,
     _: *xev.Completion,
     _: xev.Stream,
     _: xev.WriteBuffer,
     r: xev.Stream.WriteError!usize,
 ) xev.CallbackAction {
-    const ev = ev_.?;
-    ev.write_req_pool.put();
-    ev.write_buf_pool.put();
+    const td = td_.?;
+    td.write_req_pool.put();
+    td.write_buf_pool.put();
 
     const d = r catch |err| {
         log.err("write error: {}", .{err});

commit 2e62e3354b9021e74cca215a543dd448cc270d05
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 14:59:25 2024 -0700

    termio: cleanup more state

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index f2a501b6..fb6c5382 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -236,8 +236,8 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     errdefer posix.close(pipe[1]);
 
     // Setup our data that is used for callbacks
-    var ev_data_ptr = try alloc.create(EventData);
-    errdefer alloc.destroy(ev_data_ptr);
+    var read_data_ptr = try alloc.create(ReadData);
+    errdefer alloc.destroy(read_data_ptr);
 
     // Setup our stream so that we can write.
     var stream = xev.Stream.initFd(pty_fds.write);
@@ -282,14 +282,10 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     };
 
     // Setup our event data before we start
-    ev_data_ptr.* = .{
-        .writer_mailbox = thread.mailbox,
-        .writer_wakeup = thread.wakeup,
-        .surface_mailbox = self.surface_mailbox,
+    read_data_ptr.* = .{
         .renderer_state = self.renderer_state,
         .renderer_wakeup = self.renderer_wakeup,
         .renderer_mailbox = self.renderer_mailbox,
-        .process = process,
         .loop = &thread.loop,
         .terminal_stream = .{
             .handler = handler,
@@ -302,41 +298,45 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
             },
         },
     };
-    errdefer ev_data_ptr.deinit(self.alloc);
-
-    // Start our process watcher
-    process.wait(
-        ev_data_ptr.loop,
-        &ev_data_ptr.process_wait_c,
-        ThreadData,
-        data,
-        processExit,
-    );
+    errdefer read_data_ptr.deinit();
 
     // Start our reader thread
     const read_thread = try std.Thread.spawn(
         .{},
         if (builtin.os.tag == .windows) ReadThread.threadMainWindows else ReadThread.threadMainPosix,
-        .{ pty_fds.read, ev_data_ptr, pipe[0] },
+        .{ pty_fds.read, read_data_ptr, pipe[0] },
     );
     read_thread.setName("io-reader") catch {};
 
     // Return our thread data
     data.* = .{
         .alloc = alloc,
-        .ev = ev_data_ptr,
         .loop = &thread.loop,
+        .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
+        .writer_mailbox = thread.mailbox,
+        .writer_wakeup = thread.wakeup,
         .reader = .{ .exec = .{
             .start = process_start,
             .abnormal_runtime_threshold_ms = self.config.abnormal_runtime_threshold_ms,
             .wait_after_command = self.config.wait_after_command,
             .write_stream = stream,
+            .process = process,
         } },
         .read_thread = read_thread,
         .read_thread_pipe = pipe[1],
         .read_thread_fd = if (builtin.os.tag == .windows) pty_fds.read else {},
+        .read_thread_data = read_data_ptr,
     };
+
+    // Start our process watcher
+    process.wait(
+        &thread.loop,
+        &data.reader.exec.process_wait_c,
+        ThreadData,
+        data,
+        processExit,
+    );
 }
 
 /// This outputs an error message when exec failed and we are the
@@ -405,7 +405,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
     // Update our stream handler. The stream handler uses the same
     // renderer mutex so this is safe to do despite being executed
     // from another thread.
-    td.ev.terminal_stream.handler.changeConfig(&self.config);
+    td.read_thread_data.terminal_stream.handler.changeConfig(&self.config);
     td.reader.changeConfig(&self.config);
 
     // Update the configuration that we know about.
@@ -711,7 +711,7 @@ fn queueWriteExec(
 }
 
 fn readInternal(
-    ev: *EventData,
+    ev: *ReadData,
     buf: []const u8,
 ) void {
     // log.info("DATA: {d}", .{n});
@@ -722,7 +722,7 @@ fn readInternal(
     defer ev.renderer_state.mutex.unlock();
 
     // Schedule a render. We can call this first because we have the lock.
-    ev.queueRender() catch unreachable;
+    ev.terminal_stream.handler.queueRender() catch unreachable;
 
     // Whenever a character is typed, we ensure the cursor is in the
     // non-blink state so it is rendered if visible. If we're under
@@ -758,9 +758,10 @@ fn readInternal(
     // thread, then we need to wake it up so that it processes them.
     if (ev.terminal_stream.handler.writer_messaged) {
         ev.terminal_stream.handler.writer_messaged = false;
-        ev.writer_wakeup.notify() catch |err| {
-            log.warn("failed to wake up writer thread err={}", .{err});
-        };
+        // TODO
+        // ev.writer_wakeup.notify() catch |err| {
+        //     log.warn("failed to wake up writer thread err={}", .{err});
+        // };
     }
 }
 
@@ -774,15 +775,17 @@ pub const ThreadData = struct {
     /// Allocator used for the event data
     alloc: Allocator,
 
-    /// The data that is attached to the callbacks.
-    ev: *EventData,
-
     /// The event loop associated with this thread. This is owned by
     /// the Thread but we have a pointer so we can queue new work to it.
     loop: *xev.Loop,
 
+    /// The shared render state
+    renderer_state: *renderer.State,
+
     /// Mailboxes for different threads
     surface_mailbox: apprt.surface.Mailbox,
+    writer_mailbox: *termio.Mailbox,
+    writer_wakeup: xev.Async,
 
     /// Data associated with the reader implementation (i.e. pty/exec state)
     reader: termio.reader.ThreadData,
@@ -791,28 +794,19 @@ pub const ThreadData = struct {
     read_thread: std.Thread,
     read_thread_pipe: posix.fd_t,
     read_thread_fd: if (builtin.os.tag == .windows) posix.fd_t else void,
+    read_thread_data: *ReadData,
 
     pub fn deinit(self: *ThreadData) void {
         posix.close(self.read_thread_pipe);
-        self.ev.deinit(self.alloc);
+        self.read_thread_data.deinit();
         self.reader.deinit(self.alloc);
-        self.alloc.destroy(self.ev);
+        self.alloc.destroy(self.read_thread_data);
         self.* = undefined;
     }
 };
 
-pub const EventData = struct {
-    // The preallocation size for the write request pool. This should be big
-    // enough to satisfy most write requests. It must be a power of 2.
-    const WRITE_REQ_PREALLOC = std.math.pow(usize, 2, 5);
-
-    /// Mailbox for data to the writer thread.
-    writer_mailbox: *termio.Mailbox,
-    writer_wakeup: xev.Async,
-
-    /// Mailbox for the surface.
-    surface_mailbox: apprt.surface.Mailbox,
-
+/// Thread local data for the reader thread.
+pub const ReadData = struct {
     /// The stream parser. This parses the stream of escape codes and so on
     /// from the child process and calls callbacks in the stream handler.
     terminal_stream: terminal.Stream(StreamHandler),
@@ -827,13 +821,6 @@ pub const EventData = struct {
     /// The mailbox for notifying the renderer of things.
     renderer_mailbox: *renderer.Thread.Mailbox,
 
-    /// The process watcher
-    process: xev.Process,
-
-    /// This is used for both waiting for the process to exit and then
-    /// subsequently to wait for the data_stream to close.
-    process_wait_c: xev.Completion = .{},
-
     /// The event loop,
     loop: *xev.Loop,
 
@@ -841,23 +828,11 @@ pub const EventData = struct {
     /// flooding with cursor resets.
     last_cursor_reset: i64 = 0,
 
-    pub fn deinit(self: *EventData, alloc: Allocator) void {
-        _ = alloc;
-
-        // Stop our process watcher
-        self.process.deinit();
-
+    pub fn deinit(self: *ReadData) void {
         // Clear any StreamHandler state
         self.terminal_stream.handler.deinit();
         self.terminal_stream.deinit();
     }
-
-    /// This queues a render operation with the renderer thread. The render
-    /// isn't guaranteed to happen immediately but it will happen as soon as
-    /// practical.
-    pub inline fn queueRender(self: *EventData) !void {
-        try self.renderer_wakeup.notify();
-    }
 };
 
 fn processExit(
@@ -870,7 +845,6 @@ fn processExit(
 
     const td = td_.?;
     assert(td.reader == .exec);
-    const ev = td.ev;
     const execdata = &td.reader.exec;
     execdata.exited = true;
 
@@ -907,13 +881,13 @@ fn processExit(
 
         // Notify our main writer thread which has access to more
         // information so it can show a better error message.
-        _ = ev.writer_mailbox.push(.{
+        _ = td.writer_mailbox.push(.{
             .child_exited_abnormally = .{
                 .exit_code = exit_code,
                 .runtime_ms = runtime,
             },
         }, .{ .forever = {} });
-        ev.writer_wakeup.notify() catch break :runtime;
+        td.writer_wakeup.notify() catch break :runtime;
 
         return .disarm;
     }
@@ -925,9 +899,9 @@ fn processExit(
         // We output a message so that the user knows whats going on and
         // doesn't think their terminal just froze.
         terminal: {
-            ev.renderer_state.mutex.lock();
-            defer ev.renderer_state.mutex.unlock();
-            const t = ev.renderer_state.terminal;
+            td.renderer_state.mutex.lock();
+            defer td.renderer_state.mutex.unlock();
+            const t = td.renderer_state.terminal;
             t.carriageReturn();
             t.linefeed() catch break :terminal;
             t.printString("Process exited. Press any key to close the terminal.") catch
@@ -939,7 +913,7 @@ fn processExit(
     }
 
     // Notify our surface we want to close
-    _ = ev.surface_mailbox.push(.{
+    _ = td.surface_mailbox.push(.{
         .child_exited = {},
     }, .{ .forever = {} });
 
@@ -1614,7 +1588,7 @@ const Subprocess = struct {
 /// fds and this is still much faster and lower overhead than any async
 /// mechanism.
 const ReadThread = struct {
-    fn threadMainPosix(fd: posix.fd_t, ev: *EventData, quit: posix.fd_t) void {
+    fn threadMainPosix(fd: posix.fd_t, ev: *ReadData, quit: posix.fd_t) void {
         // Always close our end of the pipe when we exit.
         defer posix.close(quit);
 
@@ -1695,7 +1669,7 @@ const ReadThread = struct {
         }
     }
 
-    fn threadMainWindows(fd: posix.fd_t, ev: *EventData, quit: posix.fd_t) void {
+    fn threadMainWindows(fd: posix.fd_t, ev: *ReadData, quit: posix.fd_t) void {
         // Always close our end of the pipe when we exit.
         defer posix.close(quit);
 

commit b3c2479f8768564dd99202fbd4af0ac239351685
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 15:17:36 2024 -0700

    termio: move subprocess out to its own file

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index fb6c5382..a8920527 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -16,6 +16,7 @@ const termio = @import("../termio.zig");
 const Command = @import("../Command.zig");
 const Pty = @import("../pty.zig").Pty;
 const SegmentedPool = @import("../segmented_pool.zig").SegmentedPool;
+const StreamHandler = @import("stream_handler.zig").StreamHandler;
 const terminal = @import("../terminal/main.zig");
 const terminfo = @import("../terminfo/main.zig");
 const xev = @import("xev");
@@ -27,8 +28,6 @@ const windows = internal_os.windows;
 const configpkg = @import("../config.zig");
 const shell_integration = @import("shell_integration.zig");
 
-const StreamHandler = @import("stream_handler.zig").StreamHandler;
-
 const log = std.log.scoped(.io_exec);
 
 const c = @cImport({
@@ -46,7 +45,7 @@ const disable_kitty_keyboard_protocol = apprt.runtime == apprt.glfw;
 alloc: Allocator,
 
 /// This is the pty fd created for the subcommand.
-subprocess: Subprocess,
+subprocess: termio.Exec,
 
 /// The derived configuration for this termio implementation.
 config: DerivedConfig,
@@ -169,7 +168,7 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    var subprocess = try Subprocess.init(alloc, opts);
+    var subprocess = try termio.Exec.init(alloc, opts);
     errdefer subprocess.deinit();
 
     // If we have an initial pwd requested by the subprocess, then we
@@ -942,635 +941,6 @@ fn ttyWrite(
     return .disarm;
 }
 
-/// Subprocess manages the lifecycle of the shell subprocess.
-const Subprocess = struct {
-    /// If we build with flatpak support then we have to keep track of
-    /// a potential execution on the host.
-    const FlatpakHostCommand = if (build_config.flatpak) internal_os.FlatpakHostCommand else void;
-
-    arena: std.heap.ArenaAllocator,
-    cwd: ?[]const u8,
-    env: EnvMap,
-    args: [][]const u8,
-    grid_size: renderer.GridSize,
-    screen_size: renderer.ScreenSize,
-    pty: ?Pty = null,
-    command: ?Command = null,
-    flatpak_command: ?FlatpakHostCommand = null,
-    linux_cgroup: Command.LinuxCgroup = Command.linux_cgroup_default,
-
-    /// Initialize the subprocess. This will NOT start it, this only sets
-    /// up the internal state necessary to start it later.
-    pub fn init(gpa: Allocator, opts: termio.Options) !Subprocess {
-        // We have a lot of maybe-allocations that all share the same lifetime
-        // so use an arena so we don't end up in an accounting nightmare.
-        var arena = std.heap.ArenaAllocator.init(gpa);
-        errdefer arena.deinit();
-        const alloc = arena.allocator();
-
-        // Set our env vars. For Flatpak builds running in Flatpak we don't
-        // inherit our environment because the login shell on the host side
-        // will get it.
-        var env = env: {
-            if (comptime build_config.flatpak) {
-                if (internal_os.isFlatpak()) {
-                    break :env std.process.EnvMap.init(alloc);
-                }
-            }
-
-            break :env try std.process.getEnvMap(alloc);
-        };
-        errdefer env.deinit();
-
-        // If we have a resources dir then set our env var
-        if (opts.resources_dir) |dir| {
-            log.info("found Ghostty resources dir: {s}", .{dir});
-            try env.put("GHOSTTY_RESOURCES_DIR", dir);
-        }
-
-        // Set our TERM var. This is a bit complicated because we want to use
-        // the ghostty TERM value but we want to only do that if we have
-        // ghostty in the TERMINFO database.
-        //
-        // For now, we just look up a bundled dir but in the future we should
-        // also load the terminfo database and look for it.
-        if (opts.resources_dir) |base| {
-            try env.put("TERM", opts.config.term);
-            try env.put("COLORTERM", "truecolor");
-
-            // Assume that the resources directory is adjacent to the terminfo
-            // database
-            var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-            const dir = try std.fmt.bufPrint(&buf, "{s}/terminfo", .{
-                std.fs.path.dirname(base) orelse unreachable,
-            });
-            try env.put("TERMINFO", dir);
-        } else {
-            if (comptime builtin.target.isDarwin()) {
-                log.warn("ghostty terminfo not found, using xterm-256color", .{});
-                log.warn("the terminfo SHOULD exist on macos, please ensure", .{});
-                log.warn("you're using a valid app bundle.", .{});
-            }
-
-            try env.put("TERM", "xterm-256color");
-            try env.put("COLORTERM", "truecolor");
-        }
-
-        // Add our binary to the path if we can find it.
-        ghostty_path: {
-            var exe_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-            const exe_bin_path = std.fs.selfExePath(&exe_buf) catch |err| {
-                log.warn("failed to get ghostty exe path err={}", .{err});
-                break :ghostty_path;
-            };
-            const exe_dir = std.fs.path.dirname(exe_bin_path) orelse break :ghostty_path;
-            log.debug("appending ghostty bin to path dir={s}", .{exe_dir});
-
-            // We always set this so that if the shell overwrites the path
-            // scripts still have a way to find the Ghostty binary when
-            // running in Ghostty.
-            try env.put("GHOSTTY_BIN_DIR", exe_dir);
-
-            // Append if we have a path. We want to append so that ghostty is
-            // the last priority in the path. If we don't have a path set
-            // then we just set it to the directory of the binary.
-            if (env.get("PATH")) |path| {
-                // Verify that our path doesn't already contain this entry
-                var it = std.mem.tokenizeScalar(u8, path, internal_os.PATH_SEP[0]);
-                while (it.next()) |entry| {
-                    if (std.mem.eql(u8, entry, exe_dir)) break :ghostty_path;
-                }
-
-                try env.put(
-                    "PATH",
-                    try internal_os.appendEnv(alloc, path, exe_dir),
-                );
-            } else {
-                try env.put("PATH", exe_dir);
-            }
-        }
-
-        // Add the man pages from our application bundle to MANPATH.
-        if (comptime builtin.target.isDarwin()) {
-            if (opts.resources_dir) |resources_dir| man: {
-                var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-                const dir = std.fmt.bufPrint(&buf, "{s}/../man", .{resources_dir}) catch |err| {
-                    log.warn("error building manpath, man pages may not be available err={}", .{err});
-                    break :man;
-                };
-
-                if (env.get("MANPATH")) |manpath| {
-                    // Append to the existing MANPATH. It's very unlikely that our bundle's
-                    // resources directory already appears here so we don't spend the time
-                    // searching for it.
-                    try env.put(
-                        "MANPATH",
-                        try internal_os.appendEnv(alloc, manpath, dir),
-                    );
-                } else {
-                    try env.put("MANPATH", dir);
-                }
-            }
-        }
-
-        // Set environment variables used by some programs (such as neovim) to detect
-        // which terminal emulator and version they're running under.
-        try env.put("TERM_PROGRAM", "ghostty");
-        try env.put("TERM_PROGRAM_VERSION", build_config.version_string);
-
-        // When embedding in macOS and running via XCode, XCode injects
-        // a bunch of things that break our shell process. We remove those.
-        if (comptime builtin.target.isDarwin() and build_config.artifact == .lib) {
-            if (env.get("__XCODE_BUILT_PRODUCTS_DIR_PATHS") != null) {
-                env.remove("__XCODE_BUILT_PRODUCTS_DIR_PATHS");
-                env.remove("__XPC_DYLD_LIBRARY_PATH");
-                env.remove("DYLD_FRAMEWORK_PATH");
-                env.remove("DYLD_INSERT_LIBRARIES");
-                env.remove("DYLD_LIBRARY_PATH");
-                env.remove("LD_LIBRARY_PATH");
-                env.remove("SECURITYSESSIONID");
-                env.remove("XPC_SERVICE_NAME");
-            }
-
-            // Remove this so that running `ghostty` within Ghostty works.
-            env.remove("GHOSTTY_MAC_APP");
-        }
-
-        // Don't leak these environment variables to child processes.
-        if (comptime build_config.app_runtime == .gtk) {
-            env.remove("GDK_DEBUG");
-            env.remove("GSK_RENDERER");
-        }
-
-        // Setup our shell integration, if we can.
-        const integrated_shell: ?shell_integration.Shell, const shell_command: []const u8 = shell: {
-            const default_shell_command = opts.full_config.command orelse switch (builtin.os.tag) {
-                .windows => "cmd.exe",
-                else => "sh",
-            };
-
-            const force: ?shell_integration.Shell = switch (opts.full_config.@"shell-integration") {
-                .none => break :shell .{ null, default_shell_command },
-                .detect => null,
-                .bash => .bash,
-                .elvish => .elvish,
-                .fish => .fish,
-                .zsh => .zsh,
-            };
-
-            const dir = opts.resources_dir orelse break :shell .{
-                null,
-                default_shell_command,
-            };
-
-            const integration = try shell_integration.setup(
-                alloc,
-                dir,
-                default_shell_command,
-                &env,
-                force,
-                opts.full_config.@"shell-integration-features",
-            ) orelse break :shell .{ null, default_shell_command };
-
-            break :shell .{ integration.shell, integration.command };
-        };
-
-        if (integrated_shell) |shell| {
-            log.info(
-                "shell integration automatically injected shell={}",
-                .{shell},
-            );
-        } else if (opts.full_config.@"shell-integration" != .none) {
-            log.warn("shell could not be detected, no automatic shell integration will be injected", .{});
-        }
-
-        // Build our args list
-        const args = args: {
-            const cap = 9; // the most we'll ever use
-            var args = try std.ArrayList([]const u8).initCapacity(alloc, cap);
-            defer args.deinit();
-
-            // If we're on macOS, we have to use `login(1)` to get all of
-            // the proper environment variables set, a login shell, and proper
-            // hushlogin behavior.
-            if (comptime builtin.target.isDarwin()) darwin: {
-                const passwd = internal_os.passwd.get(alloc) catch |err| {
-                    log.warn("failed to read passwd, not using a login shell err={}", .{err});
-                    break :darwin;
-                };
-
-                const username = passwd.name orelse {
-                    log.warn("failed to get username, not using a login shell", .{});
-                    break :darwin;
-                };
-
-                const hush = if (passwd.home) |home| hush: {
-                    var dir = std.fs.openDirAbsolute(home, .{}) catch |err| {
-                        log.warn(
-                            "failed to open home dir, not checking for hushlogin err={}",
-                            .{err},
-                        );
-                        break :hush false;
-                    };
-                    defer dir.close();
-
-                    break :hush if (dir.access(".hushlogin", .{})) true else |_| false;
-                } else false;
-
-                const cmd = try std.fmt.allocPrint(
-                    alloc,
-                    "exec -l {s}",
-                    .{shell_command},
-                );
-
-                // The reason for executing login this way is unclear. This
-                // comment will attempt to explain but prepare for a truly
-                // unhinged reality.
-                //
-                // The first major issue is that on macOS, a lot of users
-                // put shell configurations in ~/.bash_profile instead of
-                // ~/.bashrc (or equivalent for another shell). This file is only
-                // loaded for a login shell so macOS users expect all their terminals
-                // to be login shells. No other platform behaves this way and its
-                // totally braindead but somehow the entire dev community on
-                // macOS has cargo culted their way to this reality so we have to
-                // do it...
-                //
-                // To get a login shell, you COULD just prepend argv0 with a `-`
-                // but that doesn't fully work because `getlogin()` C API will
-                // return the wrong value, SHELL won't be set, and various
-                // other login behaviors that macOS users expect.
-                //
-                // The proper way is to use `login(1)`. But login(1) forces
-                // the working directory to change to the home directory,
-                // which we may not want. If we specify "-l" then we can avoid
-                // this behavior but now the shell isn't a login shell.
-                //
-                // There is another issue: `login(1)` only checks for ".hushlogin"
-                // in the working directory. This means that if we specify "-l"
-                // then we won't get hushlogin honored if its in the home
-                // directory (which is standard). To get around this, we
-                // check for hushlogin ourselves and if present specify the
-                // "-q" flag to login(1).
-                //
-                // So to get all the behaviors we want, we specify "-l" but
-                // execute "bash" (which is built-in to macOS). We then use
-                // the bash builtin "exec" to replace the process with a login
-                // shell ("-l" on exec) with the command we really want.
-                //
-                // We use "bash" instead of other shells that ship with macOS
-                // because as of macOS Sonoma, we found with a microbenchmark
-                // that bash can `exec` into the desired command ~2x faster
-                // than zsh.
-                //
-                // To figure out a lot of this logic I read the login.c
-                // source code in the OSS distribution Apple provides for
-                // macOS.
-                //
-                // Awesome.
-                try args.append("/usr/bin/login");
-                if (hush) try args.append("-q");
-                try args.append("-flp");
-
-                // We execute bash with "--noprofile --norc" so that it doesn't
-                // load startup files so that (1) our shell integration doesn't
-                // break and (2) user configuration doesn't mess this process
-                // up.
-                try args.append(username);
-                try args.append("/bin/bash");
-                try args.append("--noprofile");
-                try args.append("--norc");
-                try args.append("-c");
-                try args.append(cmd);
-                break :args try args.toOwnedSlice();
-            }
-
-            if (comptime builtin.os.tag == .windows) {
-                // We run our shell wrapped in `cmd.exe` so that we don't have
-                // to parse the command line ourselves if it has arguments.
-
-                // Note we don't free any of the memory below since it is
-                // allocated in the arena.
-                const windir = try std.process.getEnvVarOwned(alloc, "WINDIR");
-                const cmd = try std.fs.path.join(alloc, &[_][]const u8{
-                    windir,
-                    "System32",
-                    "cmd.exe",
-                });
-
-                try args.append(cmd);
-                try args.append("/C");
-            } else {
-                // We run our shell wrapped in `/bin/sh` so that we don't have
-                // to parse the command line ourselves if it has arguments.
-                // Additionally, some environments (NixOS, I found) use /bin/sh
-                // to setup some environment variables that are important to
-                // have set.
-                try args.append("/bin/sh");
-                if (internal_os.isFlatpak()) try args.append("-l");
-                try args.append("-c");
-            }
-
-            try args.append(shell_command);
-            break :args try args.toOwnedSlice();
-        };
-
-        // We have to copy the cwd because there is no guarantee that
-        // pointers in full_config remain valid.
-        const cwd: ?[]u8 = if (opts.full_config.@"working-directory") |cwd|
-            try alloc.dupe(u8, cwd)
-        else
-            null;
-
-        // If we have a cgroup, then we copy that into our arena so the
-        // memory remains valid when we start.
-        const linux_cgroup: Command.LinuxCgroup = cgroup: {
-            const default = Command.linux_cgroup_default;
-            if (comptime builtin.os.tag != .linux) break :cgroup default;
-            const path = opts.linux_cgroup orelse break :cgroup default;
-            break :cgroup try alloc.dupe(u8, path);
-        };
-
-        // Our screen size should be our padded size
-        const padded_size = opts.screen_size.subPadding(opts.padding);
-
-        return .{
-            .arena = arena,
-            .env = env,
-            .cwd = cwd,
-            .args = args,
-            .grid_size = opts.grid_size,
-            .screen_size = padded_size,
-            .linux_cgroup = linux_cgroup,
-        };
-    }
-
-    /// Clean up the subprocess. This will stop the subprocess if it is started.
-    pub fn deinit(self: *Subprocess) void {
-        self.stop();
-        if (self.pty) |*pty| pty.deinit();
-        self.arena.deinit();
-        self.* = undefined;
-    }
-
-    /// Start the subprocess. If the subprocess is already started this
-    /// will crash.
-    pub fn start(self: *Subprocess, alloc: Allocator) !struct {
-        read: Pty.Fd,
-        write: Pty.Fd,
-    } {
-        assert(self.pty == null and self.command == null);
-
-        // Create our pty
-        var pty = try Pty.open(.{
-            .ws_row = @intCast(self.grid_size.rows),
-            .ws_col = @intCast(self.grid_size.columns),
-            .ws_xpixel = @intCast(self.screen_size.width),
-            .ws_ypixel = @intCast(self.screen_size.height),
-        });
-        self.pty = pty;
-        errdefer {
-            pty.deinit();
-            self.pty = null;
-        }
-
-        log.debug("starting command command={s}", .{self.args});
-
-        // In flatpak, we use the HostCommand to execute our shell.
-        if (internal_os.isFlatpak()) flatpak: {
-            if (comptime !build_config.flatpak) {
-                log.warn("flatpak detected, but flatpak support not built-in", .{});
-                break :flatpak;
-            }
-
-            // Flatpak command must have a stable pointer.
-            self.flatpak_command = .{
-                .argv = self.args,
-                .env = &self.env,
-                .stdin = pty.slave,
-                .stdout = pty.slave,
-                .stderr = pty.slave,
-            };
-            var cmd = &self.flatpak_command.?;
-            const pid = try cmd.spawn(alloc);
-            errdefer killCommandFlatpak(cmd);
-
-            log.info("started subcommand on host via flatpak API path={s} pid={?}", .{
-                self.args[0],
-                pid,
-            });
-
-            // Once started, we can close the pty child side. We do this after
-            // wait right now but that is fine too. This lets us read the
-            // parent and detect EOF.
-            _ = posix.close(pty.slave);
-
-            return .{
-                .read = pty.master,
-                .write = pty.master,
-            };
-        }
-
-        // If we can't access the cwd, then don't set any cwd and inherit.
-        // This is important because our cwd can be set by the shell (OSC 7)
-        // and we don't want to break new windows.
-        const cwd: ?[]const u8 = if (self.cwd) |proposed| cwd: {
-            if (std.fs.accessAbsolute(proposed, .{})) {
-                break :cwd proposed;
-            } else |err| {
-                log.warn("cannot access cwd, ignoring: {}", .{err});
-                break :cwd null;
-            }
-        } else null;
-
-        // Build our subcommand
-        var cmd: Command = .{
-            .path = self.args[0],
-            .args = self.args,
-            .env = &self.env,
-            .cwd = cwd,
-            .stdin = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
-            .stdout = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
-            .stderr = if (builtin.os.tag == .windows) null else .{ .handle = pty.slave },
-            .pseudo_console = if (builtin.os.tag == .windows) pty.pseudo_console else {},
-            .pre_exec = if (builtin.os.tag == .windows) null else (struct {
-                fn callback(cmd: *Command) void {
-                    const sp = cmd.getData(Subprocess) orelse unreachable;
-                    sp.childPreExec() catch |err| log.err(
-                        "error initializing child: {}",
-                        .{err},
-                    );
-                }
-            }).callback,
-            .data = self,
-            .linux_cgroup = self.linux_cgroup,
-        };
-        try cmd.start(alloc);
-        errdefer killCommand(&cmd) catch |err| {
-            log.warn("error killing command during cleanup err={}", .{err});
-        };
-        log.info("started subcommand path={s} pid={?}", .{ self.args[0], cmd.pid });
-        if (comptime builtin.os.tag == .linux) {
-            log.info("subcommand cgroup={s}", .{self.linux_cgroup orelse "-"});
-        }
-
-        self.command = cmd;
-        return switch (builtin.os.tag) {
-            .windows => .{
-                .read = pty.out_pipe,
-                .write = pty.in_pipe,
-            },
-
-            else => .{
-                .read = pty.master,
-                .write = pty.master,
-            },
-        };
-    }
-
-    /// This should be called after fork but before exec in the child process.
-    /// To repeat: this function RUNS IN THE FORKED CHILD PROCESS before
-    /// exec is called; it does NOT run in the main Ghostty process.
-    fn childPreExec(self: *Subprocess) !void {
-        // Setup our pty
-        try self.pty.?.childPreExec();
-    }
-
-    /// Called to notify that we exited externally so we can unset our
-    /// running state.
-    pub fn externalExit(self: *Subprocess) void {
-        self.command = null;
-    }
-
-    /// Stop the subprocess. This is safe to call anytime. This will wait
-    /// for the subprocess to register that it has been signalled, but not
-    /// for it to terminate, so it will not block.
-    /// This does not close the pty.
-    pub fn stop(self: *Subprocess) void {
-        // Kill our command
-        if (self.command) |*cmd| {
-            // Note: this will also wait for the command to exit, so
-            // DO NOT call cmd.wait
-            killCommand(cmd) catch |err|
-                log.err("error sending SIGHUP to command, may hang: {}", .{err});
-            self.command = null;
-        }
-
-        // Kill our Flatpak command
-        if (FlatpakHostCommand != void) {
-            if (self.flatpak_command) |*cmd| {
-                killCommandFlatpak(cmd) catch |err|
-                    log.err("error sending SIGHUP to command, may hang: {}", .{err});
-                _ = cmd.wait() catch |err|
-                    log.err("error waiting for command to exit: {}", .{err});
-                self.flatpak_command = null;
-            }
-        }
-    }
-
-    /// Resize the pty subprocess. This is safe to call anytime.
-    pub fn resize(
-        self: *Subprocess,
-        grid_size: renderer.GridSize,
-        screen_size: renderer.ScreenSize,
-    ) !void {
-        self.grid_size = grid_size;
-        self.screen_size = screen_size;
-
-        if (self.pty) |*pty| {
-            try pty.setSize(.{
-                .ws_row = @intCast(grid_size.rows),
-                .ws_col = @intCast(grid_size.columns),
-                .ws_xpixel = @intCast(screen_size.width),
-                .ws_ypixel = @intCast(screen_size.height),
-            });
-        }
-    }
-
-    /// Kill the underlying subprocess. This sends a SIGHUP to the child
-    /// process. This also waits for the command to exit and will return the
-    /// exit code.
-    fn killCommand(command: *Command) !void {
-        if (command.pid) |pid| {
-            switch (builtin.os.tag) {
-                .windows => {
-                    if (windows.kernel32.TerminateProcess(pid, 0) == 0) {
-                        return windows.unexpectedError(windows.kernel32.GetLastError());
-                    }
-
-                    _ = try command.wait(false);
-                },
-
-                else => if (getpgid(pid)) |pgid| {
-                    // It is possible to send a killpg between the time that
-                    // our child process calls setsid but before or simultaneous
-                    // to calling execve. In this case, the direct child dies
-                    // but grandchildren survive. To work around this, we loop
-                    // and repeatedly kill the process group until all
-                    // descendents are well and truly dead. We will not rest
-                    // until the entire family tree is obliterated.
-                    while (true) {
-                        if (c.killpg(pgid, c.SIGHUP) < 0) {
-                            log.warn("error killing process group pgid={}", .{pgid});
-                            return error.KillFailed;
-                        }
-
-                        // See Command.zig wait for why we specify WNOHANG.
-                        // The gist is that it lets us detect when children
-                        // are still alive without blocking so that we can
-                        // kill them again.
-                        const res = posix.waitpid(pid, std.c.W.NOHANG);
-                        if (res.pid != 0) break;
-                        std.time.sleep(10 * std.time.ns_per_ms);
-                    }
-                },
-            }
-        }
-    }
-
-    fn getpgid(pid: c.pid_t) ?c.pid_t {
-        // Get our process group ID. Before the child pid calls setsid
-        // the pgid will be ours because we forked it. Its possible that
-        // we may be calling this before setsid if we are killing a surface
-        // VERY quickly after starting it.
-        const my_pgid = c.getpgid(0);
-
-        // We loop while pgid == my_pgid. The expectation if we have a valid
-        // pid is that setsid will eventually be called because it is the
-        // FIRST thing the child process does and as far as I can tell,
-        // setsid cannot fail. I'm sure that's not true, but I'd rather
-        // have a bug reported than defensively program against it now.
-        while (true) {
-            const pgid = c.getpgid(pid);
-            if (pgid == my_pgid) {
-                log.warn("pgid is our own, retrying", .{});
-                std.time.sleep(10 * std.time.ns_per_ms);
-                continue;
-            }
-
-            // Don't know why it would be zero but its not a valid pid
-            if (pgid == 0) return null;
-
-            // If the pid doesn't exist then... we're done!
-            if (pgid == c.ESRCH) return null;
-
-            // If we have an error we're done.
-            if (pgid < 0) {
-                log.warn("error getting pgid for kill", .{});
-                return null;
-            }
-
-            return pgid;
-        }
-    }
-
-    /// Kill the underlying process started via Flatpak host command.
-    /// This sends a signal via the Flatpak API.
-    fn killCommandFlatpak(command: *FlatpakHostCommand) !void {
-        try command.signal(c.SIGHUP, true);
-    }
-};
-
 /// The read thread sits in a loop doing the following pseudo code:
 ///
 ///   while (true) { blocking_read(); exit_if_eof(); process(); }

commit 7c23d613794cd4cbf18489fc9b2c6a9587666876
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 18:50:37 2024 -0700

    termio: rename

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index a8920527..c8fdd471 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -71,6 +71,10 @@ surface_mailbox: apprt.surface.Mailbox,
 /// The cached grid size whenever a resize is called.
 grid_size: renderer.GridSize,
 
+/// The pointer to the read data. This is only valid while the termio thread
+/// is alive. This is protected by the renderer state lock.
+read_data: ?*ReadData = null,
+
 /// The configuration for this IO that is derived from the main
 /// configuration. This must be exported so that we don't need to
 /// pass around Config pointers which makes memory management a pain.
@@ -709,28 +713,40 @@ fn queueWriteExec(
     }
 }
 
-fn readInternal(
-    ev: *ReadData,
-    buf: []const u8,
-) void {
-    // log.info("DATA: {d}", .{n});
-    // log.info("DATA: {any}", .{buf[0..@intCast(usize, n)]});
+/// Process output from the pty. This is the manual API that users can
+/// call with pty data but it is also called by the read thread when using
+/// an exec subprocess.
+pub fn processOutput(self: *Termio, buf: []const u8) !void {
+    // We are modifying terminal state from here on out and we need
+    // the lock to grab our read data.
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+
+    // If we don't have read data, we can't process it.
+    const rd = self.read_data orelse return error.ReadDataNull;
+    processOutputLocked(rd, buf);
+}
 
-    // We are modifying terminal state from here on out
-    ev.renderer_state.mutex.lock();
-    defer ev.renderer_state.mutex.unlock();
+/// Process output when you ahve the read data pointer.
+pub fn processOutputReadData(rd: *ReadData, buf: []const u8) void {
+    rd.renderer_state.mutex.lock();
+    defer rd.renderer_state.mutex.unlock();
+    processOutputLocked(rd, buf);
+}
 
+/// Process output from readdata but the lock is already held.
+fn processOutputLocked(rd: *ReadData, buf: []const u8) void {
     // Schedule a render. We can call this first because we have the lock.
-    ev.terminal_stream.handler.queueRender() catch unreachable;
+    rd.terminal_stream.handler.queueRender() catch unreachable;
 
     // Whenever a character is typed, we ensure the cursor is in the
     // non-blink state so it is rendered if visible. If we're under
     // HEAVY read load, we don't want to send a ton of these so we
     // use a timer under the covers
-    const now = ev.loop.now();
-    if (now - ev.last_cursor_reset > 500) {
-        ev.last_cursor_reset = now;
-        _ = ev.renderer_mailbox.push(.{
+    const now = rd.loop.now();
+    if (now - rd.last_cursor_reset > 500) {
+        rd.last_cursor_reset = now;
+        _ = rd.renderer_mailbox.push(.{
             .reset_cursor_blink = {},
         }, .{ .forever = {} });
     }
@@ -739,26 +755,26 @@ fn readInternal(
     // process a byte at a time alternating between the inspector handler
     // and the termio handler. This is very slow compared to our optimizations
     // below but at least users only pay for it if they're using the inspector.
-    if (ev.renderer_state.inspector) |insp| {
+    if (rd.renderer_state.inspector) |insp| {
         for (buf, 0..) |byte, i| {
             insp.recordPtyRead(buf[i .. i + 1]) catch |err| {
                 log.err("error recording pty read in inspector err={}", .{err});
             };
 
-            ev.terminal_stream.next(byte) catch |err|
+            rd.terminal_stream.next(byte) catch |err|
                 log.err("error processing terminal data: {}", .{err});
         }
     } else {
-        ev.terminal_stream.nextSlice(buf) catch |err|
+        rd.terminal_stream.nextSlice(buf) catch |err|
             log.err("error processing terminal data: {}", .{err});
     }
 
     // If our stream handling caused messages to be sent to the writer
     // thread, then we need to wake it up so that it processes them.
-    if (ev.terminal_stream.handler.writer_messaged) {
-        ev.terminal_stream.handler.writer_messaged = false;
+    if (rd.terminal_stream.handler.writer_messaged) {
+        rd.terminal_stream.handler.writer_messaged = false;
         // TODO
-        // ev.writer_wakeup.notify() catch |err| {
+        // rd.writer_wakeup.notify() catch |err| {
         //     log.warn("failed to wake up writer thread err={}", .{err});
         // };
     }
@@ -804,7 +820,7 @@ pub const ThreadData = struct {
     }
 };
 
-/// Thread local data for the reader thread.
+/// The data required for the read thread.
 pub const ReadData = struct {
     /// The stream parser. This parses the stream of escape codes and so on
     /// from the child process and calls callbacks in the stream handler.
@@ -1022,7 +1038,7 @@ const ReadThread = struct {
                 if (n == 0) break;
 
                 // log.info("DATA: {d}", .{n});
-                @call(.always_inline, readInternal, .{ ev, buf[0..n] });
+                @call(.always_inline, processOutputReadData, .{ ev, buf[0..n] });
             }
 
             // Wait for data.
@@ -1060,7 +1076,7 @@ const ReadThread = struct {
                     }
                 }
 
-                @call(.always_inline, readInternal, .{ ev, buf[0..n] });
+                @call(.always_inline, processOutputReadData, .{ ev, buf[0..n] });
             }
 
             var quit_bytes: windows.DWORD = 0;

commit e30e635bed649704f960fa6ee51263679a99413e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 19:23:45 2024 -0700

    termio: move all subprocess logic to termio.Exec

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index c8fdd471..e38d5470 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -172,20 +172,11 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    var subprocess = try termio.Exec.init(alloc, opts);
+    // Setup our reader.
+    // TODO: for manual, we need to set the terminal width/height
+    var subprocess = try termio.Exec.init(alloc, opts, &term);
     errdefer subprocess.deinit();
 
-    // If we have an initial pwd requested by the subprocess, then we
-    // set that on the terminal now. This allows rapidly initializing
-    // new surfaces to use the proper pwd.
-    if (subprocess.cwd) |cwd| term.setPwd(cwd) catch |err| {
-        log.warn("error setting initial pwd err={}", .{err});
-    };
-
-    // Initial width/height based on subprocess
-    term.width_px = subprocess.screen_size.width;
-    term.height_px = subprocess.screen_size.height;
-
     return .{
         .alloc = alloc,
         .terminal = term,
@@ -208,52 +199,14 @@ pub fn deinit(self: *Termio) void {
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
     const alloc = self.alloc;
 
-    // Start our subprocess
-    const pty_fds = self.subprocess.start(alloc) catch |err| {
-        // If we specifically got this error then we are in the forked
-        // process and our child failed to execute. In that case
-        if (err != error.Termio) return err;
-
-        // Output an error message about the exec faililng and exit.
-        // This generally should NOT happen because we always wrap
-        // our command execution either in login (macOS) or /bin/sh
-        // (Linux) which are usually guaranteed to exist. Still, we
-        // want to handle this scenario.
-        self.execFailedInChild() catch {};
-        posix.exit(1);
-    };
-    errdefer self.subprocess.stop();
-    const pid = pid: {
-        const command = self.subprocess.command orelse return error.ProcessNotStarted;
-        break :pid command.pid orelse return error.ProcessNoPid;
-    };
-
-    // Track our process start time so we know how long it was
-    // running for.
-    const process_start = try std.time.Instant.now();
-
-    // Create our pipe that we'll use to kill our read thread.
-    // pipe[0] is the read end, pipe[1] is the write end.
-    const pipe = try internal_os.pipe();
-    errdefer posix.close(pipe[0]);
-    errdefer posix.close(pipe[1]);
-
     // Setup our data that is used for callbacks
     var read_data_ptr = try alloc.create(ReadData);
     errdefer alloc.destroy(read_data_ptr);
 
-    // Setup our stream so that we can write.
-    var stream = xev.Stream.initFd(pty_fds.write);
-    errdefer stream.deinit();
-
     // Wakeup watcher for the writer thread.
     var wakeup = try xev.Async.init();
     errdefer wakeup.deinit();
 
-    // Watcher to detect subprocess exit
-    var process = try xev.Process.init(pid);
-    errdefer process.deinit();
-
     // Create our stream handler
     const handler: StreamHandler = handler: {
         const default_cursor_color = if (self.config.cursor_color) |col|
@@ -303,15 +256,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     };
     errdefer read_data_ptr.deinit();
 
-    // Start our reader thread
-    const read_thread = try std.Thread.spawn(
-        .{},
-        if (builtin.os.tag == .windows) ReadThread.threadMainWindows else ReadThread.threadMainPosix,
-        .{ pty_fds.read, read_data_ptr, pipe[0] },
-    );
-    read_thread.setName("io-reader") catch {};
-
-    // Return our thread data
+    // Setup our thread data
     data.* = .{
         .alloc = alloc,
         .loop = &thread.loop,
@@ -319,27 +264,14 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .surface_mailbox = self.surface_mailbox,
         .writer_mailbox = thread.mailbox,
         .writer_wakeup = thread.wakeup,
-        .reader = .{ .exec = .{
-            .start = process_start,
-            .abnormal_runtime_threshold_ms = self.config.abnormal_runtime_threshold_ms,
-            .wait_after_command = self.config.wait_after_command,
-            .write_stream = stream,
-            .process = process,
-        } },
-        .read_thread = read_thread,
-        .read_thread_pipe = pipe[1],
-        .read_thread_fd = if (builtin.os.tag == .windows) pty_fds.read else {},
-        .read_thread_data = read_data_ptr,
+        .read_data = read_data_ptr,
+
+        // Placeholder until setup below
+        .reader = .{ .manual = {} },
     };
 
-    // Start our process watcher
-    process.wait(
-        &thread.loop,
-        &data.reader.exec.process_wait_c,
-        ThreadData,
-        data,
-        processExit,
-    );
+    // Setup our reader
+    try self.subprocess.threadEnter(alloc, self, data);
 }
 
 /// This outputs an error message when exec failed and we are the
@@ -363,33 +295,7 @@ fn execFailedInChild(self: *Termio) !void {
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
-    // Stop our reader
-    switch (data.reader) {
-        .manual => {},
-
-        .exec => |exec| {
-            if (exec.exited) self.subprocess.externalExit();
-            self.subprocess.stop();
-
-            // Quit our read thread after exiting the subprocess so that
-            // we don't get stuck waiting for data to stop flowing if it is
-            // a particularly noisy process.
-            _ = posix.write(data.read_thread_pipe, "x") catch |err|
-                log.warn("error writing to read thread quit pipe err={}", .{err});
-
-            if (comptime builtin.os.tag == .windows) {
-                // Interrupt the blocking read so the thread can see the quit message
-                if (windows.kernel32.CancelIoEx(data.read_thread_fd, null) == 0) {
-                    switch (windows.kernel32.GetLastError()) {
-                        .NOT_FOUND => {},
-                        else => |err| log.warn("error interrupting read thread err={}", .{err}),
-                    }
-                }
-            }
-
-            data.read_thread.join();
-        },
-    }
+    self.subprocess.threadExit(data);
 }
 
 /// Update the configuration.
@@ -408,7 +314,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
     // Update our stream handler. The stream handler uses the same
     // renderer mutex so this is safe to do despite being executed
     // from another thread.
-    td.read_thread_data.terminal_stream.handler.changeConfig(&self.config);
+    td.read_data.terminal_stream.handler.changeConfig(&self.config);
     td.reader.changeConfig(&self.config);
 
     // Update the configuration that we know about.
@@ -552,78 +458,10 @@ pub fn jumpToPrompt(self: *Termio, delta: isize) !void {
 /// Called when the child process exited abnormally but before
 /// the surface is notified.
 pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !void {
-    var arena = ArenaAllocator.init(self.alloc);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    // Build up our command for the error message
-    const command = try std.mem.join(alloc, " ", self.subprocess.args);
-    const runtime_str = try std.fmt.allocPrint(alloc, "{d} ms", .{runtime_ms});
-
-    // Modify the terminal to show our error message. This
-    // requires grabbing the renderer state lock.
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     const t = self.renderer_state.terminal;
-
-    // No matter what move the cursor back to the column 0.
-    t.carriageReturn();
-
-    // Reset styles
-    try t.setAttribute(.{ .unset = {} });
-
-    // If there is data in the viewport, we want to scroll down
-    // a little bit and write a horizontal rule before writing
-    // our message. This lets the use see the error message the
-    // command may have output.
-    const viewport_str = try t.plainString(alloc);
-    if (viewport_str.len > 0) {
-        try t.linefeed();
-        for (0..t.cols) |_| try t.print(0x2501);
-        t.carriageReturn();
-        try t.linefeed();
-        try t.linefeed();
-    }
-
-    // Output our error message
-    try t.setAttribute(.{ .@"8_fg" = .bright_red });
-    try t.setAttribute(.{ .bold = {} });
-    try t.printString("Ghostty failed to launch the requested command:");
-    try t.setAttribute(.{ .unset = {} });
-
-    t.carriageReturn();
-    try t.linefeed();
-    try t.linefeed();
-    try t.printString(command);
-    try t.setAttribute(.{ .unset = {} });
-
-    t.carriageReturn();
-    try t.linefeed();
-    try t.linefeed();
-    try t.printString("Runtime: ");
-    try t.setAttribute(.{ .@"8_fg" = .red });
-    try t.printString(runtime_str);
-    try t.setAttribute(.{ .unset = {} });
-
-    // We don't print this on macOS because the exit code is always 0
-    // due to the way we launch the process.
-    if (comptime !builtin.target.isDarwin()) {
-        const exit_code_str = try std.fmt.allocPrint(alloc, "{d}", .{exit_code});
-        t.carriageReturn();
-        try t.linefeed();
-        try t.printString("Exit Code: ");
-        try t.setAttribute(.{ .@"8_fg" = .red });
-        try t.printString(exit_code_str);
-        try t.setAttribute(.{ .unset = {} });
-    }
-
-    t.carriageReturn();
-    try t.linefeed();
-    try t.linefeed();
-    try t.printString("Press any key to close the window.");
-
-    // Hide the cursor
-    t.modes.set(.cursor_visible, false);
+    try self.subprocess.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
 pub inline fn queueWrite(
@@ -632,85 +470,7 @@ pub inline fn queueWrite(
     data: []const u8,
     linefeed: bool,
 ) !void {
-    switch (td.reader) {
-        .manual => {},
-        .exec => try self.queueWriteExec(
-            td,
-            data,
-            linefeed,
-        ),
-    }
-}
-
-fn queueWriteExec(
-    self: *Termio,
-    td: *ThreadData,
-    data: []const u8,
-    linefeed: bool,
-) !void {
-    const exec = &td.reader.exec;
-
-    // If our process is exited then we send our surface a message
-    // about it but we don't queue any more writes.
-    if (exec.exited) {
-        _ = td.surface_mailbox.push(.{
-            .child_exited = {},
-        }, .{ .forever = {} });
-        return;
-    }
-
-    // We go through and chunk the data if necessary to fit into
-    // our cached buffers that we can queue to the stream.
-    var i: usize = 0;
-    while (i < data.len) {
-        const req = try exec.write_req_pool.getGrow(self.alloc);
-        const buf = try exec.write_buf_pool.getGrow(self.alloc);
-        const slice = slice: {
-            // The maximum end index is either the end of our data or
-            // the end of our buffer, whichever is smaller.
-            const max = @min(data.len, i + buf.len);
-
-            // Fast
-            if (!linefeed) {
-                fastmem.copy(u8, buf, data[i..max]);
-                const len = max - i;
-                i = max;
-                break :slice buf[0..len];
-            }
-
-            // Slow, have to replace \r with \r\n
-            var buf_i: usize = 0;
-            while (i < data.len and buf_i < buf.len - 1) {
-                const ch = data[i];
-                i += 1;
-
-                if (ch != '\r') {
-                    buf[buf_i] = ch;
-                    buf_i += 1;
-                    continue;
-                }
-
-                // CRLF
-                buf[buf_i] = '\r';
-                buf[buf_i + 1] = '\n';
-                buf_i += 2;
-            }
-
-            break :slice buf[0..buf_i];
-        };
-
-        //for (slice) |b| log.warn("write: {x}", .{b});
-
-        exec.write_stream.queueWrite(
-            td.loop,
-            &exec.write_queue,
-            req,
-            .{ .slice = slice },
-            termio.reader.ThreadData.Exec,
-            exec,
-            ttyWrite,
-        );
-    }
+    try self.subprocess.queueWrite(self.alloc, td, data, linefeed);
 }
 
 /// Process output from the pty. This is the manual API that users can
@@ -804,18 +564,12 @@ pub const ThreadData = struct {
 
     /// Data associated with the reader implementation (i.e. pty/exec state)
     reader: termio.reader.ThreadData,
-
-    /// Our read thread
-    read_thread: std.Thread,
-    read_thread_pipe: posix.fd_t,
-    read_thread_fd: if (builtin.os.tag == .windows) posix.fd_t else void,
-    read_thread_data: *ReadData,
+    read_data: *ReadData,
 
     pub fn deinit(self: *ThreadData) void {
-        posix.close(self.read_thread_pipe);
-        self.read_thread_data.deinit();
         self.reader.deinit(self.alloc);
-        self.alloc.destroy(self.read_thread_data);
+        self.read_data.deinit();
+        self.alloc.destroy(self.read_data);
         self.* = undefined;
     }
 };
@@ -849,247 +603,3 @@ pub const ReadData = struct {
         self.terminal_stream.deinit();
     }
 };
-
-fn processExit(
-    td_: ?*ThreadData,
-    _: *xev.Loop,
-    _: *xev.Completion,
-    r: xev.Process.WaitError!u32,
-) xev.CallbackAction {
-    const exit_code = r catch unreachable;
-
-    const td = td_.?;
-    assert(td.reader == .exec);
-    const execdata = &td.reader.exec;
-    execdata.exited = true;
-
-    // Determine how long the process was running for.
-    const runtime_ms: ?u64 = runtime: {
-        const process_end = std.time.Instant.now() catch break :runtime null;
-        const runtime_ns = process_end.since(execdata.start);
-        const runtime_ms = runtime_ns / std.time.ns_per_ms;
-        break :runtime runtime_ms;
-    };
-    log.debug(
-        "child process exited status={} runtime={}ms",
-        .{ exit_code, runtime_ms orelse 0 },
-    );
-
-    // If our runtime was below some threshold then we assume that this
-    // was an abnormal exit and we show an error message.
-    if (runtime_ms) |runtime| runtime: {
-        // On macOS, our exit code detection doesn't work, possibly
-        // because of our `login` wrapper. More investigation required.
-        if (comptime !builtin.target.isDarwin()) {
-            // If our exit code is zero, then the command was successful
-            // and we don't ever consider it abnormal.
-            if (exit_code == 0) break :runtime;
-        }
-
-        // Our runtime always has to be under the threshold to be
-        // considered abnormal. This is because a user can always
-        // manually do something like `exit 1` in their shell to
-        // force the exit code to be non-zero. We only want to detect
-        // abnormal exits that happen so quickly the user can't react.
-        if (runtime > execdata.abnormal_runtime_threshold_ms) break :runtime;
-        log.warn("abnormal process exit detected, showing error message", .{});
-
-        // Notify our main writer thread which has access to more
-        // information so it can show a better error message.
-        _ = td.writer_mailbox.push(.{
-            .child_exited_abnormally = .{
-                .exit_code = exit_code,
-                .runtime_ms = runtime,
-            },
-        }, .{ .forever = {} });
-        td.writer_wakeup.notify() catch break :runtime;
-
-        return .disarm;
-    }
-
-    // If we're purposely waiting then we just return since the process
-    // exited flag is set to true. This allows the terminal window to remain
-    // open.
-    if (execdata.wait_after_command) {
-        // We output a message so that the user knows whats going on and
-        // doesn't think their terminal just froze.
-        terminal: {
-            td.renderer_state.mutex.lock();
-            defer td.renderer_state.mutex.unlock();
-            const t = td.renderer_state.terminal;
-            t.carriageReturn();
-            t.linefeed() catch break :terminal;
-            t.printString("Process exited. Press any key to close the terminal.") catch
-                break :terminal;
-            t.modes.set(.cursor_visible, false);
-        }
-
-        return .disarm;
-    }
-
-    // Notify our surface we want to close
-    _ = td.surface_mailbox.push(.{
-        .child_exited = {},
-    }, .{ .forever = {} });
-
-    return .disarm;
-}
-
-fn ttyWrite(
-    td_: ?*termio.reader.ThreadData.Exec,
-    _: *xev.Loop,
-    _: *xev.Completion,
-    _: xev.Stream,
-    _: xev.WriteBuffer,
-    r: xev.Stream.WriteError!usize,
-) xev.CallbackAction {
-    const td = td_.?;
-    td.write_req_pool.put();
-    td.write_buf_pool.put();
-
-    const d = r catch |err| {
-        log.err("write error: {}", .{err});
-        return .disarm;
-    };
-    _ = d;
-    //log.info("WROTE: {d}", .{d});
-
-    return .disarm;
-}
-
-/// The read thread sits in a loop doing the following pseudo code:
-///
-///   while (true) { blocking_read(); exit_if_eof(); process(); }
-///
-/// Almost all terminal-modifying activity is from the pty read, so
-/// putting this on a dedicated thread keeps performance very predictable
-/// while also almost optimal. "Locking is fast, lock contention is slow."
-/// and since we rarely have contention, this is fast.
-///
-/// This is also empirically fast compared to putting the read into
-/// an async mechanism like io_uring/epoll because the reads are generally
-/// small.
-///
-/// We use a basic poll syscall here because we are only monitoring two
-/// fds and this is still much faster and lower overhead than any async
-/// mechanism.
-const ReadThread = struct {
-    fn threadMainPosix(fd: posix.fd_t, ev: *ReadData, quit: posix.fd_t) void {
-        // Always close our end of the pipe when we exit.
-        defer posix.close(quit);
-
-        // First thing, we want to set the fd to non-blocking. We do this
-        // so that we can try to read from the fd in a tight loop and only
-        // check the quit fd occasionally.
-        if (posix.fcntl(fd, posix.F.GETFL, 0)) |flags| {
-            _ = posix.fcntl(
-                fd,
-                posix.F.SETFL,
-                flags | @as(u32, @bitCast(posix.O{ .NONBLOCK = true })),
-            ) catch |err| {
-                log.warn("read thread failed to set flags err={}", .{err});
-                log.warn("this isn't a fatal error, but may cause performance issues", .{});
-            };
-        } else |err| {
-            log.warn("read thread failed to get flags err={}", .{err});
-            log.warn("this isn't a fatal error, but may cause performance issues", .{});
-        }
-
-        // Build up the list of fds we're going to poll. We are looking
-        // for data on the pty and our quit notification.
-        var pollfds: [2]posix.pollfd = .{
-            .{ .fd = fd, .events = posix.POLL.IN, .revents = undefined },
-            .{ .fd = quit, .events = posix.POLL.IN, .revents = undefined },
-        };
-
-        var buf: [1024]u8 = undefined;
-        while (true) {
-            // We try to read from the file descriptor as long as possible
-            // to maximize performance. We only check the quit fd if the
-            // main fd blocks. This optimizes for the realistic scenario that
-            // the data will eventually stop while we're trying to quit. This
-            // is always true because we kill the process.
-            while (true) {
-                const n = posix.read(fd, &buf) catch |err| {
-                    switch (err) {
-                        // This means our pty is closed. We're probably
-                        // gracefully shutting down.
-                        error.NotOpenForReading,
-                        error.InputOutput,
-                        => {
-                            log.info("io reader exiting", .{});
-                            return;
-                        },
-
-                        // No more data, fall back to poll and check for
-                        // exit conditions.
-                        error.WouldBlock => break,
-
-                        else => {
-                            log.err("io reader error err={}", .{err});
-                            unreachable;
-                        },
-                    }
-                };
-
-                // This happens on macOS instead of WouldBlock when the
-                // child process dies. To be safe, we just break the loop
-                // and let our poll happen.
-                if (n == 0) break;
-
-                // log.info("DATA: {d}", .{n});
-                @call(.always_inline, processOutputReadData, .{ ev, buf[0..n] });
-            }
-
-            // Wait for data.
-            _ = posix.poll(&pollfds, -1) catch |err| {
-                log.warn("poll failed on read thread, exiting early err={}", .{err});
-                return;
-            };
-
-            // If our quit fd is set, we're done.
-            if (pollfds[1].revents & posix.POLL.IN != 0) {
-                log.info("read thread got quit signal", .{});
-                return;
-            }
-        }
-    }
-
-    fn threadMainWindows(fd: posix.fd_t, ev: *ReadData, quit: posix.fd_t) void {
-        // Always close our end of the pipe when we exit.
-        defer posix.close(quit);
-
-        var buf: [1024]u8 = undefined;
-        while (true) {
-            while (true) {
-                var n: windows.DWORD = 0;
-                if (windows.kernel32.ReadFile(fd, &buf, buf.len, &n, null) == 0) {
-                    const err = windows.kernel32.GetLastError();
-                    switch (err) {
-                        // Check for a quit signal
-                        .OPERATION_ABORTED => break,
-
-                        else => {
-                            log.err("io reader error err={}", .{err});
-                            unreachable;
-                        },
-                    }
-                }
-
-                @call(.always_inline, processOutputReadData, .{ ev, buf[0..n] });
-            }
-
-            var quit_bytes: windows.DWORD = 0;
-            if (windows.exp.kernel32.PeekNamedPipe(quit, null, 0, null, &quit_bytes, null) == 0) {
-                const err = windows.kernel32.GetLastError();
-                log.err("quit pipe reader error err={}", .{err});
-                unreachable;
-            }
-
-            if (quit_bytes > 0) {
-                log.info("read thread got quit signal", .{});
-                return;
-            }
-        }
-    }
-};

commit eec33f10e22b1dc9bc1f7829d81fe0542dc89450
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 13 19:27:17 2024 -0700

    termio: remove more unused things

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index e38d5470..be7614af 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -30,17 +30,6 @@ const shell_integration = @import("shell_integration.zig");
 
 const log = std.log.scoped(.io_exec);
 
-const c = @cImport({
-    @cInclude("errno.h");
-    @cInclude("signal.h");
-    @cInclude("unistd.h");
-});
-
-/// True if we should disable the kitty keyboard protocol. We have to
-/// disable this on GLFW because GLFW input events don't support the
-/// correct granularity of events.
-const disable_kitty_keyboard_protocol = apprt.runtime == apprt.glfw;
-
 /// Allocator
 alloc: Allocator,
 
@@ -272,30 +261,20 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
 
     // Setup our reader
     try self.subprocess.threadEnter(alloc, self, data);
-}
 
-/// This outputs an error message when exec failed and we are the
-/// child process. This returns so the caller should probably exit
-/// after calling this.
-///
-/// Note that this usually is only called under very very rare
-/// circumstances because we wrap our command execution in login
-/// (macOS) or /bin/sh (Linux). So this output can be pretty crude
-/// because it should never happen. Notably, this is not the error
-/// users see when `command` is invalid.
-fn execFailedInChild(self: *Termio) !void {
-    _ = self;
-    const stderr = std.io.getStdErr().writer();
-    try stderr.writeAll("exec failed\n");
-    try stderr.writeAll("press any key to exit\n");
-
-    var buf: [1]u8 = undefined;
-    var reader = std.io.getStdIn().reader();
-    _ = try reader.read(&buf);
+    // Store our read data pointer
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    self.read_data = read_data_ptr;
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
     self.subprocess.threadExit(data);
+
+    // Clear our read data pointer
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    self.read_data = null;
 }
 
 /// Update the configuration.

commit f50c15c35014cd8a63350e1ea43e8ee1ce44b462
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 14 09:40:53 2024 -0700

    termio: ReadData doesn't need a loop

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index be7614af..5eebb3c6 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -231,7 +231,6 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .renderer_state = self.renderer_state,
         .renderer_wakeup = self.renderer_wakeup,
         .renderer_mailbox = self.renderer_mailbox,
-        .loop = &thread.loop,
         .terminal_stream = .{
             .handler = handler,
             .parser = .{
@@ -482,12 +481,19 @@ fn processOutputLocked(rd: *ReadData, buf: []const u8) void {
     // non-blink state so it is rendered if visible. If we're under
     // HEAVY read load, we don't want to send a ton of these so we
     // use a timer under the covers
-    const now = rd.loop.now();
-    if (now - rd.last_cursor_reset > 500) {
+    if (std.time.Instant.now()) |now| cursor_reset: {
+        if (rd.last_cursor_reset) |last| {
+            if (now.since(last) <= (500 / std.time.ns_per_ms)) {
+                break :cursor_reset;
+            }
+        }
+
         rd.last_cursor_reset = now;
         _ = rd.renderer_mailbox.push(.{
             .reset_cursor_blink = {},
-        }, .{ .forever = {} });
+        }, .{ .instant = {} });
+    } else |err| {
+        log.warn("failed to get current time err={}", .{err});
     }
 
     // If we have an inspector, we enter SLOW MODE because we need to
@@ -569,12 +575,9 @@ pub const ReadData = struct {
     /// The mailbox for notifying the renderer of things.
     renderer_mailbox: *renderer.Thread.Mailbox,
 
-    /// The event loop,
-    loop: *xev.Loop,
-
     /// Last time the cursor was reset. This is used to prevent message
     /// flooding with cursor resets.
-    last_cursor_reset: i64 = 0,
+    last_cursor_reset: ?std.time.Instant = null,
 
     pub fn deinit(self: *ReadData) void {
         // Clear any StreamHandler state

commit af7adedb50dd954d94adde976b613cf9634aa3fd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 14 14:48:48 2024 -0700

    termio: writer abstraction

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 5eebb3c6..a329e288 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -60,6 +60,9 @@ surface_mailbox: apprt.surface.Mailbox,
 /// The cached grid size whenever a resize is called.
 grid_size: renderer.GridSize,
 
+/// The writer implementation to use.
+writer: termio.Writer,
+
 /// The pointer to the read data. This is only valid while the termio thread
 /// is alive. This is protected by the renderer state lock.
 read_data: ?*ReadData = null,
@@ -176,6 +179,7 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
+        .writer = opts.writer,
     };
 }
 
@@ -183,6 +187,7 @@ pub fn deinit(self: *Termio) void {
     self.subprocess.deinit();
     self.terminal.deinit(self.alloc);
     self.config.deinit();
+    self.writer.deinit(self.alloc);
 }
 
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
@@ -205,8 +210,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
 
         break :handler .{
             .alloc = self.alloc,
-            .writer_mailbox = thread.mailbox,
-            .writer_wakeup = thread.wakeup,
+            .writer = &self.writer,
             .surface_mailbox = self.surface_mailbox,
             .renderer_state = self.renderer_state,
             .renderer_wakeup = self.renderer_wakeup,
@@ -250,9 +254,8 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .loop = &thread.loop,
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
-        .writer_mailbox = thread.mailbox,
-        .writer_wakeup = thread.wakeup,
         .read_data = read_data_ptr,
+        .writer = &self.writer,
 
         // Placeholder until setup below
         .reader = .{ .manual = {} },
@@ -276,6 +279,40 @@ pub fn threadExit(self: *Termio, data: *ThreadData) void {
     self.read_data = null;
 }
 
+/// Send a message using the writer. Depending on the writer type in
+/// use this may process now or it may just enqueue and process later.
+///
+/// This will also notify the writer thread to process the message. If
+/// you're sending a lot of messages, it may be more efficient to use
+/// the writer directly and then call notify separately.
+pub fn queueMessage(
+    self: *Termio,
+    msg: termio.Message,
+    mutex: enum { locked, unlocked },
+) void {
+    self.writer.send(msg, switch (mutex) {
+        .locked => self.renderer_state.mutex,
+        .unlocked => null,
+    });
+    self.writer.notify();
+}
+
+/// Queue a write directly to the pty.
+///
+/// If you're using termio.Thread, this must ONLY be called from the
+/// writer thread. If you're not on the thread, use queueMessage with
+/// writer messages instead.
+///
+/// If you're not using termio.Thread, this is not threadsafe.
+pub inline fn queueWrite(
+    self: *Termio,
+    td: *ThreadData,
+    data: []const u8,
+    linefeed: bool,
+) !void {
+    try self.subprocess.queueWrite(self.alloc, td, data, linefeed);
+}
+
 /// Update the configuration.
 pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !void {
     // The remainder of this function is modifying terminal state or
@@ -442,15 +479,6 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
     try self.subprocess.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
-pub inline fn queueWrite(
-    self: *Termio,
-    td: *ThreadData,
-    data: []const u8,
-    linefeed: bool,
-) !void {
-    try self.subprocess.queueWrite(self.alloc, td, data, linefeed);
-}
-
 /// Process output from the pty. This is the manual API that users can
 /// call with pty data but it is also called by the read thread when using
 /// an exec subprocess.
@@ -544,12 +572,11 @@ pub const ThreadData = struct {
 
     /// Mailboxes for different threads
     surface_mailbox: apprt.surface.Mailbox,
-    writer_mailbox: *termio.Mailbox,
-    writer_wakeup: xev.Async,
 
     /// Data associated with the reader implementation (i.e. pty/exec state)
     reader: termio.reader.ThreadData,
     read_data: *ReadData,
+    writer: *termio.Writer,
 
     pub fn deinit(self: *ThreadData) void {
         self.reader.deinit(self.alloc);

commit a848a53d26c48a0ba82992b60da247ddbafcf7db
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 14 15:10:05 2024 -0700

    termio: remove a ton of state

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index a329e288..a2367928 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -67,6 +67,14 @@ writer: termio.Writer,
 /// is alive. This is protected by the renderer state lock.
 read_data: ?*ReadData = null,
 
+/// The stream parser. This parses the stream of escape codes and so on
+/// from the child process and calls callbacks in the stream handler.
+terminal_stream: terminal.Stream(StreamHandler),
+
+/// Last time the cursor was reset. This is used to prevent message
+/// flooding with cursor resets.
+last_cursor_reset: ?std.time.Instant = null,
+
 /// The configuration for this IO that is derived from the main
 /// configuration. This must be exported so that we don't need to
 /// pass around Config pointers which makes memory management a pain.
@@ -125,7 +133,7 @@ pub const DerivedConfig = struct {
 ///
 /// This will also start the child process if the termio is configured
 /// to run a child process.
-pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
+pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Create our terminal
     var term = try terminal.Terminal.init(alloc, .{
         .cols = opts.grid_size.columns,
@@ -169,7 +177,37 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
     var subprocess = try termio.Exec.init(alloc, opts, &term);
     errdefer subprocess.deinit();
 
-    return .{
+    // Create our stream handler. This points to memory in self so it
+    // isn't safe to use until self.* is set.
+    const handler: StreamHandler = handler: {
+        const default_cursor_color = if (opts.config.cursor_color) |col|
+            col.toTerminalRGB()
+        else
+            null;
+
+        break :handler .{
+            .alloc = alloc,
+            .writer = &self.writer,
+            .surface_mailbox = opts.surface_mailbox,
+            .renderer_state = opts.renderer_state,
+            .renderer_wakeup = opts.renderer_wakeup,
+            .renderer_mailbox = opts.renderer_mailbox,
+            .grid_size = &self.grid_size,
+            .terminal = &self.terminal,
+            .osc_color_report_format = opts.config.osc_color_report_format,
+            .enquiry_response = opts.config.enquiry_response,
+            .default_foreground_color = opts.config.foreground.toTerminalRGB(),
+            .default_background_color = opts.config.background.toTerminalRGB(),
+            .default_cursor_style = opts.config.cursor_style,
+            .default_cursor_blink = opts.config.cursor_blink,
+            .default_cursor_color = default_cursor_color,
+            .cursor_color = default_cursor_color,
+            .foreground_color = opts.config.foreground.toTerminalRGB(),
+            .background_color = opts.config.background.toTerminalRGB(),
+        };
+    };
+
+    self.* = .{
         .alloc = alloc,
         .terminal = term,
         .subprocess = subprocess,
@@ -180,6 +218,16 @@ pub fn init(alloc: Allocator, opts: termio.Options) !Termio {
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
         .writer = opts.writer,
+        .terminal_stream = .{
+            .handler = handler,
+            .parser = .{
+                .osc_parser = .{
+                    // Populate the OSC parser allocator (optional) because
+                    // we want to support large OSC payloads such as OSC 52.
+                    .alloc = alloc,
+                },
+            },
+        },
     };
 }
 
@@ -188,73 +236,25 @@ pub fn deinit(self: *Termio) void {
     self.terminal.deinit(self.alloc);
     self.config.deinit();
     self.writer.deinit(self.alloc);
+
+    // Clear any StreamHandler state
+    self.terminal_stream.handler.deinit();
+    self.terminal_stream.deinit();
 }
 
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
     const alloc = self.alloc;
 
-    // Setup our data that is used for callbacks
-    var read_data_ptr = try alloc.create(ReadData);
-    errdefer alloc.destroy(read_data_ptr);
-
     // Wakeup watcher for the writer thread.
     var wakeup = try xev.Async.init();
     errdefer wakeup.deinit();
 
-    // Create our stream handler
-    const handler: StreamHandler = handler: {
-        const default_cursor_color = if (self.config.cursor_color) |col|
-            col.toTerminalRGB()
-        else
-            null;
-
-        break :handler .{
-            .alloc = self.alloc,
-            .writer = &self.writer,
-            .surface_mailbox = self.surface_mailbox,
-            .renderer_state = self.renderer_state,
-            .renderer_wakeup = self.renderer_wakeup,
-            .renderer_mailbox = self.renderer_mailbox,
-            .grid_size = &self.grid_size,
-            .terminal = &self.terminal,
-            .osc_color_report_format = self.config.osc_color_report_format,
-            .enquiry_response = self.config.enquiry_response,
-            .default_foreground_color = self.config.foreground.toTerminalRGB(),
-            .default_background_color = self.config.background.toTerminalRGB(),
-            .default_cursor_style = self.config.cursor_style,
-            .default_cursor_blink = self.config.cursor_blink,
-            .default_cursor_color = default_cursor_color,
-            .cursor_color = default_cursor_color,
-            .foreground_color = self.config.foreground.toTerminalRGB(),
-            .background_color = self.config.background.toTerminalRGB(),
-        };
-    };
-
-    // Setup our event data before we start
-    read_data_ptr.* = .{
-        .renderer_state = self.renderer_state,
-        .renderer_wakeup = self.renderer_wakeup,
-        .renderer_mailbox = self.renderer_mailbox,
-        .terminal_stream = .{
-            .handler = handler,
-            .parser = .{
-                .osc_parser = .{
-                    // Populate the OSC parser allocator (optional) because
-                    // we want to support large OSC payloads such as OSC 52.
-                    .alloc = self.alloc,
-                },
-            },
-        },
-    };
-    errdefer read_data_ptr.deinit();
-
     // Setup our thread data
     data.* = .{
         .alloc = alloc,
         .loop = &thread.loop,
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
-        .read_data = read_data_ptr,
         .writer = &self.writer,
 
         // Placeholder until setup below
@@ -263,20 +263,10 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
 
     // Setup our reader
     try self.subprocess.threadEnter(alloc, self, data);
-
-    // Store our read data pointer
-    self.renderer_state.mutex.lock();
-    defer self.renderer_state.mutex.unlock();
-    self.read_data = read_data_ptr;
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
     self.subprocess.threadExit(data);
-
-    // Clear our read data pointer
-    self.renderer_state.mutex.lock();
-    defer self.renderer_state.mutex.unlock();
-    self.read_data = null;
 }
 
 /// Send a message using the writer. Depending on the writer type in
@@ -329,7 +319,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
     // Update our stream handler. The stream handler uses the same
     // renderer mutex so this is safe to do despite being executed
     // from another thread.
-    td.read_data.terminal_stream.handler.changeConfig(&self.config);
+    self.terminal_stream.handler.changeConfig(&self.config);
     td.reader.changeConfig(&self.config);
 
     // Update the configuration that we know about.
@@ -482,42 +472,32 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
 /// Process output from the pty. This is the manual API that users can
 /// call with pty data but it is also called by the read thread when using
 /// an exec subprocess.
-pub fn processOutput(self: *Termio, buf: []const u8) !void {
+pub fn processOutput(self: *Termio, buf: []const u8) void {
     // We are modifying terminal state from here on out and we need
     // the lock to grab our read data.
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
-
-    // If we don't have read data, we can't process it.
-    const rd = self.read_data orelse return error.ReadDataNull;
-    processOutputLocked(rd, buf);
-}
-
-/// Process output when you ahve the read data pointer.
-pub fn processOutputReadData(rd: *ReadData, buf: []const u8) void {
-    rd.renderer_state.mutex.lock();
-    defer rd.renderer_state.mutex.unlock();
-    processOutputLocked(rd, buf);
+    self.processOutputLocked(buf);
 }
 
 /// Process output from readdata but the lock is already held.
-fn processOutputLocked(rd: *ReadData, buf: []const u8) void {
+fn processOutputLocked(self: *Termio, buf: []const u8) void {
     // Schedule a render. We can call this first because we have the lock.
-    rd.terminal_stream.handler.queueRender() catch unreachable;
+    self.terminal_stream.handler.queueRender() catch unreachable;
 
     // Whenever a character is typed, we ensure the cursor is in the
     // non-blink state so it is rendered if visible. If we're under
     // HEAVY read load, we don't want to send a ton of these so we
     // use a timer under the covers
     if (std.time.Instant.now()) |now| cursor_reset: {
-        if (rd.last_cursor_reset) |last| {
+        if (self.last_cursor_reset) |last| {
             if (now.since(last) <= (500 / std.time.ns_per_ms)) {
                 break :cursor_reset;
             }
         }
 
-        rd.last_cursor_reset = now;
-        _ = rd.renderer_mailbox.push(.{
+        self.last_cursor_reset = now;
+        _ = self.renderer_mailbox.push(.{
             .reset_cursor_blink = {},
         }, .{ .instant = {} });
     } else |err| {
@@ -528,28 +508,25 @@ fn processOutputLocked(rd: *ReadData, buf: []const u8) void {
     // process a byte at a time alternating between the inspector handler
     // and the termio handler. This is very slow compared to our optimizations
     // below but at least users only pay for it if they're using the inspector.
-    if (rd.renderer_state.inspector) |insp| {
+    if (self.renderer_state.inspector) |insp| {
         for (buf, 0..) |byte, i| {
             insp.recordPtyRead(buf[i .. i + 1]) catch |err| {
                 log.err("error recording pty read in inspector err={}", .{err});
             };
 
-            rd.terminal_stream.next(byte) catch |err|
+            self.terminal_stream.next(byte) catch |err|
                 log.err("error processing terminal data: {}", .{err});
         }
     } else {
-        rd.terminal_stream.nextSlice(buf) catch |err|
+        self.terminal_stream.nextSlice(buf) catch |err|
             log.err("error processing terminal data: {}", .{err});
     }
 
     // If our stream handling caused messages to be sent to the writer
     // thread, then we need to wake it up so that it processes them.
-    if (rd.terminal_stream.handler.writer_messaged) {
-        rd.terminal_stream.handler.writer_messaged = false;
-        // TODO
-        // rd.writer_wakeup.notify() catch |err| {
-        //     log.warn("failed to wake up writer thread err={}", .{err});
-        // };
+    if (self.terminal_stream.handler.writer_messaged) {
+        self.terminal_stream.handler.writer_messaged = false;
+        self.writer.notify();
     }
 }
 
@@ -575,13 +552,10 @@ pub const ThreadData = struct {
 
     /// Data associated with the reader implementation (i.e. pty/exec state)
     reader: termio.reader.ThreadData,
-    read_data: *ReadData,
     writer: *termio.Writer,
 
     pub fn deinit(self: *ThreadData) void {
         self.reader.deinit(self.alloc);
-        self.read_data.deinit();
-        self.alloc.destroy(self.read_data);
         self.* = undefined;
     }
 };

commit 89d407dd6a2d3e437a6b292534c17d108ab70abf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 14 15:13:41 2024 -0700

    termio: excessive cursor reset

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index a2367928..b73dd829 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -491,7 +491,7 @@ fn processOutputLocked(self: *Termio, buf: []const u8) void {
     // use a timer under the covers
     if (std.time.Instant.now()) |now| cursor_reset: {
         if (self.last_cursor_reset) |last| {
-            if (now.since(last) <= (500 / std.time.ns_per_ms)) {
+            if (now.since(last) <= (500 * std.time.ns_per_ms)) {
                 break :cursor_reset;
             }
         }

commit 08ed60ceec0204e4221cdc09c91c7ba4565ca1f0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 14 15:15:22 2024 -0700

    termio: ReadData is gone!

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index b73dd829..d5521ba5 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -63,10 +63,6 @@ grid_size: renderer.GridSize,
 /// The writer implementation to use.
 writer: termio.Writer,
 
-/// The pointer to the read data. This is only valid while the termio thread
-/// is alive. This is protected by the renderer state lock.
-read_data: ?*ReadData = null,
-
 /// The stream parser. This parses the stream of escape codes and so on
 /// from the child process and calls callbacks in the stream handler.
 terminal_stream: terminal.Stream(StreamHandler),
@@ -559,30 +555,3 @@ pub const ThreadData = struct {
         self.* = undefined;
     }
 };
-
-/// The data required for the read thread.
-pub const ReadData = struct {
-    /// The stream parser. This parses the stream of escape codes and so on
-    /// from the child process and calls callbacks in the stream handler.
-    terminal_stream: terminal.Stream(StreamHandler),
-
-    /// The shared render state
-    renderer_state: *renderer.State,
-
-    /// A handle to wake up the renderer. This hints to the renderer that that
-    /// a repaint should happen.
-    renderer_wakeup: xev.Async,
-
-    /// The mailbox for notifying the renderer of things.
-    renderer_mailbox: *renderer.Thread.Mailbox,
-
-    /// Last time the cursor was reset. This is used to prevent message
-    /// flooding with cursor resets.
-    last_cursor_reset: ?std.time.Instant = null,
-
-    pub fn deinit(self: *ReadData) void {
-        // Clear any StreamHandler state
-        self.terminal_stream.handler.deinit();
-        self.terminal_stream.deinit();
-    }
-};

commit 4a4b9f24115d059b7873a149d5463bb45173617b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 09:45:58 2024 -0700

    termio: trying to get Exec to not have access to full Opts

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index d5521ba5..8a0a7051 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -170,8 +170,22 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 
     // Setup our reader.
     // TODO: for manual, we need to set the terminal width/height
-    var subprocess = try termio.Exec.init(alloc, opts, &term);
+    var subprocess = try termio.Exec.init(alloc, .{
+        .command = opts.full_config.command,
+        .shell_integration = opts.full_config.@"shell-integration",
+        .shell_integration_features = opts.full_config.@"shell-integration-features",
+        .working_directory = opts.full_config.@"working-directory",
+        .resources_dir = opts.resources_dir,
+        .term = opts.config.term,
+        .linux_cgroup = opts.linux_cgroup,
+    });
     errdefer subprocess.deinit();
+    subprocess.initTerminal(&term);
+
+    // Setup our terminal size in pixels for certain requests.
+    const screen_size = opts.screen_size.subPadding(opts.padding);
+    term.width_px = screen_size.width;
+    term.height_px = screen_size.height;
 
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.

commit 3625e1e58e4617e741668c1543763b0f4bdc2487
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 09:55:31 2024 -0700

    termio: take reader as option

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 8a0a7051..02e8f28d 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -33,8 +33,8 @@ const log = std.log.scoped(.io_exec);
 /// Allocator
 alloc: Allocator,
 
-/// This is the pty fd created for the subcommand.
-subprocess: termio.Exec,
+/// This is the implementation responsible for io.
+reader: termio.Reader,
 
 /// The derived configuration for this termio implementation.
 config: DerivedConfig,
@@ -169,18 +169,8 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
     // Setup our reader.
-    // TODO: for manual, we need to set the terminal width/height
-    var subprocess = try termio.Exec.init(alloc, .{
-        .command = opts.full_config.command,
-        .shell_integration = opts.full_config.@"shell-integration",
-        .shell_integration_features = opts.full_config.@"shell-integration-features",
-        .working_directory = opts.full_config.@"working-directory",
-        .resources_dir = opts.resources_dir,
-        .term = opts.config.term,
-        .linux_cgroup = opts.linux_cgroup,
-    });
-    errdefer subprocess.deinit();
-    subprocess.initTerminal(&term);
+    var reader = opts.reader;
+    reader.initTerminal(&term);
 
     // Setup our terminal size in pixels for certain requests.
     const screen_size = opts.screen_size.subPadding(opts.padding);
@@ -220,13 +210,13 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     self.* = .{
         .alloc = alloc,
         .terminal = term,
-        .subprocess = subprocess,
         .config = opts.config,
         .renderer_state = opts.renderer_state,
         .renderer_wakeup = opts.renderer_wakeup,
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
+        .reader = opts.reader,
         .writer = opts.writer,
         .terminal_stream = .{
             .handler = handler,
@@ -242,7 +232,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 }
 
 pub fn deinit(self: *Termio) void {
-    self.subprocess.deinit();
+    self.reader.deinit();
     self.terminal.deinit(self.alloc);
     self.config.deinit();
     self.writer.deinit(self.alloc);
@@ -272,11 +262,11 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     };
 
     // Setup our reader
-    try self.subprocess.threadEnter(alloc, self, data);
+    try self.reader.threadEnter(alloc, self, data);
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
-    self.subprocess.threadExit(data);
+    self.reader.threadExit(data);
 }
 
 /// Send a message using the writer. Depending on the writer type in
@@ -310,7 +300,7 @@ pub inline fn queueWrite(
     data: []const u8,
     linefeed: bool,
 ) !void {
-    try self.subprocess.queueWrite(self.alloc, td, data, linefeed);
+    try self.reader.queueWrite(self.alloc, td, data, linefeed);
 }
 
 /// Update the configuration.
@@ -373,7 +363,7 @@ pub fn resize(
 ) !void {
     // Update the size of our pty.
     const padded_size = screen_size.subPadding(padding);
-    try self.subprocess.resize(grid_size, padded_size);
+    try self.reader.resize(grid_size, padded_size);
 
     // Update our cached grid size
     self.grid_size = grid_size;
@@ -476,7 +466,7 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     const t = self.renderer_state.terminal;
-    try self.subprocess.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
+    try self.reader.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
 /// Process output from the pty. This is the manual API that users can

commit 001a6d2624ce0721a4eb5a793f5c46219f0afb3f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 10:14:05 2024 -0700

    termio: reader => backend

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 02e8f28d..7c48d5ff 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -34,7 +34,7 @@ const log = std.log.scoped(.io_exec);
 alloc: Allocator,
 
 /// This is the implementation responsible for io.
-reader: termio.Reader,
+backend: termio.Backend,
 
 /// The derived configuration for this termio implementation.
 config: DerivedConfig,
@@ -168,9 +168,9 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    // Setup our reader.
-    var reader = opts.reader;
-    reader.initTerminal(&term);
+    // Setup our backend.
+    var backend = opts.backend;
+    backend.initTerminal(&term);
 
     // Setup our terminal size in pixels for certain requests.
     const screen_size = opts.screen_size.subPadding(opts.padding);
@@ -216,7 +216,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
-        .reader = opts.reader,
+        .backend = opts.backend,
         .writer = opts.writer,
         .terminal_stream = .{
             .handler = handler,
@@ -232,7 +232,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 }
 
 pub fn deinit(self: *Termio) void {
-    self.reader.deinit();
+    self.backend.deinit();
     self.terminal.deinit(self.alloc);
     self.config.deinit();
     self.writer.deinit(self.alloc);
@@ -258,15 +258,15 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .writer = &self.writer,
 
         // Placeholder until setup below
-        .reader = .{ .manual = {} },
+        .backend = .{ .manual = {} },
     };
 
-    // Setup our reader
-    try self.reader.threadEnter(alloc, self, data);
+    // Setup our backend
+    try self.backend.threadEnter(alloc, self, data);
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
-    self.reader.threadExit(data);
+    self.backend.threadExit(data);
 }
 
 /// Send a message using the writer. Depending on the writer type in
@@ -300,7 +300,7 @@ pub inline fn queueWrite(
     data: []const u8,
     linefeed: bool,
 ) !void {
-    try self.reader.queueWrite(self.alloc, td, data, linefeed);
+    try self.backend.queueWrite(self.alloc, td, data, linefeed);
 }
 
 /// Update the configuration.
@@ -320,7 +320,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
     // renderer mutex so this is safe to do despite being executed
     // from another thread.
     self.terminal_stream.handler.changeConfig(&self.config);
-    td.reader.changeConfig(&self.config);
+    td.backend.changeConfig(&self.config);
 
     // Update the configuration that we know about.
     //
@@ -363,7 +363,7 @@ pub fn resize(
 ) !void {
     // Update the size of our pty.
     const padded_size = screen_size.subPadding(padding);
-    try self.reader.resize(grid_size, padded_size);
+    try self.backend.resize(grid_size, padded_size);
 
     // Update our cached grid size
     self.grid_size = grid_size;
@@ -466,7 +466,7 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     const t = self.renderer_state.terminal;
-    try self.reader.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
+    try self.backend.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
 /// Process output from the pty. This is the manual API that users can
@@ -550,12 +550,12 @@ pub const ThreadData = struct {
     /// Mailboxes for different threads
     surface_mailbox: apprt.surface.Mailbox,
 
-    /// Data associated with the reader implementation (i.e. pty/exec state)
-    reader: termio.reader.ThreadData,
+    /// Data associated with the backend implementation (i.e. pty/exec state)
+    backend: termio.backend.ThreadData,
     writer: *termio.Writer,
 
     pub fn deinit(self: *ThreadData) void {
-        self.reader.deinit(self.alloc);
+        self.backend.deinit(self.alloc);
         self.* = undefined;
     }
 };

commit 835d622baa9d0026798f9f23fbc09abcc41eaf5f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 10:23:09 2024 -0700

    termio: writer => mailbox

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 7c48d5ff..457a6636 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -60,8 +60,8 @@ surface_mailbox: apprt.surface.Mailbox,
 /// The cached grid size whenever a resize is called.
 grid_size: renderer.GridSize,
 
-/// The writer implementation to use.
-writer: termio.Writer,
+/// The mailbox implementation to use.
+mailbox: termio.Mailbox,
 
 /// The stream parser. This parses the stream of escape codes and so on
 /// from the child process and calls callbacks in the stream handler.
@@ -187,7 +187,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 
         break :handler .{
             .alloc = alloc,
-            .writer = &self.writer,
+            .termio_mailbox = &self.mailbox,
             .surface_mailbox = opts.surface_mailbox,
             .renderer_state = opts.renderer_state,
             .renderer_wakeup = opts.renderer_wakeup,
@@ -217,7 +217,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
         .backend = opts.backend,
-        .writer = opts.writer,
+        .mailbox = opts.mailbox,
         .terminal_stream = .{
             .handler = handler,
             .parser = .{
@@ -235,7 +235,7 @@ pub fn deinit(self: *Termio) void {
     self.backend.deinit();
     self.terminal.deinit(self.alloc);
     self.config.deinit();
-    self.writer.deinit(self.alloc);
+    self.mailbox.deinit(self.alloc);
 
     // Clear any StreamHandler state
     self.terminal_stream.handler.deinit();
@@ -255,7 +255,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .loop = &thread.loop,
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
-        .writer = &self.writer,
+        .mailbox = &self.mailbox,
 
         // Placeholder until setup below
         .backend = .{ .manual = {} },
@@ -269,29 +269,29 @@ pub fn threadExit(self: *Termio, data: *ThreadData) void {
     self.backend.threadExit(data);
 }
 
-/// Send a message using the writer. Depending on the writer type in
+/// Send a message to the the mailbox. Depending on the mailbox type in
 /// use this may process now or it may just enqueue and process later.
 ///
-/// This will also notify the writer thread to process the message. If
+/// This will also notify the mailbox thread to process the message. If
 /// you're sending a lot of messages, it may be more efficient to use
-/// the writer directly and then call notify separately.
+/// the mailbox directly and then call notify separately.
 pub fn queueMessage(
     self: *Termio,
     msg: termio.Message,
     mutex: enum { locked, unlocked },
 ) void {
-    self.writer.send(msg, switch (mutex) {
+    self.mailbox.send(msg, switch (mutex) {
         .locked => self.renderer_state.mutex,
         .unlocked => null,
     });
-    self.writer.notify();
+    self.mailbox.notify();
 }
 
 /// Queue a write directly to the pty.
 ///
 /// If you're using termio.Thread, this must ONLY be called from the
-/// writer thread. If you're not on the thread, use queueMessage with
-/// writer messages instead.
+/// mailbox thread. If you're not on the thread, use queueMessage with
+/// mailbox messages instead.
 ///
 /// If you're not using termio.Thread, this is not threadsafe.
 pub inline fn queueWrite(
@@ -522,11 +522,11 @@ fn processOutputLocked(self: *Termio, buf: []const u8) void {
             log.err("error processing terminal data: {}", .{err});
     }
 
-    // If our stream handling caused messages to be sent to the writer
+    // If our stream handling caused messages to be sent to the mailbox
     // thread, then we need to wake it up so that it processes them.
-    if (self.terminal_stream.handler.writer_messaged) {
-        self.terminal_stream.handler.writer_messaged = false;
-        self.writer.notify();
+    if (self.terminal_stream.handler.termio_messaged) {
+        self.terminal_stream.handler.termio_messaged = false;
+        self.mailbox.notify();
     }
 }
 
@@ -552,7 +552,7 @@ pub const ThreadData = struct {
 
     /// Data associated with the backend implementation (i.e. pty/exec state)
     backend: termio.backend.ThreadData,
-    writer: *termio.Writer,
+    mailbox: *termio.Mailbox,
 
     pub fn deinit(self: *ThreadData) void {
         self.backend.deinit(self.alloc);

commit 3867e20e72cf753cf8cf92d7dac82f225529c27d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 10:50:17 2024 -0700

    termio: get rid of manual backend

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 457a6636..ef4f78b1 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -256,9 +256,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
         .mailbox = &self.mailbox,
-
-        // Placeholder until setup below
-        .backend = .{ .manual = {} },
+        .backend = undefined, // Backend must replace this on threadEnter
     };
 
     // Setup our backend

commit 8cd901450ae7667887372d4d051b1e916f83e520
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 10:53:01 2024 -0700

    remove unused derived config values

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index ef4f78b1..fd7c3695 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -85,8 +85,6 @@ pub const DerivedConfig = struct {
     foreground: configpkg.Config.Color,
     background: configpkg.Config.Color,
     osc_color_report_format: configpkg.Config.OSCColorReportFormat,
-    term: []const u8,
-    grapheme_width_method: configpkg.Config.GraphemeWidthMethod,
     abnormal_runtime_threshold_ms: u32,
     wait_after_command: bool,
     enquiry_response: []const u8,
@@ -108,8 +106,6 @@ pub const DerivedConfig = struct {
             .foreground = config.foreground,
             .background = config.background,
             .osc_color_report_format = config.@"osc-color-report-format",
-            .term = try alloc.dupe(u8, config.term),
-            .grapheme_width_method = config.@"grapheme-width-method",
             .abnormal_runtime_threshold_ms = config.@"abnormal-command-exit-runtime",
             .wait_after_command = config.@"wait-after-command",
             .enquiry_response = try alloc.dupe(u8, config.@"enquiry-response"),
@@ -142,7 +138,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 
     // Setup our initial grapheme cluster support if enabled. We use a
     // switch to ensure we get a compiler error if more cases are added.
-    switch (opts.config.grapheme_width_method) {
+    switch (opts.full_config.@"grapheme-width-method") {
         .unicode => term.modes.set(.grapheme_cluster, true),
         .legacy => {},
     }

commit 524f24aaf5b21f9e0f8572093664b27a8930fc8f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 15 15:23:39 2024 -0700

    termio: remove unused data

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index fd7c3695..9459f915 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -239,15 +239,8 @@ pub fn deinit(self: *Termio) void {
 }
 
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
-    const alloc = self.alloc;
-
-    // Wakeup watcher for the writer thread.
-    var wakeup = try xev.Async.init();
-    errdefer wakeup.deinit();
-
-    // Setup our thread data
     data.* = .{
-        .alloc = alloc,
+        .alloc = self.alloc,
         .loop = &thread.loop,
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
@@ -256,7 +249,7 @@ pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !vo
     };
 
     // Setup our backend
-    try self.backend.threadEnter(alloc, self, data);
+    try self.backend.threadEnter(self.alloc, self, data);
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {

commit 137ba662114424e4a5c8e76417d1a8f100009364
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Jul 17 10:18:15 2024 -0700

    terminal: implement in-band size reports (Mode 2048)
    
    https://gist.github.com/rockorager/e695fb2924d36b2bcf1fff4a3704bd83

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 9459f915..9f83e671 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -344,6 +344,7 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
 /// Resize the terminal.
 pub fn resize(
     self: *Termio,
+    td: *ThreadData,
     grid_size: renderer.GridSize,
     screen_size: renderer.ScreenSize,
     padding: renderer.Padding,
@@ -377,9 +378,39 @@ pub fn resize(
 
         // Wake up our renderer so any changes will be shown asap
         self.renderer_wakeup.notify() catch {};
+
+        // If we have size reporting enabled we need to send a report.
+        if (self.terminal.modes.get(.in_band_size_reports)) {
+            try self.sizeReportLocked(td);
+        }
     }
 }
 
+/// Make a mode 2048 in-band size report.
+pub fn sizeReport(self: *Termio, td: *ThreadData) !void {
+    self.renderer_state.mutex.lock();
+    defer self.renderer_state.mutex.unlock();
+    try self.sizeReportLocked(td);
+}
+
+fn sizeReportLocked(self: *Termio, td: *ThreadData) !void {
+    // 1024 bytes should be enough for size report since report
+    // in columns and pixels.
+    var buf: [1024]u8 = undefined;
+    const message = try std.fmt.bufPrint(
+        &buf,
+        "\x1B[48;{};{};{};{}t",
+        .{
+            self.grid_size.rows,
+            self.grid_size.columns,
+            self.terminal.height_px,
+            self.terminal.width_px,
+        },
+    );
+
+    try self.queueWrite(td, message, false);
+}
+
 /// Reset the synchronized output mode. This is usually called by timer
 /// expiration from the termio thread.
 pub fn resetSynchronizedOutput(self: *Termio) void {

commit b09e4e5d636cb27f1bd0d8a032f93f2eac624a51
Author: Gregory Anders <greg@gpanders.com>
Date:   Mon Jun 17 10:17:14 2024 -0500

    config: add cursor-invert-fg-bg option
    
    When set, the cursor-invert-fg-bg option uses the inverted foreground
    and background colors of the cursor's current cell to color the cursor,
    rather than using a fixed color. This option has higher precedence than
    the cursor-color and cursor-text options, but has lower precedence than
    an OSC 12 command to change the cursor color.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 9f83e671..62373fb7 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -82,6 +82,7 @@ pub const DerivedConfig = struct {
     cursor_style: terminal.CursorStyle,
     cursor_blink: ?bool,
     cursor_color: ?configpkg.Config.Color,
+    cursor_invert: bool,
     foreground: configpkg.Config.Color,
     background: configpkg.Config.Color,
     osc_color_report_format: configpkg.Config.OSCColorReportFormat,
@@ -103,6 +104,7 @@ pub const DerivedConfig = struct {
             .cursor_style = config.@"cursor-style",
             .cursor_blink = config.@"cursor-style-blink",
             .cursor_color = config.@"cursor-color",
+            .cursor_invert = config.@"cursor-invert-fg-bg",
             .foreground = config.foreground,
             .background = config.background,
             .osc_color_report_format = config.@"osc-color-report-format",
@@ -176,8 +178,8 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.
     const handler: StreamHandler = handler: {
-        const default_cursor_color = if (opts.config.cursor_color) |col|
-            col.toTerminalRGB()
+        const default_cursor_color = if (!opts.config.cursor_invert and opts.config.cursor_color != null)
+            opts.config.cursor_color.?.toTerminalRGB()
         else
             null;
 

commit ce5e55d4aa87f0bcf2562281b972015bfa5eb01a
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Wed Aug 7 00:12:20 2024 -0500

    Implement the XTWINOPS (CSI t) control sequences that "make sense".
    
    These sequences were implemented:
    
    CSI 14 t - report the text area size in pixels
    CSI 16 t - report the cell size in pixels
    CSI 18 t - report the text area size in cells
    CSI 21 t - report the window title
    
    These sequences were not implemented because they manuipulate the window
    state in ways that we do not want.
    
    CSI 1 t
    CSI 2 t
    CSI 3 ; x ; y t
    CSI 4 ; height ; width ; t
    CSI 5 t
    CSI 6 t
    CSI 7 t
    CSI 8 ; height ; width ; t
    CSI 9 ; 0 t
    CSI 9 ; 1 t
    CSI 9 ; 2 t
    CSI 9 ; 3 t
    CSI 10 ; 0 t
    CSI 10 ; 1 t
    CSI 10 ; 2 t
    CSI 24 t
    
    These sequences were not implemented because they do not make sense in
    a Wayland context:
    
    CSI 11 t
    CSI 13 t
    CSI 14 ; 2 t
    
    These sequences were not implemented because they provide information
    about the screen that is unnecessary.
    
    CSI 15 t
    CSI 19 t
    
    These sequences were not implemeted because Ghostty does not maintain an
    icon title for windows.
    
    CSI 20 t
    CSI 22 ; 0 t
    CSI 22 ; 1 t
    CSI 23 ; 0 t
    CSI 23 ; 1 t
    
    These sequences were not implemented because of the additional
    complexity of maintaining a stack of window titles.
    
    CSI 22 ; 2 t
    CSI 23 ; 2 t

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 62373fb7..246b9b2f 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -383,32 +383,58 @@ pub fn resize(
 
         // If we have size reporting enabled we need to send a report.
         if (self.terminal.modes.get(.in_band_size_reports)) {
-            try self.sizeReportLocked(td);
+            try self.sizeReportLocked(td, .mode_2048);
         }
     }
 }
 
-/// Make a mode 2048 in-band size report.
-pub fn sizeReport(self: *Termio, td: *ThreadData) !void {
+/// Make a size report.
+pub fn sizeReport(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
-    try self.sizeReportLocked(td);
+    try self.sizeReportLocked(td, style);
 }
 
-fn sizeReportLocked(self: *Termio, td: *ThreadData) !void {
+fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
     // 1024 bytes should be enough for size report since report
     // in columns and pixels.
     var buf: [1024]u8 = undefined;
-    const message = try std.fmt.bufPrint(
-        &buf,
-        "\x1B[48;{};{};{};{}t",
-        .{
-            self.grid_size.rows,
-            self.grid_size.columns,
-            self.terminal.height_px,
-            self.terminal.width_px,
-        },
-    );
+    const message = switch (style) {
+        .mode_2048 => try std.fmt.bufPrint(
+            &buf,
+            "\x1B[48;{};{};{};{}t",
+            .{
+                self.grid_size.rows,
+                self.grid_size.columns,
+                self.terminal.height_px,
+                self.terminal.width_px,
+            },
+        ),
+        .csi_14_t => try std.fmt.bufPrint(
+            &buf,
+            "\x1b[4;{};{}t",
+            .{
+                self.terminal.height_px,
+                self.terminal.width_px,
+            },
+        ),
+        .csi_16_t => try std.fmt.bufPrint(
+            &buf,
+            "\x1b[6;{};{}t",
+            .{
+                self.terminal.height_px / self.grid_size.rows,
+                self.terminal.width_px / self.grid_size.columns,
+            },
+        ),
+        .csi_18_t => try std.fmt.bufPrint(
+            &buf,
+            "\x1b[8;{};{}t",
+            .{
+                self.grid_size.rows,
+                self.grid_size.columns,
+            },
+        ),
+    };
 
     try self.queueWrite(td, message, false);
 }

commit 7929e0bc09d4524d982c6ac369013eba40762fd0
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Aug 14 19:35:52 2024 -0400

    fix: prevent flicker while shrinking screen by eliminating thread race
    
    Before this fix, if vsync was on the GPU cells buffer could be cleared
    for a frame while resizing the terminal down. This was due to the fact
    that the surface sent messages for the resize to both the renderer and
    the IO thread. If the renderer thread was processed first then the GPU
    cells buffer(s) would be cleared and not rebuilt, because the terminal
    state would be larger than the GPU cell buffers causing updateFrame to
    bail out early, leaving empty cell buffers.
    
    This fixes the problem by changing the origin of the renderer's resize
    message to be the IO thread, only after properly updating the terminal
    state, to avoid clearing the GPU cells buffers at a time they can't be
    successfully rebuilt.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 246b9b2f..7573b000 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -378,7 +378,13 @@ pub fn resize(
         // immediately for a resize. This is allowed by the spec.
         self.terminal.modes.set(.synchronized_output, false);
 
-        // Wake up our renderer so any changes will be shown asap
+        // Mail the renderer so that it can update the GPU and re-render
+        _ = self.renderer_mailbox.push(.{
+            .resize = .{
+                .screen_size = screen_size,
+                .padding = padding,
+            },
+        }, .{ .forever = {} });
         self.renderer_wakeup.notify() catch {};
 
         // If we have size reporting enabled we need to send a report.

commit ff6a0bf9a21715e71434f72f7dca07aed4d435bb
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Aug 14 23:46:52 2024 -0400

    termio: wake renderer outside of critical area in resize

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 7573b000..ae38eb04 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -378,20 +378,20 @@ pub fn resize(
         // immediately for a resize. This is allowed by the spec.
         self.terminal.modes.set(.synchronized_output, false);
 
-        // Mail the renderer so that it can update the GPU and re-render
-        _ = self.renderer_mailbox.push(.{
-            .resize = .{
-                .screen_size = screen_size,
-                .padding = padding,
-            },
-        }, .{ .forever = {} });
-        self.renderer_wakeup.notify() catch {};
-
         // If we have size reporting enabled we need to send a report.
         if (self.terminal.modes.get(.in_band_size_reports)) {
             try self.sizeReportLocked(td, .mode_2048);
         }
     }
+
+    // Mail the renderer so that it can update the GPU and re-render
+    _ = self.renderer_mailbox.push(.{
+        .resize = .{
+            .screen_size = screen_size,
+            .padding = padding,
+        },
+    }, .{ .forever = {} });
+    self.renderer_wakeup.notify() catch {};
 }
 
 /// Make a size report.

commit df0669789986ed549b51900b11d09e559cd9999f
Author: Gregory Anders <greg@gpanders.com>
Date:   Sat Aug 31 19:40:19 2024 -0500

    termio: send initial focus reports
    
    When the focus reporting mode (1004) is enabled, send the current focus
    state. This allows applications to track their own focus state without
    first having to wait for a focus event (or query
    it by sending a DECSET followed by a DECRST).
    
    Ghostty's focus state is stored only in the renderer, where the termio
    thread cannot access it. We duplicate the focus state tracking in the
    Terminal struct with the addition of a new (1-bit) flag. We duplicate
    the state because the renderer uses the focus state for its own purposes
    (in particular, the Metal renderer uses the focus state to manage
    its DisplayLink), and synchronizing access to the shared terminal state
    is more cumbersome than simply tracking the focus state in the renderer
    in addition to the terminal.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index ae38eb04..f209748d 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -521,6 +521,12 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
     try self.backend.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
+/// Called when focus is gained or lost (when focus events are enabled)
+pub fn focusGained(self: *Termio, td: *ThreadData, focused: bool) !void {
+    const seq = if (focused) "\x1b[I" else "\x1b[O";
+    try self.queueWrite(td, seq, false);
+}
+
 /// Process output from the pty. This is the manual API that users can
 /// call with pty data but it is also called by the read thread when using
 /// an exec subprocess.

commit e8bbc987e08376976d9e6f66a647461744c4bd4d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 18 11:43:15 2024 -0700

    termio: stop the termios poller when not focused

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index f209748d..865ca8d9 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -523,8 +523,18 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
 
 /// Called when focus is gained or lost (when focus events are enabled)
 pub fn focusGained(self: *Termio, td: *ThreadData, focused: bool) !void {
-    const seq = if (focused) "\x1b[I" else "\x1b[O";
-    try self.queueWrite(td, seq, false);
+    self.renderer_state.mutex.lock();
+    const focus_event = self.renderer_state.terminal.modes.get(.focus_event);
+    self.renderer_state.mutex.unlock();
+
+    // If we have focus events enabled, we send the focus event.
+    if (focus_event) {
+        const seq = if (focused) "\x1b[I" else "\x1b[O";
+        try self.queueWrite(td, seq, false);
+    }
+
+    // We always notify our backend of focus changes.
+    try self.backend.focusGained(td, focused);
 }
 
 /// Process output from the pty. This is the manual API that users can

commit 4f1cee8eb904a7100ee0718b22b0ecb82b7e5c76
Author: Tim Culverhouse <tim@timculverhouse.com>
Date:   Fri Oct 18 22:29:52 2024 -0500

    fix: report correct screen pixel size
    
    Mode 2048 and CSI 14 t are size report control sequences which contain
    the text area size in pixels. The text area is defined to be the extents
    of the grid (rows and columns). Ghostty calculates the available size
    for the text area by setting the available padding, and then filling as
    much of the remaining space as possible. However, if there are remainder
    pixels these are still reported as part of the text area size.
    
    Pass the cell_size geometry through so that we can always report the
    correct value: columns * cell width and rows * cell height.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 865ca8d9..f28eb118 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -60,6 +60,9 @@ surface_mailbox: apprt.surface.Mailbox,
 /// The cached grid size whenever a resize is called.
 grid_size: renderer.GridSize,
 
+/// The size of a single cell. Used for size reports.
+cell_size: renderer.CellSize,
+
 /// The mailbox implementation to use.
 mailbox: termio.Mailbox,
 
@@ -171,9 +174,8 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     backend.initTerminal(&term);
 
     // Setup our terminal size in pixels for certain requests.
-    const screen_size = opts.screen_size.subPadding(opts.padding);
-    term.width_px = screen_size.width;
-    term.height_px = screen_size.height;
+    term.width_px = opts.grid_size.columns * opts.cell_size.width;
+    term.height_px = opts.grid_size.rows * opts.cell_size.height;
 
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.
@@ -214,6 +216,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .grid_size = opts.grid_size,
+        .cell_size = opts.cell_size,
         .backend = opts.backend,
         .mailbox = opts.mailbox,
         .terminal_stream = .{
@@ -348,6 +351,7 @@ pub fn resize(
     self: *Termio,
     td: *ThreadData,
     grid_size: renderer.GridSize,
+    cell_size: renderer.CellSize,
     screen_size: renderer.ScreenSize,
     padding: renderer.Padding,
 ) !void {
@@ -357,6 +361,7 @@ pub fn resize(
 
     // Update our cached grid size
     self.grid_size = grid_size;
+    self.cell_size = cell_size;
 
     // Enter the critical area that we want to keep small
     {
@@ -371,8 +376,8 @@ pub fn resize(
         );
 
         // Update our pixel sizes
-        self.terminal.width_px = padded_size.width;
-        self.terminal.height_px = padded_size.height;
+        self.terminal.width_px = self.grid_size.columns * self.cell_size.width;
+        self.terminal.height_px = self.grid_size.rows * self.cell_size.height;
 
         // Disable synchronized output mode so that we show changes
         // immediately for a resize. This is allowed by the spec.
@@ -412,24 +417,24 @@ fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeRe
             .{
                 self.grid_size.rows,
                 self.grid_size.columns,
-                self.terminal.height_px,
-                self.terminal.width_px,
+                self.grid_size.rows * self.cell_size.height,
+                self.grid_size.columns * self.cell_size.width,
             },
         ),
         .csi_14_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[4;{};{}t",
             .{
-                self.terminal.height_px,
-                self.terminal.width_px,
+                self.grid_size.rows * self.cell_size.height,
+                self.grid_size.columns * self.cell_size.width,
             },
         ),
         .csi_16_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[6;{};{}t",
             .{
-                self.terminal.height_px / self.grid_size.rows,
-                self.terminal.width_px / self.grid_size.columns,
+                self.cell_size.height,
+                self.cell_size.width,
             },
         ),
         .csi_18_t => try std.fmt.bufPrint(

commit a436bd0af62a4bdc5af14774b955f7b46ccd9deb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 7 14:38:54 2024 -0800

    move datastructures to dedicated "datastruct" package

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index f28eb118..f2cdfc77 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -15,7 +15,6 @@ const posix = std.posix;
 const termio = @import("../termio.zig");
 const Command = @import("../Command.zig");
 const Pty = @import("../pty.zig").Pty;
-const SegmentedPool = @import("../segmented_pool.zig").SegmentedPool;
 const StreamHandler = @import("stream_handler.zig").StreamHandler;
 const terminal = @import("../terminal/main.zig");
 const terminfo = @import("../terminfo/main.zig");

commit ca8130bec986e0de9dfd4e44ee8d62efb792561f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 14 12:59:57 2024 -0800

    core: make surface use only renderer.Size

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index f2cdfc77..fc1bfc32 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -168,14 +168,14 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    // Setup our backend.
-    var backend = opts.backend;
-    backend.initTerminal(&term);
-
     // Setup our terminal size in pixels for certain requests.
     term.width_px = opts.grid_size.columns * opts.cell_size.width;
     term.height_px = opts.grid_size.rows * opts.cell_size.height;
 
+    // Setup our backend.
+    var backend = opts.backend;
+    backend.initTerminal(&term);
+
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.
     const handler: StreamHandler = handler: {

commit dcb1ce83770df11b77fc7615ac3d9b9534043808
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 14 13:23:11 2024 -0800

    termio: change resize message to use new size struct

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index fc1bfc32..13ef4a73 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -349,18 +349,16 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
 pub fn resize(
     self: *Termio,
     td: *ThreadData,
-    grid_size: renderer.GridSize,
-    cell_size: renderer.CellSize,
-    screen_size: renderer.ScreenSize,
-    padding: renderer.Padding,
+    size: renderer.Size,
 ) !void {
+    const grid_size = size.grid();
+
     // Update the size of our pty.
-    const padded_size = screen_size.subPadding(padding);
-    try self.backend.resize(grid_size, padded_size);
+    try self.backend.resize(grid_size, size.terminal());
 
     // Update our cached grid size
-    self.grid_size = grid_size;
-    self.cell_size = cell_size;
+    self.grid_size = size.grid();
+    self.cell_size = size.cell;
 
     // Enter the critical area that we want to keep small
     {
@@ -375,8 +373,8 @@ pub fn resize(
         );
 
         // Update our pixel sizes
-        self.terminal.width_px = self.grid_size.columns * self.cell_size.width;
-        self.terminal.height_px = self.grid_size.rows * self.cell_size.height;
+        self.terminal.width_px = grid_size.columns * self.cell_size.width;
+        self.terminal.height_px = grid_size.rows * self.cell_size.height;
 
         // Disable synchronized output mode so that we show changes
         // immediately for a resize. This is allowed by the spec.
@@ -391,8 +389,8 @@ pub fn resize(
     // Mail the renderer so that it can update the GPU and re-render
     _ = self.renderer_mailbox.push(.{
         .resize = .{
-            .screen_size = screen_size,
-            .padding = padding,
+            .screen_size = size.screen,
+            .padding = size.padding,
         },
     }, .{ .forever = {} });
     self.renderer_wakeup.notify() catch {};

commit 90c59f2462d4a2e43456b865646ac6b25d243380
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 14 13:31:01 2024 -0800

    termio: change all sizes to the new size type

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 13ef4a73..4998bc09 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -56,11 +56,8 @@ renderer_mailbox: *renderer.Thread.Mailbox,
 /// The mailbox for communicating with the surface.
 surface_mailbox: apprt.surface.Mailbox,
 
-/// The cached grid size whenever a resize is called.
-grid_size: renderer.GridSize,
-
-/// The size of a single cell. Used for size reports.
-cell_size: renderer.CellSize,
+/// The cached size info
+size: renderer.Size,
 
 /// The mailbox implementation to use.
 mailbox: termio.Mailbox,
@@ -131,10 +128,13 @@ pub const DerivedConfig = struct {
 /// to run a child process.
 pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Create our terminal
-    var term = try terminal.Terminal.init(alloc, .{
-        .cols = opts.grid_size.columns,
-        .rows = opts.grid_size.rows,
-        .max_scrollback = opts.full_config.@"scrollback-limit",
+    var term = try terminal.Terminal.init(alloc, opts: {
+        const grid_size = opts.size.grid();
+        break :opts .{
+            .cols = grid_size.columns,
+            .rows = grid_size.rows,
+            .max_scrollback = opts.full_config.@"scrollback-limit",
+        };
     });
     errdefer term.deinit(alloc);
     term.default_palette = opts.config.palette;
@@ -169,8 +169,8 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
     // Setup our terminal size in pixels for certain requests.
-    term.width_px = opts.grid_size.columns * opts.cell_size.width;
-    term.height_px = opts.grid_size.rows * opts.cell_size.height;
+    term.width_px = term.cols * opts.size.cell.width;
+    term.height_px = term.rows * opts.size.cell.height;
 
     // Setup our backend.
     var backend = opts.backend;
@@ -191,7 +191,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .renderer_state = opts.renderer_state,
             .renderer_wakeup = opts.renderer_wakeup,
             .renderer_mailbox = opts.renderer_mailbox,
-            .grid_size = &self.grid_size,
+            .size = &self.size,
             .terminal = &self.terminal,
             .osc_color_report_format = opts.config.osc_color_report_format,
             .enquiry_response = opts.config.enquiry_response,
@@ -214,8 +214,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .renderer_wakeup = opts.renderer_wakeup,
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
-        .grid_size = opts.grid_size,
-        .cell_size = opts.cell_size,
+        .size = opts.size,
         .backend = opts.backend,
         .mailbox = opts.mailbox,
         .terminal_stream = .{
@@ -356,10 +355,6 @@ pub fn resize(
     // Update the size of our pty.
     try self.backend.resize(grid_size, size.terminal());
 
-    // Update our cached grid size
-    self.grid_size = size.grid();
-    self.cell_size = size.cell;
-
     // Enter the critical area that we want to keep small
     {
         self.renderer_state.mutex.lock();
@@ -373,8 +368,8 @@ pub fn resize(
         );
 
         // Update our pixel sizes
-        self.terminal.width_px = grid_size.columns * self.cell_size.width;
-        self.terminal.height_px = grid_size.rows * self.cell_size.height;
+        self.terminal.width_px = grid_size.columns * self.size.cell.width;
+        self.terminal.height_px = grid_size.rows * self.size.cell.height;
 
         // Disable synchronized output mode so that we show changes
         // immediately for a resize. This is allowed by the spec.
@@ -404,6 +399,8 @@ pub fn sizeReport(self: *Termio, td: *ThreadData, style: termio.Message.SizeRepo
 }
 
 fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
+    const grid_size = self.size.grid();
+
     // 1024 bytes should be enough for size report since report
     // in columns and pixels.
     var buf: [1024]u8 = undefined;
@@ -412,34 +409,34 @@ fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeRe
             &buf,
             "\x1B[48;{};{};{};{}t",
             .{
-                self.grid_size.rows,
-                self.grid_size.columns,
-                self.grid_size.rows * self.cell_size.height,
-                self.grid_size.columns * self.cell_size.width,
+                grid_size.rows,
+                grid_size.columns,
+                grid_size.rows * self.size.cell.height,
+                grid_size.columns * self.size.cell.width,
             },
         ),
         .csi_14_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[4;{};{}t",
             .{
-                self.grid_size.rows * self.cell_size.height,
-                self.grid_size.columns * self.cell_size.width,
+                grid_size.rows * self.size.cell.height,
+                grid_size.columns * self.size.cell.width,
             },
         ),
         .csi_16_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[6;{};{}t",
             .{
-                self.cell_size.height,
-                self.cell_size.width,
+                self.size.cell.height,
+                self.size.cell.width,
             },
         ),
         .csi_18_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[8;{};{}t",
             .{
-                self.grid_size.rows,
-                self.grid_size.columns,
+                grid_size.rows,
+                grid_size.columns,
             },
         ),
     };

commit 6f62944b9cab9a32a74d1ccf940a32ae9f85d026
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 14 13:34:12 2024 -0800

    renderer: message uses new size struct

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 4998bc09..d24a86d7 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -382,12 +382,7 @@ pub fn resize(
     }
 
     // Mail the renderer so that it can update the GPU and re-render
-    _ = self.renderer_mailbox.push(.{
-        .resize = .{
-            .screen_size = size.screen,
-            .padding = size.padding,
-        },
-    }, .{ .forever = {} });
+    _ = self.renderer_mailbox.push(.{ .resize = size }, .{ .forever = {} });
     self.renderer_wakeup.notify() catch {};
 }
 

commit f16af9de8165c8e0f3c3abbce1b99dac89ec3d4c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 15 10:43:16 2024 -0800

    termio: need to update cached size on resize

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index d24a86d7..9ed3ffc9 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -350,6 +350,7 @@ pub fn resize(
     td: *ThreadData,
     size: renderer.Size,
 ) !void {
+    self.size = size;
     const grid_size = size.grid();
 
     // Update the size of our pty.

commit 4042041b61314d165187b2651b47b335a6e3badb
Author: Gregory Anders <greg@gpanders.com>
Date:   Sat Nov 23 17:40:54 2024 -0600

    termio: track whether fg/bg color is explicitly set
    
    Make the foreground_color and background_color fields in the Terminal
    struct optional values so that we can determine if a foreground or
    background color was explicitly set with an OSC 10 or OSC 11 sequence.
    This makes the logic a bit simpler to reason about (i.e.
    `foreground_color` is now always "the color set by an OSC 10 sequence"
    while `default_foreground_color` is always "the color set by the config
    file") and also fixes an issue where an OSC 10 or OSC 11 query would not
    report the correct color after a config update changed the foreground or
    background color.
    
    The `cursor_color` field was already optional, with the same semantics
    (it is only non-null when explicitly set with an OSC 12) so this brings
    all three of these fields into alignment.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 9ed3ffc9..e7b39141 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -200,9 +200,9 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .default_cursor_style = opts.config.cursor_style,
             .default_cursor_blink = opts.config.cursor_blink,
             .default_cursor_color = default_cursor_color,
-            .cursor_color = default_cursor_color,
-            .foreground_color = opts.config.foreground.toTerminalRGB(),
-            .background_color = opts.config.background.toTerminalRGB(),
+            .cursor_color = null,
+            .foreground_color = null,
+            .background_color = null,
         };
     };
 

commit 853ba9e3c7c6fc5a3cdb533a3047e10a6af49019
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 29 14:39:22 2024 -0800

    terminal: reset should preserve desired default mode values
    
    Fixes #2857
    
    Some terminal modes always reset, but there are others that should be
    conditional based on how the terminal's default state is configured.
    Primarily from #2857 is the grapheme clustering mode (mode 2027) which
    was always resetting to false but should be conditional based on the
    the `grapheme-width-method` configuration.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index e7b39141..1ebe8454 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -127,6 +127,23 @@ pub const DerivedConfig = struct {
 /// This will also start the child process if the termio is configured
 /// to run a child process.
 pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
+    // The default terminal modes based on our config.
+    const default_modes: terminal.ModePacked = modes: {
+        var modes: terminal.ModePacked = .{};
+
+        // Setup our initial grapheme cluster support if enabled. We use a
+        // switch to ensure we get a compiler error if more cases are added.
+        switch (opts.full_config.@"grapheme-width-method") {
+            .unicode => modes.grapheme_cluster = true,
+            .legacy => {},
+        }
+
+        // Set default cursor blink settings
+        modes.cursor_blinking = opts.config.cursor_blink orelse true;
+
+        break :modes modes;
+    };
+
     // Create our terminal
     var term = try terminal.Terminal.init(alloc, opts: {
         const grid_size = opts.size.grid();
@@ -134,19 +151,13 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .cols = grid_size.columns,
             .rows = grid_size.rows,
             .max_scrollback = opts.full_config.@"scrollback-limit",
+            .default_modes = default_modes,
         };
     });
     errdefer term.deinit(alloc);
     term.default_palette = opts.config.palette;
     term.color_palette.colors = opts.config.palette;
 
-    // Setup our initial grapheme cluster support if enabled. We use a
-    // switch to ensure we get a compiler error if more cases are added.
-    switch (opts.full_config.@"grapheme-width-method") {
-        .unicode => term.modes.set(.grapheme_cluster, true),
-        .legacy => {},
-    }
-
     // Set the image size limits
     try term.screen.kitty_images.setLimit(
         alloc,
@@ -159,12 +170,6 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         opts.config.image_storage_limit,
     );
 
-    // Set default cursor blink settings
-    term.modes.set(
-        .cursor_blinking,
-        opts.config.cursor_blink orelse true,
-    );
-
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 

commit 250bd35830f80788f4b80e5c83b34bfa6986f112
Author: moni <lythe1107@gmail.com>
Date:   Fri Dec 6 09:44:20 2024 +0800

    termio: clear kitty images when deleting above the cursor

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 1ebe8454..bbcee790 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -478,6 +478,18 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
                 );
             }
 
+            // Clear all Kitty graphics state for this screen. This copies
+            // Kitty's behavior when Cmd+K deletes all Kitty graphics. I
+            // didn't spend time researching whether it only deletes Kitty
+            // graphics that are placed baove the cursor or if it deletes
+            // all of them. We delete all of them for now but if this behavior
+            // isn't fully correct we should fix this later.
+            self.terminal.screen.kitty_images.delete(
+                self.terminal.screen.alloc,
+                &self.terminal,
+                .{ .all = true },
+            );
+
             return;
         }
 

commit 33b1131a145ae7591877ecaf2550a65d35627c72
Author: Damien Mehala <damien.mehala@gmail.com>
Date:   Mon Dec 30 00:26:52 2024 +0100

    fix: selected text remains after clear_screen action
    
    Fixes #3414

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index bbcee790..ab61ae4c 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -466,6 +466,9 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
         // for alt screen, we do nothing.
         if (self.terminal.active_screen == .alternate) return;
 
+        // Clear our selection
+        self.terminal.screen.clearSelection();
+
         // Clear our scrollback
         if (history) self.terminal.eraseDisplay(.scrollback, false);
 

commit b7009202ce624788d1c54ae02ce8b7465b428b5a
Author: Tim Culverhouse <tim@timculverhouse.com>
Date:   Fri Feb 14 22:44:27 2025 -0600

    termio: use modified backend
    
    In Termio.init, we make a copy of backend and modify it by calling
    initTerminal. However, we used the original in the struct definition.
    This lead to the pty being opened with a size 0,0.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index ab61ae4c..8a2e6cc7 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -220,7 +220,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
         .size = opts.size,
-        .backend = opts.backend,
+        .backend = backend,
         .mailbox = opts.mailbox,
         .terminal_stream = .{
             .handler = handler,

commit d532a6e260960fd427e438ff55ff74f14edc518c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 20 21:38:49 2025 -0800

    Update libxev to use dynamic backend, support Linux configurability
    
    Related to #3224
    
    Previously, Ghostty used a static API for async event handling: io_uring
    on Linux, kqueue on macOS. This commit changes the backend to be dynamic
    on Linux so that epoll will be used if io_uring isn't available, or if
    the user explicitly chooses it.
    
    This introduces a new config `async-backend` (default "auto") which can
    be set by the user to change the async backend in use. This is a
    best-effort setting: if the user requests io_uring but it isn't
    available, Ghostty will fall back to something that is and that choice
    is up to us.
    
    Basic benchmarking both in libxev and Ghostty (vtebench) show no
    noticeable performance differences introducing the dynamic API, nor
    choosing epoll over io_uring.

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 8a2e6cc7..1d125f04 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -18,7 +18,7 @@ const Pty = @import("../pty.zig").Pty;
 const StreamHandler = @import("stream_handler.zig").StreamHandler;
 const terminal = @import("../terminal/main.zig");
 const terminfo = @import("../terminfo/main.zig");
-const xev = @import("xev");
+const xev = @import("../global.zig").xev;
 const renderer = @import("../renderer.zig");
 const apprt = @import("../apprt.zig");
 const fastmem = @import("../fastmem.zig");

commit 7e2286eb8c603ade782a3970911531595d57e280
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Mar 11 14:33:33 2025 -0700

    Zig 0.14

diff --git a/src/termio/Termio.zig b/src/termio/Termio.zig
index 1d125f04..ecfb9951 100644
--- a/src/termio/Termio.zig
+++ b/src/termio/Termio.zig
@@ -16,7 +16,7 @@ const termio = @import("../termio.zig");
 const Command = @import("../Command.zig");
 const Pty = @import("../pty.zig").Pty;
 const StreamHandler = @import("stream_handler.zig").StreamHandler;
-const terminal = @import("../terminal/main.zig");
+const terminalpkg = @import("../terminal/main.zig");
 const terminfo = @import("../terminfo/main.zig");
 const xev = @import("../global.zig").xev;
 const renderer = @import("../renderer.zig");
@@ -41,7 +41,7 @@ config: DerivedConfig,
 /// The terminal emulator internal state. This is the abstract "terminal"
 /// that manages input, grid updating, etc. and is renderer-agnostic. It
 /// just stores internal state about a grid.
-terminal: terminal.Terminal,
+terminal: terminalpkg.Terminal,
 
 /// The shared render state
 renderer_state: *renderer.State,
@@ -64,7 +64,7 @@ mailbox: termio.Mailbox,
 
 /// The stream parser. This parses the stream of escape codes and so on
 /// from the child process and calls callbacks in the stream handler.
-terminal_stream: terminal.Stream(StreamHandler),
+terminal_stream: terminalpkg.Stream(StreamHandler),
 
 /// Last time the cursor was reset. This is used to prevent message
 /// flooding with cursor resets.
@@ -76,9 +76,9 @@ last_cursor_reset: ?std.time.Instant = null,
 pub const DerivedConfig = struct {
     arena: ArenaAllocator,
 
-    palette: terminal.color.Palette,
+    palette: terminalpkg.color.Palette,
     image_storage_limit: usize,
-    cursor_style: terminal.CursorStyle,
+    cursor_style: terminalpkg.CursorStyle,
     cursor_blink: ?bool,
     cursor_color: ?configpkg.Config.Color,
     cursor_invert: bool,
@@ -128,8 +128,8 @@ pub const DerivedConfig = struct {
 /// to run a child process.
 pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // The default terminal modes based on our config.
-    const default_modes: terminal.ModePacked = modes: {
-        var modes: terminal.ModePacked = .{};
+    const default_modes: terminalpkg.ModePacked = modes: {
+        var modes: terminalpkg.ModePacked = .{};
 
         // Setup our initial grapheme cluster support if enabled. We use a
         // switch to ensure we get a compiler error if more cases are added.
@@ -145,7 +145,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     };
 
     // Create our terminal
-    var term = try terminal.Terminal.init(alloc, opts: {
+    var term = try terminalpkg.Terminal.init(alloc, opts: {
         const grid_size = opts.size.grid();
         break :opts .{
             .cols = grid_size.columns,
@@ -510,7 +510,7 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
 }
 
 /// Scroll the viewport
-pub fn scrollViewport(self: *Termio, scroll: terminal.Terminal.ScrollViewport) !void {
+pub fn scrollViewport(self: *Termio, scroll: terminalpkg.Terminal.ScrollViewport) !void {
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     try self.terminal.scrollViewport(scroll);

