# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/termio/shell_integration.zig

commit ae206b2f8957bd85e9f5e7900d6230b16258dc5c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 14:14:55 2023 -0700

    termio: fish shell integration injection

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
new file mode 100644
index 00000000..c941965b
--- /dev/null
+++ b/src/termio/shell_integration.zig
@@ -0,0 +1,70 @@
+const std = @import("std");
+const EnvMap = std.process.EnvMap;
+
+const log = std.log.scoped(.shell_integration);
+
+/// Shell types we support
+pub const Shell = enum {
+    fish,
+};
+
+/// Setup the command execution environment for automatic
+/// integrated shell integration. This returns true if shell
+/// integration was successful. False could mean many things:
+/// the shell type wasn't detected, etc.
+pub fn setup(
+    resource_dir: []const u8,
+    command_path: []const u8,
+    env: *EnvMap,
+) !?Shell {
+    const exe = std.fs.path.basename(command_path);
+    if (std.mem.eql(u8, "fish", exe)) {
+        try setupFish(resource_dir, env);
+        return .fish;
+    }
+
+    return null;
+}
+
+/// Setup the fish automatic shell integration. This works by
+/// modify XDG_DATA_DIRS to include the resource directory.
+/// Fish will automatically load configuration in XDG_DATA_DIRS
+/// "fish/vendor_conf.d/*.fish".
+fn setupFish(
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !void {
+    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+
+    // Get our path to the shell integration directory.
+    const integ_dir = try std.fmt.bufPrint(
+        &path_buf,
+        "{s}/shell-integration",
+        .{resource_dir},
+    );
+
+    // Set an env var so we can remove this from XDG_DATA_DIRS later.
+    // This happens in the shell integration config itself. We do this
+    // so that our modifications don't interfere with other commands.
+    try env.put("GHOSTTY_FISH_DIR", integ_dir);
+
+    if (env.get("XDG_DATA_DIRS")) |old| {
+        // We have an old value, We need to prepend our value to it.
+
+        // We use a 4K buffer to hold our XDG_DATA_DIR value. The stack
+        // on macOS is at least 512K and Linux is 8MB or more. So this
+        // should fit. If the user has a XDG_DATA_DIR value that is longer
+        // than this then it will fail... and we will cross that bridge
+        // when we actually get there. This avoids us needing an allocator.
+        var buf: [4096]u8 = undefined;
+        const prepended = try std.fmt.bufPrint(
+            &buf,
+            "{s}{c}{s}",
+            .{ integ_dir, std.fs.path.delimiter, old },
+        );
+        try env.put("XDG_DATA_DIRS", prepended);
+    } else {
+        // No XDG_DATA_DIRS set, we just set it our desired value.
+        try env.put("XDG_DATA_DIRS", integ_dir);
+    }
+}

commit ad62e3ac1bf1da0ff2300ec852c59a520b39cfcf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 16:10:30 2023 -0700

    fish shell integration

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index c941965b..2aaf2387 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -46,7 +46,7 @@ fn setupFish(
     // Set an env var so we can remove this from XDG_DATA_DIRS later.
     // This happens in the shell integration config itself. We do this
     // so that our modifications don't interfere with other commands.
-    try env.put("GHOSTTY_FISH_DIR", integ_dir);
+    try env.put("GHOSTTY_FISH_XDG_DIR", integ_dir);
 
     if (env.get("XDG_DATA_DIRS")) |old| {
         // We have an old value, We need to prepend our value to it.
@@ -62,6 +62,7 @@ fn setupFish(
             "{s}{c}{s}",
             .{ integ_dir, std.fs.path.delimiter, old },
         );
+
         try env.put("XDG_DATA_DIRS", prepended);
     } else {
         // No XDG_DATA_DIRS set, we just set it our desired value.

commit 80e2cd4e78ce12fef89bace993ee0dfb5cc9fb49
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 17:46:54 2023 -0700

    zsh integration

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 2aaf2387..15cf9a9d 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -6,6 +6,7 @@ const log = std.log.scoped(.shell_integration);
 /// Shell types we support
 pub const Shell = enum {
     fish,
+    zsh,
 };
 
 /// Setup the command execution environment for automatic
@@ -23,6 +24,11 @@ pub fn setup(
         return .fish;
     }
 
+    if (std.mem.eql(u8, "zsh", exe)) {
+        try setupZsh(resource_dir, env);
+        return .zsh;
+    }
+
     return null;
 }
 
@@ -69,3 +75,25 @@ fn setupFish(
         try env.put("XDG_DATA_DIRS", integ_dir);
     }
 }
+
+/// Setup the zsh automatic shell integration. This works by setting
+/// ZDOTDIR to our resources dir so that zsh will load our config. This
+/// config then loads the true user config.
+fn setupZsh(
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !void {
+    // Preserve the old zdotdir value so we can recover it.
+    if (env.get("ZDOTDIR")) |old| {
+        try env.put("GHOSTTY_ZSH_ZDOTDIR", old);
+    }
+
+    // Set our new ZDOTDIR
+    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const integ_dir = try std.fmt.bufPrint(
+        &path_buf,
+        "{s}/shell-integration/zsh",
+        .{resource_dir},
+    );
+    try env.put("ZDOTDIR", integ_dir);
+}

commit 8239f09d9d76a3f16afae631270bbeefd130f177
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 18:04:12 2023 -0700

    allow configuring shell integration injection

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 15cf9a9d..6f8fe322 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -17,8 +17,13 @@ pub fn setup(
     resource_dir: []const u8,
     command_path: []const u8,
     env: *EnvMap,
+    force_shell: ?Shell,
 ) !?Shell {
-    const exe = std.fs.path.basename(command_path);
+    const exe = if (force_shell) |shell| switch (shell) {
+        .fish => "/fish",
+        .zsh => "/zsh",
+    } else std.fs.path.basename(command_path);
+
     if (std.mem.eql(u8, "fish", exe)) {
         try setupFish(resource_dir, env);
         return .fish;

commit 18c852d47c9cdc9cb0be0c3aadbe9ad7dbc5fb63
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 7 17:05:09 2023 -0800

    config: switch shell-integration-features

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 6f8fe322..08733f6e 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -1,5 +1,6 @@
 const std = @import("std");
 const EnvMap = std.process.EnvMap;
+const config = @import("../config.zig");
 
 const log = std.log.scoped(.shell_integration);
 
@@ -18,23 +19,31 @@ pub fn setup(
     command_path: []const u8,
     env: *EnvMap,
     force_shell: ?Shell,
+    features: config.ShellIntegrationFeatures,
 ) !?Shell {
     const exe = if (force_shell) |shell| switch (shell) {
         .fish => "/fish",
         .zsh => "/zsh",
     } else std.fs.path.basename(command_path);
 
-    if (std.mem.eql(u8, "fish", exe)) {
-        try setupFish(resource_dir, env);
-        return .fish;
-    }
+    const shell: Shell = shell: {
+        if (std.mem.eql(u8, "fish", exe)) {
+            try setupFish(resource_dir, env);
+            break :shell .fish;
+        }
 
-    if (std.mem.eql(u8, "zsh", exe)) {
-        try setupZsh(resource_dir, env);
-        return .zsh;
-    }
+        if (std.mem.eql(u8, "zsh", exe)) {
+            try setupZsh(resource_dir, env);
+            break :shell .zsh;
+        }
+
+        return null;
+    };
+
+    // Setup our feature env vars
+    if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
 
-    return null;
+    return shell;
 }
 
 /// Setup the fish automatic shell integration. This works by

commit 48f316ebd29bf9a2bee38a48e598dd7e44c58ae5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jan 5 14:27:12 2024 -0800

    termio: support XDG data dirs greater than 4k for fish shell integration
    
    Fixes #1228

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 08733f6e..296c95db 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const Allocator = std.mem.Allocator;
 const EnvMap = std.process.EnvMap;
 const config = @import("../config.zig");
 
@@ -14,7 +15,13 @@ pub const Shell = enum {
 /// integrated shell integration. This returns true if shell
 /// integration was successful. False could mean many things:
 /// the shell type wasn't detected, etc.
+///
+/// The allocator is only used for temporary values, so it should
+/// be given a general purpose allocator. No allocated memory remains
+/// after this function returns except anything allocated by the
+/// EnvMap.
 pub fn setup(
+    alloc: Allocator,
     resource_dir: []const u8,
     command_path: []const u8,
     env: *EnvMap,
@@ -28,7 +35,7 @@ pub fn setup(
 
     const shell: Shell = shell: {
         if (std.mem.eql(u8, "fish", exe)) {
-            try setupFish(resource_dir, env);
+            try setupFish(alloc, resource_dir, env);
             break :shell .fish;
         }
 
@@ -51,6 +58,7 @@ pub fn setup(
 /// Fish will automatically load configuration in XDG_DATA_DIRS
 /// "fish/vendor_conf.d/*.fish".
 fn setupFish(
+    alloc_gpa: Allocator,
     resource_dir: []const u8,
     env: *EnvMap,
 ) !void {
@@ -71,17 +79,19 @@ fn setupFish(
     if (env.get("XDG_DATA_DIRS")) |old| {
         // We have an old value, We need to prepend our value to it.
 
-        // We use a 4K buffer to hold our XDG_DATA_DIR value. The stack
-        // on macOS is at least 512K and Linux is 8MB or more. So this
-        // should fit. If the user has a XDG_DATA_DIR value that is longer
-        // than this then it will fail... and we will cross that bridge
-        // when we actually get there. This avoids us needing an allocator.
-        var buf: [4096]u8 = undefined;
-        const prepended = try std.fmt.bufPrint(
-            &buf,
+        // We attempt to avoid allocating by using the stack up to 4K.
+        // Max stack size is considerably larger on macOS and Linux but
+        // 4K is a reasonable size for this for most cases. However, env
+        // vars can be significantly larger so if we have to we fall
+        // back to a heap allocated value.
+        var stack_alloc = std.heap.stackFallback(4096, alloc_gpa);
+        const alloc = stack_alloc.get();
+        const prepended = try std.fmt.allocPrint(
+            alloc,
             "{s}{c}{s}",
             .{ integ_dir, std.fs.path.delimiter, old },
         );
+        defer alloc.free(prepended);
 
         try env.put("XDG_DATA_DIRS", prepended);
     } else {

commit ee1366a0a8699a3d06446ec8e3c3629b452dccde
Author: Atanas Pepechkov <atanas@nakacide.com>
Date:   Sat Jan 13 18:56:21 2024 +0200

    add sudo wrapper as optional shell integration feature

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 296c95db..f8266f96 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -49,6 +49,7 @@ pub fn setup(
 
     // Setup our feature env vars
     if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
+    if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
 
     return shell;
 }

commit e34b37342620c32ab1420105236c343853742d98
Author: Marius Svechla <m.svechla@gmail.com>
Date:   Wed Apr 3 21:27:53 2024 +0200

    shell-integration: implement no-title option
    
    This adds a new option to the shell integration feature set, `no-title`.
    If this option is set, the shell integration will not automatically
    update the window title.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index f8266f96..95d86eaa 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -50,6 +50,7 @@ pub fn setup(
     // Setup our feature env vars
     if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
     if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
+    if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
 
     return shell;
 }

commit 5ea99d36262448deea80495fb03d60a028b6c8ad
Author: Jon Parise <jon@indelible.org>
Date:   Sat Apr 20 11:27:15 2024 -0700

    termio: fix "forced" shell integration
    
    When a shell is forced, we would supply its /-prefixed executable name
    to mimic a path location. The rest of the integration detection logic
    assumes just a base executable name. Fix the forced names accordingly.
    
    Also add a unit test for this "force shell" behavior.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 95d86eaa..8693e7fc 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -29,8 +29,8 @@ pub fn setup(
     features: config.ShellIntegrationFeatures,
 ) !?Shell {
     const exe = if (force_shell) |shell| switch (shell) {
-        .fish => "/fish",
-        .zsh => "/zsh",
+        .fish => "fish",
+        .zsh => "zsh",
     } else std.fs.path.basename(command_path);
 
     const shell: Shell = shell: {
@@ -123,3 +123,16 @@ fn setupZsh(
     );
     try env.put("ZDOTDIR", integ_dir);
 }
+
+test "force shell" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    inline for (@typeInfo(Shell).Enum.fields) |field| {
+        const shell = @field(Shell, field.name);
+        try testing.expectEqual(shell, setup(alloc, ".", "sh", &env, shell, .{}));
+    }
+}

commit 54f6abf1cf73f91508d334c419a98ccf1da7e4f2
Author: Jon Parise <jon@indelible.org>
Date:   Fri Apr 19 12:34:52 2024 -0700

    termio: pass full command to shell integration
    
    This will allow the shell integration code to inspect the full command
    string rather than just the first component (shell binary).

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 8693e7fc..d11d08f7 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -23,7 +23,7 @@ pub const Shell = enum {
 pub fn setup(
     alloc: Allocator,
     resource_dir: []const u8,
-    command_path: []const u8,
+    command: []const u8,
     env: *EnvMap,
     force_shell: ?Shell,
     features: config.ShellIntegrationFeatures,
@@ -31,7 +31,12 @@ pub fn setup(
     const exe = if (force_shell) |shell| switch (shell) {
         .fish => "fish",
         .zsh => "zsh",
-    } else std.fs.path.basename(command_path);
+    } else exe: {
+        // The command can include arguments. Look for the first space
+        // and use the basename of the first part as the command's exe.
+        const idx = std.mem.indexOfScalar(u8, command, ' ') orelse command.len;
+        break :exe std.fs.path.basename(command[0..idx]);
+    };
 
     const shell: Shell = shell: {
         if (std.mem.eql(u8, "fish", exe)) {

commit 73b3560e62954fb1ff327bf58e0ef69464694ec3
Author: Jon Parise <jon@indelible.org>
Date:   Sun May 5 13:24:09 2024 -0700

    shell-integration: automatic bash integration
    
    This change adds automatic bash shell detection and integration.
    
    Unlike our other shell integrations, bash doesn't provide a built-in
    mechanism for injecting our ghostty.bash script into the new shell
    environment.
    
    Instead, we start bash in POSIX mode and use the ENV environment
    variable to load our integration script, and the rest of the bash
    startup sequence becomes the responsibility of our script to emulate
    (along with disabling POSIX mode).

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index d11d08f7..f32b5919 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -7,19 +7,34 @@ const log = std.log.scoped(.shell_integration);
 
 /// Shell types we support
 pub const Shell = enum {
+    bash,
     fish,
     zsh,
 };
 
+pub const ShellIntegration = struct {
+    /// The successfully-integrated shell.
+    shell: Shell,
+
+    /// A revised shell command. This value will be allocated
+    /// with the setup() function's allocator and becomes the
+    /// caller's responsibility to free it.
+    command: ?[]const u8 = null,
+
+    pub fn deinit(self: ShellIntegration, alloc: Allocator) void {
+        if (self.command) |command| {
+            alloc.free(command);
+        }
+    }
+};
+
 /// Setup the command execution environment for automatic
-/// integrated shell integration. This returns true if shell
-/// integration was successful. False could mean many things:
-/// the shell type wasn't detected, etc.
+/// integrated shell integration and return a ShellIntegration
+/// struct describing the integration.  If integration fails
+/// (shell type couldn't be detected, etc.), this will return null.
 ///
-/// The allocator is only used for temporary values, so it should
-/// be given a general purpose allocator. No allocated memory remains
-/// after this function returns except anything allocated by the
-/// EnvMap.
+/// The allocator is used for temporary values and to allocate values
+/// in the ShellIntegration result.
 pub fn setup(
     alloc: Allocator,
     resource_dir: []const u8,
@@ -27,8 +42,9 @@ pub fn setup(
     env: *EnvMap,
     force_shell: ?Shell,
     features: config.ShellIntegrationFeatures,
-) !?Shell {
+) !?ShellIntegration {
     const exe = if (force_shell) |shell| switch (shell) {
+        .bash => "bash",
         .fish => "fish",
         .zsh => "zsh",
     } else exe: {
@@ -38,7 +54,14 @@ pub fn setup(
         break :exe std.fs.path.basename(command[0..idx]);
     };
 
+    var new_command: ?[]const u8 = null;
     const shell: Shell = shell: {
+        if (std.mem.eql(u8, "bash", exe)) {
+            new_command = try setupBash(alloc, command, resource_dir, env);
+            if (new_command == null) return null;
+            break :shell .bash;
+        }
+
         if (std.mem.eql(u8, "fish", exe)) {
             try setupFish(alloc, resource_dir, env);
             break :shell .fish;
@@ -57,7 +80,297 @@ pub fn setup(
     if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
     if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
 
-    return shell;
+    return .{
+        .shell = shell,
+        .command = new_command,
+    };
+}
+
+test "force shell" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    inline for (@typeInfo(Shell).Enum.fields) |field| {
+        const shell = @field(Shell, field.name);
+        const result = try setup(alloc, ".", "sh", &env, shell, .{});
+
+        try testing.expect(result != null);
+        if (result) |r| {
+            try testing.expectEqual(shell, r.shell);
+            r.deinit(alloc);
+        }
+    }
+}
+
+/// Setup the bash automatic shell integration. This works by
+/// starting bash in POSIX mode and using the ENV environment
+/// variable to load our bash integration script. This prevents
+/// bash from loading its normal startup files, which becomes
+/// our script's responsibility (along with disabling POSIX
+/// mode).
+///
+/// This returns a new (allocated) shell command string that
+/// enables the integration or null if integration failed.
+fn setupBash(
+    alloc: Allocator,
+    command: []const u8,
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !?[]const u8 {
+    // Accumulates the arguments that will form the final shell command line.
+    // We can build this list on the stack because we're just temporarily
+    // referencing other slices, but we can fall back to heap in extreme cases.
+    var args_alloc = std.heap.stackFallback(1024, alloc);
+    var args = try std.ArrayList([]const u8).initCapacity(args_alloc.get(), 2);
+    defer args.deinit();
+
+    // Iterator that yields each argument in the original command line.
+    // This will allocate once proportionate to the command line length.
+    var iter = try std.process.ArgIteratorGeneral(.{}).init(alloc, command);
+    defer iter.deinit();
+
+    // Start accumulating arguments with the executable and `--posix` mode flag.
+    if (iter.next()) |exe| {
+        try args.append(exe);
+    } else return null;
+    try args.append("--posix");
+
+    // Stores the list of intercepted command line flags that will be passed
+    // to our shell integration script: --posix --norc --noprofile
+    // We always include at least "1" so the script can differentiate between
+    // being manually sourced or automatically injected (from here).
+    var inject = try std.BoundedArray(u8, 32).init(0);
+    try inject.appendSlice("1");
+
+    var posix = false;
+
+    // Some additional cases we don't yet cover:
+    //
+    //  - If the `c` shell option is set, interactive mode is disabled, so skip
+    //    loading our shell integration.
+    //  - If additional file arguments are provided (after a `-` or `--` flag),
+    //    and the `i` shell option isn't being explicitly set, we can assume a
+    //    non-interactive shell session and skip loading our shell integration.
+    while (iter.next()) |arg| {
+        if (std.mem.eql(u8, arg, "--posix")) {
+            try inject.appendSlice(" --posix");
+            posix = true;
+        } else if (std.mem.eql(u8, arg, "--norc")) {
+            try inject.appendSlice(" --norc");
+        } else if (std.mem.eql(u8, arg, "--noprofile")) {
+            try inject.appendSlice(" --noprofile");
+        } else if (std.mem.eql(u8, arg, "--rcfile") or std.mem.eql(u8, arg, "--init-file")) {
+            if (iter.next()) |rcfile| {
+                try env.put("GHOSTTY_BASH_RCFILE", rcfile);
+            }
+        } else {
+            try args.append(arg);
+        }
+    }
+    try env.put("GHOSTTY_BASH_INJECT", inject.slice());
+
+    // In POSIX mode, HISTFILE defaults to ~/.sh_history.
+    if (!posix and env.get("HISTFILE") == null) {
+        try env.put("HISTFILE", "~/.bash_history");
+        try env.put("GHOSTTY_BASH_UNEXPORT_HISTFILE", "1");
+    }
+
+    // Preserve the existing ENV value in POSIX mode.
+    if (env.get("ENV")) |old| {
+        if (posix) {
+            try env.put("GHOSTTY_BASH_ENV", old);
+        }
+    }
+
+    // Set our new ENV to point to our integration script.
+    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const integ_dir = try std.fmt.bufPrint(
+        &path_buf,
+        "{s}/shell-integration/bash/ghostty.bash",
+        .{resource_dir},
+    );
+    try env.put("ENV", integ_dir);
+
+    // Join the acculumated arguments to form the final command string.
+    return try std.mem.join(alloc, " ", args.items);
+}
+
+test "bash" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    const command = try setupBash(alloc, "bash", ".", &env);
+    defer if (command) |c| alloc.free(c);
+
+    try testing.expectEqualStrings("bash --posix", command.?);
+    try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
+    try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_INJECT").?);
+}
+
+test "bash: inject flags" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    // bash --posix
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        const command = try setupBash(alloc, "bash --posix", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqualStrings("1 --posix", env.get("GHOSTTY_BASH_INJECT").?);
+    }
+
+    // bash --norc
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        const command = try setupBash(alloc, "bash --norc", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqualStrings("1 --norc", env.get("GHOSTTY_BASH_INJECT").?);
+    }
+
+    // bash --noprofile
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        const command = try setupBash(alloc, "bash --noprofile", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqualStrings("1 --noprofile", env.get("GHOSTTY_BASH_INJECT").?);
+    }
+}
+
+test "bash: rcfile" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    // bash --rcfile
+    {
+        const command = try setupBash(alloc, "bash --rcfile profile.sh", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
+    }
+
+    // bash --init-file
+    {
+        const command = try setupBash(alloc, "bash --init-file profile.sh", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
+    }
+}
+
+test "bash: HISTFILE" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    // HISTFILE unset
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        const command = try setupBash(alloc, "bash", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("~/.bash_history", env.get("HISTFILE").?);
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE").?);
+    }
+
+    // HISTFILE set
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        try env.put("HISTFILE", "my_history");
+
+        const command = try setupBash(alloc, "bash", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
+        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
+    }
+
+    // HISTFILE unset (POSIX mode)
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        const command = try setupBash(alloc, "bash --posix", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expect(env.get("HISTFILE") == null);
+        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
+    }
+
+    // HISTFILE set (POSIX mode)
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        try env.put("HISTFILE", "my_history");
+
+        const command = try setupBash(alloc, "bash --posix", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
+        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
+    }
+}
+
+test "bash: preserve ENV" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    const original_env = "original-env.bash";
+
+    // POSIX mode
+    {
+        try env.put("ENV", original_env);
+        const command = try setupBash(alloc, "bash --posix", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expect(std.mem.indexOf(u8, command.?, "--posix") != null);
+        try testing.expect(std.mem.indexOf(u8, env.get("GHOSTTY_BASH_INJECT").?, "posix") != null);
+        try testing.expectEqualStrings(original_env, env.get("GHOSTTY_BASH_ENV").?);
+        try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
+    }
+
+    env.remove("GHOSTTY_BASH_ENV");
+
+    // Not POSIX mode
+    {
+        try env.put("ENV", original_env);
+        const command = try setupBash(alloc, "bash", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expect(std.mem.indexOf(u8, command.?, "--posix") != null);
+        try testing.expect(std.mem.indexOf(u8, env.get("GHOSTTY_BASH_INJECT").?, "posix") == null);
+        try testing.expect(env.get("GHOSTTY_BASH_ENV") == null);
+        try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
+    }
 }
 
 /// Setup the fish automatic shell integration. This works by
@@ -128,16 +441,3 @@ fn setupZsh(
     );
     try env.put("ZDOTDIR", integ_dir);
 }
-
-test "force shell" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    inline for (@typeInfo(Shell).Enum.fields) |field| {
-        const shell = @field(Shell, field.name);
-        try testing.expectEqual(shell, setup(alloc, ".", "sh", &env, shell, .{}));
-    }
-}

commit 861edc722f23bb204ac616ac63c3f91f4b8fa024
Author: Jon Parise <jon@indelible.org>
Date:   Sun May 5 14:03:31 2024 -0700

    shell-integration: revise ShellIntegration.command comment

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index f32b5919..b2ba1e44 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -16,9 +16,7 @@ pub const ShellIntegration = struct {
     /// The successfully-integrated shell.
     shell: Shell,
 
-    /// A revised shell command. This value will be allocated
-    /// with the setup() function's allocator and becomes the
-    /// caller's responsibility to free it.
+    /// A revised, integration-aware shell command.
     command: ?[]const u8 = null,
 
     pub fn deinit(self: ShellIntegration, alloc: Allocator) void {

commit d64fa6d9dbcd9ea3c7b772f865cf089b97c40e0f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 7 19:57:26 2024 -0700

    termio: shell integration uses arena

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index b2ba1e44..413d9e18 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -1,5 +1,6 @@
 const std = @import("std");
 const Allocator = std.mem.Allocator;
+const ArenaAllocator = std.heap.ArenaAllocator;
 const EnvMap = std.process.EnvMap;
 const config = @import("../config.zig");
 
@@ -12,18 +13,17 @@ pub const Shell = enum {
     zsh,
 };
 
+/// The result of setting up a shell integration.
 pub const ShellIntegration = struct {
     /// The successfully-integrated shell.
     shell: Shell,
 
-    /// A revised, integration-aware shell command.
-    command: ?[]const u8 = null,
-
-    pub fn deinit(self: ShellIntegration, alloc: Allocator) void {
-        if (self.command) |command| {
-            alloc.free(command);
-        }
-    }
+    /// The command to use to start the shell with the integration.
+    /// In most cases this is identical to the command given but for
+    /// bash in particular it may be different.
+    ///
+    /// The memory is allocated in the arena given to setup.
+    command: []const u8,
 };
 
 /// Setup the command execution environment for automatic
@@ -32,9 +32,10 @@ pub const ShellIntegration = struct {
 /// (shell type couldn't be detected, etc.), this will return null.
 ///
 /// The allocator is used for temporary values and to allocate values
-/// in the ShellIntegration result.
+/// in the ShellIntegration result. It is expected to be an arena to
+/// simplify cleanup.
 pub fn setup(
-    alloc: Allocator,
+    alloc_arena: Allocator,
     resource_dir: []const u8,
     command: []const u8,
     env: *EnvMap,
@@ -52,22 +53,34 @@ pub fn setup(
         break :exe std.fs.path.basename(command[0..idx]);
     };
 
-    var new_command: ?[]const u8 = null;
-    const shell: Shell = shell: {
+    const result: ShellIntegration = shell: {
         if (std.mem.eql(u8, "bash", exe)) {
-            new_command = try setupBash(alloc, command, resource_dir, env);
-            if (new_command == null) return null;
-            break :shell .bash;
+            const new_command = try setupBash(
+                alloc_arena,
+                command,
+                resource_dir,
+                env,
+            ) orelse return null;
+            break :shell .{
+                .shell = .bash,
+                .command = new_command,
+            };
         }
 
         if (std.mem.eql(u8, "fish", exe)) {
-            try setupFish(alloc, resource_dir, env);
-            break :shell .fish;
+            try setupFish(alloc_arena, resource_dir, env);
+            break :shell .{
+                .shell = .fish,
+                .command = command,
+            };
         }
 
         if (std.mem.eql(u8, "zsh", exe)) {
             try setupZsh(resource_dir, env);
-            break :shell .zsh;
+            break :shell .{
+                .shell = .zsh,
+                .command = command,
+            };
         }
 
         return null;
@@ -78,15 +91,15 @@ pub fn setup(
     if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
     if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
 
-    return .{
-        .shell = shell,
-        .command = new_command,
-    };
+    return result;
 }
 
 test "force shell" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     var env = EnvMap.init(alloc);
     defer env.deinit();
@@ -94,12 +107,7 @@ test "force shell" {
     inline for (@typeInfo(Shell).Enum.fields) |field| {
         const shell = @field(Shell, field.name);
         const result = try setup(alloc, ".", "sh", &env, shell, .{});
-
-        try testing.expect(result != null);
-        if (result) |r| {
-            try testing.expectEqual(shell, r.shell);
-            r.deinit(alloc);
-        }
+        try testing.expectEqual(shell, result.?.shell);
     }
 }
 
@@ -376,7 +384,7 @@ test "bash: preserve ENV" {
 /// Fish will automatically load configuration in XDG_DATA_DIRS
 /// "fish/vendor_conf.d/*.fish".
 fn setupFish(
-    alloc_gpa: Allocator,
+    alloc_arena: Allocator,
     resource_dir: []const u8,
     env: *EnvMap,
 ) !void {
@@ -402,7 +410,7 @@ fn setupFish(
         // 4K is a reasonable size for this for most cases. However, env
         // vars can be significantly larger so if we have to we fall
         // back to a heap allocated value.
-        var stack_alloc = std.heap.stackFallback(4096, alloc_gpa);
+        var stack_alloc = std.heap.stackFallback(4096, alloc_arena);
         const alloc = stack_alloc.get();
         const prepended = try std.fmt.allocPrint(
             alloc,

commit 054e01eaaffaaf3f5cef2c2a11c0e4dcb53f7945
Author: Jon Parise <jon@indelible.org>
Date:   Wed May 8 07:49:46 2024 -0700

    shell-integration: expand bash HISTFILE value
    
    bash reads HISTFILE at startup to locate its history file, but this is
    apparently too early for it to be able to expand home-relative paths. We
    now manually expand the full path and add that to the environment.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 413d9e18..60fcc018 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -3,6 +3,7 @@ const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const EnvMap = std.process.EnvMap;
 const config = @import("../config.zig");
+const homedir = @import("../os/homedir.zig");
 
 const log = std.log.scoped(.shell_integration);
 
@@ -178,13 +179,23 @@ fn setupBash(
     }
     try env.put("GHOSTTY_BASH_INJECT", inject.slice());
 
-    // In POSIX mode, HISTFILE defaults to ~/.sh_history.
+    // In POSIX mode, HISTFILE defaults to ~/.sh_history, so unless we're
+    // staying in POSIX mode (--posix), change it back to ~/.bash_history.
     if (!posix and env.get("HISTFILE") == null) {
-        try env.put("HISTFILE", "~/.bash_history");
-        try env.put("GHOSTTY_BASH_UNEXPORT_HISTFILE", "1");
+        var home_buf: [1024]u8 = undefined;
+        if (try homedir.home(&home_buf)) |home| {
+            var histfile_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            const histfile = try std.fmt.bufPrint(
+                &histfile_buf,
+                "{s}/.bash_history",
+                .{home},
+            );
+            try env.put("HISTFILE", histfile);
+            try env.put("GHOSTTY_BASH_UNEXPORT_HISTFILE", "1");
+        }
     }
 
-    // Preserve the existing ENV value in POSIX mode.
+    // Preserve the existing ENV value when staying in POSIX mode (--posix).
     if (env.get("ENV")) |old| {
         if (posix) {
             try env.put("GHOSTTY_BASH_ENV", old);
@@ -298,7 +309,7 @@ test "bash: HISTFILE" {
         const command = try setupBash(alloc, "bash", ".", &env);
         defer if (command) |c| alloc.free(c);
 
-        try testing.expectEqualStrings("~/.bash_history", env.get("HISTFILE").?);
+        try testing.expect(std.mem.endsWith(u8, env.get("HISTFILE").?, ".bash_history"));
         try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE").?);
     }
 

commit 016c58cfe49707f92b9a7139dd66e379195ade17
Author: Jon Parise <jon@indelible.org>
Date:   Tue May 14 10:40:25 2024 -0700

    shell-integration: handle 'bash -c command'
    
    When the -c option is present, then commands are read from the first
    non-option argument command string. Our simple implementation assumes
    that if we see at least the '-c' option, a command string was given, and
    the shell is always considered to be non-interactive - even if the '-i'
    (interactive) option is also given.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 60fcc018..fb57595f 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -156,8 +156,6 @@ fn setupBash(
 
     // Some additional cases we don't yet cover:
     //
-    //  - If the `c` shell option is set, interactive mode is disabled, so skip
-    //    loading our shell integration.
     //  - If additional file arguments are provided (after a `-` or `--` flag),
     //    and the `i` shell option isn't being explicitly set, we can assume a
     //    non-interactive shell session and skip loading our shell integration.
@@ -173,6 +171,12 @@ fn setupBash(
             if (iter.next()) |rcfile| {
                 try env.put("GHOSTTY_BASH_RCFILE", rcfile);
             }
+        } else if (arg.len > 1 and arg[0] == '-' and arg[1] != '-') {
+            // '-c command' is always non-interactive
+            if (std.mem.indexOfScalar(u8, arg, 'c') != null) {
+                return null;
+            }
+            try args.append(arg);
         } else {
             try args.append(arg);
         }
@@ -297,6 +301,17 @@ test "bash: rcfile" {
     }
 }
 
+test "bash: -c command" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    try testing.expect(try setupBash(alloc, "bash -c script.sh", ".", &env) == null);
+    try testing.expect(try setupBash(alloc, "bash -ic script.sh", ".", &env) == null);
+}
+
 test "bash: HISTFILE" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit 1fa830cc739c593030f8de31f75aad79053ae6e9
Author: ilk <ilk@mailbox.org>
Date:   Thu May 16 23:59:02 2024 +0300

    feat(shell-integration): add automatic integration for Elvish
    
    Fish automatic integration taken as an example.
    Just like fish, Elvish checks `XDG_DATA_DIRS` for its modules.
    Thus, Fish integration in zig is reused, and integration in
    Elvish now removes `GHOSTTY_FISH_XDG_DIR` environment variable
    on launch.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index fb57595f..e05c57a0 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -12,6 +12,7 @@ pub const Shell = enum {
     bash,
     fish,
     zsh,
+    elvish,
 };
 
 /// The result of setting up a shell integration.
@@ -47,6 +48,7 @@ pub fn setup(
         .bash => "bash",
         .fish => "fish",
         .zsh => "zsh",
+        .elvish => "elvish",
     } else exe: {
         // The command can include arguments. Look for the first space
         // and use the basename of the first part as the command's exe.
@@ -76,6 +78,14 @@ pub fn setup(
             };
         }
 
+        if (std.mem.eql(u8, "elvish", exe)) {
+            try setupElvish(alloc_arena, resource_dir, env);
+            break :shell .{
+                .shell = .elvish,
+                .command = command,
+            };
+        }
+
         if (std.mem.eql(u8, "zsh", exe)) {
             try setupZsh(resource_dir, env);
             break :shell .{
@@ -452,6 +462,18 @@ fn setupFish(
     }
 }
 
+/// Setup the Elvish automatic shell integration.
+/// This reuses integration primitives of Fish, as Elvish also
+/// loads config in XDG_DATA_DIRS (except it imports
+/// "./elvish/lib/*.elv" files).
+fn setupElvish(
+    alloc_arena: Allocator,
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !void {
+    try setupFish(alloc_arena, resource_dir, env);
+}
+
 /// Setup the zsh automatic shell integration. This works by setting
 /// ZDOTDIR to our resources dir so that zsh will load our config. This
 /// config then loads the true user config.

commit 7377ca89172ce2d464dfb142f3519b85471bf769
Author: ilk <ilk@mailbox.org>
Date:   Fri May 17 18:02:03 2024 +0300

    refactor(shell-integration): refactor to make cases alphabetical
    
    also refactors elvish file to evade unobvious returns
    and tries to fix some build errors

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index e05c57a0..aed7ae49 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -10,9 +10,9 @@ const log = std.log.scoped(.shell_integration);
 /// Shell types we support
 pub const Shell = enum {
     bash,
+    elvish,
     fish,
     zsh,
-    elvish,
 };
 
 /// The result of setting up a shell integration.
@@ -46,9 +46,9 @@ pub fn setup(
 ) !?ShellIntegration {
     const exe = if (force_shell) |shell| switch (shell) {
         .bash => "bash",
+        .elvish => "elvish",
         .fish => "fish",
         .zsh => "zsh",
-        .elvish => "elvish",
     } else exe: {
         // The command can include arguments. Look for the first space
         // and use the basename of the first part as the command's exe.
@@ -70,18 +70,18 @@ pub fn setup(
             };
         }
 
-        if (std.mem.eql(u8, "fish", exe)) {
-            try setupFish(alloc_arena, resource_dir, env);
+        if (std.mem.eql(u8, "elvish", exe)) {
+            try setupXdgDataDirs(alloc_arena, resource_dir, env);
             break :shell .{
-                .shell = .fish,
+                .shell = .elvish,
                 .command = command,
             };
         }
 
-        if (std.mem.eql(u8, "elvish", exe)) {
-            try setupElvish(alloc_arena, resource_dir, env);
+        if (std.mem.eql(u8, "fish", exe)) {
+            try setupXdgDataDirs(alloc_arena, resource_dir, env);
             break :shell .{
-                .shell = .elvish,
+                .shell = .fish,
                 .command = command,
             };
         }
@@ -415,11 +415,14 @@ test "bash: preserve ENV" {
     }
 }
 
-/// Setup the fish automatic shell integration. This works by
-/// modify XDG_DATA_DIRS to include the resource directory.
-/// Fish will automatically load configuration in XDG_DATA_DIRS
-/// "fish/vendor_conf.d/*.fish".
-fn setupFish(
+/// Setup automatic shell integration for shells that include
+/// their modules from paths in `XDG_DATA_DIRS` env variable.
+///
+/// Path of shell-integration dir is prepended to `XDG_DATA_DIRS`.
+/// It is also saved in `GHOSTTY_INTEGRATION_DIR` variable so that
+/// the shell can refer to it and safely remove this directory
+/// from `XDG_DATA_DIRS` when integration is complete.
+fn setupXdgDataDirs(
     alloc_arena: Allocator,
     resource_dir: []const u8,
     env: *EnvMap,
@@ -436,7 +439,7 @@ fn setupFish(
     // Set an env var so we can remove this from XDG_DATA_DIRS later.
     // This happens in the shell integration config itself. We do this
     // so that our modifications don't interfere with other commands.
-    try env.put("GHOSTTY_FISH_XDG_DIR", integ_dir);
+    try env.put("GHOSTTY_INTEGRATION_DIR", integ_dir);
 
     if (env.get("XDG_DATA_DIRS")) |old| {
         // We have an old value, We need to prepend our value to it.
@@ -462,18 +465,6 @@ fn setupFish(
     }
 }
 
-/// Setup the Elvish automatic shell integration.
-/// This reuses integration primitives of Fish, as Elvish also
-/// loads config in XDG_DATA_DIRS (except it imports
-/// "./elvish/lib/*.elv" files).
-fn setupElvish(
-    alloc_arena: Allocator,
-    resource_dir: []const u8,
-    env: *EnvMap,
-) !void {
-    try setupFish(alloc_arena, resource_dir, env);
-}
-
 /// Setup the zsh automatic shell integration. This works by setting
 /// ZDOTDIR to our resources dir so that zsh will load our config. This
 /// config then loads the true user config.

commit 66a9b1b99f833bccf9ea9de44203fa24ffdbbeab
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon May 27 16:18:51 2024 -0700

    rename env var

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index aed7ae49..392fb5b4 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -419,8 +419,8 @@ test "bash: preserve ENV" {
 /// their modules from paths in `XDG_DATA_DIRS` env variable.
 ///
 /// Path of shell-integration dir is prepended to `XDG_DATA_DIRS`.
-/// It is also saved in `GHOSTTY_INTEGRATION_DIR` variable so that
-/// the shell can refer to it and safely remove this directory
+/// It is also saved in `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
+/// so that the shell can refer to it and safely remove this directory
 /// from `XDG_DATA_DIRS` when integration is complete.
 fn setupXdgDataDirs(
     alloc_arena: Allocator,
@@ -439,7 +439,7 @@ fn setupXdgDataDirs(
     // Set an env var so we can remove this from XDG_DATA_DIRS later.
     // This happens in the shell integration config itself. We do this
     // so that our modifications don't interfere with other commands.
-    try env.put("GHOSTTY_INTEGRATION_DIR", integ_dir);
+    try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
 
     if (env.get("XDG_DATA_DIRS")) |old| {
         // We have an old value, We need to prepend our value to it.

commit 7d7fa46b0c8d54048985159a897d89c85f035c16
Author: Jon Parise <jon@indelible.org>
Date:   Mon Jun 3 20:32:05 2024 -0400

    shell-integration: bash must be explicitly enabled
    
    For now, bash integration must be explicitly enabled (by setting
    `shell-integration = bash`). Our automatic shell integration requires
    bash version 4 or later, and systems like macOS continue to ship bash
    version 3 by default. This approach avoids the cost of performing a
    runtime version check.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 392fb5b4..ade1f3b5 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -57,7 +57,11 @@ pub fn setup(
     };
 
     const result: ShellIntegration = shell: {
-        if (std.mem.eql(u8, "bash", exe)) {
+        // For now, bash integration must be explicitly enabled via force_shell.
+        // Our automatic shell integration requires bash version 4 or later,
+        // and systems like macOS continue to ship bash version 3 by default.
+        // This approach avoids the cost of performing a runtime version check.
+        if (std.mem.eql(u8, "bash", exe) and force_shell == .bash) {
             const new_command = try setupBash(
                 alloc_arena,
                 command,
@@ -129,6 +133,8 @@ test "force shell" {
 /// our script's responsibility (along with disabling POSIX
 /// mode).
 ///
+/// This approach requires bash version 4 or later.
+///
 /// This returns a new (allocated) shell command string that
 /// enables the integration or null if integration failed.
 fn setupBash(

commit 72c672adb7ff9d7ce766be4ed8b0f263775636b8
Author: multifred <github-ghostty@2al.ch>
Date:   Mon Jul 22 00:06:18 2024 +0200

    Fix multiple deprecated names for zig lib/std

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index ade1f3b5..99aec848 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -204,7 +204,7 @@ fn setupBash(
     if (!posix and env.get("HISTFILE") == null) {
         var home_buf: [1024]u8 = undefined;
         if (try homedir.home(&home_buf)) |home| {
-            var histfile_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            var histfile_buf: [std.fs.max_path_bytes]u8 = undefined;
             const histfile = try std.fmt.bufPrint(
                 &histfile_buf,
                 "{s}/.bash_history",
@@ -223,7 +223,7 @@ fn setupBash(
     }
 
     // Set our new ENV to point to our integration script.
-    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
     const integ_dir = try std.fmt.bufPrint(
         &path_buf,
         "{s}/shell-integration/bash/ghostty.bash",
@@ -433,7 +433,7 @@ fn setupXdgDataDirs(
     resource_dir: []const u8,
     env: *EnvMap,
 ) !void {
-    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
 
     // Get our path to the shell integration directory.
     const integ_dir = try std.fmt.bufPrint(
@@ -484,7 +484,7 @@ fn setupZsh(
     }
 
     // Set our new ZDOTDIR
-    var path_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
     const integ_dir = try std.fmt.bufPrint(
         &path_buf,
         "{s}/shell-integration/zsh",

commit f9be02a20f9f77649efad3f6fda3dd15639ef252
Author: ukasz Niemier <lukasz@niemier.pl>
Date:   Mon Aug 5 13:56:57 2024 +0200

    chore: clean up typos

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 99aec848..7a8726b1 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -231,7 +231,7 @@ fn setupBash(
     );
     try env.put("ENV", integ_dir);
 
-    // Join the acculumated arguments to form the final command string.
+    // Join the accumulated arguments to form the final command string.
     return try std.mem.join(alloc, " ", args.items);
 }
 

commit 8e736aa4ebe5cd12edcabde61043943e4af4a187
Author: notcancername <notcancername@protonmail.com>
Date:   Sun Nov 17 15:25:36 2024 +0100

    Append the default value of XDG_DATA_DIRS when setting up shell integration

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 7a8726b1..031cc983 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -447,27 +447,30 @@ fn setupXdgDataDirs(
     // so that our modifications don't interfere with other commands.
     try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
 
-    if (env.get("XDG_DATA_DIRS")) |old| {
-        // We have an old value, We need to prepend our value to it.
-
+    {
         // We attempt to avoid allocating by using the stack up to 4K.
         // Max stack size is considerably larger on macOS and Linux but
         // 4K is a reasonable size for this for most cases. However, env
         // vars can be significantly larger so if we have to we fall
         // back to a heap allocated value.
-        var stack_alloc = std.heap.stackFallback(4096, alloc_arena);
-        const alloc = stack_alloc.get();
+        var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
+        const stack_alloc = stack_alloc_state.get();
+
+        const old_value = if (env.get("XDG_DATA_DIRS")) |old|
+            old
+        else
+            // No XDG_DATA_DIRS set, we prepend to the default value.
+            // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
+            "/usr/local/share:/usr/share";
+
         const prepended = try std.fmt.allocPrint(
-            alloc,
+            stack_alloc,
             "{s}{c}{s}",
-            .{ integ_dir, std.fs.path.delimiter, old },
+            .{ integ_dir, std.fs.path.delimiter, old_value },
         );
-        defer alloc.free(prepended);
+        defer stack_alloc.free(prepended);
 
         try env.put("XDG_DATA_DIRS", prepended);
-    } else {
-        // No XDG_DATA_DIRS set, we just set it our desired value.
-        try env.put("XDG_DATA_DIRS", integ_dir);
     }
 }
 

commit 3e971f2837c5a97c0550d7d9ef894a0ab391f7ba
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 17 09:48:25 2024 -0800

    termio: tweaks to xdg data dir handling (no logic changes)

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 031cc983..cd4d88dc 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -448,6 +448,8 @@ fn setupXdgDataDirs(
     try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
 
     {
+        const xdg_data_dir_key = "XDG_DATA_DIRS";
+
         // We attempt to avoid allocating by using the stack up to 4K.
         // Max stack size is considerably larger on macOS and Linux but
         // 4K is a reasonable size for this for most cases. However, env
@@ -456,21 +458,20 @@ fn setupXdgDataDirs(
         var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
         const stack_alloc = stack_alloc_state.get();
 
-        const old_value = if (env.get("XDG_DATA_DIRS")) |old|
-            old
-        else
-            // No XDG_DATA_DIRS set, we prepend to the default value.
-            // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
-            "/usr/local/share:/usr/share";
-
-        const prepended = try std.fmt.allocPrint(
-            stack_alloc,
-            "{s}{c}{s}",
-            .{ integ_dir, std.fs.path.delimiter, old_value },
-        );
+        // If no XDG_DATA_DIRS set use the default value as specified.
+        // This ensures that the default directories aren't lost by setting
+        // our desired integration dir directly. See #2711.
+        // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
+        const old = env.get(xdg_data_dir_key) orelse "/usr/local/share:/usr/share";
+
+        const prepended = try std.fmt.allocPrint(stack_alloc, "{s}{c}{s}", .{
+            integ_dir,
+            std.fs.path.delimiter,
+            old,
+        });
         defer stack_alloc.free(prepended);
 
-        try env.put("XDG_DATA_DIRS", prepended);
+        try env.put(xdg_data_dir_key, prepended);
     }
 }
 

commit 70cc2d9793e87567560b56d03f42dcab0f8583f9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 23 09:40:00 2024 -0800

    termio: copy input command to avoid memory corruption
    
    Fixes #2779

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index cd4d88dc..06f2abc6 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -78,7 +78,7 @@ pub fn setup(
             try setupXdgDataDirs(alloc_arena, resource_dir, env);
             break :shell .{
                 .shell = .elvish,
-                .command = command,
+                .command = try alloc_arena.dupe(u8, command),
             };
         }
 
@@ -86,7 +86,7 @@ pub fn setup(
             try setupXdgDataDirs(alloc_arena, resource_dir, env);
             break :shell .{
                 .shell = .fish,
-                .command = command,
+                .command = try alloc_arena.dupe(u8, command),
             };
         }
 
@@ -94,7 +94,7 @@ pub fn setup(
             try setupZsh(resource_dir, env);
             break :shell .{
                 .shell = .zsh,
-                .command = command,
+                .command = try alloc_arena.dupe(u8, command),
             };
         }
 

commit a0ce70651aed0ba47b92a7657c8d2e7d111c1af5
Author: Jon Parise <jon@indelible.org>
Date:   Sat Dec 14 17:17:52 2024 -0500

    bash: re-enable automatic bash shell detection
    
    Bash shell detection was originally disabled in #1823 due to problems
    with /bin/bash on macOS.
    
    Apple distributes their own patched version of Bash 3.2 on macOS that
    disables the POSIX-style $ENV-based startup path:
    
    https://github.com/apple-oss-distributions/bash/blob/e5397a7e74633a4e84194a6c6b609e04077da6f8/bash-3.2/shell.c#L1112-L1114
    
    This means we're unable to perform our automatic shell integration
    sequence in this specific environment. Standard Bash 3.2 works fine.
    
    Knowing this, we can re-enable bash shell detection by default unless
    we're running "/bin/bash" on Darwin. We can safely assume that's the
    unsupported Bash executable because /bin is non-writable on modern macOS
    installations due to System Integrity Protection.
    
    macOS users can either manually source our shell integration script
    (which otherwise works fine with Apple's Bash) or install a standard
    version of Bash from Homebrew or elsewhere.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 06f2abc6..3d7b769c 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const EnvMap = std.process.EnvMap;
@@ -57,11 +58,21 @@ pub fn setup(
     };
 
     const result: ShellIntegration = shell: {
-        // For now, bash integration must be explicitly enabled via force_shell.
-        // Our automatic shell integration requires bash version 4 or later,
-        // and systems like macOS continue to ship bash version 3 by default.
-        // This approach avoids the cost of performing a runtime version check.
-        if (std.mem.eql(u8, "bash", exe) and force_shell == .bash) {
+        if (std.mem.eql(u8, "bash", exe)) {
+            // Apple distributes their own patched version of Bash 3.2
+            // on macOS that disables the ENV-based POSIX startup path.
+            // This means we're unable to perform our automatic shell
+            // integration sequence in this specific environment.
+            //
+            // If we're running "/bin/bash" on Darwin, we can assume
+            // we're using Apple's Bash because /bin is non-writable
+            // on modern macOS due to System Integrity Protection.
+            if (comptime builtin.target.isDarwin()) {
+                if (std.mem.eql(u8, "/bin/bash", command)) {
+                    return null;
+                }
+            }
+
             const new_command = try setupBash(
                 alloc_arena,
                 command,

commit f141f4b2b03151a6b67a39851780b208761a06b0
Author: Jon Parise <jon@indelible.org>
Date:   Mon Dec 16 10:40:35 2024 -0500

    os: add prependEnv(), like appendEnv()
    
    We can use this function in setupXdgDataDirs() to simplify the
    XDG_DATA_DIRS environment variable code in a more standardized way.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 3d7b769c..634f6e96 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -5,6 +5,7 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 const EnvMap = std.process.EnvMap;
 const config = @import("../config.zig");
 const homedir = @import("../os/homedir.zig");
+const internal_os = @import("../os/main.zig");
 
 const log = std.log.scoped(.shell_integration);
 
@@ -435,8 +436,8 @@ test "bash: preserve ENV" {
 /// Setup automatic shell integration for shells that include
 /// their modules from paths in `XDG_DATA_DIRS` env variable.
 ///
-/// Path of shell-integration dir is prepended to `XDG_DATA_DIRS`.
-/// It is also saved in `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
+/// The shell-integration path is prepended to `XDG_DATA_DIRS`.
+/// It is also saved in the `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
 /// so that the shell can refer to it and safely remove this directory
 /// from `XDG_DATA_DIRS` when integration is complete.
 fn setupXdgDataDirs(
@@ -458,32 +459,60 @@ fn setupXdgDataDirs(
     // so that our modifications don't interfere with other commands.
     try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
 
-    {
-        const xdg_data_dir_key = "XDG_DATA_DIRS";
-
-        // We attempt to avoid allocating by using the stack up to 4K.
-        // Max stack size is considerably larger on macOS and Linux but
-        // 4K is a reasonable size for this for most cases. However, env
-        // vars can be significantly larger so if we have to we fall
-        // back to a heap allocated value.
-        var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
-        const stack_alloc = stack_alloc_state.get();
-
-        // If no XDG_DATA_DIRS set use the default value as specified.
-        // This ensures that the default directories aren't lost by setting
-        // our desired integration dir directly. See #2711.
-        // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
-        const old = env.get(xdg_data_dir_key) orelse "/usr/local/share:/usr/share";
-
-        const prepended = try std.fmt.allocPrint(stack_alloc, "{s}{c}{s}", .{
+    // We attempt to avoid allocating by using the stack up to 4K.
+    // Max stack size is considerably larger on mac
+    // 4K is a reasonable size for this for most cases. However, env
+    // vars can be significantly larger so if we have to we fall
+    // back to a heap allocated value.
+    var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
+    const stack_alloc = stack_alloc_state.get();
+
+    // If no XDG_DATA_DIRS set use the default value as specified.
+    // This ensures that the default directories aren't lost by setting
+    // our desired integration dir directly. See #2711.
+    // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
+    const xdg_data_dirs_key = "XDG_DATA_DIRS";
+    try env.put(
+        xdg_data_dirs_key,
+        try internal_os.prependEnv(
+            stack_alloc,
+            env.get(xdg_data_dirs_key) orelse "/usr/local/share:/usr/share",
             integ_dir,
-            std.fs.path.delimiter,
-            old,
-        });
-        defer stack_alloc.free(prepended);
+        ),
+    );
+}
 
-        try env.put(xdg_data_dir_key, prepended);
-    }
+test "xdg: empty XDG_DATA_DIRS" {
+    const testing = std.testing;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    try setupXdgDataDirs(alloc, ".", &env);
+
+    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
+    try testing.expectEqualStrings("./shell-integration:/usr/local/share:/usr/share", env.get("XDG_DATA_DIRS").?);
+}
+
+test "xdg: existing XDG_DATA_DIRS" {
+    const testing = std.testing;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    try env.put("XDG_DATA_DIRS", "/opt/share");
+    try setupXdgDataDirs(alloc, ".", &env);
+
+    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
+    try testing.expectEqualStrings("./shell-integration:/opt/share", env.get("XDG_DATA_DIRS").?);
 }
 
 /// Setup the zsh automatic shell integration. This works by setting

commit 1b91a667fba5ec70c96f6d938e466e9631d53770
Author: Jon Parise <jon@indelible.org>
Date:   Tue Jan 7 15:51:02 2025 -0500

    bash: drop automatic shell integration with --posix
    
    '--posix' starts bash in POSIX mode (like /bin/sh). This is rarely used
    for interactive shells, and removing automatic shell integration support
    for this option allows us to simply/remove some exceptional code paths.
    
    Users are still able to manually source the shell integration script.
    
    Also fix an issue where we would still inject GHOSTTY_BASH_RCFILE if we
    aborted the automatic shell integration path _after_ seeing an --rcfile
    or --init-file argument.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 634f6e96..8cd2a92a 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -174,31 +174,36 @@ fn setupBash(
     try args.append("--posix");
 
     // Stores the list of intercepted command line flags that will be passed
-    // to our shell integration script: --posix --norc --noprofile
+    // to our shell integration script: --norc --noprofile
     // We always include at least "1" so the script can differentiate between
     // being manually sourced or automatically injected (from here).
     var inject = try std.BoundedArray(u8, 32).init(0);
     try inject.appendSlice("1");
 
-    var posix = false;
-
+    // Walk through the rest of the given arguments. If we see an option that
+    // would require complex or unsupported integration behavior, we bail out
+    // and skip loading our shell integration. Users can still manually source
+    // the shell integration script.
+    //
+    // Unsupported options:
+    //  -c          -c is always non-interactive
+    //  --posix     POSIX mode (a la /bin/sh)
+    //
     // Some additional cases we don't yet cover:
     //
     //  - If additional file arguments are provided (after a `-` or `--` flag),
     //    and the `i` shell option isn't being explicitly set, we can assume a
     //    non-interactive shell session and skip loading our shell integration.
+    var rcfile: ?[]const u8 = null;
     while (iter.next()) |arg| {
         if (std.mem.eql(u8, arg, "--posix")) {
-            try inject.appendSlice(" --posix");
-            posix = true;
+            return null;
         } else if (std.mem.eql(u8, arg, "--norc")) {
             try inject.appendSlice(" --norc");
         } else if (std.mem.eql(u8, arg, "--noprofile")) {
             try inject.appendSlice(" --noprofile");
         } else if (std.mem.eql(u8, arg, "--rcfile") or std.mem.eql(u8, arg, "--init-file")) {
-            if (iter.next()) |rcfile| {
-                try env.put("GHOSTTY_BASH_RCFILE", rcfile);
-            }
+            rcfile = iter.next();
         } else if (arg.len > 1 and arg[0] == '-' and arg[1] != '-') {
             // '-c command' is always non-interactive
             if (std.mem.indexOfScalar(u8, arg, 'c') != null) {
@@ -210,10 +215,13 @@ fn setupBash(
         }
     }
     try env.put("GHOSTTY_BASH_INJECT", inject.slice());
+    if (rcfile) |v| {
+        try env.put("GHOSTTY_BASH_RCFILE", v);
+    }
 
     // In POSIX mode, HISTFILE defaults to ~/.sh_history, so unless we're
     // staying in POSIX mode (--posix), change it back to ~/.bash_history.
-    if (!posix and env.get("HISTFILE") == null) {
+    if (env.get("HISTFILE") == null) {
         var home_buf: [1024]u8 = undefined;
         if (try homedir.home(&home_buf)) |home| {
             var histfile_buf: [std.fs.max_path_bytes]u8 = undefined;
@@ -227,13 +235,6 @@ fn setupBash(
         }
     }
 
-    // Preserve the existing ENV value when staying in POSIX mode (--posix).
-    if (env.get("ENV")) |old| {
-        if (posix) {
-            try env.put("GHOSTTY_BASH_ENV", old);
-        }
-    }
-
     // Set our new ENV to point to our integration script.
     var path_buf: [std.fs.max_path_bytes]u8 = undefined;
     const integ_dir = try std.fmt.bufPrint(
@@ -262,21 +263,32 @@ test "bash" {
     try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_INJECT").?);
 }
 
-test "bash: inject flags" {
+test "bash: unsupported options" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    // bash --posix
-    {
+    const cmdlines = [_][]const u8{
+        "bash --posix",
+        "bash --rcfile script.sh --posix",
+        "bash --init-file script.sh --posix",
+        "bash -c script.sh",
+        "bash -ic script.sh",
+    };
+
+    for (cmdlines) |cmdline| {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        const command = try setupBash(alloc, "bash --posix", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("bash --posix", command.?);
-        try testing.expectEqualStrings("1 --posix", env.get("GHOSTTY_BASH_INJECT").?);
+        try testing.expect(try setupBash(alloc, cmdline, ".", &env) == null);
+        try testing.expect(env.get("GHOSTTY_BASH_INJECT") == null);
+        try testing.expect(env.get("GHOSTTY_BASH_RCFILE") == null);
+        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
     }
+}
+
+test "bash: inject flags" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
 
     // bash --norc
     {
@@ -329,17 +341,6 @@ test "bash: rcfile" {
     }
 }
 
-test "bash: -c command" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    try testing.expect(try setupBash(alloc, "bash -c script.sh", ".", &env) == null);
-    try testing.expect(try setupBash(alloc, "bash -ic script.sh", ".", &env) == null);
-}
-
 test "bash: HISTFILE" {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -369,68 +370,6 @@ test "bash: HISTFILE" {
         try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
         try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
     }
-
-    // HISTFILE unset (POSIX mode)
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        const command = try setupBash(alloc, "bash --posix", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expect(env.get("HISTFILE") == null);
-        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
-    }
-
-    // HISTFILE set (POSIX mode)
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        try env.put("HISTFILE", "my_history");
-
-        const command = try setupBash(alloc, "bash --posix", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
-        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
-    }
-}
-
-test "bash: preserve ENV" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    const original_env = "original-env.bash";
-
-    // POSIX mode
-    {
-        try env.put("ENV", original_env);
-        const command = try setupBash(alloc, "bash --posix", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expect(std.mem.indexOf(u8, command.?, "--posix") != null);
-        try testing.expect(std.mem.indexOf(u8, env.get("GHOSTTY_BASH_INJECT").?, "posix") != null);
-        try testing.expectEqualStrings(original_env, env.get("GHOSTTY_BASH_ENV").?);
-        try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
-    }
-
-    env.remove("GHOSTTY_BASH_ENV");
-
-    // Not POSIX mode
-    {
-        try env.put("ENV", original_env);
-        const command = try setupBash(alloc, "bash", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expect(std.mem.indexOf(u8, command.?, "--posix") != null);
-        try testing.expect(std.mem.indexOf(u8, env.get("GHOSTTY_BASH_INJECT").?, "posix") == null);
-        try testing.expect(env.get("GHOSTTY_BASH_ENV") == null);
-        try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
-    }
 }
 
 /// Setup automatic shell integration for shells that include

commit 8ee4deddb4edf0d4b39b673b14c3d7df2ec5244d
Author: Bryan Lee <38807139+liby@users.noreply.github.com>
Date:   Tue Jan 14 16:37:28 2025 +0800

    Fix `shell-integration-features` being ignored when `shell-integration` is `none`

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 8cd2a92a..85d9a837 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -114,9 +114,7 @@ pub fn setup(
     };
 
     // Setup our feature env vars
-    if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
-    if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
-    if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
+    try setupFeatures(env, features);
 
     return result;
 }
@@ -138,6 +136,17 @@ test "force shell" {
     }
 }
 
+/// Setup shell integration feature environment variables without
+/// performing full shell integration setup.
+pub fn setupFeatures(
+    env: *EnvMap,
+    features: config.ShellIntegrationFeatures,
+) !void {
+    if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
+    if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
+    if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
+}
+
 /// Setup the bash automatic shell integration. This works by
 /// starting bash in POSIX mode and using the ENV environment
 /// variable to load our bash integration script. This prevents

commit 9c1edb544998bb64545b3a52561c6f9e43bf0005
Author: Bryan Lee <38807139+liby@users.noreply.github.com>
Date:   Tue Jan 14 16:57:41 2025 +0800

    Add tests for setup shell integration features

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 85d9a837..8b12cabb 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -147,6 +147,47 @@ pub fn setupFeatures(
     if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
 }
 
+test "setup features" {
+    const testing = std.testing;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    // Test: all features enabled (no environment variables should be set)
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        try setupFeatures(&env, .{ .cursor = true, .sudo = true, .title = true });
+        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR") == null);
+        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO") == null);
+        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE") == null);
+    }
+
+    // Test: all features disabled
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        try setupFeatures(&env, .{ .cursor = false, .sudo = false, .title = false });
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR").?);
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO").?);
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE").?);
+    }
+
+    // Test: mixed features
+    {
+        var env = EnvMap.init(alloc);
+        defer env.deinit();
+
+        try setupFeatures(&env, .{ .cursor = false, .sudo = true, .title = false });
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR").?);
+        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO") == null);
+        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE").?);
+    }
+}
+
 /// Setup the bash automatic shell integration. This works by
 /// starting bash in POSIX mode and using the ENV environment
 /// variable to load our bash integration script. This prevents

commit ccd6fd26ecfeb652ce726ded7648dce9181a6ccc
Author: Bryan Lee <38807139+liby@users.noreply.github.com>
Date:   Wed Jan 15 08:30:40 2025 +0800

    Ensure `setup_features` runs even when shell detection fails

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 8b12cabb..915d5be9 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -58,65 +58,73 @@ pub fn setup(
         break :exe std.fs.path.basename(command[0..idx]);
     };
 
-    const result: ShellIntegration = shell: {
-        if (std.mem.eql(u8, "bash", exe)) {
-            // Apple distributes their own patched version of Bash 3.2
-            // on macOS that disables the ENV-based POSIX startup path.
-            // This means we're unable to perform our automatic shell
-            // integration sequence in this specific environment.
-            //
-            // If we're running "/bin/bash" on Darwin, we can assume
-            // we're using Apple's Bash because /bin is non-writable
-            // on modern macOS due to System Integrity Protection.
-            if (comptime builtin.target.isDarwin()) {
-                if (std.mem.eql(u8, "/bin/bash", command)) {
-                    return null;
-                }
-            }
+    const result = try setupShell(alloc_arena, resource_dir, command, env, exe);
 
-            const new_command = try setupBash(
-                alloc_arena,
-                command,
-                resource_dir,
-                env,
-            ) orelse return null;
-            break :shell .{
-                .shell = .bash,
-                .command = new_command,
-            };
-        }
+    // Setup our feature env vars
+    try setupFeatures(env, features);
 
-        if (std.mem.eql(u8, "elvish", exe)) {
-            try setupXdgDataDirs(alloc_arena, resource_dir, env);
-            break :shell .{
-                .shell = .elvish,
-                .command = try alloc_arena.dupe(u8, command),
-            };
-        }
+    return result;
+}
 
-        if (std.mem.eql(u8, "fish", exe)) {
-            try setupXdgDataDirs(alloc_arena, resource_dir, env);
-            break :shell .{
-                .shell = .fish,
-                .command = try alloc_arena.dupe(u8, command),
-            };
+fn setupShell(
+    alloc_arena: Allocator,
+    resource_dir: []const u8,
+    command: []const u8,
+    env: *EnvMap,
+    exe: []const u8,
+) !?ShellIntegration {
+    if (std.mem.eql(u8, "bash", exe)) {
+        // Apple distributes their own patched version of Bash 3.2
+        // on macOS that disables the ENV-based POSIX startup path.
+        // This means we're unable to perform our automatic shell
+        // integration sequence in this specific environment.
+        //
+        // If we're running "/bin/bash" on Darwin, we can assume
+        // we're using Apple's Bash because /bin is non-writable
+        // on modern macOS due to System Integrity Protection.
+        if (comptime builtin.target.isDarwin()) {
+            if (std.mem.eql(u8, "/bin/bash", command)) {
+                return null;
+            }
         }
 
-        if (std.mem.eql(u8, "zsh", exe)) {
-            try setupZsh(resource_dir, env);
-            break :shell .{
-                .shell = .zsh,
-                .command = try alloc_arena.dupe(u8, command),
-            };
-        }
+        const new_command = try setupBash(
+            alloc_arena,
+            command,
+            resource_dir,
+            env,
+        ) orelse return null;
+        return .{
+            .shell = .bash,
+            .command = new_command,
+        };
+    }
 
-        return null;
-    };
+    if (std.mem.eql(u8, "elvish", exe)) {
+        try setupXdgDataDirs(alloc_arena, resource_dir, env);
+        return .{
+            .shell = .elvish,
+            .command = try alloc_arena.dupe(u8, command),
+        };
+    }
 
-    // Setup our feature env vars
-    try setupFeatures(env, features);
+    if (std.mem.eql(u8, "fish", exe)) {
+        try setupXdgDataDirs(alloc_arena, resource_dir, env);
+        return .{
+            .shell = .fish,
+            .command = try alloc_arena.dupe(u8, command),
+        };
+    }
 
-    return result;
+    if (std.mem.eql(u8, "zsh", exe)) {
+        try setupZsh(resource_dir, env);
+        return .{
+            .shell = .zsh,
+            .command = try alloc_arena.dupe(u8, command),
+        };
+    }
+
+    return null;
 }
 
 test "force shell" {

commit a2018d7b20b557eeb2e0e59e39e9ad3c0c16e44a
Author: Jon Parise <jon@indelible.org>
Date:   Thu Jan 23 10:34:27 2025 -0500

    bash: handle additional command arguments
    
    A '-' or '--' argument signals the end of bash's own options. All
    remaining arguments are treated as filenames and arguments. We shouldn't
    perform any additional argument processing once we see this signal.
    
    We could also assume a non-interactive shell session in this case unless
    the '-i' (interactive) shell option has been explicitly specified, but
    let's wait on that until we know that doing so would solve a real user
    problem (and avoid any false negatives).

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 915d5be9..423e2f51 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -203,8 +203,6 @@ test "setup features" {
 /// our script's responsibility (along with disabling POSIX
 /// mode).
 ///
-/// This approach requires bash version 4 or later.
-///
 /// This returns a new (allocated) shell command string that
 /// enables the integration or null if integration failed.
 fn setupBash(
@@ -246,12 +244,6 @@ fn setupBash(
     // Unsupported options:
     //  -c          -c is always non-interactive
     //  --posix     POSIX mode (a la /bin/sh)
-    //
-    // Some additional cases we don't yet cover:
-    //
-    //  - If additional file arguments are provided (after a `-` or `--` flag),
-    //    and the `i` shell option isn't being explicitly set, we can assume a
-    //    non-interactive shell session and skip loading our shell integration.
     var rcfile: ?[]const u8 = null;
     while (iter.next()) |arg| {
         if (std.mem.eql(u8, arg, "--posix")) {
@@ -268,6 +260,14 @@ fn setupBash(
                 return null;
             }
             try args.append(arg);
+        } else if (std.mem.eql(u8, arg, "-") or std.mem.eql(u8, arg, "--")) {
+            // All remaining arguments should be passed directly to the shell
+            // command. We shouldn't perform any further option processing.
+            try args.append(arg);
+            while (iter.next()) |remaining_arg| {
+                try args.append(remaining_arg);
+            }
+            break;
         } else {
             try args.append(arg);
         }
@@ -430,6 +430,30 @@ test "bash: HISTFILE" {
     }
 }
 
+test "bash: additional arguments" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    // "-" argument separator
+    {
+        const command = try setupBash(alloc, "bash - --arg file1 file2", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix - --arg file1 file2", command.?);
+    }
+
+    // "--" argument separator
+    {
+        const command = try setupBash(alloc, "bash -- --arg file1 file2", ".", &env);
+        defer if (command) |c| alloc.free(c);
+
+        try testing.expectEqualStrings("bash --posix -- --arg file1 file2", command.?);
+    }
+}
+
 /// Setup automatic shell integration for shells that include
 /// their modules from paths in `XDG_DATA_DIRS` env variable.
 ///

commit 0f4d2bb2375c707182dba8cf2dd7723a2e918e79
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 12 09:55:46 2025 -0700

    Lots of 0.14 changes

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 423e2f51..4bbf0a3b 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -82,7 +82,7 @@ fn setupShell(
         // If we're running "/bin/bash" on Darwin, we can assume
         // we're using Apple's Bash because /bin is non-writable
         // on modern macOS due to System Integrity Protection.
-        if (comptime builtin.target.isDarwin()) {
+        if (comptime builtin.target.os.tag.isDarwin()) {
             if (std.mem.eql(u8, "/bin/bash", command)) {
                 return null;
             }
@@ -137,7 +137,7 @@ test "force shell" {
     var env = EnvMap.init(alloc);
     defer env.deinit();
 
-    inline for (@typeInfo(Shell).Enum.fields) |field| {
+    inline for (@typeInfo(Shell).@"enum".fields) |field| {
         const shell = @field(Shell, field.name);
         const result = try setup(alloc, ".", "sh", &env, shell, .{});
         try testing.expectEqual(shell, result.?.shell);

commit 314d52ac3a122b79d8d7db92c356b7ea8e0ed9e5
Author: Jon Parise <jon@indelible.org>
Date:   Sat Mar 22 08:28:56 2025 -0400

    shell-integration: switch to $GHOSTTY_SHELL_FEATURES
    
    This change consolidates all three opt-out shell integration environment
    variables into a single opt-in $GHOSTTY_SHELL_FEATURES variable. Its
    value is a comma-delimited list of the enabled shell feature names (e.g.
    "cursor,title").
    
    $GHOSTTY_SHELL_FEATURES is set at runtime and automatically added to the
    shell environment. Its value is based on the shell-integration-features
    configuration option.
    
    $GHOSTTY_SHELL_FEATURES is only set when at least one shell feature is
    enabled. It won't be set when 'shell-integration-features = false'.
    
    $GHOSTTY_SHELL_FEATURES lists only the enabled shell feature names. We
    could have alternatively gone in the opposite direction and listed the
    disabled features, letting the scripts assume each feature is on by
    default like we did before, but I think this explicit approach is a
    little safer and easier to reason about / debug.
    
    It also doesn't support the "no-" negation prefix used by the config
    system (e.g. "cursor,no-title"). This simplifies the implementation
    requirements of our (multiple) shell integration scripts, and because
    $GHOSTTY_SHELL_FEATURES is derived from shell-integration-features,
    the user-facing configuration interface retains that expressiveness.
    
    $GHOSTTY_SHELL_FEATURES is intended to primarily be an internal concern:
    an interface between the runtime and our shell integration scripts. It
    could be used by people with particular use cases who want to manually
    source those scripts, but that isn't the intended audience.
    
    ... and because the previous $GHOSTTY_SHELL_INTEGRATION_NO_* variables
    were also meant to be an internal concern, this change does not include
    backwards compatibility support for those names.
    
    One last advantage of a using a single $GHOSTTY_SHELL_FEATURES variable
    is that it can be easily forwarded to e.g. ssh sessions or other shell
    environments.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index 4bbf0a3b..d87762db 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -150,9 +150,18 @@ pub fn setupFeatures(
     env: *EnvMap,
     features: config.ShellIntegrationFeatures,
 ) !void {
-    if (!features.cursor) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR", "1");
-    if (!features.sudo) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_SUDO", "1");
-    if (!features.title) try env.put("GHOSTTY_SHELL_INTEGRATION_NO_TITLE", "1");
+    var enabled = try std.BoundedArray(u8, 256).init(0);
+
+    inline for (@typeInfo(@TypeOf(features)).@"struct".fields) |f| {
+        if (@field(features, f.name)) {
+            if (enabled.len > 0) try enabled.append(',');
+            try enabled.appendSlice(f.name);
+        }
+    }
+
+    if (enabled.len > 0) {
+        try env.put("GHOSTTY_SHELL_FEATURES", enabled.slice());
+    }
 }
 
 test "setup features" {
@@ -162,15 +171,13 @@ test "setup features" {
     defer arena.deinit();
     const alloc = arena.allocator();
 
-    // Test: all features enabled (no environment variables should be set)
+    // Test: all features enabled
     {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
         try setupFeatures(&env, .{ .cursor = true, .sudo = true, .title = true });
-        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR") == null);
-        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO") == null);
-        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE") == null);
+        try testing.expectEqualStrings("cursor,sudo,title", env.get("GHOSTTY_SHELL_FEATURES").?);
     }
 
     // Test: all features disabled
@@ -179,9 +186,7 @@ test "setup features" {
         defer env.deinit();
 
         try setupFeatures(&env, .{ .cursor = false, .sudo = false, .title = false });
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR").?);
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO").?);
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE").?);
+        try testing.expect(env.get("GHOSTTY_SHELL_FEATURES") == null);
     }
 
     // Test: mixed features
@@ -190,9 +195,7 @@ test "setup features" {
         defer env.deinit();
 
         try setupFeatures(&env, .{ .cursor = false, .sudo = true, .title = false });
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_CURSOR").?);
-        try testing.expect(env.get("GHOSTTY_SHELL_INTEGRATION_NO_SUDO") == null);
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_SHELL_INTEGRATION_NO_TITLE").?);
+        try testing.expectEqualStrings("sudo", env.get("GHOSTTY_SHELL_FEATURES").?);
     }
 }
 

commit 0caba3e19f6d656e57a74c2d0ea899133305cd5c
Author: Jon Parise <jon@indelible.org>
Date:   Sat Mar 22 15:54:48 2025 -0400

    shell-integration: comptime buffer capacity

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index d87762db..c0235180 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -150,17 +150,23 @@ pub fn setupFeatures(
     env: *EnvMap,
     features: config.ShellIntegrationFeatures,
 ) !void {
-    var enabled = try std.BoundedArray(u8, 256).init(0);
+    const fields = @typeInfo(@TypeOf(features)).@"struct".fields;
+    const capacity: usize = capacity: {
+        comptime var n: usize = fields.len - 1; // commas
+        inline for (fields) |field| n += field.name.len;
+        break :capacity n;
+    };
+    var buffer = try std.BoundedArray(u8, capacity).init(0);
 
-    inline for (@typeInfo(@TypeOf(features)).@"struct".fields) |f| {
-        if (@field(features, f.name)) {
-            if (enabled.len > 0) try enabled.append(',');
-            try enabled.appendSlice(f.name);
+    inline for (fields) |field| {
+        if (@field(features, field.name)) {
+            if (buffer.len > 0) try buffer.append(',');
+            try buffer.appendSlice(field.name);
         }
     }
 
-    if (enabled.len > 0) {
-        try env.put("GHOSTTY_SHELL_FEATURES", enabled.slice());
+    if (buffer.len > 0) {
+        try env.put("GHOSTTY_SHELL_FEATURES", buffer.slice());
     }
 }
 

commit cd6b850758b6c19aa7f081fee24ea6bd8d5296ea
Author: Jon Parise <jon@indelible.org>
Date:   Sat Mar 22 15:57:04 2025 -0400

    shell-integration: minor documentation updates

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index c0235180..ae8d5b67 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -30,7 +30,7 @@ pub const ShellIntegration = struct {
     command: []const u8,
 };
 
-/// Setup the command execution environment for automatic
+/// Set up the command execution environment for automatic
 /// integrated shell integration and return a ShellIntegration
 /// struct describing the integration.  If integration fails
 /// (shell type couldn't be detected, etc.), this will return null.
@@ -144,8 +144,7 @@ test "force shell" {
     }
 }
 
-/// Setup shell integration feature environment variables without
-/// performing full shell integration setup.
+/// Set up the shell integration features environment variable.
 pub fn setupFeatures(
     env: *EnvMap,
     features: config.ShellIntegrationFeatures,

commit 722d41a359d71f251efab9135d1bef5837512352
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Apr 5 11:45:40 2025 -0400

    config: allow commands to specify whether they shell expand or not
    
    This introduces a syntax for `command` and `initial-command` that allows
    the user to specify whether it should be run via `/bin/sh -c` or not.
    The syntax is a prefix `direct:` or `shell:` prior to the command,
    with no prefix implying a default behavior as documented.
    
    Previously, we unconditionally ran commands via `/bin/sh -c`, primarily
    to avoid having to do any shell expansion ourselves. We also leaned on
    it as a crutch for PATH-expansion but this is an easy problem compared
    to shell expansion.
    
    For the principle of least surprise, this worked well for configurations
    specified via the config file, and is still the default. However, these
    configurations are also set via the `-e` special flag to the CLI, and it
    is very much not the principle of least surprise to have the command run via
    `/bin/sh -c` in that scenario since a shell has already expanded all the
    arguments and given them to us in a nice separated format. But we had no
    way to toggle this behavior.
    
    This commit introduces the ability to do this, and changes the defaults
    so that `-e` doesn't shell expand. Further, we also do PATH lookups
    ourselves for the non-shell expanded case because thats easy (using
    execvpe style extensions but implemented as part of the Zig stdlib). We don't
    do path expansion (e.g. `~/`) because thats a shell expansion.
    
    So to be clear, there are no two polar opposite behavioes here with
    clear semantics:
    
      1. Direct commands are passed to `execvpe` directly, space separated.
         This will not handle quoted strings, environment variables, path
         expansion (e.g. `~/`), command expansion (e.g. `$()`), etc.
    
      2. Shell commands are passed to `/bin/sh -c` and will be shell expanded
         as per the shell's rules. This will handle everything that `sh`
         supports.
    
    In doing this work, I also stumbled upon a variety of smaller
    improvements that could be made:
    
      - A number of allocations have been removed from the startup path that
        only existed to add a null terminator to various strings. We now
        have null terminators from the beginning since we are almost always
        on a system that's going to need it anyways.
    
      - For bash shell integration, we no longer wrap the new bash command
        in a shell since we've formed a full parsed command line.
    
      - The process of creating the command to execute by termio is now unit
        tested, so we can test the various complex cases particularly on
        macOS of wrapping commands in the login command.
    
      - `xdg-terminal-exec` on Linux uses the `direct:` method by default
        since it is also assumed to be executed via a shell environment.

diff --git a/src/termio/shell_integration.zig b/src/termio/shell_integration.zig
index ae8d5b67..2cf80969 100644
--- a/src/termio/shell_integration.zig
+++ b/src/termio/shell_integration.zig
@@ -27,7 +27,7 @@ pub const ShellIntegration = struct {
     /// bash in particular it may be different.
     ///
     /// The memory is allocated in the arena given to setup.
-    command: []const u8,
+    command: config.Command,
 };
 
 /// Set up the command execution environment for automatic
@@ -41,7 +41,7 @@ pub const ShellIntegration = struct {
 pub fn setup(
     alloc_arena: Allocator,
     resource_dir: []const u8,
-    command: []const u8,
+    command: config.Command,
     env: *EnvMap,
     force_shell: ?Shell,
     features: config.ShellIntegrationFeatures,
@@ -51,14 +51,24 @@ pub fn setup(
         .elvish => "elvish",
         .fish => "fish",
         .zsh => "zsh",
-    } else exe: {
-        // The command can include arguments. Look for the first space
-        // and use the basename of the first part as the command's exe.
-        const idx = std.mem.indexOfScalar(u8, command, ' ') orelse command.len;
-        break :exe std.fs.path.basename(command[0..idx]);
+    } else switch (command) {
+        .direct => |v| std.fs.path.basename(v[0]),
+        .shell => |v| exe: {
+            // Shell strings can include spaces so we want to only
+            // look up to the space if it exists. No shell that we integrate
+            // has spaces.
+            const idx = std.mem.indexOfScalar(u8, v, ' ') orelse v.len;
+            break :exe std.fs.path.basename(v[0..idx]);
+        },
     };
 
-    const result = try setupShell(alloc_arena, resource_dir, command, env, exe);
+    const result = try setupShell(
+        alloc_arena,
+        resource_dir,
+        command,
+        env,
+        exe,
+    );
 
     // Setup our feature env vars
     try setupFeatures(env, features);
@@ -69,7 +79,7 @@ pub fn setup(
 fn setupShell(
     alloc_arena: Allocator,
     resource_dir: []const u8,
-    command: []const u8,
+    command: config.Command,
     env: *EnvMap,
     exe: []const u8,
 ) !?ShellIntegration {
@@ -83,7 +93,10 @@ fn setupShell(
         // we're using Apple's Bash because /bin is non-writable
         // on modern macOS due to System Integrity Protection.
         if (comptime builtin.target.os.tag.isDarwin()) {
-            if (std.mem.eql(u8, "/bin/bash", command)) {
+            if (std.mem.eql(u8, "/bin/bash", switch (command) {
+                .direct => |v| v[0],
+                .shell => |v| v,
+            })) {
                 return null;
             }
         }
@@ -104,7 +117,7 @@ fn setupShell(
         try setupXdgDataDirs(alloc_arena, resource_dir, env);
         return .{
             .shell = .elvish,
-            .command = try alloc_arena.dupe(u8, command),
+            .command = try command.clone(alloc_arena),
         };
     }
 
@@ -112,7 +125,7 @@ fn setupShell(
         try setupXdgDataDirs(alloc_arena, resource_dir, env);
         return .{
             .shell = .fish,
-            .command = try alloc_arena.dupe(u8, command),
+            .command = try command.clone(alloc_arena),
         };
     }
 
@@ -120,7 +133,7 @@ fn setupShell(
         try setupZsh(resource_dir, env);
         return .{
             .shell = .zsh,
-            .command = try alloc_arena.dupe(u8, command),
+            .command = try command.clone(alloc_arena),
         };
     }
 
@@ -139,7 +152,14 @@ test "force shell" {
 
     inline for (@typeInfo(Shell).@"enum".fields) |field| {
         const shell = @field(Shell, field.name);
-        const result = try setup(alloc, ".", "sh", &env, shell, .{});
+        const result = try setup(
+            alloc,
+            ".",
+            .{ .shell = "sh" },
+            &env,
+            shell,
+            .{},
+        );
         try testing.expectEqual(shell, result.?.shell);
     }
 }
@@ -215,25 +235,21 @@ test "setup features" {
 /// enables the integration or null if integration failed.
 fn setupBash(
     alloc: Allocator,
-    command: []const u8,
+    command: config.Command,
     resource_dir: []const u8,
     env: *EnvMap,
-) !?[]const u8 {
-    // Accumulates the arguments that will form the final shell command line.
-    // We can build this list on the stack because we're just temporarily
-    // referencing other slices, but we can fall back to heap in extreme cases.
-    var args_alloc = std.heap.stackFallback(1024, alloc);
-    var args = try std.ArrayList([]const u8).initCapacity(args_alloc.get(), 2);
+) !?config.Command {
+    var args = try std.ArrayList([:0]const u8).initCapacity(alloc, 2);
     defer args.deinit();
 
     // Iterator that yields each argument in the original command line.
     // This will allocate once proportionate to the command line length.
-    var iter = try std.process.ArgIteratorGeneral(.{}).init(alloc, command);
+    var iter = try command.argIterator(alloc);
     defer iter.deinit();
 
     // Start accumulating arguments with the executable and `--posix` mode flag.
     if (iter.next()) |exe| {
-        try args.append(exe);
+        try args.append(try alloc.dupeZ(u8, exe));
     } else return null;
     try args.append("--posix");
 
@@ -267,17 +283,17 @@ fn setupBash(
             if (std.mem.indexOfScalar(u8, arg, 'c') != null) {
                 return null;
             }
-            try args.append(arg);
+            try args.append(try alloc.dupeZ(u8, arg));
         } else if (std.mem.eql(u8, arg, "-") or std.mem.eql(u8, arg, "--")) {
             // All remaining arguments should be passed directly to the shell
             // command. We shouldn't perform any further option processing.
-            try args.append(arg);
+            try args.append(try alloc.dupeZ(u8, arg));
             while (iter.next()) |remaining_arg| {
-                try args.append(remaining_arg);
+                try args.append(try alloc.dupeZ(u8, remaining_arg));
             }
             break;
         } else {
-            try args.append(arg);
+            try args.append(try alloc.dupeZ(u8, arg));
         }
     }
     try env.put("GHOSTTY_BASH_INJECT", inject.slice());
@@ -310,30 +326,36 @@ fn setupBash(
     );
     try env.put("ENV", integ_dir);
 
-    // Join the accumulated arguments to form the final command string.
-    return try std.mem.join(alloc, " ", args.items);
+    // Since we built up a command line, we don't need to wrap it in
+    // ANOTHER shell anymore and can do a direct command.
+    return .{ .direct = try args.toOwnedSlice() };
 }
 
 test "bash" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     var env = EnvMap.init(alloc);
     defer env.deinit();
 
-    const command = try setupBash(alloc, "bash", ".", &env);
-    defer if (command) |c| alloc.free(c);
+    const command = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
 
-    try testing.expectEqualStrings("bash --posix", command.?);
+    try testing.expectEqual(2, command.?.direct.len);
+    try testing.expectEqualStrings("bash", command.?.direct[0]);
+    try testing.expectEqualStrings("--posix", command.?.direct[1]);
     try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
     try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_INJECT").?);
 }
 
 test "bash: unsupported options" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
-    const cmdlines = [_][]const u8{
+    const cmdlines = [_][:0]const u8{
         "bash --posix",
         "bash --rcfile script.sh --posix",
         "bash --init-file script.sh --posix",
@@ -345,7 +367,7 @@ test "bash: unsupported options" {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        try testing.expect(try setupBash(alloc, cmdline, ".", &env) == null);
+        try testing.expect(try setupBash(alloc, .{ .shell = cmdline }, ".", &env) == null);
         try testing.expect(env.get("GHOSTTY_BASH_INJECT") == null);
         try testing.expect(env.get("GHOSTTY_BASH_RCFILE") == null);
         try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
@@ -354,17 +376,20 @@ test "bash: unsupported options" {
 
 test "bash: inject flags" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     // bash --norc
     {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        const command = try setupBash(alloc, "bash --norc", ".", &env);
-        defer if (command) |c| alloc.free(c);
+        const command = try setupBash(alloc, .{ .shell = "bash --norc" }, ".", &env);
 
-        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqual(2, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
         try testing.expectEqualStrings("1 --norc", env.get("GHOSTTY_BASH_INJECT").?);
     }
 
@@ -373,52 +398,55 @@ test "bash: inject flags" {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        const command = try setupBash(alloc, "bash --noprofile", ".", &env);
-        defer if (command) |c| alloc.free(c);
+        const command = try setupBash(alloc, .{ .shell = "bash --noprofile" }, ".", &env);
 
-        try testing.expectEqualStrings("bash --posix", command.?);
+        try testing.expectEqual(2, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
         try testing.expectEqualStrings("1 --noprofile", env.get("GHOSTTY_BASH_INJECT").?);
     }
 }
 
 test "bash: rcfile" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     var env = EnvMap.init(alloc);
     defer env.deinit();
 
     // bash --rcfile
     {
-        const command = try setupBash(alloc, "bash --rcfile profile.sh", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("bash --posix", command.?);
+        const command = try setupBash(alloc, .{ .shell = "bash --rcfile profile.sh" }, ".", &env);
+        try testing.expectEqual(2, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
         try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
     }
 
     // bash --init-file
     {
-        const command = try setupBash(alloc, "bash --init-file profile.sh", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("bash --posix", command.?);
+        const command = try setupBash(alloc, .{ .shell = "bash --init-file profile.sh" }, ".", &env);
+        try testing.expectEqual(2, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
         try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
     }
 }
 
 test "bash: HISTFILE" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     // HISTFILE unset
     {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        const command = try setupBash(alloc, "bash", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
+        _ = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
         try testing.expect(std.mem.endsWith(u8, env.get("HISTFILE").?, ".bash_history"));
         try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE").?);
     }
@@ -430,9 +458,7 @@ test "bash: HISTFILE" {
 
         try env.put("HISTFILE", "my_history");
 
-        const command = try setupBash(alloc, "bash", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
+        _ = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
         try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
         try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
     }
@@ -440,25 +466,35 @@ test "bash: HISTFILE" {
 
 test "bash: additional arguments" {
     const testing = std.testing;
-    const alloc = testing.allocator;
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
 
     var env = EnvMap.init(alloc);
     defer env.deinit();
 
     // "-" argument separator
     {
-        const command = try setupBash(alloc, "bash - --arg file1 file2", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("bash --posix - --arg file1 file2", command.?);
+        const command = try setupBash(alloc, .{ .shell = "bash - --arg file1 file2" }, ".", &env);
+        try testing.expectEqual(6, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
+        try testing.expectEqualStrings("-", command.?.direct[2]);
+        try testing.expectEqualStrings("--arg", command.?.direct[3]);
+        try testing.expectEqualStrings("file1", command.?.direct[4]);
+        try testing.expectEqualStrings("file2", command.?.direct[5]);
     }
 
     // "--" argument separator
     {
-        const command = try setupBash(alloc, "bash -- --arg file1 file2", ".", &env);
-        defer if (command) |c| alloc.free(c);
-
-        try testing.expectEqualStrings("bash --posix -- --arg file1 file2", command.?);
+        const command = try setupBash(alloc, .{ .shell = "bash -- --arg file1 file2" }, ".", &env);
+        try testing.expectEqual(6, command.?.direct.len);
+        try testing.expectEqualStrings("bash", command.?.direct[0]);
+        try testing.expectEqualStrings("--posix", command.?.direct[1]);
+        try testing.expectEqualStrings("--", command.?.direct[2]);
+        try testing.expectEqualStrings("--arg", command.?.direct[3]);
+        try testing.expectEqualStrings("file1", command.?.direct[4]);
+        try testing.expectEqualStrings("file2", command.?.direct[5]);
     }
 }
 

