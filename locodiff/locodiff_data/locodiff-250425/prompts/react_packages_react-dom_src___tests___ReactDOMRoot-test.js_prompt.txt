# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactDOMRoot-test.js

commit 313611572b6567d229367ed20ff63d1bca8610bb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 19:50:24 2017 +0100

    Reorganize code structure (#11288)
    
    * Move files and tests to more meaningful places
    
    * Fix the build
    
    Now that we import reconciler via react-reconciler, I needed to make a few tweaks.
    
    * Update sizes
    
    * Move @preventMunge directive to FB header
    
    * Revert unintentional change
    
    * Fix Flow coverage
    
    I forgot to @flow-ify those files. This uncovered some issues.
    
    * Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    
    Like a rat in a cage
    Pulling minimum wage
    Prettier, I love you but you're bringing me down
    
    Prettier, you're safer and you're wasting my time
    Our records all show you were filthy but fine
    But they shuttered your stores
    When you opened the doors
    To the cops who were bored once they'd run out of crime
    
    Prettier, you're perfect, oh, please don't change a thing
    Your mild billionaire mayor's now convinced he's a king
    So the boring collect
    I mean all disrespect
    In the neighborhood bars I'd once dreamt I would drink
    
    Prettier, I love you but you're freaking me out
    There's a ton of the twist but we're fresh out of shout
    Like a death in the hall
    That you hear through your wall
    Prettier, I love you but you're freaking me out
    
    Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    Like a death of the heart
    Jesus, where do I start?
    But you're still the one pool where I'd happily drown
    
    And oh! Take me off your mailing list
    For kids who think it still exists
    Yes, for those who think it still exists
    Maybe I'm wrong and maybe you're right
    Maybe I'm wrong and maybe you're right
    Maybe you're right, maybe I'm wrong
    And just maybe you're right
    
    And oh! Maybe mother told you true
    And there'll always be somebody there for you
    And you'll never be alone
    But maybe she's wrong and maybe I'm right
    And just maybe she's wrong
    Maybe she's wrong and maybe I'm right
    And if so, here's this song!

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
new file mode 100644
index 0000000000..c4a327b116
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -0,0 +1,71 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var React = require('react');
+var ReactDOM = require('react-dom');
+var ReactDOMServer = require('react-dom/server');
+
+describe('ReactDOMRoot', () => {
+  let container;
+
+  beforeEach(() => {
+    container = document.createElement('div');
+  });
+
+  it('renders children', () => {
+    const root = ReactDOM.createRoot(container);
+    root.render(<div>Hi</div>);
+    expect(container.textContent).toEqual('Hi');
+  });
+
+  it('unmounts children', () => {
+    const root = ReactDOM.createRoot(container);
+    root.render(<div>Hi</div>);
+    expect(container.textContent).toEqual('Hi');
+    root.unmount();
+    expect(container.textContent).toEqual('');
+  });
+
+  it('supports hydration', async () => {
+    const markup = await new Promise(resolve =>
+      resolve(
+        ReactDOMServer.renderToString(<div><span className="extra" /></div>),
+      ),
+    );
+
+    spyOn(console, 'error');
+
+    // Does not hydrate by default
+    const container1 = document.createElement('div');
+    container1.innerHTML = markup;
+    const root1 = ReactDOM.createRoot(container1);
+    root1.render(<div><span /></div>);
+    expect(console.error.calls.count()).toBe(0);
+
+    // Accepts `hydrate` option
+    const container2 = document.createElement('div');
+    container2.innerHTML = markup;
+    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
+    root2.render(<div><span /></div>);
+    expect(console.error.calls.count()).toBe(1);
+    expect(console.error.calls.argsFor(0)[0]).toMatch('Extra attributes');
+  });
+
+  it('does not clear existing children', async () => {
+    spyOn(console, 'error');
+    container.innerHTML = '<div>a</div><div>b</div>';
+    const root = ReactDOM.createRoot(container);
+    root.render(<div><span>c</span><span>d</span></div>);
+    expect(container.textContent).toEqual('abcd');
+    root.render(<div><span>d</span><span>c</span></div>);
+    expect(container.textContent).toEqual('abdc');
+  });
+});

commit 1e35f2b282a20b41000e6b048fa5a16e147d930b
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Thu Nov 2 15:21:06 2017 -0700

    Put createRoot export under a feature flag (#11426)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c4a327b116..7135445196 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -9,6 +9,7 @@
 
 'use strict';
 
+require('shared/ReactFeatureFlags').enableCreateRoot = true;
 var React = require('react');
 var ReactDOM = require('react-dom');
 var ReactDOMServer = require('react-dom/server');

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 7135445196..d2741bd6d5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -38,7 +38,11 @@ describe('ReactDOMRoot', () => {
   it('supports hydration', async () => {
     const markup = await new Promise(resolve =>
       resolve(
-        ReactDOMServer.renderToString(<div><span className="extra" /></div>),
+        ReactDOMServer.renderToString(
+          <div>
+            <span className="extra" />
+          </div>,
+        ),
       ),
     );
 
@@ -48,14 +52,22 @@ describe('ReactDOMRoot', () => {
     const container1 = document.createElement('div');
     container1.innerHTML = markup;
     const root1 = ReactDOM.createRoot(container1);
-    root1.render(<div><span /></div>);
+    root1.render(
+      <div>
+        <span />
+      </div>,
+    );
     expect(console.error.calls.count()).toBe(0);
 
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
     const root2 = ReactDOM.createRoot(container2, {hydrate: true});
-    root2.render(<div><span /></div>);
+    root2.render(
+      <div>
+        <span />
+      </div>,
+    );
     expect(console.error.calls.count()).toBe(1);
     expect(console.error.calls.argsFor(0)[0]).toMatch('Extra attributes');
   });
@@ -64,9 +76,19 @@ describe('ReactDOMRoot', () => {
     spyOn(console, 'error');
     container.innerHTML = '<div>a</div><div>b</div>';
     const root = ReactDOM.createRoot(container);
-    root.render(<div><span>c</span><span>d</span></div>);
+    root.render(
+      <div>
+        <span>c</span>
+        <span>d</span>
+      </div>,
+    );
     expect(container.textContent).toEqual('abcd');
-    root.render(<div><span>d</span><span>c</span></div>);
+    root.render(
+      <div>
+        <span>d</span>
+        <span>c</span>
+      </div>,
+    );
     expect(container.textContent).toEqual('abdc');
   });
 });

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index d2741bd6d5..1529cf313c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -46,7 +46,7 @@ describe('ReactDOMRoot', () => {
       ),
     );
 
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     // Does not hydrate by default
     const container1 = document.createElement('div');
@@ -57,7 +57,9 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
 
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
@@ -68,12 +70,14 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(console.error.calls.count()).toBe(1);
-    expect(console.error.calls.argsFor(0)[0]).toMatch('Extra attributes');
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toMatch('Extra attributes');
+    }
   });
 
   it('does not clear existing children', async () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     container.innerHTML = '<div>a</div><div>b</div>';
     const root = ReactDOM.createRoot(container);
     root.render(

commit fa7a97fc46935e1611d52da2fdb7d53f6ab9577d
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 23 17:44:58 2017 +0000

    Run 90% of tests on compiled bundles (both development and production) (#11633)
    
    * Extract Jest config into a separate file
    
    * Refactor Jest scripts directory structure
    
    Introduces a more consistent naming scheme.
    
    * Add yarn test-bundles and yarn test-prod-bundles
    
    Only files ending with -test.public.js are opted in (so far we don't have any).
    
    * Fix error decoding for production bundles
    
    GCC seems to remove `new` from `new Error()` which broke our proxy.
    
    * Build production version of react-noop-renderer
    
    This lets us test more bundles.
    
    * Switch to blacklist (exclude .private.js tests)
    
    * Rename tests that are currently broken against bundles to *-test.internal.js
    
    Some of these are using private APIs. Some have other issues.
    
    * Add bundle tests to CI
    
    * Split private and public ReactJSXElementValidator tests
    
    * Remove internal deps from ReactServerRendering-test and make it public
    
    * Only run tests directly in __tests__
    
    This lets us share code between test files by placing them in __tests__/utils.
    
    * Remove ExecutionEnvironment dependency from DOMServerIntegrationTest
    
    It's not necessary since Stack.
    
    * Split up ReactDOMServerIntegration into test suite and utilities
    
    This enables us to further split it down. Good both for parallelization and extracting public parts.
    
    * Split Fragment tests from other DOMServerIntegration tests
    
    This enables them to opt other DOMServerIntegration tests into bundle testing.
    
    * Split ReactDOMServerIntegration into different test files
    
    It was way too slow to run all these in sequence.
    
    * Don't reset the cache twice in DOMServerIntegration tests
    
    We used to do this to simulate testing separate bundles.
    But now we actually *do* test bundles. So there is no need for this, as it makes tests slower.
    
    * Rename test-bundles* commands to test-build*
    
    Also add test-prod-build as alias for test-build-prod because I keep messing them up.
    
    * Use regenerator polyfill for react-noop
    
    This fixes other issues and finally lets us run ReactNoop tests against a prod bundle.
    
    * Run most Incremental tests against bundles
    
    Now that GCC generator issue is fixed, we can do this.
    I split ErrorLogging test separately because it does mocking. Other error handling tests don't need it.
    
    * Update sizes
    
    * Fix ReactMount test
    
    * Enable ReactDOMComponent test
    
    * Fix a warning issue uncovered by flat bundle testing
    
    With flat bundles, we couldn't produce a good warning for <div onclick={}> on SSR
    because it doesn't use the event system. However the issue was not visible in normal
    Jest runs because the event plugins have been injected by the time the test ran.
    
    To solve this, I am explicitly passing whether event system is available as an argument
    to the hook. This makes the behavior consistent between source and bundle tests. Then
    I change the tests to document the actual logic and _attempt_ to show a nice message
    (e.g. we know for sure `onclick` is a bad event but we don't know the right name for it
    on the server so we just say a generic message about camelCase naming convention).

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
deleted file mode 100644
index 1529cf313c..0000000000
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @emails react-core
- */
-
-'use strict';
-
-require('shared/ReactFeatureFlags').enableCreateRoot = true;
-var React = require('react');
-var ReactDOM = require('react-dom');
-var ReactDOMServer = require('react-dom/server');
-
-describe('ReactDOMRoot', () => {
-  let container;
-
-  beforeEach(() => {
-    container = document.createElement('div');
-  });
-
-  it('renders children', () => {
-    const root = ReactDOM.createRoot(container);
-    root.render(<div>Hi</div>);
-    expect(container.textContent).toEqual('Hi');
-  });
-
-  it('unmounts children', () => {
-    const root = ReactDOM.createRoot(container);
-    root.render(<div>Hi</div>);
-    expect(container.textContent).toEqual('Hi');
-    root.unmount();
-    expect(container.textContent).toEqual('');
-  });
-
-  it('supports hydration', async () => {
-    const markup = await new Promise(resolve =>
-      resolve(
-        ReactDOMServer.renderToString(
-          <div>
-            <span className="extra" />
-          </div>,
-        ),
-      ),
-    );
-
-    spyOnDev(console, 'error');
-
-    // Does not hydrate by default
-    const container1 = document.createElement('div');
-    container1.innerHTML = markup;
-    const root1 = ReactDOM.createRoot(container1);
-    root1.render(
-      <div>
-        <span />
-      </div>,
-    );
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-
-    // Accepts `hydrate` option
-    const container2 = document.createElement('div');
-    container2.innerHTML = markup;
-    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
-    root2.render(
-      <div>
-        <span />
-      </div>,
-    );
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toMatch('Extra attributes');
-    }
-  });
-
-  it('does not clear existing children', async () => {
-    spyOnDev(console, 'error');
-    container.innerHTML = '<div>a</div><div>b</div>';
-    const root = ReactDOM.createRoot(container);
-    root.render(
-      <div>
-        <span>c</span>
-        <span>d</span>
-      </div>,
-    );
-    expect(container.textContent).toEqual('abcd');
-    root.render(
-      <div>
-        <span>d</span>
-        <span>c</span>
-      </div>,
-    );
-    expect(container.textContent).toEqual('abdc');
-  });
-});

commit 6294b67a406d21cc6b65162e47497c1e8afe398f
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Mar 29 12:51:34 2018 -0700

    unstable_createRoot (#12487)
    
    * Removed enableCreateRoot flag. Renamed createRoot to unstable_createRoot
    
    * ReactDOMRoot test is no longer internal

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
new file mode 100644
index 0000000000..f7cd755b66
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -0,0 +1,372 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+let React = require('react');
+let ReactDOM = require('react-dom');
+let ReactDOMServer = require('react-dom/server');
+let AsyncMode = React.unstable_AsyncMode;
+
+describe('ReactDOMRoot', () => {
+  let container;
+
+  let scheduledCallback;
+  let flush;
+  let now;
+  let expire;
+
+  beforeEach(() => {
+    container = document.createElement('div');
+
+    // Override requestIdleCallback
+    scheduledCallback = null;
+    flush = function(units = Infinity) {
+      if (scheduledCallback !== null) {
+        let didStop = false;
+        while (scheduledCallback !== null && !didStop) {
+          const cb = scheduledCallback;
+          scheduledCallback = null;
+          cb({
+            timeRemaining() {
+              if (units > 0) {
+                return 999;
+              }
+              didStop = true;
+              return 0;
+            },
+          });
+          units--;
+        }
+      }
+    };
+    global.performance = {
+      now() {
+        return now;
+      },
+    };
+    global.requestIdleCallback = function(cb) {
+      scheduledCallback = cb;
+    };
+
+    now = 0;
+    expire = function(ms) {
+      now += ms;
+    };
+    global.performance = {
+      now() {
+        return now;
+      },
+    };
+
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+    ReactDOMServer = require('react-dom/server');
+    AsyncMode = React.unstable_AsyncMode;
+  });
+
+  it('renders children', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    flush();
+    expect(container.textContent).toEqual('Hi');
+  });
+
+  it('unmounts children', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    flush();
+    expect(container.textContent).toEqual('Hi');
+    root.unmount();
+    flush();
+    expect(container.textContent).toEqual('');
+  });
+
+  it('`root.render` returns a thenable work object', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const work = root.render(<AsyncMode>Hi</AsyncMode>);
+    let ops = [];
+    work.then(() => {
+      ops.push('inside callback: ' + container.textContent);
+    });
+    ops.push('before committing: ' + container.textContent);
+    flush();
+    ops.push('after committing: ' + container.textContent);
+    expect(ops).toEqual([
+      'before committing: ',
+      // `then` callback should fire during commit phase
+      'inside callback: Hi',
+      'after committing: Hi',
+    ]);
+  });
+
+  it('resolves `work.then` callback synchronously if the work already committed', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const work = root.render(<AsyncMode>Hi</AsyncMode>);
+    flush();
+    let ops = [];
+    work.then(() => {
+      ops.push('inside callback');
+    });
+    expect(ops).toEqual(['inside callback']);
+  });
+
+  it('supports hydration', async () => {
+    const markup = await new Promise(resolve =>
+      resolve(
+        ReactDOMServer.renderToString(
+          <div>
+            <span className="extra" />
+          </div>,
+        ),
+      ),
+    );
+
+    // Does not hydrate by default
+    const container1 = document.createElement('div');
+    container1.innerHTML = markup;
+    const root1 = ReactDOM.unstable_createRoot(container1);
+    root1.render(
+      <div>
+        <span />
+      </div>,
+    );
+    flush();
+
+    // Accepts `hydrate` option
+    const container2 = document.createElement('div');
+    container2.innerHTML = markup;
+    const root2 = ReactDOM.unstable_createRoot(container2, {hydrate: true});
+    root2.render(
+      <div>
+        <span />
+      </div>,
+    );
+    expect(flush).toWarnDev('Extra attributes');
+  });
+
+  it('does not clear existing children', async () => {
+    container.innerHTML = '<div>a</div><div>b</div>';
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(
+      <div>
+        <span>c</span>
+        <span>d</span>
+      </div>,
+    );
+    flush();
+    expect(container.textContent).toEqual('abcd');
+    root.render(
+      <div>
+        <span>d</span>
+        <span>c</span>
+      </div>,
+    );
+    flush();
+    expect(container.textContent).toEqual('abdc');
+  });
+
+  it('can defer a commit by batching it', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    batch.render(<div>Hi</div>);
+    // Hasn't committed yet
+    expect(container.textContent).toEqual('');
+    // Commit
+    batch.commit();
+    expect(container.textContent).toEqual('Hi');
+  });
+
+  it('applies setState in componentDidMount synchronously in a batch', done => {
+    class App extends React.Component {
+      state = {mounted: false};
+      componentDidMount() {
+        this.setState({
+          mounted: true,
+        });
+      }
+      render() {
+        return this.state.mounted ? 'Hi' : 'Bye';
+      }
+    }
+
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    batch.render(
+      <AsyncMode>
+        <App />
+      </AsyncMode>,
+    );
+
+    flush();
+
+    // Hasn't updated yet
+    expect(container.textContent).toEqual('');
+
+    let ops = [];
+    batch.then(() => {
+      // Still hasn't updated
+      ops.push(container.textContent);
+
+      // Should synchronously commit
+      batch.commit();
+      ops.push(container.textContent);
+
+      expect(ops).toEqual(['', 'Hi']);
+      done();
+    });
+  });
+
+  it('does not restart a completed batch when committing if there were no intervening updates', () => {
+    let ops = [];
+    function Foo(props) {
+      ops.push('Foo');
+      return props.children;
+    }
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    batch.render(<Foo>Hi</Foo>);
+    // Flush all async work.
+    flush();
+    // Root should complete without committing.
+    expect(ops).toEqual(['Foo']);
+    expect(container.textContent).toEqual('');
+
+    ops = [];
+
+    // Commit. Shouldn't re-render Foo.
+    batch.commit();
+    expect(ops).toEqual([]);
+    expect(container.textContent).toEqual('Hi');
+  });
+
+  it('can wait for a batch to finish', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    batch.render(<AsyncMode>Foo</AsyncMode>);
+
+    flush();
+
+    // Hasn't updated yet
+    expect(container.textContent).toEqual('');
+
+    let ops = [];
+    batch.then(() => {
+      // Still hasn't updated
+      ops.push(container.textContent);
+      // Should synchronously commit
+      batch.commit();
+      ops.push(container.textContent);
+    });
+
+    expect(ops).toEqual(['', 'Foo']);
+  });
+
+  it('`batch.render` returns a thenable work object', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    const work = batch.render('Hi');
+    let ops = [];
+    work.then(() => {
+      ops.push('inside callback: ' + container.textContent);
+    });
+    ops.push('before committing: ' + container.textContent);
+    batch.commit();
+    ops.push('after committing: ' + container.textContent);
+    expect(ops).toEqual([
+      'before committing: ',
+      // `then` callback should fire during commit phase
+      'inside callback: Hi',
+      'after committing: Hi',
+    ]);
+  });
+
+  it('can commit an empty batch', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<AsyncMode>1</AsyncMode>);
+
+    expire(2000);
+    // This batch has a later expiration time than the earlier update.
+    const batch = root.createBatch();
+
+    // This should not flush the earlier update.
+    batch.commit();
+    expect(container.textContent).toEqual('');
+
+    flush();
+    expect(container.textContent).toEqual('1');
+  });
+
+  it('two batches created simultaneously are committed separately', () => {
+    // (In other words, they have distinct expiration times)
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch1 = root.createBatch();
+    batch1.render(1);
+    const batch2 = root.createBatch();
+    batch2.render(2);
+
+    expect(container.textContent).toEqual('');
+
+    batch1.commit();
+    expect(container.textContent).toEqual('1');
+
+    batch2.commit();
+    expect(container.textContent).toEqual('2');
+  });
+
+  it('commits an earlier batch without committing a later batch', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch1 = root.createBatch();
+    batch1.render(1);
+
+    // This batch has a later expiration time
+    expire(2000);
+    const batch2 = root.createBatch();
+    batch2.render(2);
+
+    expect(container.textContent).toEqual('');
+
+    batch1.commit();
+    expect(container.textContent).toEqual('1');
+
+    batch2.commit();
+    expect(container.textContent).toEqual('2');
+  });
+
+  it('commits a later batch without committing an earlier batch', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch1 = root.createBatch();
+    batch1.render(1);
+
+    // This batch has a later expiration time
+    expire(2000);
+    const batch2 = root.createBatch();
+    batch2.render(2);
+
+    expect(container.textContent).toEqual('');
+
+    batch2.commit();
+    expect(container.textContent).toEqual('2');
+
+    batch1.commit();
+    flush();
+    expect(container.textContent).toEqual('1');
+  });
+
+  it('handles fatal errors triggered by batch.commit()', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    const batch = root.createBatch();
+    const InvalidType = undefined;
+    expect(() => batch.render(<InvalidType />)).toWarnDev([
+      'React.createElement: type is invalid',
+    ]);
+    expect(() => batch.commit()).toThrow('Element type is invalid');
+  });
+});

commit b85c5cd1884924d7fe4389121736eaa516ed8e40
Author: Heaven <ne_smalltown@163.com>
Date:   Mon Apr 16 23:36:49 2018 +0800

    remove duplicate code in test (#12620)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index f7cd755b66..f86d3b0e06 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -59,11 +59,6 @@ describe('ReactDOMRoot', () => {
     expire = function(ms) {
       now += ms;
     };
-    global.performance = {
-      now() {
-        return now;
-      },
-    };
 
     jest.resetModules();
     React = require('react');

commit 1e3cd332a015e312149efa36eb81c7523411cc2d
Author: Flarnie Marchan <flarnie@users.noreply.github.com>
Date:   Mon Apr 23 15:25:46 2018 -0700

    Remove the 'alwaysUseRequestIdleCallbackPolyfill' feature flag (#12648)
    
    * Remove the 'alwaysUseRequestIdleCallbackPolyfill' feature flag
    
    **what is the change?:**
    Removes the feature flag 'alwaysUseRequestIdleCallbackPolyfill', such
    that we **always** use the polyfill for requestIdleCallback.
    
    **why make this change?:**
    We have been testing this feature flag at 100% for some time internally,
    and determined it works better for React than the native implementation.
    Looks like RN was overriding the flag to use the native when possible,
    but since no RN products are using 'async' mode it should be safe to
    switch this flag over for RN as well.
    
    **test plan:**
    We have already been testing this internally for some time.
    
    **issue:**
    internal task t28128480
    
    * fix mistaken conditional
    
    * Add mocking of rAF, postMessage, and initial test for ReactScheduler
    
    **what is the change?:**
    - In all tests where we previously mocked rIC or relied on native
    mocking which no longer works, we are now mocking rAF and postMessage.
    - Also adds a basic initial test for ReactScheduler.
    NOTE -> we do plan to write headless browser tests for ReactScheduler!
    This is just an initial test, to verify that it works with the mocked
    out browser APIs as expected.
    
    **why make this change?:**
    We need to mock out the browser APIs more completely for the new
    'ReactScheduler' to work in our tests. Many tests are depending on it,
    since it's used at a low level.
    
    By mocking the browser APIs rather than the 'react-scheduler' module, we
    enable testing the production bundles. This approach is trading
    isolation for accuracy. These tests will be closer to a real use.
    
    **test plan:**
    run the tests :)
    
    **issue:**
    internal task T28128480

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index f86d3b0e06..2255d1cb04 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -17,47 +17,46 @@ let AsyncMode = React.unstable_AsyncMode;
 describe('ReactDOMRoot', () => {
   let container;
 
-  let scheduledCallback;
-  let flush;
-  let now;
-  let expire;
+  let advanceCurrentTime;
 
   beforeEach(() => {
     container = document.createElement('div');
-
-    // Override requestIdleCallback
-    scheduledCallback = null;
-    flush = function(units = Infinity) {
-      if (scheduledCallback !== null) {
-        let didStop = false;
-        while (scheduledCallback !== null && !didStop) {
-          const cb = scheduledCallback;
-          scheduledCallback = null;
-          cb({
-            timeRemaining() {
-              if (units > 0) {
-                return 999;
-              }
-              didStop = true;
-              return 0;
-            },
-          });
-          units--;
-        }
+    // TODO pull this into helper method, reduce repetition.
+    // mock the browser APIs which are used in react-scheduler:
+    // - requestAnimationFrame should pass the DOMHighResTimeStamp argument
+    // - calling 'window.postMessage' should actually fire postmessage handlers
+    // - must allow artificially changing time returned by Date.now
+    // Performance.now is not supported in the test environment
+    const originalDateNow = Date.now;
+    let advancedTime = null;
+    global.Date.now = function() {
+      if (advancedTime) {
+        return originalDateNow() + advancedTime;
       }
+      return originalDateNow();
     };
-    global.performance = {
-      now() {
-        return now;
-      },
+    advanceCurrentTime = function(amount) {
+      advancedTime = amount;
     };
-    global.requestIdleCallback = function(cb) {
-      scheduledCallback = cb;
+    global.requestAnimationFrame = function(cb) {
+      return setTimeout(() => {
+        cb(Date.now());
+      });
     };
-
-    now = 0;
-    expire = function(ms) {
-      now += ms;
+    const originalAddEventListener = global.addEventListener;
+    let postMessageCallback;
+    global.addEventListener = function(eventName, callback, useCapture) {
+      if (eventName === 'message') {
+        postMessageCallback = callback;
+      } else {
+        originalAddEventListener(eventName, callback, useCapture);
+      }
+    };
+    global.postMessage = function(messageKey, targetOrigin) {
+      const postMessageEvent = {source: window, data: messageKey};
+      if (postMessageCallback) {
+        postMessageCallback(postMessageEvent);
+      }
     };
 
     jest.resetModules();
@@ -70,17 +69,17 @@ describe('ReactDOMRoot', () => {
   it('renders children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('Hi');
   });
 
   it('unmounts children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('');
   });
 
@@ -92,7 +91,7 @@ describe('ReactDOMRoot', () => {
       ops.push('inside callback: ' + container.textContent);
     });
     ops.push('before committing: ' + container.textContent);
-    flush();
+    jest.runAllTimers();
     ops.push('after committing: ' + container.textContent);
     expect(ops).toEqual([
       'before committing: ',
@@ -105,7 +104,7 @@ describe('ReactDOMRoot', () => {
   it('resolves `work.then` callback synchronously if the work already committed', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const work = root.render(<AsyncMode>Hi</AsyncMode>);
-    flush();
+    jest.runAllTimers();
     let ops = [];
     work.then(() => {
       ops.push('inside callback');
@@ -133,7 +132,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    flush();
+    jest.runAllTimers();
 
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
@@ -144,7 +143,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(flush).toWarnDev('Extra attributes');
+    expect(jest.runAllTimers).toWarnDev('Extra attributes');
   });
 
   it('does not clear existing children', async () => {
@@ -156,7 +155,7 @@ describe('ReactDOMRoot', () => {
         <span>d</span>
       </div>,
     );
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('abcd');
     root.render(
       <div>
@@ -164,7 +163,7 @@ describe('ReactDOMRoot', () => {
         <span>c</span>
       </div>,
     );
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('abdc');
   });
 
@@ -200,7 +199,7 @@ describe('ReactDOMRoot', () => {
       </AsyncMode>,
     );
 
-    flush();
+    jest.runAllTimers();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -229,7 +228,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<Foo>Hi</Foo>);
     // Flush all async work.
-    flush();
+    jest.runAllTimers();
     // Root should complete without committing.
     expect(ops).toEqual(['Foo']);
     expect(container.textContent).toEqual('');
@@ -247,7 +246,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<AsyncMode>Foo</AsyncMode>);
 
-    flush();
+    jest.runAllTimers();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -287,7 +286,7 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<AsyncMode>1</AsyncMode>);
 
-    expire(2000);
+    advanceCurrentTime(2000);
     // This batch has a later expiration time than the earlier update.
     const batch = root.createBatch();
 
@@ -295,7 +294,7 @@ describe('ReactDOMRoot', () => {
     batch.commit();
     expect(container.textContent).toEqual('');
 
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('1');
   });
 
@@ -322,7 +321,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    expire(2000);
+    advanceCurrentTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -341,7 +340,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    expire(2000);
+    advanceCurrentTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -351,7 +350,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('2');
 
     batch1.commit();
-    flush();
+    jest.runAllTimers();
     expect(container.textContent).toEqual('1');
   });
 

commit 467d1391016dd2df8e1946aa33c6d6e1219c9dbb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 20:20:18 2018 +0100

    Enforce presence or absence of component stack in tests (#13215)
    
    * Enforce presence or absence of stack in tests
    
    * Rename expectNoStack to withoutStack
    
    * Fix lint
    
    * Add some tests for toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 2255d1cb04..deded72130 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -143,7 +143,9 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(jest.runAllTimers).toWarnDev('Extra attributes');
+    expect(jest.runAllTimers).toWarnDev('Extra attributes', {
+      withoutStack: true,
+    });
   });
 
   it('does not clear existing children', async () => {
@@ -358,9 +360,10 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const batch = root.createBatch();
     const InvalidType = undefined;
-    expect(() => batch.render(<InvalidType />)).toWarnDev([
-      'React.createElement: type is invalid',
-    ]);
+    expect(() => batch.render(<InvalidType />)).toWarnDev(
+      ['React.createElement: type is invalid'],
+      {withoutStack: true},
+    );
     expect(() => batch.commit()).toThrow('Element type is invalid');
   });
 });

commit 840cb1a2683dd7c0f3beafd094081d16b636721e
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Jul 27 16:50:20 2018 +0200

    Add an invariant to createRoot() to validate containers (#13279)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index deded72130..1d3bc40748 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -366,4 +366,12 @@ describe('ReactDOMRoot', () => {
     );
     expect(() => batch.commit()).toThrow('Element type is invalid');
   });
+
+  it('throws a good message on invalid containers', () => {
+    expect(() => {
+      ReactDOM.unstable_createRoot(<div>Hi</div>);
+    }).toThrow(
+      'unstable_createRoot(...): Target container is not a DOM element.',
+    );
+  });
 });

commit b92f947af1b5d8804026cb0e1cfa59ead7484ca5
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Mon Sep 3 11:27:50 2018 -0700

    Rename "react-scheduler" package to "schedule" (#13543)
    
    * Git moved packages/react-scheduler -> packages/schedule
    
    * Global find+replace 'react-scheduler' -> 'schedule'
    
    * Global find+replace 'ReactScheduler' -> 'Scheduler'
    
    * Renamed remaining files "ReactScheduler" -> "Schedule"
    
    * Add thank-you note to schedule package README
    
    * Replaced schedule package versions 0.1.0-alpha-1 -> 0.2.0
    
    * Patched our local fixtures to work around Yarn install issue
    
    * Removed some fixture hacks

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 1d3bc40748..8d3662b69f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -22,7 +22,7 @@ describe('ReactDOMRoot', () => {
   beforeEach(() => {
     container = document.createElement('div');
     // TODO pull this into helper method, reduce repetition.
-    // mock the browser APIs which are used in react-scheduler:
+    // mock the browser APIs which are used in schedule:
     // - requestAnimationFrame should pass the DOMHighResTimeStamp argument
     // - calling 'window.postMessage' should actually fire postmessage handlers
     // - must allow artificially changing time returned by Date.now

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: HÃ©ctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 8d3662b69f..9f7801d224 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed Sep 26 17:13:02 2018 +0100

    Rename AsyncMode -> ConcurrentMode (#13732)
    
    * Rename AsyncMode -> ConcurrentMode

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9f7801d224..4157e64b46 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -12,7 +12,7 @@
 let React = require('react');
 let ReactDOM = require('react-dom');
 let ReactDOMServer = require('react-dom/server');
-let AsyncMode = React.unstable_AsyncMode;
+let ConcurrentMode = React.unstable_ConcurrentMode;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -63,7 +63,7 @@ describe('ReactDOMRoot', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMServer = require('react-dom/server');
-    AsyncMode = React.unstable_AsyncMode;
+    ConcurrentMode = React.unstable_ConcurrentMode;
   });
 
   it('renders children', () => {
@@ -85,7 +85,7 @@ describe('ReactDOMRoot', () => {
 
   it('`root.render` returns a thenable work object', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render(<AsyncMode>Hi</AsyncMode>);
+    const work = root.render(<ConcurrentMode>Hi</ConcurrentMode>);
     let ops = [];
     work.then(() => {
       ops.push('inside callback: ' + container.textContent);
@@ -103,7 +103,7 @@ describe('ReactDOMRoot', () => {
 
   it('resolves `work.then` callback synchronously if the work already committed', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render(<AsyncMode>Hi</AsyncMode>);
+    const work = root.render(<ConcurrentMode>Hi</ConcurrentMode>);
     jest.runAllTimers();
     let ops = [];
     work.then(() => {
@@ -196,9 +196,9 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const batch = root.createBatch();
     batch.render(
-      <AsyncMode>
+      <ConcurrentMode>
         <App />
-      </AsyncMode>,
+      </ConcurrentMode>,
     );
 
     jest.runAllTimers();
@@ -246,7 +246,7 @@ describe('ReactDOMRoot', () => {
   it('can wait for a batch to finish', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const batch = root.createBatch();
-    batch.render(<AsyncMode>Foo</AsyncMode>);
+    batch.render(<ConcurrentMode>Foo</ConcurrentMode>);
 
     jest.runAllTimers();
 
@@ -286,7 +286,7 @@ describe('ReactDOMRoot', () => {
 
   it('can commit an empty batch', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    root.render(<AsyncMode>1</AsyncMode>);
+    root.render(<ConcurrentMode>1</ConcurrentMode>);
 
     advanceCurrentTime(2000);
     // This batch has a later expiration time than the earlier update.

commit 17d70df91939b3459813660d90871ae41096d349
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Jan 18 00:20:21 2019 +0000

    Warn when mixing createRoot() and old APIs (#14615)
    
    * Warn when mixing createRoot() and old APIs
    
    * Move container checks to entry points
    
    This way further warning check doesn't crash on bad inputs.
    
    * Fix Flow
    
    * Rename flag to be clearer
    
    * managed by -> passed to
    
    * Revert accidental change
    
    * Fix Fire shim to match

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 4157e64b46..fd6292385b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -374,4 +374,104 @@ describe('ReactDOMRoot', () => {
       'unstable_createRoot(...): Target container is not a DOM element.',
     );
   });
+
+  it('warns when rendering with legacy API into createRoot() container', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    expect(() => {
+      ReactDOM.render(<div>Bye</div>, container);
+    }).toWarnDev(
+      [
+        // We care about this warning:
+        'You are calling ReactDOM.render() on a container that was previously ' +
+          'passed to ReactDOM.unstable_createRoot(). This is not supported. ' +
+          'Did you mean to call root.render(element)?',
+        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
+        'Replacing React-rendered children with a new root component.',
+      ],
+      {withoutStack: true},
+    );
+    jest.runAllTimers();
+    // This works now but we could disallow it:
+    expect(container.textContent).toEqual('Bye');
+  });
+
+  it('warns when hydrating with legacy API into createRoot() container', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    expect(() => {
+      ReactDOM.hydrate(<div>Hi</div>, container);
+    }).toWarnDev(
+      [
+        // We care about this warning:
+        'You are calling ReactDOM.hydrate() on a container that was previously ' +
+          'passed to ReactDOM.unstable_createRoot(). This is not supported. ' +
+          'Did you mean to call root.render(element, {hydrate: true})?',
+        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
+        'Replacing React-rendered children with a new root component.',
+      ],
+      {withoutStack: true},
+    );
+  });
+
+  it('warns when unmounting with legacy API (no previous content)', () => {
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    let unmounted = false;
+    expect(() => {
+      unmounted = ReactDOM.unmountComponentAtNode(container);
+    }).toWarnDev(
+      [
+        // We care about this warning:
+        'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +
+          'passed to ReactDOM.unstable_createRoot(). This is not supported. Did you mean to call root.unmount()?',
+        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
+        "The node you're attempting to unmount was rendered by React and is not a top-level container.",
+      ],
+      {withoutStack: true},
+    );
+    expect(unmounted).toBe(false);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    root.unmount();
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('');
+  });
+
+  it('warns when unmounting with legacy API (has previous content)', () => {
+    // Currently createRoot().render() doesn't clear this.
+    container.appendChild(document.createElement('div'));
+    // The rest is the same as test above.
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<div>Hi</div>);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    let unmounted = false;
+    expect(() => {
+      unmounted = ReactDOM.unmountComponentAtNode(container);
+    }).toWarnDev('Did you mean to call root.unmount()?', {withoutStack: true});
+    expect(unmounted).toBe(false);
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('Hi');
+    root.unmount();
+    jest.runAllTimers();
+    expect(container.textContent).toEqual('');
+  });
+
+  it('warns when passing legacy container to createRoot()', () => {
+    ReactDOM.render(<div>Hi</div>, container);
+    expect(() => {
+      ReactDOM.unstable_createRoot(container);
+    }).toWarnDev(
+      'You are calling ReactDOM.unstable_createRoot() on a container that was previously ' +
+        'passed to ReactDOM.render(). This is not supported.',
+      {withoutStack: true},
+    );
+  });
 });

commit 1d48b4a68485ce870711e6baa98e5c9f5f213fdf
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Sat Feb 9 17:12:11 2019 +0000

    Fix hydration with createRoot warning (#14808)
    
    It's suggesting an API that doesn't exist. Fixed it to reference the actual
    API.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index fd6292385b..3ae0414d3c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -410,7 +410,7 @@ describe('ReactDOMRoot', () => {
         // We care about this warning:
         'You are calling ReactDOM.hydrate() on a container that was previously ' +
           'passed to ReactDOM.unstable_createRoot(). This is not supported. ' +
-          'Did you mean to call root.render(element, {hydrate: true})?',
+          'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
       ],

commit 00748c53e183952696157088a858352cc77b0010
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 26 20:51:17 2019 -0800

    Add new mock build of Scheduler with flush, yield API (#14964)
    
    * Add new mock build of Scheduler with flush, yield API
    
    Test environments need a way to take control of the Scheduler queue and
    incrementally flush work. Our current tests accomplish this either using
    dynamic injection, or by using Jest's fake timers feature. Both of these
    options are fragile and rely too much on implementation details.
    
    In this new approach, we have a separate build of Scheduler that is
    specifically designed for test environments. We mock the default
    implementation like we would any other module; in our case, via Jest.
    This special build has methods like `flushAll` and `yieldValue` that
    control when work is flushed. These methods are based on equivalent
    methods we've been using to write incremental React tests. Eventually
    we may want to migrate the React tests to interact with the mock
    Scheduler directly, instead of going through the host config like we
    currently do.
    
    For now, I'm using our custom static injection infrastructure to create
    the two builds of Scheduler â a default build for DOM (which falls back
    to a naive timer based implementation), and the new mock build. I did it
    this way because it allows me to share most of the implementation, which
    isn't specific to a host environment â e.g. everything related to the
    priority queue. It may be better to duplicate the shared code instead,
    especially considering that future environments (like React Native) may
    have entirely forked implementations. I'd prefer to wait until the
    implementation stabilizes before worrying about that, but I'm open to
    changing this now if we decide it's important enough.
    
    * Mock Scheduler in bundle tests, too
    
    * Remove special case by making regex more restrictive

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 3ae0414d3c..670f45e28b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -12,74 +12,36 @@
 let React = require('react');
 let ReactDOM = require('react-dom');
 let ReactDOMServer = require('react-dom/server');
+let Scheduler = require('scheduler');
 let ConcurrentMode = React.unstable_ConcurrentMode;
 
 describe('ReactDOMRoot', () => {
   let container;
 
-  let advanceCurrentTime;
-
   beforeEach(() => {
-    container = document.createElement('div');
-    // TODO pull this into helper method, reduce repetition.
-    // mock the browser APIs which are used in schedule:
-    // - requestAnimationFrame should pass the DOMHighResTimeStamp argument
-    // - calling 'window.postMessage' should actually fire postmessage handlers
-    // - must allow artificially changing time returned by Date.now
-    // Performance.now is not supported in the test environment
-    const originalDateNow = Date.now;
-    let advancedTime = null;
-    global.Date.now = function() {
-      if (advancedTime) {
-        return originalDateNow() + advancedTime;
-      }
-      return originalDateNow();
-    };
-    advanceCurrentTime = function(amount) {
-      advancedTime = amount;
-    };
-    global.requestAnimationFrame = function(cb) {
-      return setTimeout(() => {
-        cb(Date.now());
-      });
-    };
-    const originalAddEventListener = global.addEventListener;
-    let postMessageCallback;
-    global.addEventListener = function(eventName, callback, useCapture) {
-      if (eventName === 'message') {
-        postMessageCallback = callback;
-      } else {
-        originalAddEventListener(eventName, callback, useCapture);
-      }
-    };
-    global.postMessage = function(messageKey, targetOrigin) {
-      const postMessageEvent = {source: window, data: messageKey};
-      if (postMessageCallback) {
-        postMessageCallback(postMessageEvent);
-      }
-    };
-
     jest.resetModules();
+    container = document.createElement('div');
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMServer = require('react-dom/server');
+    Scheduler = require('scheduler');
     ConcurrentMode = React.unstable_ConcurrentMode;
   });
 
   it('renders children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
   });
 
   it('unmounts children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('');
   });
 
@@ -91,7 +53,7 @@ describe('ReactDOMRoot', () => {
       ops.push('inside callback: ' + container.textContent);
     });
     ops.push('before committing: ' + container.textContent);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     ops.push('after committing: ' + container.textContent);
     expect(ops).toEqual([
       'before committing: ',
@@ -104,7 +66,7 @@ describe('ReactDOMRoot', () => {
   it('resolves `work.then` callback synchronously if the work already committed', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const work = root.render(<ConcurrentMode>Hi</ConcurrentMode>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     let ops = [];
     work.then(() => {
       ops.push('inside callback');
@@ -132,7 +94,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    jest.runAllTimers();
+    Scheduler.flushAll();
 
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
@@ -143,7 +105,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(jest.runAllTimers).toWarnDev('Extra attributes', {
+    expect(() => Scheduler.flushAll()).toWarnDev('Extra attributes', {
       withoutStack: true,
     });
   });
@@ -157,7 +119,7 @@ describe('ReactDOMRoot', () => {
         <span>d</span>
       </div>,
     );
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('abcd');
     root.render(
       <div>
@@ -165,7 +127,7 @@ describe('ReactDOMRoot', () => {
         <span>c</span>
       </div>,
     );
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('abdc');
   });
 
@@ -201,7 +163,7 @@ describe('ReactDOMRoot', () => {
       </ConcurrentMode>,
     );
 
-    jest.runAllTimers();
+    Scheduler.flushAll();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -230,7 +192,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<Foo>Hi</Foo>);
     // Flush all async work.
-    jest.runAllTimers();
+    Scheduler.flushAll();
     // Root should complete without committing.
     expect(ops).toEqual(['Foo']);
     expect(container.textContent).toEqual('');
@@ -248,7 +210,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<ConcurrentMode>Foo</ConcurrentMode>);
 
-    jest.runAllTimers();
+    Scheduler.flushAll();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -288,7 +250,7 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<ConcurrentMode>1</ConcurrentMode>);
 
-    advanceCurrentTime(2000);
+    Scheduler.advanceTime(2000);
     // This batch has a later expiration time than the earlier update.
     const batch = root.createBatch();
 
@@ -296,7 +258,7 @@ describe('ReactDOMRoot', () => {
     batch.commit();
     expect(container.textContent).toEqual('');
 
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('1');
   });
 
@@ -323,7 +285,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    advanceCurrentTime(2000);
+    Scheduler.advanceTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -342,7 +304,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    advanceCurrentTime(2000);
+    Scheduler.advanceTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -352,7 +314,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('2');
 
     batch1.commit();
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('1');
   });
 
@@ -378,7 +340,7 @@ describe('ReactDOMRoot', () => {
   it('warns when rendering with legacy API into createRoot() container', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.render(<div>Bye</div>, container);
@@ -393,7 +355,7 @@ describe('ReactDOMRoot', () => {
       ],
       {withoutStack: true},
     );
-    jest.runAllTimers();
+    Scheduler.flushAll();
     // This works now but we could disallow it:
     expect(container.textContent).toEqual('Bye');
   });
@@ -401,7 +363,7 @@ describe('ReactDOMRoot', () => {
   it('warns when hydrating with legacy API into createRoot() container', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.hydrate(<div>Hi</div>, container);
@@ -421,7 +383,7 @@ describe('ReactDOMRoot', () => {
   it('warns when unmounting with legacy API (no previous content)', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
@@ -437,10 +399,10 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
     expect(unmounted).toBe(false);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('');
   });
 
@@ -450,17 +412,17 @@ describe('ReactDOMRoot', () => {
     // The rest is the same as test above.
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
       unmounted = ReactDOM.unmountComponentAtNode(container);
     }).toWarnDev('Did you mean to call root.unmount()?', {withoutStack: true});
     expect(unmounted).toBe(false);
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    jest.runAllTimers();
+    Scheduler.flushAll();
     expect(container.textContent).toEqual('');
   });
 

commit 83fc258f2914c1a7c14c7b98ee362934576f266b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 13 16:10:00 2019 -0700

    Remove <ConcurrentMode /> (#15532)
    
    Use createSyncRoot instead.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 670f45e28b..095f44f554 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -13,7 +13,6 @@ let React = require('react');
 let ReactDOM = require('react-dom');
 let ReactDOMServer = require('react-dom/server');
 let Scheduler = require('scheduler');
-let ConcurrentMode = React.unstable_ConcurrentMode;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -25,7 +24,6 @@ describe('ReactDOMRoot', () => {
     ReactDOM = require('react-dom');
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
-    ConcurrentMode = React.unstable_ConcurrentMode;
   });
 
   it('renders children', () => {
@@ -47,7 +45,7 @@ describe('ReactDOMRoot', () => {
 
   it('`root.render` returns a thenable work object', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render(<ConcurrentMode>Hi</ConcurrentMode>);
+    const work = root.render('Hi');
     let ops = [];
     work.then(() => {
       ops.push('inside callback: ' + container.textContent);
@@ -65,7 +63,7 @@ describe('ReactDOMRoot', () => {
 
   it('resolves `work.then` callback synchronously if the work already committed', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render(<ConcurrentMode>Hi</ConcurrentMode>);
+    const work = root.render('Hi');
     Scheduler.flushAll();
     let ops = [];
     work.then(() => {
@@ -157,11 +155,7 @@ describe('ReactDOMRoot', () => {
 
     const root = ReactDOM.unstable_createRoot(container);
     const batch = root.createBatch();
-    batch.render(
-      <ConcurrentMode>
-        <App />
-      </ConcurrentMode>,
-    );
+    batch.render(<App />);
 
     Scheduler.flushAll();
 
@@ -208,7 +202,7 @@ describe('ReactDOMRoot', () => {
   it('can wait for a batch to finish', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const batch = root.createBatch();
-    batch.render(<ConcurrentMode>Foo</ConcurrentMode>);
+    batch.render('Foo');
 
     Scheduler.flushAll();
 
@@ -248,7 +242,7 @@ describe('ReactDOMRoot', () => {
 
   it('can commit an empty batch', () => {
     const root = ReactDOM.unstable_createRoot(container);
-    root.render(<ConcurrentMode>1</ConcurrentMode>);
+    root.render(1);
 
     Scheduler.advanceTime(2000);
     // This batch has a later expiration time than the earlier update.

commit 4d307de458dfdf25e704cb2ca20b0578bba8998c
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Jun 26 12:16:08 2019 -0700

    Prefix mock Scheduler APIs with _unstable (#15999)
    
    For now this is only meant to be consumed via `act`.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 095f44f554..75fca79208 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -29,17 +29,17 @@ describe('ReactDOMRoot', () => {
   it('renders children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
   });
 
   it('unmounts children', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('');
   });
 
@@ -51,7 +51,7 @@ describe('ReactDOMRoot', () => {
       ops.push('inside callback: ' + container.textContent);
     });
     ops.push('before committing: ' + container.textContent);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     ops.push('after committing: ' + container.textContent);
     expect(ops).toEqual([
       'before committing: ',
@@ -64,7 +64,7 @@ describe('ReactDOMRoot', () => {
   it('resolves `work.then` callback synchronously if the work already committed', () => {
     const root = ReactDOM.unstable_createRoot(container);
     const work = root.render('Hi');
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     let ops = [];
     work.then(() => {
       ops.push('inside callback');
@@ -92,7 +92,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
 
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
@@ -103,7 +103,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(() => Scheduler.flushAll()).toWarnDev('Extra attributes', {
+    expect(() => Scheduler.unstable_flushAll()).toWarnDev('Extra attributes', {
       withoutStack: true,
     });
   });
@@ -117,7 +117,7 @@ describe('ReactDOMRoot', () => {
         <span>d</span>
       </div>,
     );
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('abcd');
     root.render(
       <div>
@@ -125,7 +125,7 @@ describe('ReactDOMRoot', () => {
         <span>c</span>
       </div>,
     );
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('abdc');
   });
 
@@ -157,7 +157,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<App />);
 
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -186,7 +186,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render(<Foo>Hi</Foo>);
     // Flush all async work.
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     // Root should complete without committing.
     expect(ops).toEqual(['Foo']);
     expect(container.textContent).toEqual('');
@@ -204,7 +204,7 @@ describe('ReactDOMRoot', () => {
     const batch = root.createBatch();
     batch.render('Foo');
 
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
 
     // Hasn't updated yet
     expect(container.textContent).toEqual('');
@@ -244,7 +244,7 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(1);
 
-    Scheduler.advanceTime(2000);
+    Scheduler.unstable_advanceTime(2000);
     // This batch has a later expiration time than the earlier update.
     const batch = root.createBatch();
 
@@ -252,7 +252,7 @@ describe('ReactDOMRoot', () => {
     batch.commit();
     expect(container.textContent).toEqual('');
 
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('1');
   });
 
@@ -279,7 +279,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    Scheduler.advanceTime(2000);
+    Scheduler.unstable_advanceTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -298,7 +298,7 @@ describe('ReactDOMRoot', () => {
     batch1.render(1);
 
     // This batch has a later expiration time
-    Scheduler.advanceTime(2000);
+    Scheduler.unstable_advanceTime(2000);
     const batch2 = root.createBatch();
     batch2.render(2);
 
@@ -308,7 +308,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('2');
 
     batch1.commit();
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('1');
   });
 
@@ -334,7 +334,7 @@ describe('ReactDOMRoot', () => {
   it('warns when rendering with legacy API into createRoot() container', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.render(<div>Bye</div>, container);
@@ -349,7 +349,7 @@ describe('ReactDOMRoot', () => {
       ],
       {withoutStack: true},
     );
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     // This works now but we could disallow it:
     expect(container.textContent).toEqual('Bye');
   });
@@ -357,7 +357,7 @@ describe('ReactDOMRoot', () => {
   it('warns when hydrating with legacy API into createRoot() container', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.hydrate(<div>Hi</div>, container);
@@ -377,7 +377,7 @@ describe('ReactDOMRoot', () => {
   it('warns when unmounting with legacy API (no previous content)', () => {
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
@@ -393,10 +393,10 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
     expect(unmounted).toBe(false);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('');
   });
 
@@ -406,17 +406,17 @@ describe('ReactDOMRoot', () => {
     // The rest is the same as test above.
     const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
       unmounted = ReactDOM.unmountComponentAtNode(container);
     }).toWarnDev('Did you mean to call root.unmount()?', {withoutStack: true});
     expect(unmounted).toBe(false);
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.flushAll();
+    Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('');
   });
 

commit 71d012ecd07baef6f53d02bebd720794f75266ca
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Oct 7 14:15:15 2019 -0700

    Remove dormant createBatch experiment (#17035)
    
    * Remove dormant createBatch experiment
    
    In a hybrid React app with multiple roots, `createBatch` is used to
    coordinate an update to a root with its imperative container.
    
    We've pivoted away from multi-root, hybrid React apps for now to focus
    on single root apps.
    
    This PR removes the API from the codebase. It's possible we'll add back
    some version of this feature in the future.
    
    * Remove unused export

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 75fca79208..532030d0b2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -43,35 +43,6 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('');
   });
 
-  it('`root.render` returns a thenable work object', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render('Hi');
-    let ops = [];
-    work.then(() => {
-      ops.push('inside callback: ' + container.textContent);
-    });
-    ops.push('before committing: ' + container.textContent);
-    Scheduler.unstable_flushAll();
-    ops.push('after committing: ' + container.textContent);
-    expect(ops).toEqual([
-      'before committing: ',
-      // `then` callback should fire during commit phase
-      'inside callback: Hi',
-      'after committing: Hi',
-    ]);
-  });
-
-  it('resolves `work.then` callback synchronously if the work already committed', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const work = root.render('Hi');
-    Scheduler.unstable_flushAll();
-    let ops = [];
-    work.then(() => {
-      ops.push('inside callback');
-    });
-    expect(ops).toEqual(['inside callback']);
-  });
-
   it('supports hydration', async () => {
     const markup = await new Promise(resolve =>
       resolve(
@@ -129,200 +100,6 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('abdc');
   });
 
-  it('can defer a commit by batching it', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    batch.render(<div>Hi</div>);
-    // Hasn't committed yet
-    expect(container.textContent).toEqual('');
-    // Commit
-    batch.commit();
-    expect(container.textContent).toEqual('Hi');
-  });
-
-  it('applies setState in componentDidMount synchronously in a batch', done => {
-    class App extends React.Component {
-      state = {mounted: false};
-      componentDidMount() {
-        this.setState({
-          mounted: true,
-        });
-      }
-      render() {
-        return this.state.mounted ? 'Hi' : 'Bye';
-      }
-    }
-
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    batch.render(<App />);
-
-    Scheduler.unstable_flushAll();
-
-    // Hasn't updated yet
-    expect(container.textContent).toEqual('');
-
-    let ops = [];
-    batch.then(() => {
-      // Still hasn't updated
-      ops.push(container.textContent);
-
-      // Should synchronously commit
-      batch.commit();
-      ops.push(container.textContent);
-
-      expect(ops).toEqual(['', 'Hi']);
-      done();
-    });
-  });
-
-  it('does not restart a completed batch when committing if there were no intervening updates', () => {
-    let ops = [];
-    function Foo(props) {
-      ops.push('Foo');
-      return props.children;
-    }
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    batch.render(<Foo>Hi</Foo>);
-    // Flush all async work.
-    Scheduler.unstable_flushAll();
-    // Root should complete without committing.
-    expect(ops).toEqual(['Foo']);
-    expect(container.textContent).toEqual('');
-
-    ops = [];
-
-    // Commit. Shouldn't re-render Foo.
-    batch.commit();
-    expect(ops).toEqual([]);
-    expect(container.textContent).toEqual('Hi');
-  });
-
-  it('can wait for a batch to finish', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    batch.render('Foo');
-
-    Scheduler.unstable_flushAll();
-
-    // Hasn't updated yet
-    expect(container.textContent).toEqual('');
-
-    let ops = [];
-    batch.then(() => {
-      // Still hasn't updated
-      ops.push(container.textContent);
-      // Should synchronously commit
-      batch.commit();
-      ops.push(container.textContent);
-    });
-
-    expect(ops).toEqual(['', 'Foo']);
-  });
-
-  it('`batch.render` returns a thenable work object', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    const work = batch.render('Hi');
-    let ops = [];
-    work.then(() => {
-      ops.push('inside callback: ' + container.textContent);
-    });
-    ops.push('before committing: ' + container.textContent);
-    batch.commit();
-    ops.push('after committing: ' + container.textContent);
-    expect(ops).toEqual([
-      'before committing: ',
-      // `then` callback should fire during commit phase
-      'inside callback: Hi',
-      'after committing: Hi',
-    ]);
-  });
-
-  it('can commit an empty batch', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    root.render(1);
-
-    Scheduler.unstable_advanceTime(2000);
-    // This batch has a later expiration time than the earlier update.
-    const batch = root.createBatch();
-
-    // This should not flush the earlier update.
-    batch.commit();
-    expect(container.textContent).toEqual('');
-
-    Scheduler.unstable_flushAll();
-    expect(container.textContent).toEqual('1');
-  });
-
-  it('two batches created simultaneously are committed separately', () => {
-    // (In other words, they have distinct expiration times)
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch1 = root.createBatch();
-    batch1.render(1);
-    const batch2 = root.createBatch();
-    batch2.render(2);
-
-    expect(container.textContent).toEqual('');
-
-    batch1.commit();
-    expect(container.textContent).toEqual('1');
-
-    batch2.commit();
-    expect(container.textContent).toEqual('2');
-  });
-
-  it('commits an earlier batch without committing a later batch', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch1 = root.createBatch();
-    batch1.render(1);
-
-    // This batch has a later expiration time
-    Scheduler.unstable_advanceTime(2000);
-    const batch2 = root.createBatch();
-    batch2.render(2);
-
-    expect(container.textContent).toEqual('');
-
-    batch1.commit();
-    expect(container.textContent).toEqual('1');
-
-    batch2.commit();
-    expect(container.textContent).toEqual('2');
-  });
-
-  it('commits a later batch without committing an earlier batch', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch1 = root.createBatch();
-    batch1.render(1);
-
-    // This batch has a later expiration time
-    Scheduler.unstable_advanceTime(2000);
-    const batch2 = root.createBatch();
-    batch2.render(2);
-
-    expect(container.textContent).toEqual('');
-
-    batch2.commit();
-    expect(container.textContent).toEqual('2');
-
-    batch1.commit();
-    Scheduler.unstable_flushAll();
-    expect(container.textContent).toEqual('1');
-  });
-
-  it('handles fatal errors triggered by batch.commit()', () => {
-    const root = ReactDOM.unstable_createRoot(container);
-    const batch = root.createBatch();
-    const InvalidType = undefined;
-    expect(() => batch.render(<InvalidType />)).toWarnDev(
-      ['React.createElement: type is invalid'],
-      {withoutStack: true},
-    );
-    expect(() => batch.commit()).toThrow('Element type is invalid');
-  });
-
   it('throws a good message on invalid containers', () => {
     expect(() => {
       ReactDOM.unstable_createRoot(<div>Hi</div>);

commit d364d8555f0c2c44e8fb624068b9fff30d5908ae
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Oct 14 10:46:42 2019 -0700

    Set up experimental builds (#17071)
    
    * Don't bother including `unstable_` in error
    
    The method names don't get stripped out of the production bundles
    because they are passed as arguments to the error decoder.
    
    Let's just always use the unprefixed APIs in the messages.
    
    * Set up experimental builds
    
    The experimental builds are packaged exactly like builds in the stable
    release channel: same file structure, entry points, and npm package
    names. The goal is to match what will eventually be released in stable
    as closely as possible, but with additional features turned on.
    
    Versioning and Releasing
    ------------------------
    
    The experimental builds will be published to the same registry and
    package names as the stable ones. However, they will be versioned using
    a separate scheme. Instead of semver versions, experimental releases
    will receive arbitrary version strings based on their content hashes.
    The motivation is to thwart attempts to use a version range to match
    against future experimental releases. The only way to install or depend
    on an experimental release is to refer to the specific version number.
    
    Building
    --------
    
    I did not use the existing feature flag infra to configure the
    experimental builds. The reason is because feature flags are designed
    to configure a single package. They're not designed to generate multiple
    forks of the same package; for each set of feature flags, you must
    create a separate package configuration.
    
    Instead, I've added a new build dimension called the **release
    channel**. By default, builds use the **stable** channel. There's
    also an **experimental** release channel. We have the option to add more
    in the future.
    
    There are now two dimensions per artifact: build type (production,
    development, or profiling), and release channel (stable or
    experimental). These are separate dimensions because they are
    combinatorial: there are stable and experimental production builds,
    stable and experimental developmenet builds, and so on.
    
    You can add something to an experimental build by gating on
    `__EXPERIMENTAL__`, similar to how we use `__DEV__`. Anything inside
    these branches will be excluded from the stable builds.
    This gives us a low effort way to add experimental behavior in any
    package without setting up feature flags or configuring a new package.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 532030d0b2..b58ae3508b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -103,9 +103,7 @@ describe('ReactDOMRoot', () => {
   it('throws a good message on invalid containers', () => {
     expect(() => {
       ReactDOM.unstable_createRoot(<div>Hi</div>);
-    }).toThrow(
-      'unstable_createRoot(...): Target container is not a DOM element.',
-    );
+    }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
   it('warns when rendering with legacy API into createRoot() container', () => {
@@ -119,7 +117,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.render() on a container that was previously ' +
-          'passed to ReactDOM.unstable_createRoot(). This is not supported. ' +
+          'passed to ReactDOM.createRoot(). This is not supported. ' +
           'Did you mean to call root.render(element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
@@ -142,7 +140,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.hydrate() on a container that was previously ' +
-          'passed to ReactDOM.unstable_createRoot(). This is not supported. ' +
+          'passed to ReactDOM.createRoot(). This is not supported. ' +
           'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
@@ -163,7 +161,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +
-          'passed to ReactDOM.unstable_createRoot(). This is not supported. Did you mean to call root.unmount()?',
+          'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         "The node you're attempting to unmount was rendered by React and is not a top-level container.",
       ],
@@ -202,7 +200,7 @@ describe('ReactDOMRoot', () => {
     expect(() => {
       ReactDOM.unstable_createRoot(container);
     }).toWarnDev(
-      'You are calling ReactDOM.unstable_createRoot() on a container that was previously ' +
+      'You are calling ReactDOM.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',
       {withoutStack: true},
     );

commit 30c5daf943bd3bed38e464ac79e38f0e8a27426b
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 15 15:09:19 2019 -0700

    Remove concurrent apis from stable (#17088)
    
    * Tests run in experimental mode by default
    
    For local development, you usually want experiments enabled. Unless
    the release channel is set with an environment variable, tests will
    run with __EXPERIMENTAL__ set to `true`.
    
    * Remove concurrent APIs from stable builds
    
    Those who want to try concurrent mode should use the experimental
    builds instead.
    
    I've left the `unstable_` prefixed APIs in the Facebook build so we
    can continue experimenting with them internally without blessing them
    for widespread use.
    
    * Turn on SSR flags in experimental build
    
    * Remove prefixed concurrent APIs from www build
    
    Instead we'll use the experimental builds when syncing to www.
    
    * Remove "canary" from internal React version string

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index b58ae3508b..1b77d32148 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -26,15 +26,22 @@ describe('ReactDOMRoot', () => {
     Scheduler = require('scheduler');
   });
 
+  if (!__EXPERIMENTAL__) {
+    it('createRoot is not exposed in stable build', () => {
+      expect(ReactDOM.createRoot).toBe(undefined);
+    });
+    return;
+  }
+
   it('renders children', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
   });
 
   it('unmounts children', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -57,7 +64,7 @@ describe('ReactDOMRoot', () => {
     // Does not hydrate by default
     const container1 = document.createElement('div');
     container1.innerHTML = markup;
-    const root1 = ReactDOM.unstable_createRoot(container1);
+    const root1 = ReactDOM.createRoot(container1);
     root1.render(
       <div>
         <span />
@@ -68,7 +75,7 @@ describe('ReactDOMRoot', () => {
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
-    const root2 = ReactDOM.unstable_createRoot(container2, {hydrate: true});
+    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
     root2.render(
       <div>
         <span />
@@ -81,7 +88,7 @@ describe('ReactDOMRoot', () => {
 
   it('does not clear existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(
       <div>
         <span>c</span>
@@ -102,12 +109,12 @@ describe('ReactDOMRoot', () => {
 
   it('throws a good message on invalid containers', () => {
     expect(() => {
-      ReactDOM.unstable_createRoot(<div>Hi</div>);
+      ReactDOM.createRoot(<div>Hi</div>);
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
   it('warns when rendering with legacy API into createRoot() container', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -130,7 +137,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when hydrating with legacy API into createRoot() container', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -150,7 +157,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when unmounting with legacy API (no previous content)', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -179,7 +186,7 @@ describe('ReactDOMRoot', () => {
     // Currently createRoot().render() doesn't clear this.
     container.appendChild(document.createElement('div'));
     // The rest is the same as test above.
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -198,7 +205,7 @@ describe('ReactDOMRoot', () => {
   it('warns when passing legacy container to createRoot()', () => {
     ReactDOM.render(<div>Hi</div>, container);
     expect(() => {
-      ReactDOM.unstable_createRoot(container);
+      ReactDOM.createRoot(container);
     }).toWarnDev(
       'You are calling ReactDOM.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',

commit a7b4d51a20a00f0f60b113c3a02326ccf69aef82
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sun Nov 10 00:54:13 2019 +0000

    Warn when doing createRoot twice on the same node (another approach) (#17329)
    
    * Unify fields used for createRoot warning and event system
    
    * Warn when doing createRoot twice on the same node
    
    * Stricter check for modern roots
    
    * Unmark asynchronously
    
    * Fix Flow

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 1b77d32148..6f4efc14f9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -212,4 +212,23 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
   });
+
+  it('warns when creating two roots managing the same container', () => {
+    ReactDOM.createRoot(container);
+    expect(() => {
+      ReactDOM.createRoot(container);
+    }).toWarnDev(
+      'You are calling ReactDOM.createRoot() on a container that ' +
+        'has already been passed to createRoot() before. Instead, call ' +
+        'root.render() on the existing root instead if you want to update it.',
+      {withoutStack: true},
+    );
+  });
+
+  it('does not warn when creating second root after first one is unmounted', () => {
+    const root = ReactDOM.createRoot(container);
+    root.unmount();
+    Scheduler.unstable_flushAll();
+    ReactDOM.createRoot(container); // No warning
+  });
 });

commit b15bf36750ca4c4a5a09f2de76c5315ded1258d0
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 12 23:47:55 2019 +0000

    Add component stacks to (almost) all warnings (#17586)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 6f4efc14f9..bade522f65 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -81,9 +81,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(() => Scheduler.unstable_flushAll()).toWarnDev('Extra attributes', {
-      withoutStack: true,
-    });
+    expect(() => Scheduler.unstable_flushAll()).toWarnDev('Extra attributes');
   });
 
   it('does not clear existing children', async () => {

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index bade522f65..99743902a7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -81,7 +81,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(() => Scheduler.unstable_flushAll()).toWarnDev('Extra attributes');
+    expect(() => Scheduler.unstable_flushAll()).toErrorDev('Extra attributes');
   });
 
   it('does not clear existing children', async () => {
@@ -118,7 +118,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.render(<div>Bye</div>, container);
-    }).toWarnDev(
+    }).toErrorDev(
       [
         // We care about this warning:
         'You are calling ReactDOM.render() on a container that was previously ' +
@@ -141,7 +141,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.hydrate(<div>Hi</div>, container);
-    }).toWarnDev(
+    }).toErrorDev(
       [
         // We care about this warning:
         'You are calling ReactDOM.hydrate() on a container that was previously ' +
@@ -162,7 +162,7 @@ describe('ReactDOMRoot', () => {
     let unmounted = false;
     expect(() => {
       unmounted = ReactDOM.unmountComponentAtNode(container);
-    }).toWarnDev(
+    }).toErrorDev(
       [
         // We care about this warning:
         'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +
@@ -191,7 +191,7 @@ describe('ReactDOMRoot', () => {
     let unmounted = false;
     expect(() => {
       unmounted = ReactDOM.unmountComponentAtNode(container);
-    }).toWarnDev('Did you mean to call root.unmount()?', {withoutStack: true});
+    }).toErrorDev('Did you mean to call root.unmount()?', {withoutStack: true});
     expect(unmounted).toBe(false);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -204,7 +204,7 @@ describe('ReactDOMRoot', () => {
     ReactDOM.render(<div>Hi</div>, container);
     expect(() => {
       ReactDOM.createRoot(container);
-    }).toWarnDev(
+    }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',
       {withoutStack: true},
@@ -215,7 +215,7 @@ describe('ReactDOMRoot', () => {
     ReactDOM.createRoot(container);
     expect(() => {
       ReactDOM.createRoot(container);
-    }).toWarnDev(
+    }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that ' +
         'has already been passed to createRoot() before. Instead, call ' +
         'root.render() on the existing root instead if you want to update it.',

commit e26682a9f3889439765942f1510f280466c3433a
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Jan 27 12:35:08 2020 -0800

    Removed Root API callback params and added warnings (#17916)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 99743902a7..a6bd6c3a33 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -40,6 +40,35 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
   });
 
+  it('warns if a callback parameter is provided to render', () => {
+    const callback = jest.fn();
+    const root = ReactDOM.createRoot(container);
+    expect(() =>
+      root.render(<div>Hi</div>, callback),
+    ).toErrorDev(
+      'render(...): does not support the second callback argument. ' +
+        'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      {withoutStack: true},
+    );
+    Scheduler.unstable_flushAll();
+    expect(callback).not.toHaveBeenCalled();
+  });
+
+  it('warns if a callback parameter is provided to unmount', () => {
+    const callback = jest.fn();
+    const root = ReactDOM.createRoot(container);
+    root.render(<div>Hi</div>);
+    expect(() =>
+      root.unmount(callback),
+    ).toErrorDev(
+      'unmount(...): does not support a callback argument. ' +
+        'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      {withoutStack: true},
+    );
+    Scheduler.unstable_flushAll();
+    expect(callback).not.toHaveBeenCalled();
+  });
+
   it('unmounts children', () => {
     const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);

commit 1662035852519983955c8c3bdab72a0c60b1264b
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Jan 30 17:17:42 2020 +0000

    Ensure createRoot warning parity with ReactDOM.render (#17937)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index a6bd6c3a33..0d842481b0 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -258,4 +258,34 @@ describe('ReactDOMRoot', () => {
     Scheduler.unstable_flushAll();
     ReactDOM.createRoot(container); // No warning
   });
+
+  it('warns if creating a root on the document.body', async () => {
+    expect(() => {
+      ReactDOM.createRoot(document.body);
+    }).toErrorDev(
+      'createRoot(): Creating roots directly with document.body is ' +
+        'discouraged, since its children are often manipulated by third-party ' +
+        'scripts and browser extensions. This may lead to subtle ' +
+        'reconciliation issues. Try using a container element created ' +
+        'for your app.',
+      {withoutStack: true},
+    );
+  });
+
+  it('warns if updating a root that has had its contents removed', async () => {
+    const root = ReactDOM.createRoot(container);
+    root.render(<div>Hi</div>);
+    Scheduler.unstable_flushAll();
+    container.innerHTML = '';
+
+    expect(() => {
+      root.render(<div>Hi</div>);
+    }).toErrorDev(
+      'render(...): It looks like the React-rendered content of the ' +
+        'root container was removed without using React. This is not ' +
+        'supported and will cause errors. Instead, call ' +
+        "root.unmount() to empty a root's container.",
+      {withoutStack: true},
+    );
+  });
 });

commit ea2af878cc3fb139b0e08cf9bc4b2f4178429d69
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Tue Apr 28 13:07:42 2020 -0700

    Root API should clear non-empty roots before mounting (#18730)
    
    * Root API should clear non-empty roots before mounting
    
    Legacy render-into-subtree API removes children from a container before rendering into it. The root API did not do this previously, but just left the children around in the document.
    
    This commit adds a new FiberRoot flag to clear a container's contents before mounting. This is done during the commit phase, to avoid multiple, observable mutations.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 0d842481b0..29acb9ba15 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -113,7 +113,28 @@ describe('ReactDOMRoot', () => {
     expect(() => Scheduler.unstable_flushAll()).toErrorDev('Extra attributes');
   });
 
-  it('does not clear existing children', async () => {
+  it('clears existing children with legacy API', async () => {
+    container.innerHTML = '<div>a</div><div>b</div>';
+    ReactDOM.render(
+      <div>
+        <span>c</span>
+        <span>d</span>
+      </div>,
+      container,
+    );
+    expect(container.textContent).toEqual('cd');
+    ReactDOM.render(
+      <div>
+        <span>d</span>
+        <span>c</span>
+      </div>,
+      container,
+    );
+    Scheduler.unstable_flushAll();
+    expect(container.textContent).toEqual('dc');
+  });
+
+  it('clears existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
     const root = ReactDOM.createRoot(container);
     root.render(
@@ -123,7 +144,7 @@ describe('ReactDOMRoot', () => {
       </div>,
     );
     Scheduler.unstable_flushAll();
-    expect(container.textContent).toEqual('abcd');
+    expect(container.textContent).toEqual('cd');
     root.render(
       <div>
         <span>d</span>
@@ -131,7 +152,7 @@ describe('ReactDOMRoot', () => {
       </div>,
     );
     Scheduler.unstable_flushAll();
-    expect(container.textContent).toEqual('abdc');
+    expect(container.textContent).toEqual('dc');
   });
 
   it('throws a good message on invalid containers', () => {
@@ -220,7 +241,14 @@ describe('ReactDOMRoot', () => {
     let unmounted = false;
     expect(() => {
       unmounted = ReactDOM.unmountComponentAtNode(container);
-    }).toErrorDev('Did you mean to call root.unmount()?', {withoutStack: true});
+    }).toErrorDev(
+      [
+        'Did you mean to call root.unmount()?',
+        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
+        "The node you're attempting to unmount was rendered by React and is not a top-level container.",
+      ],
+      {withoutStack: true},
+    );
     expect(unmounted).toBe(false);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');

commit fe7163e73dadceda2655736d97cdd745d7abc8ea
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 4 22:25:41 2020 -0700

    Add unstable prefix to experimental APIs (#18825)
    
    We've been shipping unprefixed experimental APIs (like `createRoot` and
    `useTransition`) to the Experimental release channel, with the rationale
    that because these APIs do not appear in any stable release, we're free
    to change or remove them later without breaking any downstream projects.
    
    What we didn't consider is that downstream projects might be tempted to
    use feature detection:
    
    ```js
    const useTransition = React.useTransition || fallbackUseTransition;
    ```
    
    This pattern assumes that the version of `useTransition` that exists in
    the Experimental channel today has the same API contract as the final
    `useTransition` API that we'll eventually ship to stable.
    
    To discourage feature detection, I've added an `unstable_` prefix to
    all of our unstable APIs.
    
    The Facebook builds still have the unprefixed APIs, though. We will
    continue to support those; if we make any breaking changes, we'll
    migrate the internal callers like we usually do. To make testing easier,
    I added the `unstable_`-prefixed APIs to the www builds, too. That way
    our tests can always use the prefixed ones without gating on the
    release channel.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 29acb9ba15..25a560c5c3 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -28,13 +28,13 @@ describe('ReactDOMRoot', () => {
 
   if (!__EXPERIMENTAL__) {
     it('createRoot is not exposed in stable build', () => {
-      expect(ReactDOM.createRoot).toBe(undefined);
+      expect(ReactDOM.unstable_createRoot).toBe(undefined);
     });
     return;
   }
 
   it('renders children', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -42,7 +42,7 @@ describe('ReactDOMRoot', () => {
 
   it('warns if a callback parameter is provided to render', () => {
     const callback = jest.fn();
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     expect(() =>
       root.render(<div>Hi</div>, callback),
     ).toErrorDev(
@@ -56,7 +56,7 @@ describe('ReactDOMRoot', () => {
 
   it('warns if a callback parameter is provided to unmount', () => {
     const callback = jest.fn();
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     expect(() =>
       root.unmount(callback),
@@ -70,7 +70,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('unmounts children', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -93,7 +93,7 @@ describe('ReactDOMRoot', () => {
     // Does not hydrate by default
     const container1 = document.createElement('div');
     container1.innerHTML = markup;
-    const root1 = ReactDOM.createRoot(container1);
+    const root1 = ReactDOM.unstable_createRoot(container1);
     root1.render(
       <div>
         <span />
@@ -104,7 +104,7 @@ describe('ReactDOMRoot', () => {
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
-    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
+    const root2 = ReactDOM.unstable_createRoot(container2, {hydrate: true});
     root2.render(
       <div>
         <span />
@@ -136,7 +136,7 @@ describe('ReactDOMRoot', () => {
 
   it('clears existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(
       <div>
         <span>c</span>
@@ -157,12 +157,12 @@ describe('ReactDOMRoot', () => {
 
   it('throws a good message on invalid containers', () => {
     expect(() => {
-      ReactDOM.createRoot(<div>Hi</div>);
+      ReactDOM.unstable_createRoot(<div>Hi</div>);
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
   it('warns when rendering with legacy API into createRoot() container', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -185,7 +185,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when hydrating with legacy API into createRoot() container', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -205,7 +205,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when unmounting with legacy API (no previous content)', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -234,7 +234,7 @@ describe('ReactDOMRoot', () => {
     // Currently createRoot().render() doesn't clear this.
     container.appendChild(document.createElement('div'));
     // The rest is the same as test above.
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -260,7 +260,7 @@ describe('ReactDOMRoot', () => {
   it('warns when passing legacy container to createRoot()', () => {
     ReactDOM.render(<div>Hi</div>, container);
     expect(() => {
-      ReactDOM.createRoot(container);
+      ReactDOM.unstable_createRoot(container);
     }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',
@@ -269,9 +269,9 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when creating two roots managing the same container', () => {
-    ReactDOM.createRoot(container);
+    ReactDOM.unstable_createRoot(container);
     expect(() => {
-      ReactDOM.createRoot(container);
+      ReactDOM.unstable_createRoot(container);
     }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that ' +
         'has already been passed to createRoot() before. Instead, call ' +
@@ -281,15 +281,15 @@ describe('ReactDOMRoot', () => {
   });
 
   it('does not warn when creating second root after first one is unmounted', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.unmount();
     Scheduler.unstable_flushAll();
-    ReactDOM.createRoot(container); // No warning
+    ReactDOM.unstable_createRoot(container); // No warning
   });
 
   it('warns if creating a root on the document.body', async () => {
     expect(() => {
-      ReactDOM.createRoot(document.body);
+      ReactDOM.unstable_createRoot(document.body);
     }).toErrorDev(
       'createRoot(): Creating roots directly with document.body is ' +
         'discouraged, since its children are often manipulated by third-party ' +
@@ -301,7 +301,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns if updating a root that has had its contents removed', async () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     container.innerHTML = '';

commit 9e9dac650535406b25979758a630a78b7c68a22c
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 28 16:09:30 2021 -0400

    Add unstable_concurrentUpdatesByDefault (#21227)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 25a560c5c3..5ffdb38131 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -13,6 +13,7 @@ let React = require('react');
 let ReactDOM = require('react-dom');
 let ReactDOMServer = require('react-dom/server');
 let Scheduler = require('scheduler');
+let act;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -24,6 +25,7 @@ describe('ReactDOMRoot', () => {
     ReactDOM = require('react-dom');
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
+    act = require('react-dom/test-utils').unstable_concurrentAct;
   });
 
   if (!__EXPERIMENTAL__) {
@@ -316,4 +318,37 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
   });
+
+  // @gate experimental
+  it('opts-in to concurrent default updates', async () => {
+    const root = ReactDOM.unstable_createRoot(container, {
+      unstable_concurrentUpdatesByDefault: true,
+    });
+
+    function Foo({value}) {
+      Scheduler.unstable_yieldValue(value);
+      return <div>{value}</div>;
+    }
+
+    await act(async () => {
+      root.render(<Foo value="a" />);
+    });
+
+    expect(container.textContent).toEqual('a');
+
+    await act(async () => {
+      root.render(<Foo value="b" />);
+
+      expect(Scheduler).toHaveYielded(['a']);
+      expect(container.textContent).toEqual('a');
+
+      expect(Scheduler).toFlushAndYieldThrough(['b']);
+      if (gate(flags => flags.allowConcurrentByDefault)) {
+        expect(container.textContent).toEqual('a');
+      } else {
+        expect(container.textContent).toEqual('b');
+      }
+    });
+    expect(container.textContent).toEqual('b');
+  });
 });

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 5ffdb38131..9fe03cc2a9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -28,15 +28,8 @@ describe('ReactDOMRoot', () => {
     act = require('react-dom/test-utils').unstable_concurrentAct;
   });
 
-  if (!__EXPERIMENTAL__) {
-    it('createRoot is not exposed in stable build', () => {
-      expect(ReactDOM.unstable_createRoot).toBe(undefined);
-    });
-    return;
-  }
-
   it('renders children', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -44,7 +37,7 @@ describe('ReactDOMRoot', () => {
 
   it('warns if a callback parameter is provided to render', () => {
     const callback = jest.fn();
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     expect(() =>
       root.render(<div>Hi</div>, callback),
     ).toErrorDev(
@@ -58,7 +51,7 @@ describe('ReactDOMRoot', () => {
 
   it('warns if a callback parameter is provided to unmount', () => {
     const callback = jest.fn();
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     expect(() =>
       root.unmount(callback),
@@ -72,7 +65,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('unmounts children', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -95,7 +88,7 @@ describe('ReactDOMRoot', () => {
     // Does not hydrate by default
     const container1 = document.createElement('div');
     container1.innerHTML = markup;
-    const root1 = ReactDOM.unstable_createRoot(container1);
+    const root1 = ReactDOM.createRoot(container1);
     root1.render(
       <div>
         <span />
@@ -106,7 +99,7 @@ describe('ReactDOMRoot', () => {
     // Accepts `hydrate` option
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
-    const root2 = ReactDOM.unstable_createRoot(container2, {hydrate: true});
+    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
     root2.render(
       <div>
         <span />
@@ -138,7 +131,7 @@ describe('ReactDOMRoot', () => {
 
   it('clears existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(
       <div>
         <span>c</span>
@@ -159,12 +152,12 @@ describe('ReactDOMRoot', () => {
 
   it('throws a good message on invalid containers', () => {
     expect(() => {
-      ReactDOM.unstable_createRoot(<div>Hi</div>);
+      ReactDOM.createRoot(<div>Hi</div>);
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
   it('warns when rendering with legacy API into createRoot() container', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -187,7 +180,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when hydrating with legacy API into createRoot() container', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -207,7 +200,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when unmounting with legacy API (no previous content)', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -236,7 +229,7 @@ describe('ReactDOMRoot', () => {
     // Currently createRoot().render() doesn't clear this.
     container.appendChild(document.createElement('div'));
     // The rest is the same as test above.
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -262,7 +255,7 @@ describe('ReactDOMRoot', () => {
   it('warns when passing legacy container to createRoot()', () => {
     ReactDOM.render(<div>Hi</div>, container);
     expect(() => {
-      ReactDOM.unstable_createRoot(container);
+      ReactDOM.createRoot(container);
     }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',
@@ -271,9 +264,9 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when creating two roots managing the same container', () => {
-    ReactDOM.unstable_createRoot(container);
+    ReactDOM.createRoot(container);
     expect(() => {
-      ReactDOM.unstable_createRoot(container);
+      ReactDOM.createRoot(container);
     }).toErrorDev(
       'You are calling ReactDOM.createRoot() on a container that ' +
         'has already been passed to createRoot() before. Instead, call ' +
@@ -283,15 +276,15 @@ describe('ReactDOMRoot', () => {
   });
 
   it('does not warn when creating second root after first one is unmounted', () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.unmount();
     Scheduler.unstable_flushAll();
-    ReactDOM.unstable_createRoot(container); // No warning
+    ReactDOM.createRoot(container); // No warning
   });
 
   it('warns if creating a root on the document.body', async () => {
     expect(() => {
-      ReactDOM.unstable_createRoot(document.body);
+      ReactDOM.createRoot(document.body);
     }).toErrorDev(
       'createRoot(): Creating roots directly with document.body is ' +
         'discouraged, since its children are often manipulated by third-party ' +
@@ -303,7 +296,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns if updating a root that has had its contents removed', async () => {
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     container.innerHTML = '';
@@ -319,9 +312,8 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  // @gate experimental
   it('opts-in to concurrent default updates', async () => {
-    const root = ReactDOM.unstable_createRoot(container, {
+    const root = ReactDOM.createRoot(container, {
       unstable_concurrentUpdatesByDefault: true,
     });
 

commit 7ec4c55971aad644616ca0b040f42410659fe802
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Jun 15 16:37:53 2021 -0400

    createRoot(..., {hydrate:true}) -> hydrateRoot(...) (#21687)
    
    This adds a new top level API for hydrating a root. It takes the initial
    children as part of its constructor. These are unlike other render calls
    in that they have to represent what the server sent and they can't be
    batched with other updates.
    
    I also changed the options to move the hydrationOptions to the top level
    since now these options are all hydration options.
    
    I kept the createRoot one just temporarily to make it easier to codemod
    internally but I'm doing a follow up to delete.
    
    As part of this I un-dried a couple of paths. ReactDOMLegacy was intended
    to be built on top of the new API but it didn't actually use those root
    APIs because there are special paths. It also doesn't actually use most of
    the commmon paths since all the options are ignored. It also made it hard
    to add only warnings for legacy only or new only code paths.
    
    I also forked the create/hydrate paths because they're subtly different
    since now the options are different. The containers are also different
    because I now error for comment nodes during hydration which just doesn't
    work at all but eventually we'll error for all createRoot calls.
    
    After some iteration it might make sense to break out some common paths but
    for now it's easier to iterate on the duplicates.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9fe03cc2a9..6fb631fb4d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -96,11 +96,10 @@ describe('ReactDOMRoot', () => {
     );
     Scheduler.unstable_flushAll();
 
-    // Accepts `hydrate` option
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
-    const root2 = ReactDOM.createRoot(container2, {hydrate: true});
-    root2.render(
+    ReactDOM.hydrateRoot(
+      container2,
       <div>
         <span />
       </div>,
@@ -191,7 +190,7 @@ describe('ReactDOMRoot', () => {
         // We care about this warning:
         'You are calling ReactDOM.hydrate() on a container that was previously ' +
           'passed to ReactDOM.createRoot(). This is not supported. ' +
-          'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',
+          'Did you mean to call hydrateRoot(container, element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
       ],

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 6fb631fb4d..0c26424097 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -25,7 +25,7 @@ describe('ReactDOMRoot', () => {
     ReactDOM = require('react-dom');
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
-    act = require('react-dom/test-utils').unstable_concurrentAct;
+    act = require('jest-react').act;
   });
 
   it('renders children', () => {

commit d3e0869324267dc62b50ee02f747f5f0a5f5c656
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 27 17:04:39 2021 -0400

    Make root.unmount() synchronous  (#22444)
    
    * Move flushSync warning to React DOM
    
    When you call in `flushSync` from an effect, React fires a warning. I've
    moved the implementation of this warning out of the reconciler and into
    React DOM.
    
    `flushSync` is a renderer API, not an isomorphic API, because it has
    behavior that was designed specifically for the constraints of React
    DOM. The equivalent API in a different renderer may not be the same.
    For example, React Native has a different threading model than the
    browser, so it might not make sense to expose a `flushSync` API to the
    JavaScript thread.
    
    * Make root.unmount() synchronous
    
    When you unmount a root, the internal state that React stores on the
    DOM node is immediately cleared. So, we should also synchronously
    delete the React tree. You should be able to create a new root using
    the same container.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 0c26424097..c13c2805a5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -14,6 +14,7 @@ let ReactDOM = require('react-dom');
 let ReactDOMServer = require('react-dom/server');
 let Scheduler = require('scheduler');
 let act;
+let useEffect;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -26,6 +27,7 @@ describe('ReactDOMRoot', () => {
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
     act = require('jest-react').act;
+    useEffect = React.useEffect;
   });
 
   it('renders children', () => {
@@ -342,4 +344,62 @@ describe('ReactDOMRoot', () => {
     });
     expect(container.textContent).toEqual('b');
   });
+
+  it('unmount is synchronous', async () => {
+    const root = ReactDOM.createRoot(container);
+    await act(async () => {
+      root.render('Hi');
+    });
+    expect(container.textContent).toEqual('Hi');
+
+    await act(async () => {
+      root.unmount();
+      // Should have already unmounted
+      expect(container.textContent).toEqual('');
+    });
+  });
+
+  it('throws if an unmounted root is updated', async () => {
+    const root = ReactDOM.createRoot(container);
+    await act(async () => {
+      root.render('Hi');
+    });
+    expect(container.textContent).toEqual('Hi');
+
+    root.unmount();
+
+    expect(() => root.render("I'm back")).toThrow(
+      'Cannot update an unmounted root.',
+    );
+  });
+
+  it('warns if root is unmounted inside an effect', async () => {
+    const container1 = document.createElement('div');
+    const root1 = ReactDOM.createRoot(container1);
+    const container2 = document.createElement('div');
+    const root2 = ReactDOM.createRoot(container2);
+
+    function App({step}) {
+      useEffect(() => {
+        if (step === 2) {
+          root2.unmount();
+        }
+      }, [step]);
+      return 'Hi';
+    }
+
+    await act(async () => {
+      root1.render(<App step={1} />);
+    });
+    expect(container1.textContent).toEqual('Hi');
+
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root1.render(<App step={2} />);
+      });
+    }).toErrorDev(
+      'Attempted to synchronously unmount a root while React was ' +
+        'already rendering.',
+    );
+  });
 });

commit 54f785bc51800556dead12aaedf9594b2f15e836
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 17 16:44:22 2022 -0500

    Disallow comments as DOM containers for createRoot (#23321)
    
    This is an old feature that we no longer support. `hydrateRoot` already
    throws if you pass a comment node; this change makes `createRoot`
    throw, too.
    
    Still enabled in the Facebook build until we migrate the callers.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c13c2805a5..40c9666835 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -402,4 +402,22 @@ describe('ReactDOMRoot', () => {
         'already rendering.',
     );
   });
+
+  // @gate disableCommentsAsDOMContainers
+  it('errors if container is a comment node', () => {
+    // This is an old feature used by www. Disabled in the open source build.
+    const div = document.createElement('div');
+    div.innerHTML = '<!-- react-mount-point-unstable -->';
+    const commentNode = div.childNodes[0];
+
+    expect(() => ReactDOM.createRoot(commentNode)).toThrow(
+      'createRoot(...): Target container is not a DOM element.',
+    );
+    expect(() => ReactDOM.hydrateRoot(commentNode)).toThrow(
+      'hydrateRoot(...): Target container is not a DOM element.',
+    );
+
+    // Still works in the legacy API
+    ReactDOM.render(<div />, commentNode);
+  });
 });

commit 8c4cd65cfaa4614bac7fd7783b4ec502a337eba3
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 24 10:57:37 2022 -0500

    Add warnings for common root API mistakes (#23356)
    
    For createRoot, a common mistake is to pass JSX as the second argument,
    instead of calling root.render.
    
    For hydrateRoot, a common mistake is to forget to pass children as
    the second argument.
    
    The type system will enforce correct usage, but since not everyone uses
    types we'll log a helpful warning, too.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 40c9666835..c673423f2b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -420,4 +420,27 @@ describe('ReactDOMRoot', () => {
     // Still works in the legacy API
     ReactDOM.render(<div />, commentNode);
   });
+
+  it('warn if no children passed to hydrateRoot', async () => {
+    expect(() =>
+      ReactDOM.hydrateRoot(container),
+    ).toErrorDev(
+      'Must provide initial children as second argument to hydrateRoot.',
+      {withoutStack: true},
+    );
+  });
+
+  it('warn if JSX passed to createRoot', async () => {
+    function App() {
+      return 'Child';
+    }
+
+    expect(() => ReactDOM.createRoot(container, <App />)).toErrorDev(
+      'You passed a JSX element to createRoot. You probably meant to call ' +
+        'root.render instead',
+      {
+        withoutStack: true,
+      },
+    );
+  });
 });

commit 68cb55f262b75f5d5b723104b830daab37b1ea14
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Thu Feb 24 16:31:48 2022 -0500

    Add more warnings for second argument to root.render. (#23358)
    
    We already had one for callbacks but containers is also an easy mistake.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c673423f2b..b39e554e49 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -51,6 +51,37 @@ describe('ReactDOMRoot', () => {
     expect(callback).not.toHaveBeenCalled();
   });
 
+  it('warn if a container is passed to root.render(...)', async () => {
+    function App() {
+      return 'Child';
+    }
+
+    const root = ReactDOM.createRoot(container);
+    expect(() => root.render(<App />, {})).toErrorDev(
+      'You passed a second argument to root.render(...) but it only accepts ' +
+        'one argument.',
+      {
+        withoutStack: true,
+      },
+    );
+  });
+
+  it('warn if a container is passed to root.render(...)', async () => {
+    function App() {
+      return 'Child';
+    }
+
+    const root = ReactDOM.createRoot(container);
+    expect(() => root.render(<App />, container)).toErrorDev(
+      'You passed a container to the second argument of root.render(...). ' +
+        "You don't need to pass it again since you already passed it to create " +
+        'the root.',
+      {
+        withoutStack: true,
+      },
+    );
+  });
+
   it('warns if a callback parameter is provided to unmount', () => {
     const callback = jest.fn();
     const root = ReactDOM.createRoot(container);

commit 17806594cc28284fe195f918e8d77de3516848ec
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Mar 1 00:13:28 2022 -0500

    Move createRoot/hydrateRoot to react-dom/client (#23385)
    
    * Move createRoot/hydrateRoot to /client
    
    We want these APIs ideally to be imported separately from things you
    might use in arbitrary components (like flushSync). Those other methods
    are "isomorphic" to how the ReactDOM tree is rendered. Similar to hooks.
    
    E.g. importing flushSync into a component that only uses it on the client
    should ideally not also pull in the entry client implementation on the
    server.
    
    This also creates a nicer parity with /server where the roots are in a
    separate entry point.
    
    Unfortunately, I can't quite do this yet because we have some legacy APIs
    that we plan on removing (like findDOMNode) and we also haven't implemented
    flushSync using a flag like startTransition does yet.
    
    Another problem is that we currently encourage these APIs to be aliased by
    /profiling (or unstable_testing). In the future you don't have to alias
    them because you can just change your roots to just import those APIs and
    they'll still work with the isomorphic forms. Although we might also just
    use export conditions for them.
    
    For that all to work, I went with a different strategy for now where the
    real API is in / but it comes with a warning if you use it. If you instead
    import /client it disables the warning in a wrapper. That means that if you
    alias / then import /client that will inturn import the alias and it'll
    just work.
    
    In a future breaking changes (likely when we switch to ESM) we can just
    remove createRoot/hydrateRoot from / and move away from the aliasing
    strategy.
    
    * Update tests to import from react-dom/client
    
    * Fix fixtures
    
    * Update warnings
    
    * Add test for the warning
    
    * Update devtools
    
    * Change order of react-dom, react-dom/client alias
    
    I think the order matters here. The first one takes precedence.
    
    * Require react-dom through client so it can be aliased
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index b39e554e49..df693b8784 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -11,6 +11,7 @@
 
 let React = require('react');
 let ReactDOM = require('react-dom');
+let ReactDOMClient = require('react-dom/client');
 let ReactDOMServer = require('react-dom/server');
 let Scheduler = require('scheduler');
 let act;
@@ -24,6 +25,7 @@ describe('ReactDOMRoot', () => {
     container = document.createElement('div');
     React = require('react');
     ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
     act = require('jest-react').act;
@@ -31,15 +33,35 @@ describe('ReactDOMRoot', () => {
   });
 
   it('renders children', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
   });
 
+  it('warns if you import createRoot from react-dom', async () => {
+    expect(() => ReactDOM.createRoot(container)).toErrorDev(
+      'You are importing createRoot from "react-dom" which is not supported. ' +
+        'You should instead import it from "react-dom/client".',
+      {
+        withoutStack: true,
+      },
+    );
+  });
+
+  it('warns if you import hydrateRoot from react-dom', async () => {
+    expect(() => ReactDOM.hydrateRoot(container, null)).toErrorDev(
+      'You are importing hydrateRoot from "react-dom" which is not supported. ' +
+        'You should instead import it from "react-dom/client".',
+      {
+        withoutStack: true,
+      },
+    );
+  });
+
   it('warns if a callback parameter is provided to render', () => {
     const callback = jest.fn();
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     expect(() =>
       root.render(<div>Hi</div>, callback),
     ).toErrorDev(
@@ -56,7 +78,7 @@ describe('ReactDOMRoot', () => {
       return 'Child';
     }
 
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     expect(() => root.render(<App />, {})).toErrorDev(
       'You passed a second argument to root.render(...) but it only accepts ' +
         'one argument.',
@@ -71,7 +93,7 @@ describe('ReactDOMRoot', () => {
       return 'Child';
     }
 
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     expect(() => root.render(<App />, container)).toErrorDev(
       'You passed a container to the second argument of root.render(...). ' +
         "You don't need to pass it again since you already passed it to create " +
@@ -84,7 +106,7 @@ describe('ReactDOMRoot', () => {
 
   it('warns if a callback parameter is provided to unmount', () => {
     const callback = jest.fn();
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     expect(() =>
       root.unmount(callback),
@@ -98,7 +120,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('unmounts children', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -121,7 +143,7 @@ describe('ReactDOMRoot', () => {
     // Does not hydrate by default
     const container1 = document.createElement('div');
     container1.innerHTML = markup;
-    const root1 = ReactDOM.createRoot(container1);
+    const root1 = ReactDOMClient.createRoot(container1);
     root1.render(
       <div>
         <span />
@@ -131,7 +153,7 @@ describe('ReactDOMRoot', () => {
 
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
-    ReactDOM.hydrateRoot(
+    ReactDOMClient.hydrateRoot(
       container2,
       <div>
         <span />
@@ -163,7 +185,7 @@ describe('ReactDOMRoot', () => {
 
   it('clears existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(
       <div>
         <span>c</span>
@@ -184,12 +206,12 @@ describe('ReactDOMRoot', () => {
 
   it('throws a good message on invalid containers', () => {
     expect(() => {
-      ReactDOM.createRoot(<div>Hi</div>);
+      ReactDOMClient.createRoot(<div>Hi</div>);
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
   it('warns when rendering with legacy API into createRoot() container', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -199,7 +221,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.render() on a container that was previously ' +
-          'passed to ReactDOM.createRoot(). This is not supported. ' +
+          'passed to ReactDOMClient.createRoot(). This is not supported. ' +
           'Did you mean to call root.render(element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
@@ -212,7 +234,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when hydrating with legacy API into createRoot() container', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -222,7 +244,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.hydrate() on a container that was previously ' +
-          'passed to ReactDOM.createRoot(). This is not supported. ' +
+          'passed to ReactDOMClient.createRoot(). This is not supported. ' +
           'Did you mean to call hydrateRoot(container, element)?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         'Replacing React-rendered children with a new root component.',
@@ -232,7 +254,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns when unmounting with legacy API (no previous content)', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -243,7 +265,7 @@ describe('ReactDOMRoot', () => {
       [
         // We care about this warning:
         'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +
-          'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?',
+          'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?',
         // This is more of a symptom but restructuring the code to avoid it isn't worth it:
         "The node you're attempting to unmount was rendered by React and is not a top-level container.",
       ],
@@ -261,7 +283,7 @@ describe('ReactDOMRoot', () => {
     // Currently createRoot().render() doesn't clear this.
     container.appendChild(document.createElement('div'));
     // The rest is the same as test above.
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     expect(container.textContent).toEqual('Hi');
@@ -287,20 +309,20 @@ describe('ReactDOMRoot', () => {
   it('warns when passing legacy container to createRoot()', () => {
     ReactDOM.render(<div>Hi</div>, container);
     expect(() => {
-      ReactDOM.createRoot(container);
+      ReactDOMClient.createRoot(container);
     }).toErrorDev(
-      'You are calling ReactDOM.createRoot() on a container that was previously ' +
+      'You are calling ReactDOMClient.createRoot() on a container that was previously ' +
         'passed to ReactDOM.render(). This is not supported.',
       {withoutStack: true},
     );
   });
 
   it('warns when creating two roots managing the same container', () => {
-    ReactDOM.createRoot(container);
+    ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.createRoot(container);
+      ReactDOMClient.createRoot(container);
     }).toErrorDev(
-      'You are calling ReactDOM.createRoot() on a container that ' +
+      'You are calling ReactDOMClient.createRoot() on a container that ' +
         'has already been passed to createRoot() before. Instead, call ' +
         'root.render() on the existing root instead if you want to update it.',
       {withoutStack: true},
@@ -308,15 +330,15 @@ describe('ReactDOMRoot', () => {
   });
 
   it('does not warn when creating second root after first one is unmounted', () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.unmount();
     Scheduler.unstable_flushAll();
-    ReactDOM.createRoot(container); // No warning
+    ReactDOMClient.createRoot(container); // No warning
   });
 
   it('warns if creating a root on the document.body', async () => {
     expect(() => {
-      ReactDOM.createRoot(document.body);
+      ReactDOMClient.createRoot(document.body);
     }).toErrorDev(
       'createRoot(): Creating roots directly with document.body is ' +
         'discouraged, since its children are often manipulated by third-party ' +
@@ -328,7 +350,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns if updating a root that has had its contents removed', async () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     container.innerHTML = '';
@@ -345,7 +367,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('opts-in to concurrent default updates', async () => {
-    const root = ReactDOM.createRoot(container, {
+    const root = ReactDOMClient.createRoot(container, {
       unstable_concurrentUpdatesByDefault: true,
     });
 
@@ -377,7 +399,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('unmount is synchronous', async () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     await act(async () => {
       root.render('Hi');
     });
@@ -391,7 +413,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('throws if an unmounted root is updated', async () => {
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     await act(async () => {
       root.render('Hi');
     });
@@ -406,9 +428,9 @@ describe('ReactDOMRoot', () => {
 
   it('warns if root is unmounted inside an effect', async () => {
     const container1 = document.createElement('div');
-    const root1 = ReactDOM.createRoot(container1);
+    const root1 = ReactDOMClient.createRoot(container1);
     const container2 = document.createElement('div');
-    const root2 = ReactDOM.createRoot(container2);
+    const root2 = ReactDOMClient.createRoot(container2);
 
     function App({step}) {
       useEffect(() => {
@@ -441,10 +463,10 @@ describe('ReactDOMRoot', () => {
     div.innerHTML = '<!-- react-mount-point-unstable -->';
     const commentNode = div.childNodes[0];
 
-    expect(() => ReactDOM.createRoot(commentNode)).toThrow(
+    expect(() => ReactDOMClient.createRoot(commentNode)).toThrow(
       'createRoot(...): Target container is not a DOM element.',
     );
-    expect(() => ReactDOM.hydrateRoot(commentNode)).toThrow(
+    expect(() => ReactDOMClient.hydrateRoot(commentNode)).toThrow(
       'hydrateRoot(...): Target container is not a DOM element.',
     );
 
@@ -454,7 +476,7 @@ describe('ReactDOMRoot', () => {
 
   it('warn if no children passed to hydrateRoot', async () => {
     expect(() =>
-      ReactDOM.hydrateRoot(container),
+      ReactDOMClient.hydrateRoot(container),
     ).toErrorDev(
       'Must provide initial children as second argument to hydrateRoot.',
       {withoutStack: true},
@@ -466,7 +488,7 @@ describe('ReactDOMRoot', () => {
       return 'Child';
     }
 
-    expect(() => ReactDOM.createRoot(container, <App />)).toErrorDev(
+    expect(() => ReactDOMClient.createRoot(container, <App />)).toErrorDev(
       'You passed a JSX element to createRoot. You probably meant to call ' +
         'root.render instead',
       {

commit c8e4789e21f6cb031b92b3bd8a905244bfd808b2
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 4 16:50:29 2022 -0500

    Pass children to hydration root constructor
    
    I already made this change for the concurrent root API in #23309. This
    does the same thing for the legacy API.
    
    Doesn't change any behavior, but I will use this in the next steps.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index df693b8784..9d6a381883 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -253,6 +253,15 @@ describe('ReactDOMRoot', () => {
     );
   });
 
+  it('callback passed to legacy hydrate() API', () => {
+    container.innerHTML = '<div>Hi</div>';
+    ReactDOM.hydrate(<div>Hi</div>, container, () => {
+      Scheduler.unstable_yieldValue('callback');
+    });
+    expect(container.textContent).toEqual('Hi');
+    expect(Scheduler).toHaveYielded(['callback']);
+  });
+
   it('warns when unmounting with legacy API (no previous content)', () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);

commit 832e2987e01aa357c3b2e551acae0682ca36fb14
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 11 21:31:23 2022 -0500

    Revert accdientally merged PR (#24081)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9d6a381883..df693b8784 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -253,15 +253,6 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  it('callback passed to legacy hydrate() API', () => {
-    container.innerHTML = '<div>Hi</div>';
-    ReactDOM.hydrate(<div>Hi</div>, container, () => {
-      Scheduler.unstable_yieldValue('callback');
-    });
-    expect(container.textContent).toEqual('Hi');
-    expect(Scheduler).toHaveYielded(['callback']);
-  });
-
   it('warns when unmounting with legacy API (no previous content)', () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);

commit 2e0d86d22192ff0b13b71b4ad68fea46bf523ef6
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Mar 20 16:18:51 2022 -0400

    Allow updating dehydrated root at lower priority without forcing client render (#24082)
    
    * Pass children to hydration root constructor
    
    I already made this change for the concurrent root API in #23309. This
    does the same thing for the legacy API.
    
    Doesn't change any behavior, but I will use this in the next steps.
    
    * Add isRootDehydrated function
    
    Currently this does nothing except read a boolean field, but I'm about
    to change this logic.
    
    Since this is accessed by React DOM, too, I put the function in a
    separate module that can be deep imported. Previously, it was accessing
    the FiberRoot directly. The reason it's a separate module is to break a
    circular dependency between React DOM and the reconciler.
    
    * Allow updates at lower pri without forcing client render
    
    Currently, if a root is updated before the shell has finished hydrating
    (for example, due to a top-level navigation), we immediately revert to
    client rendering. This is rare because the root is expected is finish
    quickly, but not exceedingly rare because the root may be suspended.
    
    This adds support for updating the root without forcing a client render
    as long as the update has lower priority than the initial hydration,
    i.e. if the update is wrapped in startTransition.
    
    To implement this, I had to do some refactoring. The main idea here is
    to make it closer to how we implement hydration in Suspense boundaries:
    
    - I moved isDehydrated from the shared FiberRoot object to the
    HostRoot's state object.
    - In the begin phase, I check if the root has received an by comparing
    the new children to the initial children. If they are different, we
    revert to client rendering, and set isDehydrated to false using a
    derived state update (a la getDerivedStateFromProps).
    - There are a few places where we used to set root.isDehydrated to false
    as a way to force a client render. Instead, I set the ForceClientRender
    flag on the root work-in-progress fiber.
    - Whenever we fall back to client rendering, I log a recoverable error.
    
    The overall code structure is almost identical to the corresponding
    logic for Suspense components.
    
    The reason this works is because if the update has lower priority than
    the initial hydration, it won't be processed during the hydration
    render, so the children will be the same.
    
    We can go even further and allow updates at _higher_ priority (though
    not sync) by implementing selective hydration at the root, like we do
    for Suspense boundaries: interrupt the current render, attempt hydration
    at slightly higher priority than the update, then continue rendering the
    update. I haven't implemented this yet, but I've structured the code in
    anticipation of adding this later.
    
    * Wrap useMutableSource logic in feature flag

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index df693b8784..9d6a381883 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -253,6 +253,15 @@ describe('ReactDOMRoot', () => {
     );
   });
 
+  it('callback passed to legacy hydrate() API', () => {
+    container.innerHTML = '<div>Hi</div>';
+    ReactDOM.hydrate(<div>Hi</div>, container, () => {
+      Scheduler.unstable_yieldValue('callback');
+    });
+    expect(container.textContent).toEqual('Hi');
+    expect(Scheduler).toHaveYielded(['callback']);
+  });
+
   it('warns when unmounting with legacy API (no previous content)', () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);

commit 796d31809b3683083d3b62ccbab4f00dec8ffb1f
Author: Josh Story <story@hey.com>
Date:   Fri Aug 12 13:27:53 2022 -0700

    Implement basic stylesheet Resources for react-dom (#25060)
    
    Implement basic support for "Resources". In the context of this commit, the only thing that is currently a Resource are
    
    <link rel="stylesheet" precedence="some-value" ...>
    
    Resources can be rendered anywhere in the react tree, even outside of normal parenting rules, for instance you can render a resource before you have rendered the <html><head> tags for your application. In the stream we reorder this so the browser always receives valid HTML and resources are emitted either in place (normal circumstances) or at the top of the <head> (when you render them above or before the <head> in your react tree)
    
    On the client, resources opt into an entirely different hydration path. Instead of matching the location within the Document these resources are queried for in the entire document. It is an error to have more than one resource with the same href attribute.
    
    The use of precedence here as an opt-in signal for resourcifying the link is in preparation for a more complete Resource implementation which will dedupe resource references (multiple will be valid), hoist to the appropriate container (body, head, or elsewhere), order (according to precedence) and Suspend boundaries that depend on them. More details will come in the coming weeks on this plan.
    
    This feature is gated by an experimental flag and will only be made available in experimental builds until some future time.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9d6a381883..0245cebd0a 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -358,6 +358,7 @@ describe('ReactDOMRoot', () => {
     );
   });
 
+  // @gate !__DEV__ || !enableFloat
   it('warns if updating a root that has had its contents removed', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);

commit 2cf4352e1c81a5b8c3528519a128c20e8e65531d
Author: Josh Story <story@hey.com>
Date:   Tue Oct 11 08:42:42 2022 -0700

    Implement HostSingleton Fiber type (#25426)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 0245cebd0a..2b84de3376 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -358,22 +358,27 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  // @gate !__DEV__ || !enableFloat
   it('warns if updating a root that has had its contents removed', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     Scheduler.unstable_flushAll();
     container.innerHTML = '';
 
-    expect(() => {
+    if (gate(flags => flags.enableFloat || flags.enableHostSingletons)) {
+      // When either of these flags are on this validation is turned off so we
+      // expect there to be no warnings
       root.render(<div>Hi</div>);
-    }).toErrorDev(
-      'render(...): It looks like the React-rendered content of the ' +
-        'root container was removed without using React. This is not ' +
-        'supported and will cause errors. Instead, call ' +
-        "root.unmount() to empty a root's container.",
-      {withoutStack: true},
-    );
+    } else {
+      expect(() => {
+        root.render(<div>Hi</div>);
+      }).toErrorDev(
+        'render(...): It looks like the React-rendered content of the ' +
+          'root container was removed without using React. This is not ' +
+          'supported and will cause errors. Instead, call ' +
+          "root.unmount() to empty a root's container.",
+        {withoutStack: true},
+      );
+    }
   });
 
   it('opts-in to concurrent default updates', async () => {

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 2b84de3376..2ae2d30e8b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 2ae2d30e8b..62273e1133 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -62,9 +62,7 @@ describe('ReactDOMRoot', () => {
   it('warns if a callback parameter is provided to render', () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
-    expect(() =>
-      root.render(<div>Hi</div>, callback),
-    ).toErrorDev(
+    expect(() => root.render(<div>Hi</div>, callback)).toErrorDev(
       'render(...): does not support the second callback argument. ' +
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
@@ -108,9 +106,7 @@ describe('ReactDOMRoot', () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    expect(() =>
-      root.unmount(callback),
-    ).toErrorDev(
+    expect(() => root.unmount(callback)).toErrorDev(
       'unmount(...): does not support a callback argument. ' +
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
@@ -490,9 +486,7 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warn if no children passed to hydrateRoot', async () => {
-    expect(() =>
-      ReactDOMClient.hydrateRoot(container),
-    ).toErrorDev(
+    expect(() => ReactDOMClient.hydrateRoot(container)).toErrorDev(
       'Must provide initial children as second argument to hydrateRoot.',
       {withoutStack: true},
     );

commit 6396b664118442f3c2eae7bf13732fcb27bda98f
Author: Josh Story <story@hey.com>
Date:   Thu Feb 9 22:59:29 2023 -0800

    Model Float on Hoistables semantics (#26106)
    
    ## Hoistables
    
    In the original implementation of Float, all hoisted elements were
    treated like Resources. They had deduplication semantics and hydrated
    based on a key. This made certain kinds of hoists very challenging such
    as sequences of meta tags for `og:image:...` metadata. The reason is
    each tag along is not dedupable based on only it's intrinsic properties.
    two identical tags may need to be included and hoisted together with
    preceding meta tags that describe a semantic object with a linear set of
    html nodes.
    
    It was clear that the concept of Browser Resources (stylesheets /
    scripts / preloads) did not extend universally to all hositable tags
    (title, meta, other links, etc...)
    
    Additionally while Resources benefit from deduping they suffer an
    inability to update because while we may have multiple rendered elements
    that refer to a single Resource it isn't unambiguous which element owns
    the props on the underlying resource. We could try merging props, but
    that is still really hard to reason about for authors. Instead we
    restrict Resource semantics to freezing the props at the time the
    Resource is first constructed and warn if you attempt to render the same
    Resource with different props via another rendered element or by
    updating an existing element for that Resource.
    
    This lack of updating restriction is however way more extreme than
    necessary for instances that get hoisted but otherwise do not dedupe;
    where there is a well defined DOM instance for each rendered element. We
    should be able to update props on these instances.
    
    Hoistable is a generalization of what Float tries to model for hoisting.
    Instead of assuming every hoistable element is a Resource we now have
    two distinct categories, hoistable elements and hoistable resources. As
    one might guess the former has semantics that match regular Host
    Components except the placement of the node is usually in the <head>.
    The latter continues to behave how the original implementation of
    HostResource behaved with the first iteration of Float
    
    ### Hoistable Element
    On the server hoistable elements render just like regular tags except
    the output is stored in special queues that can be emitted in the stream
    earlier than they otherwise would be if rendered in place. This also
    allow for instance the ability to render a hoistable before even
    rendering the <html> tag because the queues for hoistable elements won't
    flush until after we have flushed the preamble (`<DOCTYPE
    html><html><head>`).
    
    On the client, hoistable elements largely operate like HostComponents.
    The most notable difference is in the hydration strategy. If we are
    hydrating and encounter a hoistable element we will look for all tags in
    the document that could potentially be a match and we check whether the
    attributes match the props for this particular instance. We also do this
    in the commit phase rather than the render phase. The reason hydration
    can be done for HostComponents in render is the instance will be removed
    from the document if hydration fails so mutating it in render is safe.
    For hoistables the nodes are not in a hydration boundary (Root or
    SuspenseBoundary at time of writing) and thus if hydration fails and we
    may have an instance marked as bound to some Fiber when that Fiber never
    commits. Moving the hydration matching to commit ensures we will always
    succeed in pairing the hoisted DOM instance with a Fiber that has
    committed.
    
    ### Hoistable Resource
    On the server and client the semantics of Resources are largely the same
    they just don't apply to title, meta, and most link tags anymore.
    Resources hoist and dedupe via an `href` key and are ref counted. In a
    future update we will add a garbage collector so we can clean up
    Resources that no longer have any references
    
    ## `<style>` support
    In earlier implementations there was no support for <style> tags. This
    PR adds support for treating `<style href="..."
    precedence="...">...</style>` as a Resource analagous to `<link
    rel="stylesheet" href="..." precedence="..." />`
    
    It may seem odd at first to require an href to get Resource semantics
    for a style tag. The rationale is that these are for inlining of actual
    external stylesheets as an optimization and for URI like scoping of
    inline styles for css-in-js libraries. The href indicates that the key
    space for `<style>` and `<link rel="stylesheet" />` Resources is shared.
    and the precedence is there to allow for interleaving of both kinds of
    Style resources. This is an advanced feature that we do not expect most
    app developers to use directly but will be quite handy for various
    styling libraries and for folks who want to inline as much as possible
    once Fizz supports this feature.
    
    ## refactor notes
    * HostResource Fiber type is renamed HostHoistable to reflect the
    generalization of the concept
    * The Resource object representation is modified to reduce hidden class
    checks and to use less memory overall
    * The thing that distinguishes a resource from an element is whether the
    Fiber has a memoizedState. If it does, it will use resource semantics,
    otherwise element semantics
    * The time complexity of matching hositable elements for hydration
    should be improved

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 62273e1133..9d51ba40c3 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -342,16 +342,21 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns if creating a root on the document.body', async () => {
-    expect(() => {
+    if (gate(flags => flags.enableFloat)) {
+      // we no longer expect an error for this if float is enabled
       ReactDOMClient.createRoot(document.body);
-    }).toErrorDev(
-      'createRoot(): Creating roots directly with document.body is ' +
-        'discouraged, since its children are often manipulated by third-party ' +
-        'scripts and browser extensions. This may lead to subtle ' +
-        'reconciliation issues. Try using a container element created ' +
-        'for your app.',
-      {withoutStack: true},
-    );
+    } else {
+      expect(() => {
+        ReactDOMClient.createRoot(document.body);
+      }).toErrorDev(
+        'createRoot(): Creating roots directly with document.body is ' +
+          'discouraged, since its children are often manipulated by third-party ' +
+          'scripts and browser extensions. This may lead to subtle ' +
+          'reconciliation issues. Try using a container element created ' +
+          'for your app.',
+        {withoutStack: true},
+      );
+    }
   });
 
   it('warns if updating a root that has had its contents removed', async () => {

commit e64a8f4035024ce749bcbcf93b2618e66200a7f7
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 17:02:12 2023 -0500

    Codemod tests to waitFor pattern (3/?) (#26299)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9d51ba40c3..6d1db3fdee 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -16,6 +16,8 @@ let ReactDOMServer = require('react-dom/server');
 let Scheduler = require('scheduler');
 let act;
 let useEffect;
+let assertLog;
+let waitFor;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -30,6 +32,10 @@ describe('ReactDOMRoot', () => {
     Scheduler = require('scheduler');
     act = require('jest-react').act;
     useEffect = React.useEffect;
+
+    const InternalTestUtils = require('internal-test-utils');
+    assertLog = InternalTestUtils.assertLog;
+    waitFor = InternalTestUtils.waitFor;
   });
 
   it('renders children', () => {
@@ -255,7 +261,7 @@ describe('ReactDOMRoot', () => {
       Scheduler.unstable_yieldValue('callback');
     });
     expect(container.textContent).toEqual('Hi');
-    expect(Scheduler).toHaveYielded(['callback']);
+    assertLog(['callback']);
   });
 
   it('warns when unmounting with legacy API (no previous content)', () => {
@@ -401,10 +407,10 @@ describe('ReactDOMRoot', () => {
     await act(async () => {
       root.render(<Foo value="b" />);
 
-      expect(Scheduler).toHaveYielded(['a']);
+      assertLog(['a']);
       expect(container.textContent).toEqual('a');
 
-      expect(Scheduler).toFlushAndYieldThrough(['b']);
+      await waitFor(['b']);
       if (gate(flags => flags.allowConcurrentByDefault)) {
         expect(container.textContent).toEqual('a');
       } else {

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 6d1db3fdee..c8f67f580e 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -258,7 +258,7 @@ describe('ReactDOMRoot', () => {
   it('callback passed to legacy hydrate() API', () => {
     container.innerHTML = '<div>Hi</div>';
     ReactDOM.hydrate(<div>Hi</div>, container, () => {
-      Scheduler.unstable_yieldValue('callback');
+      Scheduler.log('callback');
     });
     expect(container.textContent).toEqual('Hi');
     assertLog(['callback']);
@@ -394,7 +394,7 @@ describe('ReactDOMRoot', () => {
     });
 
     function Foo({value}) {
-      Scheduler.unstable_yieldValue(value);
+      Scheduler.log(value);
       return <div>{value}</div>;
     }
 

commit 44d3807945700de8bb6bdbbf5c4d1ba513303747
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 12:58:31 2023 -0500

    Move internalAct to internal-test-utils package (#26344)
    
    This is not a public API. We only use it for our internal tests, the
    ones in this repo. Let's move it to this private package. Practically
    speaking this will also let us use async/await in the implementation.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c8f67f580e..b81d1cdc30 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -30,7 +30,7 @@ describe('ReactDOMRoot', () => {
     ReactDOMClient = require('react-dom/client');
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
-    act = require('jest-react').act;
+    act = require('internal-test-utils').act;
     useEffect = React.useEffect;
 
     const InternalTestUtils = require('internal-test-utils');

commit 62cd5af08e2ac8b1d4691e75252487083cf7a4aa
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 16:40:23 2023 -0500

    Codemod redundant async act scopes (#26350)
    
    Prior to #26347, our internal `act` API (not the public API) behaved
    differently depending on whether the scope function returned a promise
    (i.e. was an async function), for historical reasons that no longer
    apply. Now that this is fixed, I've codemodded all async act scopes that
    don't contain an await to be sync.
    
    No pressing motivation other than it looks nicer and the codemod was
    easy. Might help avoid confusion for new contributors who see async act
    scopes with nothing async inside and infer it must be like that for a
    reason.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index b81d1cdc30..3352d72c8b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -398,7 +398,7 @@ describe('ReactDOMRoot', () => {
       return <div>{value}</div>;
     }
 
-    await act(async () => {
+    await act(() => {
       root.render(<Foo value="a" />);
     });
 
@@ -422,12 +422,12 @@ describe('ReactDOMRoot', () => {
 
   it('unmount is synchronous', async () => {
     const root = ReactDOMClient.createRoot(container);
-    await act(async () => {
+    await act(() => {
       root.render('Hi');
     });
     expect(container.textContent).toEqual('Hi');
 
-    await act(async () => {
+    await act(() => {
       root.unmount();
       // Should have already unmounted
       expect(container.textContent).toEqual('');
@@ -436,7 +436,7 @@ describe('ReactDOMRoot', () => {
 
   it('throws if an unmounted root is updated', async () => {
     const root = ReactDOMClient.createRoot(container);
-    await act(async () => {
+    await act(() => {
       root.render('Hi');
     });
     expect(container.textContent).toEqual('Hi');
@@ -463,7 +463,7 @@ describe('ReactDOMRoot', () => {
       return 'Hi';
     }
 
-    await act(async () => {
+    await act(() => {
       root1.render(<App step={1} />);
     });
     expect(container1.textContent).toEqual('Hi');

commit a8875eab7f78a453d22370d1061a8bb3cd672b9d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 10 11:06:28 2023 -0500

    Update more tests to not rely on sync queuing (#26358)
    
    This fixes a handful of tests that were accidentally relying on React
    synchronously queuing work in the Scheduler after a setState.
    
    Usually this is because they use a lower level SchedulerMock method
    instead of either `act` or one of the `waitFor` helpers. In some cases,
    the solution is to switch to those APIs. In other cases, if we're
    intentionally testing some lower level behavior, we might have to be a
    bit more clever.
    
    Co-authored-by: Tianyu Yao <skyyao@fb.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 3352d72c8b..c601691c96 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -18,6 +18,7 @@ let act;
 let useEffect;
 let assertLog;
 let waitFor;
+let waitForAll;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -36,12 +37,13 @@ describe('ReactDOMRoot', () => {
     const InternalTestUtils = require('internal-test-utils');
     assertLog = InternalTestUtils.assertLog;
     waitFor = InternalTestUtils.waitFor;
+    waitForAll = InternalTestUtils.waitForAll;
   });
 
-  it('renders children', () => {
+  it('renders children', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
   });
 
@@ -65,7 +67,7 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  it('warns if a callback parameter is provided to render', () => {
+  it('warns if a callback parameter is provided to render', async () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
     expect(() => root.render(<div>Hi</div>, callback)).toErrorDev(
@@ -73,7 +75,7 @@ describe('ReactDOMRoot', () => {
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(callback).not.toHaveBeenCalled();
   });
 
@@ -108,7 +110,7 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  it('warns if a callback parameter is provided to unmount', () => {
+  it('warns if a callback parameter is provided to unmount', async () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
@@ -117,17 +119,17 @@ describe('ReactDOMRoot', () => {
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(callback).not.toHaveBeenCalled();
   });
 
-  it('unmounts children', () => {
+  it('unmounts children', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('');
   });
 
@@ -151,7 +153,7 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
 
     const container2 = document.createElement('div');
     container2.innerHTML = markup;
@@ -161,7 +163,9 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    expect(() => Scheduler.unstable_flushAll()).toErrorDev('Extra attributes');
+    await expect(async () => await waitForAll([])).toErrorDev(
+      'Extra attributes',
+    );
   });
 
   it('clears existing children with legacy API', async () => {
@@ -181,7 +185,7 @@ describe('ReactDOMRoot', () => {
       </div>,
       container,
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('dc');
   });
 
@@ -194,7 +198,7 @@ describe('ReactDOMRoot', () => {
         <span>d</span>
       </div>,
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('cd');
     root.render(
       <div>
@@ -202,7 +206,7 @@ describe('ReactDOMRoot', () => {
         <span>c</span>
       </div>,
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('dc');
   });
 
@@ -212,10 +216,10 @@ describe('ReactDOMRoot', () => {
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
-  it('warns when rendering with legacy API into createRoot() container', () => {
+  it('warns when rendering with legacy API into createRoot() container', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.render(<div>Bye</div>, container);
@@ -230,15 +234,15 @@ describe('ReactDOMRoot', () => {
       ],
       {withoutStack: true},
     );
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     // This works now but we could disallow it:
     expect(container.textContent).toEqual('Bye');
   });
 
-  it('warns when hydrating with legacy API into createRoot() container', () => {
+  it('warns when hydrating with legacy API into createRoot() container', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     expect(() => {
       ReactDOM.hydrate(<div>Hi</div>, container);
@@ -264,10 +268,10 @@ describe('ReactDOMRoot', () => {
     assertLog(['callback']);
   });
 
-  it('warns when unmounting with legacy API (no previous content)', () => {
+  it('warns when unmounting with legacy API (no previous content)', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
@@ -283,20 +287,20 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
     expect(unmounted).toBe(false);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('');
   });
 
-  it('warns when unmounting with legacy API (has previous content)', () => {
+  it('warns when unmounting with legacy API (has previous content)', async () => {
     // Currently createRoot().render() doesn't clear this.
     container.appendChild(document.createElement('div'));
     // The rest is the same as test above.
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     let unmounted = false;
     expect(() => {
@@ -310,10 +314,10 @@ describe('ReactDOMRoot', () => {
       {withoutStack: true},
     );
     expect(unmounted).toBe(false);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('Hi');
     root.unmount();
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     expect(container.textContent).toEqual('');
   });
 
@@ -340,10 +344,10 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  it('does not warn when creating second root after first one is unmounted', () => {
+  it('does not warn when creating second root after first one is unmounted', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.unmount();
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     ReactDOMClient.createRoot(container); // No warning
   });
 
@@ -368,7 +372,7 @@ describe('ReactDOMRoot', () => {
   it('warns if updating a root that has had its contents removed', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    Scheduler.unstable_flushAll();
+    await waitForAll([]);
     container.innerHTML = '';
 
     if (gate(flags => flags.enableFloat || flags.enableHostSingletons)) {

commit 1a65d036ef057b07a6b15f5604e399f91bc5ed73
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Nov 16 17:42:03 2023 -0500

    [cleanup] remove enableHostSingletons feature flag (#27583)
    
    The flag is enabled everywhere, I think we can remove it now.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c601691c96..8a24113526 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -375,7 +375,7 @@ describe('ReactDOMRoot', () => {
     await waitForAll([]);
     container.innerHTML = '';
 
-    if (gate(flags => flags.enableFloat || flags.enableHostSingletons)) {
+    if (gate(flags => flags.enableFloat)) {
       // When either of these flags are on this validation is turned off so we
       // expect there to be no warnings
       root.render(<div>Hi</div>);

commit bf32989264ff2faa9a009550401f573f29db4df2
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Jan 23 10:30:19 2024 +0100

    Convert ReactMountDestruction (partially) to createRoot (#28004)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 8a24113526..f00bb37af1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -133,6 +133,13 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('');
   });
 
+  it('can be immediately unmounted', async () => {
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.unmount();
+    });
+  });
+
   it('supports hydration', async () => {
     const markup = await new Promise(resolve =>
       resolve(
@@ -392,6 +399,18 @@ describe('ReactDOMRoot', () => {
     }
   });
 
+  it('throws if unmounting a root that has had its contents removed', async () => {
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<div>Hi</div>);
+    });
+    container.innerHTML = '';
+
+    expect(() => {
+      root.unmount();
+    }).toThrow('The node to be removed is not a child of this node.');
+  });
+
   it('opts-in to concurrent default updates', async () => {
     const root = ReactDOMClient.createRoot(container, {
       unstable_concurrentUpdatesByDefault: true,

commit 5420c4ea08a4ccf06b04f0c0abdf1f5e8d84223a
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Jan 24 23:55:21 2024 -0500

    Convert ReactMount to createRoot (#28075)
    
    To convert this file, I started replacing all the calls in line, and
    quickly realized that we already have most of these tests covered in
    other files. So I found the test that we didn't already have for
    `create/hydrateRoot` and added them, then renamed `ReactMount` to
    `ReactLegacyMount`.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index f00bb37af1..7967cf84a2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -175,27 +175,6 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  it('clears existing children with legacy API', async () => {
-    container.innerHTML = '<div>a</div><div>b</div>';
-    ReactDOM.render(
-      <div>
-        <span>c</span>
-        <span>d</span>
-      </div>,
-      container,
-    );
-    expect(container.textContent).toEqual('cd');
-    ReactDOM.render(
-      <div>
-        <span>d</span>
-        <span>c</span>
-      </div>,
-      container,
-    );
-    await waitForAll([]);
-    expect(container.textContent).toEqual('dc');
-  });
-
   it('clears existing children', async () => {
     container.innerHTML = '<div>a</div><div>b</div>';
     const root = ReactDOMClient.createRoot(container);
@@ -223,122 +202,6 @@ describe('ReactDOMRoot', () => {
     }).toThrow('createRoot(...): Target container is not a DOM element.');
   });
 
-  it('warns when rendering with legacy API into createRoot() container', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    root.render(<div>Hi</div>);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    expect(() => {
-      ReactDOM.render(<div>Bye</div>, container);
-    }).toErrorDev(
-      [
-        // We care about this warning:
-        'You are calling ReactDOM.render() on a container that was previously ' +
-          'passed to ReactDOMClient.createRoot(). This is not supported. ' +
-          'Did you mean to call root.render(element)?',
-        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
-        'Replacing React-rendered children with a new root component.',
-      ],
-      {withoutStack: true},
-    );
-    await waitForAll([]);
-    // This works now but we could disallow it:
-    expect(container.textContent).toEqual('Bye');
-  });
-
-  it('warns when hydrating with legacy API into createRoot() container', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    root.render(<div>Hi</div>);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    expect(() => {
-      ReactDOM.hydrate(<div>Hi</div>, container);
-    }).toErrorDev(
-      [
-        // We care about this warning:
-        'You are calling ReactDOM.hydrate() on a container that was previously ' +
-          'passed to ReactDOMClient.createRoot(). This is not supported. ' +
-          'Did you mean to call hydrateRoot(container, element)?',
-        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
-        'Replacing React-rendered children with a new root component.',
-      ],
-      {withoutStack: true},
-    );
-  });
-
-  it('callback passed to legacy hydrate() API', () => {
-    container.innerHTML = '<div>Hi</div>';
-    ReactDOM.hydrate(<div>Hi</div>, container, () => {
-      Scheduler.log('callback');
-    });
-    expect(container.textContent).toEqual('Hi');
-    assertLog(['callback']);
-  });
-
-  it('warns when unmounting with legacy API (no previous content)', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    root.render(<div>Hi</div>);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    let unmounted = false;
-    expect(() => {
-      unmounted = ReactDOM.unmountComponentAtNode(container);
-    }).toErrorDev(
-      [
-        // We care about this warning:
-        'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +
-          'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?',
-        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
-        "The node you're attempting to unmount was rendered by React and is not a top-level container.",
-      ],
-      {withoutStack: true},
-    );
-    expect(unmounted).toBe(false);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    root.unmount();
-    await waitForAll([]);
-    expect(container.textContent).toEqual('');
-  });
-
-  it('warns when unmounting with legacy API (has previous content)', async () => {
-    // Currently createRoot().render() doesn't clear this.
-    container.appendChild(document.createElement('div'));
-    // The rest is the same as test above.
-    const root = ReactDOMClient.createRoot(container);
-    root.render(<div>Hi</div>);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    let unmounted = false;
-    expect(() => {
-      unmounted = ReactDOM.unmountComponentAtNode(container);
-    }).toErrorDev(
-      [
-        'Did you mean to call root.unmount()?',
-        // This is more of a symptom but restructuring the code to avoid it isn't worth it:
-        "The node you're attempting to unmount was rendered by React and is not a top-level container.",
-      ],
-      {withoutStack: true},
-    );
-    expect(unmounted).toBe(false);
-    await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
-    root.unmount();
-    await waitForAll([]);
-    expect(container.textContent).toEqual('');
-  });
-
-  it('warns when passing legacy container to createRoot()', () => {
-    ReactDOM.render(<div>Hi</div>, container);
-    expect(() => {
-      ReactDOMClient.createRoot(container);
-    }).toErrorDev(
-      'You are calling ReactDOMClient.createRoot() on a container that was previously ' +
-        'passed to ReactDOM.render(). This is not supported.',
-      {withoutStack: true},
-    );
-  });
-
   it('warns when creating two roots managing the same container', () => {
     ReactDOMClient.createRoot(container);
     expect(() => {
@@ -399,6 +262,80 @@ describe('ReactDOMRoot', () => {
     }
   });
 
+  it('should render different components in same root', async () => {
+    document.body.appendChild(container);
+    const root = ReactDOMClient.createRoot(container);
+
+    await act(() => {
+      root.render(<div />);
+    });
+    expect(container.firstChild.nodeName).toBe('DIV');
+
+    await act(() => {
+      root.render(<span />);
+    });
+    expect(container.firstChild.nodeName).toBe('SPAN');
+  });
+
+  it('should not warn if mounting into non-empty node', async () => {
+    container.innerHTML = '<div></div>';
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<div />);
+    });
+
+    expect(true).toBe(true);
+  });
+
+  it('should reuse markup if rendering to the same target twice', async () => {
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<div />);
+    });
+    const firstElm = container.firstChild;
+    await act(() => {
+      root.render(<div />);
+    });
+
+    expect(firstElm).toBe(container.firstChild);
+  });
+
+  it('should unmount and remount if the key changes', async () => {
+    function Component({text}) {
+      useEffect(() => {
+        Scheduler.log('Mount');
+
+        return () => {
+          Scheduler.log('Unmount');
+        };
+      }, []);
+
+      return <span>{text}</span>;
+    }
+
+    const root = ReactDOMClient.createRoot(container);
+
+    await act(() => {
+      root.render(<Component text="orange" key="A" />);
+    });
+    expect(container.firstChild.innerHTML).toBe('orange');
+    assertLog(['Mount']);
+
+    // If we change the key, the component is unmounted and remounted
+    await act(() => {
+      root.render(<Component text="green" key="B" />);
+    });
+    expect(container.firstChild.innerHTML).toBe('green');
+    assertLog(['Unmount', 'Mount']);
+
+    // But if we don't change the key, the component instance is reused
+    await act(() => {
+      root.render(<Component text="blue" key="B" />);
+    });
+    expect(container.firstChild.innerHTML).toBe('blue');
+    assertLog([]);
+  });
+
   it('throws if unmounting a root that has had its contents removed', async () => {
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
@@ -514,9 +451,6 @@ describe('ReactDOMRoot', () => {
     expect(() => ReactDOMClient.hydrateRoot(commentNode)).toThrow(
       'hydrateRoot(...): Target container is not a DOM element.',
     );
-
-    // Still works in the legacy API
-    ReactDOM.render(<div />, commentNode);
   });
 
   it('warn if no children passed to hydrateRoot', async () => {
@@ -539,4 +473,23 @@ describe('ReactDOMRoot', () => {
       },
     );
   });
+
+  it('warns when given a function', () => {
+    function Component() {
+      return <div />;
+    }
+
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(Component);
+      });
+    }).toErrorDev(
+      'Functions are not valid as a React child. ' +
+        'This may happen if you return a Component instead of <Component /> from render. ' +
+        'Or maybe you meant to call this function rather than return it.',
+      {withoutStack: true},
+    );
+  });
 });

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 7967cf84a2..8453150a38 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -24,7 +24,6 @@ describe('ReactDOMRoot', () => {
   let container;
 
   beforeEach(() => {
-    jest.resetModules();
     container = document.createElement('div');
     React = require('react');
     ReactDOM = require('react-dom');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 8453150a38..7967cf84a2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -24,6 +24,7 @@ describe('ReactDOMRoot', () => {
   let container;
 
   beforeEach(() => {
+    jest.resetModules();
     container = document.createElement('div');
     React = require('react');
     ReactDOM = require('react-dom');

commit c1fd2a91b1042c137d750be85e5998f699a54d2a
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Sat Feb 17 16:41:59 2024 -0500

    Include the function name for context on invalid function child (#28362)
    
    Also warn for symbols.
    
    It's weird because for objects we throw a hard error but functions we do
    a dev only check. Mainly because we have an object branch anyway.
    
    In the object branch we have some built-ins that have bad errors like
    forwardRef and memo but since they're going to become functions later, I
    didn't bother updating those. Once they're functions those names will be
    part of this.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 7967cf84a2..78e45c7641 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -487,8 +487,23 @@ describe('ReactDOMRoot', () => {
       });
     }).toErrorDev(
       'Functions are not valid as a React child. ' +
-        'This may happen if you return a Component instead of <Component /> from render. ' +
-        'Or maybe you meant to call this function rather than return it.',
+        'This may happen if you return Component instead of <Component /> from render. ' +
+        'Or maybe you meant to call this function rather than return it.\n' +
+        '  root.render(Component)',
+      {withoutStack: true},
+    );
+  });
+
+  it('warns when given a symbol', () => {
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(Symbol('foo'));
+      });
+    }).toErrorDev(
+      'Symbols are not valid as a React child.\n' +
+        '  root.render(Symbol(foo))',
       {withoutStack: true},
     );
   });

commit d579e7748218920331252b0528850943d5e2dd31
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Fri Feb 23 15:16:54 2024 -0500

    Remove method name prefix from warnings and errors (#28432)
    
    This pattern is a petpeeve of mine. I don't consider this best practice
    and so most don't have these prefixes. Very inconsistent.
    
    At best this is useless and noisey that you have to parse because the
    information is also in the stack trace.
    
    At worse these are misleading because they're highlighting something
    internal (like validateDOMNesting) which even suggests an internal bug.
    Even the ones public to React aren't necessarily what you called because
    you might be calling a wrapper around it.
    
    That would be properly reflected in a stack trace - which can also
    properly ignore list so that the first stack you see is your callsite,
    
    Which might be like `render()` in react-testing-library rather than
    `createRoot()` for example.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 78e45c7641..fdf048049d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -71,7 +71,7 @@ describe('ReactDOMRoot', () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
     expect(() => root.render(<div>Hi</div>, callback)).toErrorDev(
-      'render(...): does not support the second callback argument. ' +
+      'does not support the second callback argument. ' +
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
     );
@@ -115,7 +115,7 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     expect(() => root.unmount(callback)).toErrorDev(
-      'unmount(...): does not support a callback argument. ' +
+      'does not support a callback argument. ' +
         'To execute a side effect after rendering, declare it in a component body with useEffect().',
       {withoutStack: true},
     );
@@ -199,7 +199,7 @@ describe('ReactDOMRoot', () => {
   it('throws a good message on invalid containers', () => {
     expect(() => {
       ReactDOMClient.createRoot(<div>Hi</div>);
-    }).toThrow('createRoot(...): Target container is not a DOM element.');
+    }).toThrow('Target container is not a DOM element.');
   });
 
   it('warns when creating two roots managing the same container', () => {
@@ -253,7 +253,7 @@ describe('ReactDOMRoot', () => {
       expect(() => {
         root.render(<div>Hi</div>);
       }).toErrorDev(
-        'render(...): It looks like the React-rendered content of the ' +
+        'It looks like the React-rendered content of the ' +
           'root container was removed without using React. This is not ' +
           'supported and will cause errors. Instead, call ' +
           "root.unmount() to empty a root's container.",
@@ -446,10 +446,10 @@ describe('ReactDOMRoot', () => {
     const commentNode = div.childNodes[0];
 
     expect(() => ReactDOMClient.createRoot(commentNode)).toThrow(
-      'createRoot(...): Target container is not a DOM element.',
+      'Target container is not a DOM element.',
     );
     expect(() => ReactDOMClient.hydrateRoot(commentNode)).toThrow(
-      'hydrateRoot(...): Target container is not a DOM element.',
+      'Target container is not a DOM element.',
     );
   });
 

commit 208ceeb46ca2838c9bf24cd341435f87b2d50569
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Mar 22 12:22:30 2024 -0400

    Cleanup enableFloat flag (#28613)
    
    Cleanup enableFloat flag

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index fdf048049d..db9a8da5d1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -222,21 +222,8 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warns if creating a root on the document.body', async () => {
-    if (gate(flags => flags.enableFloat)) {
-      // we no longer expect an error for this if float is enabled
-      ReactDOMClient.createRoot(document.body);
-    } else {
-      expect(() => {
-        ReactDOMClient.createRoot(document.body);
-      }).toErrorDev(
-        'createRoot(): Creating roots directly with document.body is ' +
-          'discouraged, since its children are often manipulated by third-party ' +
-          'scripts and browser extensions. This may lead to subtle ' +
-          'reconciliation issues. Try using a container element created ' +
-          'for your app.',
-        {withoutStack: true},
-      );
-    }
+    // we no longer expect an error for this if float is enabled
+    ReactDOMClient.createRoot(document.body);
   });
 
   it('warns if updating a root that has had its contents removed', async () => {
@@ -245,21 +232,9 @@ describe('ReactDOMRoot', () => {
     await waitForAll([]);
     container.innerHTML = '';
 
-    if (gate(flags => flags.enableFloat)) {
-      // When either of these flags are on this validation is turned off so we
-      // expect there to be no warnings
-      root.render(<div>Hi</div>);
-    } else {
-      expect(() => {
-        root.render(<div>Hi</div>);
-      }).toErrorDev(
-        'It looks like the React-rendered content of the ' +
-          'root container was removed without using React. This is not ' +
-          'supported and will cause errors. Instead, call ' +
-          "root.unmount() to empty a root's container.",
-        {withoutStack: true},
-      );
-    }
+    // When either of these flags are on this validation is turned off so we
+    // expect there to be no warnings
+    root.render(<div>Hi</div>);
   });
 
   it('should render different components in same root', async () => {

commit 4b8dfd6215bf855402ae1a94cb0ae4f467afca9a
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Mar 26 16:04:18 2024 -0700

    Move Hydration Warnings from the DOM Config into the Fiber reconciliation (#28476)
    
    Stacked on #28458.
    
    This doesn't actually really change the messages yet, it's just a
    refactor.
    
    Hydration warnings can be presented either as HTML or React JSX format.
    If presented as HTML it makes more sense to make that a DOM specific
    concept, however, I think it's actually better to present it in terms of
    React JSX.
    
    Most of the time the errors aren't going to be something messing with
    them at the HTML/HTTP layer. It's because the JS code does something
    different. Most of the time you're working in just React. People don't
    necessarily even know what the HTML form of it looks like. So this takes
    the approach that the warnings are presented in React JSX in their rich
    object form.
    
    Therefore, I'm moving the approach to yield diff data to the reconciler
    but it's the reconciler that's actually printing all the warnings.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index db9a8da5d1..9b9adc40da 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -171,7 +171,7 @@ describe('ReactDOMRoot', () => {
       </div>,
     );
     await expect(async () => await waitForAll([])).toErrorDev(
-      'Extra attributes',
+      'Extra attribute',
     );
   });
 

commit f7aa5e0aa3e2aa51279af4b6cb5413912cacd7f5
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Mar 26 17:01:41 2024 -0700

    Move Hydration Mismatch Errors to Throw or Log Once (Kind of) (#28502)
    
    Stacked on #28476.
    
    We used to `console.error` for every mismatch we found, up until the
    error we threw for the hydration mismatch.
    
    This changes it so that we build up a set of diffs up until we either
    throw or complete hydrating the root/suspense boundary. If we throw, we
    append the diff to the error message which gets passed to
    onRecoverableError (which by default is also logged to console). If we
    complete, we append it to a `console.error`.
    
    Since we early abort when something throws, it effectively means that we
    can only collect multiple diffs if there were preceding non-throwing
    mismatches - i.e. only properties mismatched but tag name matched.
    
    There can still be multiple logs if multiple siblings Suspense
    boundaries all error hydrating but then they're separate errors
    entirely.
    
    We still log an extra line about something erroring but I think the goal
    should be that it leads to a single recoverable or console.error.
    
    This doesn't yet actually print the diff as part of this message. That's
    in a follow up PR.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 9b9adc40da..29a78d63f8 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -171,7 +171,8 @@ describe('ReactDOMRoot', () => {
       </div>,
     );
     await expect(async () => await waitForAll([])).toErrorDev(
-      'Extra attribute',
+      "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties.",
+      {withoutStack: true},
     );
   });
 

commit 6786563f3cbbc9b16d5a8187207b5bd904386e53
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Mar 26 20:44:07 2024 -0700

    [Fiber] Don't Rethrow Errors at the Root (#28627)
    
    Stacked on top of #28498 for test fixes.
    
    ### Don't Rethrow
    
    When we started React it was 1:1 setState calls a series of renders and
    if they error, it errors where the setState was called. Simple. However,
    then batching came and the error actually got thrown somewhere else.
    With concurrent mode, it's not even possible to get setState itself to
    throw anymore.
    
    In fact, all APIs that can rethrow out of React are executed either at
    the root of the scheduler or inside a DOM event handler.
    If you throw inside a React.startTransition callback that's sync, then
    that will bubble out of the startTransition but if you throw inside an
    async callback or a useTransition we now need to handle it at the hook
    site. So in 19 we need to make all React.startTransition swallow the
    error (and report them to reportError).
    
    The only one remaining that can throw is flushSync but it doesn't really
    make sense for it to throw at the callsite neither because batching.
    Just because something rendered in this flush doesn't mean it was
    rendered due to what was just scheduled and doesn't mean that it should
    abort any of the remaining code afterwards. setState is fire and forget.
    It's send an instruction elsewhere, it's not part of the current
    imperative code.
    
    Error boundaries never rethrow. Since you should really always have
    error boundaries, most of the time, it wouldn't rethrow anyway.
    
    Rethrowing also actually currently drops errors on the floor since we
    can only rethrow the first error, so to avoid that we'd need to call
    reportError anyway. This happens in RN events.
    
    The other issue with rethrowing is that it logs an extra console.error.
    Since we're not sure that user code will actually log it anywhere we
    still log it too just like we do with errors inside error boundaries
    which leads all of these to log twice.
    The goal of this PR is to never rethrow out of React instead, errors
    outside of error boundaries get logged to reportError. Event system
    errors too.
    
    ### Breaking Changes
    
    The main thing this affects is testing where you want to inspect the
    errors thrown. To make it easier to port, if you're inside `act` we
    track the error into act in an aggregate error and then rethrow it at
    the root of `act`. Unlike before though, if you flush synchronously
    inside of act it'll still continue until the end of act before
    rethrowing.
    
    I expect most user code breakages would be to migrate from `flushSync`
    to `act` if you assert on throwing.
    
    However, in the React repo we also have `internalAct` and the
    `waitForThrow` helpers. Since these have to use public production
    implementations we track these using the global onerror or process
    uncaughtException. Unlike regular act, includes both event handler
    errors and onRecoverableError by default too. Not just render/commit
    errors. So I had to account for that in our tests.
    
    We restore logging an extra log for uncaught errors after the main log
    with the component stack in it. We use `console.warn`. This is not yet
    ignorable if you preventDefault to the main error event. To avoid
    confusion if you don't end up logging the error to console I just added
    `An error occurred`.
    
    ### Polyfill
    
    All browsers we support really supports `reportError` but not all test
    and server environments do, so I implemented a polyfill for browser and
    node in `shared/reportGlobalError`. I don't love that this is included
    in all builds and gets duplicated into isomorphic even though it's not
    actually needed in production. Maybe in the future we can require a
    polyfill for this.
    
    ### Follow Ups
    
    In a follow up, I'll make caught vs uncaught error handling be
    configurable too.
    
    ---------
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 29a78d63f8..c1f1f3d5bc 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -319,9 +319,11 @@ describe('ReactDOMRoot', () => {
     });
     container.innerHTML = '';
 
-    expect(() => {
-      root.unmount();
-    }).toThrow('The node to be removed is not a child of this node.');
+    await expect(async () => {
+      await act(() => {
+        root.unmount();
+      });
+    }).rejects.toThrow('The node to be removed is not a child of this node.');
   });
 
   it('opts-in to concurrent default updates', async () => {

commit a0537160771bafae90c6fd3154eeead2f2c903e7
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Mar 26 21:51:37 2024 -0700

    Make onUncaughtError and onCaughtError Configurable (#28641)
    
    Stacked on #28627.
    
    This makes error logging configurable using these
    `createRoot`/`hydrateRoot` options:
    
    ```
    onUncaughtError(error: mixed, errorInfo: {componentStack?: ?string}) => void
    onCaughtError(error: mixed, errorInfo: {componentStack?: ?string, errorBoundary?: ?React.Component<any, any>}) => void
    onRecoverableError(error: mixed, errorInfo: {digest?: ?string, componentStack?: ?string}) => void
    ```
    
    We already have the `onRecoverableError` option since before.
    
    Overriding these can be used to implement custom error dialogs (with
    access to the `componentStack`).
    
    It can also be used to silence caught errors when testing an error
    boundary or if you prefer not getting logs for caught errors that you've
    already handled in an error boundary.
    
    I currently expose the error boundary instance but I think we should
    probably remove that since it doesn't make sense for non-class error
    boundaries and isn't very useful anyway. It's also unclear what it
    should do when an error is rethrown from one boundary to another.
    
    Since these are public APIs now we can implement the
    ReactFiberErrorDialog forks using these options at the roots of the
    builds. So I unforked those files and instead passed a custom option for
    the native and www builds.
    
    To do this I had to fork the ReactDOMLegacy file into ReactDOMRootFB
    which is a duplication but that will go away as soon as the FB fork is
    the only legacy root.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c1f1f3d5bc..cdfb267006 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -47,6 +47,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
   });
 
+  // @gate !classic || !__DEV__
   it('warns if you import createRoot from react-dom', async () => {
     expect(() => ReactDOM.createRoot(container)).toErrorDev(
       'You are importing createRoot from "react-dom" which is not supported. ' +
@@ -57,6 +58,7 @@ describe('ReactDOMRoot', () => {
     );
   });
 
+  // @gate !classic || !__DEV__
   it('warns if you import hydrateRoot from react-dom', async () => {
     expect(() => ReactDOM.hydrateRoot(container, null)).toErrorDev(
       'You are importing hydrateRoot from "react-dom" which is not supported. ' +

commit cb6dc7a6a03ea10a38b84e9e5737739e0d468435
Author: Josh Story <story@hey.com>
Date:   Tue Apr 2 22:23:54 2024 -0700

    [FB] use modern entrypoint in tests (#28724)
    
    Removes the entrypoint hack in tests since we gate legacy mode tests now

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index cdfb267006..45f6fc095c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -47,7 +47,7 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
   });
 
-  // @gate !classic || !__DEV__
+  // @gate !www || !__DEV__
   it('warns if you import createRoot from react-dom', async () => {
     expect(() => ReactDOM.createRoot(container)).toErrorDev(
       'You are importing createRoot from "react-dom" which is not supported. ' +
@@ -58,7 +58,7 @@ describe('ReactDOMRoot', () => {
     );
   });
 
-  // @gate !classic || !__DEV__
+  // @gate !www || !__DEV__
   it('warns if you import hydrateRoot from react-dom', async () => {
     expect(() => ReactDOM.hydrateRoot(container, null)).toErrorDev(
       'You are importing hydrateRoot from "react-dom" which is not supported. ' +

commit 42eff4bc78a3636953c55096ca0b220c611a74cc
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 10 10:33:41 2024 -0400

    [tests] Fix assertions not flushed before act (#28745)
    
    Fixes some easy cases blocking
    https://github.com/facebook/react/pull/28737, I'll follow up with more
    complex/interesting cases in other PRs.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 45f6fc095c..f36f45a1e2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -342,12 +342,13 @@ describe('ReactDOMRoot', () => {
       root.render(<Foo value="a" />);
     });
 
+    assertLog(['a']);
     expect(container.textContent).toEqual('a');
 
     await act(async () => {
       root.render(<Foo value="b" />);
 
-      assertLog(['a']);
+      assertLog([]);
       expect(container.textContent).toEqual('a');
 
       await waitFor(['b']);

commit cb151849e13f46ec64570519cb93d5939fb60cab
Author: Josh Story <story@hey.com>
Date:   Wed Apr 24 08:50:32 2024 -0700

    [react-dom] move all client code to `react-dom/client` (#28271)
    
    This PR reorganizes the `react-dom` entrypoint to only pull in code that
    is environment agnostic. Previously if you required anything from this
    entrypoint in any environment the entire client reconciler was loaded.
    In a prior release we added a server rendering stub which you could
    alias in server environments to omit this unecessary code. After landing
    this change this entrypoint should not load any environment specific
    code.
    
    While a few APIs are truly client (browser) only such as createRoot and
    hydrateRoot many of the APIs you import from this package are only
    useful in the browser but could concievably be imported in shared code
    (components running in Fizz or shared components as part of an RSC app).
    To avoid making these require opting into the client bundle we are
    keeping them in the `react-dom` entrypoint and changing their
    implementation so that in environments where they are not particularly
    useful they do something benign and expected.
    
    #### Removed APIs
    The following APIs are being removed in the next major. Largely they
    have all been deprecated already and are part of legacy rendering modes
    where concurrent features of React are not available
    * `render`
    * `hydrate`
    * `findDOMNode`
    * `unmountComponentAtNode`
    * `unstable_createEventHandle`
    * `unstable_renderSubtreeIntoContainer`
    * `unstable_runWithPrioirty`
    
    #### moved Client APIs
    These APIs were available on both `react-dom` (with a warning) and
    `react-dom/client`. After this change they are only available on
    `react-dom/client`
    * `createRoot`
    * `hydrateRoot`
    
    #### retained APIs
    These APIs still exist on the `react-dom` entrypoint but have normalized
    behavior depending on which renderers are currently in scope
    * `flushSync`: will execute the function (if provided) inside the
    flushSync implemention of FlightServer, Fizz, and Fiber DOM renderers.
    * `unstable_batchedUpdates`: This is a noop in concurrent mode because
    it is now the only supported behavior because there is no legacy
    rendering mode
    * `createPortal`: This just produces an object. It can be called from
    anywhere but since you will probably not have a handle on a DOM node to
    pass to it it will likely warn in environments other than the browser
    * preloading APIS such as `preload`: These methods will execute the
    preload across all renderers currently in scope. Since we resolve the
    Request object on the server using AsyncLocalStorage or the current
    function stack in practice only one renderer should act upon the
    preload.
    
    In addition to these changes the server rendering stub now just rexports
    everything from `react-dom`. In a future minor we will add a warning
    when using the stub and in the next major we will remove the stub
    altogether

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index f36f45a1e2..993e6e5a64 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -47,28 +47,6 @@ describe('ReactDOMRoot', () => {
     expect(container.textContent).toEqual('Hi');
   });
 
-  // @gate !www || !__DEV__
-  it('warns if you import createRoot from react-dom', async () => {
-    expect(() => ReactDOM.createRoot(container)).toErrorDev(
-      'You are importing createRoot from "react-dom" which is not supported. ' +
-        'You should instead import it from "react-dom/client".',
-      {
-        withoutStack: true,
-      },
-    );
-  });
-
-  // @gate !www || !__DEV__
-  it('warns if you import hydrateRoot from react-dom', async () => {
-    expect(() => ReactDOM.hydrateRoot(container, null)).toErrorDev(
-      'You are importing hydrateRoot from "react-dom" which is not supported. ' +
-        'You should instead import it from "react-dom/client".',
-      {
-        withoutStack: true,
-      },
-    );
-  });
-
   it('warns if a callback parameter is provided to render', async () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);

commit d172bdaf95b0be869f7d36b87c95a5f12b229195
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 10 14:31:37 2024 -0400

    Add jest lint rules (#29760)
    
    ## Overview
    
    Updates `eslint-plugin-jest` and enables the recommended rules with some
    turned off that are unhelpful.
    
    The main motivations is:
    a) we have a few duplicated tests, which this found an I deleted
    b) making sure we don't accidentally commit skipped tests

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 993e6e5a64..5ab8e4e902 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -59,7 +59,7 @@ describe('ReactDOMRoot', () => {
     expect(callback).not.toHaveBeenCalled();
   });
 
-  it('warn if a container is passed to root.render(...)', async () => {
+  it('warn if a object is passed to root.render(...)', async () => {
     function App() {
       return 'Child';
     }

commit 14a4699ff173936a30ec453f7b94d47105bbb252
Author: Jack Pope <jackpope1@gmail.com>
Date:   Thu Jul 25 11:59:50 2024 -0400

    Remove allowConcurrentByDefault flag (#30445)
    
    Following https://github.com/facebook/react/pull/30436
    
    Concurrent by default strategy has been unshipped. Here we clean up the
    `allowConcurrentByDefault` path and related logic/tests.
    
    For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
    `createContainer` and `createHydrationContainer` and ignores the value
    to prevent more breaking changes to `react-reconciler` in the RC stage.

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 5ab8e4e902..355ad8cc28 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -17,7 +17,6 @@ let Scheduler = require('scheduler');
 let act;
 let useEffect;
 let assertLog;
-let waitFor;
 let waitForAll;
 
 describe('ReactDOMRoot', () => {
@@ -36,7 +35,6 @@ describe('ReactDOMRoot', () => {
 
     const InternalTestUtils = require('internal-test-utils');
     assertLog = InternalTestUtils.assertLog;
-    waitFor = InternalTestUtils.waitFor;
     waitForAll = InternalTestUtils.waitForAll;
   });
 
@@ -306,39 +304,6 @@ describe('ReactDOMRoot', () => {
     }).rejects.toThrow('The node to be removed is not a child of this node.');
   });
 
-  it('opts-in to concurrent default updates', async () => {
-    const root = ReactDOMClient.createRoot(container, {
-      unstable_concurrentUpdatesByDefault: true,
-    });
-
-    function Foo({value}) {
-      Scheduler.log(value);
-      return <div>{value}</div>;
-    }
-
-    await act(() => {
-      root.render(<Foo value="a" />);
-    });
-
-    assertLog(['a']);
-    expect(container.textContent).toEqual('a');
-
-    await act(async () => {
-      root.render(<Foo value="b" />);
-
-      assertLog([]);
-      expect(container.textContent).toEqual('a');
-
-      await waitFor(['b']);
-      if (gate(flags => flags.allowConcurrentByDefault)) {
-        expect(container.textContent).toEqual('a');
-      } else {
-        expect(container.textContent).toEqual('b');
-      }
-    });
-    expect(container.textContent).toEqual('b');
-  });
-
   it('unmount is synchronous', async () => {
     const root = ReactDOMClient.createRoot(container);
     await act(() => {

commit 03e4ec2d0fe7cd854d28634ba035dc8996ff244d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Jan 5 17:10:29 2025 -0500

    [assert helpers] react-dom (pt3) (#31983)
    
    moar assert helpers
    
    this finishes all of react-dom except the server integration tests which
    are tricky to convert

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index 355ad8cc28..c447430f20 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -18,6 +18,7 @@ let act;
 let useEffect;
 let assertLog;
 let waitForAll;
+let assertConsoleErrorDev;
 
 describe('ReactDOMRoot', () => {
   let container;
@@ -31,6 +32,8 @@ describe('ReactDOMRoot', () => {
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
     act = require('internal-test-utils').act;
+    assertConsoleErrorDev =
+      require('internal-test-utils').assertConsoleErrorDev;
     useEffect = React.useEffect;
 
     const InternalTestUtils = require('internal-test-utils');
@@ -48,9 +51,12 @@ describe('ReactDOMRoot', () => {
   it('warns if a callback parameter is provided to render', async () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
-    expect(() => root.render(<div>Hi</div>, callback)).toErrorDev(
-      'does not support the second callback argument. ' +
-        'To execute a side effect after rendering, declare it in a component body with useEffect().',
+    root.render(<div>Hi</div>, callback);
+    assertConsoleErrorDev(
+      [
+        'does not support the second callback argument. ' +
+          'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      ],
       {withoutStack: true},
     );
     await waitForAll([]);
@@ -63,9 +69,12 @@ describe('ReactDOMRoot', () => {
     }
 
     const root = ReactDOMClient.createRoot(container);
-    expect(() => root.render(<App />, {})).toErrorDev(
-      'You passed a second argument to root.render(...) but it only accepts ' +
-        'one argument.',
+    root.render(<App />, {});
+    assertConsoleErrorDev(
+      [
+        'You passed a second argument to root.render(...) but it only accepts ' +
+          'one argument.',
+      ],
       {
         withoutStack: true,
       },
@@ -78,10 +87,13 @@ describe('ReactDOMRoot', () => {
     }
 
     const root = ReactDOMClient.createRoot(container);
-    expect(() => root.render(<App />, container)).toErrorDev(
-      'You passed a container to the second argument of root.render(...). ' +
-        "You don't need to pass it again since you already passed it to create " +
-        'the root.',
+    root.render(<App />, container);
+    assertConsoleErrorDev(
+      [
+        'You passed a container to the second argument of root.render(...). ' +
+          "You don't need to pass it again since you already passed it to create " +
+          'the root.',
+      ],
       {
         withoutStack: true,
       },
@@ -92,9 +104,12 @@ describe('ReactDOMRoot', () => {
     const callback = jest.fn();
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
-    expect(() => root.unmount(callback)).toErrorDev(
-      'does not support a callback argument. ' +
-        'To execute a side effect after rendering, declare it in a component body with useEffect().',
+    root.unmount(callback);
+    assertConsoleErrorDev(
+      [
+        'does not support a callback argument. ' +
+          'To execute a side effect after rendering, declare it in a component body with useEffect().',
+      ],
       {withoutStack: true},
     );
     await waitForAll([]);
@@ -148,8 +163,27 @@ describe('ReactDOMRoot', () => {
         <span />
       </div>,
     );
-    await expect(async () => await waitForAll([])).toErrorDev(
-      "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties.",
+    await waitForAll([]);
+    assertConsoleErrorDev(
+      [
+        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. " +
+          "This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
+          '\n' +
+          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+          "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+          "- Date formatting in a user's locale which doesn't match the server.\n" +
+          '- External changing data without sending a snapshot of it along with the HTML.\n' +
+          '- Invalid HTML tag nesting.\n' +
+          '\n' +
+          'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+          '\n' +
+          'https://react.dev/link/hydration-mismatch\n' +
+          '\n' +
+          '  <div>\n' +
+          '    <span\n' +
+          '-     className="extra"\n' +
+          '    >\n',
+      ],
       {withoutStack: true},
     );
   });
@@ -183,12 +217,13 @@ describe('ReactDOMRoot', () => {
 
   it('warns when creating two roots managing the same container', () => {
     ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOMClient.createRoot(container);
-    }).toErrorDev(
-      'You are calling ReactDOMClient.createRoot() on a container that ' +
-        'has already been passed to createRoot() before. Instead, call ' +
-        'root.render() on the existing root instead if you want to update it.',
+    ReactDOMClient.createRoot(container);
+    assertConsoleErrorDev(
+      [
+        'You are calling ReactDOMClient.createRoot() on a container that ' +
+          'has already been passed to createRoot() before. Instead, call ' +
+          'root.render() on the existing root instead if you want to update it.',
+      ],
       {withoutStack: true},
     );
   });
@@ -352,14 +387,15 @@ describe('ReactDOMRoot', () => {
     });
     expect(container1.textContent).toEqual('Hi');
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root1.render(<App step={2} />);
-      });
-    }).toErrorDev(
-      'Attempted to synchronously unmount a root while React was ' +
-        'already rendering.',
-    );
+    ReactDOM.flushSync(() => {
+      root1.render(<App step={2} />);
+    });
+    assertConsoleErrorDev([
+      'Attempted to synchronously unmount a root while React was already rendering. ' +
+        'React cannot finish unmounting the root until the current render has completed, ' +
+        'which may lead to a race condition.\n' +
+        '    in App (at **)',
+    ]);
   });
 
   // @gate disableCommentsAsDOMContainers
@@ -378,8 +414,12 @@ describe('ReactDOMRoot', () => {
   });
 
   it('warn if no children passed to hydrateRoot', async () => {
-    expect(() => ReactDOMClient.hydrateRoot(container)).toErrorDev(
-      'Must provide initial children as second argument to hydrateRoot.',
+    ReactDOMClient.hydrateRoot(container);
+    assertConsoleErrorDev(
+      [
+        'Must provide initial children as second argument to hydrateRoot. ' +
+          'Example usage: hydrateRoot(domContainer, <App />)',
+      ],
       {withoutStack: true},
     );
   });
@@ -389,9 +429,15 @@ describe('ReactDOMRoot', () => {
       return 'Child';
     }
 
-    expect(() => ReactDOMClient.createRoot(container, <App />)).toErrorDev(
-      'You passed a JSX element to createRoot. You probably meant to call ' +
-        'root.render instead',
+    ReactDOMClient.createRoot(container, <App />);
+    assertConsoleErrorDev(
+      [
+        'You passed a JSX element to createRoot. You probably meant to call root.render instead. ' +
+          'Example usage:\n' +
+          '\n' +
+          '  let root = createRoot(domContainer);\n' +
+          '  root.render(<App />);',
+      ],
       {
         withoutStack: true,
       },
@@ -405,15 +451,16 @@ describe('ReactDOMRoot', () => {
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(Component);
-      });
-    }).toErrorDev(
-      'Functions are not valid as a React child. ' +
-        'This may happen if you return Component instead of <Component /> from render. ' +
-        'Or maybe you meant to call this function rather than return it.\n' +
-        '  root.render(Component)',
+    ReactDOM.flushSync(() => {
+      root.render(Component);
+    });
+    assertConsoleErrorDev(
+      [
+        'Functions are not valid as a React child. ' +
+          'This may happen if you return Component instead of <Component /> from render. ' +
+          'Or maybe you meant to call this function rather than return it.\n' +
+          '  root.render(Component)',
+      ],
       {withoutStack: true},
     );
   });
@@ -421,13 +468,14 @@ describe('ReactDOMRoot', () => {
   it('warns when given a symbol', () => {
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(Symbol('foo'));
-      });
-    }).toErrorDev(
-      'Symbols are not valid as a React child.\n' +
-        '  root.render(Symbol(foo))',
+    ReactDOM.flushSync(() => {
+      root.render(Symbol('foo'));
+    });
+    assertConsoleErrorDev(
+      [
+        'Symbols are not valid as a React child.\n' +
+          '  root.render(Symbol(foo))',
+      ],
       {withoutStack: true},
     );
   });

commit 029e8bd618af23fbdd9efdac565ad81f7d4640d8
Author: Sebastian "Sebbie" Silbermann <sebastian.silbermann@vercel.com>
Date:   Thu Mar 6 17:12:50 2025 +0100

    Add Owner Stack to attribute hydration mismatches (#32538)

diff --git a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
index c447430f20..25503d3a3c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMRoot-test.js
@@ -164,28 +164,26 @@ describe('ReactDOMRoot', () => {
       </div>,
     );
     await waitForAll([]);
-    assertConsoleErrorDev(
-      [
-        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. " +
-          "This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
-          '\n' +
-          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-          "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-          "- Date formatting in a user's locale which doesn't match the server.\n" +
-          '- External changing data without sending a snapshot of it along with the HTML.\n' +
-          '- Invalid HTML tag nesting.\n' +
-          '\n' +
-          'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-          '\n' +
-          'https://react.dev/link/hydration-mismatch\n' +
-          '\n' +
-          '  <div>\n' +
-          '    <span\n' +
-          '-     className="extra"\n' +
-          '    >\n',
-      ],
-      {withoutStack: true},
-    );
+    assertConsoleErrorDev([
+      "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. " +
+        "This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
+        '\n' +
+        "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+        "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+        "- Date formatting in a user's locale which doesn't match the server.\n" +
+        '- External changing data without sending a snapshot of it along with the HTML.\n' +
+        '- Invalid HTML tag nesting.\n' +
+        '\n' +
+        'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+        '\n' +
+        'https://react.dev/link/hydration-mismatch\n' +
+        '\n' +
+        '  <div>\n' +
+        '    <span\n' +
+        '-     className="extra"\n' +
+        '    >\n' +
+        '\n    in span (at **)',
+    ]);
   });
 
   it('clears existing children', async () => {

