# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
new file mode 100644
index 0000000000..aaeabc6af3
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -0,0 +1,1080 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var React;
+var ReactNoop;
+
+describe('ReactIncrementalSideEffects', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+  });
+
+  function normalizeCodeLocInfo(str) {
+    return str && str.replace(/\(at .+?:\d+\)/g, '(at **)');
+  }
+
+  function div(...children) {
+    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
+    return {type: 'div', children, prop: undefined};
+  }
+
+  function span(prop) {
+    return {type: 'span', children: [], prop};
+  }
+
+  it('can update child nodes of a host instance', () => {
+    function Bar(props) {
+      return <span>{props.text}</span>;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World' ? <Bar text={props.text} /> : null}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span())]);
+
+    ReactNoop.render(<Foo text="World" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span(), span())]);
+  });
+
+  it('can update child nodes of a fragment', function() {
+    function Bar(props) {
+      return <span>{props.text}</span>;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World'
+            ? [<Bar key="a" text={props.text} />, <div key="b" />]
+            : props.text === 'Hi'
+                ? [<div key="b" />, <Bar key="a" text={props.text} />]
+                : null}
+          <span prop="test" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span(), span('test'))]);
+
+    ReactNoop.render(<Foo text="World" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(), span(), div(), span('test')),
+    ]);
+
+    ReactNoop.render(<Foo text="Hi" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(), div(), span(), span('test')),
+    ]);
+  });
+
+  it('can update child nodes rendering into text nodes', function() {
+    function Bar(props) {
+      return props.text;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World'
+            ? [<Bar key="a" text={props.text} />, '!']
+            : null}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div('Hello')]);
+
+    ReactNoop.render(<Foo text="World" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')]);
+  });
+
+  it('can deletes children either components, host or text', function() {
+    function Bar(props) {
+      return <span prop={props.children} />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.show
+            ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World']
+            : []}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(), span('Hello'), 'World'),
+    ]);
+
+    ReactNoop.render(<Foo show={false} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('can delete a child that changes type - implicit keys', function() {
+    let unmounted = false;
+
+    class ClassComponent extends React.Component {
+      componentWillUnmount() {
+        unmounted = true;
+      }
+      render() {
+        return <span prop="Class" />;
+      }
+    }
+
+    function FunctionalComponent(props) {
+      return <span prop="Function" />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.useClass
+            ? <ClassComponent />
+            : props.useFunction
+                ? <FunctionalComponent />
+                : props.useText ? 'Text' : null}
+          Trail
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo useClass={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+
+    expect(unmounted).toBe(false);
+
+    ReactNoop.render(<Foo useFunction={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+
+    expect(unmounted).toBe(true);
+
+    ReactNoop.render(<Foo useText={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div('Text', 'Trail')]);
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+  });
+
+  it('can delete a child that changes type - explicit keys', function() {
+    let unmounted = false;
+
+    class ClassComponent extends React.Component {
+      componentWillUnmount() {
+        unmounted = true;
+      }
+      render() {
+        return <span prop="Class" />;
+      }
+    }
+
+    function FunctionalComponent(props) {
+      return <span prop="Function" />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.useClass
+            ? <ClassComponent key="a" />
+            : props.useFunction ? <FunctionalComponent key="a" /> : null}
+          Trail
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo useClass={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+
+    expect(unmounted).toBe(false);
+
+    ReactNoop.render(<Foo useFunction={true} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+
+    expect(unmounted).toBe(true);
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+  });
+
+  it('does not update child nodes if a flush is aborted', () => {
+    function Bar(props) {
+      return <span prop={props.text} />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <div>
+            <Bar text={props.text} />
+            {props.text === 'Hello' ? <Bar text={props.text} /> : null}
+          </div>
+          <Bar text="Yo" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('Hello')), span('Yo')),
+    ]);
+
+    ReactNoop.render(<Foo text="World" />);
+    ReactNoop.flushDeferredPri(35);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('Hello')), span('Yo')),
+    ]);
+  });
+
+  it('preserves a previously rendered node when deprioritized', () => {
+    function Middle(props) {
+      return <span prop={props.children} />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <div hidden={true}>
+            <Middle>{props.text}</Middle>
+          </div>
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="foo" />);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([div(div(span('foo')))]);
+
+    ReactNoop.render(<Foo text="bar" />);
+    ReactNoop.flushDeferredPri(20);
+
+    expect(ReactNoop.getChildren()).toEqual([div(div(span('foo')))]);
+
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([div(div(span('bar')))]);
+  });
+
+  it('can reuse side-effects after being preempted', () => {
+    function Bar(props) {
+      return <span prop={props.children} />;
+    }
+
+    var middleContent = (
+      <div>
+        <Bar>Hello</Bar>
+        <Bar>World</Bar>
+      </div>
+    );
+
+    function Foo(props) {
+      return (
+        <div hidden={true}>
+          {props.step === 0
+            ? <div>
+                <Bar>Hi</Bar>
+                <Bar>{props.text}</Bar>
+              </div>
+            : middleContent}
+        </div>
+      );
+    }
+
+    // Init
+    ReactNoop.render(<Foo text="foo" step={0} />);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hi'), span('foo'))),
+    ]);
+
+    // Make a quick update which will schedule low priority work to
+    // update the middle content.
+    ReactNoop.render(<Foo text="bar" step={1} />);
+    ReactNoop.flushDeferredPri(30);
+
+    // The tree remains unchanged.
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hi'), span('foo'))),
+    ]);
+
+    // The first Bar has already completed its update but we'll interrupt it to
+    // render some higher priority work. The middle content will bailout so
+    // it remains untouched which means that it should reuse it next time.
+    ReactNoop.render(<Foo text="foo" step={1} />);
+    ReactNoop.flush();
+
+    // Since we did nothing to the middle subtree during the interuption,
+    // we should be able to reuse the reconciliation work that we already did
+    // without restarting. The side-effects should still be replayed.
+
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('World'))),
+    ]);
+  });
+
+  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.children !== nextProps.children;
+      }
+      render() {
+        return <span prop={this.props.children} />;
+      }
+    }
+
+    class Content extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.step !== nextProps.step;
+      }
+      render() {
+        return (
+          <div>
+            <Bar>{this.props.step === 0 ? 'Hi' : 'Hello'}</Bar>
+            <Bar>{this.props.step === 0 ? this.props.text : 'World'}</Bar>
+          </div>
+        );
+      }
+    }
+
+    function Foo(props) {
+      return (
+        <div hidden={true}>
+          <Content step={props.step} text={props.text} />
+        </div>
+      );
+    }
+
+    // Init
+    ReactNoop.render(<Foo text="foo" step={0} />);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hi'), span('foo'))),
+    ]);
+
+    // Make a quick update which will schedule low priority work to
+    // update the middle content.
+    ReactNoop.render(<Foo text="bar" step={1} />);
+    ReactNoop.flushDeferredPri(35);
+
+    // The tree remains unchanged.
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hi'), span('foo'))),
+    ]);
+
+    // The first Bar has already completed its update but we'll interrupt it to
+    // render some higher priority work. The middle content will bailout so
+    // it remains untouched which means that it should reuse it next time.
+    ReactNoop.render(<Foo text="foo" step={1} />);
+    ReactNoop.flush(30);
+
+    // Since we did nothing to the middle subtree during the interuption,
+    // we should be able to reuse the reconciliation work that we already did
+    // without restarting. The side-effects should still be replayed.
+
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('World'))),
+    ]);
+  });
+
+  it('can update a completed tree before it has a chance to commit', () => {
+    function Foo(props) {
+      return <span prop={props.step} />;
+    }
+    ReactNoop.render(<Foo step={1} />);
+    // This should be just enough to complete the tree without committing it
+    ReactNoop.flushDeferredPri(20);
+    expect(ReactNoop.getChildren()).toEqual([]);
+    // To confirm, perform one more unit of work. The tree should now be flushed.
+    // (ReactNoop decrements the time remaining by 5 *before* returning it from
+    // the deadline, so to perform n units of work, you need to give it 5n + 5.
+    // TODO: This is confusing. Decrement it after.)
+    ReactNoop.flushDeferredPri(10);
+    expect(ReactNoop.getChildren()).toEqual([span(1)]);
+
+    ReactNoop.render(<Foo step={2} />);
+    // This should be just enough to complete the tree without committing it
+    ReactNoop.flushDeferredPri(20);
+    expect(ReactNoop.getChildren()).toEqual([span(1)]);
+    // This time, before we commit the tree, we update the root component with
+    // new props
+    ReactNoop.render(<Foo step={3} />);
+    // Now let's commit. We already had a commit that was pending, which will
+    // render 2.
+    ReactNoop.flushDeferredPri(10);
+    expect(ReactNoop.getChildren()).toEqual([span(2)]);
+    // If we flush the rest of the work, we should get another commit that
+    // renders 3. If it renders 2 again, that means an update was dropped.
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([span(3)]);
+  });
+
+  it('updates a child even though the old props is empty', () => {
+    function Foo(props) {
+      return (
+        <div hidden={true}>
+          <span prop={1} />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([div(span(1))]);
+  });
+
+  xit('can defer side-effects and resume them later on', () => {
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        return <span prop={this.props.idx} />;
+      }
+    }
+    function Foo(props) {
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx + 1} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    ReactNoop.flushDeferredPri(40 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(0),
+        div(/*the spans are down-prioritized and not rendered yet*/),
+      ),
+    ]);
+    ReactNoop.render(<Foo tick={1} idx={0} />);
+    ReactNoop.flushDeferredPri(35 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(1), div(/*still not rendered yet*/)),
+    ]);
+    ReactNoop.flushDeferredPri(30 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(1),
+        div(
+          // Now we had enough time to finish the spans.
+          span(0),
+          span(1),
+        ),
+      ),
+    ]);
+    var innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
+    ReactNoop.render(<Foo tick={2} idx={1} />);
+    ReactNoop.flushDeferredPri(30 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(2),
+        div(
+          // Still same old numbers.
+          span(0),
+          span(1),
+        ),
+      ),
+    ]);
+    ReactNoop.render(<Foo tick={3} idx={1} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // New numbers.
+          span(1),
+          span(2),
+        ),
+      ),
+    ]);
+
+    var innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
+    // This should have been an update to an existing instance, not recreation.
+    // We verify that by ensuring that the child instance was the same as
+    // before.
+    expect(innerSpanA).toBe(innerSpanB);
+  });
+
+  xit('can defer side-effects and reuse them later - complex', function() {
+    var ops = [];
+
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        ops.push('Bar');
+        return <span prop={this.props.idx} />;
+      }
+    }
+    class Baz extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        ops.push('Baz');
+        return [
+          <Bar key="a" idx={this.props.idx} />,
+          <Bar key="b" idx={this.props.idx} />,
+        ];
+      }
+    }
+    function Foo(props) {
+      ops.push('Foo');
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Baz idx={props.idx} />
+            <Baz idx={props.idx} />
+            <Baz idx={props.idx} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    ReactNoop.flushDeferredPri(65 + 5);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(0),
+        div(/*the spans are down-prioritized and not rendered yet*/),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Foo', 'Baz', 'Bar']);
+    ops = [];
+
+    ReactNoop.render(<Foo tick={1} idx={0} />);
+    ReactNoop.flushDeferredPri(70);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(1), div(/*still not rendered yet*/)),
+    ]);
+
+    expect(ops).toEqual(['Foo']);
+    ops = [];
+
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(1),
+        div(
+          // Now we had enough time to finish the spans.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar']);
+    ops = [];
+
+    // Now we're going to update the index but we'll only let it finish half
+    // way through.
+    ReactNoop.render(<Foo tick={2} idx={1} />);
+    ReactNoop.flushDeferredPri(95);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(2),
+        div(
+          // Still same old numbers.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    // We let it finish half way through. That means we'll have one fully
+    // completed Baz, one half-way completed Baz and one fully incomplete Baz.
+    expect(ops).toEqual(['Foo', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar']);
+    ops = [];
+
+    // We'll update again, without letting the new index update yet. Only half
+    // way through.
+    ReactNoop.render(<Foo tick={3} idx={1} />);
+    ReactNoop.flushDeferredPri(50);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // Old numbers.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Foo']);
+    ops = [];
+
+    // We should now be able to reuse some of the work we've already done
+    // and replay those side-effects.
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // New numbers.
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
+  });
+
+  it('deprioritizes setStates that happens within a deprioritized tree', () => {
+    var ops = [];
+
+    var barInstances = [];
+
+    class Bar extends React.Component {
+      constructor() {
+        super();
+        this.state = {active: false};
+        barInstances.push(this);
+      }
+      activate() {
+        this.setState({active: true});
+      }
+      render() {
+        ops.push('Bar');
+        return <span prop={this.state.active ? 'X' : this.props.idx} />;
+      }
+    }
+    function Foo(props) {
+      ops.push('Foo');
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(0), div(span(0), span(0), span(0))),
+    ]);
+
+    expect(ops).toEqual(['Foo', 'Bar', 'Bar', 'Bar']);
+
+    ops = [];
+
+    ReactNoop.render(<Foo tick={1} idx={1} />);
+    ReactNoop.flushDeferredPri(70 + 5);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        // Updated.
+        span(1),
+        div(
+          // Still not updated.
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Foo', 'Bar', 'Bar']);
+    ops = [];
+
+    barInstances[0].activate();
+
+    // This should not be enough time to render the content of all the hidden
+    // items. Including the set state since that is deprioritized.
+    // TODO: The cycles it takes to do this could be lowered with further
+    // optimizations.
+    ReactNoop.flushDeferredPri(60 + 5);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        // Updated.
+        span(1),
+        div(
+          // Still not updated.
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar']);
+    ops = [];
+
+    // However, once we render fully, we will have enough time to finish it all
+    // at once.
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(1),
+        div(
+          // Now we had enough time to finish the spans.
+          span('X'),
+          span(1),
+          span(1),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar', 'Bar']);
+  });
+  // TODO: Test that side-effects are not cut off when a work in progress node
+  // moves to "current" without flushing due to having lower priority. Does this
+  // even happen? Maybe a child doesn't get processed because it is lower prio?
+
+  it('calls callback after update is flushed', () => {
+    let instance;
+    class Foo extends React.Component {
+      constructor() {
+        super();
+        instance = this;
+        this.state = {text: 'foo'};
+      }
+      render() {
+        return <span prop={this.state.text} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    let called = false;
+    instance.setState({text: 'bar'}, () => {
+      expect(ReactNoop.getChildren()).toEqual([span('bar')]);
+      called = true;
+    });
+    ReactNoop.flush();
+    expect(called).toBe(true);
+  });
+
+  it('calls setState callback even if component bails out', () => {
+    let instance;
+    class Foo extends React.Component {
+      constructor() {
+        super();
+        instance = this;
+        this.state = {text: 'foo'};
+      }
+      shouldComponentUpdate(nextProps, nextState) {
+        return this.state.text !== nextState.text;
+      }
+      render() {
+        return <span prop={this.state.text} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    let called = false;
+    instance.setState({}, () => {
+      called = true;
+    });
+    ReactNoop.flush();
+    expect(called).toBe(true);
+  });
+
+  // TODO: Test that callbacks are not lost if an update is preempted.
+
+  it('calls componentWillUnmount after a deletion, even if nested', () => {
+    var ops = [];
+
+    class Bar extends React.Component {
+      componentWillUnmount() {
+        ops.push(this.props.name);
+      }
+      render() {
+        return <span />;
+      }
+    }
+
+    class Wrapper extends React.Component {
+      componentWillUnmount() {
+        ops.push('Wrapper');
+      }
+      render() {
+        return <Bar name={this.props.name} />;
+      }
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.show
+            ? [
+                <Bar key="a" name="A" />,
+                <Wrapper key="b" name="B" />,
+                <div key="cd">
+                  <Bar name="C" />
+                  <Wrapper name="D" />,
+                </div>,
+                [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
+              ]
+            : []}
+          <div>
+            {props.show ? <Bar key="g" name="G" /> : null}
+          </div>
+          <Bar name="this should not unmount" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    ReactNoop.flush();
+    expect(ops).toEqual([]);
+
+    ReactNoop.render(<Foo show={false} />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      'A',
+      'Wrapper',
+      'B',
+      'C',
+      'Wrapper',
+      'D',
+      'E',
+      'F',
+      'G',
+    ]);
+  });
+
+  it('calls componentDidMount/Update after insertion/update', () => {
+    var ops = [];
+
+    class Bar extends React.Component {
+      componentDidMount() {
+        ops.push('mount:' + this.props.name);
+      }
+      componentDidUpdate() {
+        ops.push('update:' + this.props.name);
+      }
+      render() {
+        return <span />;
+      }
+    }
+
+    class Wrapper extends React.Component {
+      componentDidMount() {
+        ops.push('mount:wrapper-' + this.props.name);
+      }
+      componentDidUpdate() {
+        ops.push('update:wrapper-' + this.props.name);
+      }
+      render() {
+        return <Bar name={this.props.name} />;
+      }
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar key="a" name="A" />
+          <Wrapper key="b" name="B" />
+          <div key="cd">
+            <Bar name="C" />
+            <Wrapper name="D" />
+          </div>
+          {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
+          <div>
+            <Bar key="g" name="G" />
+          </div>
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      'mount:A',
+      'mount:B',
+      'mount:wrapper-B',
+      'mount:C',
+      'mount:D',
+      'mount:wrapper-D',
+      'mount:E',
+      'mount:F',
+      'mount:G',
+    ]);
+
+    ops = [];
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      'update:A',
+      'update:B',
+      'update:wrapper-B',
+      'update:C',
+      'update:D',
+      'update:wrapper-D',
+      'update:E',
+      'update:F',
+      'update:G',
+    ]);
+  });
+
+  it('invokes ref callbacks after insertion/update/unmount', () => {
+    spyOn(console, 'error');
+    var classInstance = null;
+
+    var ops = [];
+
+    class ClassComponent extends React.Component {
+      render() {
+        classInstance = this;
+        return <span />;
+      }
+    }
+
+    function FunctionalComponent(props) {
+      return <span />;
+    }
+
+    function Foo(props) {
+      return props.show
+        ? <div>
+            <ClassComponent ref={n => ops.push(n)} />
+            <FunctionalComponent ref={n => ops.push(n)} />
+            <div ref={n => ops.push(n)} />
+          </div>
+        : null;
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      classInstance,
+      // no call for functional components
+      div(),
+    ]);
+
+    ops = [];
+
+    // Refs that switch function instances get reinvoked
+    ReactNoop.render(<Foo show={true} />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      // detach all refs that switched handlers first.
+      null,
+      null,
+      // reattach as a separate phase
+      classInstance,
+      div(),
+    ]);
+
+    ops = [];
+
+    ReactNoop.render(<Foo show={false} />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      // unmount
+      null,
+      null,
+    ]);
+
+    expectDev(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toBe(
+      'Warning: Stateless function components cannot be given refs. ' +
+        'Attempts to access this ref will fail.\n\nCheck the render method ' +
+        'of `Foo`.\n' +
+        '    in FunctionalComponent (at **)\n' +
+        '    in div (at **)\n' +
+        '    in Foo (at **)',
+    );
+  });
+
+  // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
+  // expected way for aborted and resumed render life-cycles.
+
+  it('supports string refs', () => {
+    var fooInstance = null;
+
+    class Bar extends React.Component {
+      componentDidMount() {
+        this.test = 'test';
+      }
+      render() {
+        return <div />;
+      }
+    }
+
+    class Foo extends React.Component {
+      render() {
+        fooInstance = this;
+        return <Bar ref="bar" />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    expect(fooInstance.refs.bar.test).toEqual('test');
+  });
+});

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index aaeabc6af3..14170abc5b 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -67,8 +67,8 @@ describe('ReactIncrementalSideEffects', () => {
           {props.text === 'World'
             ? [<Bar key="a" text={props.text} />, <div key="b" />]
             : props.text === 'Hi'
-                ? [<div key="b" />, <Bar key="a" text={props.text} />]
-                : null}
+              ? [<div key="b" />, <Bar key="a" text={props.text} />]
+              : null}
           <span prop="test" />
         </div>
       );
@@ -161,11 +161,13 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       return (
         <div>
-          {props.useClass
-            ? <ClassComponent />
-            : props.useFunction
-                ? <FunctionalComponent />
-                : props.useText ? 'Text' : null}
+          {props.useClass ? (
+            <ClassComponent />
+          ) : props.useFunction ? (
+            <FunctionalComponent />
+          ) : props.useText ? (
+            'Text'
+          ) : null}
           Trail
         </div>
       );
@@ -211,9 +213,11 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       return (
         <div>
-          {props.useClass
-            ? <ClassComponent key="a" />
-            : props.useFunction ? <FunctionalComponent key="a" /> : null}
+          {props.useClass ? (
+            <ClassComponent key="a" />
+          ) : props.useFunction ? (
+            <FunctionalComponent key="a" />
+          ) : null}
           Trail
         </div>
       );
@@ -311,12 +315,14 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       return (
         <div hidden={true}>
-          {props.step === 0
-            ? <div>
-                <Bar>Hi</Bar>
-                <Bar>{props.text}</Bar>
-              </div>
-            : middleContent}
+          {props.step === 0 ? (
+            <div>
+              <Bar>Hi</Bar>
+              <Bar>{props.text}</Bar>
+            </div>
+          ) : (
+            middleContent
+          )}
         </div>
       );
     }
@@ -879,9 +885,7 @@ describe('ReactIncrementalSideEffects', () => {
                 [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
               ]
             : []}
-          <div>
-            {props.show ? <Bar key="g" name="G" /> : null}
-          </div>
+          <div>{props.show ? <Bar key="g" name="G" /> : null}</div>
           <Bar name="this should not unmount" />
         </div>
       );
@@ -999,13 +1003,13 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     function Foo(props) {
-      return props.show
-        ? <div>
-            <ClassComponent ref={n => ops.push(n)} />
-            <FunctionalComponent ref={n => ops.push(n)} />
-            <div ref={n => ops.push(n)} />
-          </div>
-        : null;
+      return props.show ? (
+        <div>
+          <ClassComponent ref={n => ops.push(n)} />
+          <FunctionalComponent ref={n => ops.push(n)} />
+          <div ref={n => ops.push(n)} />
+        </div>
+      ) : null;
     }
 
     ReactNoop.render(<Foo show={true} />);

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 14170abc5b..e1cd0307ca 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -986,7 +986,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   it('invokes ref callbacks after insertion/update/unmount', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     var classInstance = null;
 
     var ops = [];
@@ -1044,14 +1044,16 @@ describe('ReactIncrementalSideEffects', () => {
       null,
     ]);
 
-    expectDev(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toBe(
-      'Warning: Stateless function components cannot be given refs. ' +
-        'Attempts to access this ref will fail.\n\nCheck the render method ' +
-        'of `Foo`.\n' +
-        '    in FunctionalComponent (at **)\n' +
-        '    in div (at **)\n' +
-        '    in Foo (at **)',
-    );
+    if (__DEV__) {
+      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toBe(
+        'Warning: Stateless function components cannot be given refs. ' +
+          'Attempts to access this ref will fail.\n\nCheck the render method ' +
+          'of `Foo`.\n' +
+          '    in FunctionalComponent (at **)\n' +
+          '    in div (at **)\n' +
+          '    in Foo (at **)',
+      );
+    }
   });
 
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the

commit 6074664f73c6b1ea1f774f2bc698224e3677cef0
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Thu Nov 30 21:59:05 2017 -0200

    react-reconciler: convert vars into let/const (#11729)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index e1cd0307ca..e1dbf3286b 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -9,8 +9,8 @@
 
 'use strict';
 
-var React;
-var ReactNoop;
+let React;
+let ReactNoop;
 
 describe('ReactIncrementalSideEffects', () => {
   beforeEach(() => {
@@ -305,7 +305,7 @@ describe('ReactIncrementalSideEffects', () => {
       return <span prop={props.children} />;
     }
 
-    var middleContent = (
+    const middleContent = (
       <div>
         <Bar>Hello</Bar>
         <Bar>World</Bar>
@@ -515,7 +515,7 @@ describe('ReactIncrementalSideEffects', () => {
         ),
       ),
     ]);
-    var innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
+    const innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
     ReactNoop.render(<Foo tick={2} idx={1} />);
     ReactNoop.flushDeferredPri(30 + 25);
     expect(ReactNoop.getChildren()).toEqual([
@@ -541,7 +541,7 @@ describe('ReactIncrementalSideEffects', () => {
       ),
     ]);
 
-    var innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
+    const innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
     // This should have been an update to an existing instance, not recreation.
     // We verify that by ensuring that the child instance was the same as
     // before.
@@ -549,7 +549,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   xit('can defer side-effects and reuse them later - complex', function() {
-    var ops = [];
+    let ops = [];
 
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -693,9 +693,9 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   it('deprioritizes setStates that happens within a deprioritized tree', () => {
-    var ops = [];
+    let ops = [];
 
-    var barInstances = [];
+    const barInstances = [];
 
     class Bar extends React.Component {
       constructor() {
@@ -851,7 +851,7 @@ describe('ReactIncrementalSideEffects', () => {
   // TODO: Test that callbacks are not lost if an update is preempted.
 
   it('calls componentWillUnmount after a deletion, even if nested', () => {
-    var ops = [];
+    const ops = [];
 
     class Bar extends React.Component {
       componentWillUnmount() {
@@ -911,7 +911,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   it('calls componentDidMount/Update after insertion/update', () => {
-    var ops = [];
+    let ops = [];
 
     class Bar extends React.Component {
       componentDidMount() {
@@ -987,9 +987,9 @@ describe('ReactIncrementalSideEffects', () => {
 
   it('invokes ref callbacks after insertion/update/unmount', () => {
     spyOnDev(console, 'error');
-    var classInstance = null;
+    let classInstance = null;
 
-    var ops = [];
+    let ops = [];
 
     class ClassComponent extends React.Component {
       render() {
@@ -1060,7 +1060,7 @@ describe('ReactIncrementalSideEffects', () => {
   // expected way for aborted and resumed render life-cycles.
 
   it('supports string refs', () => {
-    var fooInstance = null;
+    let fooInstance = null;
 
     class Bar extends React.Component {
       componentDidMount() {

commit 0deea326674077598e351803d7a204a1c744a578
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jan 2 18:42:18 2018 +0000

    Run some tests in Node environment (#11948)
    
    * Run some tests in Node environment
    
    * Separate SSR tests that require DOM
    
    This allow us to run others with Node environment.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index e1dbf3286b..d31de9d2f9 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -5,6 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @emails react-core
+ * @jest-environment node
  */
 
 'use strict';

commit 9f848f8ebec30b3aaa4844ecaef83b014359c5e3
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 13:55:37 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11957)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()
    
    * Updated several additional tests to use .toWarnDev() matcher
    
    * Updated ReactElementValidator to distinguish between Array and Object in its warning. Also updated its test to use .toWarnDev() matcher.
    
    * Updated a couple of additional tests
    
    * Removed unused normalizeCodeLocInfo() methods

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index d31de9d2f9..ba405776a5 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -20,10 +20,6 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop = require('react-noop-renderer');
   });
 
-  function normalizeCodeLocInfo(str) {
-    return str && str.replace(/\(at .+?:\d+\)/g, '(at **)');
-  }
-
   function div(...children) {
     children = children.map(c => (typeof c === 'string' ? {text: c} : c));
     return {type: 'div', children, prop: undefined};
@@ -987,7 +983,6 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   it('invokes ref callbacks after insertion/update/unmount', () => {
-    spyOnDev(console, 'error');
     let classInstance = null;
 
     let ops = [];
@@ -1014,7 +1009,14 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo show={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'Warning: Stateless function components cannot be given refs. ' +
+        'Attempts to access this ref will fail.\n\nCheck the render method ' +
+        'of `Foo`.\n' +
+        '    in FunctionalComponent (at **)\n' +
+        '    in div (at **)\n' +
+        '    in Foo (at **)',
+    );
     expect(ops).toEqual([
       classInstance,
       // no call for functional components
@@ -1044,17 +1046,6 @@ describe('ReactIncrementalSideEffects', () => {
       null,
       null,
     ]);
-
-    if (__DEV__) {
-      expect(normalizeCodeLocInfo(console.error.calls.argsFor(0)[0])).toBe(
-        'Warning: Stateless function components cannot be given refs. ' +
-          'Attempts to access this ref will fail.\n\nCheck the render method ' +
-          'of `Foo`.\n' +
-          '    in FunctionalComponent (at **)\n' +
-          '    in div (at **)\n' +
-          '    in Foo (at **)',
-      );
-    }
   });
 
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the

commit 5b975411a1258c2747730ee428140a2d01ea673b
Author: Semen Zhydenko <simeon.zhidenko@gmail.com>
Date:   Thu Jan 11 13:24:49 2018 +0100

    Minor typos fixed (#12005)
    
    * commiting -> committing
    
    * doens't -> doesn't
    
    * interuption -> interruption
    
    * inital -> initial
    
    * statment -> statement

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index ba405776a5..5a2bdb022f 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -348,7 +348,7 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.render(<Foo text="foo" step={1} />);
     ReactNoop.flush();
 
-    // Since we did nothing to the middle subtree during the interuption,
+    // Since we did nothing to the middle subtree during the interruption,
     // we should be able to reuse the reconciliation work that we already did
     // without restarting. The side-effects should still be replayed.
 
@@ -413,7 +413,7 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.render(<Foo text="foo" step={1} />);
     ReactNoop.flush(30);
 
-    // Since we did nothing to the middle subtree during the interuption,
+    // Since we did nothing to the middle subtree during the interruption,
     // we should be able to reuse the reconciliation work that we already did
     // without restarting. The side-effects should still be replayed.
 

commit d3b183c32326cacc29efea43ca9300a17ed4aca0
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Jan 25 14:30:53 2018 -0800

    Debug render-phase side effects in "strict" mode (#12094)
    
    A new feature flag has been added, debugRenderPhaseSideEffectsForStrictMode. When enabled, StrictMode subtrees will also double-invoke lifecycles in the same way as debugRenderPhaseSideEffects.
    
    By default, this flag is enabled for __DEV__ only. Internally we can toggle it with a GK.
    
    This breaks several of our incremental tests which make use of the noop-renderer. Updating the tests to account for the double-rendering in development mode makes them significantly more complicated. The most straight forward fix for this will be to convert them to be run as internal tests only. I believe this is reasonable since we are the only people making use of the noop renderer.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
deleted file mode 100644
index 5a2bdb022f..0000000000
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ /dev/null
@@ -1,1078 +0,0 @@
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @emails react-core
- * @jest-environment node
- */
-
-'use strict';
-
-let React;
-let ReactNoop;
-
-describe('ReactIncrementalSideEffects', () => {
-  beforeEach(() => {
-    jest.resetModules();
-    React = require('react');
-    ReactNoop = require('react-noop-renderer');
-  });
-
-  function div(...children) {
-    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
-    return {type: 'div', children, prop: undefined};
-  }
-
-  function span(prop) {
-    return {type: 'span', children: [], prop};
-  }
-
-  it('can update child nodes of a host instance', () => {
-    function Bar(props) {
-      return <span>{props.text}</span>;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <Bar text={props.text} />
-          {props.text === 'World' ? <Bar text={props.text} /> : null}
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo text="Hello" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span())]);
-
-    ReactNoop.render(<Foo text="World" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span(), span())]);
-  });
-
-  it('can update child nodes of a fragment', function() {
-    function Bar(props) {
-      return <span>{props.text}</span>;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <Bar text={props.text} />
-          {props.text === 'World'
-            ? [<Bar key="a" text={props.text} />, <div key="b" />]
-            : props.text === 'Hi'
-              ? [<div key="b" />, <Bar key="a" text={props.text} />]
-              : null}
-          <span prop="test" />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo text="Hello" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span(), span('test'))]);
-
-    ReactNoop.render(<Foo text="World" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(), span(), div(), span('test')),
-    ]);
-
-    ReactNoop.render(<Foo text="Hi" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(), div(), span(), span('test')),
-    ]);
-  });
-
-  it('can update child nodes rendering into text nodes', function() {
-    function Bar(props) {
-      return props.text;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <Bar text={props.text} />
-          {props.text === 'World'
-            ? [<Bar key="a" text={props.text} />, '!']
-            : null}
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo text="Hello" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div('Hello')]);
-
-    ReactNoop.render(<Foo text="World" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')]);
-  });
-
-  it('can deletes children either components, host or text', function() {
-    function Bar(props) {
-      return <span prop={props.children} />;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          {props.show
-            ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World']
-            : []}
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo show={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(), span('Hello'), 'World'),
-    ]);
-
-    ReactNoop.render(<Foo show={false} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('can delete a child that changes type - implicit keys', function() {
-    let unmounted = false;
-
-    class ClassComponent extends React.Component {
-      componentWillUnmount() {
-        unmounted = true;
-      }
-      render() {
-        return <span prop="Class" />;
-      }
-    }
-
-    function FunctionalComponent(props) {
-      return <span prop="Function" />;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          {props.useClass ? (
-            <ClassComponent />
-          ) : props.useFunction ? (
-            <FunctionalComponent />
-          ) : props.useText ? (
-            'Text'
-          ) : null}
-          Trail
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo useClass={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
-
-    expect(unmounted).toBe(false);
-
-    ReactNoop.render(<Foo useFunction={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
-
-    expect(unmounted).toBe(true);
-
-    ReactNoop.render(<Foo useText={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div('Text', 'Trail')]);
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
-  });
-
-  it('can delete a child that changes type - explicit keys', function() {
-    let unmounted = false;
-
-    class ClassComponent extends React.Component {
-      componentWillUnmount() {
-        unmounted = true;
-      }
-      render() {
-        return <span prop="Class" />;
-      }
-    }
-
-    function FunctionalComponent(props) {
-      return <span prop="Function" />;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          {props.useClass ? (
-            <ClassComponent key="a" />
-          ) : props.useFunction ? (
-            <FunctionalComponent key="a" />
-          ) : null}
-          Trail
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo useClass={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
-
-    expect(unmounted).toBe(false);
-
-    ReactNoop.render(<Foo useFunction={true} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
-
-    expect(unmounted).toBe(true);
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
-  });
-
-  it('does not update child nodes if a flush is aborted', () => {
-    function Bar(props) {
-      return <span prop={props.text} />;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <div>
-            <Bar text={props.text} />
-            {props.text === 'Hello' ? <Bar text={props.text} /> : null}
-          </div>
-          <Bar text="Yo" />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo text="Hello" />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('Hello')), span('Yo')),
-    ]);
-
-    ReactNoop.render(<Foo text="World" />);
-    ReactNoop.flushDeferredPri(35);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('Hello')), span('Yo')),
-    ]);
-  });
-
-  it('preserves a previously rendered node when deprioritized', () => {
-    function Middle(props) {
-      return <span prop={props.children} />;
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <div hidden={true}>
-            <Middle>{props.text}</Middle>
-          </div>
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo text="foo" />);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([div(div(span('foo')))]);
-
-    ReactNoop.render(<Foo text="bar" />);
-    ReactNoop.flushDeferredPri(20);
-
-    expect(ReactNoop.getChildren()).toEqual([div(div(span('foo')))]);
-
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([div(div(span('bar')))]);
-  });
-
-  it('can reuse side-effects after being preempted', () => {
-    function Bar(props) {
-      return <span prop={props.children} />;
-    }
-
-    const middleContent = (
-      <div>
-        <Bar>Hello</Bar>
-        <Bar>World</Bar>
-      </div>
-    );
-
-    function Foo(props) {
-      return (
-        <div hidden={true}>
-          {props.step === 0 ? (
-            <div>
-              <Bar>Hi</Bar>
-              <Bar>{props.text}</Bar>
-            </div>
-          ) : (
-            middleContent
-          )}
-        </div>
-      );
-    }
-
-    // Init
-    ReactNoop.render(<Foo text="foo" step={0} />);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hi'), span('foo'))),
-    ]);
-
-    // Make a quick update which will schedule low priority work to
-    // update the middle content.
-    ReactNoop.render(<Foo text="bar" step={1} />);
-    ReactNoop.flushDeferredPri(30);
-
-    // The tree remains unchanged.
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hi'), span('foo'))),
-    ]);
-
-    // The first Bar has already completed its update but we'll interrupt it to
-    // render some higher priority work. The middle content will bailout so
-    // it remains untouched which means that it should reuse it next time.
-    ReactNoop.render(<Foo text="foo" step={1} />);
-    ReactNoop.flush();
-
-    // Since we did nothing to the middle subtree during the interruption,
-    // we should be able to reuse the reconciliation work that we already did
-    // without restarting. The side-effects should still be replayed.
-
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('World'))),
-    ]);
-  });
-
-  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
-    class Bar extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.children !== nextProps.children;
-      }
-      render() {
-        return <span prop={this.props.children} />;
-      }
-    }
-
-    class Content extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.step !== nextProps.step;
-      }
-      render() {
-        return (
-          <div>
-            <Bar>{this.props.step === 0 ? 'Hi' : 'Hello'}</Bar>
-            <Bar>{this.props.step === 0 ? this.props.text : 'World'}</Bar>
-          </div>
-        );
-      }
-    }
-
-    function Foo(props) {
-      return (
-        <div hidden={true}>
-          <Content step={props.step} text={props.text} />
-        </div>
-      );
-    }
-
-    // Init
-    ReactNoop.render(<Foo text="foo" step={0} />);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hi'), span('foo'))),
-    ]);
-
-    // Make a quick update which will schedule low priority work to
-    // update the middle content.
-    ReactNoop.render(<Foo text="bar" step={1} />);
-    ReactNoop.flushDeferredPri(35);
-
-    // The tree remains unchanged.
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hi'), span('foo'))),
-    ]);
-
-    // The first Bar has already completed its update but we'll interrupt it to
-    // render some higher priority work. The middle content will bailout so
-    // it remains untouched which means that it should reuse it next time.
-    ReactNoop.render(<Foo text="foo" step={1} />);
-    ReactNoop.flush(30);
-
-    // Since we did nothing to the middle subtree during the interruption,
-    // we should be able to reuse the reconciliation work that we already did
-    // without restarting. The side-effects should still be replayed.
-
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('World'))),
-    ]);
-  });
-
-  it('can update a completed tree before it has a chance to commit', () => {
-    function Foo(props) {
-      return <span prop={props.step} />;
-    }
-    ReactNoop.render(<Foo step={1} />);
-    // This should be just enough to complete the tree without committing it
-    ReactNoop.flushDeferredPri(20);
-    expect(ReactNoop.getChildren()).toEqual([]);
-    // To confirm, perform one more unit of work. The tree should now be flushed.
-    // (ReactNoop decrements the time remaining by 5 *before* returning it from
-    // the deadline, so to perform n units of work, you need to give it 5n + 5.
-    // TODO: This is confusing. Decrement it after.)
-    ReactNoop.flushDeferredPri(10);
-    expect(ReactNoop.getChildren()).toEqual([span(1)]);
-
-    ReactNoop.render(<Foo step={2} />);
-    // This should be just enough to complete the tree without committing it
-    ReactNoop.flushDeferredPri(20);
-    expect(ReactNoop.getChildren()).toEqual([span(1)]);
-    // This time, before we commit the tree, we update the root component with
-    // new props
-    ReactNoop.render(<Foo step={3} />);
-    // Now let's commit. We already had a commit that was pending, which will
-    // render 2.
-    ReactNoop.flushDeferredPri(10);
-    expect(ReactNoop.getChildren()).toEqual([span(2)]);
-    // If we flush the rest of the work, we should get another commit that
-    // renders 3. If it renders 2 again, that means an update was dropped.
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([span(3)]);
-  });
-
-  it('updates a child even though the old props is empty', () => {
-    function Foo(props) {
-      return (
-        <div hidden={true}>
-          <span prop={1} />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([div(span(1))]);
-  });
-
-  xit('can defer side-effects and resume them later on', () => {
-    class Bar extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        return <span prop={this.props.idx} />;
-      }
-    }
-    function Foo(props) {
-      return (
-        <div>
-          <span prop={props.tick} />
-          <div hidden={true}>
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx + 1} />
-          </div>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    ReactNoop.flushDeferredPri(40 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(0),
-        div(/*the spans are down-prioritized and not rendered yet*/),
-      ),
-    ]);
-    ReactNoop.render(<Foo tick={1} idx={0} />);
-    ReactNoop.flushDeferredPri(35 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(1), div(/*still not rendered yet*/)),
-    ]);
-    ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(1),
-        div(
-          // Now we had enough time to finish the spans.
-          span(0),
-          span(1),
-        ),
-      ),
-    ]);
-    const innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
-    ReactNoop.render(<Foo tick={2} idx={1} />);
-    ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(2),
-        div(
-          // Still same old numbers.
-          span(0),
-          span(1),
-        ),
-      ),
-    ]);
-    ReactNoop.render(<Foo tick={3} idx={1} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // New numbers.
-          span(1),
-          span(2),
-        ),
-      ),
-    ]);
-
-    const innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
-    // This should have been an update to an existing instance, not recreation.
-    // We verify that by ensuring that the child instance was the same as
-    // before.
-    expect(innerSpanA).toBe(innerSpanB);
-  });
-
-  xit('can defer side-effects and reuse them later - complex', function() {
-    let ops = [];
-
-    class Bar extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        ops.push('Bar');
-        return <span prop={this.props.idx} />;
-      }
-    }
-    class Baz extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        ops.push('Baz');
-        return [
-          <Bar key="a" idx={this.props.idx} />,
-          <Bar key="b" idx={this.props.idx} />,
-        ];
-      }
-    }
-    function Foo(props) {
-      ops.push('Foo');
-      return (
-        <div>
-          <span prop={props.tick} />
-          <div hidden={true}>
-            <Baz idx={props.idx} />
-            <Baz idx={props.idx} />
-            <Baz idx={props.idx} />
-          </div>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    ReactNoop.flushDeferredPri(65 + 5);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(0),
-        div(/*the spans are down-prioritized and not rendered yet*/),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Foo', 'Baz', 'Bar']);
-    ops = [];
-
-    ReactNoop.render(<Foo tick={1} idx={0} />);
-    ReactNoop.flushDeferredPri(70);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(1), div(/*still not rendered yet*/)),
-    ]);
-
-    expect(ops).toEqual(['Foo']);
-    ops = [];
-
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(1),
-        div(
-          // Now we had enough time to finish the spans.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar']);
-    ops = [];
-
-    // Now we're going to update the index but we'll only let it finish half
-    // way through.
-    ReactNoop.render(<Foo tick={2} idx={1} />);
-    ReactNoop.flushDeferredPri(95);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(2),
-        div(
-          // Still same old numbers.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
-
-    // We let it finish half way through. That means we'll have one fully
-    // completed Baz, one half-way completed Baz and one fully incomplete Baz.
-    expect(ops).toEqual(['Foo', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar']);
-    ops = [];
-
-    // We'll update again, without letting the new index update yet. Only half
-    // way through.
-    ReactNoop.render(<Foo tick={3} idx={1} />);
-    ReactNoop.flushDeferredPri(50);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // Old numbers.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Foo']);
-    ops = [];
-
-    // We should now be able to reuse some of the work we've already done
-    // and replay those side-effects.
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // New numbers.
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
-  });
-
-  it('deprioritizes setStates that happens within a deprioritized tree', () => {
-    let ops = [];
-
-    const barInstances = [];
-
-    class Bar extends React.Component {
-      constructor() {
-        super();
-        this.state = {active: false};
-        barInstances.push(this);
-      }
-      activate() {
-        this.setState({active: true});
-      }
-      render() {
-        ops.push('Bar');
-        return <span prop={this.state.active ? 'X' : this.props.idx} />;
-      }
-    }
-    function Foo(props) {
-      ops.push('Foo');
-      return (
-        <div>
-          <span prop={props.tick} />
-          <div hidden={true}>
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx} />
-          </div>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(0), div(span(0), span(0), span(0))),
-    ]);
-
-    expect(ops).toEqual(['Foo', 'Bar', 'Bar', 'Bar']);
-
-    ops = [];
-
-    ReactNoop.render(<Foo tick={1} idx={1} />);
-    ReactNoop.flushDeferredPri(70 + 5);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        // Updated.
-        span(1),
-        div(
-          // Still not updated.
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Foo', 'Bar', 'Bar']);
-    ops = [];
-
-    barInstances[0].activate();
-
-    // This should not be enough time to render the content of all the hidden
-    // items. Including the set state since that is deprioritized.
-    // TODO: The cycles it takes to do this could be lowered with further
-    // optimizations.
-    ReactNoop.flushDeferredPri(60 + 5);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        // Updated.
-        span(1),
-        div(
-          // Still not updated.
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Bar']);
-    ops = [];
-
-    // However, once we render fully, we will have enough time to finish it all
-    // at once.
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(1),
-        div(
-          // Now we had enough time to finish the spans.
-          span('X'),
-          span(1),
-          span(1),
-        ),
-      ),
-    ]);
-
-    expect(ops).toEqual(['Bar', 'Bar']);
-  });
-  // TODO: Test that side-effects are not cut off when a work in progress node
-  // moves to "current" without flushing due to having lower priority. Does this
-  // even happen? Maybe a child doesn't get processed because it is lower prio?
-
-  it('calls callback after update is flushed', () => {
-    let instance;
-    class Foo extends React.Component {
-      constructor() {
-        super();
-        instance = this;
-        this.state = {text: 'foo'};
-      }
-      render() {
-        return <span prop={this.state.text} />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
-    let called = false;
-    instance.setState({text: 'bar'}, () => {
-      expect(ReactNoop.getChildren()).toEqual([span('bar')]);
-      called = true;
-    });
-    ReactNoop.flush();
-    expect(called).toBe(true);
-  });
-
-  it('calls setState callback even if component bails out', () => {
-    let instance;
-    class Foo extends React.Component {
-      constructor() {
-        super();
-        instance = this;
-        this.state = {text: 'foo'};
-      }
-      shouldComponentUpdate(nextProps, nextState) {
-        return this.state.text !== nextState.text;
-      }
-      render() {
-        return <span prop={this.state.text} />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
-    let called = false;
-    instance.setState({}, () => {
-      called = true;
-    });
-    ReactNoop.flush();
-    expect(called).toBe(true);
-  });
-
-  // TODO: Test that callbacks are not lost if an update is preempted.
-
-  it('calls componentWillUnmount after a deletion, even if nested', () => {
-    const ops = [];
-
-    class Bar extends React.Component {
-      componentWillUnmount() {
-        ops.push(this.props.name);
-      }
-      render() {
-        return <span />;
-      }
-    }
-
-    class Wrapper extends React.Component {
-      componentWillUnmount() {
-        ops.push('Wrapper');
-      }
-      render() {
-        return <Bar name={this.props.name} />;
-      }
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          {props.show
-            ? [
-                <Bar key="a" name="A" />,
-                <Wrapper key="b" name="B" />,
-                <div key="cd">
-                  <Bar name="C" />
-                  <Wrapper name="D" />,
-                </div>,
-                [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
-              ]
-            : []}
-          <div>{props.show ? <Bar key="g" name="G" /> : null}</div>
-          <Bar name="this should not unmount" />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo show={true} />);
-    ReactNoop.flush();
-    expect(ops).toEqual([]);
-
-    ReactNoop.render(<Foo show={false} />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      'A',
-      'Wrapper',
-      'B',
-      'C',
-      'Wrapper',
-      'D',
-      'E',
-      'F',
-      'G',
-    ]);
-  });
-
-  it('calls componentDidMount/Update after insertion/update', () => {
-    let ops = [];
-
-    class Bar extends React.Component {
-      componentDidMount() {
-        ops.push('mount:' + this.props.name);
-      }
-      componentDidUpdate() {
-        ops.push('update:' + this.props.name);
-      }
-      render() {
-        return <span />;
-      }
-    }
-
-    class Wrapper extends React.Component {
-      componentDidMount() {
-        ops.push('mount:wrapper-' + this.props.name);
-      }
-      componentDidUpdate() {
-        ops.push('update:wrapper-' + this.props.name);
-      }
-      render() {
-        return <Bar name={this.props.name} />;
-      }
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <Bar key="a" name="A" />
-          <Wrapper key="b" name="B" />
-          <div key="cd">
-            <Bar name="C" />
-            <Wrapper name="D" />
-          </div>
-          {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
-          <div>
-            <Bar key="g" name="G" />
-          </div>
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      'mount:A',
-      'mount:B',
-      'mount:wrapper-B',
-      'mount:C',
-      'mount:D',
-      'mount:wrapper-D',
-      'mount:E',
-      'mount:F',
-      'mount:G',
-    ]);
-
-    ops = [];
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      'update:A',
-      'update:B',
-      'update:wrapper-B',
-      'update:C',
-      'update:D',
-      'update:wrapper-D',
-      'update:E',
-      'update:F',
-      'update:G',
-    ]);
-  });
-
-  it('invokes ref callbacks after insertion/update/unmount', () => {
-    let classInstance = null;
-
-    let ops = [];
-
-    class ClassComponent extends React.Component {
-      render() {
-        classInstance = this;
-        return <span />;
-      }
-    }
-
-    function FunctionalComponent(props) {
-      return <span />;
-    }
-
-    function Foo(props) {
-      return props.show ? (
-        <div>
-          <ClassComponent ref={n => ops.push(n)} />
-          <FunctionalComponent ref={n => ops.push(n)} />
-          <div ref={n => ops.push(n)} />
-        </div>
-      ) : null;
-    }
-
-    ReactNoop.render(<Foo show={true} />);
-    expect(ReactNoop.flush).toWarnDev(
-      'Warning: Stateless function components cannot be given refs. ' +
-        'Attempts to access this ref will fail.\n\nCheck the render method ' +
-        'of `Foo`.\n' +
-        '    in FunctionalComponent (at **)\n' +
-        '    in div (at **)\n' +
-        '    in Foo (at **)',
-    );
-    expect(ops).toEqual([
-      classInstance,
-      // no call for functional components
-      div(),
-    ]);
-
-    ops = [];
-
-    // Refs that switch function instances get reinvoked
-    ReactNoop.render(<Foo show={true} />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      // detach all refs that switched handlers first.
-      null,
-      null,
-      // reattach as a separate phase
-      classInstance,
-      div(),
-    ]);
-
-    ops = [];
-
-    ReactNoop.render(<Foo show={false} />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      // unmount
-      null,
-      null,
-    ]);
-  });
-
-  // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
-  // expected way for aborted and resumed render life-cycles.
-
-  it('supports string refs', () => {
-    let fooInstance = null;
-
-    class Bar extends React.Component {
-      componentDidMount() {
-        this.test = 'test';
-      }
-      render() {
-        return <div />;
-      }
-    }
-
-    class Foo extends React.Component {
-      render() {
-        fooInstance = this;
-        return <Bar ref="bar" />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    expect(fooInstance.refs.bar.test).toEqual('test');
-  });
-});

commit 147bdef11bbeb8f4aef18c56d53ec1591fce8653
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Apr 8 20:54:54 2020 -0700

    Port more tests to the Scheduler.unstable_yieldValue pattern and drop internal.js (#18549)
    
    * Drop the .internal.js suffix on some files that don't need it anymore
    
    * Port some ops patterns to scheduler yield
    
    * Fix triangle test to avoid side-effects in constructor
    
    * Move replaying of setState updaters until after the effect
    
    Otherwise any warnings get silenced if they're deduped.
    
    * Drop .internal.js in more files
    
    * Don't check propTypes on a simple memo component unless it's lazy
    
    Comparing the elementType doesn't work for this because it will never be
    the same for a simple element.
    
    This caused us to double validate these. This was covered up because in
    internal tests this was deduped since they shared the prop types cache
    but since we now inline it, it doesn't get deduped.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
new file mode 100644
index 0000000000..766c1e84b6
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -0,0 +1,1272 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ * @jest-environment node
+ */
+
+'use strict';
+
+let React;
+let ReactNoop;
+let Scheduler;
+
+describe('ReactIncrementalSideEffects', () => {
+  beforeEach(() => {
+    jest.resetModules();
+
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+    Scheduler = require('scheduler');
+  });
+
+  function div(...children) {
+    children = children.map(c =>
+      typeof c === 'string' ? {text: c, hidden: false} : c,
+    );
+    return {type: 'div', children, prop: undefined, hidden: false};
+  }
+
+  function span(prop) {
+    return {type: 'span', children: [], prop, hidden: false};
+  }
+
+  function text(t) {
+    return {text: t, hidden: false};
+  }
+
+  it('can update child nodes of a host instance', () => {
+    function Bar(props) {
+      return <span>{props.text}</span>;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World' ? <Bar text={props.text} /> : null}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span())]);
+
+    ReactNoop.render(<Foo text="World" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span(), span())]);
+  });
+
+  it('can update child nodes of a fragment', function() {
+    function Bar(props) {
+      return <span>{props.text}</span>;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World'
+            ? [<Bar key="a" text={props.text} />, <div key="b" />]
+            : props.text === 'Hi'
+            ? [<div key="b" />, <Bar key="a" text={props.text} />]
+            : null}
+          <span prop="test" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span(), span('test'))]);
+
+    ReactNoop.render(<Foo text="World" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(), span(), div(), span('test')),
+    ]);
+
+    ReactNoop.render(<Foo text="Hi" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(), div(), span(), span('test')),
+    ]);
+  });
+
+  it('can update child nodes rendering into text nodes', function() {
+    function Bar(props) {
+      return props.text;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar text={props.text} />
+          {props.text === 'World'
+            ? [<Bar key="a" text={props.text} />, '!']
+            : null}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div('Hello')]);
+
+    ReactNoop.render(<Foo text="World" />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')]);
+  });
+
+  it('can deletes children either components, host or text', function() {
+    function Bar(props) {
+      return <span prop={props.children} />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.show
+            ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World']
+            : []}
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(), span('Hello'), 'World'),
+    ]);
+
+    ReactNoop.render(<Foo show={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('can delete a child that changes type - implicit keys', function() {
+    let unmounted = false;
+
+    class ClassComponent extends React.Component {
+      componentWillUnmount() {
+        unmounted = true;
+      }
+      render() {
+        return <span prop="Class" />;
+      }
+    }
+
+    function FunctionComponent(props) {
+      return <span prop="Function" />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.useClass ? (
+            <ClassComponent />
+          ) : props.useFunction ? (
+            <FunctionComponent />
+          ) : props.useText ? (
+            'Text'
+          ) : null}
+          Trail
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo useClass={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+
+    expect(unmounted).toBe(false);
+
+    ReactNoop.render(<Foo useFunction={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+
+    expect(unmounted).toBe(true);
+
+    ReactNoop.render(<Foo useText={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div('Text', 'Trail')]);
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+  });
+
+  it('can delete a child that changes type - explicit keys', function() {
+    let unmounted = false;
+
+    class ClassComponent extends React.Component {
+      componentWillUnmount() {
+        unmounted = true;
+      }
+      render() {
+        return <span prop="Class" />;
+      }
+    }
+
+    function FunctionComponent(props) {
+      return <span prop="Function" />;
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.useClass ? (
+            <ClassComponent key="a" />
+          ) : props.useFunction ? (
+            <FunctionComponent key="a" />
+          ) : null}
+          Trail
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo useClass={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+
+    expect(unmounted).toBe(false);
+
+    ReactNoop.render(<Foo useFunction={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+
+    expect(unmounted).toBe(true);
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+  });
+
+  it('can delete a child when it unmounts inside a portal', () => {
+    function Bar(props) {
+      return <span prop={props.children} />;
+    }
+
+    const portalContainer = ReactNoop.getOrCreateRootContainer(
+      'portalContainer',
+    );
+    function Foo(props) {
+      return ReactNoop.createPortal(
+        props.show ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'] : [],
+        portalContainer,
+        null,
+      );
+    }
+
+    ReactNoop.render(
+      <div>
+        <Foo show={true} />
+      </div>,
+    );
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([
+      div(),
+      span('Hello'),
+      text('World'),
+    ]);
+
+    ReactNoop.render(
+      <div>
+        <Foo show={false} />
+      </div>,
+    );
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+
+    ReactNoop.render(
+      <div>
+        <Foo show={true} />
+      </div>,
+    );
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([
+      div(),
+      span('Hello'),
+      text('World'),
+    ]);
+
+    ReactNoop.render(null);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+
+    ReactNoop.render(<Foo show={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+
+    ReactNoop.render(<Foo show={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([
+      div(),
+      span('Hello'),
+      text('World'),
+    ]);
+
+    ReactNoop.render(null);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+  });
+
+  it('can delete a child when it unmounts with a portal', () => {
+    function Bar(props) {
+      return <span prop={props.children} />;
+    }
+
+    const portalContainer = ReactNoop.getOrCreateRootContainer(
+      'portalContainer',
+    );
+    function Foo(props) {
+      return ReactNoop.createPortal(
+        [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'],
+        portalContainer,
+        null,
+      );
+    }
+
+    ReactNoop.render(
+      <div>
+        <Foo />
+      </div>,
+    );
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([
+      div(),
+      span('Hello'),
+      text('World'),
+    ]);
+
+    ReactNoop.render(null);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([
+      div(),
+      span('Hello'),
+      text('World'),
+    ]);
+
+    ReactNoop.render(null);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+  });
+
+  it('does not update child nodes if a flush is aborted', () => {
+    function Bar(props) {
+      Scheduler.unstable_yieldValue('Bar');
+      return <span prop={props.text} />;
+    }
+
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return (
+        <div>
+          <div>
+            <Bar text={props.text} />
+            {props.text === 'Hello' ? <Bar text={props.text} /> : null}
+          </div>
+          <Bar text="Yo" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="Hello" />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar']);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('Hello')), span('Yo')),
+    ]);
+
+    ReactNoop.render(<Foo text="World" />);
+
+    // Flush some of the work without committing
+    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar']);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(div(span('Hello'), span('Hello')), span('Yo')),
+    ]);
+  });
+
+  it('preserves a previously rendered node when deprioritized', () => {
+    function Middle(props) {
+      Scheduler.unstable_yieldValue('Middle');
+      return <span prop={props.children} />;
+    }
+
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return (
+        <div>
+          <div hidden={true}>
+            <Middle>{props.text}</Middle>
+          </div>
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo text="foo" />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Middle']);
+
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        <div hidden={true}>
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    ReactNoop.render(<Foo text="bar" />, () =>
+      Scheduler.unstable_yieldValue('commit'),
+    );
+    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        <div hidden={true}>
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    expect(Scheduler).toFlushAndYield(['Middle']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        <div hidden={true}>
+          <span prop="bar" />
+        </div>
+      </div>,
+    );
+  });
+
+  it('can reuse side-effects after being preempted', () => {
+    function Bar(props) {
+      Scheduler.unstable_yieldValue('Bar');
+      return <span prop={props.children} />;
+    }
+
+    const middleContent = (
+      <div>
+        <Bar>Hello</Bar>
+        <Bar>World</Bar>
+      </div>
+    );
+
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return (
+        <div hidden={true}>
+          {props.step === 0 ? (
+            <div>
+              <Bar>Hi</Bar>
+              <Bar>{props.text}</Bar>
+            </div>
+          ) : (
+            middleContent
+          )}
+        </div>
+      );
+    }
+
+    // Init
+    ReactNoop.render(<Foo text="foo" step={0} />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar']);
+
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hi" />
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    // Make a quick update which will schedule low priority work to
+    // update the middle content.
+    ReactNoop.render(<Foo text="bar" step={1} />, () =>
+      Scheduler.unstable_yieldValue('commit'),
+    );
+    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit', 'Bar']);
+
+    // The tree remains unchanged.
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hi" />
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    // The first Bar has already completed its update but we'll interrupt it to
+    // render some higher priority work. The middle content will bailout so
+    // it remains untouched which means that it should reuse it next time.
+    ReactNoop.render(<Foo text="foo" step={1} />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar']);
+
+    // Since we did nothing to the middle subtree during the interruption,
+    // we should be able to reuse the reconciliation work that we already did
+    // without restarting. The side-effects should still be replayed.
+
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hello" />
+          <span prop="World" />
+        </div>
+      </div>,
+    );
+  });
+
+  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.children !== nextProps.children;
+      }
+      render() {
+        Scheduler.unstable_yieldValue('Bar');
+        return <span prop={this.props.children} />;
+      }
+    }
+
+    class Content extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.step !== nextProps.step;
+      }
+      render() {
+        Scheduler.unstable_yieldValue('Content');
+        return (
+          <div>
+            <Bar>{this.props.step === 0 ? 'Hi' : 'Hello'}</Bar>
+            <Bar>{this.props.step === 0 ? this.props.text : 'World'}</Bar>
+          </div>
+        );
+      }
+    }
+
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return (
+        <div hidden={true}>
+          <Content step={props.step} text={props.text} />
+        </div>
+      );
+    }
+
+    // Init
+    ReactNoop.render(<Foo text="foo" step={0} />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar']);
+
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hi" />
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    // Make a quick update which will schedule low priority work to
+    // update the middle content.
+    ReactNoop.render(<Foo text="bar" step={1} />);
+    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Content', 'Bar']);
+
+    // The tree remains unchanged.
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hi" />
+          <span prop="foo" />
+        </div>
+      </div>,
+    );
+
+    // The first Bar has already completed its update but we'll interrupt it to
+    // render some higher priority work. The middle content will bailout so
+    // it remains untouched which means that it should reuse it next time.
+    ReactNoop.render(<Foo text="foo" step={1} />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar']);
+
+    // Since we did nothing to the middle subtree during the interruption,
+    // we should be able to reuse the reconciliation work that we already did
+    // without restarting. The side-effects should still be replayed.
+
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <div>
+          <span prop="Hello" />
+          <span prop="World" />
+        </div>
+      </div>,
+    );
+  });
+
+  it('can update a completed tree before it has a chance to commit', () => {
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return <span prop={props.step} />;
+    }
+    ReactNoop.render(<Foo step={1} />);
+    // This should be just enough to complete the tree without committing it
+    expect(Scheduler).toFlushAndYieldThrough(['Foo']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
+    // To confirm, perform one more unit of work. The tree should now
+    // be flushed.
+    ReactNoop.flushNextYield();
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
+
+    ReactNoop.render(<Foo step={2} />);
+    // This should be just enough to complete the tree without committing it
+    expect(Scheduler).toFlushAndYieldThrough(['Foo']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
+    // This time, before we commit the tree, we update the root component with
+    // new props
+    ReactNoop.render(<Foo step={3} />);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
+    // Now let's commit. We already had a commit that was pending, which will
+    // render 2.
+    ReactNoop.flushNextYield();
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />);
+    // If we flush the rest of the work, we should get another commit that
+    // renders 3. If it renders 2 again, that means an update was dropped.
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
+  });
+
+  it('updates a child even though the old props is empty', () => {
+    function Foo(props) {
+      return (
+        <div hidden={true}>
+          <span prop={1} />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div hidden={true}>
+        <span prop={1} />
+      </div>,
+    );
+  });
+
+  xit('can defer side-effects and resume them later on', () => {
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        return <span prop={this.props.idx} />;
+      }
+    }
+    function Foo(props) {
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx + 1} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    ReactNoop.flushDeferredPri(40 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(0),
+        div(/*the spans are down-prioritized and not rendered yet*/),
+      ),
+    ]);
+    ReactNoop.render(<Foo tick={1} idx={0} />);
+    ReactNoop.flushDeferredPri(35 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(1), div(/*still not rendered yet*/)),
+    ]);
+    ReactNoop.flushDeferredPri(30 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(1),
+        div(
+          // Now we had enough time to finish the spans.
+          span(0),
+          span(1),
+        ),
+      ),
+    ]);
+    const innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
+    ReactNoop.render(<Foo tick={2} idx={1} />);
+    ReactNoop.flushDeferredPri(30 + 25);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(2),
+        div(
+          // Still same old numbers.
+          span(0),
+          span(1),
+        ),
+      ),
+    ]);
+    ReactNoop.render(<Foo tick={3} idx={1} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // New numbers.
+          span(1),
+          span(2),
+        ),
+      ),
+    ]);
+
+    const innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
+    // This should have been an update to an existing instance, not recreation.
+    // We verify that by ensuring that the child instance was the same as
+    // before.
+    expect(innerSpanA).toBe(innerSpanB);
+  });
+
+  xit('can defer side-effects and reuse them later - complex', function() {
+    let ops = [];
+
+    class Bar extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        ops.push('Bar');
+        return <span prop={this.props.idx} />;
+      }
+    }
+    class Baz extends React.Component {
+      shouldComponentUpdate(nextProps) {
+        return this.props.idx !== nextProps.idx;
+      }
+      render() {
+        ops.push('Baz');
+        return [
+          <Bar key="a" idx={this.props.idx} />,
+          <Bar key="b" idx={this.props.idx} />,
+        ];
+      }
+    }
+    function Foo(props) {
+      ops.push('Foo');
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Baz idx={props.idx} />
+            <Baz idx={props.idx} />
+            <Baz idx={props.idx} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    ReactNoop.flushDeferredPri(65 + 5);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(0),
+        div(/*the spans are down-prioritized and not rendered yet*/),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Foo', 'Baz', 'Bar']);
+    ops = [];
+
+    ReactNoop.render(<Foo tick={1} idx={0} />);
+    ReactNoop.flushDeferredPri(70);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(span(1), div(/*still not rendered yet*/)),
+    ]);
+
+    expect(ops).toEqual(['Foo']);
+    ops = [];
+
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(1),
+        div(
+          // Now we had enough time to finish the spans.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar']);
+    ops = [];
+
+    // Now we're going to update the index but we'll only let it finish half
+    // way through.
+    ReactNoop.render(<Foo tick={2} idx={1} />);
+    ReactNoop.flushDeferredPri(95);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(2),
+        div(
+          // Still same old numbers.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    // We let it finish half way through. That means we'll have one fully
+    // completed Baz, one half-way completed Baz and one fully incomplete Baz.
+    expect(ops).toEqual(['Foo', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar']);
+    ops = [];
+
+    // We'll update again, without letting the new index update yet. Only half
+    // way through.
+    ReactNoop.render(<Foo tick={3} idx={1} />);
+    ReactNoop.flushDeferredPri(50);
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // Old numbers.
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+          span(0),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Foo']);
+    ops = [];
+
+    // We should now be able to reuse some of the work we've already done
+    // and replay those side-effects.
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([
+      div(
+        span(3),
+        div(
+          // New numbers.
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+          span(1),
+        ),
+      ),
+    ]);
+
+    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
+  });
+
+  it('deprioritizes setStates that happens within a deprioritized tree', () => {
+    const barInstances = [];
+
+    class Bar extends React.Component {
+      constructor() {
+        super();
+        this.state = {active: false};
+      }
+      activate() {
+        this.setState({active: true});
+      }
+      render() {
+        barInstances.push(this);
+        Scheduler.unstable_yieldValue('Bar');
+        return <span prop={this.state.active ? 'X' : this.props.idx} />;
+      }
+    }
+    function Foo(props) {
+      Scheduler.unstable_yieldValue('Foo');
+      return (
+        <div>
+          <span prop={props.tick} />
+          <div hidden={true}>
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx} />
+            <Bar idx={props.idx} />
+          </div>
+        </div>
+      );
+    }
+    ReactNoop.render(<Foo tick={0} idx={0} />);
+    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        <span prop={0} />
+        <div hidden={true}>
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+        </div>
+      </div>,
+    );
+
+    ReactNoop.render(<Foo tick={1} idx={1} />);
+    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar', 'Bar']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        {/* Updated */}
+        <span prop={1} />
+        <div hidden={true}>
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+        </div>
+      </div>,
+    );
+
+    barInstances[0].activate();
+
+    // This should not be enough time to render the content of all the hidden
+    // items. Including the set state since that is deprioritized.
+    // ReactNoop.flushDeferredPri(35);
+    expect(Scheduler).toFlushAndYieldThrough(['Bar']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        {/* Updated */}
+        <span prop={1} />
+        <div hidden={true}>
+          {/* Still not updated */}
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+        </div>
+      </div>,
+    );
+
+    // However, once we render fully, we will have enough time to finish it all
+    // at once.
+    expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+    expect(ReactNoop.getChildrenAsJSX()).toEqual(
+      <div>
+        <span prop={1} />
+        <div hidden={true}>
+          {/* Now we had enough time to finish the spans. */}
+          <span prop="X" />
+          <span prop={1} />
+          <span prop={1} />
+        </div>
+      </div>,
+    );
+  });
+  // TODO: Test that side-effects are not cut off when a work in progress node
+  // moves to "current" without flushing due to having lower priority. Does this
+  // even happen? Maybe a child doesn't get processed because it is lower prio?
+
+  it('calls callback after update is flushed', () => {
+    let instance;
+    class Foo extends React.Component {
+      constructor() {
+        super();
+        instance = this;
+        this.state = {text: 'foo'};
+      }
+      render() {
+        return <span prop={this.state.text} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    let called = false;
+    instance.setState({text: 'bar'}, () => {
+      expect(ReactNoop.getChildren()).toEqual([span('bar')]);
+      called = true;
+    });
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(called).toBe(true);
+  });
+
+  it('calls setState callback even if component bails out', () => {
+    let instance;
+    class Foo extends React.Component {
+      constructor() {
+        super();
+        instance = this;
+        this.state = {text: 'foo'};
+      }
+      shouldComponentUpdate(nextProps, nextState) {
+        return this.state.text !== nextState.text;
+      }
+      render() {
+        return <span prop={this.state.text} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    let called = false;
+    instance.setState({}, () => {
+      called = true;
+    });
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(called).toBe(true);
+  });
+
+  // TODO: Test that callbacks are not lost if an update is preempted.
+
+  it('calls componentWillUnmount after a deletion, even if nested', () => {
+    const ops = [];
+
+    class Bar extends React.Component {
+      componentWillUnmount() {
+        ops.push(this.props.name);
+      }
+      render() {
+        return <span />;
+      }
+    }
+
+    class Wrapper extends React.Component {
+      componentWillUnmount() {
+        ops.push('Wrapper');
+      }
+      render() {
+        return <Bar name={this.props.name} />;
+      }
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          {props.show
+            ? [
+                <Bar key="a" name="A" />,
+                <Wrapper key="b" name="B" />,
+                <div key="cd">
+                  <Bar name="C" />
+                  <Wrapper name="D" />,
+                </div>,
+                [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
+              ]
+            : []}
+          <div>{props.show ? <Bar key="g" name="G" /> : null}</div>
+          <Bar name="this should not unmount" />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([]);
+
+    ReactNoop.render(<Foo show={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([
+      'A',
+      'Wrapper',
+      'B',
+      'C',
+      'Wrapper',
+      'D',
+      'E',
+      'F',
+      'G',
+    ]);
+  });
+
+  it('calls componentDidMount/Update after insertion/update', () => {
+    let ops = [];
+
+    class Bar extends React.Component {
+      componentDidMount() {
+        ops.push('mount:' + this.props.name);
+      }
+      componentDidUpdate() {
+        ops.push('update:' + this.props.name);
+      }
+      render() {
+        return <span />;
+      }
+    }
+
+    class Wrapper extends React.Component {
+      componentDidMount() {
+        ops.push('mount:wrapper-' + this.props.name);
+      }
+      componentDidUpdate() {
+        ops.push('update:wrapper-' + this.props.name);
+      }
+      render() {
+        return <Bar name={this.props.name} />;
+      }
+    }
+
+    function Foo(props) {
+      return (
+        <div>
+          <Bar key="a" name="A" />
+          <Wrapper key="b" name="B" />
+          <div key="cd">
+            <Bar name="C" />
+            <Wrapper name="D" />
+          </div>
+          {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
+          <div>
+            <Bar key="g" name="G" />
+          </div>
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([
+      'mount:A',
+      'mount:B',
+      'mount:wrapper-B',
+      'mount:C',
+      'mount:D',
+      'mount:wrapper-D',
+      'mount:E',
+      'mount:F',
+      'mount:G',
+    ]);
+
+    ops = [];
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([
+      'update:A',
+      'update:B',
+      'update:wrapper-B',
+      'update:C',
+      'update:D',
+      'update:wrapper-D',
+      'update:E',
+      'update:F',
+      'update:G',
+    ]);
+  });
+
+  it('invokes ref callbacks after insertion/update/unmount', () => {
+    let classInstance = null;
+
+    let ops = [];
+
+    class ClassComponent extends React.Component {
+      render() {
+        classInstance = this;
+        return <span />;
+      }
+    }
+
+    function FunctionComponent(props) {
+      return <span />;
+    }
+
+    function Foo(props) {
+      return props.show ? (
+        <div>
+          <ClassComponent ref={n => ops.push(n)} />
+          <FunctionComponent ref={n => ops.push(n)} />
+          <div ref={n => ops.push(n)} />
+        </div>
+      ) : null;
+    }
+
+    ReactNoop.render(<Foo show={true} />);
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+      'Warning: Function components cannot be given refs. ' +
+        'Attempts to access this ref will fail. ' +
+        'Did you mean to use React.forwardRef()?\n\n' +
+        'Check the render method ' +
+        'of `Foo`.\n' +
+        '    in FunctionComponent (at **)\n' +
+        '    in div (at **)\n' +
+        '    in Foo (at **)',
+    );
+    expect(ops).toEqual([
+      classInstance,
+      // no call for function components
+      div(),
+    ]);
+
+    ops = [];
+
+    // Refs that switch function instances get reinvoked
+    ReactNoop.render(<Foo show={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([
+      // detach all refs that switched handlers first.
+      null,
+      null,
+      // reattach as a separate phase
+      classInstance,
+      div(),
+    ]);
+
+    ops = [];
+
+    ReactNoop.render(<Foo show={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(ops).toEqual([
+      // unmount
+      null,
+      null,
+    ]);
+  });
+
+  // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
+  // expected way for aborted and resumed render life-cycles.
+
+  it('supports string refs', () => {
+    let fooInstance = null;
+
+    class Bar extends React.Component {
+      componentDidMount() {
+        this.test = 'test';
+      }
+      render() {
+        return <div />;
+      }
+    }
+
+    class Foo extends React.Component {
+      render() {
+        fooInstance = this;
+        return <Bar ref="bar" />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+      'Warning: A string ref, "bar", has been found within a strict mode tree.',
+    );
+
+    expect(fooInstance.refs.bar.test).toEqual('test');
+  });
+});

commit 8b9c4d1688333865e702fcd65ad2ab7d83b3c33c
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 11 20:02:08 2020 -0700

    Expose LegacyHidden type and disable <div hidden /> API in new fork (#18891)
    
    * Expose LegacyHidden type
    
    I will use this internally at Facebook to migrate away from
    <div hidden />. The end goal is to migrate to the Offscreen type, but
    that has different semantics. This is an incremental step.
    
    * Disable <div hidden /> API in new fork
    
    Migrates to the unstable_LegacyHidden type instead. The old fork does
    not support the new component type, so I updated the tests to use an
    indirection that picks the correct API. I will remove this once the
    LegacyHidden (and/or Offscreen) type has landed in both implementations.
    
    * Add gated warning for `<div hidden />` API
    
    Only exists so we can detect callers in www and migrate them to the new
    API. Should not visible to anyone outside React Core team.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 766c1e84b6..824c8577e5 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -38,6 +38,25 @@ describe('ReactIncrementalSideEffects', () => {
     return {text: t, hidden: false};
   }
 
+  // TODO: Delete this once new API exists in both forks
+  function LegacyHiddenDiv({hidden, children, ...props}) {
+    if (gate(flags => flags.new)) {
+      return (
+        <div hidden={hidden} {...props}>
+          <React.unstable_LegacyHidden mode={hidden ? 'hidden' : 'visible'}>
+            {children}
+          </React.unstable_LegacyHidden>
+        </div>
+      );
+    } else {
+      return (
+        <div hidden={hidden} {...props}>
+          {children}
+        </div>
+      );
+    }
+  }
+
   it('can update child nodes of a host instance', () => {
     function Bar(props) {
       return <span>{props.text}</span>;
@@ -405,6 +424,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
+  // @gate enableLegacyHiddenType
   it('preserves a previously rendered node when deprioritized', () => {
     function Middle(props) {
       Scheduler.unstable_yieldValue('Middle');
@@ -415,9 +435,9 @@ describe('ReactIncrementalSideEffects', () => {
       Scheduler.unstable_yieldValue('Foo');
       return (
         <div>
-          <div hidden={true}>
+          <LegacyHiddenDiv hidden={true}>
             <Middle>{props.text}</Middle>
-          </div>
+          </LegacyHiddenDiv>
         </div>
       );
     }
@@ -455,6 +475,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
+  // @gate enableLegacyHiddenType
   it('can reuse side-effects after being preempted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -471,7 +492,7 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return (
-        <div hidden={true}>
+        <LegacyHiddenDiv hidden={true}>
           {props.step === 0 ? (
             <div>
               <Bar>Hi</Bar>
@@ -480,7 +501,7 @@ describe('ReactIncrementalSideEffects', () => {
           ) : (
             middleContent
           )}
-        </div>
+        </LegacyHiddenDiv>
       );
     }
 
@@ -534,6 +555,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
+  // @gate enableLegacyHiddenType
   it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -563,9 +585,9 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return (
-        <div hidden={true}>
+        <LegacyHiddenDiv hidden={true}>
           <Content step={props.step} text={props.text} />
-        </div>
+        </LegacyHiddenDiv>
       );
     }
 
@@ -649,12 +671,13 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
+  // @gate enableLegacyHiddenType
   it('updates a child even though the old props is empty', () => {
     function Foo(props) {
       return (
-        <div hidden={true}>
+        <LegacyHiddenDiv hidden={true}>
           <span prop={1} />
-        </div>
+        </LegacyHiddenDiv>
       );
     }
 
@@ -888,6 +911,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
   });
 
+  // @gate enableLegacyHiddenType
   it('deprioritizes setStates that happens within a deprioritized tree', () => {
     const barInstances = [];
 
@@ -910,11 +934,11 @@ describe('ReactIncrementalSideEffects', () => {
       return (
         <div>
           <span prop={props.tick} />
-          <div hidden={true}>
+          <LegacyHiddenDiv hidden={true}>
             <Bar idx={props.idx} />
             <Bar idx={props.idx} />
             <Bar idx={props.idx} />
-          </div>
+          </LegacyHiddenDiv>
         </div>
       );
     }

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 824c8577e5..6acd32d8b8 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -38,23 +38,20 @@ describe('ReactIncrementalSideEffects', () => {
     return {text: t, hidden: false};
   }
 
-  // TODO: Delete this once new API exists in both forks
-  function LegacyHiddenDiv({hidden, children, ...props}) {
-    if (gate(flags => flags.new)) {
-      return (
-        <div hidden={hidden} {...props}>
-          <React.unstable_LegacyHidden mode={hidden ? 'hidden' : 'visible'}>
-            {children}
-          </React.unstable_LegacyHidden>
-        </div>
-      );
-    } else {
-      return (
-        <div hidden={hidden} {...props}>
+  // Note: This is based on a similar component we use in www. We can delete
+  // once the extra div wrapper is no longer neccessary.
+  function LegacyHiddenDiv({children, mode}) {
+    return (
+      <div
+        hidden={
+          mode === 'hidden' ? 'unstable-do-not-use-legacy-hidden' : undefined
+        }>
+        <React.unstable_LegacyHidden
+          mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
           {children}
-        </div>
-      );
-    }
+        </React.unstable_LegacyHidden>
+      </div>
+    );
   }
 
   it('can update child nodes of a host instance', () => {
@@ -424,7 +421,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  // @gate enableLegacyHiddenType
+  // @gate experimental
   it('preserves a previously rendered node when deprioritized', () => {
     function Middle(props) {
       Scheduler.unstable_yieldValue('Middle');
@@ -435,7 +432,7 @@ describe('ReactIncrementalSideEffects', () => {
       Scheduler.unstable_yieldValue('Foo');
       return (
         <div>
-          <LegacyHiddenDiv hidden={true}>
+          <LegacyHiddenDiv mode="hidden">
             <Middle>{props.text}</Middle>
           </LegacyHiddenDiv>
         </div>
@@ -475,7 +472,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate enableLegacyHiddenType
+  // @gate experimental
   it('can reuse side-effects after being preempted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -492,7 +489,7 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return (
-        <LegacyHiddenDiv hidden={true}>
+        <LegacyHiddenDiv mode="hidden">
           {props.step === 0 ? (
             <div>
               <Bar>Hi</Bar>
@@ -555,7 +552,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate enableLegacyHiddenType
+  // @gate experimental
   it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -585,7 +582,7 @@ describe('ReactIncrementalSideEffects', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return (
-        <LegacyHiddenDiv hidden={true}>
+        <LegacyHiddenDiv mode="hidden">
           <Content step={props.step} text={props.text} />
         </LegacyHiddenDiv>
       );
@@ -671,11 +668,11 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
-  // @gate enableLegacyHiddenType
+  // @gate experimental
   it('updates a child even though the old props is empty', () => {
     function Foo(props) {
       return (
-        <LegacyHiddenDiv hidden={true}>
+        <LegacyHiddenDiv mode="hidden">
           <span prop={1} />
         </LegacyHiddenDiv>
       );
@@ -911,7 +908,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
   });
 
-  // @gate enableLegacyHiddenType
+  // @gate experimental
   it('deprioritizes setStates that happens within a deprioritized tree', () => {
     const barInstances = [];
 
@@ -934,7 +931,7 @@ describe('ReactIncrementalSideEffects', () => {
       return (
         <div>
           <span prop={props.tick} />
-          <LegacyHiddenDiv hidden={true}>
+          <LegacyHiddenDiv mode="hidden">
             <Bar idx={props.idx} />
             <Bar idx={props.idx} />
             <Bar idx={props.idx} />

commit 103ed08c46198d01119ef35c37d78c6bc89705db
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jun 12 12:57:20 2020 -0700

    Remove shouldDeprioritizeSubtree from host config (#19124)
    
    No longer being used.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 6acd32d8b8..bcd35fb264 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -42,10 +42,7 @@ describe('ReactIncrementalSideEffects', () => {
   // once the extra div wrapper is no longer neccessary.
   function LegacyHiddenDiv({children, mode}) {
     return (
-      <div
-        hidden={
-          mode === 'hidden' ? 'unstable-do-not-use-legacy-hidden' : undefined
-        }>
+      <div hidden={mode === 'hidden'}>
         <React.unstable_LegacyHidden
           mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
           {children}

commit 30b47103d4354d9187dc0f1fb804855a5208ca9f
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 15 19:59:44 2020 -0400

    Fix spelling errors and typos (#19138)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index bcd35fb264..3939aa7e70 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -39,7 +39,7 @@ describe('ReactIncrementalSideEffects', () => {
   }
 
   // Note: This is based on a similar component we use in www. We can delete
-  // once the extra div wrapper is no longer neccessary.
+  // once the extra div wrapper is no longer necessary.
   function LegacyHiddenDiv({children, mode}) {
     return (
       <div hidden={mode === 'hidden'}>

commit 933880b4544a83ce54c8a47f348effe725a58843
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Apr 9 19:50:09 2021 -0400

    Make time-slicing opt-in (#21072)
    
    * Add enableSyncDefaultUpdates feature flag
    
    * Add enableSyncDefaultUpdates implementation
    
    * Fix tests
    
    * Switch feature flag to true by default
    
    * Finish concurrent render whenever for non-sync lanes
    
    * Also return DefaultLane with eventLane
    
    * Gate interruption test
    
    * Add continuout native event test
    
    * Fix tests from rebasing main
    
    * Hardcode lanes, remove added export
    
    * Sync forks

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 3939aa7e70..32d4699318 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -384,6 +384,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('does not update child nodes if a flush is aborted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -409,7 +410,13 @@ describe('ReactIncrementalSideEffects', () => {
       div(div(span('Hello'), span('Hello')), span('Yo')),
     ]);
 
-    ReactNoop.render(<Foo text="World" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Foo text="World" />);
+      });
+    } else {
+      ReactNoop.render(<Foo text="World" />);
+    }
 
     // Flush some of the work without committing
     expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar']);
@@ -633,12 +640,19 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('can update a completed tree before it has a chance to commit', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return <span prop={props.step} />;
     }
-    ReactNoop.render(<Foo step={1} />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Foo step={1} />);
+      });
+    } else {
+      ReactNoop.render(<Foo step={1} />);
+    }
     // This should be just enough to complete the tree without committing it
     expect(Scheduler).toFlushAndYieldThrough(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
@@ -647,13 +661,26 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.flushNextYield();
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
-    ReactNoop.render(<Foo step={2} />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Foo step={2} />);
+      });
+    } else {
+      ReactNoop.render(<Foo step={2} />);
+    }
     // This should be just enough to complete the tree without committing it
     expect(Scheduler).toFlushAndYieldThrough(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
-    ReactNoop.render(<Foo step={3} />);
+
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Foo step={3} />);
+      });
+    } else {
+      ReactNoop.render(<Foo step={3} />);
+    }
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // Now let's commit. We already had a commit that was pending, which will
     // render 2.

commit 15fb8c3045064e13e81706a36bf0e4e419803c97
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon May 3 16:57:03 2021 -0400

    createRoot API is no longer strict by default (#21417)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 32d4699318..fd819eeb32 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1308,9 +1308,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
-      'Warning: A string ref, "bar", has been found within a strict mode tree.',
-    );
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(fooInstance.refs.bar.test).toEqual('test');
   });

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index fd819eeb32..bb42fc621f 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -384,7 +384,6 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('does not update child nodes if a flush is aborted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -411,7 +410,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Foo text="World" />);
       });
     } else {
@@ -640,14 +639,13 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('can update a completed tree before it has a chance to commit', () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return <span prop={props.step} />;
     }
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Foo step={1} />);
       });
     } else {
@@ -662,7 +660,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Foo step={2} />);
       });
     } else {
@@ -675,7 +673,7 @@ describe('ReactIncrementalSideEffects', () => {
     // new props
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Foo step={3} />);
       });
     } else {

commit 86715efa23c02dd156e61a4476f28045bb5f4654
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Jun 2 21:03:29 2021 -0400

    Resolve the true entry point during tests (#21505)
    
    * Resolve the entry point for tests the same way builds do
    
    This way the source tests, test the same entry point configuration.
    
    * Gate test selectors on www
    
    These are currently only exposed in www builds
    
    * Gate createEventHandle / useFocus on www
    
    These are enabled in both www variants but not OSS experimental.
    
    * Temporarily disable www-modern entry point
    
    Use the main one that has all the exports until we fix more tests.
    
    * Remove enableCache override that's no longer correct
    
    * Open gates for www
    
    These used to not be covered because they used Cache which wasn't exposed.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index bb42fc621f..f0c6bad863 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -424,7 +424,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('preserves a previously rendered node when deprioritized', () => {
     function Middle(props) {
       Scheduler.unstable_yieldValue('Middle');
@@ -475,7 +475,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('can reuse side-effects after being preempted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -555,7 +555,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -690,7 +690,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('updates a child even though the old props is empty', () => {
     function Foo(props) {
       return (
@@ -930,7 +930,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('deprioritizes setStates that happens within a deprioritized tree', () => {
     const barInstances = [];
 

commit 72a933d2892dac9e5327678b6bd37af8d589bb22
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Mar 9 11:48:03 2022 -0500

    Gate legacy hidden (#24047)
    
    * Gate legacy hidden
    
    * Gate tests
    
    * Remove export from experimental

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index f0c6bad863..e09c866d6d 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -424,7 +424,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  // @gate experimental || www
+  // @gate www
   it('preserves a previously rendered node when deprioritized', () => {
     function Middle(props) {
       Scheduler.unstable_yieldValue('Middle');
@@ -475,7 +475,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate experimental || www
+  // @gate www
   it('can reuse side-effects after being preempted', () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
@@ -555,7 +555,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate experimental || www
+  // @gate www
   it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -690,7 +690,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
-  // @gate experimental || www
+  // @gate www
   it('updates a child even though the old props is empty', () => {
     function Foo(props) {
       return (
@@ -930,7 +930,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
   });
 
-  // @gate experimental || www
+  // @gate www
   it('deprioritizes setStates that happens within a deprioritized tree', () => {
     const barInstances = [];
 

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index e09c866d6d..635e426cd7 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6fb8133ed3aa6b23063375dd345c6e413b05f0fe
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Nov 17 01:15:57 2022 +0100

    Turn on string ref deprecation warning for everybody (not codemoddable) (#25383)
    
    ## Summary
    
    Alternate to https://github.com/facebook/react/pull/25334 without any
    prod runtime changes i.e. the proposed codemod in
    https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-string-refs-and-remove-production-mode-_owner-field
    would not work.
    
    ## How did you test this change?
    
    - [x] CI
    - [x] `yarn test` with and without `warnAboutStringRefs`

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 635e426cd7..6bac75ab30 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -11,6 +11,7 @@
 'use strict';
 
 let React;
+let ReactFeatureFlags;
 let ReactNoop;
 let Scheduler;
 
@@ -19,6 +20,7 @@ describe('ReactIncrementalSideEffects', () => {
     jest.resetModules();
 
     React = require('react');
+    ReactFeatureFlags = require('shared/ReactFeatureFlags');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
   });
@@ -1306,8 +1308,19 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
-
+    expect(() => {
+      expect(Scheduler).toFlushWithoutYielding();
+    }).toErrorDev(
+      ReactFeatureFlags.warnAboutStringRefs
+        ? [
+            'Warning: Component "Foo" contains the string ref "bar". ' +
+              'Support for string refs will be removed in a future major release. ' +
+              'We recommend using useRef() or createRef() instead. ' +
+              'Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\n' +
+              '    in Foo (at **)',
+          ]
+        : [],
+    );
     expect(fooInstance.refs.bar.test).toEqual('test');
   });
 });

commit 0fce6bb498357feb4465859912004b2e20fe7084
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Jan 11 12:19:46 2023 -0500

    [cleanup] remove feature flags warnAboutDefaultPropsOnFunctionComponents and warnAboutStringRefs (#25980)
    
    These feature flags are fully rolled out and easy to clean up. Let's
    remove them!

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 6bac75ab30..1203c9494c 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -11,7 +11,6 @@
 'use strict';
 
 let React;
-let ReactFeatureFlags;
 let ReactNoop;
 let Scheduler;
 
@@ -20,7 +19,6 @@ describe('ReactIncrementalSideEffects', () => {
     jest.resetModules();
 
     React = require('react');
-    ReactFeatureFlags = require('shared/ReactFeatureFlags');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
   });
@@ -1310,17 +1308,13 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.render(<Foo />);
     expect(() => {
       expect(Scheduler).toFlushWithoutYielding();
-    }).toErrorDev(
-      ReactFeatureFlags.warnAboutStringRefs
-        ? [
-            'Warning: Component "Foo" contains the string ref "bar". ' +
-              'Support for string refs will be removed in a future major release. ' +
-              'We recommend using useRef() or createRef() instead. ' +
-              'Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\n' +
-              '    in Foo (at **)',
-          ]
-        : [],
-    );
+    }).toErrorDev([
+      'Warning: Component "Foo" contains the string ref "bar". ' +
+        'Support for string refs will be removed in a future major release. ' +
+        'We recommend using useRef() or createRef() instead. ' +
+        'Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\n' +
+        '    in Foo (at **)',
+    ]);
     expect(fooInstance.refs.bar.test).toEqual('test');
   });
 });

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 1203c9494c..bb5f2e5970 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -74,7 +74,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren()).toEqual([div(span(), span())]);
   });
 
-  it('can update child nodes of a fragment', function() {
+  it('can update child nodes of a fragment', function () {
     function Bar(props) {
       return <span>{props.text}</span>;
     }
@@ -110,7 +110,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  it('can update child nodes rendering into text nodes', function() {
+  it('can update child nodes rendering into text nodes', function () {
     function Bar(props) {
       return props.text;
     }
@@ -135,7 +135,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')]);
   });
 
-  it('can deletes children either components, host or text', function() {
+  it('can deletes children either components, host or text', function () {
     function Bar(props) {
       return <span prop={props.children} />;
     }
@@ -161,7 +161,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('can delete a child that changes type - implicit keys', function() {
+  it('can delete a child that changes type - implicit keys', function () {
     let unmounted = false;
 
     class ClassComponent extends React.Component {
@@ -213,7 +213,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
   });
 
-  it('can delete a child that changes type - explicit keys', function() {
+  it('can delete a child that changes type - explicit keys', function () {
     let unmounted = false;
 
     class ClassComponent extends React.Component {
@@ -264,9 +264,8 @@ describe('ReactIncrementalSideEffects', () => {
       return <span prop={props.children} />;
     }
 
-    const portalContainer = ReactNoop.getOrCreateRootContainer(
-      'portalContainer',
-    );
+    const portalContainer =
+      ReactNoop.getOrCreateRootContainer('portalContainer');
     function Foo(props) {
       return ReactNoop.createPortal(
         props.show ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'] : [],
@@ -340,9 +339,8 @@ describe('ReactIncrementalSideEffects', () => {
       return <span prop={props.children} />;
     }
 
-    const portalContainer = ReactNoop.getOrCreateRootContainer(
-      'portalContainer',
-    );
+    const portalContainer =
+      ReactNoop.getOrCreateRootContainer('portalContainer');
     function Foo(props) {
       return ReactNoop.createPortal(
         [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'],
@@ -786,7 +784,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(innerSpanA).toBe(innerSpanB);
   });
 
-  xit('can defer side-effects and reuse them later - complex', function() {
+  xit('can defer side-effects and reuse them later - complex', function () {
     let ops = [];
 
     class Bar extends React.Component {

commit 3ff1540e9bbe30aae52e2c9ab61c843bd0c94237
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Feb 9 11:54:35 2023 +0100

    Prefer JSX in ReactNoop assertions (to combat out-of-memory test runs) (#26127)
    
    ## Summary
    
    Prefer `getChildrenAsJSX` or `toMatchRenderedOutput` over `getChildren`.
    Use `dangerouslyGetChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    Prefer `getPendingChildrenAsJSX` over `getPendingChildren`. Use
    `dangerouslyGetPendingChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    `ReactNoop.getChildren` contains the fibers as non-enumerable
    properties. If you pass the children to `toEqual` and have a mismatch,
    Jest performance is very poor (to the point of causing out-of-memory
    crashes e.g.
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624297/parallel-runs/5?filterBy=ALL&invite=true#step-106-27).
    Mismatches can sometimes be intended e.g. on gated tests.
    
    Instead, I converted almost all of the `toEqual` assertions to
    `toMatchRenderedOutput` assertions or compare the JSX instead. For
    ReactNoopPersistent we still use `getChildren` since we have assertions
    on referential equality. `toMatchRenderedOutput` is more accurate in
    some instances anyway. I highlighted some of those more accurate
    assertions in review-comments.
    
    ## How did you test this change?
    
    - [x] `CIRCLE_NODE_TOTAL=20 CIRCLE_NODE_INDEX=5 yarn test
    -r=experimental --env=development --ci`: Can take up to 350s (and use up
    to 7GB of memory) on `main` but 11s on this branch
    - [x] No more slow `yarn test` parallel runs of `yarn_test` jobs (the
    steps in these runs should take <1min but sometimes they take 3min and
    end with OOM like
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624258/parallel-runs/5?filterBy=ALL:
    Looks good with a sample size of 1
    https://app.circleci.com/pipelines/github/facebook/react/38110/workflows/745109a2-b86b-429f-8c01-9b23a245417a/jobs/624651

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index bb5f2e5970..3e4cd2e4f5 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -23,21 +23,6 @@ describe('ReactIncrementalSideEffects', () => {
     Scheduler = require('scheduler');
   });
 
-  function div(...children) {
-    children = children.map(c =>
-      typeof c === 'string' ? {text: c, hidden: false} : c,
-    );
-    return {type: 'div', children, prop: undefined, hidden: false};
-  }
-
-  function span(prop) {
-    return {type: 'span', children: [], prop, hidden: false};
-  }
-
-  function text(t) {
-    return {text: t, hidden: false};
-  }
-
   // Note: This is based on a similar component we use in www. We can delete
   // once the extra div wrapper is no longer necessary.
   function LegacyHiddenDiv({children, mode}) {
@@ -67,11 +52,20 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo text="Hello" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>Hello</span>
+      </div>,
+    );
 
     ReactNoop.render(<Foo text="World" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span(), span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>World</span>
+        <span>World</span>
+      </div>,
+    );
   });
 
   it('can update child nodes of a fragment', function () {
@@ -95,19 +89,34 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo text="Hello" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span(), span('test'))]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>Hello</span>
+        <span prop="test" />
+      </div>,
+    );
 
     ReactNoop.render(<Foo text="World" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(), span(), div(), span('test')),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>World</span>
+        <span>World</span>
+        <div />
+        <span prop="test" />
+      </div>,
+    );
 
     ReactNoop.render(<Foo text="Hi" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(), div(), span(), span('test')),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>Hi</span>
+        <div />
+        <span>Hi</span>
+        <span prop="test" />
+      </div>,
+    );
   });
 
   it('can update child nodes rendering into text nodes', function () {
@@ -128,11 +137,11 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo text="Hello" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div('Hello')]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo text="World" />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>WorldWorld!</div>);
   });
 
   it('can deletes children either components, host or text', function () {
@@ -152,13 +161,17 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo show={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(), span('Hello'), 'World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <div />
+        <span prop="Hello" />
+        World
+      </div>,
+    );
 
     ReactNoop.render(<Foo show={false} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div />);
   });
 
   it('can delete a child that changes type - implicit keys', function () {
@@ -194,23 +207,33 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo useClass={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop="Class" />
+        Trail
+      </div>,
+    );
 
     expect(unmounted).toBe(false);
 
     ReactNoop.render(<Foo useFunction={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop="Function" />
+        Trail
+      </div>,
+    );
 
     expect(unmounted).toBe(true);
 
     ReactNoop.render(<Foo useText={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div('Text', 'Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>TextTrail</div>);
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
   });
 
   it('can delete a child that changes type - explicit keys', function () {
@@ -244,19 +267,29 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo useClass={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop="Class" />
+        Trail
+      </div>,
+    );
 
     expect(unmounted).toBe(false);
 
     ReactNoop.render(<Foo useFunction={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop="Function" />
+        Trail
+      </div>,
+    );
 
     expect(unmounted).toBe(true);
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div('Trail')]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
   });
 
   it('can delete a child when it unmounts inside a portal', () => {
@@ -280,12 +313,14 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([
-      div(),
-      span('Hello'),
-      text('World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(<div />);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
+      <>
+        <div />
+        <span prop="Hello" />
+        World
+      </>,
+    );
 
     ReactNoop.render(
       <div>
@@ -293,8 +328,8 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(<div />);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(
       <div>
@@ -302,36 +337,40 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([
-      div(),
-      span('Hello'),
-      text('World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(<div />);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
+      <>
+        <div />
+        <span prop="Hello" />
+        World
+      </>,
+    );
 
     ReactNoop.render(null);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo show={false} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo show={true} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([
-      div(),
-      span('Hello'),
-      text('World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
+      <>
+        <div />
+        <span prop="Hello" />
+        World
+      </>,
+    );
 
     ReactNoop.render(null);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
   });
 
   it('can delete a child when it unmounts with a portal', () => {
@@ -355,31 +394,35 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([
-      div(),
-      span('Hello'),
-      text('World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(<div />);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
+      <>
+        <div />
+        <span prop="Hello" />
+        World
+      </>,
+    );
 
     ReactNoop.render(null);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([
-      div(),
-      span('Hello'),
-      text('World'),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
+      <>
+        <div />
+        <span prop="Hello" />
+        World
+      </>,
+    );
 
     ReactNoop.render(null);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([]);
-    expect(ReactNoop.getChildren('portalContainer')).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
   });
 
   it('does not update child nodes if a flush is aborted', () => {
@@ -403,9 +446,15 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo text="Hello" />);
     expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar']);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('Hello')), span('Yo')),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <div>
+          <span prop="Hello" />
+          <span prop="Hello" />
+        </div>
+        <span prop="Yo" />
+      </div>,
+    );
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
       React.startTransition(() => {
@@ -417,9 +466,15 @@ describe('ReactIncrementalSideEffects', () => {
 
     // Flush some of the work without committing
     expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar']);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(div(span('Hello'), span('Hello')), span('Yo')),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <div>
+          <span prop="Hello" />
+          <span prop="Hello" />
+        </div>
+        <span prop="Yo" />
+      </div>,
+    );
   });
 
   // @gate www
@@ -729,55 +784,61 @@ describe('ReactIncrementalSideEffects', () => {
     }
     ReactNoop.render(<Foo tick={0} idx={0} />);
     ReactNoop.flushDeferredPri(40 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(0),
-        div(/*the spans are down-prioritized and not rendered yet*/),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={0} />
+        <div />
+      </div>,
+    );
     ReactNoop.render(<Foo tick={1} idx={0} />);
     ReactNoop.flushDeferredPri(35 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(1), div(/*still not rendered yet*/)),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={1} />
+        <div>{/*still not rendered yet*/}</div>
+      </div>,
+    );
     ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(1),
-        div(
-          // Now we had enough time to finish the spans.
-          span(0),
-          span(1),
-        ),
-      ),
-    ]);
-    const innerSpanA = ReactNoop.getChildren()[0].children[1].children[1];
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={1} />
+        <div>
+          {/* Now we had enough time to finish the spans. */}
+          <span prop={0} />
+          <span prop={1} />
+        </div>
+        ,
+      </div>,
+    );
+    const innerSpanA =
+      ReactNoop.dangerouslyGetChildren()[0].children[1].children[1];
     ReactNoop.render(<Foo tick={2} idx={1} />);
     ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(2),
-        div(
-          // Still same old numbers.
-          span(0),
-          span(1),
-        ),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={2} />
+        <div>
+          {/* Still same old numbers. */}
+          <span prop={0} />
+          <span prop={1} />
+        </div>
+      </div>,
+    );
     ReactNoop.render(<Foo tick={3} idx={1} />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // New numbers.
-          span(1),
-          span(2),
-        ),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={3} />
+        <div>
+          {/* New numbers. */}
+          <span prop={1} />
+          <span prop={2} />
+        </div>
+      </div>,
+    );
 
-    const innerSpanB = ReactNoop.getChildren()[0].children[1].children[1];
+    const innerSpanB =
+      ReactNoop.dangerouslyGetChildren()[0].children[1].children[1];
     // This should have been an update to an existing instance, not recreation.
     // We verify that by ensuring that the child instance was the same as
     // before.
@@ -823,39 +884,44 @@ describe('ReactIncrementalSideEffects', () => {
     }
     ReactNoop.render(<Foo tick={0} idx={0} />);
     ReactNoop.flushDeferredPri(65 + 5);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(0),
-        div(/*the spans are down-prioritized and not rendered yet*/),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={0} />
+        {/*the spans are down-prioritized and not rendered yet*/}
+        <div />
+      </div>,
+    );
 
     expect(ops).toEqual(['Foo', 'Baz', 'Bar']);
     ops = [];
 
     ReactNoop.render(<Foo tick={1} idx={0} />);
     ReactNoop.flushDeferredPri(70);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(span(1), div(/*still not rendered yet*/)),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={1} />
+        {/*still not rendered yet*/}
+        <div />
+      </div>,
+    );
 
     expect(ops).toEqual(['Foo']);
     ops = [];
 
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(1),
-        div(
-          // Now we had enough time to finish the spans.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
+    expect(ReactNoop).toMatchRenderedOutput([
+      <div>
+        <span prop={1} />,
+        <div>
+          {/* Now we had enough time to finish the spans. */}
+          <span prop={0} />,
+          <span prop={0} />,
+          <span prop={0} />,
+          <span prop={0} />,
+          <span prop={0} />,
+          <span prop={0} />,
+        </div>
+      </div>,
     ]);
 
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar']);
@@ -865,20 +931,20 @@ describe('ReactIncrementalSideEffects', () => {
     // way through.
     ReactNoop.render(<Foo tick={2} idx={1} />);
     ReactNoop.flushDeferredPri(95);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(2),
-        div(
-          // Still same old numbers.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={2} />,
+        <div>
+          {/* Still same old numbers. */}
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+        </div>
+      </div>,
+    );
 
     // We let it finish half way through. That means we'll have one fully
     // completed Baz, one half-way completed Baz and one fully incomplete Baz.
@@ -889,20 +955,20 @@ describe('ReactIncrementalSideEffects', () => {
     // way through.
     ReactNoop.render(<Foo tick={3} idx={1} />);
     ReactNoop.flushDeferredPri(50);
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // Old numbers.
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-          span(0),
-        ),
-      ),
-    ]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span prop={3} />
+        <div>
+          {/* Old numbers. */}
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+          <span prop={0} />
+        </div>
+      </div>,
+    );
 
     expect(ops).toEqual(['Foo']);
     ops = [];
@@ -910,19 +976,19 @@ describe('ReactIncrementalSideEffects', () => {
     // We should now be able to reuse some of the work we've already done
     // and replay those side-effects.
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([
-      div(
-        span(3),
-        div(
-          // New numbers.
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-          span(1),
-        ),
-      ),
+    expect(ReactNoop).toMatchRenderedOutput([
+      <div>
+        <span prop={3} />,
+        <div>
+          {/* New numbers. */}
+          <span prop={1} />
+          <span prop={1} />
+          <span prop={1} />
+          <span prop={1} />
+          <span prop={1} />
+          <span prop={1} />
+        </div>
+      </div>,
     ]);
 
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
@@ -1039,10 +1105,10 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
     let called = false;
     instance.setState({text: 'bar'}, () => {
-      expect(ReactNoop.getChildren()).toEqual([span('bar')]);
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="bar" />);
       called = true;
     });
     expect(Scheduler).toFlushWithoutYielding();
@@ -1067,7 +1133,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushWithoutYielding();
-    expect(ReactNoop.getChildren()).toEqual([span('foo')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
     let called = false;
     instance.setState({}, () => {
       called = true;
@@ -1253,7 +1319,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual([
       classInstance,
       // no call for function components
-      div(),
+      {type: 'div', children: [], prop: undefined, hidden: false},
     ]);
 
     ops = [];
@@ -1267,7 +1333,7 @@ describe('ReactIncrementalSideEffects', () => {
       null,
       // reattach as a separate phase
       classInstance,
-      div(),
+      {type: 'div', children: [], prop: undefined, hidden: false},
     ]);
 
     ops = [];

commit b2ae9ddb3b497d16a7c27c051da1827d08871138
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Feb 27 14:04:02 2023 -0500

    Cleanup enableSyncDefaultUpdate flag (#26236)
    
    This feature flag is enabled everywhere.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 3e4cd2e4f5..fd1361de82 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -456,13 +456,9 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo text="World" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo text="World" />);
-    }
+    });
 
     // Flush some of the work without committing
     expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar']);
@@ -697,13 +693,9 @@ describe('ReactIncrementalSideEffects', () => {
       Scheduler.unstable_yieldValue('Foo');
       return <span prop={props.step} />;
     }
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={1} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={1} />);
-    }
+    });
     // This should be just enough to complete the tree without committing it
     expect(Scheduler).toFlushAndYieldThrough(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
@@ -712,26 +704,18 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.flushNextYield();
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={2} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={2} />);
-    }
+    });
     // This should be just enough to complete the tree without committing it
     expect(Scheduler).toFlushAndYieldThrough(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={3} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={3} />);
-    }
+    });
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // Now let's commit. We already had a commit that was pending, which will
     // render 2.

commit faacefb4d0167f8d5973672754fe87afc607397b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 21:24:22 2023 -0500

    Codemod tests to waitFor pattern (4/?) (#26302)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index fd1361de82..4c20424e2e 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -13,6 +13,8 @@
 let React;
 let ReactNoop;
 let Scheduler;
+let waitForAll;
+let waitFor;
 
 describe('ReactIncrementalSideEffects', () => {
   beforeEach(() => {
@@ -21,6 +23,10 @@ describe('ReactIncrementalSideEffects', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
   });
 
   // Note: This is based on a similar component we use in www. We can delete
@@ -36,7 +42,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   }
 
-  it('can update child nodes of a host instance', () => {
+  it('can update child nodes of a host instance', async () => {
     function Bar(props) {
       return <span>{props.text}</span>;
     }
@@ -51,7 +57,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo text="Hello" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span>Hello</span>
@@ -59,7 +65,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(<Foo text="World" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span>World</span>
@@ -68,7 +74,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  it('can update child nodes of a fragment', function () {
+  it('can update child nodes of a fragment', async function () {
     function Bar(props) {
       return <span>{props.text}</span>;
     }
@@ -88,7 +94,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo text="Hello" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span>Hello</span>
@@ -97,7 +103,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(<Foo text="World" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span>World</span>
@@ -108,7 +114,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(<Foo text="Hi" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span>Hi</span>
@@ -119,7 +125,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  it('can update child nodes rendering into text nodes', function () {
+  it('can update child nodes rendering into text nodes', async function () {
     function Bar(props) {
       return props.text;
     }
@@ -136,15 +142,15 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo text="Hello" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo text="World" />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>WorldWorld!</div>);
   });
 
-  it('can deletes children either components, host or text', function () {
+  it('can deletes children either components, host or text', async function () {
     function Bar(props) {
       return <span prop={props.children} />;
     }
@@ -160,7 +166,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo show={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <div />
@@ -170,11 +176,11 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(<Foo show={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div />);
   });
 
-  it('can delete a child that changes type - implicit keys', function () {
+  it('can delete a child that changes type - implicit keys', async function () {
     let unmounted = false;
 
     class ClassComponent extends React.Component {
@@ -206,7 +212,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo useClass={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span prop="Class" />
@@ -217,7 +223,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(unmounted).toBe(false);
 
     ReactNoop.render(<Foo useFunction={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span prop="Function" />
@@ -228,15 +234,15 @@ describe('ReactIncrementalSideEffects', () => {
     expect(unmounted).toBe(true);
 
     ReactNoop.render(<Foo useText={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>TextTrail</div>);
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
   });
 
-  it('can delete a child that changes type - explicit keys', function () {
+  it('can delete a child that changes type - explicit keys', async function () {
     let unmounted = false;
 
     class ClassComponent extends React.Component {
@@ -266,7 +272,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo useClass={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span prop="Class" />
@@ -277,7 +283,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(unmounted).toBe(false);
 
     ReactNoop.render(<Foo useFunction={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span prop="Function" />
@@ -288,11 +294,11 @@ describe('ReactIncrementalSideEffects', () => {
     expect(unmounted).toBe(true);
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
   });
 
-  it('can delete a child when it unmounts inside a portal', () => {
+  it('can delete a child when it unmounts inside a portal', async () => {
     function Bar(props) {
       return <span prop={props.children} />;
     }
@@ -312,7 +318,7 @@ describe('ReactIncrementalSideEffects', () => {
         <Foo show={true} />
       </div>,
     );
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div />);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
       <>
@@ -327,7 +333,7 @@ describe('ReactIncrementalSideEffects', () => {
         <Foo show={false} />
       </div>,
     );
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div />);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
@@ -336,7 +342,7 @@ describe('ReactIncrementalSideEffects', () => {
         <Foo show={true} />
       </div>,
     );
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div />);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
       <>
@@ -347,17 +353,17 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(null);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo show={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo show={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
       <>
@@ -368,12 +374,12 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(null);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
   });
 
-  it('can delete a child when it unmounts with a portal', () => {
+  it('can delete a child when it unmounts with a portal', async () => {
     function Bar(props) {
       return <span prop={props.children} />;
     }
@@ -393,7 +399,7 @@ describe('ReactIncrementalSideEffects', () => {
         <Foo />
       </div>,
     );
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<div />);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
       <>
@@ -404,12 +410,12 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(null);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(
       <>
@@ -420,12 +426,12 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(null);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
     expect(ReactNoop.getChildrenAsJSX('portalContainer')).toEqual(null);
   });
 
-  it('does not update child nodes if a flush is aborted', () => {
+  it('does not update child nodes if a flush is aborted', async () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
       return <span prop={props.text} />;
@@ -445,7 +451,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo text="Hello" />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Bar', 'Bar', 'Bar']);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <div>
@@ -461,7 +467,7 @@ describe('ReactIncrementalSideEffects', () => {
     });
 
     // Flush some of the work without committing
-    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar']);
+    await waitFor(['Foo', 'Bar']);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <div>
@@ -474,7 +480,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   // @gate www
-  it('preserves a previously rendered node when deprioritized', () => {
+  it('preserves a previously rendered node when deprioritized', async () => {
     function Middle(props) {
       Scheduler.unstable_yieldValue('Middle');
       return <span prop={props.children} />;
@@ -492,7 +498,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo text="foo" />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Middle']);
+    await waitForAll(['Foo', 'Middle']);
 
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
@@ -505,7 +511,7 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.render(<Foo text="bar" />, () =>
       Scheduler.unstable_yieldValue('commit'),
     );
-    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit']);
+    await waitFor(['Foo', 'commit']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         <div hidden={true}>
@@ -514,7 +520,7 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
 
-    expect(Scheduler).toFlushAndYield(['Middle']);
+    await waitForAll(['Middle']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         <div hidden={true}>
@@ -525,7 +531,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   // @gate www
-  it('can reuse side-effects after being preempted', () => {
+  it('can reuse side-effects after being preempted', async () => {
     function Bar(props) {
       Scheduler.unstable_yieldValue('Bar');
       return <span prop={props.children} />;
@@ -556,7 +562,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     // Init
     ReactNoop.render(<Foo text="foo" step={0} />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Bar', 'Bar']);
 
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div hidden={true}>
@@ -572,7 +578,7 @@ describe('ReactIncrementalSideEffects', () => {
     ReactNoop.render(<Foo text="bar" step={1} />, () =>
       Scheduler.unstable_yieldValue('commit'),
     );
-    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit', 'Bar']);
+    await waitFor(['Foo', 'commit', 'Bar']);
 
     // The tree remains unchanged.
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
@@ -588,7 +594,7 @@ describe('ReactIncrementalSideEffects', () => {
     // render some higher priority work. The middle content will bailout so
     // it remains untouched which means that it should reuse it next time.
     ReactNoop.render(<Foo text="foo" step={1} />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Bar', 'Bar']);
 
     // Since we did nothing to the middle subtree during the interruption,
     // we should be able to reuse the reconciliation work that we already did
@@ -605,7 +611,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   // @gate www
-  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
+  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', async () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
         return this.props.children !== nextProps.children;
@@ -642,7 +648,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     // Init
     ReactNoop.render(<Foo text="foo" step={0} />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Content', 'Bar', 'Bar']);
 
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div hidden={true}>
@@ -656,7 +662,7 @@ describe('ReactIncrementalSideEffects', () => {
     // Make a quick update which will schedule low priority work to
     // update the middle content.
     ReactNoop.render(<Foo text="bar" step={1} />);
-    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Content', 'Bar']);
+    await waitFor(['Foo', 'Content', 'Bar']);
 
     // The tree remains unchanged.
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
@@ -672,7 +678,7 @@ describe('ReactIncrementalSideEffects', () => {
     // render some higher priority work. The middle content will bailout so
     // it remains untouched which means that it should reuse it next time.
     ReactNoop.render(<Foo text="foo" step={1} />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Content', 'Bar', 'Bar']);
 
     // Since we did nothing to the middle subtree during the interruption,
     // we should be able to reuse the reconciliation work that we already did
@@ -688,7 +694,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  it('can update a completed tree before it has a chance to commit', () => {
+  it('can update a completed tree before it has a chance to commit', async () => {
     function Foo(props) {
       Scheduler.unstable_yieldValue('Foo');
       return <span prop={props.step} />;
@@ -697,7 +703,7 @@ describe('ReactIncrementalSideEffects', () => {
       ReactNoop.render(<Foo step={1} />);
     });
     // This should be just enough to complete the tree without committing it
-    expect(Scheduler).toFlushAndYieldThrough(['Foo']);
+    await waitFor(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
     // To confirm, perform one more unit of work. The tree should now
     // be flushed.
@@ -708,7 +714,7 @@ describe('ReactIncrementalSideEffects', () => {
       ReactNoop.render(<Foo step={2} />);
     });
     // This should be just enough to complete the tree without committing it
-    expect(Scheduler).toFlushAndYieldThrough(['Foo']);
+    await waitFor(['Foo']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
@@ -723,12 +729,12 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />);
     // If we flush the rest of the work, we should get another commit that
     // renders 3. If it renders 2 again, that means an update was dropped.
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
   // @gate www
-  it('updates a child even though the old props is empty', () => {
+  it('updates a child even though the old props is empty', async () => {
     function Foo(props) {
       return (
         <LegacyHiddenDiv mode="hidden">
@@ -738,7 +744,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div hidden={true}>
         <span prop={1} />
@@ -746,7 +752,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  xit('can defer side-effects and resume them later on', () => {
+  xit('can defer side-effects and resume them later on', async () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
         return this.props.idx !== nextProps.idx;
@@ -809,7 +815,7 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
     ReactNoop.render(<Foo tick={3} idx={1} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(
       <div>
         <span prop={3} />
@@ -829,7 +835,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(innerSpanA).toBe(innerSpanB);
   });
 
-  xit('can defer side-effects and reuse them later - complex', function () {
+  xit('can defer side-effects and reuse them later - complex', async function () {
     let ops = [];
 
     class Bar extends React.Component {
@@ -892,7 +898,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Foo']);
     ops = [];
 
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput([
       <div>
         <span prop={1} />,
@@ -959,7 +965,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     // We should now be able to reuse some of the work we've already done
     // and replay those side-effects.
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput([
       <div>
         <span prop={3} />,
@@ -979,7 +985,7 @@ describe('ReactIncrementalSideEffects', () => {
   });
 
   // @gate www
-  it('deprioritizes setStates that happens within a deprioritized tree', () => {
+  it('deprioritizes setStates that happens within a deprioritized tree', async () => {
     const barInstances = [];
 
     class Bar extends React.Component {
@@ -1010,7 +1016,7 @@ describe('ReactIncrementalSideEffects', () => {
       );
     }
     ReactNoop.render(<Foo tick={0} idx={0} />);
-    expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar']);
+    await waitForAll(['Foo', 'Bar', 'Bar', 'Bar']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         <span prop={0} />
@@ -1023,7 +1029,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     ReactNoop.render(<Foo tick={1} idx={1} />);
-    expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar', 'Bar']);
+    await waitFor(['Foo', 'Bar', 'Bar']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         {/* Updated */}
@@ -1041,7 +1047,7 @@ describe('ReactIncrementalSideEffects', () => {
     // This should not be enough time to render the content of all the hidden
     // items. Including the set state since that is deprioritized.
     // ReactNoop.flushDeferredPri(35);
-    expect(Scheduler).toFlushAndYieldThrough(['Bar']);
+    await waitFor(['Bar']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         {/* Updated */}
@@ -1057,7 +1063,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     // However, once we render fully, we will have enough time to finish it all
     // at once.
-    expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+    await waitForAll(['Bar', 'Bar']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
         <span prop={1} />
@@ -1074,7 +1080,7 @@ describe('ReactIncrementalSideEffects', () => {
   // moves to "current" without flushing due to having lower priority. Does this
   // even happen? Maybe a child doesn't get processed because it is lower prio?
 
-  it('calls callback after update is flushed', () => {
+  it('calls callback after update is flushed', async () => {
     let instance;
     class Foo extends React.Component {
       constructor() {
@@ -1088,18 +1094,18 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
     let called = false;
     instance.setState({text: 'bar'}, () => {
       expect(ReactNoop).toMatchRenderedOutput(<span prop="bar" />);
       called = true;
     });
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(called).toBe(true);
   });
 
-  it('calls setState callback even if component bails out', () => {
+  it('calls setState callback even if component bails out', async () => {
     let instance;
     class Foo extends React.Component {
       constructor() {
@@ -1116,19 +1122,19 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
     let called = false;
     instance.setState({}, () => {
       called = true;
     });
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(called).toBe(true);
   });
 
   // TODO: Test that callbacks are not lost if an update is preempted.
 
-  it('calls componentWillUnmount after a deletion, even if nested', () => {
+  it('calls componentWillUnmount after a deletion, even if nested', async () => {
     const ops = [];
 
     class Bar extends React.Component {
@@ -1170,11 +1176,11 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo show={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([]);
 
     ReactNoop.render(<Foo show={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([
       'A',
       'Wrapper',
@@ -1188,7 +1194,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  it('calls componentDidMount/Update after insertion/update', () => {
+  it('calls componentDidMount/Update after insertion/update', async () => {
     let ops = [];
 
     class Bar extends React.Component {
@@ -1233,7 +1239,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([
       'mount:A',
       'mount:B',
@@ -1249,7 +1255,7 @@ describe('ReactIncrementalSideEffects', () => {
     ops = [];
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([
       'update:A',
       'update:B',
@@ -1263,7 +1269,7 @@ describe('ReactIncrementalSideEffects', () => {
     ]);
   });
 
-  it('invokes ref callbacks after insertion/update/unmount', () => {
+  it('invokes ref callbacks after insertion/update/unmount', async () => {
     let classInstance = null;
 
     let ops = [];
@@ -1310,7 +1316,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     // Refs that switch function instances get reinvoked
     ReactNoop.render(<Foo show={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([
       // detach all refs that switched handlers first.
       null,
@@ -1323,7 +1329,7 @@ describe('ReactIncrementalSideEffects', () => {
     ops = [];
 
     ReactNoop.render(<Foo show={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(ops).toEqual([
       // unmount
       null,
@@ -1334,7 +1340,7 @@ describe('ReactIncrementalSideEffects', () => {
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
   // expected way for aborted and resumed render life-cycles.
 
-  it('supports string refs', () => {
+  it('supports string refs', async () => {
     let fooInstance = null;
 
     class Bar extends React.Component {
@@ -1354,8 +1360,8 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(() => {
-      expect(Scheduler).toFlushWithoutYielding();
+    await expect(async () => {
+      await waitForAll([]);
     }).toErrorDev([
       'Warning: Component "Foo" contains the string ref "bar". ' +
         'Support for string refs will be removed in a future major release. ' +

commit 25685d8a90dd83d30cee6bd365bcb0115f1a2ff1
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 4 18:06:20 2023 -0500

    Codemod tests to waitFor pattern (9/?) (#26309)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 4c20424e2e..912680dfd1 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1296,7 +1296,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo show={true} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+    await expect(async () => await waitForAll([])).toErrorDev(
       'Warning: Function components cannot be given refs. ' +
         'Attempts to access this ref will fail. ' +
         'Did you mean to use React.forwardRef()?\n\n' +

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 912680dfd1..0ed01d9471 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -433,12 +433,12 @@ describe('ReactIncrementalSideEffects', () => {
 
   it('does not update child nodes if a flush is aborted', async () => {
     function Bar(props) {
-      Scheduler.unstable_yieldValue('Bar');
+      Scheduler.log('Bar');
       return <span prop={props.text} />;
     }
 
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return (
         <div>
           <div>
@@ -482,12 +482,12 @@ describe('ReactIncrementalSideEffects', () => {
   // @gate www
   it('preserves a previously rendered node when deprioritized', async () => {
     function Middle(props) {
-      Scheduler.unstable_yieldValue('Middle');
+      Scheduler.log('Middle');
       return <span prop={props.children} />;
     }
 
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return (
         <div>
           <LegacyHiddenDiv mode="hidden">
@@ -508,9 +508,7 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
 
-    ReactNoop.render(<Foo text="bar" />, () =>
-      Scheduler.unstable_yieldValue('commit'),
-    );
+    ReactNoop.render(<Foo text="bar" />, () => Scheduler.log('commit'));
     await waitFor(['Foo', 'commit']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
@@ -533,7 +531,7 @@ describe('ReactIncrementalSideEffects', () => {
   // @gate www
   it('can reuse side-effects after being preempted', async () => {
     function Bar(props) {
-      Scheduler.unstable_yieldValue('Bar');
+      Scheduler.log('Bar');
       return <span prop={props.children} />;
     }
 
@@ -545,7 +543,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
 
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return (
         <LegacyHiddenDiv mode="hidden">
           {props.step === 0 ? (
@@ -576,7 +574,7 @@ describe('ReactIncrementalSideEffects', () => {
     // Make a quick update which will schedule low priority work to
     // update the middle content.
     ReactNoop.render(<Foo text="bar" step={1} />, () =>
-      Scheduler.unstable_yieldValue('commit'),
+      Scheduler.log('commit'),
     );
     await waitFor(['Foo', 'commit', 'Bar']);
 
@@ -617,7 +615,7 @@ describe('ReactIncrementalSideEffects', () => {
         return this.props.children !== nextProps.children;
       }
       render() {
-        Scheduler.unstable_yieldValue('Bar');
+        Scheduler.log('Bar');
         return <span prop={this.props.children} />;
       }
     }
@@ -627,7 +625,7 @@ describe('ReactIncrementalSideEffects', () => {
         return this.props.step !== nextProps.step;
       }
       render() {
-        Scheduler.unstable_yieldValue('Content');
+        Scheduler.log('Content');
         return (
           <div>
             <Bar>{this.props.step === 0 ? 'Hi' : 'Hello'}</Bar>
@@ -638,7 +636,7 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return (
         <LegacyHiddenDiv mode="hidden">
           <Content step={props.step} text={props.text} />
@@ -696,7 +694,7 @@ describe('ReactIncrementalSideEffects', () => {
 
   it('can update a completed tree before it has a chance to commit', async () => {
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return <span prop={props.step} />;
     }
     React.startTransition(() => {
@@ -998,12 +996,12 @@ describe('ReactIncrementalSideEffects', () => {
       }
       render() {
         barInstances.push(this);
-        Scheduler.unstable_yieldValue('Bar');
+        Scheduler.log('Bar');
         return <span prop={this.state.active ? 'X' : this.props.idx} />;
       }
     }
     function Foo(props) {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       return (
         <div>
           <span prop={props.tick} />

commit a8875eab7f78a453d22370d1061a8bb3cd672b9d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 10 11:06:28 2023 -0500

    Update more tests to not rely on sync queuing (#26358)
    
    This fixes a handful of tests that were accidentally relying on React
    synchronously queuing work in the Scheduler after a setState.
    
    Usually this is because they use a lower level SchedulerMock method
    instead of either `act` or one of the `waitFor` helpers. In some cases,
    the solution is to switch to those APIs. In other cases, if we're
    intentionally testing some lower level behavior, we might have to be a
    bit more clever.
    
    Co-authored-by: Tianyu Yao <skyyao@fb.com>

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 0ed01d9471..b47897e54d 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -15,6 +15,7 @@ let ReactNoop;
 let Scheduler;
 let waitForAll;
 let waitFor;
+let waitForPaint;
 
 describe('ReactIncrementalSideEffects', () => {
   beforeEach(() => {
@@ -27,6 +28,7 @@ describe('ReactIncrementalSideEffects', () => {
     const InternalTestUtils = require('internal-test-utils');
     waitForAll = InternalTestUtils.waitForAll;
     waitFor = InternalTestUtils.waitFor;
+    waitForPaint = InternalTestUtils.waitForPaint;
   });
 
   // Note: This is based on a similar component we use in www. We can delete
@@ -694,25 +696,25 @@ describe('ReactIncrementalSideEffects', () => {
 
   it('can update a completed tree before it has a chance to commit', async () => {
     function Foo(props) {
-      Scheduler.log('Foo');
+      Scheduler.log('Foo ' + props.step);
       return <span prop={props.step} />;
     }
     React.startTransition(() => {
       ReactNoop.render(<Foo step={1} />);
     });
     // This should be just enough to complete the tree without committing it
-    await waitFor(['Foo']);
+    await waitFor(['Foo 1']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
     // To confirm, perform one more unit of work. The tree should now
     // be flushed.
-    ReactNoop.flushNextYield();
+    await waitForPaint([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
     React.startTransition(() => {
       ReactNoop.render(<Foo step={2} />);
     });
     // This should be just enough to complete the tree without committing it
-    await waitFor(['Foo']);
+    await waitFor(['Foo 2']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
@@ -723,11 +725,11 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // Now let's commit. We already had a commit that was pending, which will
     // render 2.
-    ReactNoop.flushNextYield();
+    await waitForPaint([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />);
     // If we flush the rest of the work, we should get another commit that
     // renders 3. If it renders 2 again, that means an update was dropped.
-    await waitForAll([]);
+    await waitForAll(['Foo 3']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 

commit da94e8b24a3f31a3e805f9bf6bba73055aad9d41
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Apr 4 10:08:14 2023 -0400

    Revert "Cleanup enableSyncDefaultUpdate flag (#26236)" (#26528)
    
    This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.
    
    While the feature flag is fully rolled out, these tests are also testing
    behavior set with an unstable flag on root, which for now we want to
    preserve.
    
    Not sure if there's a better way then adding a dynamic feature flag to
    the www build?

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index b47897e54d..5df785b7e0 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -464,9 +464,13 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<Foo text="World" />);
+      });
+    } else {
       ReactNoop.render(<Foo text="World" />);
-    });
+    }
 
     // Flush some of the work without committing
     await waitFor(['Foo', 'Bar']);
@@ -699,9 +703,13 @@ describe('ReactIncrementalSideEffects', () => {
       Scheduler.log('Foo ' + props.step);
       return <span prop={props.step} />;
     }
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<Foo step={1} />);
+      });
+    } else {
       ReactNoop.render(<Foo step={1} />);
-    });
+    }
     // This should be just enough to complete the tree without committing it
     await waitFor(['Foo 1']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
@@ -710,18 +718,26 @@ describe('ReactIncrementalSideEffects', () => {
     await waitForPaint([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<Foo step={2} />);
+      });
+    } else {
       ReactNoop.render(<Foo step={2} />);
-    });
+    }
     // This should be just enough to complete the tree without committing it
     await waitFor(['Foo 2']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<Foo step={3} />);
+      });
+    } else {
       ReactNoop.render(<Foo step={3} />);
-    });
+    }
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // Now let's commit. We already had a commit that was pending, which will
     // render 2.

commit 018c58c9c65452cff25aaf1f38f78a9b90d8e5c1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jun 1 09:24:56 2023 -0400

    Clean up enableSyncDefaultUpdates flag a bit (#26858)
    
    ## Overview
    
    Does a few things:
    - Renames `enableSyncDefaultUpdates` to
    `forceConcurrentByDefaultForTesting`
    - Changes the way it's used so it's dead-code eliminated separate from
    `allowConcurrentByDefault`
    - Deletes a bunch of the gated code
    
    The gates that are deleted are unnecessary now. We were keeping them
    when we originally thought we would come back to being concurrent by
    default. But we've shifted and now sync-by default is the desired
    behavior long term, so there's no need to keep all these forked tests
    around.
    
    I'll follow up to delete more of the forked behavior if possible.
    Ideally we wouldn't need this flag even if we're still using
    `allowConcurrentByDefault`.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 5df785b7e0..b47897e54d 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -464,13 +464,9 @@ describe('ReactIncrementalSideEffects', () => {
       </div>,
     );
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo text="World" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo text="World" />);
-    }
+    });
 
     // Flush some of the work without committing
     await waitFor(['Foo', 'Bar']);
@@ -703,13 +699,9 @@ describe('ReactIncrementalSideEffects', () => {
       Scheduler.log('Foo ' + props.step);
       return <span prop={props.step} />;
     }
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={1} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={1} />);
-    }
+    });
     // This should be just enough to complete the tree without committing it
     await waitFor(['Foo 1']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
@@ -718,26 +710,18 @@ describe('ReactIncrementalSideEffects', () => {
     await waitForPaint([]);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={2} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={2} />);
-    }
+    });
     // This should be just enough to complete the tree without committing it
     await waitFor(['Foo 2']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // This time, before we commit the tree, we update the root component with
     // new props
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Foo step={3} />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Foo step={3} />);
-    }
+    });
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
     // Now let's commit. We already had a commit that was pending, which will
     // render 2.

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index b47897e54d..9dac866df1 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -19,8 +19,6 @@ let waitForPaint;
 
 describe('ReactIncrementalSideEffects', () => {
   beforeEach(() => {
-    jest.resetModules();
-
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 9dac866df1..b47897e54d 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -19,6 +19,8 @@ let waitForPaint;
 
 describe('ReactIncrementalSideEffects', () => {
   beforeEach(() => {
+    jest.resetModules();
+
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');

commit fa2f82addc7c817892c482792f56a35277e8b75a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 20 14:17:41 2024 -0500

    Pass ref as normal prop (#28348)
    
    Depends on:
    
    - #28317
    - #28320
    
    ---
    
    Changes the behavior of the JSX runtime to pass through `ref` as a
    normal prop, rather than plucking it from the props object and storing
    on the element.
    
    This is a breaking change since it changes the type of the receiving
    component. However, most code is unaffected since it's unlikely that a
    component would have attempted to access a `ref` prop, since it was not
    possible to get a reference to one.
    
    `forwardRef` _will_ still pluck `ref` from the props object, though,
    since it's extremely common for users to spread the props object onto
    the inner component and pass `ref` as a differently named prop. This is
    for maximum compatibility with existing code  the real impact of this
    change is that `forwardRef` is no longer required.
    
    Currently, refs are resolved during child reconciliation and stored on
    the fiber. As a result of this change, we can move ref resolution to
    happen only much later, and only for components that actually use them.
    Then we can remove the `ref` field from the Fiber type. I have not yet
    done that in this step, though.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index b47897e54d..1e34dd9cde 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1296,16 +1296,22 @@ describe('ReactIncrementalSideEffects', () => {
     }
 
     ReactNoop.render(<Foo show={true} />);
-    await expect(async () => await waitForAll([])).toErrorDev(
-      'Warning: Function components cannot be given refs. ' +
-        'Attempts to access this ref will fail. ' +
-        'Did you mean to use React.forwardRef()?\n\n' +
-        'Check the render method ' +
-        'of `Foo`.\n' +
-        '    in FunctionComponent (at **)\n' +
-        '    in div (at **)\n' +
-        '    in Foo (at **)',
-    );
+
+    if (gate(flags => flags.enableRefAsProp)) {
+      await waitForAll([]);
+    } else {
+      await expect(async () => await waitForAll([])).toErrorDev(
+        'Warning: Function components cannot be given refs. ' +
+          'Attempts to access this ref will fail. ' +
+          'Did you mean to use React.forwardRef()?\n\n' +
+          'Check the render method ' +
+          'of `Foo`.\n' +
+          '    in FunctionComponent (at **)\n' +
+          '    in div (at **)\n' +
+          '    in Foo (at **)',
+      );
+    }
+
     expect(ops).toEqual([
       classInstance,
       // no call for function components

commit c9798954e26a2354a951cc65607f2901a45bf035
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 27 11:43:04 2024 -0500

    Remove string refs (behind flag)  (#28322)
    
    Depends on:
    
    - https://github.com/facebook/react/pull/28398
    
    ---
    
    This removes string refs, which has been deprecated in Strict Mode for
    seven years.
    
    I've left them behind a flag for Meta, but in open source this fully
    removes the feature.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 1e34dd9cde..a034de39d6 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1346,6 +1346,7 @@ describe('ReactIncrementalSideEffects', () => {
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
   // expected way for aborted and resumed render life-cycles.
 
+  // @gate !disableStringRefs
   it('supports string refs', async () => {
     let fooInstance = null;
 

commit 1940cb27b260c2eab79c76763d1151ba18353ff8
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Mar 3 17:34:33 2024 -0500

    Update /link URLs to react.dev (#28477)
    
    Depends on https://github.com/reactjs/react.dev/pull/6670 [merged]

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index a034de39d6..9f892d3f91 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1373,7 +1373,7 @@ describe('ReactIncrementalSideEffects', () => {
       'Warning: Component "Foo" contains the string ref "bar". ' +
         'Support for string refs will be removed in a future major release. ' +
         'We recommend using useRef() or createRef() instead. ' +
-        'Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\n' +
+        'Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref\n' +
         '    in Foo (at **)',
     ]);
     expect(fooInstance.refs.bar.test).toEqual('test');

commit e3ebcd54b98a4f8f5a9f7e63982fa75578b648ed
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 5 10:53:11 2024 -0400

    Move string ref coercion to JSX runtime (#28473)
    
    Based on:
    
    - #28464
    
    ---
    
    This moves the entire string ref implementation out Fiber and into the
    JSX runtime. The string is converted to a callback ref during element
    creation. This is a subtle change in behavior, because it will have
    already been converted to a callback ref if you access element.prop.ref
    or element.ref. But this is only for Meta, because string refs are
    disabled entirely in open source. And if it leads to an issue in
    practice, the solution is to switch to a different ref type, which Meta
    is going to do regardless.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 9f892d3f91..6226e2bc22 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1374,6 +1374,7 @@ describe('ReactIncrementalSideEffects', () => {
         'Support for string refs will be removed in a future major release. ' +
         'We recommend using useRef() or createRef() instead. ' +
         'Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref\n' +
+        '    in Bar (at **)\n' +
         '    in Foo (at **)',
     ]);
     expect(fooInstance.refs.bar.test).toEqual('test');

commit eabb681535ab9582c0785049c5a16f8851430ff2
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Jun 4 13:07:29 2024 -0400

    Add xplat test variants (#29734)
    
    ## Overview
    
    We didn't have any tests that ran in persistent mode with the xplat
    feature flags (for either variant).
    
    As a result, invalid test gating like in
    https://github.com/facebook/react/pull/29664 were not caught.
    
    This PR adds test flavors for `ReactFeatureFlag-native-fb.js` in both
    variants.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 6226e2bc22..8b1de82b26 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -481,7 +481,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate www
+  // @gate enableLegacyHidden
   it('preserves a previously rendered node when deprioritized', async () => {
     function Middle(props) {
       Scheduler.log('Middle');
@@ -530,7 +530,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate www
+  // @gate enableLegacyHidden
   it('can reuse side-effects after being preempted', async () => {
     function Bar(props) {
       Scheduler.log('Bar');
@@ -610,7 +610,7 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  // @gate www
+  // @gate enableLegacyHidden
   it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', async () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
@@ -733,7 +733,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
   });
 
-  // @gate www
+  // @gate enableLegacyHidden
   it('updates a child even though the old props is empty', async () => {
     function Foo(props) {
       return (
@@ -984,7 +984,7 @@ describe('ReactIncrementalSideEffects', () => {
     expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
   });
 
-  // @gate www
+  // @gate enableLegacyHidden
   it('deprioritizes setStates that happens within a deprioritized tree', async () => {
     const barInstances = [];
 

commit d172bdaf95b0be869f7d36b87c95a5f12b229195
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 10 14:31:37 2024 -0400

    Add jest lint rules (#29760)
    
    ## Overview
    
    Updates `eslint-plugin-jest` and enables the recommended rules with some
    turned off that are unhelpful.
    
    The main motivations is:
    a) we have a few duplicated tests, which this found an I deleted
    b) making sure we don't accidentally commit skipped tests

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 8b1de82b26..8a633c1cee 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -752,7 +752,8 @@ describe('ReactIncrementalSideEffects', () => {
     );
   });
 
-  xit('can defer side-effects and resume them later on', async () => {
+  // eslint-disable-next-line jest/no-disabled-tests
+  it.skip('can defer side-effects and resume them later on', async () => {
     class Bar extends React.Component {
       shouldComponentUpdate(nextProps) {
         return this.props.idx !== nextProps.idx;
@@ -835,7 +836,8 @@ describe('ReactIncrementalSideEffects', () => {
     expect(innerSpanA).toBe(innerSpanB);
   });
 
-  xit('can defer side-effects and reuse them later - complex', async function () {
+  // eslint-disable-next-line jest/no-disabled-tests
+  it.skip('can defer side-effects and reuse them later - complex', async function () {
     let ops = [];
 
     class Bar extends React.Component {

commit 277420803947724b43c47bbc47d3a353553868f1
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Jun 10 18:41:56 2024 -0400

    Remove Warning: prefix and toString on console Arguments (#29839)
    
    Basically make `console.error` and `console.warn` behave like normal -
    when a component stack isn't appended. I need this because I need to be
    able to print rich logs with the component stack option and to be able
    to disable instrumentation completely in `console.createTask`
    environments that don't need it.
    
    Currently we can't print logs with richer objects because they're
    toString:ed first. In practice, pretty much all arguments we log are
    already toString:ed so it's not necessary anyway. Some might be like a
    number. So it would only be a problem if some environment can't handle
    proper consoles but then it's up to that environment to toString it
    before logging.
    
    The `Warning: ` prefix is historic and is both noisy and confusing. It's
    mostly unnecessary since the UI surrounding `console.error` and
    `console.warn` tend to have visual treatment around it anyway. However,
    it's actively misleading when `console.error` gets prefixed with a
    Warning that we consider an error level. There's an argument to be made
    that some of our `console.error` don't make the bar for an error but
    then the argument is to downgrade each of those to `console.warn` - not
    to brand all our actual error logging with `Warning: `.
    
    Apparently something needs to change in React Native before landing this
    because it depends on the prefix somehow which probably doesn't make
    sense already.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 8a633c1cee..73600d9419 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1303,7 +1303,7 @@ describe('ReactIncrementalSideEffects', () => {
       await waitForAll([]);
     } else {
       await expect(async () => await waitForAll([])).toErrorDev(
-        'Warning: Function components cannot be given refs. ' +
+        'Function components cannot be given refs. ' +
           'Attempts to access this ref will fail. ' +
           'Did you mean to use React.forwardRef()?\n\n' +
           'Check the render method ' +
@@ -1372,7 +1372,7 @@ describe('ReactIncrementalSideEffects', () => {
     await expect(async () => {
       await waitForAll([]);
     }).toErrorDev([
-      'Warning: Component "Foo" contains the string ref "bar". ' +
+      'Component "Foo" contains the string ref "bar". ' +
         'Support for string refs will be removed in a future major release. ' +
         'We recommend using useRef() or createRef() instead. ' +
         'Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref\n' +

commit b7e7f1a3fab87e8fc19e86a8088a9e0fe4710973
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jul 22 16:09:01 2024 -0400

    [BE] upgrade prettier to 3.3.3 (#30420)
    
    Mostly just changes in ternary formatting.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 73600d9419..37e885cd47 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -88,8 +88,8 @@ describe('ReactIncrementalSideEffects', () => {
           {props.text === 'World'
             ? [<Bar key="a" text={props.text} />, <div key="b" />]
             : props.text === 'Hi'
-            ? [<div key="b" />, <Bar key="a" text={props.text} />]
-            : null}
+              ? [<div key="b" />, <Bar key="a" text={props.text} />]
+              : null}
           <span prop="test" />
         </div>
       );

commit 07aa494432e97f63fca9faf2fad6f76fead31063
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Nov 4 14:30:58 2024 -0500

    Remove enableRefAsProp feature flag (#30346)
    
    The flag is fully rolled out.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 37e885cd47..81f892b48e 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1299,20 +1299,7 @@ describe('ReactIncrementalSideEffects', () => {
 
     ReactNoop.render(<Foo show={true} />);
 
-    if (gate(flags => flags.enableRefAsProp)) {
-      await waitForAll([]);
-    } else {
-      await expect(async () => await waitForAll([])).toErrorDev(
-        'Function components cannot be given refs. ' +
-          'Attempts to access this ref will fail. ' +
-          'Did you mean to use React.forwardRef()?\n\n' +
-          'Check the render method ' +
-          'of `Foo`.\n' +
-          '    in FunctionComponent (at **)\n' +
-          '    in div (at **)\n' +
-          '    in Foo (at **)',
-      );
-    }
+    await waitForAll([]);
 
     expect(ops).toEqual([
       classInstance,

commit e1378902bbb322aa1fe1953780f4b2b5f80d26b1
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Nov 6 14:00:10 2024 -0500

    [string-refs] cleanup string ref code (#31443)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
index 81f892b48e..c4473c1774 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js
@@ -1334,38 +1334,4 @@ describe('ReactIncrementalSideEffects', () => {
 
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
   // expected way for aborted and resumed render life-cycles.
-
-  // @gate !disableStringRefs
-  it('supports string refs', async () => {
-    let fooInstance = null;
-
-    class Bar extends React.Component {
-      componentDidMount() {
-        this.test = 'test';
-      }
-      render() {
-        return <div />;
-      }
-    }
-
-    class Foo extends React.Component {
-      render() {
-        fooInstance = this;
-        return <Bar ref="bar" />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    await expect(async () => {
-      await waitForAll([]);
-    }).toErrorDev([
-      'Component "Foo" contains the string ref "bar". ' +
-        'Support for string refs will be removed in a future major release. ' +
-        'We recommend using useRef() or createRef() instead. ' +
-        'Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref\n' +
-        '    in Bar (at **)\n' +
-        '    in Foo (at **)',
-    ]);
-    expect(fooInstance.refs.bar.test).toEqual('test');
-  });
 });

