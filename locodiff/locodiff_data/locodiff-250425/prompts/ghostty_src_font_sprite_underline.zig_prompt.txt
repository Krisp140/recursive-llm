# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/sprite/underline.zig

commit 278668c953ffcba960c1c9fb7a4a8fed4ba614c9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:14:49 2022 -0800

    font: draw single and double underlines as sprites

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
new file mode 100644
index 00000000..5f6d2f9a
--- /dev/null
+++ b/src/font/sprite/underline.zig
@@ -0,0 +1,119 @@
+//! This file renders underline sprites. To draw underlines, we render the
+//! full cell-width as a sprite and then draw it as a separate pass to the
+//! text.
+//!
+//! We used to render the underlines directly in the GPU shaders but its
+//! annoying to support multiple types of underlines and its also annoying
+//! to maintain and debug another set of shaders for each renderer instead of
+//! just relying on the glyph system we already need to support for text
+//! anyways.
+const std = @import("std");
+const builtin = @import("builtin");
+const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
+const font = @import("../main.zig");
+const Sprite = font.sprite.Sprite;
+const Atlas = @import("../../Atlas.zig");
+
+/// Draw an underline.
+pub fn renderGlyph(
+    alloc: Allocator,
+    atlas: *Atlas,
+    sprite: Sprite,
+    width: u32,
+    height: u32,
+    line_pos: u32,
+    line_thickness: u32,
+) !font.Glyph {
+    // Create the canvas we'll use to draw. We draw the underline in
+    // a full cell size and position it according to "pos".
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+    defer canvas.deinit(alloc);
+
+    // Perform the actual drawing
+    (Draw{
+        .width = width,
+        .height = height,
+        .pos = line_pos,
+        .thickness = line_thickness,
+    }).draw(&canvas, sprite);
+
+    // Write the drawing to the atlas
+    const region = try canvas.writeAtlas(alloc, atlas);
+
+    // Our coordinates start at the BOTTOM for our renderers so we have to
+    // specify an offset of the full height because we rendered a full size
+    // cell.
+    const offset_y = @intCast(i32, height);
+
+    return font.Glyph{
+        .width = width,
+        .height = height,
+        .offset_x = 0,
+        .offset_y = offset_y,
+        .atlas_x = region.x,
+        .atlas_y = region.y,
+        .advance_x = @intToFloat(f32, width),
+    };
+}
+
+/// Stores drawing state.
+const Draw = struct {
+    width: u32,
+    height: u32,
+    pos: u32,
+    thickness: u32,
+
+    /// Draw a specific underline sprite to the canvas.
+    fn draw(self: Draw, canvas: *font.sprite.Canvas, sprite: Sprite) void {
+        switch (sprite) {
+            .underline => self.drawSingle(canvas),
+            .underline_double => self.drawDouble(canvas),
+        }
+    }
+
+    /// Draw a single underline.
+    fn drawSingle(self: Draw, canvas: *font.sprite.Canvas) void {
+        canvas.rect(.{
+            .x = 0,
+            .y = self.pos,
+            .width = self.width,
+            .height = self.thickness,
+        }, .on);
+    }
+
+    /// Draw a double underline.
+    fn drawDouble(self: Draw, canvas: *font.sprite.Canvas) void {
+        canvas.rect(.{
+            .x = 0,
+            .y = self.pos,
+            .width = self.width,
+            .height = self.thickness,
+        }, .on);
+
+        canvas.rect(.{
+            .x = 0,
+            .y = self.pos + (self.thickness * 2),
+            .width = self.width,
+            .height = self.thickness,
+        }, .on);
+    }
+};
+
+test "single" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var atlas_greyscale = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas_greyscale.deinit(alloc);
+
+    _ = try renderGlyph(
+        alloc,
+        &atlas_greyscale,
+        .underline,
+        36,
+        18,
+        9,
+        2,
+    );
+}

commit 6a32a30a16dc8c9158821a27e02ef280a9a5fa74
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:39:18 2022 -0800

    font: render dotted underlines

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 5f6d2f9a..4ce2aad3 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -69,6 +69,7 @@ const Draw = struct {
         switch (sprite) {
             .underline => self.drawSingle(canvas),
             .underline_double => self.drawDouble(canvas),
+            .underline_dotted => self.drawDotted(canvas),
         }
     }
 
@@ -98,6 +99,21 @@ const Draw = struct {
             .height = self.thickness,
         }, .on);
     }
+
+    /// Draw a dotted underline.
+    fn drawDotted(self: Draw, canvas: *font.sprite.Canvas) void {
+        const dot_width = @max(self.thickness, 3);
+        const dot_count = self.width / dot_width;
+        var i: u32 = 0;
+        while (i < dot_count) : (i += 2) {
+            canvas.rect(.{
+                .x = i * dot_width,
+                .y = self.pos,
+                .width = dot_width,
+                .height = self.thickness,
+            }, .on);
+        }
+    }
 };
 
 test "single" {

commit fee681ac78eb7438bb749bbff870d4255e32a551
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 15:44:12 2022 -0800

    dashed underlines

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 4ce2aad3..87c25a9d 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -70,6 +70,7 @@ const Draw = struct {
             .underline => self.drawSingle(canvas),
             .underline_double => self.drawDouble(canvas),
             .underline_dotted => self.drawDotted(canvas),
+            .underline_dashed => self.drawDashed(canvas),
         }
     }
 
@@ -114,6 +115,21 @@ const Draw = struct {
             }, .on);
         }
     }
+
+    /// Draw a dashed underline.
+    fn drawDashed(self: Draw, canvas: *font.sprite.Canvas) void {
+        const dash_width = self.width / 3 + 1;
+        const dash_count = (self.width / dash_width) + 1;
+        var i: u32 = 0;
+        while (i < dash_count) : (i += 2) {
+            canvas.rect(.{
+                .x = i * dash_width,
+                .y = self.pos,
+                .width = dash_width,
+                .height = self.thickness,
+            }, .on);
+        }
+    }
 };
 
 test "single" {

commit bfc657395ac0373cf1d93c7ba75d04ee19b4932a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 16:11:15 2022 -0800

    curly underlines

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 87c25a9d..5e1dedde 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -71,6 +71,7 @@ const Draw = struct {
             .underline_double => self.drawDouble(canvas),
             .underline_dotted => self.drawDotted(canvas),
             .underline_dashed => self.drawDashed(canvas),
+            .underline_curly => self.drawCurly(canvas),
         }
     }
 
@@ -130,6 +131,41 @@ const Draw = struct {
             }, .on);
         }
     }
+
+    /// Draw a curly underline. Thanks to Wez Furlong for providing
+    /// the basic math structure for this since I was lazy with the
+    /// geometry.
+    fn drawCurly(self: Draw, canvas: *font.sprite.Canvas) void {
+        // This is the lowest that the curl can go.
+        const y_max = self.height - 1;
+
+        // The full heightof the wave can be from the bottom to the
+        // underline position. We also calculate our starting y which is
+        // slightly below our descender since our wave will move about that.
+        const wave_height = @intToFloat(f64, y_max - self.pos);
+        const half_height = wave_height / 4;
+        const y = self.pos + @floatToInt(u32, half_height);
+
+        const x_factor = (2 * std.math.pi) / @intToFloat(f64, self.width);
+        var x: u32 = 0;
+        while (x < self.width) : (x += 1) {
+            const vertical = @floatToInt(
+                u32,
+                (-1 * half_height) * @sin(@intToFloat(f64, x) * x_factor) + half_height,
+            );
+
+            var row: u32 = 0;
+            while (row < self.thickness) : (row += 1) {
+                const y1 = @min(row + y + vertical, y_max);
+                canvas.rect(.{
+                    .x = x,
+                    .y = y1,
+                    .width = 1,
+                    .height = 1,
+                }, .on);
+            }
+        }
+    }
 };
 
 test "single" {
@@ -149,3 +185,21 @@ test "single" {
         2,
     );
 }
+
+test "curly" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var atlas_greyscale = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas_greyscale.deinit(alloc);
+
+    _ = try renderGlyph(
+        alloc,
+        &atlas_greyscale,
+        .underline_curly,
+        36,
+        18,
+        9,
+        2,
+    );
+}

commit f871630fa40e6dbe035d55376a90d33c4470e5f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 28 10:35:46 2022 -0800

    move Atlas to font

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 5e1dedde..94036a72 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -13,12 +13,11 @@ const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const font = @import("../main.zig");
 const Sprite = font.sprite.Sprite;
-const Atlas = @import("../../Atlas.zig");
 
 /// Draw an underline.
 pub fn renderGlyph(
     alloc: Allocator,
-    atlas: *Atlas,
+    atlas: *font.Atlas,
     sprite: Sprite,
     width: u32,
     height: u32,
@@ -172,7 +171,7 @@ test "single" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try Atlas.init(alloc, 512, .greyscale);
+    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas_greyscale.deinit(alloc);
 
     _ = try renderGlyph(
@@ -190,7 +189,7 @@ test "curly" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try Atlas.init(alloc, 512, .greyscale);
+    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas_greyscale.deinit(alloc);
 
     _ = try renderGlyph(

commit b21e18a9e6896b05b47dff21552d620d76452021
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 13 16:16:56 2022 -0800

    font: start converting Box font to our abstract canvas interface

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 94036a72..e13fb7d3 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -78,7 +78,7 @@ const Draw = struct {
     fn drawSingle(self: Draw, canvas: *font.sprite.Canvas) void {
         canvas.rect(.{
             .x = 0,
-            .y = self.pos,
+            .y = @intCast(i32, self.pos),
             .width = self.width,
             .height = self.thickness,
         }, .on);
@@ -88,14 +88,14 @@ const Draw = struct {
     fn drawDouble(self: Draw, canvas: *font.sprite.Canvas) void {
         canvas.rect(.{
             .x = 0,
-            .y = self.pos,
+            .y = @intCast(i32, self.pos),
             .width = self.width,
             .height = self.thickness,
         }, .on);
 
         canvas.rect(.{
             .x = 0,
-            .y = self.pos + (self.thickness * 2),
+            .y = @intCast(i32, self.pos + (self.thickness * 2)),
             .width = self.width,
             .height = self.thickness,
         }, .on);
@@ -108,8 +108,8 @@ const Draw = struct {
         var i: u32 = 0;
         while (i < dot_count) : (i += 2) {
             canvas.rect(.{
-                .x = i * dot_width,
-                .y = self.pos,
+                .x = @intCast(i32, i * dot_width),
+                .y = @intCast(i32, self.pos),
                 .width = dot_width,
                 .height = self.thickness,
             }, .on);
@@ -123,8 +123,8 @@ const Draw = struct {
         var i: u32 = 0;
         while (i < dash_count) : (i += 2) {
             canvas.rect(.{
-                .x = i * dash_width,
-                .y = self.pos,
+                .x = @intCast(i32, i * dash_width),
+                .y = @intCast(i32, self.pos),
                 .width = dash_width,
                 .height = self.thickness,
             }, .on);
@@ -157,8 +157,8 @@ const Draw = struct {
             while (row < self.thickness) : (row += 1) {
                 const y1 = @min(row + y + vertical, y_max);
                 canvas.rect(.{
-                    .x = x,
-                    .y = y1,
+                    .x = @intCast(i32, x),
+                    .y = @intCast(i32, y1),
                     .width = 1,
                     .height = 1,
                 }, .on);

commit cf519bcd758388a025f60c7eedafd9a4571b1bf5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 4 15:10:24 2023 -0800

    Use procedurally generated sprites for cursors rather than shaders

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index e13fb7d3..abf52236 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -71,6 +71,7 @@ const Draw = struct {
             .underline_dotted => self.drawDotted(canvas),
             .underline_dashed => self.drawDashed(canvas),
             .underline_curly => self.drawCurly(canvas),
+            else => unreachable,
         }
     }
 

commit cfb8108279823c27bc3ac344a1dff76678aa2e1b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jun 22 16:01:00 2023 -0700

    font: curly underline has a minimum wave height
    
    This fixes rendering issues with some fonts where the underline position
    is too close to the bottom of the cell causing a very shallow curl.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index abf52236..b8900e15 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -24,6 +24,10 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
+    // Berkeley: warning: UNDERLINE RENDER width:18 height:37 pos:35 thickness:2
+    // Normal: warning: UNDERLINE RENDER width:18 height:38 pos:30 thickness:2
+    std.log.warn("UNDERLINE RENDER width:{} height:{} pos:{} thickness:{}", .{ width, height, line_pos, line_thickness });
+
     // Create the canvas we'll use to draw. We draw the underline in
     // a full cell size and position it according to "pos".
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
@@ -139,12 +143,21 @@ const Draw = struct {
         // This is the lowest that the curl can go.
         const y_max = self.height - 1;
 
+        // Some fonts put the underline too close to the bottom of the
+        // cell height and this doesn't allow us to make a high enough
+        // wave. This constant is arbitrary, change it for aesthetics.
+        const pos = pos: {
+            const MIN_HEIGHT = 7;
+            const height = y_max - self.pos;
+            break :pos if (height < MIN_HEIGHT) self.pos -| MIN_HEIGHT else self.pos;
+        };
+
         // The full heightof the wave can be from the bottom to the
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
-        const wave_height = @intToFloat(f64, y_max - self.pos);
+        const wave_height = @intToFloat(f64, y_max - pos);
         const half_height = wave_height / 4;
-        const y = self.pos + @floatToInt(u32, half_height);
+        const y = pos + @floatToInt(u32, half_height);
 
         const x_factor = (2 * std.math.pi) / @intToFloat(f64, self.width);
         var x: u32 = 0;

commit e810a7bf91d1727b69d8c96a6fe33d3d67ea58de
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jun 22 16:07:10 2023 -0700

    font: fix double underline drawing with very low underline positions

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index b8900e15..9fcd5cb1 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -91,16 +91,26 @@ const Draw = struct {
 
     /// Draw a double underline.
     fn drawDouble(self: Draw, canvas: *font.sprite.Canvas) void {
+        // The maximum y value has to have space for the bottom underline.
+        // If we underflow (saturated) to 0, then we don't draw. This should
+        // never happen but we don't want to draw something undefined.
+        const y_max = self.height -| 1 -| self.thickness;
+        if (y_max == 0) return;
+
+        const space = self.thickness * 2;
+        const bottom = @min(self.pos + space, y_max);
+        const top = bottom - space;
+
         canvas.rect(.{
             .x = 0,
-            .y = @intCast(i32, self.pos),
+            .y = @intCast(i32, top),
             .width = self.width,
             .height = self.thickness,
         }, .on);
 
         canvas.rect(.{
             .x = 0,
-            .y = @intCast(i32, self.pos + (self.thickness * 2)),
+            .y = @intCast(i32, bottom),
             .width = self.width,
             .height = self.thickness,
         }, .on);

commit 43554c1b648114f3aa5fc42589ec250d5f1aa34c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jun 22 16:07:43 2023 -0700

    font: remove old logging

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 9fcd5cb1..532ad0f0 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -24,10 +24,6 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
-    // Berkeley: warning: UNDERLINE RENDER width:18 height:37 pos:35 thickness:2
-    // Normal: warning: UNDERLINE RENDER width:18 height:38 pos:30 thickness:2
-    std.log.warn("UNDERLINE RENDER width:{} height:{} pos:{} thickness:{}", .{ width, height, line_pos, line_thickness });
-
     // Create the canvas we'll use to draw. We draw the underline in
     // a full cell size and position it according to "pos".
     var canvas = try font.sprite.Canvas.init(alloc, width, height);

commit 1d45df17e4a387e4c58ecc2b643c2ce137820d65
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jun 22 20:11:57 2023 -0700

    font: underline sprites should never go out of bounds for canvas

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 532ad0f0..362a1832 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -77,9 +77,14 @@ const Draw = struct {
 
     /// Draw a single underline.
     fn drawSingle(self: Draw, canvas: *font.sprite.Canvas) void {
+        // Ensure we never overflow out of bounds on the canvas
+        const y_max = self.height -| 1;
+        const bottom = @min(self.pos + self.thickness, y_max);
+        const y = @intCast(i32, bottom - self.thickness);
+
         canvas.rect(.{
             .x = 0,
-            .y = @intCast(i32, self.pos),
+            .y = y,
             .width = self.width,
             .height = self.thickness,
         }, .on);
@@ -114,14 +119,20 @@ const Draw = struct {
 
     /// Draw a dotted underline.
     fn drawDotted(self: Draw, canvas: *font.sprite.Canvas) void {
+        const y_max = self.height -| 1 -| self.thickness;
+        if (y_max == 0) return;
+        const y = @min(self.pos, y_max);
         const dot_width = @max(self.thickness, 3);
         const dot_count = self.width / dot_width;
         var i: u32 = 0;
         while (i < dot_count) : (i += 2) {
+            // Ensure we never go out of bounds for the rect
+            const x = @min(i * dot_width, self.width - 1);
+            const width = @min(self.width - 1 - x, dot_width);
             canvas.rect(.{
                 .x = @intCast(i32, i * dot_width),
-                .y = @intCast(i32, self.pos),
-                .width = dot_width,
+                .y = @intCast(i32, y),
+                .width = width,
                 .height = self.thickness,
             }, .on);
         }
@@ -129,14 +140,20 @@ const Draw = struct {
 
     /// Draw a dashed underline.
     fn drawDashed(self: Draw, canvas: *font.sprite.Canvas) void {
+        const y_max = self.height -| 1 -| self.thickness;
+        if (y_max == 0) return;
+        const y = @min(self.pos, y_max);
         const dash_width = self.width / 3 + 1;
         const dash_count = (self.width / dash_width) + 1;
         var i: u32 = 0;
         while (i < dash_count) : (i += 2) {
+            // Ensure we never go out of bounds for the rect
+            const x = @min(i * dash_width, self.width - 1);
+            const width = @min(self.width - 1 - x, dash_width);
             canvas.rect(.{
-                .x = @intCast(i32, i * dash_width),
-                .y = @intCast(i32, self.pos),
-                .width = dash_width,
+                .x = @intCast(i32, x),
+                .y = @intCast(i32, y),
+                .width = width,
                 .height = self.thickness,
             }, .on);
         }

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 362a1832..593b20e6 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -52,7 +52,7 @@ pub fn renderGlyph(
         .offset_y = offset_y,
         .atlas_x = region.x,
         .atlas_y = region.y,
-        .advance_x = @intToFloat(f32, width),
+        .advance_x = @floatFromInt(f32, width),
     };
 }
 
@@ -178,16 +178,16 @@ const Draw = struct {
         // The full heightof the wave can be from the bottom to the
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
-        const wave_height = @intToFloat(f64, y_max - pos);
+        const wave_height = @floatFromInt(f64, y_max - pos);
         const half_height = wave_height / 4;
-        const y = pos + @floatToInt(u32, half_height);
+        const y = pos + @intFromFloat(u32, half_height);
 
-        const x_factor = (2 * std.math.pi) / @intToFloat(f64, self.width);
+        const x_factor = (2 * std.math.pi) / @floatFromInt(f64, self.width);
         var x: u32 = 0;
         while (x < self.width) : (x += 1) {
-            const vertical = @floatToInt(
+            const vertical = @intFromFloat(
                 u32,
-                (-1 * half_height) * @sin(@intToFloat(f64, x) * x_factor) + half_height,
+                (-1 * half_height) * @sin(@floatFromInt(f64, x) * x_factor) + half_height,
             );
 
             var row: u32 = 0;

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 593b20e6..8979f206 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -43,7 +43,7 @@ pub fn renderGlyph(
     // Our coordinates start at the BOTTOM for our renderers so we have to
     // specify an offset of the full height because we rendered a full size
     // cell.
-    const offset_y = @intCast(i32, height);
+    const offset_y = @as(i32, @intCast(height));
 
     return font.Glyph{
         .width = width,
@@ -52,7 +52,7 @@ pub fn renderGlyph(
         .offset_y = offset_y,
         .atlas_x = region.x,
         .atlas_y = region.y,
-        .advance_x = @floatFromInt(f32, width),
+        .advance_x = @floatFromInt(width),
     };
 }
 
@@ -80,7 +80,7 @@ const Draw = struct {
         // Ensure we never overflow out of bounds on the canvas
         const y_max = self.height -| 1;
         const bottom = @min(self.pos + self.thickness, y_max);
-        const y = @intCast(i32, bottom - self.thickness);
+        const y = @as(i32, @intCast(bottom - self.thickness));
 
         canvas.rect(.{
             .x = 0,
@@ -104,14 +104,14 @@ const Draw = struct {
 
         canvas.rect(.{
             .x = 0,
-            .y = @intCast(i32, top),
+            .y = @intCast(top),
             .width = self.width,
             .height = self.thickness,
         }, .on);
 
         canvas.rect(.{
             .x = 0,
-            .y = @intCast(i32, bottom),
+            .y = @intCast(bottom),
             .width = self.width,
             .height = self.thickness,
         }, .on);
@@ -130,8 +130,8 @@ const Draw = struct {
             const x = @min(i * dot_width, self.width - 1);
             const width = @min(self.width - 1 - x, dot_width);
             canvas.rect(.{
-                .x = @intCast(i32, i * dot_width),
-                .y = @intCast(i32, y),
+                .x = @intCast(i * dot_width),
+                .y = @intCast(y),
                 .width = width,
                 .height = self.thickness,
             }, .on);
@@ -151,8 +151,8 @@ const Draw = struct {
             const x = @min(i * dash_width, self.width - 1);
             const width = @min(self.width - 1 - x, dash_width);
             canvas.rect(.{
-                .x = @intCast(i32, x),
-                .y = @intCast(i32, y),
+                .x = @intCast(x),
+                .y = @intCast(y),
                 .width = width,
                 .height = self.thickness,
             }, .on);
@@ -178,24 +178,24 @@ const Draw = struct {
         // The full heightof the wave can be from the bottom to the
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
-        const wave_height = @floatFromInt(f64, y_max - pos);
+        const wave_height = @as(f64, @floatFromInt(y_max - pos));
         const half_height = wave_height / 4;
-        const y = pos + @intFromFloat(u32, half_height);
+        const y = pos + @as(u32, @intFromFloat(half_height));
 
-        const x_factor = (2 * std.math.pi) / @floatFromInt(f64, self.width);
+        const x_factor = (2 * std.math.pi) / @as(f64, @floatFromInt(self.width));
         var x: u32 = 0;
         while (x < self.width) : (x += 1) {
-            const vertical = @intFromFloat(
+            const vertical = @as(
                 u32,
-                (-1 * half_height) * @sin(@floatFromInt(f64, x) * x_factor) + half_height,
+                @intFromFloat((-1 * half_height) * @sin(@as(f64, @floatFromInt(x)) * x_factor) + half_height),
             );
 
             var row: u32 = 0;
             while (row < self.thickness) : (row += 1) {
                 const y1 = @min(row + y + vertical, y_max);
                 canvas.rect(.{
-                    .x = @intCast(i32, x),
-                    .y = @intCast(i32, y1),
+                    .x = @intCast(x),
+                    .y = @intCast(y1),
                     .width = 1,
                     .height = 1,
                 }, .on);

commit b98cc3d79fe34f0c4cef2a4b06d4e8f7d5d67fed
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 22:08:19 2023 -0700

    config: add remaining font modifiers

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 8979f206..5317667e 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -171,8 +171,9 @@ const Draw = struct {
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos = pos: {
             const MIN_HEIGHT = 7;
-            const height = y_max - self.pos;
-            break :pos if (height < MIN_HEIGHT) self.pos -| MIN_HEIGHT else self.pos;
+            const clamped_pos = @min(y_max, self.pos);
+            const height = y_max - clamped_pos;
+            break :pos if (height < MIN_HEIGHT) clamped_pos -| MIN_HEIGHT else clamped_pos;
         };
 
         // The full heightof the wave can be from the bottom to the

commit a5eb746cf592d9785eff789022e0cb2a09059a50
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Sun Oct 29 02:49:31 2023 +1100

    feat: update undercurl with antialiasing

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 5317667e..0a0d127d 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -165,12 +165,13 @@ const Draw = struct {
     fn drawCurly(self: Draw, canvas: *font.sprite.Canvas) void {
         // This is the lowest that the curl can go.
         const y_max = self.height - 1;
+        const x_factor = 2 * std.math.pi / @as(f64, @floatFromInt(self.width - 1));
 
         // Some fonts put the underline too close to the bottom of the
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos = pos: {
-            const MIN_HEIGHT = 7;
+            const MIN_HEIGHT = 5;
             const clamped_pos = @min(y_max, self.pos);
             const height = y_max - clamped_pos;
             break :pos if (height < MIN_HEIGHT) clamped_pos -| MIN_HEIGHT else clamped_pos;
@@ -180,26 +181,26 @@ const Draw = struct {
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
         const wave_height = @as(f64, @floatFromInt(y_max - pos));
-        const half_height = wave_height / 4;
-        const y = pos + @as(u32, @intFromFloat(half_height));
+        //const wave_height = @as(f64, @floatFromInt(y_max - (pos - self.thickness / 2)));
+        const half_height = @max(1, wave_height / 4);
+        const y_pos = @as(i32, @intCast(pos)) + @as(i32, @intFromFloat(2 * half_height));
 
-        const x_factor = (2 * std.math.pi) / @as(f64, @floatFromInt(self.width));
+        // follow Xiaolin Wu's antialias algorithm to draw the curve
         var x: u32 = 0;
         while (x < self.width) : (x += 1) {
-            const vertical = @as(
-                u32,
-                @intFromFloat((-1 * half_height) * @sin(@as(f64, @floatFromInt(x)) * x_factor) + half_height),
-            );
-
-            var row: u32 = 0;
-            while (row < self.thickness) : (row += 1) {
-                const y1 = @min(row + y + vertical, y_max);
-                canvas.rect(.{
-                    .x = @intCast(x),
-                    .y = @intCast(y1),
-                    .width = 1,
-                    .height = 1,
-                }, .on);
+            const y0 = half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor);
+            const y1 = y_pos + @as(i32, @intFromFloat(@floor(y0)));
+            const y3 = y1 - 1 + @as(i32, @intCast(self.thickness));
+            const alpha = @as(u8, @intFromFloat(255 * @abs(y0 - @floor(y0))));
+
+            // upper and lower bounds
+            canvas.pixel(x, @min(@as(u32, @intCast(y1)), y_max), @enumFromInt(255 - alpha));
+            canvas.pixel(x, @min(@as(u32, @intCast(y3)), y_max), @enumFromInt(alpha));
+
+            // fill between upper and lower bound
+            var y2: u32 = @as(u32, @intCast(y1)) + 1;
+            while (y2 < y3) : (y2 += 1) {
+                canvas.pixel(x, @min(y2, y_max), .on);
             }
         }
     }

commit 6d971de87afe144a3e91fcfbcef7c8d1d377a7d4
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Sun Oct 29 03:13:17 2023 +1100

    feat: add x_facter comment and remove old code

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 0a0d127d..0bb91a26 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -165,6 +165,10 @@ const Draw = struct {
     fn drawCurly(self: Draw, canvas: *font.sprite.Canvas) void {
         // This is the lowest that the curl can go.
         const y_max = self.height - 1;
+
+        // Determines the density of the waves.
+        //   `2 * pi...` = 1 peak per character
+        //   `4 * pi...` = 2 peaks per character
         const x_factor = 2 * std.math.pi / @as(f64, @floatFromInt(self.width - 1));
 
         // Some fonts put the underline too close to the bottom of the
@@ -181,7 +185,6 @@ const Draw = struct {
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
         const wave_height = @as(f64, @floatFromInt(y_max - pos));
-        //const wave_height = @as(f64, @floatFromInt(y_max - (pos - self.thickness / 2)));
         const half_height = @max(1, wave_height / 4);
         const y_pos = @as(i32, @intCast(pos)) + @as(i32, @intFromFloat(2 * half_height));
 

commit a249e5973d367f48168078b5cb8c945fd6055555
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 28 10:40:51 2023 -0700

    font/underline: some additional type annotations

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 0bb91a26..cadd8ce2 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -174,18 +174,18 @@ const Draw = struct {
         // Some fonts put the underline too close to the bottom of the
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
-        const pos = pos: {
+        const pos: u32 = pos: {
             const MIN_HEIGHT = 5;
             const clamped_pos = @min(y_max, self.pos);
             const height = y_max - clamped_pos;
             break :pos if (height < MIN_HEIGHT) clamped_pos -| MIN_HEIGHT else clamped_pos;
         };
 
-        // The full heightof the wave can be from the bottom to the
+        // The full height of the wave can be from the bottom to the
         // underline position. We also calculate our starting y which is
         // slightly below our descender since our wave will move about that.
-        const wave_height = @as(f64, @floatFromInt(y_max - pos));
-        const half_height = @max(1, wave_height / 4);
+        const wave_height: f64 = @floatFromInt(y_max - pos);
+        const half_height: f64 = @max(1, wave_height / 4);
         const y_pos = @as(i32, @intCast(pos)) + @as(i32, @intFromFloat(2 * half_height));
 
         // follow Xiaolin Wu's antialias algorithm to draw the curve
@@ -194,7 +194,7 @@ const Draw = struct {
             const y0 = half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor);
             const y1 = y_pos + @as(i32, @intFromFloat(@floor(y0)));
             const y3 = y1 - 1 + @as(i32, @intCast(self.thickness));
-            const alpha = @as(u8, @intFromFloat(255 * @abs(y0 - @floor(y0))));
+            const alpha: u8 = @intFromFloat(255 * @abs(y0 - @floor(y0)));
 
             // upper and lower bounds
             canvas.pixel(x, @min(@as(u32, @intCast(y1)), y_max), @enumFromInt(255 - alpha));

commit 58f1653a1603609ac0bec03c00e78ba018668266
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Sun Oct 29 14:17:46 2023 +1100

    feat: cleanup types and reduce casting

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index cadd8ce2..d28b9d67 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -182,28 +182,27 @@ const Draw = struct {
         };
 
         // The full height of the wave can be from the bottom to the
-        // underline position. We also calculate our starting y which is
-        // slightly below our descender since our wave will move about that.
+        // underline position. We also calculate our mid y point of the wave
         const wave_height: f64 = @floatFromInt(y_max - pos);
         const half_height: f64 = @max(1, wave_height / 4);
-        const y_pos = @as(i32, @intCast(pos)) + @as(i32, @intFromFloat(2 * half_height));
+        const y_mid: u32 = pos + @as(u32, @intFromFloat(2 * half_height));
 
         // follow Xiaolin Wu's antialias algorithm to draw the curve
         var x: u32 = 0;
         while (x < self.width) : (x += 1) {
-            const y0 = half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor);
-            const y1 = y_pos + @as(i32, @intFromFloat(@floor(y0)));
-            const y3 = y1 - 1 + @as(i32, @intCast(self.thickness));
-            const alpha: u8 = @intFromFloat(255 * @abs(y0 - @floor(y0)));
+            const y: f64 = @as(f64, @floatFromInt(y_mid)) + (half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor));
+            const y_upper: u32 = @intFromFloat(@floor(y));
+            const y_lower: u32 = y_upper - 1 + self.thickness;
+            const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
 
             // upper and lower bounds
-            canvas.pixel(x, @min(@as(u32, @intCast(y1)), y_max), @enumFromInt(255 - alpha));
-            canvas.pixel(x, @min(@as(u32, @intCast(y3)), y_max), @enumFromInt(alpha));
+            canvas.pixel(x, @min(y_upper, y_max), @enumFromInt(255 - alpha));
+            canvas.pixel(x, @min(y_lower, y_max), @enumFromInt(alpha));
 
             // fill between upper and lower bound
-            var y2: u32 = @as(u32, @intCast(y1)) + 1;
-            while (y2 < y3) : (y2 += 1) {
-                canvas.pixel(x, @min(y2, y_max), .on);
+            var y_fill: u32 = y_upper + 1;
+            while (y_fill < y_lower) : (y_fill += 1) {
+                canvas.pixel(x, @min(y_fill, y_max), .on);
             }
         }
     }

commit 60b69a32d0bff5700bff83884d1fc8561e541d17
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Tue Oct 31 21:23:53 2023 +1100

    feat: update undercurl thickness and wave height

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index d28b9d67..ed08896c 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -175,10 +175,8 @@ const Draw = struct {
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos: u32 = pos: {
-            const MIN_HEIGHT = 5;
-            const clamped_pos = @min(y_max, self.pos);
-            const height = y_max - clamped_pos;
-            break :pos if (height < MIN_HEIGHT) clamped_pos -| MIN_HEIGHT else clamped_pos;
+            const MIN_HEIGHT: u32 = @max(self.height / 10, 3);
+            break :pos y_max - (MIN_HEIGHT * 2);
         };
 
         // The full height of the wave can be from the bottom to the
@@ -192,7 +190,7 @@ const Draw = struct {
         while (x < self.width) : (x += 1) {
             const y: f64 = @as(f64, @floatFromInt(y_mid)) + (half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor));
             const y_upper: u32 = @intFromFloat(@floor(y));
-            const y_lower: u32 = y_upper - 1 + self.thickness;
+            const y_lower: u32 = y_upper + self.thickness;
             const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
 
             // upper and lower bounds

commit d7a16e024564248cd1211170f8722cfd9b93e101
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Tue Oct 31 21:53:04 2023 +1100

    feat: update undercurl thickness and wave height

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index ed08896c..2e3a7095 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -175,7 +175,7 @@ const Draw = struct {
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos: u32 = pos: {
-            const MIN_HEIGHT: u32 = @max(self.height / 10, 3);
+            const MIN_HEIGHT: u32 = @max(self.height / 9, 3);
             break :pos y_max - (MIN_HEIGHT * 2);
         };
 

commit 212b30a163d425632a9496f500db6e6e64a7978e
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Wed Nov 1 11:51:32 2023 +1100

    feat: change minimum height to 2

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 2e3a7095..6f9ab149 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -175,7 +175,7 @@ const Draw = struct {
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos: u32 = pos: {
-            const MIN_HEIGHT: u32 = @max(self.height / 9, 3);
+            const MIN_HEIGHT: u32 = @max(self.height / 9, 2);
             break :pos y_max - (MIN_HEIGHT * 2);
         };
 

commit a81c7b7bb2fcfd3361c2fd6d680bd9164bc9228e
Author: Matthew Winter <33818+wintermi@users.noreply.github.com>
Date:   Wed Nov 1 19:04:20 2023 +1100

    feat: improve variable naming

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 6f9ab149..55a29d80 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -166,29 +166,29 @@ const Draw = struct {
         // This is the lowest that the curl can go.
         const y_max = self.height - 1;
 
-        // Determines the density of the waves.
+        // Calculate the wave period for a single character
         //   `2 * pi...` = 1 peak per character
         //   `4 * pi...` = 2 peaks per character
-        const x_factor = 2 * std.math.pi / @as(f64, @floatFromInt(self.width - 1));
+        const wave_period = 2 * std.math.pi / @as(f64, @floatFromInt(self.width - 1));
 
         // Some fonts put the underline too close to the bottom of the
         // cell height and this doesn't allow us to make a high enough
         // wave. This constant is arbitrary, change it for aesthetics.
         const pos: u32 = pos: {
-            const MIN_HEIGHT: u32 = @max(self.height / 9, 2);
-            break :pos y_max - (MIN_HEIGHT * 2);
+            const MIN_AMPLITUDE: u32 = @max(self.height / 9, 2);
+            break :pos y_max - (MIN_AMPLITUDE * 2);
         };
 
-        // The full height of the wave can be from the bottom to the
+        // The full aplitude of the wave can be from the bottom to the
         // underline position. We also calculate our mid y point of the wave
-        const wave_height: f64 = @floatFromInt(y_max - pos);
-        const half_height: f64 = @max(1, wave_height / 4);
-        const y_mid: u32 = pos + @as(u32, @intFromFloat(2 * half_height));
+        const double_amplitude: f64 = @floatFromInt(y_max - pos);
+        const half_amplitude: f64 = @max(1, double_amplitude / 4);
+        const y_mid: u32 = pos + @as(u32, @intFromFloat(2 * half_amplitude));
 
         // follow Xiaolin Wu's antialias algorithm to draw the curve
         var x: u32 = 0;
         while (x < self.width) : (x += 1) {
-            const y: f64 = @as(f64, @floatFromInt(y_mid)) + (half_height * @cos(@as(f64, @floatFromInt(x)) * x_factor));
+            const y: f64 = @as(f64, @floatFromInt(y_mid)) + (half_amplitude * @cos(@as(f64, @floatFromInt(x)) * wave_period));
             const y_upper: u32 = @intFromFloat(@floor(y));
             const y_lower: u32 = y_upper + self.thickness;
             const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));

commit 0f19251aa6bc494a173af3077aaaa85714fe1a1e
Author: em-dash <33614480+em-dash@users.noreply.github.com>
Date:   Sat Feb 24 20:49:51 2024 +1100

    fix crash in underline drawing math

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 55a29d80..163a8fb7 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -80,7 +80,7 @@ const Draw = struct {
         // Ensure we never overflow out of bounds on the canvas
         const y_max = self.height -| 1;
         const bottom = @min(self.pos + self.thickness, y_max);
-        const y = @as(i32, @intCast(bottom - self.thickness));
+        const y = @as(i32, @intCast(bottom)) - @as(i32, @intCast(self.thickness));
 
         canvas.rect(.{
             .x = 0,

commit 759c8cddb4f705902762cf8efdbda8522eefc78d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 24 09:30:04 2024 -0800

    font/sprite: test for thick underline, assertion on x/y for rect

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 163a8fb7..64859b0a 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -80,7 +80,7 @@ const Draw = struct {
         // Ensure we never overflow out of bounds on the canvas
         const y_max = self.height -| 1;
         const bottom = @min(self.pos + self.thickness, y_max);
-        const y = @as(i32, @intCast(bottom)) - @as(i32, @intCast(self.thickness));
+        const y = @as(i32, @intCast(bottom -| self.thickness));
 
         canvas.rect(.{
             .x = 0,
@@ -224,6 +224,26 @@ test "single" {
     );
 }
 
+test "single large thickness" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
+    defer atlas_greyscale.deinit(alloc);
+
+    // unrealistic thickness but used to cause a crash
+    // https://github.com/mitchellh/ghostty/pull/1548
+    _ = try renderGlyph(
+        alloc,
+        &atlas_greyscale,
+        .underline,
+        36,
+        18,
+        9,
+        200,
+    );
+}
+
 test "curly" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit 796d1312ff2732c53b0872cdefec0ab0eb634000
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 24 13:19:49 2024 -0800

    font/sprite: rect must be smaller than canvas dims

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 64859b0a..064efc74 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -80,13 +80,14 @@ const Draw = struct {
         // Ensure we never overflow out of bounds on the canvas
         const y_max = self.height -| 1;
         const bottom = @min(self.pos + self.thickness, y_max);
-        const y = @as(i32, @intCast(bottom -| self.thickness));
+        const y = bottom -| self.thickness;
+        const max_height = self.height - y;
 
         canvas.rect(.{
             .x = 0,
-            .y = y,
+            .y = @intCast(y),
             .width = self.width,
-            .height = self.thickness,
+            .height = @min(self.thickness, max_height),
         }, .on);
     }
 

commit 0f348e809eb88d8c0313e794ededf9d2fd590b0a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 22 10:25:33 2024 -0700

    font: strikethrough uses sprite rendering

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 064efc74..19e228de 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -7,6 +7,9 @@
 //! to maintain and debug another set of shaders for each renderer instead of
 //! just relying on the glyph system we already need to support for text
 //! anyways.
+//!
+//! This also renders strikethrough, so its really more generally a
+//! "horizontal line" renderer.
 const std = @import("std");
 const builtin = @import("builtin");
 const assert = std.debug.assert;
@@ -71,6 +74,7 @@ const Draw = struct {
             .underline_dotted => self.drawDotted(canvas),
             .underline_dashed => self.drawDashed(canvas),
             .underline_curly => self.drawCurly(canvas),
+            .strikethrough => self.drawSingle(canvas),
             else => unreachable,
         }
     }
@@ -225,6 +229,24 @@ test "single" {
     );
 }
 
+test "strikethrough" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
+    defer atlas_greyscale.deinit(alloc);
+
+    _ = try renderGlyph(
+        alloc,
+        &atlas_greyscale,
+        .strikethrough,
+        36,
+        18,
+        9,
+        2,
+    );
+}
+
 test "single large thickness" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit f9be02a20f9f77649efad3f6fda3dd15639ef252
Author: ≈Åukasz Niemier <lukasz@niemier.pl>
Date:   Mon Aug 5 13:56:57 2024 +0200

    chore: clean up typos

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 19e228de..668b168d 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -184,7 +184,7 @@ const Draw = struct {
             break :pos y_max - (MIN_AMPLITUDE * 2);
         };
 
-        // The full aplitude of the wave can be from the bottom to the
+        // The full amplitude of the wave can be from the bottom to the
         // underline position. We also calculate our mid y point of the wave
         const double_amplitude: f64 = @floatFromInt(y_max - pos);
         const half_amplitude: f64 = @max(1, double_amplitude / 4);

commit 10b8ca3c694aa5e0b5cf7eaaae79a4990e3774c3
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Aug 11 18:02:12 2024 -0400

    spelling: normalize grey -> gray

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 668b168d..b22db4f5 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -215,12 +215,12 @@ test "single" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
-    defer atlas_greyscale.deinit(alloc);
+    var atlas_grayscale = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas_grayscale.deinit(alloc);
 
     _ = try renderGlyph(
         alloc,
-        &atlas_greyscale,
+        &atlas_grayscale,
         .underline,
         36,
         18,
@@ -233,12 +233,12 @@ test "strikethrough" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
-    defer atlas_greyscale.deinit(alloc);
+    var atlas_grayscale = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas_grayscale.deinit(alloc);
 
     _ = try renderGlyph(
         alloc,
-        &atlas_greyscale,
+        &atlas_grayscale,
         .strikethrough,
         36,
         18,
@@ -251,14 +251,14 @@ test "single large thickness" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
-    defer atlas_greyscale.deinit(alloc);
+    var atlas_grayscale = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas_grayscale.deinit(alloc);
 
     // unrealistic thickness but used to cause a crash
     // https://github.com/mitchellh/ghostty/pull/1548
     _ = try renderGlyph(
         alloc,
-        &atlas_greyscale,
+        &atlas_grayscale,
         .underline,
         36,
         18,
@@ -271,12 +271,12 @@ test "curly" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas_greyscale = try font.Atlas.init(alloc, 512, .greyscale);
-    defer atlas_greyscale.deinit(alloc);
+    var atlas_grayscale = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas_grayscale.deinit(alloc);
 
     _ = try renderGlyph(
         alloc,
-        &atlas_greyscale,
+        &atlas_grayscale,
         .underline_curly,
         36,
         18,

commit 6917bcacad036e89d9efa666b0e607d840067d2c
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Thu Aug 8 11:13:30 2024 -0400

    font/sprite: fix 1px gap at right edge of dotted and dashed underlines

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index b22db4f5..c60fd71b 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -133,7 +133,7 @@ const Draw = struct {
         while (i < dot_count) : (i += 2) {
             // Ensure we never go out of bounds for the rect
             const x = @min(i * dot_width, self.width - 1);
-            const width = @min(self.width - 1 - x, dot_width);
+            const width = @min(self.width - x, dot_width);
             canvas.rect(.{
                 .x = @intCast(i * dot_width),
                 .y = @intCast(y),
@@ -154,7 +154,7 @@ const Draw = struct {
         while (i < dash_count) : (i += 2) {
             // Ensure we never go out of bounds for the rect
             const x = @min(i * dash_width, self.width - 1);
-            const width = @min(self.width - 1 - x, dash_width);
+            const width = @min(self.width - x, dash_width);
             canvas.rect(.{
                 .x = @intCast(x),
                 .y = @intCast(y),

commit b3a7901b791b5639f3c68954c67a6046470a5012
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 18:12:56 2024 -0600

    font/sprite: rework underline rendering, adjust positioning

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index c60fd71b..af0dd739 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -27,189 +27,166 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
-    // Create the canvas we'll use to draw. We draw the underline in
-    // a full cell size and position it according to "pos".
-    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+    // _ = height;
+
+    // Draw the appropriate sprite
+    var canvas: font.sprite.Canvas, const offset_y: i32 = switch (sprite) {
+        .underline => try drawSingle(alloc, width, line_thickness),
+        .underline_double => try drawDouble(alloc, width, line_thickness),
+        .underline_dotted => try drawDotted(alloc, width, line_thickness),
+        .underline_dashed => try drawDashed(alloc, width, line_thickness),
+        .underline_curly => try drawCurly(alloc, width, line_thickness),
+        .strikethrough => try drawSingle(alloc, width, line_thickness),
+        else => unreachable,
+    };
     defer canvas.deinit(alloc);
 
-    // Perform the actual drawing
-    (Draw{
-        .width = width,
-        .height = height,
-        .pos = line_pos,
-        .thickness = line_thickness,
-    }).draw(&canvas, sprite);
-
     // Write the drawing to the atlas
     const region = try canvas.writeAtlas(alloc, atlas);
 
-    // Our coordinates start at the BOTTOM for our renderers so we have to
-    // specify an offset of the full height because we rendered a full size
-    // cell.
-    const offset_y = @as(i32, @intCast(height));
-
     return font.Glyph{
         .width = width,
-        .height = height,
+        .height = @intCast(region.height),
         .offset_x = 0,
-        .offset_y = offset_y,
+        .offset_y = @as(i32, @intCast(height + region.height)) - @as(i32, @intCast(line_pos)) + offset_y + 1,
         .atlas_x = region.x,
         .atlas_y = region.y,
         .advance_x = @floatFromInt(width),
     };
 }
 
-/// Stores drawing state.
-const Draw = struct {
-    width: u32,
-    height: u32,
-    pos: u32,
-    thickness: u32,
-
-    /// Draw a specific underline sprite to the canvas.
-    fn draw(self: Draw, canvas: *font.sprite.Canvas, sprite: Sprite) void {
-        switch (sprite) {
-            .underline => self.drawSingle(canvas),
-            .underline_double => self.drawDouble(canvas),
-            .underline_dotted => self.drawDotted(canvas),
-            .underline_dashed => self.drawDashed(canvas),
-            .underline_curly => self.drawCurly(canvas),
-            .strikethrough => self.drawSingle(canvas),
-            else => unreachable,
-        }
-    }
+/// Draw a single underline.
+fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+    const height: u32 = thickness;
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
-    /// Draw a single underline.
-    fn drawSingle(self: Draw, canvas: *font.sprite.Canvas) void {
-        // Ensure we never overflow out of bounds on the canvas
-        const y_max = self.height -| 1;
-        const bottom = @min(self.pos + self.thickness, y_max);
-        const y = bottom -| self.thickness;
-        const max_height = self.height - y;
+    canvas.rect(.{
+        .x = 0,
+        .y = 0,
+        .width = width,
+        .height = thickness,
+    }, .on);
+
+    const offset_y: i32 = 0;
+
+    return .{ canvas, offset_y };
+}
+
+/// Draw a double underline.
+fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+    const height: u32 = thickness * 3;
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+
+    canvas.rect(.{
+        .x = 0,
+        .y = 0,
+        .width = width,
+        .height = thickness,
+    }, .on);
+
+    canvas.rect(.{
+        .x = 0,
+        .y = @intCast(thickness * 2),
+        .width = width,
+        .height = thickness,
+    }, .on);
 
+    const offset_y: i32 = -@as(i32, @intCast(thickness));
+
+    return .{ canvas, offset_y };
+}
+
+/// Draw a dotted underline.
+fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+    const height: u32 = thickness;
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+
+    const dot_width = @max(thickness, 3);
+    const dot_count = width / dot_width;
+    var i: u32 = 0;
+    while (i < dot_count) : (i += 2) {
+        // Ensure we never go out of bounds for the rect
+        const x = @min(i * dot_width, width - 1);
+        const rect_width = @min(width - x, dot_width);
         canvas.rect(.{
-            .x = 0,
-            .y = @intCast(y),
-            .width = self.width,
-            .height = @min(self.thickness, max_height),
+            .x = @intCast(i * dot_width),
+            .y = 0,
+            .width = rect_width,
+            .height = thickness,
         }, .on);
     }
 
-    /// Draw a double underline.
-    fn drawDouble(self: Draw, canvas: *font.sprite.Canvas) void {
-        // The maximum y value has to have space for the bottom underline.
-        // If we underflow (saturated) to 0, then we don't draw. This should
-        // never happen but we don't want to draw something undefined.
-        const y_max = self.height -| 1 -| self.thickness;
-        if (y_max == 0) return;
+    const offset_y: i32 = 0;
 
-        const space = self.thickness * 2;
-        const bottom = @min(self.pos + space, y_max);
-        const top = bottom - space;
+    return .{ canvas, offset_y };
+}
 
-        canvas.rect(.{
-            .x = 0,
-            .y = @intCast(top),
-            .width = self.width,
-            .height = self.thickness,
-        }, .on);
+/// Draw a dashed underline.
+fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+    const height: u32 = thickness;
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
+    const dash_width = width / 3 + 1;
+    const dash_count = (width / dash_width) + 1;
+    var i: u32 = 0;
+    while (i < dash_count) : (i += 2) {
+        // Ensure we never go out of bounds for the rect
+        const x = @min(i * dash_width, width - 1);
+        const rect_width = @min(width - x, dash_width);
         canvas.rect(.{
-            .x = 0,
-            .y = @intCast(bottom),
-            .width = self.width,
-            .height = self.thickness,
+            .x = @intCast(x),
+            .y = 0,
+            .width = rect_width,
+            .height = thickness,
         }, .on);
     }
 
-    /// Draw a dotted underline.
-    fn drawDotted(self: Draw, canvas: *font.sprite.Canvas) void {
-        const y_max = self.height -| 1 -| self.thickness;
-        if (y_max == 0) return;
-        const y = @min(self.pos, y_max);
-        const dot_width = @max(self.thickness, 3);
-        const dot_count = self.width / dot_width;
-        var i: u32 = 0;
-        while (i < dot_count) : (i += 2) {
-            // Ensure we never go out of bounds for the rect
-            const x = @min(i * dot_width, self.width - 1);
-            const width = @min(self.width - x, dot_width);
-            canvas.rect(.{
-                .x = @intCast(i * dot_width),
-                .y = @intCast(y),
-                .width = width,
-                .height = self.thickness,
-            }, .on);
-        }
-    }
+    const offset_y: i32 = 0;
 
-    /// Draw a dashed underline.
-    fn drawDashed(self: Draw, canvas: *font.sprite.Canvas) void {
-        const y_max = self.height -| 1 -| self.thickness;
-        if (y_max == 0) return;
-        const y = @min(self.pos, y_max);
-        const dash_width = self.width / 3 + 1;
-        const dash_count = (self.width / dash_width) + 1;
-        var i: u32 = 0;
-        while (i < dash_count) : (i += 2) {
-            // Ensure we never go out of bounds for the rect
-            const x = @min(i * dash_width, self.width - 1);
-            const width = @min(self.width - x, dash_width);
-            canvas.rect(.{
-                .x = @intCast(x),
-                .y = @intCast(y),
-                .width = width,
-                .height = self.thickness,
-            }, .on);
-        }
-    }
+    return .{ canvas, offset_y };
+}
 
-    /// Draw a curly underline. Thanks to Wez Furlong for providing
-    /// the basic math structure for this since I was lazy with the
-    /// geometry.
-    fn drawCurly(self: Draw, canvas: *font.sprite.Canvas) void {
-        // This is the lowest that the curl can go.
-        const y_max = self.height - 1;
-
-        // Calculate the wave period for a single character
-        //   `2 * pi...` = 1 peak per character
-        //   `4 * pi...` = 2 peaks per character
-        const wave_period = 2 * std.math.pi / @as(f64, @floatFromInt(self.width - 1));
-
-        // Some fonts put the underline too close to the bottom of the
-        // cell height and this doesn't allow us to make a high enough
-        // wave. This constant is arbitrary, change it for aesthetics.
-        const pos: u32 = pos: {
-            const MIN_AMPLITUDE: u32 = @max(self.height / 9, 2);
-            break :pos y_max - (MIN_AMPLITUDE * 2);
-        };
-
-        // The full amplitude of the wave can be from the bottom to the
-        // underline position. We also calculate our mid y point of the wave
-        const double_amplitude: f64 = @floatFromInt(y_max - pos);
-        const half_amplitude: f64 = @max(1, double_amplitude / 4);
-        const y_mid: u32 = pos + @as(u32, @intFromFloat(2 * half_amplitude));
-
-        // follow Xiaolin Wu's antialias algorithm to draw the curve
-        var x: u32 = 0;
-        while (x < self.width) : (x += 1) {
-            const y: f64 = @as(f64, @floatFromInt(y_mid)) + (half_amplitude * @cos(@as(f64, @floatFromInt(x)) * wave_period));
-            const y_upper: u32 = @intFromFloat(@floor(y));
-            const y_lower: u32 = y_upper + self.thickness;
-            const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
-
-            // upper and lower bounds
-            canvas.pixel(x, @min(y_upper, y_max), @enumFromInt(255 - alpha));
-            canvas.pixel(x, @min(y_lower, y_max), @enumFromInt(alpha));
-
-            // fill between upper and lower bound
-            var y_fill: u32 = y_upper + 1;
-            while (y_fill < y_lower) : (y_fill += 1) {
-                canvas.pixel(x, @min(y_fill, y_max), .on);
-            }
+/// Draw a curly underline. Thanks to Wez Furlong for providing
+/// the basic math structure for this since I was lazy with the
+/// geometry.
+fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+    const height: u32 = thickness * 4;
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+
+    // Calculate the wave period for a single character
+    //   `2 * pi...` = 1 peak per character
+    //   `4 * pi...` = 2 peaks per character
+    const wave_period = 2 * std.math.pi / @as(f64, @floatFromInt(width - 1));
+
+    // The full amplitude of the wave can be from the bottom to the
+    // underline position. We also calculate our mid y point of the wave
+    const half_amplitude: f64 = @as(f64, @floatFromInt(thickness));
+    const y_mid: f64 = half_amplitude + 1;
+
+    // follow Xiaolin Wu's antialias algorithm to draw the curve
+    var x: u32 = 0;
+    while (x < width) : (x += 1) {
+        const cosx: f64 = @cos(@as(f64, @floatFromInt(x)) * wave_period);
+        const y: f64 = y_mid + half_amplitude * cosx;
+        const y_upper: u32 = @intFromFloat(@floor(y));
+        const y_lower: u32 = y_upper + thickness + (thickness >> 1);
+        const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
+
+        // upper and lower bounds
+        canvas.pixel(x, @min(y_upper, height), @enumFromInt(255 - alpha));
+        canvas.pixel(x, @min(y_lower, height), @enumFromInt(alpha));
+
+        // fill between upper and lower bound
+        var y_fill: u32 = y_upper + 1;
+        while (y_fill < y_lower) : (y_fill += 1) {
+            canvas.pixel(x, @min(y_fill, height), .on);
         }
     }
-};
+
+    const offset_y: i32 = -@as(i32, @intCast(thickness * 2));
+
+    return .{ canvas, offset_y };
+}
 
 test "single" {
     const testing = std.testing;

commit 49a3008919378f2dde829941a5fb0e33defbf39c
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 19:41:49 2024 -0600

    font/sprite: reduce uneven gaps in dotted underline

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index af0dd739..f38bc50e 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -102,14 +102,15 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprit
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
     const dot_width = @max(thickness, 3);
-    const dot_count = width / dot_width;
+    const dot_count = @max((width / dot_width) / 2, 1);
+    const gap_width = try std.math.divCeil(u32, width -| (dot_count * dot_width), dot_count);
     var i: u32 = 0;
-    while (i < dot_count) : (i += 2) {
+    while (i < dot_count) : (i += 1) {
         // Ensure we never go out of bounds for the rect
-        const x = @min(i * dot_width, width - 1);
+        const x = @min(i * (dot_width + gap_width), width - 1);
         const rect_width = @min(width - x, dot_width);
         canvas.rect(.{
-            .x = @intCast(i * dot_width),
+            .x = @intCast(x),
             .y = 0,
             .width = rect_width,
             .height = thickness,

commit 9a87001fa649eb5a8ee2ff9afc31a943963d912c
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Sep 25 11:46:43 2024 -0600

    font/sprite: correct underline placement calculation

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index f38bc50e..08e74c78 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -27,9 +27,7 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
-    // _ = height;
-
-    // Draw the appropriate sprite
+   // Draw the appropriate sprite
     var canvas: font.sprite.Canvas, const offset_y: i32 = switch (sprite) {
         .underline => try drawSingle(alloc, width, line_thickness),
         .underline_double => try drawDouble(alloc, width, line_thickness),
@@ -48,15 +46,24 @@ pub fn renderGlyph(
         .width = width,
         .height = @intCast(region.height),
         .offset_x = 0,
-        .offset_y = @as(i32, @intCast(height + region.height)) - @as(i32, @intCast(line_pos)) + offset_y + 1,
+        // Glyph.offset_y is the distance between the top of the glyph and the
+        // bottom of the cell. We want the top of the glyph to be at line_pos
+        // from the TOP of the cell, and then offset by the offset_y from the
+        // draw function.
+        .offset_y = @as(i32, @intCast(height - line_pos)) - offset_y,
         .atlas_x = region.x,
         .atlas_y = region.y,
         .advance_x = @floatFromInt(width),
     };
 }
 
+/// A tuple with the canvas that the desired sprite was drawn on and
+/// a recommended offset (+Y = down) to shift its Y position by, to
+/// correct for underline styles with additional thickness.
+const CanvasAndOffset = struct { font.sprite.Canvas, i32 };
+
 /// Draw a single underline.
-fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const height: u32 = thickness;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
@@ -73,7 +80,7 @@ fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprit
 }
 
 /// Draw a double underline.
-fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const height: u32 = thickness * 3;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
@@ -97,7 +104,7 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprit
 }
 
 /// Draw a dotted underline.
-fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const height: u32 = thickness;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
@@ -123,7 +130,7 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprit
 }
 
 /// Draw a dashed underline.
-fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const height: u32 = thickness;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
@@ -150,7 +157,7 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprit
 /// Draw a curly underline. Thanks to Wez Furlong for providing
 /// the basic math structure for this since I was lazy with the
 /// geometry.
-fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !struct { font.sprite.Canvas, i32 } {
+fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const height: u32 = thickness * 4;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 

commit f67a647a12d6b361342e5fe4df5029fce4009d5c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 29 09:33:28 2024 -0700

    font/sprite: bounds checking for pixel writes on Pixman

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 08e74c78..0f00dffe 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -27,7 +27,7 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
-   // Draw the appropriate sprite
+    // Draw the appropriate sprite
     var canvas: font.sprite.Canvas, const offset_y: i32 = switch (sprite) {
         .underline => try drawSingle(alloc, width, line_thickness),
         .underline_double => try drawDouble(alloc, width, line_thickness),

commit bbacee66d0aecdb049598bbc1d950af5755cc175
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 29 09:39:17 2024 -0700

    font/sprite: fix out of bounds right on curly underline
    
    Fixes #2321

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 0f00dffe..03ce2872 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -181,13 +181,13 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
 
         // upper and lower bounds
-        canvas.pixel(x, @min(y_upper, height), @enumFromInt(255 - alpha));
-        canvas.pixel(x, @min(y_lower, height), @enumFromInt(alpha));
+        canvas.pixel(x, @min(y_upper, height - 1), @enumFromInt(255 - alpha));
+        canvas.pixel(x, @min(y_lower, height - 1), @enumFromInt(alpha));
 
         // fill between upper and lower bound
         var y_fill: u32 = y_upper + 1;
         while (y_fill < y_lower) : (y_fill += 1) {
-            canvas.pixel(x, @min(y_fill, height), .on);
+            canvas.pixel(x, @min(y_fill, height - 1), .on);
         }
     }
 

commit 156f735f8d87102142563cfdbbc7245d596c2636
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sat Oct 5 21:53:58 2024 -0400

    font/sprite: fix undercurl rendering
    
    - Limit max amplitude relative to cell width to avoid being too wavy
    - Fix application of xiaolin-wu's for anti-aliasing too always be at
    least 1px thick.
    - Fix height calculation to avoid clipping bottom of wave at small
    sizes.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 03ce2872..50a2a286 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -158,26 +158,30 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 /// the basic math structure for this since I was lazy with the
 /// geometry.
 fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
-    const height: u32 = thickness * 4;
-    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+    const float_width: f64 = @floatFromInt(width);
+    const float_thick: f64 = @floatFromInt(thickness);
 
     // Calculate the wave period for a single character
     //   `2 * pi...` = 1 peak per character
     //   `4 * pi...` = 2 peaks per character
-    const wave_period = 2 * std.math.pi / @as(f64, @floatFromInt(width - 1));
+    const wave_period = 2 * std.math.pi / float_width;
 
     // The full amplitude of the wave can be from the bottom to the
     // underline position. We also calculate our mid y point of the wave
-    const half_amplitude: f64 = @as(f64, @floatFromInt(thickness));
+    const half_amplitude = @min(float_width / 6, float_thick * 2);
     const y_mid: f64 = half_amplitude + 1;
 
+    const height: u32 = @intFromFloat(@ceil(half_amplitude * 4 + 2));
+
+    var canvas = try font.sprite.Canvas.init(alloc, width, height);
+
     // follow Xiaolin Wu's antialias algorithm to draw the curve
     var x: u32 = 0;
     while (x < width) : (x += 1) {
         const cosx: f64 = @cos(@as(f64, @floatFromInt(x)) * wave_period);
         const y: f64 = y_mid + half_amplitude * cosx;
         const y_upper: u32 = @intFromFloat(@floor(y));
-        const y_lower: u32 = y_upper + thickness + (thickness >> 1);
+        const y_lower: u32 = y_upper + thickness + 1;
         const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
 
         // upper and lower bounds
@@ -191,7 +195,7 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         }
     }
 
-    const offset_y: i32 = -@as(i32, @intCast(thickness * 2));
+    const offset_y: i32 = @intFromFloat(-@round(half_amplitude));
 
     return .{ canvas, offset_y };
 }

commit fd49fb7338249291217be35bf830a1dcf36287e8
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sat Oct 5 22:08:17 2024 -0400

    font/sprite: improve double underline legibility with min 2px gap
    
    At small thicknesses, the legibility of the double underline is not
    great when it's a 1px line, a 1px gap, and another 1px line.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 50a2a286..3648fb97 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -81,7 +81,11 @@ fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 
 /// Draw a double underline.
 fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
-    const height: u32 = thickness * 3;
+    // Our gap between lines will be at least 2px.
+    // (i.e. if our thickness is 1, we still have a gap of 2)
+    const gap = @max(2, thickness);
+
+    const height: u32 = thickness * 2 * gap;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
     canvas.rect(.{
@@ -93,7 +97,7 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 
     canvas.rect(.{
         .x = 0,
-        .y = @intCast(thickness * 2),
+        .y = @intCast(thickness + gap),
         .width = width,
         .height = thickness,
     }, .on);

commit c454ef627b8d08fff2c4465da97cbb37c0cead65
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sat Oct 5 22:12:59 2024 -0400

    fix(font/sprite): avoid underflow
    
    There's a degenerate case where height < line_pos

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 3648fb97..eead4081 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -50,7 +50,7 @@ pub fn renderGlyph(
         // bottom of the cell. We want the top of the glyph to be at line_pos
         // from the TOP of the cell, and then offset by the offset_y from the
         // draw function.
-        .offset_y = @as(i32, @intCast(height - line_pos)) - offset_y,
+        .offset_y = @as(i32, @intCast(height -| line_pos)) - offset_y,
         .atlas_x = region.x,
         .atlas_y = region.y,
         .advance_x = @floatFromInt(width),

commit 06a37f32bea95bbe9ad727efe85ac47587535e68
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Oct 6 00:22:08 2024 -0400

    font/sprite: use offset curve approximation for undercurl

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index eead4081..67bc38b4 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -172,25 +172,49 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 
     // The full amplitude of the wave can be from the bottom to the
     // underline position. We also calculate our mid y point of the wave
-    const half_amplitude = @min(float_width / 6, float_thick * 2);
-    const y_mid: f64 = half_amplitude + 1;
+    const half_amplitude = 1.0 / wave_period;
+    const y_mid: f64 = half_amplitude + float_thick * 0.5 + 1;
 
-    const height: u32 = @intFromFloat(@ceil(half_amplitude * 4 + 2));
+    // This is used in calculating the offset curve estimate below.
+    const offset_factor = @min(1.0, float_thick * 0.5 * wave_period) * @min(1.0, half_amplitude * wave_period);
+
+    const height: u32 = @intFromFloat(@ceil(half_amplitude + float_thick + 1) * 2);
 
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
     // follow Xiaolin Wu's antialias algorithm to draw the curve
     var x: u32 = 0;
     while (x < width) : (x += 1) {
-        const cosx: f64 = @cos(@as(f64, @floatFromInt(x)) * wave_period);
+        const t: f64 = @as(f64, @floatFromInt(x)) * wave_period;
+        // Use the slope at this location to add thickness to
+        // the line on this column, counteracting the thinning
+        // caused by the slope.
+        //
+        // This is not the exact offset curve for a sine wave,
+        // but it's a decent enough approximation.
+        //
+        // How did I derive this? I stared at Desmos and fiddled
+        // with numbers for an hour until it was good enough.
+        const t_u: f64 = t + std.math.pi;
+        const slope_factor_u: f64 = (@sin(t_u) * @sin(t_u) * offset_factor) / ((1.0 + @cos(t_u / 2) * @cos(t_u / 2) * 2) * wave_period);
+        const slope_factor_l: f64 = (@sin(t) * @sin(t) * offset_factor) / ((1.0 + @cos(t / 2) * @cos(t / 2) * 2) * wave_period);
+
+        const cosx: f64 = @cos(t);
+        // This will be the center of our stroke.
         const y: f64 = y_mid + half_amplitude * cosx;
-        const y_upper: u32 = @intFromFloat(@floor(y));
-        const y_lower: u32 = y_upper + thickness + 1;
-        const alpha: u8 = @intFromFloat(255 * @abs(y - @floor(y)));
+
+        // The upper pixel and lower pixel are
+        // calculated relative to the center.
+        const y_u: f64 = y - float_thick * 0.5 - slope_factor_u;
+        const y_l: f64 = y + float_thick * 0.5 + slope_factor_l;
+        const y_upper: u32 = @intFromFloat(@floor(y_u));
+        const y_lower: u32 = @intFromFloat(@ceil(y_l));
+        const alpha_u: u8 = @intFromFloat(@round(255 * (1.0 - @abs(y_u - @floor(y_u)))));
+        const alpha_l: u8 = @intFromFloat(@round(255 * (1.0 - @abs(y_l - @ceil(y_l)))));
 
         // upper and lower bounds
-        canvas.pixel(x, @min(y_upper, height - 1), @enumFromInt(255 - alpha));
-        canvas.pixel(x, @min(y_lower, height - 1), @enumFromInt(alpha));
+        canvas.pixel(x, @min(y_upper, height - 1), @enumFromInt(alpha_u));
+        canvas.pixel(x, @min(y_lower, height - 1), @enumFromInt(alpha_l));
 
         // fill between upper and lower bound
         var y_fill: u32 = y_upper + 1;

commit 63f82119cd7ecd7fac632fc52a865a0a67a04ad9
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Oct 14 14:46:43 2024 -0400

    font/sprite(underline): add thickness correction to undercurl

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 67bc38b4..3a7d5cb9 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -163,7 +163,9 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 /// geometry.
 fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const float_width: f64 = @floatFromInt(width);
-    const float_thick: f64 = @floatFromInt(thickness);
+    // Because of we way we draw the undercurl, we end up making it around 1px
+    // thicker than it should be, to fix this we just reduce the thickness by 1.
+    const float_thick: f64 = @floatFromInt(@max(1, thickness -| 1));
 
     // Calculate the wave period for a single character
     //   `2 * pi...` = 1 peak per character

commit 2462921681d7967d4f9079e5ba050a1a044ad087
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Oct 14 14:53:09 2024 -0400

    font/sprite(underline): make undercurl segment symmetrical
    
    Previously was biased half a pixel to one side.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 3a7d5cb9..29bf7b25 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -187,7 +187,9 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     // follow Xiaolin Wu's antialias algorithm to draw the curve
     var x: u32 = 0;
     while (x < width) : (x += 1) {
-        const t: f64 = @as(f64, @floatFromInt(x)) * wave_period;
+        // We sample the wave function at the *middle* of each
+        // pixel column, to ensure that it renders symmetrically.
+        const t: f64 = (@as(f64, @floatFromInt(x)) + 0.5) * wave_period;
         // Use the slope at this location to add thickness to
         // the line on this column, counteracting the thinning
         // caused by the slope.

commit d38d0f30c4860dfae4091d4e064f9dcc804794b7
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Oct 9 19:31:13 2024 -0400

    font/sprite: replace pixman with z2d, extend Box coverage
    
    More complete coverage of the Symbols For Legacy Computing block,
    including characters from Unicode 16.0.
    
    Pixman and the web canvas impl for Canvas have been removed in favor of
    z2d for drawing, since it has a nicer API with more powerful methods,
    and is in Zig with no specific platform optimizations so should compile
    to wasm no problem.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 29bf7b25..cd580d14 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -70,8 +70,8 @@ fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     canvas.rect(.{
         .x = 0,
         .y = 0,
-        .width = width,
-        .height = thickness,
+        .width = @floatFromInt(width),
+        .height = @floatFromInt(thickness),
     }, .on);
 
     const offset_y: i32 = 0;
@@ -91,15 +91,15 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     canvas.rect(.{
         .x = 0,
         .y = 0,
-        .width = width,
-        .height = thickness,
+        .width = @floatFromInt(width),
+        .height = @floatFromInt(thickness),
     }, .on);
 
     canvas.rect(.{
         .x = 0,
-        .y = @intCast(thickness + gap),
-        .width = width,
-        .height = thickness,
+        .y = @floatFromInt(thickness * 2),
+        .width = @floatFromInt(width),
+        .height = @floatFromInt(thickness),
     }, .on);
 
     const offset_y: i32 = -@as(i32, @intCast(thickness));
@@ -121,10 +121,10 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const x = @min(i * (dot_width + gap_width), width - 1);
         const rect_width = @min(width - x, dot_width);
         canvas.rect(.{
-            .x = @intCast(x),
+            .x = @floatFromInt(x),
             .y = 0,
-            .width = rect_width,
-            .height = thickness,
+            .width = @floatFromInt(rect_width),
+            .height = @floatFromInt(thickness),
         }, .on);
     }
 
@@ -146,10 +146,10 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const x = @min(i * dash_width, width - 1);
         const rect_width = @min(width - x, dash_width);
         canvas.rect(.{
-            .x = @intCast(x),
+            .x = @floatFromInt(x),
             .y = 0,
-            .width = rect_width,
-            .height = thickness,
+            .width = @floatFromInt(rect_width),
+            .height = @floatFromInt(thickness),
         }, .on);
     }
 

commit c66042d6e06aeb004f346255bb5587b2b2af865f
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Tue Oct 15 11:59:52 2024 -0400

    font/sprite: address PR review feedback
    
    - Make canvas geometry primitives generic, use `Rect(u32)` for `rect`
    function, so that we don't have to worry about negatives or rounding.
    - Make `Quads` struct packed just in case it gets non-comptime use in
    the future.
    - Clarify comment on why we're discarding out of range pixels + runtime
    unreachable for any other type of error which we shouldn't ever see.
    - Move z2d import above in-tree imports.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index cd580d14..10e3e82f 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -70,8 +70,8 @@ fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     canvas.rect(.{
         .x = 0,
         .y = 0,
-        .width = @floatFromInt(width),
-        .height = @floatFromInt(thickness),
+        .width = width,
+        .height = thickness,
     }, .on);
 
     const offset_y: i32 = 0;
@@ -91,15 +91,15 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     canvas.rect(.{
         .x = 0,
         .y = 0,
-        .width = @floatFromInt(width),
-        .height = @floatFromInt(thickness),
+        .width = width,
+        .height = thickness,
     }, .on);
 
     canvas.rect(.{
         .x = 0,
-        .y = @floatFromInt(thickness * 2),
-        .width = @floatFromInt(width),
-        .height = @floatFromInt(thickness),
+        .y = thickness * 2,
+        .width = width,
+        .height = thickness,
     }, .on);
 
     const offset_y: i32 = -@as(i32, @intCast(thickness));
@@ -121,10 +121,10 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const x = @min(i * (dot_width + gap_width), width - 1);
         const rect_width = @min(width - x, dot_width);
         canvas.rect(.{
-            .x = @floatFromInt(x),
+            .x = @intCast(x),
             .y = 0,
-            .width = @floatFromInt(rect_width),
-            .height = @floatFromInt(thickness),
+            .width = rect_width,
+            .height = thickness,
         }, .on);
     }
 
@@ -146,10 +146,10 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const x = @min(i * dash_width, width - 1);
         const rect_width = @min(width - x, dash_width);
         canvas.rect(.{
-            .x = @floatFromInt(x),
+            .x = @intCast(x),
             .y = 0,
-            .width = @floatFromInt(rect_width),
-            .height = @floatFromInt(thickness),
+            .width = rect_width,
+            .height = thickness,
         }, .on);
     }
 

commit 2a4398b319eac076ddf5d55f3472c54986b24e80
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Thu Oct 17 21:07:52 2024 -0400

    font/sprite: undercurl minimum thickness improvement

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 10e3e82f..07421215 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -165,7 +165,11 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const float_width: f64 = @floatFromInt(width);
     // Because of we way we draw the undercurl, we end up making it around 1px
     // thicker than it should be, to fix this we just reduce the thickness by 1.
-    const float_thick: f64 = @floatFromInt(@max(1, thickness -| 1));
+    //
+    // We use a minimum thickness of 0.414 because this empirically produces
+    // the nicest undercurls at 1px underline thickness; thinner tends to look
+    // too thin compared to straight underlines and has artefacting.
+    const float_thick: f64 = @max(0.414, @as(f64, @floatFromInt(thickness -| 1)));
 
     // Calculate the wave period for a single character
     //   `2 * pi...` = 1 peak per character

commit 4496e7d314adf883726ec821753d824e34337069
Author: Marijn Besseling <njirambem@gmail.com>
Date:   Sun Oct 20 12:51:18 2024 +0200

    implement overline decoration (SGR 53/55)

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index 07421215..e54807bc 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -34,6 +34,7 @@ pub fn renderGlyph(
         .underline_dotted => try drawDotted(alloc, width, line_thickness),
         .underline_dashed => try drawDashed(alloc, width, line_thickness),
         .underline_curly => try drawCurly(alloc, width, line_thickness),
+        .overline => try drawSingle(alloc, width, line_thickness),
         .strikethrough => try drawSingle(alloc, width, line_thickness),
         else => unreachable,
     };

commit b920352c397c274985420ffc68ab7b3e425f45b6
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Dec 22 15:57:07 2024 -0500

    deps: update z2d to v0.4.0
    
    Introduces static path methods and a reworked context API that makes
    things generally cleaner.
    
    This update incidentally fixed a bug we had before where the corner
    triangle shade characters were drawn solid rather than medium shade.

diff --git a/src/font/sprite/underline.zig b/src/font/sprite/underline.zig
index e54807bc..d2e439e6 100644
--- a/src/font/sprite/underline.zig
+++ b/src/font/sprite/underline.zig
@@ -38,7 +38,7 @@ pub fn renderGlyph(
         .strikethrough => try drawSingle(alloc, width, line_thickness),
         else => unreachable,
     };
-    defer canvas.deinit(alloc);
+    defer canvas.deinit();
 
     // Write the drawing to the atlas
     const region = try canvas.writeAtlas(alloc, atlas);

