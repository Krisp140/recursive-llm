# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
new file mode 100644
index 000000000..45de6fd39
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -0,0 +1,155 @@
+import { TestEditor } from '../../../test/TestEditor'
+import { TextShapeTool } from './TextShapeTool'
+
+let editor: TestEditor
+
+beforeEach(() => {
+	editor = new TestEditor()
+})
+
+afterEach(() => {
+	editor?.dispose()
+})
+
+describe(TextShapeTool, () => {
+	it('Creates text, edits it, undoes and redoes', () => {
+		expect(editor.shapesArray.length).toBe(0)
+		editor.setCurrentTool('text')
+		editor.expectToBeIn('text.idle')
+		editor.pointerDown(0, 0)
+		editor.expectToBeIn('text.pointing')
+		editor.pointerUp()
+		editor.expectToBeIn('select.editing_shape')
+		// This comes from the component, not the state chart
+		editor.updateShapes([{ ...editor.shapesArray[0]!, type: 'text', props: { text: 'Hello' } }])
+		// Deselect the editing shape
+		editor.cancel()
+		editor.expectToBeIn('select.idle')
+		expect(editor.shapesArray.length).toBe(1)
+		editor.expectShapeToMatch({
+			id: editor.shapesArray[0].id,
+			type: 'text',
+			props: { text: 'Hello' },
+		})
+
+		editor.undo()
+
+		expect(editor.shapesArray.length).toBe(0)
+
+		editor.redo()
+
+		expect(editor.shapesArray.length).toBe(1)
+
+		editor.expectShapeToMatch({
+			id: editor.shapesArray[0].id,
+			type: 'text',
+			props: { text: 'Hello' },
+		})
+	})
+})
+
+describe('When selecting the tool', () => {
+	it('starts in idle, transitions to pointing and dragging', () => {
+		editor.setCurrentTool('text')
+		editor.expectToBeIn('text.idle')
+	})
+})
+
+describe('When in idle state', () => {
+	it('Transitions to pointing on pointer down', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.expectToBeIn('text.pointing')
+		editor.pointerUp()
+		editor.expectToBeIn('select.editing_shape')
+	})
+
+	it('creates a shape on pointer up', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.pointerUp()
+		editor.expectToBeIn('select.editing_shape')
+		expect(editor.shapesArray.length).toBe(1)
+	})
+
+	it('returns to select on cancel', () => {
+		editor.setCurrentTool('text')
+		editor.cancel()
+		editor.expectToBeIn('select.idle')
+	})
+})
+
+describe('When in the pointing state', () => {
+	it('returns to idle on escape', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.cancel()
+		editor.expectToBeIn('text.idle')
+		expect(editor.shapesArray.length).toBe(0)
+	})
+
+	it('returns to idle on interrupt', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.expectToBeIn('text.pointing')
+		editor.interrupt()
+		editor.expectToBeIn('text.idle')
+		expect(editor.shapesArray.length).toBe(0)
+	})
+
+	it('transitions to select.resizing when dragging and edits on pointer up', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(10, 10)
+		editor.expectToBeIn('select.resizing')
+		editor.pointerUp()
+		expect(editor.shapesArray.length).toBe(1)
+		editor.expectToBeIn('select.editing_shape')
+	})
+
+	it('on pointer up, preserves the center when the text has a auto width', () => {
+		editor.setCurrentTool('text')
+		const x = 0
+		const y = 0
+		editor.pointerDown(x, y)
+		editor.pointerUp()
+		const bounds = editor.getPageBounds(editor.shapesArray[0])!
+		expect(editor.shapesArray[0]).toMatchObject({
+			x: x - bounds.width / 2,
+			y: y - bounds.height / 2,
+		})
+	})
+})
+
+describe('When resizing', () => {
+	it('bails on escape while resizing and returns to text.idle', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(100, 100)
+		editor.expectToBeIn('select.resizing')
+		editor.cancel()
+		editor.expectToBeIn('text.idle')
+		expect(editor.shapesArray.length).toBe(0)
+	})
+
+	it('does not bails on interrupt while resizing', () => {
+		editor.setCurrentTool('text')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(100, 100)
+		editor.expectToBeIn('select.resizing')
+		editor.interrupt()
+		expect(editor.shapesArray.length).toBe(1)
+	})
+
+	it('preserves the top left when the text has a fixed width', () => {
+		editor.setCurrentTool('text')
+		const x = 0
+		const y = 0
+		editor.pointerDown(x, y)
+		editor.pointerMove(x + 100, y + 100)
+		expect(editor.shapesArray[0]).toMatchObject({
+			x,
+			y,
+		})
+	})
+})

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 45de6fd39..a609ab014 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -13,7 +13,7 @@ afterEach(() => {
 
 describe(TextShapeTool, () => {
 	it('Creates text, edits it, undoes and redoes', () => {
-		expect(editor.shapesArray.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 		editor.setCurrentTool('text')
 		editor.expectToBeIn('text.idle')
 		editor.pointerDown(0, 0)
@@ -21,27 +21,29 @@ describe(TextShapeTool, () => {
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
-		editor.updateShapes([{ ...editor.shapesArray[0]!, type: 'text', props: { text: 'Hello' } }])
+		editor.updateShapes([
+			{ ...editor.shapesOnCurrentPage[0]!, type: 'text', props: { text: 'Hello' } },
+		])
 		// Deselect the editing shape
 		editor.cancel()
 		editor.expectToBeIn('select.idle')
-		expect(editor.shapesArray.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 		editor.expectShapeToMatch({
-			id: editor.shapesArray[0].id,
+			id: editor.shapesOnCurrentPage[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
 
 		editor.undo()
 
-		expect(editor.shapesArray.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 
 		editor.redo()
 
-		expect(editor.shapesArray.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 
 		editor.expectShapeToMatch({
-			id: editor.shapesArray[0].id,
+			id: editor.shapesOnCurrentPage[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
@@ -69,7 +71,7 @@ describe('When in idle state', () => {
 		editor.pointerDown(0, 0)
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
-		expect(editor.shapesArray.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 	})
 
 	it('returns to select on cancel', () => {
@@ -85,7 +87,7 @@ describe('When in the pointing state', () => {
 		editor.pointerDown(0, 0)
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesArray.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('returns to idle on interrupt', () => {
@@ -94,7 +96,7 @@ describe('When in the pointing state', () => {
 		editor.expectToBeIn('text.pointing')
 		editor.interrupt()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesArray.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
@@ -103,7 +105,7 @@ describe('When in the pointing state', () => {
 		editor.pointerMove(10, 10)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
-		expect(editor.shapesArray.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -113,8 +115,8 @@ describe('When in the pointing state', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getPageBounds(editor.shapesArray[0])!
-		expect(editor.shapesArray[0]).toMatchObject({
+		const bounds = editor.getPageBounds(editor.shapesOnCurrentPage[0])!
+		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
@@ -129,7 +131,7 @@ describe('When resizing', () => {
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesArray.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('does not bails on interrupt while resizing', () => {
@@ -138,7 +140,7 @@ describe('When resizing', () => {
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
-		expect(editor.shapesArray.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 	})
 
 	it('preserves the top left when the text has a fixed width', () => {
@@ -147,7 +149,7 @@ describe('When resizing', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerMove(x + 100, y + 100)
-		expect(editor.shapesArray[0]).toMatchObject({
+		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
 			x,
 			y,
 		})

commit e17074a8b3a60d26a2e54ca5b5d47622db7676be
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 14:21:14 2023 +0100

    Editor commands API / effects (#1778)
    
    This PR shrinks the commands API surface and adds a manager
    (`CleanupManager`) for side effects.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    Use the app! Especially undo and redo. Our tests are passing but I've
    found more cases where our coverage fails to catch issues.
    
    ### Release Notes
    
    - tbd

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index a609ab014..6f2c17b3d 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -13,7 +13,7 @@ afterEach(() => {
 
 describe(TextShapeTool, () => {
 	it('Creates text, edits it, undoes and redoes', () => {
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 		editor.setCurrentTool('text')
 		editor.expectToBeIn('text.idle')
 		editor.pointerDown(0, 0)
@@ -22,28 +22,28 @@ describe(TextShapeTool, () => {
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
 		editor.updateShapes([
-			{ ...editor.shapesOnCurrentPage[0]!, type: 'text', props: { text: 'Hello' } },
+			{ ...editor.currentPageShapes[0]!, type: 'text', props: { text: 'Hello' } },
 		])
 		// Deselect the editing shape
 		editor.cancel()
 		editor.expectToBeIn('select.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 		editor.expectShapeToMatch({
-			id: editor.shapesOnCurrentPage[0].id,
+			id: editor.currentPageShapes[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
 
 		editor.undo()
 
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 
 		editor.redo()
 
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 
 		editor.expectShapeToMatch({
-			id: editor.shapesOnCurrentPage[0].id,
+			id: editor.currentPageShapes[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
@@ -71,7 +71,7 @@ describe('When in idle state', () => {
 		editor.pointerDown(0, 0)
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 	})
 
 	it('returns to select on cancel', () => {
@@ -87,7 +87,7 @@ describe('When in the pointing state', () => {
 		editor.pointerDown(0, 0)
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('returns to idle on interrupt', () => {
@@ -96,7 +96,7 @@ describe('When in the pointing state', () => {
 		editor.expectToBeIn('text.pointing')
 		editor.interrupt()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
@@ -105,7 +105,7 @@ describe('When in the pointing state', () => {
 		editor.pointerMove(10, 10)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -115,8 +115,8 @@ describe('When in the pointing state', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getPageBounds(editor.shapesOnCurrentPage[0])!
-		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
+		const bounds = editor.getPageBounds(editor.currentPageShapes[0])!
+		expect(editor.currentPageShapes[0]).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
@@ -131,7 +131,7 @@ describe('When resizing', () => {
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('does not bails on interrupt while resizing', () => {
@@ -140,7 +140,7 @@ describe('When resizing', () => {
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 	})
 
 	it('preserves the top left when the text has a fixed width', () => {
@@ -149,7 +149,7 @@ describe('When resizing', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerMove(x + 100, y + 100)
-		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
+		expect(editor.currentPageShapes[0]).toMatchObject({
 			x,
 			y,
 		})

commit 79fae186e4816f4b60f336fa80c2d85ef1debc21
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 18:03:31 2023 +0100

    Revert "Editor commands API / effects" (#1783)
    
    Reverts tldraw/tldraw#1778.
    
    Fuzz testing picked up errors related to deleting pages and undo/redo
    which may doom this PR.
    
    ### Change Type
    
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 6f2c17b3d..a609ab014 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -13,7 +13,7 @@ afterEach(() => {
 
 describe(TextShapeTool, () => {
 	it('Creates text, edits it, undoes and redoes', () => {
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 		editor.setCurrentTool('text')
 		editor.expectToBeIn('text.idle')
 		editor.pointerDown(0, 0)
@@ -22,28 +22,28 @@ describe(TextShapeTool, () => {
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
 		editor.updateShapes([
-			{ ...editor.currentPageShapes[0]!, type: 'text', props: { text: 'Hello' } },
+			{ ...editor.shapesOnCurrentPage[0]!, type: 'text', props: { text: 'Hello' } },
 		])
 		// Deselect the editing shape
 		editor.cancel()
 		editor.expectToBeIn('select.idle')
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 		editor.expectShapeToMatch({
-			id: editor.currentPageShapes[0].id,
+			id: editor.shapesOnCurrentPage[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
 
 		editor.undo()
 
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 
 		editor.redo()
 
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 
 		editor.expectShapeToMatch({
-			id: editor.currentPageShapes[0].id,
+			id: editor.shapesOnCurrentPage[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
@@ -71,7 +71,7 @@ describe('When in idle state', () => {
 		editor.pointerDown(0, 0)
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 	})
 
 	it('returns to select on cancel', () => {
@@ -87,7 +87,7 @@ describe('When in the pointing state', () => {
 		editor.pointerDown(0, 0)
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('returns to idle on interrupt', () => {
@@ -96,7 +96,7 @@ describe('When in the pointing state', () => {
 		editor.expectToBeIn('text.pointing')
 		editor.interrupt()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
@@ -105,7 +105,7 @@ describe('When in the pointing state', () => {
 		editor.pointerMove(10, 10)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -115,8 +115,8 @@ describe('When in the pointing state', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getPageBounds(editor.currentPageShapes[0])!
-		expect(editor.currentPageShapes[0]).toMatchObject({
+		const bounds = editor.getPageBounds(editor.shapesOnCurrentPage[0])!
+		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
@@ -131,7 +131,7 @@ describe('When resizing', () => {
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.shapesOnCurrentPage.length).toBe(0)
 	})
 
 	it('does not bails on interrupt while resizing', () => {
@@ -140,7 +140,7 @@ describe('When resizing', () => {
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.shapesOnCurrentPage.length).toBe(1)
 	})
 
 	it('preserves the top left when the text has a fixed width', () => {
@@ -149,7 +149,7 @@ describe('When resizing', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerMove(x + 100, y + 100)
-		expect(editor.currentPageShapes[0]).toMatchObject({
+		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
 			x,
 			y,
 		})

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index a609ab014..6ecc88097 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -13,7 +13,7 @@ afterEach(() => {
 
 describe(TextShapeTool, () => {
 	it('Creates text, edits it, undoes and redoes', () => {
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 		editor.setCurrentTool('text')
 		editor.expectToBeIn('text.idle')
 		editor.pointerDown(0, 0)
@@ -22,28 +22,28 @@ describe(TextShapeTool, () => {
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
 		editor.updateShapes([
-			{ ...editor.shapesOnCurrentPage[0]!, type: 'text', props: { text: 'Hello' } },
+			{ ...editor.currentPageShapes[0]!, type: 'text', props: { text: 'Hello' } },
 		])
 		// Deselect the editing shape
 		editor.cancel()
 		editor.expectToBeIn('select.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 		editor.expectShapeToMatch({
-			id: editor.shapesOnCurrentPage[0].id,
+			id: editor.currentPageShapes[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
 
 		editor.undo()
 
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 
 		editor.redo()
 
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 
 		editor.expectShapeToMatch({
-			id: editor.shapesOnCurrentPage[0].id,
+			id: editor.currentPageShapes[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
@@ -71,7 +71,7 @@ describe('When in idle state', () => {
 		editor.pointerDown(0, 0)
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 	})
 
 	it('returns to select on cancel', () => {
@@ -87,7 +87,7 @@ describe('When in the pointing state', () => {
 		editor.pointerDown(0, 0)
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('returns to idle on interrupt', () => {
@@ -96,7 +96,7 @@ describe('When in the pointing state', () => {
 		editor.expectToBeIn('text.pointing')
 		editor.interrupt()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
@@ -105,7 +105,7 @@ describe('When in the pointing state', () => {
 		editor.pointerMove(10, 10)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -115,8 +115,8 @@ describe('When in the pointing state', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getPageBounds(editor.shapesOnCurrentPage[0])!
-		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
+		const bounds = editor.getShapePageBounds(editor.currentPageShapes[0])!
+		expect(editor.currentPageShapes[0]).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
@@ -131,7 +131,7 @@ describe('When resizing', () => {
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.shapesOnCurrentPage.length).toBe(0)
+		expect(editor.currentPageShapes.length).toBe(0)
 	})
 
 	it('does not bails on interrupt while resizing', () => {
@@ -140,7 +140,7 @@ describe('When resizing', () => {
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
-		expect(editor.shapesOnCurrentPage.length).toBe(1)
+		expect(editor.currentPageShapes.length).toBe(1)
 	})
 
 	it('preserves the top left when the text has a fixed width', () => {
@@ -149,7 +149,7 @@ describe('When resizing', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerMove(x + 100, y + 100)
-		expect(editor.shapesOnCurrentPage[0]).toMatchObject({
+		expect(editor.currentPageShapes[0]).toMatchObject({
 			x,
 			y,
 		})

commit dc0f6ae0f25518342de828498998c5c7241da7b0
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 16:32:27 2023 +0000

    No impure getters pt8 (#2221)
    
    follow up to #2189
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 6ecc88097..0879dd52d 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -13,7 +13,7 @@ afterEach(() => {
 
 describe(TextShapeTool, () => {
 	it('Creates text, edits it, undoes and redoes', () => {
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.getCurrentPageShapes().length).toBe(0)
 		editor.setCurrentTool('text')
 		editor.expectToBeIn('text.idle')
 		editor.pointerDown(0, 0)
@@ -22,28 +22,28 @@ describe(TextShapeTool, () => {
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
 		editor.updateShapes([
-			{ ...editor.currentPageShapes[0]!, type: 'text', props: { text: 'Hello' } },
+			{ ...editor.getCurrentPageShapes()[0]!, type: 'text', props: { text: 'Hello' } },
 		])
 		// Deselect the editing shape
 		editor.cancel()
 		editor.expectToBeIn('select.idle')
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.getCurrentPageShapes().length).toBe(1)
 		editor.expectShapeToMatch({
-			id: editor.currentPageShapes[0].id,
+			id: editor.getCurrentPageShapes()[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
 
 		editor.undo()
 
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.getCurrentPageShapes().length).toBe(0)
 
 		editor.redo()
 
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.getCurrentPageShapes().length).toBe(1)
 
 		editor.expectShapeToMatch({
-			id: editor.currentPageShapes[0].id,
+			id: editor.getCurrentPageShapes()[0].id,
 			type: 'text',
 			props: { text: 'Hello' },
 		})
@@ -71,7 +71,7 @@ describe('When in idle state', () => {
 		editor.pointerDown(0, 0)
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.getCurrentPageShapes().length).toBe(1)
 	})
 
 	it('returns to select on cancel', () => {
@@ -87,7 +87,7 @@ describe('When in the pointing state', () => {
 		editor.pointerDown(0, 0)
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.getCurrentPageShapes().length).toBe(0)
 	})
 
 	it('returns to idle on interrupt', () => {
@@ -96,7 +96,7 @@ describe('When in the pointing state', () => {
 		editor.expectToBeIn('text.pointing')
 		editor.interrupt()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.getCurrentPageShapes().length).toBe(0)
 	})
 
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
@@ -105,7 +105,7 @@ describe('When in the pointing state', () => {
 		editor.pointerMove(10, 10)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.getCurrentPageShapes().length).toBe(1)
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -115,8 +115,8 @@ describe('When in the pointing state', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getShapePageBounds(editor.currentPageShapes[0])!
-		expect(editor.currentPageShapes[0]).toMatchObject({
+		const bounds = editor.getShapePageBounds(editor.getCurrentPageShapes()[0])!
+		expect(editor.getCurrentPageShapes()[0]).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
@@ -131,7 +131,7 @@ describe('When resizing', () => {
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
 		editor.expectToBeIn('text.idle')
-		expect(editor.currentPageShapes.length).toBe(0)
+		expect(editor.getCurrentPageShapes().length).toBe(0)
 	})
 
 	it('does not bails on interrupt while resizing', () => {
@@ -140,7 +140,7 @@ describe('When resizing', () => {
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
-		expect(editor.currentPageShapes.length).toBe(1)
+		expect(editor.getCurrentPageShapes().length).toBe(1)
 	})
 
 	it('preserves the top left when the text has a fixed width', () => {
@@ -149,7 +149,7 @@ describe('When resizing', () => {
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerMove(x + 100, y + 100)
-		expect(editor.currentPageShapes[0]).toMatchObject({
+		expect(editor.getCurrentPageShapes()[0]).toMatchObject({
 			x,
 			y,
 		})

commit ac149c1014fb5f0539d7c55f0f10ce2a05a23f74
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jun 16 19:58:13 2024 +0300

    Dynamic size mode + fill fill (#3835)
    
    This PR adds a user preference for "dynamic size mode" where the scale
    of shapes (text size, stroke width) is relative to the current zoom
    level. This means that the stroke width in screen pixels (or text size
    in screen pixels) is identical regardless of zoom level.
    
    ![Kapture 2024-05-27 at 05 23
    21](https://github.com/tldraw/tldraw/assets/23072548/f247ecce-bfcd-4f85-b7a5-d7677b38e4d8)
    
    - [x] Draw shape
    - [x] Text shape
    - [x] Highlighter shape
    - [x] Geo shape
    - [x] Arrow shape
    - [x] Note shape
    - [x] Line shape
    
    Embed shape?
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    1. Use the tools.
    2. Change zoom
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - Adds a dynamic size user preferences.
    - Removes double click to reset scale on text shapes.
    - Removes double click to reset autosize on text shapes.
    
    ---------
    
    Co-authored-by: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 0879dd52d..451403452 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -1,3 +1,4 @@
+import { DefaultTextAlignStyle } from '@tldraw/editor'
 import { TestEditor } from '../../../test/TestEditor'
 import { TextShapeTool } from './TextShapeTool'
 
@@ -111,16 +112,48 @@ describe('When in the pointing state', () => {
 
 	it('on pointer up, preserves the center when the text has a auto width', () => {
 		editor.setCurrentTool('text')
+		editor.setStyleForNextShapes(DefaultTextAlignStyle, 'middle')
 		const x = 0
 		const y = 0
 		editor.pointerDown(x, y)
 		editor.pointerUp()
-		const bounds = editor.getShapePageBounds(editor.getCurrentPageShapes()[0])!
-		expect(editor.getCurrentPageShapes()[0]).toMatchObject({
+		const shape = editor.getLastCreatedShape()
+		const bounds = editor.getShapePageBounds(shape)!
+		expect(shape).toMatchObject({
 			x: x - bounds.width / 2,
 			y: y - bounds.height / 2,
 		})
 	})
+
+	it('on pointer up, preserves the center when the text has a auto width (left aligned)', () => {
+		editor.setCurrentTool('text')
+		editor.setStyleForNextShapes(DefaultTextAlignStyle, 'start')
+		const x = 0
+		const y = 0
+		editor.pointerDown(x, y)
+		editor.pointerUp()
+		const shape = editor.getLastCreatedShape()
+		const bounds = editor.getShapePageBounds(shape)!
+		expect(shape).toMatchObject({
+			x,
+			y: y - bounds.height / 2,
+		})
+	})
+
+	it('on pointer up, preserves the center when the text has a auto width (right aligned)', () => {
+		editor.setCurrentTool('text')
+		editor.setStyleForNextShapes(DefaultTextAlignStyle, 'end')
+		const x = 0
+		const y = 0
+		editor.pointerDown(x, y)
+		editor.pointerUp()
+		const shape = editor.getLastCreatedShape()
+		const bounds = editor.getShapePageBounds(shape)!
+		expect(shape).toMatchObject({
+			x: x - bounds.width,
+			y: y - bounds.height / 2,
+		})
+	})
 })
 
 describe('When resizing', () => {
@@ -151,7 +184,7 @@ describe('When resizing', () => {
 		editor.pointerMove(x + 100, y + 100)
 		expect(editor.getCurrentPageShapes()[0]).toMatchObject({
 			x,
-			y,
+			y: -12, // 24 is the height of the text, and it's centered at that point
 		})
 	})
 })

commit 5b8c0753b85276468b31604dba8d6e2a4e332162
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jul 30 12:34:57 2024 +0100

    text shape: dont make a fixed width unless more intentional drag (#4293)
    
    Small thing I noticed when on the call with Jørgen. He created a narrow
    vertical column of text because he accidentally dragged just a touch and
    didn't know how to undo that state. This makes that drag state a little
    less accident-prone. (Maybe it means or dragging state is a touch too
    sensitive in general? I dunno)
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Text shape: dont make a fixed width unless more intentional drag
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 451403452..385418416 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -103,7 +103,7 @@ describe('When in the pointing state', () => {
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
 		editor.setCurrentTool('text')
 		editor.pointerDown(0, 0)
-		editor.pointerMove(10, 10)
+		editor.pointerMove(24, 24)
 		editor.expectToBeIn('select.resizing')
 		editor.pointerUp()
 		expect(editor.getCurrentPageShapes().length).toBe(1)

commit c6e07a06c0d094026bcc09dee9ce6024f0b6ce58
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Aug 2 14:01:15 2024 +0100

    Combino fixed text (#4331)
    
    This PR incorporates a few other PRs related to avoiding accidental
    fixed-width text shapes.
    
    - the user must have been pointing for more that 150ms
    - the user must have dragged 10 times more than usual for dragging
    (along the x axis)
    - the initial shape's width is set using the user's drag distance
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a fixed size text shape while zoomed in / zoomed out
    2. Click while moving the mouse with the text shape selected (should not
    create a fixed-width shape)
    
    ### Release notes
    
    - Improved accidental fixed-width text shape creation.

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index 385418416..a31ab0781 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -3,6 +3,7 @@ import { TestEditor } from '../../../test/TestEditor'
 import { TextShapeTool } from './TextShapeTool'
 
 let editor: TestEditor
+jest.useFakeTimers()
 
 beforeEach(() => {
 	editor = new TestEditor()
@@ -103,10 +104,32 @@ describe('When in the pointing state', () => {
 	it('transitions to select.resizing when dragging and edits on pointer up', () => {
 		editor.setCurrentTool('text')
 		editor.pointerDown(0, 0)
-		editor.pointerMove(24, 24)
+
+		// doesn't matter how far we move if we haven't been pointing long enough
+		editor.pointerMove(100, 100)
+		editor.expectToBeIn('text.pointing')
+
+		// Go back to start and wait a little to satisfy the time requirement
+		editor.pointerMove(0, 0)
+		jest.advanceTimersByTime(200)
+
+		// y axis doesn't matter
+		editor.pointerMove(0, 100)
+		editor.expectToBeIn('text.pointing')
+
+		// x axis matters
+		editor.pointerMove(0, 10)
+		editor.expectToBeIn('text.pointing')
+
+		// needs to be far enough
+		editor.pointerMove(100, 0)
 		editor.expectToBeIn('select.resizing')
-		editor.pointerUp()
+
+		// Create the shape immediately
 		expect(editor.getCurrentPageShapes().length).toBe(1)
+
+		// Go to editing on pointer up
+		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
 	})
 
@@ -160,6 +183,7 @@ describe('When resizing', () => {
 	it('bails on escape while resizing and returns to text.idle', () => {
 		editor.setCurrentTool('text')
 		editor.pointerDown(0, 0)
+		jest.advanceTimersByTime(200)
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.cancel()
@@ -170,6 +194,7 @@ describe('When resizing', () => {
 	it('does not bails on interrupt while resizing', () => {
 		editor.setCurrentTool('text')
 		editor.pointerDown(0, 0)
+		jest.advanceTimersByTime(200)
 		editor.pointerMove(100, 100)
 		editor.expectToBeIn('select.resizing')
 		editor.interrupt()
@@ -181,6 +206,7 @@ describe('When resizing', () => {
 		const x = 0
 		const y = 0
 		editor.pointerDown(x, y)
+		jest.advanceTimersByTime(200)
 		editor.pointerMove(x + 100, y + 100)
 		expect(editor.getCurrentPageShapes()[0]).toMatchObject({
 			x,

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists↔headers, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster — I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool — can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
index a31ab0781..b12fab573 100644
--- a/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
+++ b/packages/tldraw/src/lib/shapes/text/TextShapeTool.test.ts
@@ -1,4 +1,4 @@
-import { DefaultTextAlignStyle } from '@tldraw/editor'
+import { DefaultTextAlignStyle, TLTextShape, toRichText } from '@tldraw/editor'
 import { TestEditor } from '../../../test/TestEditor'
 import { TextShapeTool } from './TextShapeTool'
 
@@ -23,8 +23,12 @@ describe(TextShapeTool, () => {
 		editor.pointerUp()
 		editor.expectToBeIn('select.editing_shape')
 		// This comes from the component, not the state chart
-		editor.updateShapes([
-			{ ...editor.getCurrentPageShapes()[0]!, type: 'text', props: { text: 'Hello' } },
+		editor.updateShapes<TLTextShape>([
+			{
+				...editor.getCurrentPageShapes()[0]!,
+				type: 'text',
+				props: { richText: toRichText('Hello') },
+			},
 		])
 		// Deselect the editing shape
 		editor.cancel()
@@ -33,7 +37,7 @@ describe(TextShapeTool, () => {
 		editor.expectShapeToMatch({
 			id: editor.getCurrentPageShapes()[0].id,
 			type: 'text',
-			props: { text: 'Hello' },
+			props: { richText: toRichText('Hello') },
 		})
 
 		editor.undo()
@@ -47,7 +51,7 @@ describe(TextShapeTool, () => {
 		editor.expectShapeToMatch({
 			id: editor.getCurrentPageShapes()[0].id,
 			type: 'text',
-			props: { text: 'Hello' },
+			props: { richText: toRichText('Hello') },
 		})
 	})
 })

