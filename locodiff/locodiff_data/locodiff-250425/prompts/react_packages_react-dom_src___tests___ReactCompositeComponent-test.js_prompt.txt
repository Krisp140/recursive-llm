# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactCompositeComponent-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
new file mode 100644
index 0000000000..75f3e8060f
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -0,0 +1,1503 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var ChildUpdates;
+var MorphingComponent;
+var React;
+var ReactDOM;
+var ReactDOMServer;
+var ReactCurrentOwner;
+var ReactTestUtils;
+var PropTypes;
+var shallowEqual;
+var shallowCompare;
+
+describe('ReactCompositeComponent', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+    ReactDOMServer = require('react-dom/server');
+    ReactCurrentOwner = require('react')
+      .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
+    ReactTestUtils = require('react-dom/test-utils');
+    PropTypes = require('prop-types');
+    shallowEqual = require('fbjs/lib/shallowEqual');
+
+    shallowCompare = function(instance, nextProps, nextState) {
+      return (
+        !shallowEqual(instance.props, nextProps) ||
+        !shallowEqual(instance.state, nextState)
+      );
+    };
+
+    MorphingComponent = class extends React.Component {
+      state = {activated: false};
+
+      _toggleActivatedState = () => {
+        this.setState({activated: !this.state.activated});
+      };
+
+      render() {
+        var toggleActivatedState = this._toggleActivatedState;
+        return !this.state.activated
+          ? <a ref="x" onClick={toggleActivatedState} />
+          : <b ref="x" onClick={toggleActivatedState} />;
+      }
+    };
+
+    /**
+     * We'll use this to ensure that an old version is not cached when it is
+     * reallocated again.
+     */
+    ChildUpdates = class extends React.Component {
+      getAnchor = () => {
+        return this.refs.anch;
+      };
+
+      render() {
+        var className = this.props.anchorClassOn ? 'anchorClass' : '';
+        return this.props.renderAnchor
+          ? <a ref="anch" className={className} />
+          : <b />;
+      }
+    };
+  });
+
+  it('should support module pattern components', () => {
+    function Child({test}) {
+      return {
+        render() {
+          return <div>{test}</div>;
+        },
+      };
+    }
+
+    var el = document.createElement('div');
+    ReactDOM.render(<Child test="test" />, el);
+
+    expect(el.textContent).toBe('test');
+  });
+
+  it('should support rendering to different child types over time', () => {
+    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+    var el = ReactDOM.findDOMNode(instance);
+    expect(el.tagName).toBe('A');
+
+    instance._toggleActivatedState();
+    el = ReactDOM.findDOMNode(instance);
+    expect(el.tagName).toBe('B');
+
+    instance._toggleActivatedState();
+    el = ReactDOM.findDOMNode(instance);
+    expect(el.tagName).toBe('A');
+  });
+
+  it('should not thrash a server rendered layout with client side one', () => {
+    class Child extends React.Component {
+      render() {
+        return null;
+      }
+    }
+
+    class Parent extends React.Component {
+      render() {
+        return <div><Child /></div>;
+      }
+    }
+
+    spyOn(console, 'warn');
+    var markup = ReactDOMServer.renderToString(<Parent />);
+
+    // Old API based on heuristic
+    var container = document.createElement('div');
+    container.innerHTML = markup;
+    ReactDOM.render(<Parent />, container);
+    expectDev(console.warn.calls.count()).toBe(1);
+    expectDev(console.warn.calls.argsFor(0)[0]).toContain(
+      'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
+        'will stop working in React v17. Replace the ReactDOM.render() call ' +
+        'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
+    );
+
+    // New explicit API
+    console.warn.calls.reset();
+    container = document.createElement('div');
+    container.innerHTML = markup;
+    ReactDOM.hydrate(<Parent />, container);
+    expectDev(console.warn.calls.count()).toBe(0);
+  });
+
+  it('should react to state changes from callbacks', () => {
+    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+    var el = ReactDOM.findDOMNode(instance);
+    expect(el.tagName).toBe('A');
+
+    ReactTestUtils.Simulate.click(el);
+    el = ReactDOM.findDOMNode(instance);
+    expect(el.tagName).toBe('B');
+  });
+
+  it('should rewire refs when rendering to different child types', () => {
+    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+
+    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('A');
+    instance._toggleActivatedState();
+    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('B');
+    instance._toggleActivatedState();
+    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('A');
+  });
+
+  it('should not cache old DOM nodes when switching constructors', () => {
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(
+      <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
+      container,
+    );
+    ReactDOM.render(
+      // Warm any cache
+      <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
+      container,
+    );
+    ReactDOM.render(
+      // Clear out the anchor
+      <ChildUpdates renderAnchor={false} anchorClassOn={true} />,
+      container,
+    );
+    ReactDOM.render(
+      // rerender
+      <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
+      container,
+    );
+    expect(instance.getAnchor().className).toBe('');
+  });
+
+  it('should use default values for undefined props', () => {
+    class Component extends React.Component {
+      static defaultProps = {prop: 'testKey'};
+
+      render() {
+        return <span />;
+      }
+    }
+
+    var instance1 = ReactTestUtils.renderIntoDocument(<Component />);
+    expect(instance1.props).toEqual({prop: 'testKey'});
+
+    var instance2 = ReactTestUtils.renderIntoDocument(
+      <Component prop={undefined} />,
+    );
+    expect(instance2.props).toEqual({prop: 'testKey'});
+
+    var instance3 = ReactTestUtils.renderIntoDocument(
+      <Component prop={null} />,
+    );
+    expect(instance3.props).toEqual({prop: null});
+  });
+
+  it('should not mutate passed-in props object', () => {
+    class Component extends React.Component {
+      static defaultProps = {prop: 'testKey'};
+
+      render() {
+        return <span />;
+      }
+    }
+
+    var inputProps = {};
+    var instance1 = <Component {...inputProps} />;
+    instance1 = ReactTestUtils.renderIntoDocument(instance1);
+    expect(instance1.props.prop).toBe('testKey');
+
+    // We don't mutate the input, just in case the caller wants to do something
+    // with it after using it to instantiate a component
+    expect(inputProps.prop).not.toBeDefined();
+  });
+
+  it('should warn about `forceUpdate` on unmounted components', () => {
+    spyOn(console, 'error');
+
+    var container = document.createElement('div');
+    document.body.appendChild(container);
+
+    class Component extends React.Component {
+      render() {
+        return <div />;
+      }
+    }
+
+    var instance = <Component />;
+    expect(instance.forceUpdate).not.toBeDefined();
+
+    instance = ReactDOM.render(instance, container);
+    instance.forceUpdate();
+
+    expectDev(console.error.calls.count()).toBe(0);
+
+    ReactDOM.unmountComponentAtNode(container);
+
+    instance.forceUpdate();
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Can only update a mounted or mounting component. This usually means ' +
+        'you called setState, replaceState, or forceUpdate on an unmounted ' +
+        'component. This is a no-op.\n\nPlease check the code for the ' +
+        'Component component.',
+    );
+  });
+
+  it('should warn about `setState` on unmounted components', () => {
+    spyOn(console, 'error');
+
+    var container = document.createElement('div');
+    document.body.appendChild(container);
+
+    var renders = 0;
+
+    class Component extends React.Component {
+      state = {value: 0};
+
+      render() {
+        renders++;
+        return <div />;
+      }
+    }
+
+    var instance = <Component />;
+    expect(instance.setState).not.toBeDefined();
+
+    instance = ReactDOM.render(instance, container);
+
+    expect(renders).toBe(1);
+
+    instance.setState({value: 1});
+
+    expectDev(console.error.calls.count()).toBe(0);
+
+    expect(renders).toBe(2);
+
+    ReactDOM.unmountComponentAtNode(container);
+    instance.setState({value: 2});
+
+    expect(renders).toBe(2);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Can only update a mounted or mounting component. This usually means ' +
+        'you called setState, replaceState, or forceUpdate on an unmounted ' +
+        'component. This is a no-op.\n\nPlease check the code for the ' +
+        'Component component.',
+    );
+  });
+
+  it('should silently allow `setState`, not call cb on unmounting components', () => {
+    var cbCalled = false;
+    var container = document.createElement('div');
+    document.body.appendChild(container);
+
+    class Component extends React.Component {
+      state = {value: 0};
+
+      componentWillUnmount() {
+        expect(() => {
+          this.setState({value: 2}, function() {
+            cbCalled = true;
+          });
+        }).not.toThrow();
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var instance = ReactDOM.render(<Component />, container);
+    instance.setState({value: 1});
+
+    ReactDOM.unmountComponentAtNode(container);
+    expect(cbCalled).toBe(false);
+  });
+
+  it('should warn about `setState` in render', () => {
+    spyOn(console, 'error');
+
+    var container = document.createElement('div');
+
+    var renderedState = -1;
+    var renderPasses = 0;
+
+    class Component extends React.Component {
+      state = {value: 0};
+
+      render() {
+        renderPasses++;
+        renderedState = this.state.value;
+        if (this.state.value === 0) {
+          this.setState({value: 1});
+        }
+        return <div />;
+      }
+    }
+
+    expectDev(console.error.calls.count()).toBe(0);
+
+    var instance = ReactDOM.render(<Component />, container);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Cannot update during an existing state transition (such as within ' +
+        "`render` or another component's constructor). Render methods should " +
+        'be a pure function of props and state; constructor side-effects are ' +
+        'an anti-pattern, but can be moved to `componentWillMount`.',
+    );
+
+    // The setState call is queued and then executed as a second pass. This
+    // behavior is undefined though so we're free to change it to suit the
+    // implementation details.
+    expect(renderPasses).toBe(2);
+    expect(renderedState).toBe(1);
+    expect(instance.state.value).toBe(1);
+
+    // Forcing a rerender anywhere will cause the update to happen.
+    var instance2 = ReactDOM.render(<Component prop={123} />, container);
+    expect(instance).toBe(instance2);
+    expect(renderedState).toBe(1);
+    expect(instance2.state.value).toBe(1);
+  });
+
+  it('should warn about `setState` in getChildContext', () => {
+    spyOn(console, 'error');
+
+    var container = document.createElement('div');
+
+    var renderPasses = 0;
+
+    class Component extends React.Component {
+      state = {value: 0};
+
+      getChildContext() {
+        if (this.state.value === 0) {
+          this.setState({value: 1});
+        }
+      }
+
+      render() {
+        renderPasses++;
+        return <div />;
+      }
+    }
+    Component.childContextTypes = {};
+
+    expectDev(console.error.calls.count()).toBe(0);
+    var instance = ReactDOM.render(<Component />, container);
+    expect(renderPasses).toBe(2);
+    expect(instance.state.value).toBe(1);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toBe(
+      'Warning: setState(...): Cannot call setState() inside getChildContext()',
+    );
+  });
+
+  it('should cleanup even if render() fatals', () => {
+    class BadComponent extends React.Component {
+      render() {
+        throw new Error();
+      }
+    }
+
+    var instance = <BadComponent />;
+
+    expect(ReactCurrentOwner.current).toBe(null);
+
+    expect(function() {
+      instance = ReactTestUtils.renderIntoDocument(instance);
+    }).toThrow();
+
+    expect(ReactCurrentOwner.current).toBe(null);
+  });
+
+  it('should call componentWillUnmount before unmounting', () => {
+    var container = document.createElement('div');
+    var innerUnmounted = false;
+
+    class Component extends React.Component {
+      render() {
+        return (
+          <div>
+            <Inner />
+            Text
+          </div>
+        );
+      }
+    }
+
+    class Inner extends React.Component {
+      componentWillUnmount() {
+        innerUnmounted = true;
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    ReactDOM.render(<Component />, container);
+    ReactDOM.unmountComponentAtNode(container);
+    expect(innerUnmounted).toBe(true);
+  });
+
+  it('should warn when shouldComponentUpdate() returns undefined', () => {
+    spyOn(console, 'error');
+
+    class Component extends React.Component {
+      state = {bogus: false};
+
+      shouldComponentUpdate() {
+        return undefined;
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    instance.setState({bogus: true});
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toBe(
+      'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
+        'boolean value. Make sure to return true or false.',
+    );
+  });
+
+  it('should warn when componentDidUnmount method is defined', () => {
+    spyOn(console, 'error');
+
+    class Component extends React.Component {
+      componentDidUnmount = () => {};
+
+      render() {
+        return <div />;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Component />);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toBe(
+      'Warning: Component has a method called ' +
+        'componentDidUnmount(). But there is no such lifecycle method. ' +
+        'Did you mean componentWillUnmount()?',
+    );
+  });
+
+  it('should warn when defaultProps was defined as an instance property', () => {
+    spyOn(console, 'error');
+
+    class Component extends React.Component {
+      constructor(props) {
+        super(props);
+        this.defaultProps = {name: 'Abhay'};
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Component />);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toBe(
+      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+        'and will be ignored. Instead, define defaultProps as a static property on Component.',
+    );
+  });
+
+  it('should pass context to children when not owner', () => {
+    class Parent extends React.Component {
+      render() {
+        return <Child><Grandchild /></Child>;
+      }
+    }
+
+    class Child extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+        };
+      }
+
+      render() {
+        return React.Children.only(this.props.children);
+      }
+    }
+
+    class Grandchild extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string,
+      };
+
+      render() {
+        return <div>{this.context.foo}</div>;
+      }
+    }
+
+    var component = ReactTestUtils.renderIntoDocument(<Parent />);
+    expect(ReactDOM.findDOMNode(component).innerHTML).toBe('bar');
+  });
+
+  it('should skip update when rerendering element in container', () => {
+    class Parent extends React.Component {
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    var childRenders = 0;
+
+    class Child extends React.Component {
+      render() {
+        childRenders++;
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    var child = <Child />;
+
+    ReactDOM.render(<Parent>{child}</Parent>, container);
+    ReactDOM.render(<Parent>{child}</Parent>, container);
+    expect(childRenders).toBe(1);
+  });
+
+  it('should pass context when re-rendered for static child', () => {
+    var parentInstance = null;
+    var childInstance = null;
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+        flag: PropTypes.bool,
+      };
+
+      state = {
+        flag: false,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+          flag: this.state.flag,
+        };
+      }
+
+      render() {
+        return React.Children.only(this.props.children);
+      }
+    }
+
+    class Middle extends React.Component {
+      render() {
+        return this.props.children;
+      }
+    }
+
+    class Child extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string,
+        flag: PropTypes.bool,
+      };
+
+      render() {
+        childInstance = this;
+        return <span>Child</span>;
+      }
+    }
+
+    parentInstance = ReactTestUtils.renderIntoDocument(
+      <Parent><Middle><Child /></Middle></Parent>,
+    );
+
+    expect(parentInstance.state.flag).toBe(false);
+    expect(childInstance.context).toEqual({foo: 'bar', flag: false});
+
+    parentInstance.setState({flag: true});
+    expect(parentInstance.state.flag).toBe(true);
+    expect(childInstance.context).toEqual({foo: 'bar', flag: true});
+  });
+
+  it('should pass context when re-rendered for static child within a composite component', () => {
+    class Parent extends React.Component {
+      static childContextTypes = {
+        flag: PropTypes.bool,
+      };
+
+      state = {
+        flag: true,
+      };
+
+      getChildContext() {
+        return {
+          flag: this.state.flag,
+        };
+      }
+
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    class Child extends React.Component {
+      static contextTypes = {
+        flag: PropTypes.bool,
+      };
+
+      render() {
+        return <div />;
+      }
+    }
+
+    class Wrapper extends React.Component {
+      render() {
+        return (
+          <Parent ref="parent">
+            <Child ref="child" />
+          </Parent>
+        );
+      }
+    }
+
+    var wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
+
+    expect(wrapper.refs.parent.state.flag).toEqual(true);
+    expect(wrapper.refs.child.context).toEqual({flag: true});
+
+    // We update <Parent /> while <Child /> is still a static prop relative to this update
+    wrapper.refs.parent.setState({flag: false});
+
+    expect(wrapper.refs.parent.state.flag).toEqual(false);
+    expect(wrapper.refs.child.context).toEqual({flag: false});
+  });
+
+  it('should pass context transitively', () => {
+    var childInstance = null;
+    var grandchildInstance = null;
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+        depth: PropTypes.number,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+          depth: 0,
+        };
+      }
+
+      render() {
+        return <Child />;
+      }
+    }
+
+    class Child extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string,
+        depth: PropTypes.number,
+      };
+
+      static childContextTypes = {
+        depth: PropTypes.number,
+      };
+
+      getChildContext() {
+        return {
+          depth: this.context.depth + 1,
+        };
+      }
+
+      render() {
+        childInstance = this;
+        return <Grandchild />;
+      }
+    }
+
+    class Grandchild extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string,
+        depth: PropTypes.number,
+      };
+
+      render() {
+        grandchildInstance = this;
+        return <div />;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Parent />);
+    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
+    expect(grandchildInstance.context).toEqual({foo: 'bar', depth: 1});
+  });
+
+  it('should pass context when re-rendered', () => {
+    var parentInstance = null;
+    var childInstance = null;
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+        depth: PropTypes.number,
+      };
+
+      state = {
+        flag: false,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+          depth: 0,
+        };
+      }
+
+      render() {
+        var output = <Child />;
+        if (!this.state.flag) {
+          output = <span>Child</span>;
+        }
+        return output;
+      }
+    }
+
+    class Child extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string,
+        depth: PropTypes.number,
+      };
+
+      render() {
+        childInstance = this;
+        return <span>Child</span>;
+      }
+    }
+
+    parentInstance = ReactTestUtils.renderIntoDocument(<Parent />);
+    expect(childInstance).toBeNull();
+
+    expect(parentInstance.state.flag).toBe(false);
+    ReactDOM.unstable_batchedUpdates(function() {
+      parentInstance.setState({flag: true});
+    });
+    expect(parentInstance.state.flag).toBe(true);
+
+    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
+  });
+
+  it('unmasked context propagates through updates', () => {
+    class Leaf extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      componentWillReceiveProps(nextProps, nextContext) {
+        expect('foo' in nextContext).toBe(true);
+      }
+
+      shouldComponentUpdate(nextProps, nextState, nextContext) {
+        expect('foo' in nextContext).toBe(true);
+        return true;
+      }
+
+      render() {
+        return <span>{this.context.foo}</span>;
+      }
+    }
+
+    class Intermediary extends React.Component {
+      componentWillReceiveProps(nextProps, nextContext) {
+        expect('foo' in nextContext).toBe(false);
+      }
+
+      shouldComponentUpdate(nextProps, nextState, nextContext) {
+        expect('foo' in nextContext).toBe(false);
+        return true;
+      }
+
+      render() {
+        return <Leaf />;
+      }
+    }
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+      };
+
+      getChildContext() {
+        return {
+          foo: this.props.cntxt,
+        };
+      }
+
+      render() {
+        return <Intermediary />;
+      }
+    }
+
+    var div = document.createElement('div');
+    ReactDOM.render(<Parent cntxt="noise" />, div);
+    expect(div.children[0].innerHTML).toBe('noise');
+    div.children[0].innerHTML = 'aliens';
+    div.children[0].id = 'aliens';
+    expect(div.children[0].innerHTML).toBe('aliens');
+    expect(div.children[0].id).toBe('aliens');
+    ReactDOM.render(<Parent cntxt="bar" />, div);
+    expect(div.children[0].innerHTML).toBe('bar');
+    expect(div.children[0].id).toBe('aliens');
+  });
+
+  it('should trigger componentWillReceiveProps for context changes', () => {
+    var contextChanges = 0;
+    var propChanges = 0;
+
+    class GrandChild extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      componentWillReceiveProps(nextProps, nextContext) {
+        expect('foo' in nextContext).toBe(true);
+
+        if (nextProps !== this.props) {
+          propChanges++;
+        }
+
+        if (nextContext !== this.context) {
+          contextChanges++;
+        }
+      }
+
+      render() {
+        return <span className="grand-child">{this.props.children}</span>;
+      }
+    }
+
+    class ChildWithContext extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      componentWillReceiveProps(nextProps, nextContext) {
+        expect('foo' in nextContext).toBe(true);
+
+        if (nextProps !== this.props) {
+          propChanges++;
+        }
+
+        if (nextContext !== this.context) {
+          contextChanges++;
+        }
+      }
+
+      render() {
+        return <div className="child-with">{this.props.children}</div>;
+      }
+    }
+
+    class ChildWithoutContext extends React.Component {
+      componentWillReceiveProps(nextProps, nextContext) {
+        expect('foo' in nextContext).toBe(false);
+
+        if (nextProps !== this.props) {
+          propChanges++;
+        }
+
+        if (nextContext !== this.context) {
+          contextChanges++;
+        }
+      }
+
+      render() {
+        return <div className="child-without">{this.props.children}</div>;
+      }
+    }
+
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+      };
+
+      state = {
+        foo: 'abc',
+      };
+
+      getChildContext() {
+        return {
+          foo: this.state.foo,
+        };
+      }
+
+      render() {
+        return <div className="parent">{this.props.children}</div>;
+      }
+    }
+
+    var div = document.createElement('div');
+
+    var parentInstance = null;
+    ReactDOM.render(
+      <Parent ref={inst => (parentInstance = inst)}>
+        <ChildWithoutContext>
+          A1
+          <GrandChild>A2</GrandChild>
+        </ChildWithoutContext>
+
+        <ChildWithContext>
+          B1
+          <GrandChild>B2</GrandChild>
+        </ChildWithContext>
+      </Parent>,
+      div,
+    );
+
+    parentInstance.setState({
+      foo: 'def',
+    });
+
+    expect(propChanges).toBe(0);
+    expect(contextChanges).toBe(3); // ChildWithContext, GrandChild x 2
+  });
+
+  it('should disallow nested render calls', () => {
+    spyOn(console, 'error');
+
+    class Inner extends React.Component {
+      render() {
+        return <div />;
+      }
+    }
+
+    class Outer extends React.Component {
+      render() {
+        ReactTestUtils.renderIntoDocument(<Inner />);
+        return <div />;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Outer />);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toMatch(
+      'Render methods should be a pure function of props and state; ' +
+        'triggering nested component updates from render is not allowed. If ' +
+        'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
+        'render method of Outer.',
+    );
+  });
+
+  it('only renders once if updated in componentWillReceiveProps', () => {
+    var renders = 0;
+
+    class Component extends React.Component {
+      state = {updated: false};
+
+      componentWillReceiveProps(props) {
+        expect(props.update).toBe(1);
+        expect(renders).toBe(1);
+        this.setState({updated: true});
+        expect(renders).toBe(1);
+      }
+
+      render() {
+        renders++;
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(<Component update={0} />, container);
+    expect(renders).toBe(1);
+    expect(instance.state.updated).toBe(false);
+    ReactDOM.render(<Component update={1} />, container);
+    expect(renders).toBe(2);
+    expect(instance.state.updated).toBe(true);
+  });
+
+  it('only renders once if updated in componentWillReceiveProps when batching', () => {
+    var renders = 0;
+
+    class Component extends React.Component {
+      state = {updated: false};
+
+      componentWillReceiveProps(props) {
+        expect(props.update).toBe(1);
+        expect(renders).toBe(1);
+        this.setState({updated: true});
+        expect(renders).toBe(1);
+      }
+
+      render() {
+        renders++;
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(<Component update={0} />, container);
+    expect(renders).toBe(1);
+    expect(instance.state.updated).toBe(false);
+    ReactDOM.unstable_batchedUpdates(() => {
+      ReactDOM.render(<Component update={1} />, container);
+    });
+    expect(renders).toBe(2);
+    expect(instance.state.updated).toBe(true);
+  });
+
+  it('should update refs if shouldComponentUpdate gives false', () => {
+    class Static extends React.Component {
+      shouldComponentUpdate() {
+        return false;
+      }
+
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    class Component extends React.Component {
+      render() {
+        if (this.props.flipped) {
+          return (
+            <div>
+              <Static ref="static0" key="B">B (ignored)</Static>
+              <Static ref="static1" key="A">A (ignored)</Static>
+            </div>
+          );
+        } else {
+          return (
+            <div>
+              <Static ref="static0" key="A">A</Static>
+              <Static ref="static1" key="B">B</Static>
+            </div>
+          );
+        }
+      }
+    }
+
+    var container = document.createElement('div');
+    var comp = ReactDOM.render(<Component flipped={false} />, container);
+    expect(ReactDOM.findDOMNode(comp.refs.static0).textContent).toBe('A');
+    expect(ReactDOM.findDOMNode(comp.refs.static1).textContent).toBe('B');
+
+    // When flipping the order, the refs should update even though the actual
+    // contents do not
+    ReactDOM.render(<Component flipped={true} />, container);
+    expect(ReactDOM.findDOMNode(comp.refs.static0).textContent).toBe('B');
+    expect(ReactDOM.findDOMNode(comp.refs.static1).textContent).toBe('A');
+  });
+
+  it('should allow access to findDOMNode in componentWillUnmount', () => {
+    var a = null;
+    var b = null;
+
+    class Component extends React.Component {
+      componentDidMount() {
+        a = ReactDOM.findDOMNode(this);
+        expect(a).not.toBe(null);
+      }
+
+      componentWillUnmount() {
+        b = ReactDOM.findDOMNode(this);
+        expect(b).not.toBe(null);
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    expect(a).toBe(container.firstChild);
+    ReactDOM.render(<Component />, container);
+    ReactDOM.unmountComponentAtNode(container);
+    expect(a).toBe(b);
+  });
+
+  it('context should be passed down from the parent', () => {
+    class Parent extends React.Component {
+      static childContextTypes = {
+        foo: PropTypes.string,
+      };
+
+      getChildContext() {
+        return {
+          foo: 'bar',
+        };
+      }
+
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    class Component extends React.Component {
+      static contextTypes = {
+        foo: PropTypes.string.isRequired,
+      };
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var div = document.createElement('div');
+    ReactDOM.render(<Parent><Component /></Parent>, div);
+  });
+
+  it('should replace state', () => {
+    class Moo extends React.Component {
+      state = {x: 1};
+      render() {
+        return <div />;
+      }
+    }
+
+    var moo = ReactTestUtils.renderIntoDocument(<Moo />);
+    // No longer a public API, but we can test that it works internally by
+    // reaching into the updater.
+    moo.updater.enqueueReplaceState(moo, {y: 2});
+    expect('x' in moo.state).toBe(false);
+    expect(moo.state.y).toBe(2);
+  });
+
+  it('should support objects with prototypes as state', () => {
+    var NotActuallyImmutable = function(str) {
+      this.str = str;
+    };
+    NotActuallyImmutable.prototype.amIImmutable = function() {
+      return true;
+    };
+    class Moo extends React.Component {
+      state = new NotActuallyImmutable('first');
+      // No longer a public API, but we can test that it works internally by
+      // reaching into the updater.
+      _replaceState = update => this.updater.enqueueReplaceState(this, update);
+      render() {
+        return <div />;
+      }
+    }
+
+    var moo = ReactTestUtils.renderIntoDocument(<Moo />);
+    expect(moo.state.str).toBe('first');
+    expect(moo.state.amIImmutable()).toBe(true);
+
+    var secondState = new NotActuallyImmutable('second');
+    moo._replaceState(secondState);
+    expect(moo.state.str).toBe('second');
+    expect(moo.state.amIImmutable()).toBe(true);
+    expect(moo.state).toBe(secondState);
+
+    moo.setState({str: 'third'});
+    expect(moo.state.str).toBe('third');
+    // Here we lose the prototype.
+    expect(moo.state.amIImmutable).toBe(undefined);
+
+    // When more than one state update is enqueued, we have the same behavior
+    var fifthState = new NotActuallyImmutable('fifth');
+    ReactDOM.unstable_batchedUpdates(function() {
+      moo.setState({str: 'fourth'});
+      moo._replaceState(fifthState);
+    });
+    expect(moo.state).toBe(fifthState);
+
+    // When more than one state update is enqueued, we have the same behavior
+    var sixthState = new NotActuallyImmutable('sixth');
+    ReactDOM.unstable_batchedUpdates(function() {
+      moo._replaceState(sixthState);
+      moo.setState({str: 'seventh'});
+    });
+    expect(moo.state.str).toBe('seventh');
+    expect(moo.state.amIImmutable).toBe(undefined);
+  });
+
+  it('should not warn about unmounting during unmounting', () => {
+    var container = document.createElement('div');
+    var layer = document.createElement('div');
+
+    class Component extends React.Component {
+      componentDidMount() {
+        ReactDOM.render(<div />, layer);
+      }
+
+      componentWillUnmount() {
+        ReactDOM.unmountComponentAtNode(layer);
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    class Outer extends React.Component {
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    ReactDOM.render(<Outer><Component /></Outer>, container);
+    ReactDOM.render(<Outer />, container);
+  });
+
+  it('should warn when mutated props are passed', () => {
+    spyOn(console, 'error');
+
+    var container = document.createElement('div');
+
+    class Foo extends React.Component {
+      constructor(props) {
+        var _props = {idx: props.idx + '!'};
+        super(_props);
+      }
+
+      render() {
+        return <span />;
+      }
+    }
+
+    expectDev(console.error.calls.count()).toBe(0);
+
+    ReactDOM.render(<Foo idx="qwe" />, container);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Foo(...): When calling super() in `Foo`, make sure to pass ' +
+        "up the same props that your component's constructor was passed.",
+    );
+  });
+
+  it('should only call componentWillUnmount once', () => {
+    var app;
+    var count = 0;
+
+    class App extends React.Component {
+      render() {
+        if (this.props.stage === 1) {
+          return <UnunmountableComponent />;
+        } else {
+          return null;
+        }
+      }
+    }
+
+    class UnunmountableComponent extends React.Component {
+      componentWillUnmount() {
+        app.setState({});
+        count++;
+        throw Error('always fails');
+      }
+
+      render() {
+        return <div>Hello {this.props.name}</div>;
+      }
+    }
+
+    var container = document.createElement('div');
+
+    var setRef = ref => {
+      if (ref) {
+        app = ref;
+      }
+    };
+
+    expect(function() {
+      ReactDOM.render(<App ref={setRef} stage={1} />, container);
+      ReactDOM.render(<App ref={setRef} stage={2} />, container);
+    }).toThrow();
+    expect(count).toBe(1);
+  });
+
+  it('prepares new child before unmounting old', () => {
+    var log = [];
+
+    class Spy extends React.Component {
+      componentWillMount() {
+        log.push(this.props.name + ' componentWillMount');
+      }
+      render() {
+        log.push(this.props.name + ' render');
+        return <div />;
+      }
+      componentDidMount() {
+        log.push(this.props.name + ' componentDidMount');
+      }
+      componentWillUnmount() {
+        log.push(this.props.name + ' componentWillUnmount');
+      }
+    }
+
+    class Wrapper extends React.Component {
+      render() {
+        return <Spy key={this.props.name} name={this.props.name} />;
+      }
+    }
+
+    var container = document.createElement('div');
+    ReactDOM.render(<Wrapper name="A" />, container);
+    ReactDOM.render(<Wrapper name="B" />, container);
+
+    expect(log).toEqual([
+      'A componentWillMount',
+      'A render',
+      'A componentDidMount',
+
+      'B componentWillMount',
+      'B render',
+      'A componentWillUnmount',
+      'B componentDidMount',
+    ]);
+  });
+
+  it('respects a shallow shouldComponentUpdate implementation', () => {
+    var renderCalls = 0;
+    class PlasticWrap extends React.Component {
+      constructor(props, context) {
+        super(props, context);
+        this.state = {
+          color: 'green',
+        };
+      }
+
+      render() {
+        return <Apple color={this.state.color} ref="apple" />;
+      }
+    }
+
+    class Apple extends React.Component {
+      state = {
+        cut: false,
+        slices: 1,
+      };
+
+      shouldComponentUpdate(nextProps, nextState) {
+        return shallowCompare(this, nextProps, nextState);
+      }
+
+      cut() {
+        this.setState({
+          cut: true,
+          slices: 10,
+        });
+      }
+
+      eatSlice() {
+        this.setState({
+          slices: this.state.slices - 1,
+        });
+      }
+
+      render() {
+        renderCalls++;
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(<PlasticWrap />, container);
+    expect(renderCalls).toBe(1);
+
+    // Do not re-render based on props
+    instance.setState({color: 'green'});
+    expect(renderCalls).toBe(1);
+
+    // Re-render based on props
+    instance.setState({color: 'red'});
+    expect(renderCalls).toBe(2);
+
+    // Re-render base on state
+    instance.refs.apple.cut();
+    expect(renderCalls).toBe(3);
+
+    // No re-render based on state
+    instance.refs.apple.cut();
+    expect(renderCalls).toBe(3);
+
+    // Re-render based on state again
+    instance.refs.apple.eatSlice();
+    expect(renderCalls).toBe(4);
+  });
+
+  it('does not do a deep comparison for a shallow shouldComponentUpdate implementation', () => {
+    function getInitialState() {
+      return {
+        foo: [1, 2, 3],
+        bar: {a: 4, b: 5, c: 6},
+      };
+    }
+
+    var renderCalls = 0;
+    var initialSettings = getInitialState();
+
+    class Component extends React.Component {
+      state = initialSettings;
+
+      shouldComponentUpdate(nextProps, nextState) {
+        return shallowCompare(this, nextProps, nextState);
+      }
+
+      render() {
+        renderCalls++;
+        return <div />;
+      }
+    }
+
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(<Component />, container);
+    expect(renderCalls).toBe(1);
+
+    // Do not re-render if state is equal
+    var settings = {
+      foo: initialSettings.foo,
+      bar: initialSettings.bar,
+    };
+    instance.setState(settings);
+    expect(renderCalls).toBe(1);
+
+    // Re-render because one field changed
+    initialSettings.foo = [1, 2, 3];
+    instance.setState(initialSettings);
+    expect(renderCalls).toBe(2);
+
+    // Re-render because the object changed
+    instance.setState(getInitialState());
+    expect(renderCalls).toBe(3);
+  });
+
+  it('should call setState callback with no arguments', () => {
+    let mockArgs;
+    class Component extends React.Component {
+      componentDidMount() {
+        this.setState({}, (...args) => (mockArgs = args));
+      }
+      render() {
+        return false;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Component />);
+    expect(mockArgs.length).toEqual(0);
+  });
+});

commit 7f10fae4c18510f64d7cf07bcbf4a1742387f2e4
Author: shawn wang <shawnthe1@gmail.com>
Date:   Tue Oct 31 08:02:55 2017 -0400

    Warn if class has a render() method but doesn't extend React.Component (#11168)
    
    Warn if class has a render() method but doesn't extend React.Component

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 75f3e8060f..56bd6c63ab 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -326,6 +326,26 @@ describe('ReactCompositeComponent', () => {
     expect(cbCalled).toBe(false);
   });
 
+  it('should warn when rendering a class with a render method that does not extend React.Component', () => {
+    spyOn(console, 'error');
+    var container = document.createElement('div');
+    class ClassWithRenderNotExtended {
+      render() {
+        return <div />;
+      }
+    }
+    expectDev(console.error.calls.count()).toBe(0);
+    expect(() => {
+      ReactDOM.render(<ClassWithRenderNotExtended />, container);
+    }).toThrow(TypeError);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+        "but doesn't extend React.Component. This is likely to cause errors. " +
+        'Change ClassWithRenderNotExtended to extend React.Component instead.',
+    );
+  });
+
   it('should warn about `setState` in render', () => {
     spyOn(console, 'error');
 

commit 3f1f3dc12e72809c997d8e1078edfadd7e31bc14
Author: Anushree Subramani <anushreesubramani@users.noreply.github.com>
Date:   Tue Oct 31 18:05:28 2017 +0530

     Deduplicated many warnings (#11140) (#11216)
    
    *  Deduplicated many warnings (#11140)
    
    *  Deduplicated the following warnings:
    
    1.  Can only update a mounted or mounting component.
        This usually means you called setState, replaceState,
        or forceUpdate on an unmounted component. This is a no-op
    
    2.  %s.componentWillReceiveProps(): Assigning directly to
        this.state is deprecated (except inside a component's
        constructor). Use setState instead.'
    
    3.  An update (setState, replaceState, or forceUpdate) was scheduled
        from inside an update function. Update functions should be pure,
        with zero side-effects. Consider using componentDidUpdate or a
        callback.
    
    4.  setState(...): Cannot call setState() inside getChildContext()
    
    * Code review changes made for #11140
    
    * Minor style fix
    
    * Test deduplication for noop updates in server renderer
    
    * Test deduplication for cWRP warning
    
    * Test deduplication for cWM setState warning
    
    * Test deduplication for unnmounted setState warning
    
    * Fix existing Flow typing
    
    * Test deduplication for invalid updates
    
    * Test deduplication of update-in-updater warning

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 56bd6c63ab..10b4b73c33 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -252,6 +252,9 @@ describe('ReactCompositeComponent', () => {
         'component. This is a no-op.\n\nPlease check the code for the ' +
         'Component component.',
     );
+
+    instance.forceUpdate();
+    expectDev(console.error.calls.count()).toBe(1);
   });
 
   it('should warn about `setState` on unmounted components', () => {
@@ -391,6 +394,11 @@ describe('ReactCompositeComponent', () => {
     expect(instance).toBe(instance2);
     expect(renderedState).toBe(1);
     expect(instance2.state.value).toBe(1);
+
+    // Test deduplication
+    ReactDOM.unmountComponentAtNode(container);
+    ReactDOM.render(<Component prop={123} />, container);
+    expectDev(console.error.calls.count()).toBe(1);
   });
 
   it('should warn about `setState` in getChildContext', () => {
@@ -424,6 +432,11 @@ describe('ReactCompositeComponent', () => {
     expectDev(console.error.calls.argsFor(0)[0]).toBe(
       'Warning: setState(...): Cannot call setState() inside getChildContext()',
     );
+
+    // Test deduplication
+    ReactDOM.unmountComponentAtNode(container);
+    ReactDOM.render(<Component />, container);
+    expectDev(console.error.calls.count()).toBe(1);
   });
 
   it('should cleanup even if render() fatals', () => {

commit 787c2ad2d97d001f35757877abd623c9a6b87afd
Author: Dean Brophy <dean.brophy@gmail.com>
Date:   Wed Nov 1 15:01:24 2017 -0600

    Constructor error message (#11395)
    
    * Constructor test and fix complete
    
    * Linters and prettier run
    
    * Remove unnecessary checks
    
    * Update error message
    
    * Updat unit test
    
    * prettier
    
    * Tweak the check to be more specific
    
    * Move tests to ReactCompositeComponent-test
    
    * add error call count and remove line

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 10b4b73c33..af7688573b 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1533,4 +1533,43 @@ describe('ReactCompositeComponent', () => {
     ReactTestUtils.renderIntoDocument(<Component />);
     expect(mockArgs.length).toEqual(0);
   });
+
+  it('should return a meaningful warning when constructor is returned', () => {
+    spyOn(console, 'error');
+    class RenderTextInvalidConstructor extends React.Component {
+      constructor(props) {
+        super(props);
+        return {something: false};
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    expect(function() {
+      ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
+    }).toThrow();
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.mostRecent().args[0]).toBe(
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+    );
+  });
+
+  it('should return error if render is not defined', () => {
+    spyOn(console, 'error');
+    class RenderTestUndefinedRender extends React.Component {}
+
+    expect(function() {
+      ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
+    }).toThrow();
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.mostRecent().args[0]).toBe(
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+    );
+  });
 });

commit 48012ef839bc13e35188b68d2db145869a6a05f5
Author: Tom <tom@tomm.cc>
Date:   Wed Nov 8 00:00:31 2017 +1000

    Add warning for componentDidReceiveProps() (#11479)
    
    * Add warning for componentDidReceiveProps()
    
    * Adjust message for componentDidReceiveProps() warning

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index af7688573b..51730d7ff8 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -533,6 +533,29 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
+  it('should warn when componentDidReceiveProps method is defined', () => {
+    spyOn(console, 'error');
+
+    class Component extends React.Component {
+      componentDidReceiveProps = () => {};
+
+      render() {
+        return <div />;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Component />);
+
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toBe(
+      'Warning: Component has a method called ' +
+        'componentDidReceiveProps(). But there is no such lifecycle method. ' +
+        'If you meant to update the state in response to changing props, ' +
+        'use componentWillReceiveProps(). If you meant to fetch data or ' +
+        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+    );
+  });
+
   it('should warn when defaultProps was defined as an instance property', () => {
     spyOn(console, 'error');
 

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 51730d7ff8..17b54543fd 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -48,9 +48,11 @@ describe('ReactCompositeComponent', () => {
 
       render() {
         var toggleActivatedState = this._toggleActivatedState;
-        return !this.state.activated
-          ? <a ref="x" onClick={toggleActivatedState} />
-          : <b ref="x" onClick={toggleActivatedState} />;
+        return !this.state.activated ? (
+          <a ref="x" onClick={toggleActivatedState} />
+        ) : (
+          <b ref="x" onClick={toggleActivatedState} />
+        );
       }
     };
 
@@ -65,9 +67,11 @@ describe('ReactCompositeComponent', () => {
 
       render() {
         var className = this.props.anchorClassOn ? 'anchorClass' : '';
-        return this.props.renderAnchor
-          ? <a ref="anch" className={className} />
-          : <b />;
+        return this.props.renderAnchor ? (
+          <a ref="anch" className={className} />
+        ) : (
+          <b />
+        );
       }
     };
   });
@@ -110,7 +114,11 @@ describe('ReactCompositeComponent', () => {
 
     class Parent extends React.Component {
       render() {
-        return <div><Child /></div>;
+        return (
+          <div>
+            <Child />
+          </div>
+        );
       }
     }
 
@@ -582,7 +590,11 @@ describe('ReactCompositeComponent', () => {
   it('should pass context to children when not owner', () => {
     class Parent extends React.Component {
       render() {
-        return <Child><Grandchild /></Child>;
+        return (
+          <Child>
+            <Grandchild />
+          </Child>
+        );
       }
     }
 
@@ -685,7 +697,11 @@ describe('ReactCompositeComponent', () => {
     }
 
     parentInstance = ReactTestUtils.renderIntoDocument(
-      <Parent><Middle><Child /></Middle></Parent>,
+      <Parent>
+        <Middle>
+          <Child />
+        </Middle>
+      </Parent>,
     );
 
     expect(parentInstance.state.flag).toBe(false);
@@ -1139,15 +1155,23 @@ describe('ReactCompositeComponent', () => {
         if (this.props.flipped) {
           return (
             <div>
-              <Static ref="static0" key="B">B (ignored)</Static>
-              <Static ref="static1" key="A">A (ignored)</Static>
+              <Static ref="static0" key="B">
+                B (ignored)
+              </Static>
+              <Static ref="static1" key="A">
+                A (ignored)
+              </Static>
             </div>
           );
         } else {
           return (
             <div>
-              <Static ref="static0" key="A">A</Static>
-              <Static ref="static1" key="B">B</Static>
+              <Static ref="static0" key="A">
+                A
+              </Static>
+              <Static ref="static1" key="B">
+                B
+              </Static>
             </div>
           );
         }
@@ -1221,7 +1245,12 @@ describe('ReactCompositeComponent', () => {
     }
 
     var div = document.createElement('div');
-    ReactDOM.render(<Parent><Component /></Parent>, div);
+    ReactDOM.render(
+      <Parent>
+        <Component />
+      </Parent>,
+      div,
+    );
   });
 
   it('should replace state', () => {
@@ -1314,7 +1343,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactDOM.render(<Outer><Component /></Outer>, container);
+    ReactDOM.render(
+      <Outer>
+        <Component />
+      </Outer>,
+      container,
+    );
     ReactDOM.render(<Outer />, container);
   });
 

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 17b54543fd..5797e4b942 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -122,26 +122,29 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    spyOn(console, 'warn');
+    spyOnDev(console, 'warn');
     var markup = ReactDOMServer.renderToString(<Parent />);
 
     // Old API based on heuristic
     var container = document.createElement('div');
     container.innerHTML = markup;
     ReactDOM.render(<Parent />, container);
-    expectDev(console.warn.calls.count()).toBe(1);
-    expectDev(console.warn.calls.argsFor(0)[0]).toContain(
-      'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
-        'will stop working in React v17. Replace the ReactDOM.render() call ' +
-        'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
-    );
-
+    if (__DEV__) {
+      expect(console.warn.calls.count()).toBe(1);
+      expect(console.warn.calls.argsFor(0)[0]).toContain(
+        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
+          'will stop working in React v17. Replace the ReactDOM.render() call ' +
+          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
+      );
+      console.warn.calls.reset();
+    }
     // New explicit API
-    console.warn.calls.reset();
     container = document.createElement('div');
     container.innerHTML = markup;
     ReactDOM.hydrate(<Parent />, container);
-    expectDev(console.warn.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.warn.calls.count()).toBe(0);
+    }
   });
 
   it('should react to state changes from callbacks', () => {
@@ -231,7 +234,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn about `forceUpdate` on unmounted components', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     var container = document.createElement('div');
     document.body.appendChild(container);
@@ -248,25 +251,31 @@ describe('ReactCompositeComponent', () => {
     instance = ReactDOM.render(instance, container);
     instance.forceUpdate();
 
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
 
     ReactDOM.unmountComponentAtNode(container);
 
     instance.forceUpdate();
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Can only update a mounted or mounting component. This usually means ' +
-        'you called setState, replaceState, or forceUpdate on an unmounted ' +
-        'component. This is a no-op.\n\nPlease check the code for the ' +
-        'Component component.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Can only update a mounted or mounting component. This usually means ' +
+          'you called setState, replaceState, or forceUpdate on an unmounted ' +
+          'component. This is a no-op.\n\nPlease check the code for the ' +
+          'Component component.',
+      );
+    }
 
     instance.forceUpdate();
-    expectDev(console.error.calls.count()).toBe(1);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+    }
   });
 
   it('should warn about `setState` on unmounted components', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     var container = document.createElement('div');
     document.body.appendChild(container);
@@ -291,7 +300,9 @@ describe('ReactCompositeComponent', () => {
 
     instance.setState({value: 1});
 
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
 
     expect(renders).toBe(2);
 
@@ -300,13 +311,15 @@ describe('ReactCompositeComponent', () => {
 
     expect(renders).toBe(2);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Can only update a mounted or mounting component. This usually means ' +
-        'you called setState, replaceState, or forceUpdate on an unmounted ' +
-        'component. This is a no-op.\n\nPlease check the code for the ' +
-        'Component component.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Can only update a mounted or mounting component. This usually means ' +
+          'you called setState, replaceState, or forceUpdate on an unmounted ' +
+          'component. This is a no-op.\n\nPlease check the code for the ' +
+          'Component component.',
+      );
+    }
   });
 
   it('should silently allow `setState`, not call cb on unmounting components', () => {
@@ -338,27 +351,31 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when rendering a class with a render method that does not extend React.Component', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     var container = document.createElement('div');
     class ClassWithRenderNotExtended {
       render() {
         return <div />;
       }
     }
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
     expect(() => {
       ReactDOM.render(<ClassWithRenderNotExtended />, container);
     }).toThrow(TypeError);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
-        "but doesn't extend React.Component. This is likely to cause errors. " +
-        'Change ClassWithRenderNotExtended to extend React.Component instead.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+          "but doesn't extend React.Component. This is likely to cause errors. " +
+          'Change ClassWithRenderNotExtended to extend React.Component instead.',
+      );
+    }
   });
 
   it('should warn about `setState` in render', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     var container = document.createElement('div');
 
@@ -378,17 +395,21 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
 
     var instance = ReactDOM.render(<Component />, container);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Cannot update during an existing state transition (such as within ' +
-        "`render` or another component's constructor). Render methods should " +
-        'be a pure function of props and state; constructor side-effects are ' +
-        'an anti-pattern, but can be moved to `componentWillMount`.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Cannot update during an existing state transition (such as within ' +
+          "`render` or another component's constructor). Render methods should " +
+          'be a pure function of props and state; constructor side-effects are ' +
+          'an anti-pattern, but can be moved to `componentWillMount`.',
+      );
+    }
 
     // The setState call is queued and then executed as a second pass. This
     // behavior is undefined though so we're free to change it to suit the
@@ -406,11 +427,13 @@ describe('ReactCompositeComponent', () => {
     // Test deduplication
     ReactDOM.unmountComponentAtNode(container);
     ReactDOM.render(<Component prop={123} />, container);
-    expectDev(console.error.calls.count()).toBe(1);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+    }
   });
 
   it('should warn about `setState` in getChildContext', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     var container = document.createElement('div');
 
@@ -432,19 +455,25 @@ describe('ReactCompositeComponent', () => {
     }
     Component.childContextTypes = {};
 
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
     var instance = ReactDOM.render(<Component />, container);
     expect(renderPasses).toBe(2);
     expect(instance.state.value).toBe(1);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toBe(
-      'Warning: setState(...): Cannot call setState() inside getChildContext()',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toBe(
+        'Warning: setState(...): Cannot call setState() inside getChildContext()',
+      );
+    }
 
     // Test deduplication
     ReactDOM.unmountComponentAtNode(container);
     ReactDOM.render(<Component />, container);
-    expectDev(console.error.calls.count()).toBe(1);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+    }
   });
 
   it('should cleanup even if render() fatals', () => {
@@ -496,7 +525,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when shouldComponentUpdate() returns undefined', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     class Component extends React.Component {
       state = {bogus: false};
@@ -513,15 +542,17 @@ describe('ReactCompositeComponent', () => {
     var instance = ReactTestUtils.renderIntoDocument(<Component />);
     instance.setState({bogus: true});
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toBe(
-      'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
-        'boolean value. Make sure to return true or false.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toBe(
+        'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
+          'boolean value. Make sure to return true or false.',
+      );
+    }
   });
 
   it('should warn when componentDidUnmount method is defined', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     class Component extends React.Component {
       componentDidUnmount = () => {};
@@ -533,16 +564,18 @@ describe('ReactCompositeComponent', () => {
 
     ReactTestUtils.renderIntoDocument(<Component />);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toBe(
-      'Warning: Component has a method called ' +
-        'componentDidUnmount(). But there is no such lifecycle method. ' +
-        'Did you mean componentWillUnmount()?',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toBe(
+        'Warning: Component has a method called ' +
+          'componentDidUnmount(). But there is no such lifecycle method. ' +
+          'Did you mean componentWillUnmount()?',
+      );
+    }
   });
 
   it('should warn when componentDidReceiveProps method is defined', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     class Component extends React.Component {
       componentDidReceiveProps = () => {};
@@ -554,18 +587,20 @@ describe('ReactCompositeComponent', () => {
 
     ReactTestUtils.renderIntoDocument(<Component />);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toBe(
-      'Warning: Component has a method called ' +
-        'componentDidReceiveProps(). But there is no such lifecycle method. ' +
-        'If you meant to update the state in response to changing props, ' +
-        'use componentWillReceiveProps(). If you meant to fetch data or ' +
-        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toBe(
+        'Warning: Component has a method called ' +
+          'componentDidReceiveProps(). But there is no such lifecycle method. ' +
+          'If you meant to update the state in response to changing props, ' +
+          'use componentWillReceiveProps(). If you meant to fetch data or ' +
+          'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+      );
+    }
   });
 
   it('should warn when defaultProps was defined as an instance property', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     class Component extends React.Component {
       constructor(props) {
@@ -580,11 +615,13 @@ describe('ReactCompositeComponent', () => {
 
     ReactTestUtils.renderIntoDocument(<Component />);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toBe(
-      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
-        'and will be ignored. Instead, define defaultProps as a static property on Component.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toBe(
+        'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+          'and will be ignored. Instead, define defaultProps as a static property on Component.',
+      );
+    }
   });
 
   it('should pass context to children when not owner', () => {
@@ -1056,7 +1093,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should disallow nested render calls', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     class Inner extends React.Component {
       render() {
@@ -1072,13 +1109,15 @@ describe('ReactCompositeComponent', () => {
     }
 
     ReactTestUtils.renderIntoDocument(<Outer />);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toMatch(
-      'Render methods should be a pure function of props and state; ' +
-        'triggering nested component updates from render is not allowed. If ' +
-        'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
-        'render method of Outer.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toMatch(
+        'Render methods should be a pure function of props and state; ' +
+          'triggering nested component updates from render is not allowed. If ' +
+          'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
+          'render method of Outer.',
+      );
+    }
   });
 
   it('only renders once if updated in componentWillReceiveProps', () => {
@@ -1353,7 +1392,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when mutated props are passed', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     var container = document.createElement('div');
 
@@ -1368,15 +1407,19 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expectDev(console.error.calls.count()).toBe(0);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(0);
+    }
 
     ReactDOM.render(<Foo idx="qwe" />, container);
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Foo(...): When calling super() in `Foo`, make sure to pass ' +
-        "up the same props that your component's constructor was passed.",
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Foo(...): When calling super() in `Foo`, make sure to pass ' +
+          "up the same props that your component's constructor was passed.",
+      );
+    }
   });
 
   it('should only call componentWillUnmount once', () => {
@@ -1592,7 +1635,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should return a meaningful warning when constructor is returned', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     class RenderTextInvalidConstructor extends React.Component {
       constructor(props) {
         super(props);
@@ -1608,25 +1651,29 @@ describe('ReactCompositeComponent', () => {
       ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
     }).toThrow();
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.mostRecent().args[0]).toBe(
-      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
-        'did you accidentally return an object from the constructor?',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.mostRecent().args[0]).toBe(
+        'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+          'did you accidentally return an object from the constructor?',
+      );
+    }
   });
 
   it('should return error if render is not defined', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     class RenderTestUndefinedRender extends React.Component {}
 
     expect(function() {
       ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
     }).toThrow();
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.mostRecent().args[0]).toBe(
-      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-        'component instance: you may have forgotten to define `render`.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.mostRecent().args[0]).toBe(
+        'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+          'component instance: you may have forgotten to define `render`.',
+      );
+    }
   });
 });

commit f114bad09f7a3ddc11265741cb84250fd08d5890
Author: Alex Cordeiro <accordeiro@users.noreply.github.com>
Date:   Wed Nov 22 20:15:11 2017 -0200

    Bug fix - SetState callback called before component state is updated in ReactShallowRenderer (#11507)
    
    * Create test to verify ReactShallowRenderer bug (#11496)
    
    * Fix ReactShallowRenderer callback bug on componentWillMount (#11496)
    
    * Improve fnction naming and clean up queued callback before call
    
    * Run prettier on ReactShallowRenderer.js
    
    * Consolidate callback call on ReactShallowRenderer.js
    
    * Ensure callback behavior is similar between ReactDOM and ReactShallowRenderer
    
    * Fix Code Review requests (#11507)
    
    * Move test to ReactCompositeComponent
    
    * Verify the callback gets called
    
    * Ensure multiple callbacks are correctly handled on ReactShallowRenderer
    
    * Ensure the setState callback is called inside componentWillMount (ReactDOM)
    
    * Clear ReactShallowRenderer callback queue before actually calling the callbacks
    
    * Add test for multiple callbacks on ReactShallowRenderer
    
    * Ensure the ReactShallowRenderer callback queue is cleared after invoking callbacks
    
    * Remove references to internal fields on ReactShallowRenderer test

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 5797e4b942..1bac93ec04 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1634,6 +1634,73 @@ describe('ReactCompositeComponent', () => {
     expect(mockArgs.length).toEqual(0);
   });
 
+  it('this.state should be updated on setState callback inside componentWillMount', () => {
+    const div = document.createElement('div');
+    let stateSuccessfullyUpdated = false;
+
+    class Component extends React.Component {
+      constructor(props, context) {
+        super(props, context);
+        this.state = {
+          hasUpdatedState: false,
+        };
+      }
+
+      componentWillMount() {
+        this.setState(
+          {hasUpdatedState: true},
+          () => (stateSuccessfullyUpdated = this.state.hasUpdatedState),
+        );
+      }
+
+      render() {
+        return <div>{this.props.children}</div>;
+      }
+    }
+
+    ReactDOM.render(<Component />, div);
+    expect(stateSuccessfullyUpdated).toBe(true);
+  });
+
+  it('should call the setState callback even if shouldComponentUpdate = false', done => {
+    const mockFn = jest.fn().mockReturnValue(false);
+    const div = document.createElement('div');
+
+    let instance;
+
+    class Component extends React.Component {
+      constructor(props, context) {
+        super(props, context);
+        this.state = {
+          hasUpdatedState: false,
+        };
+      }
+
+      componentWillMount() {
+        instance = this;
+      }
+
+      shouldComponentUpdate() {
+        return mockFn();
+      }
+
+      render() {
+        return <div>{this.state.hasUpdatedState}</div>;
+      }
+    }
+
+    ReactDOM.render(<Component />, div);
+
+    expect(instance).toBeDefined();
+    expect(mockFn).not.toBeCalled();
+
+    instance.setState({hasUpdatedState: true}, () => {
+      expect(mockFn).toBeCalled();
+      expect(instance.state.hasUpdatedState).toBe(true);
+      done();
+    });
+  });
+
   it('should return a meaningful warning when constructor is returned', () => {
     spyOnDev(console, 'error');
     class RenderTextInvalidConstructor extends React.Component {

commit 48616e591fe23c0b89b0823c3ec99bae2d7b6853
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Tue Dec 5 16:29:22 2017 -0200

    react-dom: convert packages/react-dom/src/__tests__ (#11776)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 1bac93ec04..3ae6384dbb 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -9,16 +9,16 @@
 
 'use strict';
 
-var ChildUpdates;
-var MorphingComponent;
-var React;
-var ReactDOM;
-var ReactDOMServer;
-var ReactCurrentOwner;
-var ReactTestUtils;
-var PropTypes;
-var shallowEqual;
-var shallowCompare;
+let ChildUpdates;
+let MorphingComponent;
+let React;
+let ReactDOM;
+let ReactDOMServer;
+let ReactCurrentOwner;
+let ReactTestUtils;
+let PropTypes;
+let shallowEqual;
+let shallowCompare;
 
 describe('ReactCompositeComponent', () => {
   beforeEach(() => {
@@ -47,7 +47,7 @@ describe('ReactCompositeComponent', () => {
       };
 
       render() {
-        var toggleActivatedState = this._toggleActivatedState;
+        const toggleActivatedState = this._toggleActivatedState;
         return !this.state.activated ? (
           <a ref="x" onClick={toggleActivatedState} />
         ) : (
@@ -66,7 +66,7 @@ describe('ReactCompositeComponent', () => {
       };
 
       render() {
-        var className = this.props.anchorClassOn ? 'anchorClass' : '';
+        const className = this.props.anchorClassOn ? 'anchorClass' : '';
         return this.props.renderAnchor ? (
           <a ref="anch" className={className} />
         ) : (
@@ -85,15 +85,15 @@ describe('ReactCompositeComponent', () => {
       };
     }
 
-    var el = document.createElement('div');
+    const el = document.createElement('div');
     ReactDOM.render(<Child test="test" />, el);
 
     expect(el.textContent).toBe('test');
   });
 
   it('should support rendering to different child types over time', () => {
-    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
-    var el = ReactDOM.findDOMNode(instance);
+    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+    let el = ReactDOM.findDOMNode(instance);
     expect(el.tagName).toBe('A');
 
     instance._toggleActivatedState();
@@ -123,10 +123,10 @@ describe('ReactCompositeComponent', () => {
     }
 
     spyOnDev(console, 'warn');
-    var markup = ReactDOMServer.renderToString(<Parent />);
+    const markup = ReactDOMServer.renderToString(<Parent />);
 
     // Old API based on heuristic
-    var container = document.createElement('div');
+    let container = document.createElement('div');
     container.innerHTML = markup;
     ReactDOM.render(<Parent />, container);
     if (__DEV__) {
@@ -148,8 +148,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should react to state changes from callbacks', () => {
-    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
-    var el = ReactDOM.findDOMNode(instance);
+    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+    let el = ReactDOM.findDOMNode(instance);
     expect(el.tagName).toBe('A');
 
     ReactTestUtils.Simulate.click(el);
@@ -158,7 +158,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should rewire refs when rendering to different child types', () => {
-    var instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
+    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
 
     expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('A');
     instance._toggleActivatedState();
@@ -168,8 +168,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should not cache old DOM nodes when switching constructors', () => {
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(
       <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
       container,
     );
@@ -200,15 +200,15 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance1 = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance1 = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance1.props).toEqual({prop: 'testKey'});
 
-    var instance2 = ReactTestUtils.renderIntoDocument(
+    const instance2 = ReactTestUtils.renderIntoDocument(
       <Component prop={undefined} />,
     );
     expect(instance2.props).toEqual({prop: 'testKey'});
 
-    var instance3 = ReactTestUtils.renderIntoDocument(
+    const instance3 = ReactTestUtils.renderIntoDocument(
       <Component prop={null} />,
     );
     expect(instance3.props).toEqual({prop: null});
@@ -223,8 +223,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var inputProps = {};
-    var instance1 = <Component {...inputProps} />;
+    const inputProps = {};
+    let instance1 = <Component {...inputProps} />;
     instance1 = ReactTestUtils.renderIntoDocument(instance1);
     expect(instance1.props.prop).toBe('testKey');
 
@@ -236,7 +236,7 @@ describe('ReactCompositeComponent', () => {
   it('should warn about `forceUpdate` on unmounted components', () => {
     spyOnDev(console, 'error');
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     document.body.appendChild(container);
 
     class Component extends React.Component {
@@ -245,7 +245,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance = <Component />;
+    let instance = <Component />;
     expect(instance.forceUpdate).not.toBeDefined();
 
     instance = ReactDOM.render(instance, container);
@@ -277,10 +277,10 @@ describe('ReactCompositeComponent', () => {
   it('should warn about `setState` on unmounted components', () => {
     spyOnDev(console, 'error');
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     document.body.appendChild(container);
 
-    var renders = 0;
+    let renders = 0;
 
     class Component extends React.Component {
       state = {value: 0};
@@ -291,7 +291,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance = <Component />;
+    let instance = <Component />;
     expect(instance.setState).not.toBeDefined();
 
     instance = ReactDOM.render(instance, container);
@@ -323,8 +323,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should silently allow `setState`, not call cb on unmounting components', () => {
-    var cbCalled = false;
-    var container = document.createElement('div');
+    let cbCalled = false;
+    const container = document.createElement('div');
     document.body.appendChild(container);
 
     class Component extends React.Component {
@@ -343,7 +343,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance = ReactDOM.render(<Component />, container);
+    const instance = ReactDOM.render(<Component />, container);
     instance.setState({value: 1});
 
     ReactDOM.unmountComponentAtNode(container);
@@ -352,7 +352,7 @@ describe('ReactCompositeComponent', () => {
 
   it('should warn when rendering a class with a render method that does not extend React.Component', () => {
     spyOnDev(console, 'error');
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     class ClassWithRenderNotExtended {
       render() {
         return <div />;
@@ -377,10 +377,10 @@ describe('ReactCompositeComponent', () => {
   it('should warn about `setState` in render', () => {
     spyOnDev(console, 'error');
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
 
-    var renderedState = -1;
-    var renderPasses = 0;
+    let renderedState = -1;
+    let renderPasses = 0;
 
     class Component extends React.Component {
       state = {value: 0};
@@ -399,7 +399,7 @@ describe('ReactCompositeComponent', () => {
       expect(console.error.calls.count()).toBe(0);
     }
 
-    var instance = ReactDOM.render(<Component />, container);
+    const instance = ReactDOM.render(<Component />, container);
 
     if (__DEV__) {
       expect(console.error.calls.count()).toBe(1);
@@ -419,7 +419,7 @@ describe('ReactCompositeComponent', () => {
     expect(instance.state.value).toBe(1);
 
     // Forcing a rerender anywhere will cause the update to happen.
-    var instance2 = ReactDOM.render(<Component prop={123} />, container);
+    const instance2 = ReactDOM.render(<Component prop={123} />, container);
     expect(instance).toBe(instance2);
     expect(renderedState).toBe(1);
     expect(instance2.state.value).toBe(1);
@@ -435,9 +435,9 @@ describe('ReactCompositeComponent', () => {
   it('should warn about `setState` in getChildContext', () => {
     spyOnDev(console, 'error');
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
 
-    var renderPasses = 0;
+    let renderPasses = 0;
 
     class Component extends React.Component {
       state = {value: 0};
@@ -458,7 +458,7 @@ describe('ReactCompositeComponent', () => {
     if (__DEV__) {
       expect(console.error.calls.count()).toBe(0);
     }
-    var instance = ReactDOM.render(<Component />, container);
+    const instance = ReactDOM.render(<Component />, container);
     expect(renderPasses).toBe(2);
     expect(instance.state.value).toBe(1);
     if (__DEV__) {
@@ -483,7 +483,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance = <BadComponent />;
+    let instance = <BadComponent />;
 
     expect(ReactCurrentOwner.current).toBe(null);
 
@@ -495,8 +495,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should call componentWillUnmount before unmounting', () => {
-    var container = document.createElement('div');
-    var innerUnmounted = false;
+    const container = document.createElement('div');
+    let innerUnmounted = false;
 
     class Component extends React.Component {
       render() {
@@ -539,7 +539,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<Component />);
     instance.setState({bogus: true});
 
     if (__DEV__) {
@@ -661,7 +661,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var component = ReactTestUtils.renderIntoDocument(<Parent />);
+    const component = ReactTestUtils.renderIntoDocument(<Parent />);
     expect(ReactDOM.findDOMNode(component).innerHTML).toBe('bar');
   });
 
@@ -672,7 +672,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var childRenders = 0;
+    let childRenders = 0;
 
     class Child extends React.Component {
       render() {
@@ -681,8 +681,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var child = <Child />;
+    const container = document.createElement('div');
+    const child = <Child />;
 
     ReactDOM.render(<Parent>{child}</Parent>, container);
     ReactDOM.render(<Parent>{child}</Parent>, container);
@@ -690,8 +690,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should pass context when re-rendered for static child', () => {
-    var parentInstance = null;
-    var childInstance = null;
+    let parentInstance = null;
+    let childInstance = null;
 
     class Parent extends React.Component {
       static childContextTypes = {
@@ -790,7 +790,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
+    const wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
 
     expect(wrapper.refs.parent.state.flag).toEqual(true);
     expect(wrapper.refs.child.context).toEqual({flag: true});
@@ -803,8 +803,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should pass context transitively', () => {
-    var childInstance = null;
-    var grandchildInstance = null;
+    let childInstance = null;
+    let grandchildInstance = null;
 
     class Parent extends React.Component {
       static childContextTypes = {
@@ -864,8 +864,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should pass context when re-rendered', () => {
-    var parentInstance = null;
-    var childInstance = null;
+    let parentInstance = null;
+    let childInstance = null;
 
     class Parent extends React.Component {
       static childContextTypes = {
@@ -885,7 +885,7 @@ describe('ReactCompositeComponent', () => {
       }
 
       render() {
-        var output = <Child />;
+        let output = <Child />;
         if (!this.state.flag) {
           output = <span>Child</span>;
         }
@@ -968,7 +968,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var div = document.createElement('div');
+    const div = document.createElement('div');
     ReactDOM.render(<Parent cntxt="noise" />, div);
     expect(div.children[0].innerHTML).toBe('noise');
     div.children[0].innerHTML = 'aliens';
@@ -981,8 +981,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should trigger componentWillReceiveProps for context changes', () => {
-    var contextChanges = 0;
-    var propChanges = 0;
+    let contextChanges = 0;
+    let propChanges = 0;
 
     class GrandChild extends React.Component {
       static contextTypes = {
@@ -1066,9 +1066,9 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var div = document.createElement('div');
+    const div = document.createElement('div');
 
-    var parentInstance = null;
+    let parentInstance = null;
     ReactDOM.render(
       <Parent ref={inst => (parentInstance = inst)}>
         <ChildWithoutContext>
@@ -1121,7 +1121,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('only renders once if updated in componentWillReceiveProps', () => {
-    var renders = 0;
+    let renders = 0;
 
     class Component extends React.Component {
       state = {updated: false};
@@ -1139,8 +1139,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(<Component update={0} />, container);
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(<Component update={0} />, container);
     expect(renders).toBe(1);
     expect(instance.state.updated).toBe(false);
     ReactDOM.render(<Component update={1} />, container);
@@ -1149,7 +1149,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('only renders once if updated in componentWillReceiveProps when batching', () => {
-    var renders = 0;
+    let renders = 0;
 
     class Component extends React.Component {
       state = {updated: false};
@@ -1167,8 +1167,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(<Component update={0} />, container);
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(<Component update={0} />, container);
     expect(renders).toBe(1);
     expect(instance.state.updated).toBe(false);
     ReactDOM.unstable_batchedUpdates(() => {
@@ -1217,8 +1217,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var comp = ReactDOM.render(<Component flipped={false} />, container);
+    const container = document.createElement('div');
+    const comp = ReactDOM.render(<Component flipped={false} />, container);
     expect(ReactDOM.findDOMNode(comp.refs.static0).textContent).toBe('A');
     expect(ReactDOM.findDOMNode(comp.refs.static1).textContent).toBe('B');
 
@@ -1230,8 +1230,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should allow access to findDOMNode in componentWillUnmount', () => {
-    var a = null;
-    var b = null;
+    let a = null;
+    let b = null;
 
     class Component extends React.Component {
       componentDidMount() {
@@ -1249,7 +1249,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     expect(a).toBe(container.firstChild);
     ReactDOM.render(<Component />, container);
     ReactDOM.unmountComponentAtNode(container);
@@ -1283,7 +1283,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var div = document.createElement('div');
+    const div = document.createElement('div');
     ReactDOM.render(
       <Parent>
         <Component />
@@ -1300,7 +1300,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var moo = ReactTestUtils.renderIntoDocument(<Moo />);
+    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
     // No longer a public API, but we can test that it works internally by
     // reaching into the updater.
     moo.updater.enqueueReplaceState(moo, {y: 2});
@@ -1309,7 +1309,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should support objects with prototypes as state', () => {
-    var NotActuallyImmutable = function(str) {
+    const NotActuallyImmutable = function(str) {
       this.str = str;
     };
     NotActuallyImmutable.prototype.amIImmutable = function() {
@@ -1325,11 +1325,11 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var moo = ReactTestUtils.renderIntoDocument(<Moo />);
+    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
     expect(moo.state.str).toBe('first');
     expect(moo.state.amIImmutable()).toBe(true);
 
-    var secondState = new NotActuallyImmutable('second');
+    const secondState = new NotActuallyImmutable('second');
     moo._replaceState(secondState);
     expect(moo.state.str).toBe('second');
     expect(moo.state.amIImmutable()).toBe(true);
@@ -1341,7 +1341,7 @@ describe('ReactCompositeComponent', () => {
     expect(moo.state.amIImmutable).toBe(undefined);
 
     // When more than one state update is enqueued, we have the same behavior
-    var fifthState = new NotActuallyImmutable('fifth');
+    const fifthState = new NotActuallyImmutable('fifth');
     ReactDOM.unstable_batchedUpdates(function() {
       moo.setState({str: 'fourth'});
       moo._replaceState(fifthState);
@@ -1349,7 +1349,7 @@ describe('ReactCompositeComponent', () => {
     expect(moo.state).toBe(fifthState);
 
     // When more than one state update is enqueued, we have the same behavior
-    var sixthState = new NotActuallyImmutable('sixth');
+    const sixthState = new NotActuallyImmutable('sixth');
     ReactDOM.unstable_batchedUpdates(function() {
       moo._replaceState(sixthState);
       moo.setState({str: 'seventh'});
@@ -1359,8 +1359,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should not warn about unmounting during unmounting', () => {
-    var container = document.createElement('div');
-    var layer = document.createElement('div');
+    const container = document.createElement('div');
+    const layer = document.createElement('div');
 
     class Component extends React.Component {
       componentDidMount() {
@@ -1394,11 +1394,11 @@ describe('ReactCompositeComponent', () => {
   it('should warn when mutated props are passed', () => {
     spyOnDev(console, 'error');
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
 
     class Foo extends React.Component {
       constructor(props) {
-        var _props = {idx: props.idx + '!'};
+        const _props = {idx: props.idx + '!'};
         super(_props);
       }
 
@@ -1423,8 +1423,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should only call componentWillUnmount once', () => {
-    var app;
-    var count = 0;
+    let app;
+    let count = 0;
 
     class App extends React.Component {
       render() {
@@ -1448,9 +1448,9 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
 
-    var setRef = ref => {
+    const setRef = ref => {
       if (ref) {
         app = ref;
       }
@@ -1464,7 +1464,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('prepares new child before unmounting old', () => {
-    var log = [];
+    const log = [];
 
     class Spy extends React.Component {
       componentWillMount() {
@@ -1488,7 +1488,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     ReactDOM.render(<Wrapper name="A" />, container);
     ReactDOM.render(<Wrapper name="B" />, container);
 
@@ -1505,7 +1505,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('respects a shallow shouldComponentUpdate implementation', () => {
-    var renderCalls = 0;
+    let renderCalls = 0;
     class PlasticWrap extends React.Component {
       constructor(props, context) {
         super(props, context);
@@ -1548,8 +1548,8 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(<PlasticWrap />, container);
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(<PlasticWrap />, container);
     expect(renderCalls).toBe(1);
 
     // Do not re-render based on props
@@ -1581,8 +1581,8 @@ describe('ReactCompositeComponent', () => {
       };
     }
 
-    var renderCalls = 0;
-    var initialSettings = getInitialState();
+    let renderCalls = 0;
+    const initialSettings = getInitialState();
 
     class Component extends React.Component {
       state = initialSettings;
@@ -1597,12 +1597,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(<Component />, container);
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(<Component />, container);
     expect(renderCalls).toBe(1);
 
     // Do not re-render if state is equal
-    var settings = {
+    const settings = {
       foo: initialSettings.foo,
       bar: initialSettings.bar,
     };

commit a442d9bc082878ccf66872b1eeed3465927801b6
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 10:08:24 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11952)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 3ae6384dbb..a707a8df6c 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -122,29 +122,21 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    spyOnDev(console, 'warn');
     const markup = ReactDOMServer.renderToString(<Parent />);
 
     // Old API based on heuristic
     let container = document.createElement('div');
     container.innerHTML = markup;
-    ReactDOM.render(<Parent />, container);
-    if (__DEV__) {
-      expect(console.warn.calls.count()).toBe(1);
-      expect(console.warn.calls.argsFor(0)[0]).toContain(
-        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
-          'will stop working in React v17. Replace the ReactDOM.render() call ' +
-          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
-      );
-      console.warn.calls.reset();
-    }
+    expect(() => ReactDOM.render(<Parent />, container)).toLowPriorityWarnDev(
+      'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
+        'will stop working in React v17. Replace the ReactDOM.render() call ' +
+        'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
+    );
+
     // New explicit API
     container = document.createElement('div');
     container.innerHTML = markup;
     ReactDOM.hydrate(<Parent />, container);
-    if (__DEV__) {
-      expect(console.warn.calls.count()).toBe(0);
-    }
   });
 
   it('should react to state changes from callbacks', () => {
@@ -234,8 +226,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn about `forceUpdate` on unmounted components', () => {
-    spyOnDev(console, 'error');
-
     const container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -251,32 +241,20 @@ describe('ReactCompositeComponent', () => {
     instance = ReactDOM.render(instance, container);
     instance.forceUpdate();
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-
     ReactDOM.unmountComponentAtNode(container);
 
-    instance.forceUpdate();
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Can only update a mounted or mounting component. This usually means ' +
-          'you called setState, replaceState, or forceUpdate on an unmounted ' +
-          'component. This is a no-op.\n\nPlease check the code for the ' +
-          'Component component.',
-      );
-    }
+    expect(() => instance.forceUpdate()).toWarnDev(
+      'Can only update a mounted or mounting component. This usually means ' +
+        'you called setState, replaceState, or forceUpdate on an unmounted ' +
+        'component. This is a no-op.\n\nPlease check the code for the ' +
+        'Component component.',
+    );
 
+    // No additional warning should be recorded
     instance.forceUpdate();
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-    }
   });
 
   it('should warn about `setState` on unmounted components', () => {
-    spyOnDev(console, 'error');
-
     const container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -300,26 +278,20 @@ describe('ReactCompositeComponent', () => {
 
     instance.setState({value: 1});
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-
     expect(renders).toBe(2);
 
     ReactDOM.unmountComponentAtNode(container);
-    instance.setState({value: 2});
 
-    expect(renders).toBe(2);
+    expect(() => {
+      instance.setState({value: 2});
+    }).toWarnDev(
+      'Can only update a mounted or mounting component. This usually means ' +
+        'you called setState, replaceState, or forceUpdate on an unmounted ' +
+        'component. This is a no-op.\n\nPlease check the code for the ' +
+        'Component component.',
+    );
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Can only update a mounted or mounting component. This usually means ' +
-          'you called setState, replaceState, or forceUpdate on an unmounted ' +
-          'component. This is a no-op.\n\nPlease check the code for the ' +
-          'Component component.',
-      );
-    }
+    expect(renders).toBe(2);
   });
 
   it('should silently allow `setState`, not call cb on unmounting components', () => {
@@ -351,32 +323,24 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when rendering a class with a render method that does not extend React.Component', () => {
-    spyOnDev(console, 'error');
     const container = document.createElement('div');
     class ClassWithRenderNotExtended {
       render() {
         return <div />;
       }
     }
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
     expect(() => {
-      ReactDOM.render(<ClassWithRenderNotExtended />, container);
-    }).toThrow(TypeError);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
+      expect(() => {
+        ReactDOM.render(<ClassWithRenderNotExtended />, container);
+      }).toWarnDev(
         'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
           "but doesn't extend React.Component. This is likely to cause errors. " +
           'Change ClassWithRenderNotExtended to extend React.Component instead.',
       );
-    }
+    }).toThrow(TypeError);
   });
 
   it('should warn about `setState` in render', () => {
-    spyOnDev(console, 'error');
-
     const container = document.createElement('div');
 
     let renderedState = -1;
@@ -395,21 +359,16 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-
-    const instance = ReactDOM.render(<Component />, container);
+    let instance;
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Cannot update during an existing state transition (such as within ' +
-          "`render` or another component's constructor). Render methods should " +
-          'be a pure function of props and state; constructor side-effects are ' +
-          'an anti-pattern, but can be moved to `componentWillMount`.',
-      );
-    }
+    expect(() => {
+      instance = ReactDOM.render(<Component />, container);
+    }).toWarnDev(
+      'Cannot update during an existing state transition (such as within ' +
+        "`render` or another component's constructor). Render methods should " +
+        'be a pure function of props and state; constructor side-effects are ' +
+        'an anti-pattern, but can be moved to `componentWillMount`.',
+    );
 
     // The setState call is queued and then executed as a second pass. This
     // behavior is undefined though so we're free to change it to suit the
@@ -424,17 +383,12 @@ describe('ReactCompositeComponent', () => {
     expect(renderedState).toBe(1);
     expect(instance2.state.value).toBe(1);
 
-    // Test deduplication
+    // Test deduplication; (no additional warnings are expected).
     ReactDOM.unmountComponentAtNode(container);
     ReactDOM.render(<Component prop={123} />, container);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-    }
   });
 
   it('should warn about `setState` in getChildContext', () => {
-    spyOnDev(console, 'error');
-
     const container = document.createElement('div');
 
     let renderPasses = 0;
@@ -455,25 +409,20 @@ describe('ReactCompositeComponent', () => {
     }
     Component.childContextTypes = {};
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-    const instance = ReactDOM.render(<Component />, container);
+    let instance;
+
+    expect(() => {
+      instance = ReactDOM.render(<Component />, container);
+    }).toWarnDev(
+      'Warning: setState(...): Cannot call setState() inside getChildContext()',
+    );
+
     expect(renderPasses).toBe(2);
     expect(instance.state.value).toBe(1);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toBe(
-        'Warning: setState(...): Cannot call setState() inside getChildContext()',
-      );
-    }
 
-    // Test deduplication
+    // Test deduplication; (no additional warnings are expected).
     ReactDOM.unmountComponentAtNode(container);
     ReactDOM.render(<Component />, container);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-    }
   });
 
   it('should cleanup even if render() fatals', () => {
@@ -487,7 +436,7 @@ describe('ReactCompositeComponent', () => {
 
     expect(ReactCurrentOwner.current).toBe(null);
 
-    expect(function() {
+    expect(() => {
       instance = ReactTestUtils.renderIntoDocument(instance);
     }).toThrow();
 
@@ -525,8 +474,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when shouldComponentUpdate() returns undefined', () => {
-    spyOnDev(console, 'error');
-
     class Component extends React.Component {
       state = {bogus: false};
 
@@ -540,20 +487,14 @@ describe('ReactCompositeComponent', () => {
     }
 
     const instance = ReactTestUtils.renderIntoDocument(<Component />);
-    instance.setState({bogus: true});
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toBe(
-        'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
-          'boolean value. Make sure to return true or false.',
-      );
-    }
+    expect(() => instance.setState({bogus: true})).toWarnDev(
+      'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
+        'boolean value. Make sure to return true or false.',
+    );
   });
 
   it('should warn when componentDidUnmount method is defined', () => {
-    spyOnDev(console, 'error');
-
     class Component extends React.Component {
       componentDidUnmount = () => {};
 
@@ -562,21 +503,14 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<Component />);
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toBe(
-        'Warning: Component has a method called ' +
-          'componentDidUnmount(). But there is no such lifecycle method. ' +
-          'Did you mean componentWillUnmount()?',
-      );
-    }
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+      'Warning: Component has a method called ' +
+        'componentDidUnmount(). But there is no such lifecycle method. ' +
+        'Did you mean componentWillUnmount()?',
+    );
   });
 
   it('should warn when componentDidReceiveProps method is defined', () => {
-    spyOnDev(console, 'error');
-
     class Component extends React.Component {
       componentDidReceiveProps = () => {};
 
@@ -585,23 +519,16 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<Component />);
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toBe(
-        'Warning: Component has a method called ' +
-          'componentDidReceiveProps(). But there is no such lifecycle method. ' +
-          'If you meant to update the state in response to changing props, ' +
-          'use componentWillReceiveProps(). If you meant to fetch data or ' +
-          'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
-      );
-    }
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+      'Warning: Component has a method called ' +
+        'componentDidReceiveProps(). But there is no such lifecycle method. ' +
+        'If you meant to update the state in response to changing props, ' +
+        'use componentWillReceiveProps(). If you meant to fetch data or ' +
+        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+    );
   });
 
   it('should warn when defaultProps was defined as an instance property', () => {
-    spyOnDev(console, 'error');
-
     class Component extends React.Component {
       constructor(props) {
         super(props);
@@ -613,15 +540,10 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<Component />);
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toBe(
-        'Warning: Setting defaultProps as an instance property on Component is not supported ' +
-          'and will be ignored. Instead, define defaultProps as a static property on Component.',
-      );
-    }
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+        'and will be ignored. Instead, define defaultProps as a static property on Component.',
+    );
   });
 
   it('should pass context to children when not owner', () => {
@@ -1093,8 +1015,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should disallow nested render calls', () => {
-    spyOnDev(console, 'error');
-
     class Inner extends React.Component {
       render() {
         return <div />;
@@ -1108,16 +1028,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<Outer />);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toMatch(
-        'Render methods should be a pure function of props and state; ' +
-          'triggering nested component updates from render is not allowed. If ' +
-          'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
-          'render method of Outer.',
-      );
-    }
+    expect(() => ReactTestUtils.renderIntoDocument(<Outer />)).toWarnDev(
+      'Render methods should be a pure function of props and state; ' +
+        'triggering nested component updates from render is not allowed. If ' +
+        'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
+        'render method of Outer.',
+    );
   });
 
   it('only renders once if updated in componentWillReceiveProps', () => {
@@ -1392,8 +1308,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when mutated props are passed', () => {
-    spyOnDev(console, 'error');
-
     const container = document.createElement('div');
 
     class Foo extends React.Component {
@@ -1407,19 +1321,10 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(0);
-    }
-
-    ReactDOM.render(<Foo idx="qwe" />, container);
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Foo(...): When calling super() in `Foo`, make sure to pass ' +
-          "up the same props that your component's constructor was passed.",
-      );
-    }
+    expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toWarnDev(
+      'Foo(...): When calling super() in `Foo`, make sure to pass ' +
+        "up the same props that your component's constructor was passed.",
+    );
   });
 
   it('should only call componentWillUnmount once', () => {
@@ -1456,7 +1361,7 @@ describe('ReactCompositeComponent', () => {
       }
     };
 
-    expect(function() {
+    expect(() => {
       ReactDOM.render(<App ref={setRef} stage={1} />, container);
       ReactDOM.render(<App ref={setRef} stage={2} />, container);
     }).toThrow();
@@ -1702,7 +1607,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should return a meaningful warning when constructor is returned', () => {
-    spyOnDev(console, 'error');
     class RenderTextInvalidConstructor extends React.Component {
       constructor(props) {
         super(props);
@@ -1714,33 +1618,26 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(function() {
-      ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
-    }).toThrow();
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.mostRecent().args[0]).toBe(
+    expect(() => {
+      expect(() => {
+        ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
+      }).toWarnDev(
         'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
           'did you accidentally return an object from the constructor?',
       );
-    }
+    }).toThrow();
   });
 
   it('should return error if render is not defined', () => {
-    spyOnDev(console, 'error');
     class RenderTestUndefinedRender extends React.Component {}
 
-    expect(function() {
-      ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
-    }).toThrow();
-
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.mostRecent().args[0]).toBe(
+    expect(() => {
+      expect(() => {
+        ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
+      }).toWarnDev(
         'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
           'component instance: you may have forgotten to define `render`.',
       );
-    }
+    }).toThrow();
   });
 });

commit e6e393b9c5221bfb1a5ddcc7221c42e96ab3baca
Author: Neil Kistner <neil.kistner@gmail.com>
Date:   Tue Jan 9 10:24:49 2018 -0600

    Add warning in server renderer if class doesn't extend React.Component (#11993)
    
    * Add warning in server renderer if class doesn't extend React.Component
    
    In dev mode, while server rendering, a warning will be thrown if there is a class that doesn't extend React.Component.
    
    * Use `.toWarnDev` matcher and deduplicate warnings
    
    * Deduplicate client-side warning if class doesn't extend React.Component
    
    * Default componentName to Unknown if null

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index a707a8df6c..330b613644 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -338,6 +338,11 @@ describe('ReactCompositeComponent', () => {
           'Change ClassWithRenderNotExtended to extend React.Component instead.',
       );
     }).toThrow(TypeError);
+
+    // Test deduplication
+    expect(() => {
+      ReactDOM.render(<ClassWithRenderNotExtended />, container);
+    }).toThrow(TypeError);
   });
 
   it('should warn about `setState` in render', () => {

commit 97e2911508a2a7af6f50cf87ae503abe39842bef
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri Jan 19 09:36:46 2018 -0800

    RFC 6: Deprecate unsafe lifecycles (#12028)
    
    * Added unsafe_* lifecycles and deprecation warnings
    If the old lifecycle hooks (componentWillMount, componentWillUpdate, componentWillReceiveProps) are detected, these methods will be called and a deprecation warning will be logged. (In other words, we do not check for both the presence of the old and new lifecycles.) This commit is expected to fail tests.
    
    * Ran lifecycle hook codemod over project
    This should handle the bulk of the updates. I will manually update TypeScript and CoffeeScript tests with another commit.
    The actual command run with this commit was: jscodeshift --parser=flow -t ../react-codemod/transforms/rename-unsafe-lifecycles.js ./packages/**/src/**/*.js
    
    * Manually migrated CoffeeScript and TypeScript tests
    
    * Added inline note to createReactClassIntegration-test
    Explaining why lifecycles hooks have not been renamed in this test.
    
    * Udated NativeMethodsMixin with new lifecycle hooks
    
    * Added static getDerivedStateFromProps to ReactPartialRenderer
    Also added a new set of tests focused on server side lifecycle hooks.
    
    * Added getDerivedStateFromProps to shallow renderer
    Also added warnings for several cases involving getDerivedStateFromProps() as well as the deprecated lifecycles.
    Also added tests for the above.
    
    * Dedupe and DEV-only deprecation warning in server renderer
    
    * Renamed unsafe_* prefix to UNSAFE_* to be more noticeable
    
    * Added getDerivedStateFromProps to ReactFiberClassComponent
    Also updated class component and lifecyle tests to cover the added functionality.
    
    * Warn about UNSAFE_componentWillRecieveProps misspelling
    
    * Added tests to createReactClassIntegration for new lifecycles
    
    * Added warning for stateless functional components with gDSFP
    
    * Added createReactClass test for static gDSFP
    
    * Moved lifecycle deprecation warnings behind (disabled) feature flag
    
    Updated tests accordingly, by temporarily splitting tests that were specific to this feature-flag into their own, internal tests. This was the only way I knew of to interact with the feature flag without breaking our build/dist tests.
    
    * Tidying up
    
    * Tweaked warning message wording slightly
    Replaced 'You may may have returned undefined.' with 'You may have returned undefined.'
    
    * Replaced truthy partialState checks with != null
    
    * Call getDerivedStateFromProps via .call(null) to prevent type access
    
    * Move shallow-renderer didWarn* maps off the instance
    
    * Only call getDerivedStateFromProps if props instance has changed
    
    * Avoid creating new state object if not necessary
    
    * Inject state as a param to callGetDerivedStateFromProps
    This value will be either workInProgress.memoizedState (for updates) or instance.state (for initialization).
    
    * Explicitly warn about uninitialized state before calling getDerivedStateFromProps.
    And added some new tests for this change.
    
    Also:
    * Improved a couple of falsy null/undefined checks to more explicitly check for null or undefined.
    * Made some small tweaks to ReactFiberClassComponent WRT when and how it reads instance.state and sets to null.
    
    * Improved wording for deprecation lifecycle warnings
    
    * Fix state-regression for module-pattern components
    Also add support for new static getDerivedStateFromProps method

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 330b613644..54649cc28f 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -850,7 +850,7 @@ describe('ReactCompositeComponent', () => {
         foo: PropTypes.string.isRequired,
       };
 
-      componentWillReceiveProps(nextProps, nextContext) {
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
         expect('foo' in nextContext).toBe(true);
       }
 
@@ -865,7 +865,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     class Intermediary extends React.Component {
-      componentWillReceiveProps(nextProps, nextContext) {
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
         expect('foo' in nextContext).toBe(false);
       }
 
@@ -916,7 +916,7 @@ describe('ReactCompositeComponent', () => {
         foo: PropTypes.string.isRequired,
       };
 
-      componentWillReceiveProps(nextProps, nextContext) {
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
         expect('foo' in nextContext).toBe(true);
 
         if (nextProps !== this.props) {
@@ -938,7 +938,7 @@ describe('ReactCompositeComponent', () => {
         foo: PropTypes.string.isRequired,
       };
 
-      componentWillReceiveProps(nextProps, nextContext) {
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
         expect('foo' in nextContext).toBe(true);
 
         if (nextProps !== this.props) {
@@ -956,7 +956,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     class ChildWithoutContext extends React.Component {
-      componentWillReceiveProps(nextProps, nextContext) {
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
         expect('foo' in nextContext).toBe(false);
 
         if (nextProps !== this.props) {
@@ -1047,7 +1047,7 @@ describe('ReactCompositeComponent', () => {
     class Component extends React.Component {
       state = {updated: false};
 
-      componentWillReceiveProps(props) {
+      UNSAFE_componentWillReceiveProps(props) {
         expect(props.update).toBe(1);
         expect(renders).toBe(1);
         this.setState({updated: true});
@@ -1075,7 +1075,7 @@ describe('ReactCompositeComponent', () => {
     class Component extends React.Component {
       state = {updated: false};
 
-      componentWillReceiveProps(props) {
+      UNSAFE_componentWillReceiveProps(props) {
         expect(props.update).toBe(1);
         expect(renders).toBe(1);
         this.setState({updated: true});
@@ -1377,7 +1377,7 @@ describe('ReactCompositeComponent', () => {
     const log = [];
 
     class Spy extends React.Component {
-      componentWillMount() {
+      UNSAFE_componentWillMount() {
         log.push(this.props.name + ' componentWillMount');
       }
       render() {
@@ -1556,7 +1556,7 @@ describe('ReactCompositeComponent', () => {
         };
       }
 
-      componentWillMount() {
+      UNSAFE_componentWillMount() {
         this.setState(
           {hasUpdatedState: true},
           () => (stateSuccessfullyUpdated = this.state.hasUpdatedState),
@@ -1586,7 +1586,7 @@ describe('ReactCompositeComponent', () => {
         };
       }
 
-      componentWillMount() {
+      UNSAFE_componentWillMount() {
         instance = this;
       }
 

commit 5855e9f2158b31d945f3fcc5bc582389dbecc88e
Author: Sophie Alpert <git@sophiebits.com>
Date:   Thu Mar 29 08:21:22 2018 -0700

    Improve warning message for setState-on-unmounted (#12347)
    
    This is one of the most common warnings people see, and I don't think the old text is especially clear. Improve it.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 54649cc28f..10f63f6ac1 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -244,10 +244,11 @@ describe('ReactCompositeComponent', () => {
     ReactDOM.unmountComponentAtNode(container);
 
     expect(() => instance.forceUpdate()).toWarnDev(
-      'Can only update a mounted or mounting component. This usually means ' +
-        'you called setState, replaceState, or forceUpdate on an unmounted ' +
-        'component. This is a no-op.\n\nPlease check the code for the ' +
-        'Component component.',
+      "Warning: Can't call setState (or forceUpdate) on an unmounted " +
+        'component. This is a no-op, but it indicates a memory leak in your ' +
+        'application. To fix, cancel all subscriptions and asynchronous ' +
+        'tasks in the componentWillUnmount method.\n' +
+        '    in Component (at **)',
     );
 
     // No additional warning should be recorded
@@ -269,10 +270,15 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    let instance = <Component />;
-    expect(instance.setState).not.toBeDefined();
-
-    instance = ReactDOM.render(instance, container);
+    let instance;
+    ReactDOM.render(
+      <div>
+        <span>
+          <Component ref={c => (instance = c || instance)} />
+        </span>
+      </div>,
+      container,
+    );
 
     expect(renders).toBe(1);
 
@@ -280,15 +286,17 @@ describe('ReactCompositeComponent', () => {
 
     expect(renders).toBe(2);
 
-    ReactDOM.unmountComponentAtNode(container);
+    ReactDOM.render(<div />, container);
 
     expect(() => {
       instance.setState({value: 2});
     }).toWarnDev(
-      'Can only update a mounted or mounting component. This usually means ' +
-        'you called setState, replaceState, or forceUpdate on an unmounted ' +
-        'component. This is a no-op.\n\nPlease check the code for the ' +
-        'Component component.',
+      "Warning: Can't call setState (or forceUpdate) on an unmounted " +
+        'component. This is a no-op, but it indicates a memory leak in your ' +
+        'application. To fix, cancel all subscriptions and asynchronous ' +
+        'tasks in the componentWillUnmount method.\n' +
+        '    in Component (at **)\n' +
+        '    in span',
     );
 
     expect(renders).toBe(2);

commit 36c29393720157a3966ce1d50449a33a35bdf14c
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Apr 3 21:22:44 2018 +0100

    Improve not-yet-mounted setState warning (#12531)
    
    * Tweak not-yet-mounted setState warning
    
    * Add \n\n

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 10f63f6ac1..4b8b996467 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -225,6 +225,58 @@ describe('ReactCompositeComponent', () => {
     expect(inputProps.prop).not.toBeDefined();
   });
 
+  it('should warn about `forceUpdate` on not-yet-mounted components', () => {
+    class MyComponent extends React.Component {
+      constructor(props) {
+        super(props);
+        this.forceUpdate();
+      }
+      render() {
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
+      "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
+        'This is a no-op, but it might indicate a bug in your application.\n\n' +
+        'To fix, assign the initial state in the MyComponent constructor. ' +
+        'If the state needs to reflect an external data source, ' +
+        'you may also add a componentDidMount lifecycle hook to MyComponent ' +
+        'and call setState there if the external data has changed.',
+    );
+
+    // No additional warning should be recorded
+    const container2 = document.createElement('div');
+    ReactDOM.render(<MyComponent />, container2);
+  });
+
+  it('should warn about `setState` on not-yet-mounted components', () => {
+    class MyComponent extends React.Component {
+      constructor(props) {
+        super(props);
+        this.setState();
+      }
+      render() {
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
+      "Warning: Can't call setState on a component that is not yet mounted. " +
+        'This is a no-op, but it might indicate a bug in your application.\n\n' +
+        'To fix, assign the initial state in the MyComponent constructor. ' +
+        'If the state needs to reflect an external data source, ' +
+        'you may also add a componentDidMount lifecycle hook to MyComponent ' +
+        'and call setState there if the external data has changed.',
+    );
+
+    // No additional warning should be recorded
+    const container2 = document.createElement('div');
+    ReactDOM.render(<MyComponent />, container2);
+  });
+
   it('should warn about `forceUpdate` on unmounted components', () => {
     const container = document.createElement('div');
     document.body.appendChild(container);

commit a2cc3c38e214c16ff6805312d4353c1faab9ff95
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Apr 3 21:56:21 2018 +0100

    Follow up: make new warning less wordy (#12532)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 4b8b996467..216afa8550 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -239,11 +239,9 @@ describe('ReactCompositeComponent', () => {
     const container = document.createElement('div');
     expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
       "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
-        'This is a no-op, but it might indicate a bug in your application.\n\n' +
-        'To fix, assign the initial state in the MyComponent constructor. ' +
-        'If the state needs to reflect an external data source, ' +
-        'you may also add a componentDidMount lifecycle hook to MyComponent ' +
-        'and call setState there if the external data has changed.',
+        'This is a no-op, but it might indicate a bug in your application. ' +
+        'Instead, assign to `this.state` directly or define a `state = {};` ' +
+        'class property with the desired state in the MyComponent component.',
     );
 
     // No additional warning should be recorded
@@ -265,11 +263,9 @@ describe('ReactCompositeComponent', () => {
     const container = document.createElement('div');
     expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
       "Warning: Can't call setState on a component that is not yet mounted. " +
-        'This is a no-op, but it might indicate a bug in your application.\n\n' +
-        'To fix, assign the initial state in the MyComponent constructor. ' +
-        'If the state needs to reflect an external data source, ' +
-        'you may also add a componentDidMount lifecycle hook to MyComponent ' +
-        'and call setState there if the external data has changed.',
+        'This is a no-op, but it might indicate a bug in your application. ' +
+        'Instead, assign to `this.state` directly or define a `state = {};` ' +
+        'class property with the desired state in the MyComponent component.',
     );
 
     // No additional warning should be recorded

commit 036ae3c6e2f056adffc31dfb78d1b6f0c63272f0
Author: Philipp Spie <hello@philippspiess.com>
Date:   Wed Jun 13 13:41:23 2018 +0200

    Use native event dispatching instead of Simulate or SimulateNative (#13023)
    
    * Use native event dispatching instead of Simulate or SimulateNative
    
    In #12629 @gaearon suggested that it would be better to drop usage of
    `ReactTestUtils.Simulate` and `ReactTestUtils.SimulateNative`. In this
    PR Im attempting at removing it from a lot of places with only a few
    leftovers.
    
    Those leftovers can be categorized into three groups:
    
    1. Anything that tests that `SimulateNative` throws. This is a property
       that native event dispatching doesnt have so I cant convert that
       easily. Affected test suites: `EventPluginHub-test`,
       `ReactBrowserEventEmitter-test`.
    2. Anything that tests `ReactTestUtils` directly. Affected test suites:
       `ReactBrowserEventEmitter-test` (this file has one test that reads
        "should have mouse enter simulated by test utils"),
        `ReactTestUtils-test`.
    3. Anything that dispatches a `change` event. The reason here goes a bit
       deeper and is rooted in the way we shim onChange. Usually when using
       native event dispatching, you would set the nodes `.value` and then
       dispatch the event. However inside [`inputValueTracking.js`][] we
       install a setter on the nodes `.value` that will ignore the next
       `change` event (I found [this][near-perfect-oninput-shim] article
       from Sophie that explains that this is to avoid onChange when
       updating the value via JavaScript).
    
    All remaining usages of `Simulate` or `SimulateNative` can be avoided
    by mounting the containers inside the `document` and dispatching native
    events.
    
    Here some remarks:
    
    1. Im using `Element#click()` instead of `dispatchEvent`. In the jsdom
       changelog I read that `click()` now properly sets the correct values
       (you can also verify it does the same thing by looking at the
       [source][jsdom-source]).
    2. I had to update jsdom in order to get `TouchEvent` constructors
       working (and while doing so also updated jest). There was one
       unexpected surprise: `ReactScheduler-test` was relying on not having
       `window.performance` available. Ive recreated the previous
       environment by deleting this property from the global object.
    3. I was a bit confused that `ReactTestUtils.renderIntoDocument()` does
       not render into the document 
    
    [`inputValueTracking.js`]: https://github.com/facebook/react/blob/392530104c00c25074ce38e1f7e1dd363018c7ce/packages/react-dom/src/client/inputValueTracking.js#L79
    [near-perfect-oninput-shim]: https://sophiebits.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html
    [jsdom-source]: https://github.com/jsdom/jsdom/blob/45b77f5d21cef74cad278d089937d8462c29acce/lib/jsdom/living/nodes/HTMLElement-impl.js#L43-L76
    
    * Make sure contains are unlinked from the document even if the test fails
    
    * Remove unnecessary findDOMNode calls

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 216afa8550..d614d27dd3 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -140,23 +140,28 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should react to state changes from callbacks', () => {
-    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
-    let el = ReactDOM.findDOMNode(instance);
-    expect(el.tagName).toBe('A');
-
-    ReactTestUtils.Simulate.click(el);
-    el = ReactDOM.findDOMNode(instance);
-    expect(el.tagName).toBe('B');
+    const container = document.createElement('div');
+    document.body.appendChild(container);
+    try {
+      const instance = ReactDOM.render(<MorphingComponent />, container);
+      let el = ReactDOM.findDOMNode(instance);
+      expect(el.tagName).toBe('A');
+      el.click();
+      el = ReactDOM.findDOMNode(instance);
+      expect(el.tagName).toBe('B');
+    } finally {
+      document.body.removeChild(container);
+    }
   });
 
   it('should rewire refs when rendering to different child types', () => {
     const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
 
-    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('A');
+    expect(instance.refs.x.tagName).toBe('A');
     instance._toggleActivatedState();
-    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('B');
+    expect(instance.refs.x.tagName).toBe('B');
     instance._toggleActivatedState();
-    expect(ReactDOM.findDOMNode(instance.refs.x).tagName).toBe('A');
+    expect(instance.refs.x.tagName).toBe('A');
   });
 
   it('should not cache old DOM nodes when switching constructors', () => {

commit aeda7b745d9c080150704feb20ea576238a1b9a1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jun 19 16:03:45 2018 +0100

    Remove fbjs dependency (#13069)
    
    * Inline fbjs/lib/invariant
    
    * Inline fbjs/lib/warning
    
    * Remove remaining usage of fbjs in packages/*.js
    
    * Fix lint
    
    * Remove fbjs from dependencies
    
    * Protect against accidental fbjs imports
    
    * Fix broken test mocks
    
    * Allow transitive deps on fbjs/ for UMD bundles
    
    * Remove fbjs from release script

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index d614d27dd3..182564111f 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -17,10 +17,50 @@ let ReactDOMServer;
 let ReactCurrentOwner;
 let ReactTestUtils;
 let PropTypes;
-let shallowEqual;
-let shallowCompare;
 
 describe('ReactCompositeComponent', () => {
+  const hasOwnProperty = Object.prototype.hasOwnProperty;
+
+  /**
+   * Performs equality by iterating through keys on an object and returning false
+   * when any key has values which are not strictly equal between the arguments.
+   * Returns true when the values of all keys are strictly equal.
+   */
+  function shallowEqual(objA: mixed, objB: mixed): boolean {
+    if (Object.is(objA, objB)) {
+      return true;
+    }
+    if (
+      typeof objA !== 'object' ||
+      objA === null ||
+      typeof objB !== 'object' ||
+      objB === null
+    ) {
+      return false;
+    }
+    const keysA = Object.keys(objA);
+    const keysB = Object.keys(objB);
+    if (keysA.length !== keysB.length) {
+      return false;
+    }
+    for (let i = 0; i < keysA.length; i++) {
+      if (
+        !hasOwnProperty.call(objB, keysA[i]) ||
+        !Object.is(objA[keysA[i]], objB[keysA[i]])
+      ) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  function shallowCompare(instance, nextProps, nextState) {
+    return (
+      !shallowEqual(instance.props, nextProps) ||
+      !shallowEqual(instance.state, nextState)
+    );
+  }
+
   beforeEach(() => {
     jest.resetModules();
     React = require('react');
@@ -30,14 +70,6 @@ describe('ReactCompositeComponent', () => {
       .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
     ReactTestUtils = require('react-dom/test-utils');
     PropTypes = require('prop-types');
-    shallowEqual = require('fbjs/lib/shallowEqual');
-
-    shallowCompare = function(instance, nextProps, nextState) {
-      return (
-        !shallowEqual(instance.props, nextProps) ||
-        !shallowEqual(instance.state, nextState)
-      );
-    };
 
     MorphingComponent = class extends React.Component {
       state = {activated: false};

commit 467d1391016dd2df8e1946aa33c6d6e1219c9dbb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 20:20:18 2018 +0100

    Enforce presence or absence of component stack in tests (#13215)
    
    * Enforce presence or absence of stack in tests
    
    * Rename expectNoStack to withoutStack
    
    * Fix lint
    
    * Add some tests for toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 182564111f..c0b30b032e 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -163,6 +163,7 @@ describe('ReactCompositeComponent', () => {
       'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
         'will stop working in React v17. Replace the ReactDOM.render() call ' +
         'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
+      {withoutStack: true},
     );
 
     // New explicit API
@@ -279,6 +280,7 @@ describe('ReactCompositeComponent', () => {
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
+      {withoutStack: true},
     );
 
     // No additional warning should be recorded
@@ -303,6 +305,7 @@ describe('ReactCompositeComponent', () => {
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
+      {withoutStack: true},
     );
 
     // No additional warning should be recorded
@@ -466,6 +469,7 @@ describe('ReactCompositeComponent', () => {
         "`render` or another component's constructor). Render methods should " +
         'be a pure function of props and state; constructor side-effects are ' +
         'an anti-pattern, but can be moved to `componentWillMount`.',
+      {withoutStack: true},
     );
 
     // The setState call is queued and then executed as a second pass. This
@@ -513,6 +517,7 @@ describe('ReactCompositeComponent', () => {
       instance = ReactDOM.render(<Component />, container);
     }).toWarnDev(
       'Warning: setState(...): Cannot call setState() inside getChildContext()',
+      {withoutStack: true},
     );
 
     expect(renderPasses).toBe(2);
@@ -589,6 +594,7 @@ describe('ReactCompositeComponent', () => {
     expect(() => instance.setState({bogus: true})).toWarnDev(
       'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
         'boolean value. Make sure to return true or false.',
+      {withoutStack: true},
     );
   });
 
@@ -605,6 +611,7 @@ describe('ReactCompositeComponent', () => {
       'Warning: Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
         'Did you mean componentWillUnmount()?',
+      {withoutStack: true},
     );
   });
 
@@ -623,6 +630,7 @@ describe('ReactCompositeComponent', () => {
         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
         'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+      {withoutStack: true},
     );
   });
 
@@ -641,6 +649,7 @@ describe('ReactCompositeComponent', () => {
     expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
       'Warning: Setting defaultProps as an instance property on Component is not supported ' +
         'and will be ignored. Instead, define defaultProps as a static property on Component.',
+      {withoutStack: true},
     );
   });
 
@@ -1131,6 +1140,7 @@ describe('ReactCompositeComponent', () => {
         'triggering nested component updates from render is not allowed. If ' +
         'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
         'render method of Outer.',
+      {withoutStack: true},
     );
   });
 
@@ -1422,6 +1432,7 @@ describe('ReactCompositeComponent', () => {
     expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toWarnDev(
       'Foo(...): When calling super() in `Foo`, make sure to pass ' +
         "up the same props that your component's constructor was passed.",
+      {withoutStack: true},
     );
   });
 

commit 6db080154b8a24a1af5385630e41dc814ede037b
Author: Ideveloper <zx6658@naver.com>
Date:   Thu Aug 2 10:11:17 2018 +0900

    Remove irrelevant suggestion of a legacy method from a warning (#13169)
    
    * Edit warn message what use deprecated lifecycle method
    
    * delete setState warn message about prescriptive and deprecated life cycle
    
    * fix lint
    
    * Prettier
    
    * Formatting

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index c0b30b032e..6e1320dd7c 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -466,9 +466,7 @@ describe('ReactCompositeComponent', () => {
       instance = ReactDOM.render(<Component />, container);
     }).toWarnDev(
       'Cannot update during an existing state transition (such as within ' +
-        "`render` or another component's constructor). Render methods should " +
-        'be a pure function of props and state; constructor side-effects are ' +
-        'an anti-pattern, but can be moved to `componentWillMount`.',
+        '`render`). Render methods should be a pure function of props and state.',
       {withoutStack: true},
     );
 

commit e106b8c44f9a81058f250c7ee37b61ae0094455e
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Aug 21 07:43:02 2018 -0700

    Warn about unsafe toWarnDev() nesting in tests (#12457)
    
    * Add lint run to warn about improperly nested toWarnDev matchers
    * Updated tests to avoid invalid nesting

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 6e1320dd7c..fc19cefedc 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -428,12 +428,13 @@ describe('ReactCompositeComponent', () => {
     expect(() => {
       expect(() => {
         ReactDOM.render(<ClassWithRenderNotExtended />, container);
-      }).toWarnDev(
-        'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
-          "but doesn't extend React.Component. This is likely to cause errors. " +
-          'Change ClassWithRenderNotExtended to extend React.Component instead.',
-      );
-    }).toThrow(TypeError);
+      }).toThrow(TypeError);
+    }).toWarnDev(
+      'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+        "but doesn't extend React.Component. This is likely to cause errors. " +
+        'Change ClassWithRenderNotExtended to extend React.Component instead.',
+      {withoutStack: true},
+    );
 
     // Test deduplication
     expect(() => {
@@ -1728,11 +1729,18 @@ describe('ReactCompositeComponent', () => {
     expect(() => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
-      }).toWarnDev(
+      }).toThrow();
+    }).toWarnDev(
+      [
+        // Expect two errors because invokeGuardedCallback will dispatch an error event,
+        // Causing the warning to be logged again.
         'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
           'did you accidentally return an object from the constructor?',
-      );
-    }).toThrow();
+        'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+          'did you accidentally return an object from the constructor?',
+      ],
+      {withoutStack: true},
+    );
   });
 
   it('should return error if render is not defined', () => {
@@ -1741,10 +1749,17 @@ describe('ReactCompositeComponent', () => {
     expect(() => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
-      }).toWarnDev(
+      }).toThrow();
+    }).toWarnDev(
+      [
+        // Expect two errors because invokeGuardedCallback will dispatch an error event,
+        // Causing the warning to be logged again.
         'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
           'component instance: you may have forgotten to define `render`.',
-      );
-    }).toThrow();
+        'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+          'component instance: you may have forgotten to define `render`.',
+      ],
+      {withoutStack: true},
+    );
   });
 });

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Hctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index fc19cefedc..7db34eafa7 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 4a40d7624575d030e2d2aa98b24000e59a9e4f02
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Sep 10 17:54:45 2018 +0100

    Fix a regression related to isReactComponent prototype check (#13608)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 7db34eafa7..115544170a 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1762,4 +1762,18 @@ describe('ReactCompositeComponent', () => {
       {withoutStack: true},
     );
   });
+
+  // Regression test for accidental breaking change
+  // https://github.com/facebook/react/issues/13580
+  it('should support classes shadowing isReactComponent', () => {
+    class Shadow extends React.Component {
+      isReactComponent() {}
+      render() {
+        return <div />;
+      }
+    }
+    const container = document.createElement('div');
+    ReactDOM.render(<Shadow />, container);
+    expect(container.firstChild.tagName).toBe('DIV');
+  });
 });

commit 9e9e3970e424e3a6d36b29d22cb7326d6c5705f8
Author: Sophie Alpert <git@sophiebits.com>
Date:   Fri Oct 5 15:32:15 2018 -0700

    Warn for Hook set-state on unmounted component

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 115544170a..43ac793cf5 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -332,7 +332,7 @@ describe('ReactCompositeComponent', () => {
     ReactDOM.unmountComponentAtNode(container);
 
     expect(() => instance.forceUpdate()).toWarnDev(
-      "Warning: Can't call setState (or forceUpdate) on an unmounted " +
+      "Warning: Can't perform a React state update on an unmounted " +
         'component. This is a no-op, but it indicates a memory leak in your ' +
         'application. To fix, cancel all subscriptions and asynchronous ' +
         'tasks in the componentWillUnmount method.\n' +
@@ -379,7 +379,7 @@ describe('ReactCompositeComponent', () => {
     expect(() => {
       instance.setState({value: 2});
     }).toWarnDev(
-      "Warning: Can't call setState (or forceUpdate) on an unmounted " +
+      "Warning: Can't perform a React state update on an unmounted " +
         'component. This is a no-op, but it indicates a memory leak in your ' +
         'application. To fix, cancel all subscriptions and asynchronous ' +
         'tasks in the componentWillUnmount method.\n' +

commit a9fdf8a32650d6238a6d9b055f3ac68e88090cec
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Nov 20 16:40:01 2018 +0000

    Warn about reassigning this.props (#14277)
    
    * Warn about reassigning this.props
    
    * Improve the warning
    
    * Don't show the spammy bug warning if we suspect it's a component bug

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 43ac793cf5..de512b7ec1 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1743,6 +1743,25 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
+  it('should warn about reassigning this.props while rendering', () => {
+    class Bad extends React.Component {
+      componentDidMount() {}
+      componentDidUpdate() {}
+      render() {
+        this.props = {...this.props};
+        return null;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<Bad />, container);
+    }).toWarnDev(
+      'It looks like Bad is reassigning its own `this.props` while rendering. ' +
+        'This is not supported and can lead to confusing bugs.',
+    );
+  });
+
   it('should return error if render is not defined', () => {
     class RenderTestUndefinedRender extends React.Component {}
 

commit acd65db5bc2cd1ab19be66318f3e931054796739
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 19 12:55:27 2019 -0700

    Deprecate module pattern (factory) components (#15145)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index de512b7ec1..7766944ec6 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -118,7 +118,14 @@ describe('ReactCompositeComponent', () => {
     }
 
     const el = document.createElement('div');
-    ReactDOM.render(<Child test="test" />, el);
+    expect(() => ReactDOM.render(<Child test="test" />, el)).toWarnDev(
+      'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+        'Change Child to a class that extends React.Component instead. ' +
+        "If you can't use a class try assigning the prototype on the function as a workaround. " +
+        '`Child.prototype = React.Component.prototype`. ' +
+        "Don't use an arrow function since it cannot be called with `new` by React.",
+      {withoutStack: true},
+    );
 
     expect(el.textContent).toBe('test');
   });

commit b15bf36750ca4c4a5a09f2de76c5315ded1258d0
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 12 23:47:55 2019 +0000

    Add component stacks to (almost) all warnings (#17586)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 7766944ec6..cede35d72a 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -124,7 +124,6 @@ describe('ReactCompositeComponent', () => {
         "If you can't use a class try assigning the prototype on the function as a workaround. " +
         '`Child.prototype = React.Component.prototype`. ' +
         "Don't use an arrow function since it cannot be called with `new` by React.",
-      {withoutStack: true},
     );
 
     expect(el.textContent).toBe('test');
@@ -287,7 +286,6 @@ describe('ReactCompositeComponent', () => {
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
-      {withoutStack: true},
     );
 
     // No additional warning should be recorded
@@ -312,7 +310,6 @@ describe('ReactCompositeComponent', () => {
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
-      {withoutStack: true},
     );
 
     // No additional warning should be recorded
@@ -440,7 +437,6 @@ describe('ReactCompositeComponent', () => {
       'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
         'Change ClassWithRenderNotExtended to extend React.Component instead.',
-      {withoutStack: true},
     );
 
     // Test deduplication
@@ -475,7 +471,6 @@ describe('ReactCompositeComponent', () => {
     }).toWarnDev(
       'Cannot update during an existing state transition (such as within ' +
         '`render`). Render methods should be a pure function of props and state.',
-      {withoutStack: true},
     );
 
     // The setState call is queued and then executed as a second pass. This
@@ -523,7 +518,6 @@ describe('ReactCompositeComponent', () => {
       instance = ReactDOM.render(<Component />, container);
     }).toWarnDev(
       'Warning: setState(...): Cannot call setState() inside getChildContext()',
-      {withoutStack: true},
     );
 
     expect(renderPasses).toBe(2);
@@ -600,7 +594,6 @@ describe('ReactCompositeComponent', () => {
     expect(() => instance.setState({bogus: true})).toWarnDev(
       'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
         'boolean value. Make sure to return true or false.',
-      {withoutStack: true},
     );
   });
 
@@ -617,7 +610,6 @@ describe('ReactCompositeComponent', () => {
       'Warning: Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
         'Did you mean componentWillUnmount()?',
-      {withoutStack: true},
     );
   });
 
@@ -636,7 +628,6 @@ describe('ReactCompositeComponent', () => {
         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
         'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
-      {withoutStack: true},
     );
   });
 
@@ -655,7 +646,6 @@ describe('ReactCompositeComponent', () => {
     expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
       'Warning: Setting defaultProps as an instance property on Component is not supported ' +
         'and will be ignored. Instead, define defaultProps as a static property on Component.',
-      {withoutStack: true},
     );
   });
 
@@ -1146,7 +1136,6 @@ describe('ReactCompositeComponent', () => {
         'triggering nested component updates from render is not allowed. If ' +
         'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
         'render method of Outer.',
-      {withoutStack: true},
     );
   });
 
@@ -1438,7 +1427,6 @@ describe('ReactCompositeComponent', () => {
     expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toWarnDev(
       'Foo(...): When calling super() in `Foo`, make sure to pass ' +
         "up the same props that your component's constructor was passed.",
-      {withoutStack: true},
     );
   });
 
@@ -1737,17 +1725,14 @@ describe('ReactCompositeComponent', () => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
       }).toThrow();
-    }).toWarnDev(
-      [
-        // Expect two errors because invokeGuardedCallback will dispatch an error event,
-        // Causing the warning to be logged again.
-        'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
-          'did you accidentally return an object from the constructor?',
-        'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
-          'did you accidentally return an object from the constructor?',
-      ],
-      {withoutStack: true},
-    );
+    }).toWarnDev([
+      // Expect two errors because invokeGuardedCallback will dispatch an error event,
+      // Causing the warning to be logged again.
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+    ]);
   });
 
   it('should warn about reassigning this.props while rendering', () => {
@@ -1776,17 +1761,14 @@ describe('ReactCompositeComponent', () => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
       }).toThrow();
-    }).toWarnDev(
-      [
-        // Expect two errors because invokeGuardedCallback will dispatch an error event,
-        // Causing the warning to be logged again.
-        'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-          'component instance: you may have forgotten to define `render`.',
-        'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-          'component instance: you may have forgotten to define `render`.',
-      ],
-      {withoutStack: true},
-    );
+    }).toWarnDev([
+      // Expect two errors because invokeGuardedCallback will dispatch an error event,
+      // Causing the warning to be logged again.
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+    ]);
   });
 
   // Regression test for accidental breaking change

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index cede35d72a..5994813d69 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -118,7 +118,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     const el = document.createElement('div');
-    expect(() => ReactDOM.render(<Child test="test" />, el)).toWarnDev(
+    expect(() => ReactDOM.render(<Child test="test" />, el)).toErrorDev(
       'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
         'Change Child to a class that extends React.Component instead. ' +
         "If you can't use a class try assigning the prototype on the function as a workaround. " +
@@ -165,7 +165,7 @@ describe('ReactCompositeComponent', () => {
     // Old API based on heuristic
     let container = document.createElement('div');
     container.innerHTML = markup;
-    expect(() => ReactDOM.render(<Parent />, container)).toLowPriorityWarnDev(
+    expect(() => ReactDOM.render(<Parent />, container)).toWarnDev(
       'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
         'will stop working in React v17. Replace the ReactDOM.render() call ' +
         'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
@@ -281,7 +281,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<MyComponent />, container)).toErrorDev(
       "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
@@ -305,7 +305,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<MyComponent />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<MyComponent />, container)).toErrorDev(
       "Warning: Can't call setState on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
@@ -335,7 +335,7 @@ describe('ReactCompositeComponent', () => {
 
     ReactDOM.unmountComponentAtNode(container);
 
-    expect(() => instance.forceUpdate()).toWarnDev(
+    expect(() => instance.forceUpdate()).toErrorDev(
       "Warning: Can't perform a React state update on an unmounted " +
         'component. This is a no-op, but it indicates a memory leak in your ' +
         'application. To fix, cancel all subscriptions and asynchronous ' +
@@ -382,7 +382,7 @@ describe('ReactCompositeComponent', () => {
 
     expect(() => {
       instance.setState({value: 2});
-    }).toWarnDev(
+    }).toErrorDev(
       "Warning: Can't perform a React state update on an unmounted " +
         'component. This is a no-op, but it indicates a memory leak in your ' +
         'application. To fix, cancel all subscriptions and asynchronous ' +
@@ -433,7 +433,7 @@ describe('ReactCompositeComponent', () => {
       expect(() => {
         ReactDOM.render(<ClassWithRenderNotExtended />, container);
       }).toThrow(TypeError);
-    }).toWarnDev(
+    }).toErrorDev(
       'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
         'Change ClassWithRenderNotExtended to extend React.Component instead.',
@@ -468,7 +468,7 @@ describe('ReactCompositeComponent', () => {
 
     expect(() => {
       instance = ReactDOM.render(<Component />, container);
-    }).toWarnDev(
+    }).toErrorDev(
       'Cannot update during an existing state transition (such as within ' +
         '`render`). Render methods should be a pure function of props and state.',
     );
@@ -516,7 +516,7 @@ describe('ReactCompositeComponent', () => {
 
     expect(() => {
       instance = ReactDOM.render(<Component />, container);
-    }).toWarnDev(
+    }).toErrorDev(
       'Warning: setState(...): Cannot call setState() inside getChildContext()',
     );
 
@@ -591,7 +591,7 @@ describe('ReactCompositeComponent', () => {
 
     const instance = ReactTestUtils.renderIntoDocument(<Component />);
 
-    expect(() => instance.setState({bogus: true})).toWarnDev(
+    expect(() => instance.setState({bogus: true})).toErrorDev(
       'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
         'boolean value. Make sure to return true or false.',
     );
@@ -606,7 +606,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
       'Warning: Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
         'Did you mean componentWillUnmount()?',
@@ -622,7 +622,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
       'Warning: Component has a method called ' +
         'componentDidReceiveProps(). But there is no such lifecycle method. ' +
         'If you meant to update the state in response to changing props, ' +
@@ -643,7 +643,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toWarnDev(
+    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
       'Warning: Setting defaultProps as an instance property on Component is not supported ' +
         'and will be ignored. Instead, define defaultProps as a static property on Component.',
     );
@@ -1131,7 +1131,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactTestUtils.renderIntoDocument(<Outer />)).toWarnDev(
+    expect(() => ReactTestUtils.renderIntoDocument(<Outer />)).toErrorDev(
       'Render methods should be a pure function of props and state; ' +
         'triggering nested component updates from render is not allowed. If ' +
         'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
@@ -1424,7 +1424,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toErrorDev(
       'Foo(...): When calling super() in `Foo`, make sure to pass ' +
         "up the same props that your component's constructor was passed.",
     );
@@ -1725,7 +1725,7 @@ describe('ReactCompositeComponent', () => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
       }).toThrow();
-    }).toWarnDev([
+    }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
       // Causing the warning to be logged again.
       'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
@@ -1748,7 +1748,7 @@ describe('ReactCompositeComponent', () => {
     const container = document.createElement('div');
     expect(() => {
       ReactDOM.render(<Bad />, container);
-    }).toWarnDev(
+    }).toErrorDev(
       'It looks like Bad is reassigning its own `this.props` while rendering. ' +
         'This is not supported and can lead to confusing bugs.',
     );
@@ -1761,7 +1761,7 @@ describe('ReactCompositeComponent', () => {
       expect(() => {
         ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
       }).toThrow();
-    }).toWarnDev([
+    }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
       // Causing the warning to be logged again.
       'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +

commit b979db4e7215957f03c4221622f0b115a868439a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 13:54:11 2020 +0000

    Bump Prettier (#17811)
    
    * Bump Prettier
    
    * Reformat
    
    * Use non-deprecated option

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 5994813d69..908d418cac 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -165,7 +165,9 @@ describe('ReactCompositeComponent', () => {
     // Old API based on heuristic
     let container = document.createElement('div');
     container.innerHTML = markup;
-    expect(() => ReactDOM.render(<Parent />, container)).toWarnDev(
+    expect(() =>
+      ReactDOM.render(<Parent />, container),
+    ).toWarnDev(
       'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
         'will stop working in React v17. Replace the ReactDOM.render() call ' +
         'with ReactDOM.hydrate() if you want React to attach to the server HTML.',

commit 849e8328b596ce67720f33d73a1d57108e6de504
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Feb 27 02:14:30 2020 +0000

    Remove unnecessary warnings (#18135)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 908d418cac..49e107f877 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -493,43 +493,6 @@ describe('ReactCompositeComponent', () => {
     ReactDOM.render(<Component prop={123} />, container);
   });
 
-  it('should warn about `setState` in getChildContext', () => {
-    const container = document.createElement('div');
-
-    let renderPasses = 0;
-
-    class Component extends React.Component {
-      state = {value: 0};
-
-      getChildContext() {
-        if (this.state.value === 0) {
-          this.setState({value: 1});
-        }
-      }
-
-      render() {
-        renderPasses++;
-        return <div />;
-      }
-    }
-    Component.childContextTypes = {};
-
-    let instance;
-
-    expect(() => {
-      instance = ReactDOM.render(<Component />, container);
-    }).toErrorDev(
-      'Warning: setState(...): Cannot call setState() inside getChildContext()',
-    );
-
-    expect(renderPasses).toBe(2);
-    expect(instance.state.value).toBe(1);
-
-    // Test deduplication; (no additional warnings are expected).
-    ReactDOM.unmountComponentAtNode(container);
-    ReactDOM.render(<Component />, container);
-  });
-
   it('should cleanup even if render() fatals', () => {
     class BadComponent extends React.Component {
       render() {

commit 22cab1cbd6ad52925828643c8c6d0d4fd7890c54
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Mar 17 22:47:24 2020 +0100

    test(getComponentName): Increase test coverage (#18149)
    
    Co-authored-by: Brian Vaughn <brian.david.vaughn@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 49e107f877..3767b9aeca 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -542,7 +542,7 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should warn when shouldComponentUpdate() returns undefined', () => {
-    class Component extends React.Component {
+    class ClassComponent extends React.Component {
       state = {bogus: false};
 
       shouldComponentUpdate() {
@@ -554,10 +554,10 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<ClassComponent />);
 
     expect(() => instance.setState({bogus: true})).toErrorDev(
-      'Warning: Component.shouldComponentUpdate(): Returned undefined instead of a ' +
+      'Warning: ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
         'boolean value. Make sure to return true or false.',
     );
   });

commit fe1f79b95b5987b7179d1eaf5ff5bb9a7bc4b7b5
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Mar 18 00:07:14 2020 +0000

    Don't fire the render phase update warning for class lifecycles (#18330)
    
    * Change the warning to not say "function body"
    
    This warning is more generic and may happen with class components too.
    
    * Dedupe by the rendering component
    
    * Don't warn outside of render

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 3767b9aeca..98396fb6eb 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1749,4 +1749,114 @@ describe('ReactCompositeComponent', () => {
     ReactDOM.render(<Shadow />, container);
     expect(container.firstChild.tagName).toBe('DIV');
   });
+
+  it('should not warn on updating function component from componentWillMount', () => {
+    let _setState;
+    function A() {
+      _setState = React.useState()[1];
+      return null;
+    }
+    class B extends React.Component {
+      UNSAFE_componentWillMount() {
+        _setState({});
+      }
+      render() {
+        return null;
+      }
+    }
+    function Parent() {
+      return (
+        <div>
+          <A />
+          <B />
+        </div>
+      );
+    }
+    const container = document.createElement('div');
+    ReactDOM.render(<Parent />, container);
+  });
+
+  it('should not warn on updating function component from componentWillUpdate', () => {
+    let _setState;
+    function A() {
+      _setState = React.useState()[1];
+      return null;
+    }
+    class B extends React.Component {
+      UNSAFE_componentWillUpdate() {
+        _setState({});
+      }
+      render() {
+        return null;
+      }
+    }
+    function Parent() {
+      return (
+        <div>
+          <A />
+          <B />
+        </div>
+      );
+    }
+    const container = document.createElement('div');
+    ReactDOM.render(<Parent />, container);
+    ReactDOM.render(<Parent />, container);
+  });
+
+  it('should not warn on updating function component from componentWillReceiveProps', () => {
+    let _setState;
+    function A() {
+      _setState = React.useState()[1];
+      return null;
+    }
+    class B extends React.Component {
+      UNSAFE_componentWillReceiveProps() {
+        _setState({});
+      }
+      render() {
+        return null;
+      }
+    }
+    function Parent() {
+      return (
+        <div>
+          <A />
+          <B />
+        </div>
+      );
+    }
+    const container = document.createElement('div');
+    ReactDOM.render(<Parent />, container);
+    ReactDOM.render(<Parent />, container);
+  });
+
+  it('should warn on updating function component from render', () => {
+    let _setState;
+    function A() {
+      _setState = React.useState()[1];
+      return null;
+    }
+    class B extends React.Component {
+      render() {
+        _setState({});
+        return null;
+      }
+    }
+    function Parent() {
+      return (
+        <div>
+          <A />
+          <B />
+        </div>
+      );
+    }
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<Parent />, container);
+    }).toErrorDev(
+      'Cannot update a component (`A`) while rendering a different component (`B`)',
+    );
+    // Dedupe.
+    ReactDOM.render(<Parent />, container);
+  });
 });

commit d8d2b6e89cdff27a1ac246c6e9e030c2cc8760e3
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Apr 1 18:31:59 2020 +0100

    Disable module components dynamically for WWW (#18446)
    
    * Make disableModulePatternComponents dynamic for WWW
    
    * Run both flags and tests and respect the flag in SSR

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 98396fb6eb..73984da6c4 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -108,26 +108,53 @@ describe('ReactCompositeComponent', () => {
     };
   });
 
-  it('should support module pattern components', () => {
-    function Child({test}) {
-      return {
-        render() {
-          return <div>{test}</div>;
-        },
-      };
-    }
+  if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
+    it('should not support module pattern components', () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
 
-    const el = document.createElement('div');
-    expect(() => ReactDOM.render(<Child test="test" />, el)).toErrorDev(
-      'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-        'Change Child to a class that extends React.Component instead. ' +
-        "If you can't use a class try assigning the prototype on the function as a workaround. " +
-        '`Child.prototype = React.Component.prototype`. ' +
-        "Don't use an arrow function since it cannot be called with `new` by React.",
-    );
+      const el = document.createElement('div');
+      expect(() => {
+        expect(() => ReactDOM.render(<Child test="test" />, el)).toThrow(
+          'Objects are not valid as a React child (found: object with keys {render}).',
+        );
+      }).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
 
-    expect(el.textContent).toBe('test');
-  });
+      expect(el.textContent).toBe('');
+    });
+  } else {
+    it('should support module pattern components', () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
+
+      const el = document.createElement('div');
+      expect(() => ReactDOM.render(<Child test="test" />, el)).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
+
+      expect(el.textContent).toBe('test');
+    });
+  }
 
   it('should support rendering to different child types over time', () => {
     const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);

commit 4985bb0a80f5cbeaa61d21a7daf7da5ecff2d892
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Thu May 28 10:25:39 2020 -0700

    Rename 17 to 18 in warnings (#19031)
    
    We're not really supposed to refer to future versions by numbers.
    
    These will all slip so these numbers don't make sense anymore.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 73984da6c4..7006f51b77 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -196,7 +196,7 @@ describe('ReactCompositeComponent', () => {
       ReactDOM.render(<Parent />, container),
     ).toWarnDev(
       'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
-        'will stop working in React v17. Replace the ReactDOM.render() call ' +
+        'will stop working in React v18. Replace the ReactDOM.render() call ' +
         'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
       {withoutStack: true},
     );

commit 5890e0e692d1c39eddde0110bd0d123409f31dd3
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Thu May 13 13:18:21 2021 -0400

    Remove data-reactroot from server rendering and hydration heuristic (#20996)
    
    This was used to implicitly hydrate if you call ReactDOM.render.
    
    We've had a warning to explicitly use ReactDOM.hydrate(...) instead of
    ReactDOM.render(...). We can now remove this from the generated markup.
    (And avoid adding it to Fizz.)
    
    This is a little strange to do now since we're trying hard to make the
    root API work the same.
    
    But if we kept it, we'd need to keep it in the generated output which adds
    unnecessary bytes. It also risks people relying on it, in the Fizz world
    where as this is an opportunity to create that clean state.
    
    We could possibly only keep it in the old server rendering APIs but then
    that creates an implicit dependency between which server API and which
    client API that you use. Currently you can really mix and match either way.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 7006f51b77..1c02667d7b 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -13,7 +13,6 @@ let ChildUpdates;
 let MorphingComponent;
 let React;
 let ReactDOM;
-let ReactDOMServer;
 let ReactCurrentOwner;
 let ReactTestUtils;
 let PropTypes;
@@ -65,7 +64,6 @@ describe('ReactCompositeComponent', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
-    ReactDOMServer = require('react-dom/server');
     ReactCurrentOwner = require('react')
       .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
     ReactTestUtils = require('react-dom/test-utils');
@@ -170,43 +168,6 @@ describe('ReactCompositeComponent', () => {
     expect(el.tagName).toBe('A');
   });
 
-  it('should not thrash a server rendered layout with client side one', () => {
-    class Child extends React.Component {
-      render() {
-        return null;
-      }
-    }
-
-    class Parent extends React.Component {
-      render() {
-        return (
-          <div>
-            <Child />
-          </div>
-        );
-      }
-    }
-
-    const markup = ReactDOMServer.renderToString(<Parent />);
-
-    // Old API based on heuristic
-    let container = document.createElement('div');
-    container.innerHTML = markup;
-    expect(() =>
-      ReactDOM.render(<Parent />, container),
-    ).toWarnDev(
-      'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
-        'will stop working in React v18. Replace the ReactDOM.render() call ' +
-        'with ReactDOM.hydrate() if you want React to attach to the server HTML.',
-      {withoutStack: true},
-    );
-
-    // New explicit API
-    container = document.createElement('div');
-    container.innerHTML = markup;
-    ReactDOM.hydrate(<Parent />, container);
-  });
-
   it('should react to state changes from callbacks', () => {
     const container = document.createElement('div');
     document.body.appendChild(container);

commit 7ed0706d7ec9907e8fd19c4cf0e8625733cf2a1c
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Aug 18 21:50:02 2021 +0100

    Remove the warning for setState on unmounted components (#22114)
    
    * Remove warning for setState on unmounted components
    
    * Trigger CI

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 1c02667d7b..d4eec830da 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -307,7 +307,7 @@ describe('ReactCompositeComponent', () => {
     ReactDOM.render(<MyComponent />, container2);
   });
 
-  it('should warn about `forceUpdate` on unmounted components', () => {
+  it('should not warn about `forceUpdate` on unmounted components', () => {
     const container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -325,19 +325,11 @@ describe('ReactCompositeComponent', () => {
 
     ReactDOM.unmountComponentAtNode(container);
 
-    expect(() => instance.forceUpdate()).toErrorDev(
-      "Warning: Can't perform a React state update on an unmounted " +
-        'component. This is a no-op, but it indicates a memory leak in your ' +
-        'application. To fix, cancel all subscriptions and asynchronous ' +
-        'tasks in the componentWillUnmount method.\n' +
-        '    in Component (at **)',
-    );
-
-    // No additional warning should be recorded
+    instance.forceUpdate();
     instance.forceUpdate();
   });
 
-  it('should warn about `setState` on unmounted components', () => {
+  it('should not warn about `setState` on unmounted components', () => {
     const container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -365,22 +357,10 @@ describe('ReactCompositeComponent', () => {
     expect(renders).toBe(1);
 
     instance.setState({value: 1});
-
     expect(renders).toBe(2);
 
     ReactDOM.render(<div />, container);
-
-    expect(() => {
-      instance.setState({value: 2});
-    }).toErrorDev(
-      "Warning: Can't perform a React state update on an unmounted " +
-        'component. This is a no-op, but it indicates a memory leak in your ' +
-        'application. To fix, cancel all subscriptions and asynchronous ' +
-        'tasks in the componentWillUnmount method.\n' +
-        '    in Component (at **)\n' +
-        '    in span',
-    );
-
+    instance.setState({value: 2});
     expect(renders).toBe(2);
   });
 

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index d4eec830da..ed1e36f9ba 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6fb8133ed3aa6b23063375dd345c6e413b05f0fe
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Nov 17 01:15:57 2022 +0100

    Turn on string ref deprecation warning for everybody (not codemoddable) (#25383)
    
    ## Summary
    
    Alternate to https://github.com/facebook/react/pull/25334 without any
    prod runtime changes i.e. the proposed codemod in
    https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-string-refs-and-remove-production-mode-_owner-field
    would not work.
    
    ## How did you test this change?
    
    - [x] CI
    - [x] `yarn test` with and without `warnAboutStringRefs`

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index ed1e36f9ba..4510ebf001 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -72,6 +72,8 @@ describe('ReactCompositeComponent', () => {
     MorphingComponent = class extends React.Component {
       state = {activated: false};
 
+      xRef = React.createRef();
+
       _toggleActivatedState = () => {
         this.setState({activated: !this.state.activated});
       };
@@ -79,9 +81,9 @@ describe('ReactCompositeComponent', () => {
       render() {
         const toggleActivatedState = this._toggleActivatedState;
         return !this.state.activated ? (
-          <a ref="x" onClick={toggleActivatedState} />
+          <a ref={this.xRef} onClick={toggleActivatedState} />
         ) : (
-          <b ref="x" onClick={toggleActivatedState} />
+          <b ref={this.xRef} onClick={toggleActivatedState} />
         );
       }
     };
@@ -91,14 +93,16 @@ describe('ReactCompositeComponent', () => {
      * reallocated again.
      */
     ChildUpdates = class extends React.Component {
+      anchorRef = React.createRef();
+
       getAnchor = () => {
-        return this.refs.anch;
+        return this.anchorRef.current;
       };
 
       render() {
         const className = this.props.anchorClassOn ? 'anchorClass' : '';
         return this.props.renderAnchor ? (
-          <a ref="anch" className={className} />
+          <a ref={this.anchorRef} className={className} />
         ) : (
           <b />
         );
@@ -186,11 +190,11 @@ describe('ReactCompositeComponent', () => {
   it('should rewire refs when rendering to different child types', () => {
     const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
 
-    expect(instance.refs.x.tagName).toBe('A');
+    expect(instance.xRef.current.tagName).toBe('A');
     instance._toggleActivatedState();
-    expect(instance.refs.x.tagName).toBe('B');
+    expect(instance.xRef.current.tagName).toBe('B');
     instance._toggleActivatedState();
-    expect(instance.refs.x.tagName).toBe('A');
+    expect(instance.xRef.current.tagName).toBe('A');
   });
 
   it('should not cache old DOM nodes when switching constructors', () => {
@@ -739,10 +743,13 @@ describe('ReactCompositeComponent', () => {
     }
 
     class Wrapper extends React.Component {
+      parentRef = React.createRef();
+      childRef = React.createRef();
+
       render() {
         return (
-          <Parent ref="parent">
-            <Child ref="child" />
+          <Parent ref={this.parentRef}>
+            <Child ref={this.childRef} />
           </Parent>
         );
       }
@@ -750,14 +757,14 @@ describe('ReactCompositeComponent', () => {
 
     const wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
 
-    expect(wrapper.refs.parent.state.flag).toEqual(true);
-    expect(wrapper.refs.child.context).toEqual({flag: true});
+    expect(wrapper.parentRef.current.state.flag).toEqual(true);
+    expect(wrapper.childRef.current.context).toEqual({flag: true});
 
     // We update <Parent /> while <Child /> is still a static prop relative to this update
-    wrapper.refs.parent.setState({flag: false});
+    wrapper.parentRef.current.setState({flag: false});
 
-    expect(wrapper.refs.parent.state.flag).toEqual(false);
-    expect(wrapper.refs.child.context).toEqual({flag: false});
+    expect(wrapper.parentRef.current.state.flag).toEqual(false);
+    expect(wrapper.childRef.current.context).toEqual({flag: false});
   });
 
   it('should pass context transitively', () => {
@@ -1142,14 +1149,17 @@ describe('ReactCompositeComponent', () => {
     }
 
     class Component extends React.Component {
+      static0Ref = React.createRef();
+      static1Ref = React.createRef();
+
       render() {
         if (this.props.flipped) {
           return (
             <div>
-              <Static ref="static0" key="B">
+              <Static ref={this.static0Ref} key="B">
                 B (ignored)
               </Static>
-              <Static ref="static1" key="A">
+              <Static ref={this.static1Ref} key="A">
                 A (ignored)
               </Static>
             </div>
@@ -1157,10 +1167,10 @@ describe('ReactCompositeComponent', () => {
         } else {
           return (
             <div>
-              <Static ref="static0" key="A">
+              <Static ref={this.static0Ref} key="A">
                 A
               </Static>
-              <Static ref="static1" key="B">
+              <Static ref={this.static1Ref} key="B">
                 B
               </Static>
             </div>
@@ -1171,14 +1181,14 @@ describe('ReactCompositeComponent', () => {
 
     const container = document.createElement('div');
     const comp = ReactDOM.render(<Component flipped={false} />, container);
-    expect(ReactDOM.findDOMNode(comp.refs.static0).textContent).toBe('A');
-    expect(ReactDOM.findDOMNode(comp.refs.static1).textContent).toBe('B');
+    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('A');
+    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('B');
 
     // When flipping the order, the refs should update even though the actual
     // contents do not
     ReactDOM.render(<Component flipped={true} />, container);
-    expect(ReactDOM.findDOMNode(comp.refs.static0).textContent).toBe('B');
-    expect(ReactDOM.findDOMNode(comp.refs.static1).textContent).toBe('A');
+    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('B');
+    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('A');
   });
 
   it('should allow access to findDOMNode in componentWillUnmount', () => {
@@ -1453,10 +1463,11 @@ describe('ReactCompositeComponent', () => {
         this.state = {
           color: 'green',
         };
+        this.appleRef = React.createRef();
       }
 
       render() {
-        return <Apple color={this.state.color} ref="apple" />;
+        return <Apple color={this.state.color} ref={this.appleRef} />;
       }
     }
 
@@ -1502,15 +1513,15 @@ describe('ReactCompositeComponent', () => {
     expect(renderCalls).toBe(2);
 
     // Re-render base on state
-    instance.refs.apple.cut();
+    instance.appleRef.current.cut();
     expect(renderCalls).toBe(3);
 
     // No re-render based on state
-    instance.refs.apple.cut();
+    instance.appleRef.current.cut();
     expect(renderCalls).toBe(3);
 
     // Re-render based on state again
-    instance.refs.apple.eatSlice();
+    instance.appleRef.current.eatSlice();
     expect(renderCalls).toBe(4);
   });
 

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 4510ebf001..0595f868b1 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -64,8 +64,9 @@ describe('ReactCompositeComponent', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
-    ReactCurrentOwner = require('react')
-      .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
+    ReactCurrentOwner =
+      require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
+        .ReactCurrentOwner;
     ReactTestUtils = require('react-dom/test-utils');
     PropTypes = require('prop-types');
 
@@ -378,7 +379,7 @@ describe('ReactCompositeComponent', () => {
 
       componentWillUnmount() {
         expect(() => {
-          this.setState({value: 2}, function() {
+          this.setState({value: 2}, function () {
             cbCalled = true;
           });
         }).not.toThrow();
@@ -874,7 +875,7 @@ describe('ReactCompositeComponent', () => {
     expect(childInstance).toBeNull();
 
     expect(parentInstance.state.flag).toBe(false);
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       parentInstance.setState({flag: true});
     });
     expect(parentInstance.state.flag).toBe(true);
@@ -1271,10 +1272,10 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should support objects with prototypes as state', () => {
-    const NotActuallyImmutable = function(str) {
+    const NotActuallyImmutable = function (str) {
       this.str = str;
     };
-    NotActuallyImmutable.prototype.amIImmutable = function() {
+    NotActuallyImmutable.prototype.amIImmutable = function () {
       return true;
     };
     class Moo extends React.Component {
@@ -1304,7 +1305,7 @@ describe('ReactCompositeComponent', () => {
 
     // When more than one state update is enqueued, we have the same behavior
     const fifthState = new NotActuallyImmutable('fifth');
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       moo.setState({str: 'fourth'});
       moo._replaceState(fifthState);
     });
@@ -1312,7 +1313,7 @@ describe('ReactCompositeComponent', () => {
 
     // When more than one state update is enqueued, we have the same behavior
     const sixthState = new NotActuallyImmutable('sixth');
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       moo._replaceState(sixthState);
       moo.setState({str: 'seventh'});
     });

commit 63346148603675f5d03509969007b7937cfddff2
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 11 15:32:02 2023 -0500

    Add disableLegacyContext test gates where needed (#26371)
    
    The www builds include disableLegacyContext as a dynamic flag, so we
    should be running the tests in that mode, too. Previously we were
    overriding the flag during the test run. This strategy usually doesn't
    work because the flags get compiled out in the final build, but we
    happen to not test www in build mode, only source.
    
    To get of this hacky override, I added a test gate to every test that
    uses legacy context. When we eventually remove legacy context from the
    codebase, this should make it slightly easier to find which tests are
    affected. And removes one more hack from our hack-ridden test config.
    
    Given that sometimes www has features enabled that aren't on in other
    builds, we might want to consider testing its build artifacts in CI,
    rather than just source. That would have forced this cleanup to happen
    sooner. Currently we only test the public builds in CI.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 0595f868b1..bf91fb08dd 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -587,6 +587,7 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
+  // @gate !disableLegacyContext
   it('should pass context to children when not owner', () => {
     class Parent extends React.Component {
       render() {
@@ -652,6 +653,7 @@ describe('ReactCompositeComponent', () => {
     expect(childRenders).toBe(1);
   });
 
+  // @gate !disableLegacyContext
   it('should pass context when re-rendered for static child', () => {
     let parentInstance = null;
     let childInstance = null;
@@ -712,6 +714,7 @@ describe('ReactCompositeComponent', () => {
     expect(childInstance.context).toEqual({foo: 'bar', flag: true});
   });
 
+  // @gate !disableLegacyContext
   it('should pass context when re-rendered for static child within a composite component', () => {
     class Parent extends React.Component {
       static childContextTypes = {
@@ -768,6 +771,7 @@ describe('ReactCompositeComponent', () => {
     expect(wrapper.childRef.current.context).toEqual({flag: false});
   });
 
+  // @gate !disableLegacyContext
   it('should pass context transitively', () => {
     let childInstance = null;
     let grandchildInstance = null;
@@ -829,6 +833,7 @@ describe('ReactCompositeComponent', () => {
     expect(grandchildInstance.context).toEqual({foo: 'bar', depth: 1});
   });
 
+  // @gate !disableLegacyContext
   it('should pass context when re-rendered', () => {
     let parentInstance = null;
     let childInstance = null;
@@ -883,6 +888,7 @@ describe('ReactCompositeComponent', () => {
     expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
   });
 
+  // @gate !disableLegacyContext
   it('unmasked context propagates through updates', () => {
     class Leaf extends React.Component {
       static contextTypes = {
@@ -946,6 +952,7 @@ describe('ReactCompositeComponent', () => {
     expect(div.children[0].id).toBe('aliens');
   });
 
+  // @gate !disableLegacyContext
   it('should trigger componentWillReceiveProps for context changes', () => {
     let contextChanges = 0;
     let propChanges = 0;
@@ -1219,6 +1226,7 @@ describe('ReactCompositeComponent', () => {
     expect(a).toBe(b);
   });
 
+  // @gate !disableLegacyContext || !__DEV__
   it('context should be passed down from the parent', () => {
     class Parent extends React.Component {
       static childContextTypes = {

commit 4c73da8cbdbd2493827f86ed1991c3770ecb9625
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jan 29 14:03:16 2024 -0500

    Convert ReactCompositeComponent to createRoot (#28099)
    
    Moves tests depending on legacy APIs to `ReactLegacyCompositeComponents`
    and updates the rest.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index bf91fb08dd..c58e825203 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -13,9 +13,11 @@ let ChildUpdates;
 let MorphingComponent;
 let React;
 let ReactDOM;
+let ReactDOMClient;
 let ReactCurrentOwner;
-let ReactTestUtils;
-let PropTypes;
+let Scheduler;
+let assertLog;
+let act;
 
 describe('ReactCompositeComponent', () => {
   const hasOwnProperty = Object.prototype.hasOwnProperty;
@@ -64,55 +66,153 @@ describe('ReactCompositeComponent', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
     ReactCurrentOwner =
       require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
         .ReactCurrentOwner;
-    ReactTestUtils = require('react-dom/test-utils');
-    PropTypes = require('prop-types');
+    Scheduler = require('scheduler');
+    assertLog = require('internal-test-utils').assertLog;
+    act = require('internal-test-utils').act;
+  });
+
+  describe('MorphingComponent', () => {
+    let instance;
+    let childInstance;
 
-    MorphingComponent = class extends React.Component {
-      state = {activated: false};
+    beforeEach(() => {
+      MorphingComponent = class extends React.Component {
+        state = {activated: false};
+        xRef = React.createRef();
 
-      xRef = React.createRef();
+        componentDidMount() {
+          instance = this;
+        }
+
+        _toggleActivatedState = () => {
+          this.setState({activated: !this.state.activated});
+        };
 
-      _toggleActivatedState = () => {
-        this.setState({activated: !this.state.activated});
+        render() {
+          const toggleActivatedState = this._toggleActivatedState;
+          return !this.state.activated ? (
+            <a ref={this.xRef} onClick={toggleActivatedState} />
+          ) : (
+            <b ref={this.xRef} onClick={toggleActivatedState} />
+          );
+        }
       };
 
-      render() {
-        const toggleActivatedState = this._toggleActivatedState;
-        return !this.state.activated ? (
-          <a ref={this.xRef} onClick={toggleActivatedState} />
-        ) : (
-          <b ref={this.xRef} onClick={toggleActivatedState} />
-        );
-      }
-    };
+      /**
+       * We'll use this to ensure that an old version is not cached when it is
+       * reallocated again.
+       */
+      ChildUpdates = class extends React.Component {
+        anchorRef = React.createRef();
 
-    /**
-     * We'll use this to ensure that an old version is not cached when it is
-     * reallocated again.
-     */
-    ChildUpdates = class extends React.Component {
-      anchorRef = React.createRef();
+        componentDidMount() {
+          childInstance = this;
+        }
+
+        getAnchor = () => {
+          return this.anchorRef.current;
+        };
 
-      getAnchor = () => {
-        return this.anchorRef.current;
+        render() {
+          const className = this.props.anchorClassOn ? 'anchorClass' : '';
+          return this.props.renderAnchor ? (
+            <a ref={this.anchorRef} className={className} />
+          ) : (
+            <b />
+          );
+        }
       };
+    });
+    it('should support rendering to different child types over time', async () => {
+      const root = ReactDOMClient.createRoot(document.createElement('div'));
+      await act(() => {
+        root.render(<MorphingComponent />);
+      });
+      expect(instance.xRef.current.tagName).toBe('A');
+
+      await act(() => {
+        instance._toggleActivatedState();
+      });
+      expect(instance.xRef.current.tagName).toBe('B');
+
+      await act(() => {
+        instance._toggleActivatedState();
+      });
+      expect(instance.xRef.current.tagName).toBe('A');
+    });
 
-      render() {
-        const className = this.props.anchorClassOn ? 'anchorClass' : '';
-        return this.props.renderAnchor ? (
-          <a ref={this.anchorRef} className={className} />
-        ) : (
-          <b />
-        );
+    it('should react to state changes from callbacks', async () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
+      try {
+        await act(() => {
+          root.render(<MorphingComponent />);
+        });
+        expect(instance.xRef.current.tagName).toBe('A');
+        await act(() => {
+          instance.xRef.current.click();
+        });
+        expect(instance.xRef.current.tagName).toBe('B');
+      } finally {
+        document.body.removeChild(container);
+        root.unmount();
       }
-    };
+    });
+
+    it('should rewire refs when rendering to different child types', async () => {
+      const container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<MorphingComponent />);
+      });
+      expect(instance.xRef.current.tagName).toBe('A');
+
+      await act(() => {
+        instance._toggleActivatedState();
+      });
+      expect(instance.xRef.current.tagName).toBe('B');
+
+      await act(() => {
+        instance._toggleActivatedState();
+      });
+      expect(instance.xRef.current.tagName).toBe('A');
+    });
+
+    it('should not cache old DOM nodes when switching constructors', async () => {
+      const container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<ChildUpdates renderAnchor={true} anchorClassOn={false} />);
+      });
+      await act(() => {
+        root.render(
+          // Warm any cache
+          <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
+        );
+      });
+      await act(() => {
+        root.render(
+          // Clear out the anchor
+          <ChildUpdates renderAnchor={false} anchorClassOn={true} />,
+        );
+      });
+      await act(() => {
+        root.render(
+          // rerender
+          <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
+        );
+      });
+      expect(childInstance.getAnchor().className).toBe('');
+    });
   });
 
   if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
-    it('should not support module pattern components', () => {
+    it('should not support module pattern components', async () => {
       function Child({test}) {
         return {
           render() {
@@ -122,8 +222,13 @@ describe('ReactCompositeComponent', () => {
       }
 
       const el = document.createElement('div');
+      const root = ReactDOMClient.createRoot(el);
       expect(() => {
-        expect(() => ReactDOM.render(<Child test="test" />, el)).toThrow(
+        expect(() => {
+          ReactDOM.flushSync(() => {
+            root.render(<Child test="test" />);
+          });
+        }).toThrow(
           'Objects are not valid as a React child (found: object with keys {render}).',
         );
       }).toErrorDev(
@@ -147,7 +252,12 @@ describe('ReactCompositeComponent', () => {
       }
 
       const el = document.createElement('div');
-      expect(() => ReactDOM.render(<Child test="test" />, el)).toErrorDev(
+      const root = ReactDOMClient.createRoot(el);
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<Child test="test" />);
+        });
+      }).toErrorDev(
         'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
           'Change Child to a class that extends React.Component instead. ' +
           "If you can't use a class try assigning the prototype on the function as a workaround. " +
@@ -159,70 +269,7 @@ describe('ReactCompositeComponent', () => {
     });
   }
 
-  it('should support rendering to different child types over time', () => {
-    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
-    let el = ReactDOM.findDOMNode(instance);
-    expect(el.tagName).toBe('A');
-
-    instance._toggleActivatedState();
-    el = ReactDOM.findDOMNode(instance);
-    expect(el.tagName).toBe('B');
-
-    instance._toggleActivatedState();
-    el = ReactDOM.findDOMNode(instance);
-    expect(el.tagName).toBe('A');
-  });
-
-  it('should react to state changes from callbacks', () => {
-    const container = document.createElement('div');
-    document.body.appendChild(container);
-    try {
-      const instance = ReactDOM.render(<MorphingComponent />, container);
-      let el = ReactDOM.findDOMNode(instance);
-      expect(el.tagName).toBe('A');
-      el.click();
-      el = ReactDOM.findDOMNode(instance);
-      expect(el.tagName).toBe('B');
-    } finally {
-      document.body.removeChild(container);
-    }
-  });
-
-  it('should rewire refs when rendering to different child types', () => {
-    const instance = ReactTestUtils.renderIntoDocument(<MorphingComponent />);
-
-    expect(instance.xRef.current.tagName).toBe('A');
-    instance._toggleActivatedState();
-    expect(instance.xRef.current.tagName).toBe('B');
-    instance._toggleActivatedState();
-    expect(instance.xRef.current.tagName).toBe('A');
-  });
-
-  it('should not cache old DOM nodes when switching constructors', () => {
-    const container = document.createElement('div');
-    const instance = ReactDOM.render(
-      <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
-      container,
-    );
-    ReactDOM.render(
-      // Warm any cache
-      <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
-      container,
-    );
-    ReactDOM.render(
-      // Clear out the anchor
-      <ChildUpdates renderAnchor={false} anchorClassOn={true} />,
-      container,
-    );
-    ReactDOM.render(
-      // rerender
-      <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
-      container,
-    );
-    expect(instance.getAnchor().className).toBe('');
-  });
-
-  it('should use default values for undefined props', () => {
+  it('should use default values for undefined props', async () => {
     class Component extends React.Component {
       static defaultProps = {prop: 'testKey'};
 
@@ -231,21 +278,29 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    const instance1 = ReactTestUtils.renderIntoDocument(<Component />);
+    let instance1;
+    let instance2;
+    let instance3;
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Component ref={ref => (instance1 = ref)} />);
+    });
     expect(instance1.props).toEqual({prop: 'testKey'});
 
-    const instance2 = ReactTestUtils.renderIntoDocument(
-      <Component prop={undefined} />,
-    );
+    await act(() => {
+      root.render(
+        <Component ref={ref => (instance2 = ref)} prop={undefined} />,
+      );
+    });
     expect(instance2.props).toEqual({prop: 'testKey'});
 
-    const instance3 = ReactTestUtils.renderIntoDocument(
-      <Component prop={null} />,
-    );
+    await act(() => {
+      root.render(<Component ref={ref => (instance3 = ref)} prop={null} />);
+    });
     expect(instance3.props).toEqual({prop: null});
   });
 
-  it('should not mutate passed-in props object', () => {
+  it('should not mutate passed-in props object', async () => {
     class Component extends React.Component {
       static defaultProps = {prop: 'testKey'};
 
@@ -255,8 +310,11 @@ describe('ReactCompositeComponent', () => {
     }
 
     const inputProps = {};
-    let instance1 = <Component {...inputProps} />;
-    instance1 = ReactTestUtils.renderIntoDocument(instance1);
+    let instance1;
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Component {...inputProps} ref={ref => (instance1 = ref)} />);
+    });
     expect(instance1.props.prop).toBe('testKey');
 
     // We don't mutate the input, just in case the caller wants to do something
@@ -264,19 +322,24 @@ describe('ReactCompositeComponent', () => {
     expect(inputProps.prop).not.toBeDefined();
   });
 
-  it('should warn about `forceUpdate` on not-yet-mounted components', () => {
+  it('should warn about `forceUpdate` on not-yet-mounted components', async () => {
     class MyComponent extends React.Component {
       constructor(props) {
         super(props);
         this.forceUpdate();
       }
       render() {
-        return <div />;
+        return <div>foo</div>;
       }
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<MyComponent />, container)).toErrorDev(
+    const root = ReactDOMClient.createRoot(container);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<MyComponent />);
+      });
+    }).toErrorDev(
       "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
@@ -285,22 +348,32 @@ describe('ReactCompositeComponent', () => {
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
-    ReactDOM.render(<MyComponent />, container2);
+    const root2 = ReactDOMClient.createRoot(container2);
+    await act(() => {
+      root2.render(<MyComponent />);
+    });
+    expect(container2.firstChild.textContent).toBe('foo');
   });
 
-  it('should warn about `setState` on not-yet-mounted components', () => {
+  it('should warn about `setState` on not-yet-mounted components', async () => {
     class MyComponent extends React.Component {
       constructor(props) {
         super(props);
         this.setState();
       }
       render() {
-        return <div />;
+        return <div>foo</div>;
       }
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<MyComponent />, container)).toErrorDev(
+    const root = ReactDOMClient.createRoot(container);
+
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<MyComponent />);
+      });
+    }).toErrorDev(
       "Warning: Can't call setState on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
@@ -309,67 +382,87 @@ describe('ReactCompositeComponent', () => {
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
-    ReactDOM.render(<MyComponent />, container2);
+    const root2 = ReactDOMClient.createRoot(container2);
+    await act(() => {
+      root2.render(<MyComponent />);
+    });
+    expect(container2.firstChild.textContent).toBe('foo');
   });
 
-  it('should not warn about `forceUpdate` on unmounted components', () => {
+  it('should not warn about `forceUpdate` on unmounted components', async () => {
     const container = document.createElement('div');
     document.body.appendChild(container);
 
+    let instance;
     class Component extends React.Component {
+      componentDidMount() {
+        instance = this;
+      }
+
       render() {
         return <div />;
       }
     }
 
-    let instance = <Component />;
-    expect(instance.forceUpdate).not.toBeDefined();
+    const component = <Component />;
+    expect(component.forceUpdate).not.toBeDefined();
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(component);
+    });
 
-    instance = ReactDOM.render(instance, container);
     instance.forceUpdate();
 
-    ReactDOM.unmountComponentAtNode(container);
+    root.unmount(container);
 
     instance.forceUpdate();
     instance.forceUpdate();
   });
 
-  it('should not warn about `setState` on unmounted components', () => {
+  it('should not warn about `setState` on unmounted components', async () => {
     const container = document.createElement('div');
     document.body.appendChild(container);
 
-    let renders = 0;
-
     class Component extends React.Component {
       state = {value: 0};
 
       render() {
-        renders++;
+        Scheduler.log('render ' + this.state.value);
         return <div />;
       }
     }
 
-    let instance;
-    ReactDOM.render(
-      <div>
-        <span>
-          <Component ref={c => (instance = c || instance)} />
-        </span>
-      </div>,
-      container,
-    );
+    let ref;
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(
+        <div>
+          <span>
+            <Component ref={c => (ref = c || ref)} />
+          </span>
+        </div>,
+      );
+    });
 
-    expect(renders).toBe(1);
+    assertLog(['render 0']);
 
-    instance.setState({value: 1});
-    expect(renders).toBe(2);
+    await act(() => {
+      ref.setState({value: 1});
+    });
+    assertLog(['render 1']);
 
-    ReactDOM.render(<div />, container);
-    instance.setState({value: 2});
-    expect(renders).toBe(2);
+    await act(() => {
+      root.render(<div />);
+    });
+
+    await act(() => {
+      ref.setState({value: 2});
+    });
+    // setState on an unmounted component is a noop.
+    assertLog([]);
   });
 
-  it('should silently allow `setState`, not call cb on unmounting components', () => {
+  it('should silently allow `setState`, not call cb on unmounting components', async () => {
     let cbCalled = false;
     const container = document.createElement('div');
     document.body.appendChild(container);
@@ -389,24 +482,33 @@ describe('ReactCompositeComponent', () => {
         return <div />;
       }
     }
-
-    const instance = ReactDOM.render(<Component />, container);
+    let instance;
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component ref={c => (instance = c)} />);
+    });
+    await act(() => {
+      instance.setState({value: 1});
+    });
     instance.setState({value: 1});
 
-    ReactDOM.unmountComponentAtNode(container);
+    root.unmount();
     expect(cbCalled).toBe(false);
   });
 
-  it('should warn when rendering a class with a render method that does not extend React.Component', () => {
+  it('should warn when rendering a class with a render method that does not extend React.Component', async () => {
     const container = document.createElement('div');
     class ClassWithRenderNotExtended {
       render() {
         return <div />;
       }
     }
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
       expect(() => {
-        ReactDOM.render(<ClassWithRenderNotExtended />, container);
+        ReactDOM.flushSync(() => {
+          root.render(<ClassWithRenderNotExtended />);
+        });
       }).toThrow(TypeError);
     }).toErrorDev(
       'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
@@ -416,33 +518,33 @@ describe('ReactCompositeComponent', () => {
 
     // Test deduplication
     expect(() => {
-      ReactDOM.render(<ClassWithRenderNotExtended />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<ClassWithRenderNotExtended />);
+      });
     }).toThrow(TypeError);
   });
 
-  it('should warn about `setState` in render', () => {
+  it('should warn about `setState` in render', async () => {
     const container = document.createElement('div');
 
-    let renderedState = -1;
-    let renderPasses = 0;
-
     class Component extends React.Component {
       state = {value: 0};
 
       render() {
-        renderPasses++;
-        renderedState = this.state.value;
+        Scheduler.log('render ' + this.state.value);
         if (this.state.value === 0) {
           this.setState({value: 1});
         }
-        return <div />;
+        return <div>foo {this.state.value}</div>;
       }
     }
 
     let instance;
-
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      instance = ReactDOM.render(<Component />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<Component ref={ref => (instance = ref)} />);
+      });
     }).toErrorDev(
       'Cannot update during an existing state transition (such as within ' +
         '`render`). Render methods should be a pure function of props and state.',
@@ -451,40 +553,37 @@ describe('ReactCompositeComponent', () => {
     // The setState call is queued and then executed as a second pass. This
     // behavior is undefined though so we're free to change it to suit the
     // implementation details.
-    expect(renderPasses).toBe(2);
-    expect(renderedState).toBe(1);
+    assertLog(['render 0', 'render 1']);
     expect(instance.state.value).toBe(1);
 
     // Forcing a rerender anywhere will cause the update to happen.
-    const instance2 = ReactDOM.render(<Component prop={123} />, container);
-    expect(instance).toBe(instance2);
-    expect(renderedState).toBe(1);
-    expect(instance2.state.value).toBe(1);
-
-    // Test deduplication; (no additional warnings are expected).
-    ReactDOM.unmountComponentAtNode(container);
-    ReactDOM.render(<Component prop={123} />, container);
+    await act(() => {
+      root.render(<Component prop={123} />);
+    });
+    assertLog(['render 1']);
   });
 
-  it('should cleanup even if render() fatals', () => {
+  it('should cleanup even if render() fatals', async () => {
     class BadComponent extends React.Component {
       render() {
         throw new Error();
       }
     }
 
-    let instance = <BadComponent />;
-
+    const instance = <BadComponent />;
     expect(ReactCurrentOwner.current).toBe(null);
 
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     expect(() => {
-      instance = ReactTestUtils.renderIntoDocument(instance);
+      ReactDOM.flushSync(() => {
+        root.render(instance);
+      });
     }).toThrow();
 
     expect(ReactCurrentOwner.current).toBe(null);
   });
 
-  it('should call componentWillUnmount before unmounting', () => {
+  it('should call componentWillUnmount before unmounting', async () => {
     const container = document.createElement('div');
     let innerUnmounted = false;
 
@@ -500,572 +599,149 @@ describe('ReactCompositeComponent', () => {
     }
 
     class Inner extends React.Component {
-      componentWillUnmount() {
-        innerUnmounted = true;
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    ReactDOM.render(<Component />, container);
-    ReactDOM.unmountComponentAtNode(container);
-    expect(innerUnmounted).toBe(true);
-  });
-
-  it('should warn when shouldComponentUpdate() returns undefined', () => {
-    class ClassComponent extends React.Component {
-      state = {bogus: false};
-
-      shouldComponentUpdate() {
-        return undefined;
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const instance = ReactTestUtils.renderIntoDocument(<ClassComponent />);
-
-    expect(() => instance.setState({bogus: true})).toErrorDev(
-      'Warning: ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
-        'boolean value. Make sure to return true or false.',
-    );
-  });
-
-  it('should warn when componentDidUnmount method is defined', () => {
-    class Component extends React.Component {
-      componentDidUnmount = () => {};
-
-      render() {
-        return <div />;
-      }
-    }
-
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
-      'Warning: Component has a method called ' +
-        'componentDidUnmount(). But there is no such lifecycle method. ' +
-        'Did you mean componentWillUnmount()?',
-    );
-  });
-
-  it('should warn when componentDidReceiveProps method is defined', () => {
-    class Component extends React.Component {
-      componentDidReceiveProps = () => {};
-
-      render() {
-        return <div />;
-      }
-    }
-
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
-      'Warning: Component has a method called ' +
-        'componentDidReceiveProps(). But there is no such lifecycle method. ' +
-        'If you meant to update the state in response to changing props, ' +
-        'use componentWillReceiveProps(). If you meant to fetch data or ' +
-        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
-    );
-  });
-
-  it('should warn when defaultProps was defined as an instance property', () => {
-    class Component extends React.Component {
-      constructor(props) {
-        super(props);
-        this.defaultProps = {name: 'Abhay'};
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    expect(() => ReactTestUtils.renderIntoDocument(<Component />)).toErrorDev(
-      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
-        'and will be ignored. Instead, define defaultProps as a static property on Component.',
-    );
-  });
-
-  // @gate !disableLegacyContext
-  it('should pass context to children when not owner', () => {
-    class Parent extends React.Component {
-      render() {
-        return (
-          <Child>
-            <Grandchild />
-          </Child>
-        );
-      }
-    }
-
-    class Child extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-      };
-
-      getChildContext() {
-        return {
-          foo: 'bar',
-        };
-      }
-
-      render() {
-        return React.Children.only(this.props.children);
-      }
-    }
-
-    class Grandchild extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string,
-      };
-
-      render() {
-        return <div>{this.context.foo}</div>;
-      }
-    }
-
-    const component = ReactTestUtils.renderIntoDocument(<Parent />);
-    expect(ReactDOM.findDOMNode(component).innerHTML).toBe('bar');
-  });
-
-  it('should skip update when rerendering element in container', () => {
-    class Parent extends React.Component {
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    let childRenders = 0;
-
-    class Child extends React.Component {
-      render() {
-        childRenders++;
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const child = <Child />;
-
-    ReactDOM.render(<Parent>{child}</Parent>, container);
-    ReactDOM.render(<Parent>{child}</Parent>, container);
-    expect(childRenders).toBe(1);
-  });
-
-  // @gate !disableLegacyContext
-  it('should pass context when re-rendered for static child', () => {
-    let parentInstance = null;
-    let childInstance = null;
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-        flag: PropTypes.bool,
-      };
-
-      state = {
-        flag: false,
-      };
-
-      getChildContext() {
-        return {
-          foo: 'bar',
-          flag: this.state.flag,
-        };
-      }
-
-      render() {
-        return React.Children.only(this.props.children);
-      }
-    }
-
-    class Middle extends React.Component {
-      render() {
-        return this.props.children;
-      }
-    }
-
-    class Child extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string,
-        flag: PropTypes.bool,
-      };
-
-      render() {
-        childInstance = this;
-        return <span>Child</span>;
-      }
-    }
-
-    parentInstance = ReactTestUtils.renderIntoDocument(
-      <Parent>
-        <Middle>
-          <Child />
-        </Middle>
-      </Parent>,
-    );
-
-    expect(parentInstance.state.flag).toBe(false);
-    expect(childInstance.context).toEqual({foo: 'bar', flag: false});
-
-    parentInstance.setState({flag: true});
-    expect(parentInstance.state.flag).toBe(true);
-    expect(childInstance.context).toEqual({foo: 'bar', flag: true});
-  });
-
-  // @gate !disableLegacyContext
-  it('should pass context when re-rendered for static child within a composite component', () => {
-    class Parent extends React.Component {
-      static childContextTypes = {
-        flag: PropTypes.bool,
-      };
-
-      state = {
-        flag: true,
-      };
-
-      getChildContext() {
-        return {
-          flag: this.state.flag,
-        };
-      }
-
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    class Child extends React.Component {
-      static contextTypes = {
-        flag: PropTypes.bool,
-      };
-
-      render() {
-        return <div />;
-      }
-    }
-
-    class Wrapper extends React.Component {
-      parentRef = React.createRef();
-      childRef = React.createRef();
-
-      render() {
-        return (
-          <Parent ref={this.parentRef}>
-            <Child ref={this.childRef} />
-          </Parent>
-        );
-      }
-    }
-
-    const wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
-
-    expect(wrapper.parentRef.current.state.flag).toEqual(true);
-    expect(wrapper.childRef.current.context).toEqual({flag: true});
-
-    // We update <Parent /> while <Child /> is still a static prop relative to this update
-    wrapper.parentRef.current.setState({flag: false});
-
-    expect(wrapper.parentRef.current.state.flag).toEqual(false);
-    expect(wrapper.childRef.current.context).toEqual({flag: false});
-  });
-
-  // @gate !disableLegacyContext
-  it('should pass context transitively', () => {
-    let childInstance = null;
-    let grandchildInstance = null;
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-        depth: PropTypes.number,
-      };
-
-      getChildContext() {
-        return {
-          foo: 'bar',
-          depth: 0,
-        };
-      }
-
-      render() {
-        return <Child />;
-      }
-    }
-
-    class Child extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string,
-        depth: PropTypes.number,
-      };
-
-      static childContextTypes = {
-        depth: PropTypes.number,
-      };
-
-      getChildContext() {
-        return {
-          depth: this.context.depth + 1,
-        };
-      }
-
-      render() {
-        childInstance = this;
-        return <Grandchild />;
-      }
-    }
-
-    class Grandchild extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string,
-        depth: PropTypes.number,
-      };
-
-      render() {
-        grandchildInstance = this;
-        return <div />;
-      }
-    }
-
-    ReactTestUtils.renderIntoDocument(<Parent />);
-    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
-    expect(grandchildInstance.context).toEqual({foo: 'bar', depth: 1});
-  });
-
-  // @gate !disableLegacyContext
-  it('should pass context when re-rendered', () => {
-    let parentInstance = null;
-    let childInstance = null;
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-        depth: PropTypes.number,
-      };
-
-      state = {
-        flag: false,
-      };
-
-      getChildContext() {
-        return {
-          foo: 'bar',
-          depth: 0,
-        };
-      }
-
-      render() {
-        let output = <Child />;
-        if (!this.state.flag) {
-          output = <span>Child</span>;
-        }
-        return output;
-      }
-    }
-
-    class Child extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string,
-        depth: PropTypes.number,
-      };
-
-      render() {
-        childInstance = this;
-        return <span>Child</span>;
-      }
-    }
-
-    parentInstance = ReactTestUtils.renderIntoDocument(<Parent />);
-    expect(childInstance).toBeNull();
-
-    expect(parentInstance.state.flag).toBe(false);
-    ReactDOM.unstable_batchedUpdates(function () {
-      parentInstance.setState({flag: true});
-    });
-    expect(parentInstance.state.flag).toBe(true);
-
-    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
-  });
-
-  // @gate !disableLegacyContext
-  it('unmasked context propagates through updates', () => {
-    class Leaf extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-      };
-
-      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
-        expect('foo' in nextContext).toBe(true);
-      }
-
-      shouldComponentUpdate(nextProps, nextState, nextContext) {
-        expect('foo' in nextContext).toBe(true);
-        return true;
-      }
-
-      render() {
-        return <span>{this.context.foo}</span>;
-      }
-    }
-
-    class Intermediary extends React.Component {
-      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
-        expect('foo' in nextContext).toBe(false);
-      }
-
-      shouldComponentUpdate(nextProps, nextState, nextContext) {
-        expect('foo' in nextContext).toBe(false);
-        return true;
-      }
-
-      render() {
-        return <Leaf />;
-      }
-    }
-
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-      };
-
-      getChildContext() {
-        return {
-          foo: this.props.cntxt,
-        };
+      componentWillUnmount() {
+        innerUnmounted = true;
       }
 
       render() {
-        return <Intermediary />;
+        return <div />;
       }
     }
 
-    const div = document.createElement('div');
-    ReactDOM.render(<Parent cntxt="noise" />, div);
-    expect(div.children[0].innerHTML).toBe('noise');
-    div.children[0].innerHTML = 'aliens';
-    div.children[0].id = 'aliens';
-    expect(div.children[0].innerHTML).toBe('aliens');
-    expect(div.children[0].id).toBe('aliens');
-    ReactDOM.render(<Parent cntxt="bar" />, div);
-    expect(div.children[0].innerHTML).toBe('bar');
-    expect(div.children[0].id).toBe('aliens');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
+    root.unmount();
+    expect(innerUnmounted).toBe(true);
   });
 
-  // @gate !disableLegacyContext
-  it('should trigger componentWillReceiveProps for context changes', () => {
-    let contextChanges = 0;
-    let propChanges = 0;
-
-    class GrandChild extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-      };
-
-      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
-        expect('foo' in nextContext).toBe(true);
-
-        if (nextProps !== this.props) {
-          propChanges++;
-        }
+  it('should warn when shouldComponentUpdate() returns undefined', async () => {
+    class ClassComponent extends React.Component {
+      state = {bogus: false};
 
-        if (nextContext !== this.context) {
-          contextChanges++;
-        }
+      shouldComponentUpdate() {
+        return undefined;
       }
 
       render() {
-        return <span className="grand-child">{this.props.children}</span>;
+        return <div />;
       }
     }
+    let instance;
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<ClassComponent ref={ref => (instance = ref)} />);
+    });
 
-    class ChildWithContext extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-      };
-
-      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
-        expect('foo' in nextContext).toBe(true);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        instance.setState({bogus: true});
+      });
+    }).toErrorDev(
+      'Warning: ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
+        'boolean value. Make sure to return true or false.',
+    );
+  });
 
-        if (nextProps !== this.props) {
-          propChanges++;
-        }
+  it('should warn when componentDidUnmount method is defined', async () => {
+    class Component extends React.Component {
+      componentDidUnmount = () => {};
 
-        if (nextContext !== this.context) {
-          contextChanges++;
-        }
+      render() {
+        return <div />;
       }
+    }
+
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Component has a method called ' +
+        'componentDidUnmount(). But there is no such lifecycle method. ' +
+        'Did you mean componentWillUnmount()?',
+    );
+  });
+
+  it('should warn when componentDidReceiveProps method is defined', () => {
+    class Component extends React.Component {
+      componentDidReceiveProps = () => {};
 
       render() {
-        return <div className="child-with">{this.props.children}</div>;
+        return <div />;
       }
     }
 
-    class ChildWithoutContext extends React.Component {
-      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
-        expect('foo' in nextContext).toBe(false);
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-        if (nextProps !== this.props) {
-          propChanges++;
-        }
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Component has a method called ' +
+        'componentDidReceiveProps(). But there is no such lifecycle method. ' +
+        'If you meant to update the state in response to changing props, ' +
+        'use componentWillReceiveProps(). If you meant to fetch data or ' +
+        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+    );
+  });
 
-        if (nextContext !== this.context) {
-          contextChanges++;
-        }
+  it('should warn when defaultProps was defined as an instance property', () => {
+    class Component extends React.Component {
+      constructor(props) {
+        super(props);
+        this.defaultProps = {name: 'Abhay'};
       }
 
       render() {
-        return <div className="child-without">{this.props.children}</div>;
+        return <div />;
       }
     }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-      };
-
-      state = {
-        foo: 'abc',
-      };
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+        'and will be ignored. Instead, define defaultProps as a static property on Component.',
+    );
+  });
 
-      getChildContext() {
-        return {
-          foo: this.state.foo,
-        };
+  it('should skip update when rerendering element in container', async () => {
+    class Parent extends React.Component {
+      render() {
+        return <div>{this.props.children}</div>;
       }
+    }
 
+    class Child extends React.Component {
       render() {
-        return <div className="parent">{this.props.children}</div>;
+        Scheduler.log('Child render');
+        return <div />;
       }
     }
 
-    const div = document.createElement('div');
-
-    let parentInstance = null;
-    ReactDOM.render(
-      <Parent ref={inst => (parentInstance = inst)}>
-        <ChildWithoutContext>
-          A1
-          <GrandChild>A2</GrandChild>
-        </ChildWithoutContext>
-
-        <ChildWithContext>
-          B1
-          <GrandChild>B2</GrandChild>
-        </ChildWithContext>
-      </Parent>,
-      div,
-    );
-
-    parentInstance.setState({
-      foo: 'def',
+    const container = document.createElement('div');
+    const child = <Child />;
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent>{child}</Parent>);
     });
+    assertLog(['Child render']);
 
-    expect(propChanges).toBe(0);
-    expect(contextChanges).toBe(3); // ChildWithContext, GrandChild x 2
+    await act(() => {
+      root.render(<Parent>{child}</Parent>);
+    });
+    assertLog([]);
   });
 
   it('should disallow nested render calls', () => {
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     class Inner extends React.Component {
       render() {
         return <div />;
@@ -1074,12 +750,16 @@ describe('ReactCompositeComponent', () => {
 
     class Outer extends React.Component {
       render() {
-        ReactTestUtils.renderIntoDocument(<Inner />);
+        root.render(<Inner />);
         return <div />;
       }
     }
 
-    expect(() => ReactTestUtils.renderIntoDocument(<Outer />)).toErrorDev(
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Outer />);
+      });
+    }).toErrorDev(
       'Render methods should be a pure function of props and state; ' +
         'triggering nested component updates from render is not allowed. If ' +
         'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
@@ -1087,7 +767,7 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
-  it('only renders once if updated in componentWillReceiveProps', () => {
+  it('only renders once if updated in componentWillReceiveProps', async () => {
     let renders = 0;
 
     class Component extends React.Component {
@@ -1107,15 +787,23 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
-    const instance = ReactDOM.render(<Component update={0} />, container);
+    const root = ReactDOMClient.createRoot(container);
+    let instance;
+
+    await act(() => {
+      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+    });
     expect(renders).toBe(1);
     expect(instance.state.updated).toBe(false);
-    ReactDOM.render(<Component update={1} />, container);
+
+    await act(() => {
+      root.render(<Component update={1} ref={ref => (instance = ref)} />);
+    });
     expect(renders).toBe(2);
     expect(instance.state.updated).toBe(true);
   });
 
-  it('only renders once if updated in componentWillReceiveProps when batching', () => {
+  it('only renders once if updated in componentWillReceiveProps when batching', async () => {
     let renders = 0;
 
     class Component extends React.Component {
@@ -1135,234 +823,21 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
-    const instance = ReactDOM.render(<Component update={0} />, container);
+    const root = ReactDOMClient.createRoot(container);
+    let instance;
+    await act(() => {
+      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+    });
     expect(renders).toBe(1);
     expect(instance.state.updated).toBe(false);
-    ReactDOM.unstable_batchedUpdates(() => {
-      ReactDOM.render(<Component update={1} />, container);
+    await act(() => {
+      root.render(<Component update={1} ref={ref => (instance = ref)} />);
     });
     expect(renders).toBe(2);
     expect(instance.state.updated).toBe(true);
   });
 
-  it('should update refs if shouldComponentUpdate gives false', () => {
-    class Static extends React.Component {
-      shouldComponentUpdate() {
-        return false;
-      }
-
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    class Component extends React.Component {
-      static0Ref = React.createRef();
-      static1Ref = React.createRef();
-
-      render() {
-        if (this.props.flipped) {
-          return (
-            <div>
-              <Static ref={this.static0Ref} key="B">
-                B (ignored)
-              </Static>
-              <Static ref={this.static1Ref} key="A">
-                A (ignored)
-              </Static>
-            </div>
-          );
-        } else {
-          return (
-            <div>
-              <Static ref={this.static0Ref} key="A">
-                A
-              </Static>
-              <Static ref={this.static1Ref} key="B">
-                B
-              </Static>
-            </div>
-          );
-        }
-      }
-    }
-
-    const container = document.createElement('div');
-    const comp = ReactDOM.render(<Component flipped={false} />, container);
-    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('A');
-    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('B');
-
-    // When flipping the order, the refs should update even though the actual
-    // contents do not
-    ReactDOM.render(<Component flipped={true} />, container);
-    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('B');
-    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('A');
-  });
-
-  it('should allow access to findDOMNode in componentWillUnmount', () => {
-    let a = null;
-    let b = null;
-
-    class Component extends React.Component {
-      componentDidMount() {
-        a = ReactDOM.findDOMNode(this);
-        expect(a).not.toBe(null);
-      }
-
-      componentWillUnmount() {
-        b = ReactDOM.findDOMNode(this);
-        expect(b).not.toBe(null);
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    expect(a).toBe(container.firstChild);
-    ReactDOM.render(<Component />, container);
-    ReactDOM.unmountComponentAtNode(container);
-    expect(a).toBe(b);
-  });
-
-  // @gate !disableLegacyContext || !__DEV__
-  it('context should be passed down from the parent', () => {
-    class Parent extends React.Component {
-      static childContextTypes = {
-        foo: PropTypes.string,
-      };
-
-      getChildContext() {
-        return {
-          foo: 'bar',
-        };
-      }
-
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    class Component extends React.Component {
-      static contextTypes = {
-        foo: PropTypes.string.isRequired,
-      };
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const div = document.createElement('div');
-    ReactDOM.render(
-      <Parent>
-        <Component />
-      </Parent>,
-      div,
-    );
-  });
-
-  it('should replace state', () => {
-    class Moo extends React.Component {
-      state = {x: 1};
-      render() {
-        return <div />;
-      }
-    }
-
-    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
-    // No longer a public API, but we can test that it works internally by
-    // reaching into the updater.
-    moo.updater.enqueueReplaceState(moo, {y: 2});
-    expect('x' in moo.state).toBe(false);
-    expect(moo.state.y).toBe(2);
-  });
-
-  it('should support objects with prototypes as state', () => {
-    const NotActuallyImmutable = function (str) {
-      this.str = str;
-    };
-    NotActuallyImmutable.prototype.amIImmutable = function () {
-      return true;
-    };
-    class Moo extends React.Component {
-      state = new NotActuallyImmutable('first');
-      // No longer a public API, but we can test that it works internally by
-      // reaching into the updater.
-      _replaceState = update => this.updater.enqueueReplaceState(this, update);
-      render() {
-        return <div />;
-      }
-    }
-
-    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
-    expect(moo.state.str).toBe('first');
-    expect(moo.state.amIImmutable()).toBe(true);
-
-    const secondState = new NotActuallyImmutable('second');
-    moo._replaceState(secondState);
-    expect(moo.state.str).toBe('second');
-    expect(moo.state.amIImmutable()).toBe(true);
-    expect(moo.state).toBe(secondState);
-
-    moo.setState({str: 'third'});
-    expect(moo.state.str).toBe('third');
-    // Here we lose the prototype.
-    expect(moo.state.amIImmutable).toBe(undefined);
-
-    // When more than one state update is enqueued, we have the same behavior
-    const fifthState = new NotActuallyImmutable('fifth');
-    ReactDOM.unstable_batchedUpdates(function () {
-      moo.setState({str: 'fourth'});
-      moo._replaceState(fifthState);
-    });
-    expect(moo.state).toBe(fifthState);
-
-    // When more than one state update is enqueued, we have the same behavior
-    const sixthState = new NotActuallyImmutable('sixth');
-    ReactDOM.unstable_batchedUpdates(function () {
-      moo._replaceState(sixthState);
-      moo.setState({str: 'seventh'});
-    });
-    expect(moo.state.str).toBe('seventh');
-    expect(moo.state.amIImmutable).toBe(undefined);
-  });
-
-  it('should not warn about unmounting during unmounting', () => {
-    const container = document.createElement('div');
-    const layer = document.createElement('div');
-
-    class Component extends React.Component {
-      componentDidMount() {
-        ReactDOM.render(<div />, layer);
-      }
-
-      componentWillUnmount() {
-        ReactDOM.unmountComponentAtNode(layer);
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    class Outer extends React.Component {
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    ReactDOM.render(
-      <Outer>
-        <Component />
-      </Outer>,
-      container,
-    );
-    ReactDOM.render(<Outer />, container);
-  });
-
-  it('should warn when mutated props are passed', () => {
+  it('should warn when mutated props are passed', async () => {
     const container = document.createElement('div');
 
     class Foo extends React.Component {
@@ -1376,7 +851,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => ReactDOM.render(<Foo idx="qwe" />, container)).toErrorDev(
+    const root = ReactDOMClient.createRoot(container);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Foo idx="qwe" />);
+      });
+    }).toErrorDev(
       'Foo(...): When calling super() in `Foo`, make sure to pass ' +
         "up the same props that your component's constructor was passed.",
     );
@@ -1416,29 +896,32 @@ describe('ReactCompositeComponent', () => {
       }
     };
 
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<App ref={setRef} stage={1} />, container);
-      ReactDOM.render(<App ref={setRef} stage={2} />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<App ref={setRef} stage={1} />);
+      });
+      ReactDOM.flushSync(() => {
+        root.render(<App ref={setRef} stage={2} />);
+      });
     }).toThrow();
     expect(count).toBe(1);
   });
 
-  it('prepares new child before unmounting old', () => {
-    const log = [];
-
+  it('prepares new child before unmounting old', async () => {
     class Spy extends React.Component {
       UNSAFE_componentWillMount() {
-        log.push(this.props.name + ' componentWillMount');
+        Scheduler.log(this.props.name + ' componentWillMount');
       }
       render() {
-        log.push(this.props.name + ' render');
+        Scheduler.log(this.props.name + ' render');
         return <div />;
       }
       componentDidMount() {
-        log.push(this.props.name + ' componentDidMount');
+        Scheduler.log(this.props.name + ' componentDidMount');
       }
       componentWillUnmount() {
-        log.push(this.props.name + ' componentWillUnmount');
+        Scheduler.log(this.props.name + ' componentWillUnmount');
       }
     }
 
@@ -1449,10 +932,15 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
-    ReactDOM.render(<Wrapper name="A" />, container);
-    ReactDOM.render(<Wrapper name="B" />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Wrapper name="A" />);
+    });
+    await act(() => {
+      root.render(<Wrapper name="B" />);
+    });
 
-    expect(log).toEqual([
+    assertLog([
       'A componentWillMount',
       'A render',
       'A componentDidMount',
@@ -1464,8 +952,7 @@ describe('ReactCompositeComponent', () => {
     ]);
   });
 
-  it('respects a shallow shouldComponentUpdate implementation', () => {
-    let renderCalls = 0;
+  it('respects a shallow shouldComponentUpdate implementation', async () => {
     class PlasticWrap extends React.Component {
       constructor(props, context) {
         super(props, context);
@@ -1504,37 +991,54 @@ describe('ReactCompositeComponent', () => {
       }
 
       render() {
-        renderCalls++;
+        const {color} = this.props;
+        const {cut, slices} = this.state;
+
+        Scheduler.log(`${color} ${cut} ${slices}`);
         return <div />;
       }
     }
 
     const container = document.createElement('div');
-    const instance = ReactDOM.render(<PlasticWrap />, container);
-    expect(renderCalls).toBe(1);
+    const root = ReactDOMClient.createRoot(container);
+    let instance;
+    await act(() => {
+      root.render(<PlasticWrap ref={ref => (instance = ref)} />);
+    });
+    assertLog(['green false 1']);
 
     // Do not re-render based on props
-    instance.setState({color: 'green'});
-    expect(renderCalls).toBe(1);
+    await act(() => {
+      instance.setState({color: 'green'});
+    });
+    assertLog([]);
 
     // Re-render based on props
-    instance.setState({color: 'red'});
-    expect(renderCalls).toBe(2);
+    await act(() => {
+      instance.setState({color: 'red'});
+    });
+    assertLog(['red false 1']);
 
     // Re-render base on state
-    instance.appleRef.current.cut();
-    expect(renderCalls).toBe(3);
+    await act(() => {
+      instance.appleRef.current.cut();
+    });
+    assertLog(['red true 10']);
 
     // No re-render based on state
-    instance.appleRef.current.cut();
-    expect(renderCalls).toBe(3);
+    await act(() => {
+      instance.appleRef.current.cut();
+    });
+    assertLog([]);
 
     // Re-render based on state again
-    instance.appleRef.current.eatSlice();
-    expect(renderCalls).toBe(4);
+    await act(() => {
+      instance.appleRef.current.eatSlice();
+    });
+    assertLog(['red true 9']);
   });
 
-  it('does not do a deep comparison for a shallow shouldComponentUpdate implementation', () => {
+  it('does not do a deep comparison for a shallow shouldComponentUpdate implementation', async () => {
     function getInitialState() {
       return {
         foo: [1, 2, 3],
@@ -1542,7 +1046,6 @@ describe('ReactCompositeComponent', () => {
       };
     }
 
-    let renderCalls = 0;
     const initialSettings = getInitialState();
 
     class Component extends React.Component {
@@ -1553,34 +1056,45 @@ describe('ReactCompositeComponent', () => {
       }
 
       render() {
-        renderCalls++;
+        const {foo, bar} = this.state;
+        Scheduler.log(`{foo:[${foo}],bar:{a:${bar.a},b:${bar.b},c:${bar.c}}`);
         return <div />;
       }
     }
 
     const container = document.createElement('div');
-    const instance = ReactDOM.render(<Component />, container);
-    expect(renderCalls).toBe(1);
+    const root = ReactDOMClient.createRoot(container);
+    let instance;
+    await act(() => {
+      root.render(<Component ref={ref => (instance = ref)} />);
+    });
+    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
 
     // Do not re-render if state is equal
     const settings = {
       foo: initialSettings.foo,
       bar: initialSettings.bar,
     };
-    instance.setState(settings);
-    expect(renderCalls).toBe(1);
+    await act(() => {
+      instance.setState(settings);
+    });
+    assertLog([]);
 
     // Re-render because one field changed
     initialSettings.foo = [1, 2, 3];
-    instance.setState(initialSettings);
-    expect(renderCalls).toBe(2);
+    await act(() => {
+      instance.setState(initialSettings);
+    });
+    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
 
     // Re-render because the object changed
-    instance.setState(getInitialState());
-    expect(renderCalls).toBe(3);
+    await act(() => {
+      instance.setState(getInitialState());
+    });
+    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
   });
 
-  it('should call setState callback with no arguments', () => {
+  it('should call setState callback with no arguments', async () => {
     let mockArgs;
     class Component extends React.Component {
       componentDidMount() {
@@ -1590,12 +1104,15 @@ describe('ReactCompositeComponent', () => {
         return false;
       }
     }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Component />);
+    });
 
-    ReactTestUtils.renderIntoDocument(<Component />);
     expect(mockArgs.length).toEqual(0);
   });
 
-  it('this.state should be updated on setState callback inside componentWillMount', () => {
+  it('this.state should be updated on setState callback inside componentWillMount', async () => {
     const div = document.createElement('div');
     let stateSuccessfullyUpdated = false;
 
@@ -1619,16 +1136,18 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactDOM.render(<Component />, div);
+    const root = ReactDOMClient.createRoot(div);
+    await act(() => {
+      root.render(<Component />);
+    });
+
     expect(stateSuccessfullyUpdated).toBe(true);
   });
 
-  it('should call the setState callback even if shouldComponentUpdate = false', done => {
+  it('should call the setState callback even if shouldComponentUpdate = false', async () => {
     const mockFn = jest.fn().mockReturnValue(false);
     const div = document.createElement('div');
 
-    let instance;
-
     class Component extends React.Component {
       constructor(props, context) {
         super(props, context);
@@ -1650,16 +1169,24 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactDOM.render(<Component />, div);
+    const root = ReactDOMClient.createRoot(div);
+    let instance;
+    await act(() => {
+      root.render(<Component ref={ref => (instance = ref)} />);
+    });
 
     expect(instance).toBeDefined();
     expect(mockFn).not.toBeCalled();
 
-    instance.setState({hasUpdatedState: true}, () => {
-      expect(mockFn).toBeCalled();
-      expect(instance.state.hasUpdatedState).toBe(true);
-      done();
+    await act(() => {
+      instance.setState({hasUpdatedState: true}, () => {
+        expect(mockFn).toBeCalled();
+        expect(instance.state.hasUpdatedState).toBe(true);
+        Scheduler.log('setState callback called');
+      });
     });
+
+    assertLog(['setState callback called']);
   });
 
   it('should return a meaningful warning when constructor is returned', () => {
@@ -1674,9 +1201,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     expect(() => {
       expect(() => {
-        ReactTestUtils.renderIntoDocument(<RenderTextInvalidConstructor />);
+        ReactDOM.flushSync(() => {
+          root.render(<RenderTextInvalidConstructor />);
+        });
       }).toThrow();
     }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
@@ -1685,6 +1215,11 @@ describe('ReactCompositeComponent', () => {
         'did you accidentally return an object from the constructor?',
       'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
         'did you accidentally return an object from the constructor?',
+      // And then two more because we retry errors.
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
     ]);
   });
 
@@ -1699,8 +1234,11 @@ describe('ReactCompositeComponent', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<Bad />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<Bad />);
+      });
     }).toErrorDev(
       'It looks like Bad is reassigning its own `this.props` while rendering. ' +
         'This is not supported and can lead to confusing bugs.',
@@ -1710,9 +1248,12 @@ describe('ReactCompositeComponent', () => {
   it('should return error if render is not defined', () => {
     class RenderTestUndefinedRender extends React.Component {}
 
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     expect(() => {
       expect(() => {
-        ReactTestUtils.renderIntoDocument(<RenderTestUndefinedRender />);
+        ReactDOM.flushSync(() => {
+          root.render(<RenderTestUndefinedRender />);
+        });
       }).toThrow();
     }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
@@ -1721,12 +1262,18 @@ describe('ReactCompositeComponent', () => {
         'component instance: you may have forgotten to define `render`.',
       'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
         'component instance: you may have forgotten to define `render`.',
+
+      // And then two more because we retry errors.
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
     ]);
   });
 
   // Regression test for accidental breaking change
   // https://github.com/facebook/react/issues/13580
-  it('should support classes shadowing isReactComponent', () => {
+  it('should support classes shadowing isReactComponent', async () => {
     class Shadow extends React.Component {
       isReactComponent() {}
       render() {
@@ -1734,19 +1281,24 @@ describe('ReactCompositeComponent', () => {
       }
     }
     const container = document.createElement('div');
-    ReactDOM.render(<Shadow />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Shadow />);
+    });
     expect(container.firstChild.tagName).toBe('DIV');
   });
 
-  it('should not warn on updating function component from componentWillMount', () => {
-    let _setState;
+  it('should not warn on updating function component from componentWillMount', async () => {
+    let setState;
+    let ref;
     function A() {
-      _setState = React.useState()[1];
-      return null;
+      const [state, _setState] = React.useState(null);
+      setState = _setState;
+      return <div ref={r => (ref = r)}>{state}</div>;
     }
     class B extends React.Component {
       UNSAFE_componentWillMount() {
-        _setState({});
+        setState(1);
       }
       render() {
         return null;
@@ -1761,18 +1313,25 @@ describe('ReactCompositeComponent', () => {
       );
     }
     const container = document.createElement('div');
-    ReactDOM.render(<Parent />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    expect(ref.textContent).toBe('1');
   });
 
-  it('should not warn on updating function component from componentWillUpdate', () => {
-    let _setState;
+  it('should not warn on updating function component from componentWillUpdate', async () => {
+    let setState;
+    let ref;
     function A() {
-      _setState = React.useState()[1];
-      return null;
+      const [state, _setState] = React.useState();
+      setState = _setState;
+      return <div ref={r => (ref = r)}>{state}</div>;
     }
     class B extends React.Component {
       UNSAFE_componentWillUpdate() {
-        _setState({});
+        setState(1);
       }
       render() {
         return null;
@@ -1787,19 +1346,29 @@ describe('ReactCompositeComponent', () => {
       );
     }
     const container = document.createElement('div');
-    ReactDOM.render(<Parent />, container);
-    ReactDOM.render(<Parent />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    expect(ref.textContent).toBe('1');
   });
 
-  it('should not warn on updating function component from componentWillReceiveProps', () => {
-    let _setState;
+  it('should not warn on updating function component from componentWillReceiveProps', async () => {
+    let setState;
+    let ref;
     function A() {
-      _setState = React.useState()[1];
-      return null;
+      const [state, _setState] = React.useState();
+      setState = _setState;
+      return <div ref={r => (ref = r)}>{state}</div>;
     }
+
     class B extends React.Component {
       UNSAFE_componentWillReceiveProps() {
-        _setState({});
+        setState(1);
       }
       render() {
         return null;
@@ -1814,19 +1383,29 @@ describe('ReactCompositeComponent', () => {
       );
     }
     const container = document.createElement('div');
-    ReactDOM.render(<Parent />, container);
-    ReactDOM.render(<Parent />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    expect(ref.textContent).toBe('1');
   });
 
   it('should warn on updating function component from render', () => {
-    let _setState;
+    let setState;
+    let ref;
     function A() {
-      _setState = React.useState()[1];
-      return null;
+      const [state, _setState] = React.useState(0);
+      setState = _setState;
+      return <div ref={r => (ref = r)}>{state}</div>;
     }
+
     class B extends React.Component {
       render() {
-        _setState({});
+        setState(c => c + 1);
         return null;
       }
     }
@@ -1839,12 +1418,24 @@ describe('ReactCompositeComponent', () => {
       );
     }
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<Parent />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<Parent />);
+      });
     }).toErrorDev(
       'Cannot update a component (`A`) while rendering a different component (`B`)',
     );
+
+    // We error, but still update the state.
+    expect(ref.textContent).toBe('1');
+
     // Dedupe.
-    ReactDOM.render(<Parent />, container);
+    ReactDOM.flushSync(() => {
+      root.render(<Parent />);
+    });
+
+    // We error, but still update the state.
+    expect(ref.textContent).toBe('2');
   });
 });

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index c58e825203..b478f4fe37 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -63,7 +63,6 @@ describe('ReactCompositeComponent', () => {
   }
 
   beforeEach(() => {
-    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index b478f4fe37..c58e825203 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -63,6 +63,7 @@ describe('ReactCompositeComponent', () => {
   }
 
   beforeEach(() => {
+    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');

commit fa2f82addc7c817892c482792f56a35277e8b75a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 20 14:17:41 2024 -0500

    Pass ref as normal prop (#28348)
    
    Depends on:
    
    - #28317
    - #28320
    
    ---
    
    Changes the behavior of the JSX runtime to pass through `ref` as a
    normal prop, rather than plucking it from the props object and storing
    on the element.
    
    This is a breaking change since it changes the type of the receiving
    component. However, most code is unaffected since it's unlikely that a
    component would have attempted to access a `ref` prop, since it was not
    possible to get a reference to one.
    
    `forwardRef` _will_ still pluck `ref` from the props object, though,
    since it's extremely common for users to spread the props object onto
    the inner component and pass `ref` as a differently named prop. This is
    for maximum compatibility with existing code  the real impact of this
    change is that `forwardRef` is no longer required.
    
    Currently, refs are resolved during child reconciliation and stored on
    the fiber. As a result of this change, we can move ref resolution to
    happen only much later, and only for components that actually use them.
    Then we can remove the `ref` field from the Fiber type. I have not yet
    done that in this step, though.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index c58e825203..b3ec748d92 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -278,26 +278,48 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
+    function refFn1(ref) {
+      instance1 = ref;
+    }
+
+    function refFn2(ref) {
+      instance2 = ref;
+    }
+
+    function refFn3(ref) {
+      instance3 = ref;
+    }
+
     let instance1;
     let instance2;
     let instance3;
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await act(() => {
-      root.render(<Component ref={ref => (instance1 = ref)} />);
+      root.render(<Component ref={refFn1} />);
     });
-    expect(instance1.props).toEqual({prop: 'testKey'});
+    if (gate(flags => flags.enableRefAsProp)) {
+      expect(instance1.props).toEqual({prop: 'testKey', ref: refFn1});
+    } else {
+      expect(instance1.props).toEqual({prop: 'testKey'});
+    }
 
     await act(() => {
-      root.render(
-        <Component ref={ref => (instance2 = ref)} prop={undefined} />,
-      );
+      root.render(<Component ref={refFn2} prop={undefined} />);
     });
-    expect(instance2.props).toEqual({prop: 'testKey'});
+    if (gate(flags => flags.enableRefAsProp)) {
+      expect(instance2.props).toEqual({prop: 'testKey', ref: refFn2});
+    } else {
+      expect(instance2.props).toEqual({prop: 'testKey'});
+    }
 
     await act(() => {
-      root.render(<Component ref={ref => (instance3 = ref)} prop={null} />);
+      root.render(<Component ref={refFn3} prop={null} />);
     });
-    expect(instance3.props).toEqual({prop: null});
+    if (gate(flags => flags.enableRefAsProp)) {
+      expect(instance3.props).toEqual({prop: null, ref: refFn3});
+    } else {
+      expect(instance3.props).toEqual({prop: null});
+    }
   });
 
   it('should not mutate passed-in props object', async () => {

commit d579e7748218920331252b0528850943d5e2dd31
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Fri Feb 23 15:16:54 2024 -0500

    Remove method name prefix from warnings and errors (#28432)
    
    This pattern is a petpeeve of mine. I don't consider this best practice
    and so most don't have these prefixes. Very inconsistent.
    
    At best this is useless and noisey that you have to parse because the
    information is also in the stack trace.
    
    At worse these are misleading because they're highlighting something
    internal (like validateDOMNesting) which even suggests an internal bug.
    Even the ones public to React aren't necessarily what you called because
    you might be calling a wrapper around it.
    
    That would be properly reflected in a stack trace - which can also
    properly ignore list so that the first stack you see is your callsite,
    
    Which might be like `render()` in react-testing-library rather than
    `createRoot()` for example.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index b3ec748d92..42d7b3133d 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -879,7 +879,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<Foo idx="qwe" />);
       });
     }).toErrorDev(
-      'Foo(...): When calling super() in `Foo`, make sure to pass ' +
+      'When calling super() in `Foo`, make sure to pass ' +
         "up the same props that your component's constructor was passed.",
     );
   });
@@ -1233,14 +1233,14 @@ describe('ReactCompositeComponent', () => {
     }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
       // Causing the warning to be logged again.
-      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
-      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
       // And then two more because we retry errors.
-      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
-      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
     ]);
   });
@@ -1280,16 +1280,16 @@ describe('ReactCompositeComponent', () => {
     }).toErrorDev([
       // Expect two errors because invokeGuardedCallback will dispatch an error event,
       // Causing the warning to be logged again.
-      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-        'component instance: you may have forgotten to define `render`.',
-      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-        'component instance: you may have forgotten to define `render`.',
+      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+        'you may have forgotten to define `render`.',
+      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+        'you may have forgotten to define `render`.',
 
       // And then two more because we retry errors.
-      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-        'component instance: you may have forgotten to define `render`.',
-      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
-        'component instance: you may have forgotten to define `render`.',
+      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+        'you may have forgotten to define `render`.',
+      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+        'you may have forgotten to define `render`.',
     ]);
   });
 

commit 89021fb4ec9aa82194b0788566e736a4cedfc0e4
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Mar 11 17:17:07 2024 -0700

    Remove invokeGuardedCallback and replay trick (#28515)
    
    We broke the ability to "break on uncaught exceptions" by adding a
    try/catch higher up in the scheduling. We're giving up on fixing that so
    we can remove the replay trick inside an event handler.
    
    The issue with that approach is that we end up double logging a lot of
    errors in DEV since they get reported to the page.
    
    It's also a lot of complexity around this feature.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 42d7b3133d..bf082369e0 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1231,13 +1231,6 @@ describe('ReactCompositeComponent', () => {
         });
       }).toThrow();
     }).toErrorDev([
-      // Expect two errors because invokeGuardedCallback will dispatch an error event,
-      // Causing the warning to be logged again.
-      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?',
-      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?',
-      // And then two more because we retry errors.
       'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
       'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
@@ -1278,14 +1271,6 @@ describe('ReactCompositeComponent', () => {
         });
       }).toThrow();
     }).toErrorDev([
-      // Expect two errors because invokeGuardedCallback will dispatch an error event,
-      // Causing the warning to be logged again.
-      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.',
-      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.',
-
-      // And then two more because we retry errors.
       'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
         'you may have forgotten to define `render`.',
       'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +

commit 6786563f3cbbc9b16d5a8187207b5bd904386e53
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 26 20:44:07 2024 -0700

    [Fiber] Don't Rethrow Errors at the Root (#28627)
    
    Stacked on top of #28498 for test fixes.
    
    ### Don't Rethrow
    
    When we started React it was 1:1 setState calls a series of renders and
    if they error, it errors where the setState was called. Simple. However,
    then batching came and the error actually got thrown somewhere else.
    With concurrent mode, it's not even possible to get setState itself to
    throw anymore.
    
    In fact, all APIs that can rethrow out of React are executed either at
    the root of the scheduler or inside a DOM event handler.
    If you throw inside a React.startTransition callback that's sync, then
    that will bubble out of the startTransition but if you throw inside an
    async callback or a useTransition we now need to handle it at the hook
    site. So in 19 we need to make all React.startTransition swallow the
    error (and report them to reportError).
    
    The only one remaining that can throw is flushSync but it doesn't really
    make sense for it to throw at the callsite neither because batching.
    Just because something rendered in this flush doesn't mean it was
    rendered due to what was just scheduled and doesn't mean that it should
    abort any of the remaining code afterwards. setState is fire and forget.
    It's send an instruction elsewhere, it's not part of the current
    imperative code.
    
    Error boundaries never rethrow. Since you should really always have
    error boundaries, most of the time, it wouldn't rethrow anyway.
    
    Rethrowing also actually currently drops errors on the floor since we
    can only rethrow the first error, so to avoid that we'd need to call
    reportError anyway. This happens in RN events.
    
    The other issue with rethrowing is that it logs an extra console.error.
    Since we're not sure that user code will actually log it anywhere we
    still log it too just like we do with errors inside error boundaries
    which leads all of these to log twice.
    The goal of this PR is to never rethrow out of React instead, errors
    outside of error boundaries get logged to reportError. Event system
    errors too.
    
    ### Breaking Changes
    
    The main thing this affects is testing where you want to inspect the
    errors thrown. To make it easier to port, if you're inside `act` we
    track the error into act in an aggregate error and then rethrow it at
    the root of `act`. Unlike before though, if you flush synchronously
    inside of act it'll still continue until the end of act before
    rethrowing.
    
    I expect most user code breakages would be to migrate from `flushSync`
    to `act` if you assert on throwing.
    
    However, in the React repo we also have `internalAct` and the
    `waitForThrow` helpers. Since these have to use public production
    implementations we track these using the global onerror or process
    uncaughtException. Unlike regular act, includes both event handler
    errors and onRecoverableError by default too. Not just render/commit
    errors. So I had to account for that in our tests.
    
    We restore logging an extra log for uncaught errors after the main log
    with the component stack in it. We use `console.warn`. This is not yet
    ignorable if you preventDefault to the main error event. To avoid
    confusion if you don't end up logging the error to console I just added
    `An error occurred`.
    
    ### Polyfill
    
    All browsers we support really supports `reportError` but not all test
    and server environments do, so I implemented a polyfill for browser and
    node in `shared/reportGlobalError`. I don't love that this is included
    in all builds and gets duplicated into isomorphic even though it's not
    actually needed in production. Maybe in the future we can require a
    polyfill for this.
    
    ### Follow Ups
    
    In a follow up, I'll make caught vs uncaught error handling be
    configurable too.
    
    ---------
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index bf082369e0..561928b24f 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -223,12 +223,12 @@ describe('ReactCompositeComponent', () => {
 
       const el = document.createElement('div');
       const root = ReactDOMClient.createRoot(el);
-      expect(() => {
-        expect(() => {
-          ReactDOM.flushSync(() => {
+      await expect(async () => {
+        await expect(async () => {
+          await act(() => {
             root.render(<Child test="test" />);
           });
-        }).toThrow(
+        }).rejects.toThrow(
           'Objects are not valid as a React child (found: object with keys {render}).',
         );
       }).toErrorDev(
@@ -526,12 +526,12 @@ describe('ReactCompositeComponent', () => {
       }
     }
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      expect(() => {
-        ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await expect(async () => {
+        await act(() => {
           root.render(<ClassWithRenderNotExtended />);
         });
-      }).toThrow(TypeError);
+      }).rejects.toThrow(TypeError);
     }).toErrorDev(
       'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
@@ -539,11 +539,11 @@ describe('ReactCompositeComponent', () => {
     );
 
     // Test deduplication
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<ClassWithRenderNotExtended />);
       });
-    }).toThrow(TypeError);
+    }).rejects.toThrow(TypeError);
   });
 
   it('should warn about `setState` in render', async () => {
@@ -596,11 +596,11 @@ describe('ReactCompositeComponent', () => {
     expect(ReactCurrentOwner.current).toBe(null);
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(instance);
       });
-    }).toThrow();
+    }).rejects.toThrow();
 
     expect(ReactCurrentOwner.current).toBe(null);
   });
@@ -884,7 +884,7 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
-  it('should only call componentWillUnmount once', () => {
+  it('should only call componentWillUnmount once', async () => {
     let app;
     let count = 0;
 
@@ -919,14 +919,14 @@ describe('ReactCompositeComponent', () => {
     };
 
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<App ref={setRef} stage={1} />);
       });
-      ReactDOM.flushSync(() => {
+      await act(() => {
         root.render(<App ref={setRef} stage={2} />);
       });
-    }).toThrow();
+    }).rejects.toThrow();
     expect(count).toBe(1);
   });
 
@@ -1211,7 +1211,7 @@ describe('ReactCompositeComponent', () => {
     assertLog(['setState callback called']);
   });
 
-  it('should return a meaningful warning when constructor is returned', () => {
+  it('should return a meaningful warning when constructor is returned', async () => {
     class RenderTextInvalidConstructor extends React.Component {
       constructor(props) {
         super(props);
@@ -1224,12 +1224,12 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    expect(() => {
-      expect(() => {
-        ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await expect(async () => {
+        await act(() => {
           root.render(<RenderTextInvalidConstructor />);
         });
-      }).toThrow();
+      }).rejects.toThrow();
     }).toErrorDev([
       'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
@@ -1260,16 +1260,16 @@ describe('ReactCompositeComponent', () => {
     );
   });
 
-  it('should return error if render is not defined', () => {
+  it('should return error if render is not defined', async () => {
     class RenderTestUndefinedRender extends React.Component {}
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    expect(() => {
-      expect(() => {
-        ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await expect(async () => {
+        await act(() => {
           root.render(<RenderTestUndefinedRender />);
         });
-      }).toThrow();
+      }).rejects.toThrow();
     }).toErrorDev([
       'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
         'you may have forgotten to define `render`.',

commit cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc
Author: Josh Story <story@hey.com>
Date:   Thu Mar 28 13:08:08 2024 -0700

    Remove module pattern function component support (#27742)
    
    The module pattern
    
    ```
    function MyComponent() {
      return {
        render() {
          return this.state.foo
        }
      }
    }
    ```
    
    has been deprecated for approximately 5 years now. This PR removes
    support for this pattern. It also simplifies a number of code paths in
    particular related to the concept of `IndeterminateComponent` types.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 561928b24f..2e56a911a0 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -211,63 +211,27 @@ describe('ReactCompositeComponent', () => {
     });
   });
 
-  if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
-    it('should not support module pattern components', async () => {
-      function Child({test}) {
-        return {
-          render() {
-            return <div>{test}</div>;
-          },
-        };
-      }
-
-      const el = document.createElement('div');
-      const root = ReactDOMClient.createRoot(el);
-      await expect(async () => {
-        await expect(async () => {
-          await act(() => {
-            root.render(<Child test="test" />);
-          });
-        }).rejects.toThrow(
-          'Objects are not valid as a React child (found: object with keys {render}).',
-        );
-      }).toErrorDev(
-        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-          'Change Child to a class that extends React.Component instead. ' +
-          "If you can't use a class try assigning the prototype on the function as a workaround. " +
-          '`Child.prototype = React.Component.prototype`. ' +
-          "Don't use an arrow function since it cannot be called with `new` by React.",
-      );
-
-      expect(el.textContent).toBe('');
-    });
-  } else {
-    it('should support module pattern components', () => {
-      function Child({test}) {
-        return {
-          render() {
-            return <div>{test}</div>;
-          },
-        };
-      }
+  it('should not support module pattern components', async () => {
+    function Child({test}) {
+      return {
+        render() {
+          return <div>{test}</div>;
+        },
+      };
+    }
 
-      const el = document.createElement('div');
-      const root = ReactDOMClient.createRoot(el);
-      expect(() => {
-        ReactDOM.flushSync(() => {
-          root.render(<Child test="test" />);
-        });
-      }).toErrorDev(
-        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-          'Change Child to a class that extends React.Component instead. ' +
-          "If you can't use a class try assigning the prototype on the function as a workaround. " +
-          '`Child.prototype = React.Component.prototype`. ' +
-          "Don't use an arrow function since it cannot be called with `new` by React.",
-      );
+    const el = document.createElement('div');
+    const root = ReactDOMClient.createRoot(el);
+    await expect(async () => {
+      await act(() => {
+        root.render(<Child test="test" />);
+      });
+    }).rejects.toThrow(
+      'Objects are not valid as a React child (found: object with keys {render}).',
+    );
 
-      expect(el.textContent).toBe('test');
-    });
-  }
+    expect(el.textContent).toBe('');
+  });
 
   it('should use default values for undefined props', async () => {
     class Component extends React.Component {

commit f2690747239533fa266612d2d4dd9ae88ea92fbc
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Mar 29 10:10:11 2024 -0400

    Revert "Remove module pattern function component support" (#28670)
    
    This breaks internal tests, so must be something in the refactor. Since
    it's the top commit let's revert and split into two PRs, one that
    removes the flag and one that does the refactor, so we can find the bug.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 2e56a911a0..561928b24f 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -211,27 +211,63 @@ describe('ReactCompositeComponent', () => {
     });
   });
 
-  it('should not support module pattern components', async () => {
-    function Child({test}) {
-      return {
-        render() {
-          return <div>{test}</div>;
-        },
-      };
-    }
+  if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
+    it('should not support module pattern components', async () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
 
-    const el = document.createElement('div');
-    const root = ReactDOMClient.createRoot(el);
-    await expect(async () => {
-      await act(() => {
-        root.render(<Child test="test" />);
-      });
-    }).rejects.toThrow(
-      'Objects are not valid as a React child (found: object with keys {render}).',
-    );
+      const el = document.createElement('div');
+      const root = ReactDOMClient.createRoot(el);
+      await expect(async () => {
+        await expect(async () => {
+          await act(() => {
+            root.render(<Child test="test" />);
+          });
+        }).rejects.toThrow(
+          'Objects are not valid as a React child (found: object with keys {render}).',
+        );
+      }).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
 
-    expect(el.textContent).toBe('');
-  });
+      expect(el.textContent).toBe('');
+    });
+  } else {
+    it('should support module pattern components', () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
+
+      const el = document.createElement('div');
+      const root = ReactDOMClient.createRoot(el);
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<Child test="test" />);
+        });
+      }).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
+
+      expect(el.textContent).toBe('test');
+    });
+  }
 
   it('should use default values for undefined props', async () => {
     class Component extends React.Component {

commit a73c3450e1b528fa6cb3e94fa4d4359c7a4b61f1
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Mar 29 11:16:17 2024 -0400

    Remove module pattern function component support (flag only) (#28671)
    
    Remove module pattern function component support (flag only)
    
    > This is a redo of #27742, but only including the flag removal,
    excluding further simplifications.
    
    The module pattern
    
    ```
    function MyComponent() {
      return {
        render() {
          return this.state.foo
        }
      }
    }
    ```
    
    has been deprecated for approximately 5 years now. This PR removes
    support for this pattern.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 561928b24f..5959cdefcc 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -211,64 +211,35 @@ describe('ReactCompositeComponent', () => {
     });
   });
 
-  if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
-    it('should not support module pattern components', async () => {
-      function Child({test}) {
-        return {
-          render() {
-            return <div>{test}</div>;
-          },
-        };
-      }
+  it('should not support module pattern components', async () => {
+    function Child({test}) {
+      return {
+        render() {
+          return <div>{test}</div>;
+        },
+      };
+    }
 
-      const el = document.createElement('div');
-      const root = ReactDOMClient.createRoot(el);
+    const el = document.createElement('div');
+    const root = ReactDOMClient.createRoot(el);
+    await expect(async () => {
       await expect(async () => {
-        await expect(async () => {
-          await act(() => {
-            root.render(<Child test="test" />);
-          });
-        }).rejects.toThrow(
-          'Objects are not valid as a React child (found: object with keys {render}).',
-        );
-      }).toErrorDev(
-        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-          'Change Child to a class that extends React.Component instead. ' +
-          "If you can't use a class try assigning the prototype on the function as a workaround. " +
-          '`Child.prototype = React.Component.prototype`. ' +
-          "Don't use an arrow function since it cannot be called with `new` by React.",
-      );
-
-      expect(el.textContent).toBe('');
-    });
-  } else {
-    it('should support module pattern components', () => {
-      function Child({test}) {
-        return {
-          render() {
-            return <div>{test}</div>;
-          },
-        };
-      }
-
-      const el = document.createElement('div');
-      const root = ReactDOMClient.createRoot(el);
-      expect(() => {
-        ReactDOM.flushSync(() => {
+        await act(() => {
           root.render(<Child test="test" />);
         });
-      }).toErrorDev(
-        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-          'Change Child to a class that extends React.Component instead. ' +
-          "If you can't use a class try assigning the prototype on the function as a workaround. " +
-          '`Child.prototype = React.Component.prototype`. ' +
-          "Don't use an arrow function since it cannot be called with `new` by React.",
+      }).rejects.toThrow(
+        'Objects are not valid as a React child (found: object with keys {render}).',
       );
+    }).toErrorDev(
+      'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+        'Change Child to a class that extends React.Component instead. ' +
+        "If you can't use a class try assigning the prototype on the function as a workaround. " +
+        '`Child.prototype = React.Component.prototype`. ' +
+        "Don't use an arrow function since it cannot be called with `new` by React.",
+    );
 
-      expect(el.textContent).toBe('test');
-    });
-  }
-
+    expect(el.textContent).toBe('');
+  });
   it('should use default values for undefined props', async () => {
     class Component extends React.Component {
       static defaultProps = {prop: 'testKey'};

commit 5998a775194f491afa5d3badd9afe9ceaf12845e
Author: Josh Story <story@hey.com>
Date:   Tue Apr 2 17:42:43 2024 -0700

    Reland #28672: Remove IndeterminateComponent (#28681)
    
    This PR relands #28672 on top of the flag removal and the test
    demonstrating a breakage in Suspense for legacy mode.
    
    React has deprecated module pattern Function Components for many years
    at this point. Supporting this pattern required React to have a concept
    of an indeterminate component so that when a component first renders it
    can turn into either a ClassComponent or a FunctionComponent depending
    on what it returns. While this feature was deprecated and put behind a
    flag it is still in stable. This change remvoes the flag, removes the
    warnings, and removes the concept of IndeterminateComponent from the
    React codebase.
    
    While removing IndeterminateComponent type Seb and I discovered that we
    needed a concept of IncompleteFunctionComponent to support Suspense in
    legacy mode. This new work tag is only needed as long as legacy mode is
    around and ideally any code that considers this tag will be excludable
    from OSS builds once we land extra gates using `disableLegacyMode` flag.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 5959cdefcc..2e56a911a0 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -223,23 +223,16 @@ describe('ReactCompositeComponent', () => {
     const el = document.createElement('div');
     const root = ReactDOMClient.createRoot(el);
     await expect(async () => {
-      await expect(async () => {
-        await act(() => {
-          root.render(<Child test="test" />);
-        });
-      }).rejects.toThrow(
-        'Objects are not valid as a React child (found: object with keys {render}).',
-      );
-    }).toErrorDev(
-      'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
-        'Change Child to a class that extends React.Component instead. ' +
-        "If you can't use a class try assigning the prototype on the function as a workaround. " +
-        '`Child.prototype = React.Component.prototype`. ' +
-        "Don't use an arrow function since it cannot be called with `new` by React.",
+      await act(() => {
+        root.render(<Child test="test" />);
+      });
+    }).rejects.toThrow(
+      'Objects are not valid as a React child (found: object with keys {render}).',
     );
 
     expect(el.textContent).toBe('');
   });
+
   it('should use default values for undefined props', async () => {
     class Component extends React.Component {
       static defaultProps = {prop: 'testKey'};

commit dc545c8d6eaca87c8d5cabfab6e1c768ecafe426
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 2 23:15:04 2024 -0400

    Fix: Class components should "consume" ref prop (#28719)
    
    When a ref is passed to a class component, the class instance is
    attached to the ref's current property automatically. This different
    from function components, where you have to do something extra to attach
    a ref to an instance, like passing the ref to `useImperativeHandle`.
    
    Existing class component code is written with the assumption that a ref
    will not be passed through as a prop. For example, class components that
    act as indirections often spread `this.props` onto a child component. To
    maintain this expectation, we should remove the ref from the props
    object ("consume" it) before passing it to lifecycle methods. Without
    this change, much existing code will break because the ref will attach
    to the inner component instead of the outer one.
    
    This is not an issue for function components because we used to warn if
    you passed a ref to a function component. Instead, you had to use
    `forwardRef`, which also implements this "consuming" behavior.
    
    There are a few places in the reconciler where we modify the fiber's
    internal props object before passing it to userspace. The trickiest one
    is class components, because the props object gets exposed in many
    different places, including as a property on the class instance.
    
    This was already accounted for when we added support for setting default
    props on a lazy wrapper (i.e. `React.lazy` that resolves to a class
    component).
    
    In all of these same places, we will also need to remove the ref prop
    when `enableRefAsProp` is on.
    
    Closes #28602
    
    ---------
    
    Co-authored-by: Jan Kassens <jan@kassens.net>

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 2e56a911a0..ba3118bc65 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -261,29 +261,17 @@ describe('ReactCompositeComponent', () => {
     await act(() => {
       root.render(<Component ref={refFn1} />);
     });
-    if (gate(flags => flags.enableRefAsProp)) {
-      expect(instance1.props).toEqual({prop: 'testKey', ref: refFn1});
-    } else {
-      expect(instance1.props).toEqual({prop: 'testKey'});
-    }
+    expect(instance1.props).toEqual({prop: 'testKey'});
 
     await act(() => {
       root.render(<Component ref={refFn2} prop={undefined} />);
     });
-    if (gate(flags => flags.enableRefAsProp)) {
-      expect(instance2.props).toEqual({prop: 'testKey', ref: refFn2});
-    } else {
-      expect(instance2.props).toEqual({prop: 'testKey'});
-    }
+    expect(instance2.props).toEqual({prop: 'testKey'});
 
     await act(() => {
       root.render(<Component ref={refFn3} prop={null} />);
     });
-    if (gate(flags => flags.enableRefAsProp)) {
-      expect(instance3.props).toEqual({prop: null, ref: refFn3});
-    } else {
-      expect(instance3.props).toEqual({prop: null});
-    }
+    expect(instance3.props).toEqual({prop: null});
   });
 
   it('should not mutate passed-in props object', async () => {

commit d50323eb845c5fde0d720cae888bf35dedd05506
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Apr 8 19:23:23 2024 -0400

    Flatten ReactSharedInternals (#28783)
    
    This is similar to #28771 but for isomorphic. We need a make over for
    these dispatchers anyway so this is the first step. Also helps flush out
    some internals usage that will break anyway.
    
    It flattens the inner mutable objects onto the ReactSharedInternals.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index ba3118bc65..030573a380 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -14,7 +14,7 @@ let MorphingComponent;
 let React;
 let ReactDOM;
 let ReactDOMClient;
-let ReactCurrentOwner;
+let ReactSharedInternals;
 let Scheduler;
 let assertLog;
 let act;
@@ -67,9 +67,8 @@ describe('ReactCompositeComponent', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    ReactCurrentOwner =
-      require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
-        .ReactCurrentOwner;
+    ReactSharedInternals =
+      require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
     Scheduler = require('scheduler');
     assertLog = require('internal-test-utils').assertLog;
     act = require('internal-test-utils').act;
@@ -545,7 +544,9 @@ describe('ReactCompositeComponent', () => {
     }
 
     const instance = <BadComponent />;
-    expect(ReactCurrentOwner.current).toBe(null);
+    expect(ReactSharedInternals.owner).toBe(
+      __DEV__ || !gate(flags => flags.disableStringRefs) ? null : undefined,
+    );
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
@@ -554,7 +555,9 @@ describe('ReactCompositeComponent', () => {
       });
     }).rejects.toThrow();
 
-    expect(ReactCurrentOwner.current).toBe(null);
+    expect(ReactSharedInternals.owner).toBe(
+      __DEV__ || !gate(flags => flags.disableStringRefs) ? null : undefined,
+    );
   });
 
   it('should call componentWillUnmount before unmounting', async () => {

commit f6131653570bbbf62d642ba9343b9cd0ab1ae97c
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Apr 9 12:20:22 2024 -0400

    Rename SECRET INTERNALS to `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE` (#28789)
    
    Follow up to #28783 and #28786.
    
    Since we've changed the implementations of these we can rename them to
    something a bit more descriptive while we're at it, since anyone
    depending on them will need to upgrade their code anyway.
    
    "react" with no condition:
    `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react" with "react-server" condition:
    `__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react-dom":
    `__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 030573a380..e098c93ca7 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -68,7 +68,7 @@ describe('ReactCompositeComponent', () => {
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
     ReactSharedInternals =
-      require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+      require('react').__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     Scheduler = require('scheduler');
     assertLog = require('internal-test-utils').assertLog;
     act = require('internal-test-utils').act;

commit 42eff4bc78a3636953c55096ca0b220c611a74cc
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 10 10:33:41 2024 -0400

    [tests] Fix assertions not flushed before act (#28745)
    
    Fixes some easy cases blocking
    https://github.com/facebook/react/pull/28737, I'll follow up with more
    complex/interesting cases in other PRs.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index e098c93ca7..4630f9ddbc 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -913,15 +913,13 @@ describe('ReactCompositeComponent', () => {
     await act(() => {
       root.render(<Wrapper name="A" />);
     });
+
+    assertLog(['A componentWillMount', 'A render', 'A componentDidMount']);
     await act(() => {
       root.render(<Wrapper name="B" />);
     });
 
     assertLog([
-      'A componentWillMount',
-      'A render',
-      'A componentDidMount',
-
       'B componentWillMount',
       'B render',
       'A componentWillUnmount',

commit 94eed63c49d989861ae7cd62e111de6d717f0a10
Author: Josh Story <story@hey.com>
Date:   Thu Apr 25 10:40:40 2024 -0700

    (Land #28798) Move Current Owner (and Cache) to an Async Dispatcher (#28912)
    
    Rebasing and landing https://github.com/facebook/react/pull/28798
    
    This PR was approved already but held back to give time for the sync.
    Rebased and landing here without pushing to seb's remote to avoid
    possibility of lost updates
    
    ---------
    
    Co-authored-by: Sebastian Markbage <sebastian@calyptus.eu>

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 4630f9ddbc..894afb39ba 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -537,16 +537,24 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should cleanup even if render() fatals', async () => {
+    const dispatcherEnabled =
+      __DEV__ ||
+      !gate(flags => flags.disableStringRefs) ||
+      gate(flags => flags.enableCache);
+    const ownerEnabled = __DEV__ || !gate(flags => flags.disableStringRefs);
+
+    let stashedDispatcher;
     class BadComponent extends React.Component {
       render() {
+        // Stash the dispatcher that was available in render so we can check
+        // that its internals also reset.
+        stashedDispatcher = ReactSharedInternals.A;
         throw new Error();
       }
     }
 
     const instance = <BadComponent />;
-    expect(ReactSharedInternals.owner).toBe(
-      __DEV__ || !gate(flags => flags.disableStringRefs) ? null : undefined,
-    );
+    expect(ReactSharedInternals.A).toBe(dispatcherEnabled ? null : undefined);
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
@@ -555,9 +563,16 @@ describe('ReactCompositeComponent', () => {
       });
     }).rejects.toThrow();
 
-    expect(ReactSharedInternals.owner).toBe(
-      __DEV__ || !gate(flags => flags.disableStringRefs) ? null : undefined,
-    );
+    expect(ReactSharedInternals.A).toBe(dispatcherEnabled ? null : undefined);
+    if (dispatcherEnabled) {
+      if (ownerEnabled) {
+        expect(stashedDispatcher.getOwner()).toBe(null);
+      } else {
+        expect(stashedDispatcher.getOwner).toBe(undefined);
+      }
+    } else {
+      expect(stashedDispatcher).toBe(undefined);
+    }
   });
 
   it('should call componentWillUnmount before unmounting', async () => {

commit 277420803947724b43c47bbc47d3a353553868f1
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Jun 10 18:41:56 2024 -0400

    Remove Warning: prefix and toString on console Arguments (#29839)
    
    Basically make `console.error` and `console.warn` behave like normal -
    when a component stack isn't appended. I need this because I need to be
    able to print rich logs with the component stack option and to be able
    to disable instrumentation completely in `console.createTask`
    environments that don't need it.
    
    Currently we can't print logs with richer objects because they're
    toString:ed first. In practice, pretty much all arguments we log are
    already toString:ed so it's not necessary anyway. Some might be like a
    number. So it would only be a problem if some environment can't handle
    proper consoles but then it's up to that environment to toString it
    before logging.
    
    The `Warning: ` prefix is historic and is both noisy and confusing. It's
    mostly unnecessary since the UI surrounding `console.error` and
    `console.warn` tend to have visual treatment around it anyway. However,
    it's actively misleading when `console.error` gets prefixed with a
    Warning that we consider an error level. There's an argument to be made
    that some of our `console.error` don't make the bar for an error but
    then the argument is to downgrade each of those to `console.warn` - not
    to brand all our actual error logging with `Warning: `.
    
    Apparently something needs to change in React Native before landing this
    because it depends on the prefix somehow which probably doesn't make
    sense already.

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 894afb39ba..89d0b83abc 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -313,7 +313,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<MyComponent />);
       });
     }).toErrorDev(
-      "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
+      "Can't call forceUpdate on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
@@ -347,7 +347,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<MyComponent />);
       });
     }).toErrorDev(
-      "Warning: Can't call setState on a component that is not yet mounted. " +
+      "Can't call setState on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
         'class property with the desired state in the MyComponent component.',
@@ -484,7 +484,7 @@ describe('ReactCompositeComponent', () => {
         });
       }).rejects.toThrow(TypeError);
     }).toErrorDev(
-      'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+      'The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
         'Change ClassWithRenderNotExtended to extend React.Component instead.',
     );
@@ -631,7 +631,7 @@ describe('ReactCompositeComponent', () => {
         instance.setState({bogus: true});
       });
     }).toErrorDev(
-      'Warning: ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
+      'ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
         'boolean value. Make sure to return true or false.',
     );
   });
@@ -651,7 +651,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<Component />);
       });
     }).toErrorDev(
-      'Warning: Component has a method called ' +
+      'Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
         'Did you mean componentWillUnmount()?',
     );
@@ -673,7 +673,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<Component />);
       });
     }).toErrorDev(
-      'Warning: Component has a method called ' +
+      'Component has a method called ' +
         'componentDidReceiveProps(). But there is no such lifecycle method. ' +
         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
@@ -699,7 +699,7 @@ describe('ReactCompositeComponent', () => {
         root.render(<Component />);
       });
     }).toErrorDev(
-      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+      'Setting defaultProps as an instance property on Component is not supported ' +
         'and will be ignored. Instead, define defaultProps as a static property on Component.',
     );
   });
@@ -1199,9 +1199,9 @@ describe('ReactCompositeComponent', () => {
         });
       }).rejects.toThrow();
     }).toErrorDev([
-      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
+      'No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
-      'Warning: No `render` method found on the RenderTextInvalidConstructor instance: ' +
+      'No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?',
     ]);
   });
@@ -1239,9 +1239,9 @@ describe('ReactCompositeComponent', () => {
         });
       }).rejects.toThrow();
     }).toErrorDev([
-      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+      'No `render` method found on the RenderTestUndefinedRender instance: ' +
         'you may have forgotten to define `render`.',
-      'Warning: No `render` method found on the RenderTestUndefinedRender instance: ' +
+      'No `render` method found on the RenderTestUndefinedRender instance: ' +
         'you may have forgotten to define `render`.',
     ]);
   });

commit e1378902bbb322aa1fe1953780f4b2b5f80d26b1
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Nov 6 14:00:10 2024 -0500

    [string-refs] cleanup string ref code (#31443)

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 89d0b83abc..4444076681 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -537,11 +537,8 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should cleanup even if render() fatals', async () => {
-    const dispatcherEnabled =
-      __DEV__ ||
-      !gate(flags => flags.disableStringRefs) ||
-      gate(flags => flags.enableCache);
-    const ownerEnabled = __DEV__ || !gate(flags => flags.disableStringRefs);
+    const dispatcherEnabled = __DEV__ || gate(flags => flags.enableCache);
+    const ownerEnabled = __DEV__;
 
     let stashedDispatcher;
     class BadComponent extends React.Component {

commit e06c72fcf4632ad3117add713a25f6354631f037
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Dec 15 12:34:08 2024 -0500

    [flags] Cleanup enableCache (#31778)
    
    This is landed everywhere

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 4444076681..30b5ced5cf 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -537,7 +537,6 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should cleanup even if render() fatals', async () => {
-    const dispatcherEnabled = __DEV__ || gate(flags => flags.enableCache);
     const ownerEnabled = __DEV__;
 
     let stashedDispatcher;
@@ -551,7 +550,7 @@ describe('ReactCompositeComponent', () => {
     }
 
     const instance = <BadComponent />;
-    expect(ReactSharedInternals.A).toBe(dispatcherEnabled ? null : undefined);
+    expect(ReactSharedInternals.A).toBe(null);
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
@@ -560,15 +559,11 @@ describe('ReactCompositeComponent', () => {
       });
     }).rejects.toThrow();
 
-    expect(ReactSharedInternals.A).toBe(dispatcherEnabled ? null : undefined);
-    if (dispatcherEnabled) {
-      if (ownerEnabled) {
-        expect(stashedDispatcher.getOwner()).toBe(null);
-      } else {
-        expect(stashedDispatcher.getOwner).toBe(undefined);
-      }
+    expect(ReactSharedInternals.A).toBe(null);
+    if (ownerEnabled) {
+      expect(stashedDispatcher.getOwner()).toBe(null);
     } else {
-      expect(stashedDispatcher).toBe(undefined);
+      expect(stashedDispatcher.getOwner).toBe(undefined);
     }
   });
 

commit a7c898d83a991c48f3981fcc65d969f1d90d80a1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jan 2 15:28:06 2025 -0500

    [assert helpers] react-dom (pt 1) (#31897)
    
    Converts ~half of react-dom tests

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 30b5ced5cf..3d5f61c1ed 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -18,6 +18,7 @@ let ReactSharedInternals;
 let Scheduler;
 let assertLog;
 let act;
+let assertConsoleErrorDev;
 
 describe('ReactCompositeComponent', () => {
   const hasOwnProperty = Object.prototype.hasOwnProperty;
@@ -71,7 +72,7 @@ describe('ReactCompositeComponent', () => {
       require('react').__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     Scheduler = require('scheduler');
     assertLog = require('internal-test-utils').assertLog;
-    act = require('internal-test-utils').act;
+    ({act, assertConsoleErrorDev} = require('internal-test-utils'));
   });
 
   describe('MorphingComponent', () => {
@@ -308,16 +309,16 @@ describe('ReactCompositeComponent', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<MyComponent />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<MyComponent />);
+    });
+    assertConsoleErrorDev([
       "Can't call forceUpdate on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
-        'class property with the desired state in the MyComponent component.',
-    );
+        'class property with the desired state in the MyComponent component.\n' +
+        '    in MyComponent (at **)',
+    ]);
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
@@ -342,16 +343,16 @@ describe('ReactCompositeComponent', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<MyComponent />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<MyComponent />);
+    });
+    assertConsoleErrorDev([
       "Can't call setState on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
-        'class property with the desired state in the MyComponent component.',
-    );
+        'class property with the desired state in the MyComponent component.\n' +
+        '    in MyComponent (at **)',
+    ]);
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
@@ -478,16 +479,16 @@ describe('ReactCompositeComponent', () => {
     }
     const root = ReactDOMClient.createRoot(container);
     await expect(async () => {
-      await expect(async () => {
-        await act(() => {
-          root.render(<ClassWithRenderNotExtended />);
-        });
-      }).rejects.toThrow(TypeError);
-    }).toErrorDev(
+      await act(() => {
+        root.render(<ClassWithRenderNotExtended />);
+      });
+    }).rejects.toThrow(TypeError);
+    assertConsoleErrorDev([
       'The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
-        'Change ClassWithRenderNotExtended to extend React.Component instead.',
-    );
+        'Change ClassWithRenderNotExtended to extend React.Component instead.\n' +
+        '    in ClassWithRenderNotExtended (at **)',
+    ]);
 
     // Test deduplication
     await expect(async () => {
@@ -514,14 +515,14 @@ describe('ReactCompositeComponent', () => {
 
     let instance;
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Component ref={ref => (instance = ref)} />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Component ref={ref => (instance = ref)} />);
+    });
+    assertConsoleErrorDev([
       'Cannot update during an existing state transition (such as within ' +
-        '`render`). Render methods should be a pure function of props and state.',
-    );
+        '`render`). Render methods should be a pure function of props and state.\n' +
+        '    in Component (at **)',
+    ]);
 
     // The setState call is queued and then executed as a second pass. This
     // behavior is undefined though so we're free to change it to suit the
@@ -618,14 +619,14 @@ describe('ReactCompositeComponent', () => {
       root.render(<ClassComponent ref={ref => (instance = ref)} />);
     });
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        instance.setState({bogus: true});
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      instance.setState({bogus: true});
+    });
+    assertConsoleErrorDev([
       'ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
-        'boolean value. Make sure to return true or false.',
-    );
+        'boolean value. Make sure to return true or false.\n' +
+        '    in ClassComponent (at **)',
+    ]);
   });
 
   it('should warn when componentDidUnmount method is defined', async () => {
@@ -638,15 +639,15 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Component />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Component />);
+    });
+    assertConsoleErrorDev([
       'Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
-        'Did you mean componentWillUnmount()?',
-    );
+        'Did you mean componentWillUnmount()?\n' +
+        '    in Component (at **)',
+    ]);
   });
 
   it('should warn when componentDidReceiveProps method is defined', () => {
@@ -660,17 +661,17 @@ describe('ReactCompositeComponent', () => {
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Component />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Component />);
+    });
+    assertConsoleErrorDev([
       'Component has a method called ' +
         'componentDidReceiveProps(). But there is no such lifecycle method. ' +
         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
-        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
-    );
+        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().\n' +
+        '    in Component (at **)',
+    ]);
   });
 
   it('should warn when defaultProps was defined as an instance property', () => {
@@ -686,14 +687,14 @@ describe('ReactCompositeComponent', () => {
     }
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Component />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Component />);
+    });
+    assertConsoleErrorDev([
       'Setting defaultProps as an instance property on Component is not supported ' +
-        'and will be ignored. Instead, define defaultProps as a static property on Component.',
-    );
+        'and will be ignored. Instead, define defaultProps as a static property on Component.\n' +
+        '    in Component (at **)',
+    ]);
   });
 
   it('should skip update when rerendering element in container', async () => {
@@ -739,16 +740,16 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Outer />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Outer />);
+    });
+    assertConsoleErrorDev([
       'Render methods should be a pure function of props and state; ' +
         'triggering nested component updates from render is not allowed. If ' +
-        'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
-        'render method of Outer.',
-    );
+        'necessary, trigger nested updates in componentDidUpdate.\n\n' +
+        'Check the render method of Outer.\n' +
+        '    in Outer (at **)',
+    ]);
   });
 
   it('only renders once if updated in componentWillReceiveProps', async () => {
@@ -836,14 +837,14 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Foo idx="qwe" />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Foo idx="qwe" />);
+    });
+    assertConsoleErrorDev([
       'When calling super() in `Foo`, make sure to pass ' +
-        "up the same props that your component's constructor was passed.",
-    );
+        "up the same props that your component's constructor was passed.\n" +
+        '    in Foo (at **)',
+    ]);
   });
 
   it('should only call componentWillUnmount once', async () => {
@@ -1185,16 +1186,17 @@ describe('ReactCompositeComponent', () => {
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
-      await expect(async () => {
-        await act(() => {
-          root.render(<RenderTextInvalidConstructor />);
-        });
-      }).rejects.toThrow();
-    }).toErrorDev([
+      await act(() => {
+        root.render(<RenderTextInvalidConstructor />);
+      });
+    }).rejects.toThrow();
+    assertConsoleErrorDev([
       'No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?',
+        'did you accidentally return an object from the constructor?\n' +
+        '    in RenderTextInvalidConstructor (at **)',
       'No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?',
+        'did you accidentally return an object from the constructor?\n' +
+        '    in RenderTextInvalidConstructor (at **)',
     ]);
   });
 
@@ -1210,14 +1212,14 @@ describe('ReactCompositeComponent', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Bad />);
-      });
-    }).toErrorDev(
+    ReactDOM.flushSync(() => {
+      root.render(<Bad />);
+    });
+    assertConsoleErrorDev([
       'It looks like Bad is reassigning its own `this.props` while rendering. ' +
-        'This is not supported and can lead to confusing bugs.',
-    );
+        'This is not supported and can lead to confusing bugs.\n' +
+        '    in Bad (at **)',
+    ]);
   });
 
   it('should return error if render is not defined', async () => {
@@ -1225,16 +1227,17 @@ describe('ReactCompositeComponent', () => {
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
-      await expect(async () => {
-        await act(() => {
-          root.render(<RenderTestUndefinedRender />);
-        });
-      }).rejects.toThrow();
-    }).toErrorDev([
+      await act(() => {
+        root.render(<RenderTestUndefinedRender />);
+      });
+    }).rejects.toThrow();
+    assertConsoleErrorDev([
       'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.',
+        'you may have forgotten to define `render`.\n' +
+        '    in RenderTestUndefinedRender (at **)',
       'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.',
+        'you may have forgotten to define `render`.\n' +
+        '    in RenderTestUndefinedRender (at **)',
     ]);
   });
 
@@ -1386,13 +1389,18 @@ describe('ReactCompositeComponent', () => {
     }
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<Parent />);
-      });
-    }).toErrorDev(
-      'Cannot update a component (`A`) while rendering a different component (`B`)',
-    );
+    ReactDOM.flushSync(() => {
+      root.render(<Parent />);
+    });
+    assertConsoleErrorDev([
+      'Cannot update a component (`A`) while rendering a different component (`B`). ' +
+        'To locate the bad setState() call inside `B`, ' +
+        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
+        (gate('enableOwnerStacks')
+          ? ''
+          : '    in B (at **)\n' + '    in div (at **)\n') +
+        '    in Parent (at **)',
+    ]);
 
     // We error, but still update the state.
     expect(ref.textContent).toBe('1');

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
index 3d5f61c1ed..5a70daef06 100644
--- a/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
+++ b/packages/react-dom/src/__tests__/ReactCompositeComponent-test.js
@@ -1396,9 +1396,6 @@ describe('ReactCompositeComponent', () => {
       'Cannot update a component (`A`) while rendering a different component (`B`). ' +
         'To locate the bad setState() call inside `B`, ' +
         'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        (gate('enableOwnerStacks')
-          ? ''
-          : '    in B (at **)\n' + '    in div (at **)\n') +
         '    in Parent (at **)',
     ]);
 

