# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a ‚Äúcore‚Äù library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we‚Äôve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
new file mode 100644
index 000000000..66b24bb29
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -0,0 +1,207 @@
+import {
+	BaseBoxShapeUtil,
+	HTMLContainer,
+	TLVideoShape,
+	toDomPrecision,
+	track,
+	useIsEditing,
+	videoShapeMigrations,
+	videoShapeProps,
+} from '@tldraw/editor'
+import React from 'react'
+import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
+
+/** @public */
+export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
+	static override type = 'video' as const
+	static override props = videoShapeProps
+	static override migrations = videoShapeMigrations
+
+	override canEdit = () => true
+	override isAspectRatioLocked = () => true
+
+	override getDefaultProps(): TLVideoShape['props'] {
+		return {
+			w: 100,
+			h: 100,
+			assetId: null,
+			time: 0,
+			playing: true,
+			url: '',
+		}
+	}
+
+	component(shape: TLVideoShape) {
+		return <TLVideoUtilComponent shape={shape} videoUtil={this} />
+	}
+
+	indicator(shape: TLVideoShape) {
+		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
+	}
+
+	override toSvg(shape: TLVideoShape) {
+		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
+		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', serializeVideo(shape.id))
+		image.setAttribute('width', shape.props.w.toString())
+		image.setAttribute('height', shape.props.h.toString())
+		g.appendChild(image)
+
+		return g
+	}
+}
+
+// Function from v1, could be improved bu explicitly using this.model.time (?)
+function serializeVideo(id: string): string {
+	const splitId = id.split(':')[1]
+	const video = document.querySelector(`.tl-video-shape-${splitId}`) as HTMLVideoElement
+	if (video) {
+		const canvas = document.createElement('canvas')
+		canvas.width = video.videoWidth
+		canvas.height = video.videoHeight
+		canvas.getContext('2d')!.drawImage(video, 0, 0)
+		return canvas.toDataURL('image/png')
+	} else throw new Error('Video with id ' + splitId + ' not found')
+}
+
+const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
+	shape: TLVideoShape
+	videoUtil: VideoShapeUtil
+}) {
+	const { shape, videoUtil } = props
+	const showControls = videoUtil.editor.getBounds(shape).w * videoUtil.editor.zoomLevel >= 110
+	const asset = shape.props.assetId ? videoUtil.editor.getAssetById(shape.props.assetId) : null
+	const { time, playing } = shape.props
+	const isEditing = useIsEditing(shape.id)
+	const prefersReducedMotion = usePrefersReducedMotion()
+
+	const rVideo = React.useRef<HTMLVideoElement>(null!)
+
+	const handlePlay = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
+		(e) => {
+			const video = e.currentTarget
+
+			videoUtil.editor.updateShapes([
+				{
+					type: 'video',
+					id: shape.id,
+					props: {
+						playing: true,
+						time: video.currentTime,
+					},
+				},
+			])
+		},
+		[shape.id, videoUtil.editor]
+	)
+
+	const handlePause = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
+		(e) => {
+			const video = e.currentTarget
+
+			videoUtil.editor.updateShapes([
+				{
+					type: 'video',
+					id: shape.id,
+					props: {
+						playing: false,
+						time: video.currentTime,
+					},
+				},
+			])
+		},
+		[shape.id, videoUtil.editor]
+	)
+
+	const handleSetCurrentTime = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
+		(e) => {
+			const video = e.currentTarget
+
+			if (isEditing) {
+				videoUtil.editor.updateShapes([
+					{
+						type: 'video',
+						id: shape.id,
+						props: {
+							time: video.currentTime,
+						},
+					},
+				])
+			}
+		},
+		[isEditing, shape.id, videoUtil.editor]
+	)
+
+	const [isLoaded, setIsLoaded] = React.useState(false)
+
+	const handleLoadedData = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
+		(e) => {
+			const video = e.currentTarget
+			if (time !== video.currentTime) {
+				video.currentTime = time
+			}
+
+			if (!playing) {
+				video.pause()
+			}
+
+			setIsLoaded(true)
+		},
+		[playing, time]
+	)
+
+	// If the current time changes and we're not editing the video, update the video time
+	React.useEffect(() => {
+		const video = rVideo.current
+
+		if (!video) return
+
+		if (isLoaded && !isEditing && time !== video.currentTime) {
+			video.currentTime = time
+		}
+	}, [isEditing, isLoaded, time])
+
+	React.useEffect(() => {
+		if (prefersReducedMotion) {
+			const video = rVideo.current
+			video.pause()
+			video.currentTime = 0
+		}
+	}, [rVideo, prefersReducedMotion])
+
+	return (
+		<>
+			<HTMLContainer id={shape.id}>
+				<div className="tl-counter-scaled">
+					{asset?.props.src ? (
+						<video
+							ref={rVideo}
+							className={`tl-video tl-video-shape-${shape.id.split(':')[1]} tl-hitarea-stroke`}
+							width="100%"
+							height="100%"
+							draggable={false}
+							playsInline
+							autoPlay
+							muted
+							loop
+							disableRemotePlayback
+							disablePictureInPicture
+							controls={isEditing && showControls}
+							onPlay={handlePlay}
+							onPause={handlePause}
+							onTimeUpdate={handleSetCurrentTime}
+							onLoadedData={handleLoadedData}
+							hidden={!isLoaded}
+						>
+							<source src={asset.props.src} />
+						</video>
+					) : null}
+				</div>
+			</HTMLContainer>
+			{'url' in shape.props && shape.props.url && (
+				<HyperlinkButton url={shape.props.url} zoomLevel={videoUtil.editor.zoomLevel} />
+			)}
+		</>
+	)
+})

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape‚Äîbut not focusing its input‚Äîwhile editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 66b24bb29..98d4a1383 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -70,8 +70,9 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 	videoUtil: VideoShapeUtil
 }) {
 	const { shape, videoUtil } = props
-	const showControls = videoUtil.editor.getBounds(shape).w * videoUtil.editor.zoomLevel >= 110
-	const asset = shape.props.assetId ? videoUtil.editor.getAssetById(shape.props.assetId) : null
+	const showControls =
+		videoUtil.editor.getGeometry(shape).bounds.w * videoUtil.editor.zoomLevel >= 110
+	const asset = shape.props.assetId ? videoUtil.editor.getAsset(shape.props.assetId) : null
 	const { time, playing } = shape.props
 	const isEditing = useIsEditing(shape.id)
 	const prefersReducedMotion = usePrefersReducedMotion()
@@ -177,7 +178,7 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 					{asset?.props.src ? (
 						<video
 							ref={rVideo}
-							className={`tl-video tl-video-shape-${shape.id.split(':')[1]} tl-hitarea-stroke`}
+							className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
 							width="100%"
 							height="100%"
 							draggable={false}

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 98d4a1383..ab3da4399 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -71,7 +71,7 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 }) {
 	const { shape, videoUtil } = props
 	const showControls =
-		videoUtil.editor.getGeometry(shape).bounds.w * videoUtil.editor.zoomLevel >= 110
+		videoUtil.editor.getShapeGeometry(shape).bounds.w * videoUtil.editor.zoomLevel >= 110
 	const asset = shape.props.assetId ? videoUtil.editor.getAsset(shape.props.assetId) : null
 	const { time, playing } = shape.props
 	const isEditing = useIsEditing(shape.id)

commit 57b2cf69557584d4e05985dc843b1e043164f62f
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Aug 25 07:49:06 2023 +0200

    [fix] editing video shapes (#1821)
    
    This PR fixes editing video shapes. The controls are now interactive
    again.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Create a video shape.
    2. Double click to edit the shape.
    3. Use the controls to pause, change time, etc.
    
    ### Release Notes
    
    - Fix bug with editing video shapes.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index ab3da4399..3e33ddf86 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -161,6 +161,12 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 		if (isLoaded && !isEditing && time !== video.currentTime) {
 			video.currentTime = time
 		}
+
+		if (isEditing) {
+			if (document.activeElement !== video) {
+				video.focus()
+			}
+		}
 	}, [isEditing, isLoaded, time])
 
 	React.useEffect(() => {

commit 5458362829f9cd9b2dd3e8d29ff2b1615c43180f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Sep 18 15:36:48 2023 +0100

    Fix video shape controls (#1909)
    
    The video shape was not interactive in it's editing mode, so I just
    updated it to have `pointer-events: all` when editing.
    
    closes #1908
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixes pointer events for editing video shapes.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 3e33ddf86..f687feda7 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -184,6 +184,7 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 					{asset?.props.src ? (
 						<video
 							ref={rVideo}
+							style={isEditing ? { pointerEvents: 'all' } : undefined}
 							className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
 							width="100%"
 							height="100%"

commit 6f872c796afd6cf538ce81d35c5a40dcccbe7013
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 11:57:43 2023 +0000

    No impure getters pt6 (#2218)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index f687feda7..3c0b31c81 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -71,7 +71,7 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 }) {
 	const { shape, videoUtil } = props
 	const showControls =
-		videoUtil.editor.getShapeGeometry(shape).bounds.w * videoUtil.editor.zoomLevel >= 110
+		videoUtil.editor.getShapeGeometry(shape).bounds.w * videoUtil.editor.getZoomLevel() >= 110
 	const asset = shape.props.assetId ? videoUtil.editor.getAsset(shape.props.assetId) : null
 	const { time, playing } = shape.props
 	const isEditing = useIsEditing(shape.id)
@@ -208,7 +208,7 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 				</div>
 			</HTMLContainer>
 			{'url' in shape.props && shape.props.url && (
-				<HyperlinkButton url={shape.props.url} zoomLevel={videoUtil.editor.zoomLevel} />
+				<HyperlinkButton url={shape.props.url} zoomLevel={videoUtil.editor.getZoomLevel()} />
 			)}
 		</>
 	)

commit a03edcff9d65780a3c0109e152c724358cc71058
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Wed Feb 7 16:30:46 2024 +0000

    error reporting: rm ids from msgs for better Sentry grouping (#2738)
    
    This removes the ids from shape paths so that they can be grouped on our
    error reporting tool.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Release Notes
    
    - Error reporting: improve grouping for Sentry.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 3c0b31c81..8c0a5b43f 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -52,7 +52,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 }
 
-// Function from v1, could be improved bu explicitly using this.model.time (?)
+// Function from v1, could be improved but explicitly using this.model.time (?)
 function serializeVideo(id: string): string {
 	const splitId = id.split(':')[1]
 	const video = document.querySelector(`.tl-video-shape-${splitId}`) as HTMLVideoElement
@@ -62,7 +62,7 @@ function serializeVideo(id: string): string {
 		canvas.height = video.videoHeight
 		canvas.getContext('2d')!.drawImage(video, 0, 0)
 		return canvas.toDataURL('image/png')
-	} else throw new Error('Video with id ' + splitId + ' not found')
+	} else throw new Error('Video with not found when attempting serialization.')
 }
 
 const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {

commit 4cc823e22eab5d9e751a32c958e83d28d9eb8ec4
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Mar 1 18:16:27 2024 +0000

    Show a broken image for files without assets (#2990)
    
    This PR shows a broken state for images or video shapes without assets.
    It deletes assets when pasted content fails to generate a new asset for
    the shape. It includes some mild refactoring to the image shape.
    Previously, shapes that had no corresponding assets would be
    transparent. This PR preserves the transparent state for shapes with
    assets but without source data (ie loading assets).
    
    After:
    <img width="1062" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/81ad6953-a45f-4cc2-9f39-559009621a82">
    <img width="1158" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/40d15158-d201-458f-b555-6f3d8708a283">
    
    Before:
    <img width="1178" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/2bed5b3c-cf1f-48be-9c68-d15fdccb9c99">
    
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Create an image / video
    2. Delete its asset
    
    ### Release Notes
    
    - Better handling of broken images / videos.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 8c0a5b43f..8c0ffb493 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -1,14 +1,15 @@
+/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
 	HTMLContainer,
 	TLVideoShape,
 	toDomPrecision,
-	track,
 	useIsEditing,
 	videoShapeMigrations,
 	videoShapeProps,
 } from '@tldraw/editor'
-import React from 'react'
+import { ReactEventHandler, useCallback, useEffect, useRef, useState } from 'react'
+import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
@@ -33,154 +34,124 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 
 	component(shape: TLVideoShape) {
-		return <TLVideoUtilComponent shape={shape} videoUtil={this} />
-	}
+		const { editor } = this
+		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
+		const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : null
+		const { time, playing } = shape.props
+		const isEditing = useIsEditing(shape.id)
+		const prefersReducedMotion = usePrefersReducedMotion()
 
-	indicator(shape: TLVideoShape) {
-		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
-	}
+		const rVideo = useRef<HTMLVideoElement>(null!)
 
-	override toSvg(shape: TLVideoShape) {
-		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
-		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', serializeVideo(shape.id))
-		image.setAttribute('width', shape.props.w.toString())
-		image.setAttribute('height', shape.props.h.toString())
-		g.appendChild(image)
-
-		return g
-	}
-}
-
-// Function from v1, could be improved but explicitly using this.model.time (?)
-function serializeVideo(id: string): string {
-	const splitId = id.split(':')[1]
-	const video = document.querySelector(`.tl-video-shape-${splitId}`) as HTMLVideoElement
-	if (video) {
-		const canvas = document.createElement('canvas')
-		canvas.width = video.videoWidth
-		canvas.height = video.videoHeight
-		canvas.getContext('2d')!.drawImage(video, 0, 0)
-		return canvas.toDataURL('image/png')
-	} else throw new Error('Video with not found when attempting serialization.')
-}
+		const handlePlay = useCallback<ReactEventHandler<HTMLVideoElement>>(
+			(e) => {
+				const video = e.currentTarget
 
-const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
-	shape: TLVideoShape
-	videoUtil: VideoShapeUtil
-}) {
-	const { shape, videoUtil } = props
-	const showControls =
-		videoUtil.editor.getShapeGeometry(shape).bounds.w * videoUtil.editor.getZoomLevel() >= 110
-	const asset = shape.props.assetId ? videoUtil.editor.getAsset(shape.props.assetId) : null
-	const { time, playing } = shape.props
-	const isEditing = useIsEditing(shape.id)
-	const prefersReducedMotion = usePrefersReducedMotion()
-
-	const rVideo = React.useRef<HTMLVideoElement>(null!)
-
-	const handlePlay = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
-		(e) => {
-			const video = e.currentTarget
-
-			videoUtil.editor.updateShapes([
-				{
-					type: 'video',
-					id: shape.id,
-					props: {
-						playing: true,
-						time: video.currentTime,
-					},
-				},
-			])
-		},
-		[shape.id, videoUtil.editor]
-	)
-
-	const handlePause = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
-		(e) => {
-			const video = e.currentTarget
-
-			videoUtil.editor.updateShapes([
-				{
-					type: 'video',
-					id: shape.id,
-					props: {
-						playing: false,
-						time: video.currentTime,
+				editor.updateShapes([
+					{
+						type: 'video',
+						id: shape.id,
+						props: {
+							playing: true,
+							time: video.currentTime,
+						},
 					},
-				},
-			])
-		},
-		[shape.id, videoUtil.editor]
-	)
+				])
+			},
+			[shape.id, editor]
+		)
 
-	const handleSetCurrentTime = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
-		(e) => {
-			const video = e.currentTarget
+		const handlePause = useCallback<ReactEventHandler<HTMLVideoElement>>(
+			(e) => {
+				const video = e.currentTarget
 
-			if (isEditing) {
-				videoUtil.editor.updateShapes([
+				editor.updateShapes([
 					{
 						type: 'video',
 						id: shape.id,
 						props: {
+							playing: false,
 							time: video.currentTime,
 						},
 					},
 				])
-			}
-		},
-		[isEditing, shape.id, videoUtil.editor]
-	)
+			},
+			[shape.id, editor]
+		)
+
+		const handleSetCurrentTime = useCallback<ReactEventHandler<HTMLVideoElement>>(
+			(e) => {
+				const video = e.currentTarget
+
+				if (isEditing) {
+					editor.updateShapes([
+						{
+							type: 'video',
+							id: shape.id,
+							props: {
+								time: video.currentTime,
+							},
+						},
+					])
+				}
+			},
+			[isEditing, shape.id, editor]
+		)
+
+		const [isLoaded, setIsLoaded] = useState(false)
+
+		const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>(
+			(e) => {
+				const video = e.currentTarget
+				if (time !== video.currentTime) {
+					video.currentTime = time
+				}
+
+				if (!playing) {
+					video.pause()
+				}
+
+				setIsLoaded(true)
+			},
+			[playing, time]
+		)
+
+		// If the current time changes and we're not editing the video, update the video time
+		useEffect(() => {
+			const video = rVideo.current
 
-	const [isLoaded, setIsLoaded] = React.useState(false)
+			if (!video) return
 
-	const handleLoadedData = React.useCallback<React.ReactEventHandler<HTMLVideoElement>>(
-		(e) => {
-			const video = e.currentTarget
-			if (time !== video.currentTime) {
+			if (isLoaded && !isEditing && time !== video.currentTime) {
 				video.currentTime = time
 			}
 
-			if (!playing) {
-				video.pause()
+			if (isEditing) {
+				if (document.activeElement !== video) {
+					video.focus()
+				}
 			}
+		}, [isEditing, isLoaded, time])
 
-			setIsLoaded(true)
-		},
-		[playing, time]
-	)
-
-	// If the current time changes and we're not editing the video, update the video time
-	React.useEffect(() => {
-		const video = rVideo.current
-
-		if (!video) return
-
-		if (isLoaded && !isEditing && time !== video.currentTime) {
-			video.currentTime = time
-		}
-
-		if (isEditing) {
-			if (document.activeElement !== video) {
-				video.focus()
+		useEffect(() => {
+			if (prefersReducedMotion) {
+				const video = rVideo.current
+				video.pause()
+				video.currentTime = 0
 			}
-		}
-	}, [isEditing, isLoaded, time])
-
-	React.useEffect(() => {
-		if (prefersReducedMotion) {
-			const video = rVideo.current
-			video.pause()
-			video.currentTime = 0
-		}
-	}, [rVideo, prefersReducedMotion])
-
-	return (
-		<>
-			<HTMLContainer id={shape.id}>
-				<div className="tl-counter-scaled">
+		}, [rVideo, prefersReducedMotion])
+
+		return (
+			<>
+				<HTMLContainer
+					id={shape.id}
+					className="tl-video-container tl-counter-scaled"
+					style={{
+						color: 'var(--color-text-3)',
+						backgroundColor: asset ? 'transparent' : 'var(--color-low)',
+						border: asset ? 'none' : '1px solid var(--color-low-border)',
+					}}
+				>
 					{asset?.props.src ? (
 						<video
 							ref={rVideo}
@@ -204,12 +175,42 @@ const TLVideoUtilComponent = track(function TLVideoUtilComponent(props: {
 						>
 							<source src={asset.props.src} />
 						</video>
-					) : null}
-				</div>
-			</HTMLContainer>
-			{'url' in shape.props && shape.props.url && (
-				<HyperlinkButton url={shape.props.url} zoomLevel={videoUtil.editor.getZoomLevel()} />
-			)}
-		</>
-	)
-})
+					) : (
+						<BrokenAssetIcon />
+					)}
+				</HTMLContainer>
+				{'url' in shape.props && shape.props.url && (
+					<HyperlinkButton url={shape.props.url} zoomLevel={editor.getZoomLevel()} />
+				)}
+			</>
+		)
+	}
+
+	indicator(shape: TLVideoShape) {
+		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
+	}
+
+	override toSvg(shape: TLVideoShape) {
+		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
+		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', serializeVideo(shape.id))
+		image.setAttribute('width', shape.props.w.toString())
+		image.setAttribute('height', shape.props.h.toString())
+		g.appendChild(image)
+
+		return g
+	}
+}
+
+// Function from v1, could be improved but explicitly using this.model.time (?)
+function serializeVideo(id: string): string {
+	const splitId = id.split(':')[1]
+	const video = document.querySelector(`.tl-video-shape-${splitId}`) as HTMLVideoElement
+	if (video) {
+		const canvas = document.createElement('canvas')
+		canvas.width = video.videoWidth
+		canvas.height = video.videoHeight
+		canvas.getContext('2d')!.drawImage(video, 0, 0)
+		return canvas.toDataURL('image/png')
+	} else throw new Error('Video with not found when attempting serialization.')
+}

commit 1aef0e8f61c7265af88581ebcc72f6a863586148
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Mar 2 19:38:21 2024 +0000

    [fix] Missing element crash (rare) on video shapes. (#3037)
    
    This PR adds a few guards against crashes when the video shape element
    is not found.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Release Notes
    
    - Fixed a rare crash with video shapes.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 8c0ffb493..89eb5f83c 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -46,6 +46,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const handlePlay = useCallback<ReactEventHandler<HTMLVideoElement>>(
 			(e) => {
 				const video = e.currentTarget
+				if (!video) return
 
 				editor.updateShapes([
 					{
@@ -64,6 +65,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const handlePause = useCallback<ReactEventHandler<HTMLVideoElement>>(
 			(e) => {
 				const video = e.currentTarget
+				if (!video) return
 
 				editor.updateShapes([
 					{
@@ -82,6 +84,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const handleSetCurrentTime = useCallback<ReactEventHandler<HTMLVideoElement>>(
 			(e) => {
 				const video = e.currentTarget
+				if (!video) return
 
 				if (isEditing) {
 					editor.updateShapes([
@@ -103,6 +106,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>(
 			(e) => {
 				const video = e.currentTarget
+				if (!video) return
 				if (time !== video.currentTime) {
 					video.currentTime = time
 				}
@@ -119,7 +123,6 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		// If the current time changes and we're not editing the video, update the video time
 		useEffect(() => {
 			const video = rVideo.current
-
 			if (!video) return
 
 			if (isLoaded && !isEditing && time !== video.currentTime) {
@@ -136,6 +139,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		useEffect(() => {
 			if (prefersReducedMotion) {
 				const video = rVideo.current
+				if (!video) return
 				video.pause()
 				video.currentTime = 0
 			}

commit 5e4bca9961bf31ecfc791bed1d92248e70dff7e9
Author: hirano <bubweiser@users.noreply.github.com>
Date:   Tue Mar 5 01:21:41 2024 +0900

    Fix an issue where the video size was not drawn correctly (#3047)
    
    Fixed an issue where the video size was drawing larger than the shape
    size.
    
    
    After:
    ![„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà 2024-03-04 15 38
    10](https://github.com/tldraw/tldraw/assets/20399854/5839f4a3-913b-4d3a-a816-003d58f89d50)
    
    Before:
    ![„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà 2024-03-04 15 37
    32](https://github.com/tldraw/tldraw/assets/20399854/188bd0cb-50aa-4ea9-a0a5-7748d747eae0)
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    no tests
    
    ### Release Notes
    
    - Fix an issue where the video size was not drawn correctly.
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 89eb5f83c..796bf84ff 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -149,39 +149,42 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 			<>
 				<HTMLContainer
 					id={shape.id}
-					className="tl-video-container tl-counter-scaled"
 					style={{
 						color: 'var(--color-text-3)',
 						backgroundColor: asset ? 'transparent' : 'var(--color-low)',
 						border: asset ? 'none' : '1px solid var(--color-low-border)',
 					}}
 				>
-					{asset?.props.src ? (
-						<video
-							ref={rVideo}
-							style={isEditing ? { pointerEvents: 'all' } : undefined}
-							className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
-							width="100%"
-							height="100%"
-							draggable={false}
-							playsInline
-							autoPlay
-							muted
-							loop
-							disableRemotePlayback
-							disablePictureInPicture
-							controls={isEditing && showControls}
-							onPlay={handlePlay}
-							onPause={handlePause}
-							onTimeUpdate={handleSetCurrentTime}
-							onLoadedData={handleLoadedData}
-							hidden={!isLoaded}
-						>
-							<source src={asset.props.src} />
-						</video>
-					) : (
-						<BrokenAssetIcon />
-					)}
+					<div className="tl-counter-scaled">
+						<div className="tl-video-container">
+							{asset?.props.src ? (
+								<video
+									ref={rVideo}
+									style={isEditing ? { pointerEvents: 'all' } : undefined}
+									className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
+									width="100%"
+									height="100%"
+									draggable={false}
+									playsInline
+									autoPlay
+									muted
+									loop
+									disableRemotePlayback
+									disablePictureInPicture
+									controls={isEditing && showControls}
+									onPlay={handlePlay}
+									onPause={handlePause}
+									onTimeUpdate={handleSetCurrentTime}
+									onLoadedData={handleLoadedData}
+									hidden={!isLoaded}
+								>
+									<source src={asset.props.src} />
+								</video>
+							) : (
+								<BrokenAssetIcon />
+							)}
+						</div>
+					</div>
 				</HTMLContainer>
 				{'url' in shape.props && shape.props.url && (
 					<HyperlinkButton url={shape.props.url} zoomLevel={editor.getZoomLevel()} />

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 796bf84ff..ac88bb899 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -198,14 +198,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 
 	override toSvg(shape: TLVideoShape) {
-		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
-		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', serializeVideo(shape.id))
-		image.setAttribute('width', shape.props.w.toString())
-		image.setAttribute('height', shape.props.h.toString())
-		g.appendChild(image)
-
-		return g
+		return <image href={serializeVideo(shape.id)} width={shape.props.w} height={shape.props.h} />
 	}
 }
 

commit 6c846716c343e1ad40839f0f2bab758f58b4284d
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 15:17:09 2024 +0100

    assets: make option to transform urls dynamically / LOD (#3827)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3764
    
    This continues the idea kicked off in
    https://github.com/tldraw/tldraw/pull/3684 to explore LOD and takes it
    in a different direction.
    
    Several things here to call out:
    - our dotcom version would start to use Cloudflare's image transforms
    - we don't rewrite non-image assets
    - we debounce zooming so that we're not swapping out images while
    zooming (it creates jank)
    - we load different images based on steps of .25 (maybe we want to make
    this more, like 0.33). Feels like 0.5 might be a bit too much but we can
    play around with it.
    - we take into account network connection speed. if you're on 3g, for
    example, we have the size of the image.
    - dpr is taken into account - in our case, Cloudflare handles it. But if
    it wasn't Cloudflare, we could add it to our width equation.
    - we use Cloudflare's `fit=scale-down` setting to never scale _up_ an
    image.
    - we don't swap the image in until we've finished loading it
    programatically (to avoid a blank image while it loads)
    
    TODO
    - [x] We need to enable Cloudflare's pricing on image transforms btw
    @steveruizok üòâ - this won't work quite yet until we do that.
    
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [x] `feature` ‚Äî New feature
    - [ ] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know
    
    
    ### Test Plan
    
    1. Test images on staging, small, medium, large, mega
    2. Test videos on staging
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Assets: make option to transform urls dynamically to provide different
    sized images on demand.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index ac88bb899..1fd8d0325 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -11,6 +11,7 @@ import {
 import { ReactEventHandler, useCallback, useEffect, useRef, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { useAsset } from '../shared/useAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 /** @public */
@@ -36,7 +37,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	component(shape: TLVideoShape) {
 		const { editor } = this
 		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
-		const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : null
+		const { asset, url } = useAsset(shape.props.assetId, shape.props.w)
 		const { time, playing } = shape.props
 		const isEditing = useIsEditing(shape.id)
 		const prefersReducedMotion = usePrefersReducedMotion()
@@ -157,7 +158,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 				>
 					<div className="tl-counter-scaled">
 						<div className="tl-video-container">
-							{asset?.props.src ? (
+							{url ? (
 								<video
 									ref={rVideo}
 									style={isEditing ? { pointerEvents: 'all' } : undefined}
@@ -178,7 +179,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 									onLoadedData={handleLoadedData}
 									hidden={!isLoaded}
 								>
-									<source src={asset.props.src} />
+									<source src={url} />
 								</video>
 							) : (
 								<BrokenAssetIcon />

commit 73c2b1088a1c4ab308fd6f71e5148bffc74c546b
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Fri Jun 14 11:01:50 2024 +0100

    image: follow-up fixes for LOD (#3934)
    
    couple fixes and improvements for the LOD work.
    
    - add `format=auto` for Cloudflare to send back more modern image
    formats
    - fix the broken asset logic that regressed (should not have looked at
    `url`)
    - fix stray parenthesis, omg
    - rm the `useValueDebounced` function in lieu of just debouncing the
    resolver. the problem was that the initial load in a multiplayer room
    has a zoom of 1 but then the real zoom comes in (via the url) and so we
    would double load all images üò¨. this switches the debouncing to the
    resolving stage, not making it tied to the zoom specifically.
    
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [x] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [ ] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 1fd8d0325..712dca02e 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -158,7 +158,9 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 				>
 					<div className="tl-counter-scaled">
 						<div className="tl-video-container">
-							{url ? (
+							{!asset?.props.src ? (
+								<BrokenAssetIcon />
+							) : url ? (
 								<video
 									ref={rVideo}
 									style={isEditing ? { pointerEvents: 'all' } : undefined}
@@ -181,9 +183,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 								>
 									<source src={url} />
 								</video>
-							) : (
-								<BrokenAssetIcon />
-							)}
+							) : null}
 						</div>
 					</div>
 				</HTMLContainer>

commit ca3ef619ad07c5cc7d1cb11a4ea9a56eba3bfe4e
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 18 12:39:20 2024 +0100

    lod: dont resize images that are culled (#3970)
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [x] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 712dca02e..bd0183473 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -37,7 +37,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	component(shape: TLVideoShape) {
 		const { editor } = this
 		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
-		const { asset, url } = useAsset(shape.props.assetId, shape.props.w)
+		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
 		const { time, playing } = shape.props
 		const isEditing = useIsEditing(shape.id)
 		const prefersReducedMotion = usePrefersReducedMotion()

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index bd0183473..1116bcdd9 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -20,8 +20,12 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	static override props = videoShapeProps
 	static override migrations = videoShapeMigrations
 
-	override canEdit = () => true
-	override isAspectRatioLocked = () => true
+	override canEdit() {
+		return true
+	}
+	override isAspectRatioLocked() {
+		return true
+	}
 
 	override getDefaultProps(): TLVideoShape['props'] {
 		return {

commit 88f7b572e5f7f1075e73c4d56f9ab7994a5c1268
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Thu Aug 1 17:49:14 2024 +0100

    images: show ghost preview image whilst uploading (#3988)
    
    This adds feedback that an upload is happening, both for images and
    videos. For images, it creates a ghost image whilst uploading. For
    videos, it has the spinner (because creating the object blobs seems too
    memory heavy, but I could be convinced). The majority of the work was
    shifting `defaultExternalContentHandlers.ts` so that it's asynchronously
    creates the assets instead of synchronously when adding new assets.
    
    Also:
    - consolidated some asset creation logic around media, there was some
    duplication across the codebase
    - useMultiplayerAssets was unnecessary actually, got rid of it!
    
    Images:
    
    
    https://github.com/tldraw/tldraw/assets/469604/2633d7f1-121c-4d5f-8212-99bcd57a4ba9
    
    
    Videos:
    
    
    https://github.com/tldraw/tldraw/assets/469604/01cfa7b3-8863-45ab-b479-0a15683aa520
    
    Fixes https://github.com/tldraw/tldraw/issues/1567
    
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [x] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know
    
    
    ### Release Notes
    
    - Media: add image and video upload indicators.
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 1116bcdd9..d6a56adf9 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -4,6 +4,7 @@ import {
 	HTMLContainer,
 	TLVideoShape,
 	toDomPrecision,
+	useEditorComponents,
 	useIsEditing,
 	videoShapeMigrations,
 	videoShapeProps,
@@ -45,6 +46,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const { time, playing } = shape.props
 		const isEditing = useIsEditing(shape.id)
 		const prefersReducedMotion = usePrefersReducedMotion()
+		const { Spinner } = useEditorComponents()
 
 		const rVideo = useRef<HTMLVideoElement>(null!)
 
@@ -162,31 +164,42 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 				>
 					<div className="tl-counter-scaled">
 						<div className="tl-video-container">
-							{!asset?.props.src ? (
+							{!asset ? (
 								<BrokenAssetIcon />
+							) : Spinner && !asset.props.src ? (
+								<Spinner />
 							) : url ? (
-								<video
-									ref={rVideo}
-									style={isEditing ? { pointerEvents: 'all' } : undefined}
-									className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
-									width="100%"
-									height="100%"
-									draggable={false}
-									playsInline
-									autoPlay
-									muted
-									loop
-									disableRemotePlayback
-									disablePictureInPicture
-									controls={isEditing && showControls}
-									onPlay={handlePlay}
-									onPause={handlePause}
-									onTimeUpdate={handleSetCurrentTime}
-									onLoadedData={handleLoadedData}
-									hidden={!isLoaded}
-								>
-									<source src={url} />
-								</video>
+								<>
+									<video
+										ref={rVideo}
+										style={
+											isEditing
+												? { pointerEvents: 'all' }
+												: !isLoaded
+													? { display: 'none' }
+													: undefined
+										}
+										className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
+										width="100%"
+										height="100%"
+										draggable={false}
+										playsInline
+										autoPlay
+										muted
+										loop
+										disableRemotePlayback
+										disablePictureInPicture
+										controls={isEditing && showControls}
+										onPlay={handlePlay}
+										onPause={handlePause}
+										onTimeUpdate={handleSetCurrentTime}
+										onLoadedData={handleLoadedData}
+										hidden={!isLoaded}
+									>
+										<source src={url} />
+									</video>
+									{!isLoaded && Spinner && <Spinner />}
+								</>
 							) : null}
 						</div>
 					</div>

commit 9948f3e2325c6814c3f2eb76281a12bef2444183
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Sat Aug 3 14:02:59 2024 +0100

    video: rm sync that doesn't really work; fix fullscreen rendering (#4338)
    
    Our syncing didn't really work, caused problems in multiplayer mode.
    We're ripping it out for now until we rethink this.
    
    Drive-by fix: I noticed that in fullscreen, portrait videos were being
    cut off because we render in `cover` mode. This fixes that.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - video: rm sync that doesn't really work; fix fullscreen rendering

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index d6a56adf9..1fa1f4e1b 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -9,6 +9,7 @@ import {
 	videoShapeMigrations,
 	videoShapeProps,
 } from '@tldraw/editor'
+import classNames from 'classnames'
 import { ReactEventHandler, useCallback, useEffect, useRef, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
@@ -43,105 +44,41 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		const { editor } = this
 		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
 		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
-		const { time, playing } = shape.props
 		const isEditing = useIsEditing(shape.id)
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const { Spinner } = useEditorComponents()
 
 		const rVideo = useRef<HTMLVideoElement>(null!)
 
-		const handlePlay = useCallback<ReactEventHandler<HTMLVideoElement>>(
-			(e) => {
-				const video = e.currentTarget
-				if (!video) return
-
-				editor.updateShapes([
-					{
-						type: 'video',
-						id: shape.id,
-						props: {
-							playing: true,
-							time: video.currentTime,
-						},
-					},
-				])
-			},
-			[shape.id, editor]
-		)
-
-		const handlePause = useCallback<ReactEventHandler<HTMLVideoElement>>(
-			(e) => {
-				const video = e.currentTarget
-				if (!video) return
-
-				editor.updateShapes([
-					{
-						type: 'video',
-						id: shape.id,
-						props: {
-							playing: false,
-							time: video.currentTime,
-						},
-					},
-				])
-			},
-			[shape.id, editor]
-		)
+		const [isLoaded, setIsLoaded] = useState(false)
 
-		const handleSetCurrentTime = useCallback<ReactEventHandler<HTMLVideoElement>>(
-			(e) => {
-				const video = e.currentTarget
-				if (!video) return
+		const [isFullscreen, setIsFullscreen] = useState(false)
 
-				if (isEditing) {
-					editor.updateShapes([
-						{
-							type: 'video',
-							id: shape.id,
-							props: {
-								time: video.currentTime,
-							},
-						},
-					])
-				}
-			},
-			[isEditing, shape.id, editor]
-		)
-
-		const [isLoaded, setIsLoaded] = useState(false)
+		useEffect(() => {
+			const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current)
+			document.addEventListener('fullscreenchange', fullscreenChange)
 
-		const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>(
-			(e) => {
-				const video = e.currentTarget
-				if (!video) return
-				if (time !== video.currentTime) {
-					video.currentTime = time
-				}
+			return () => document.removeEventListener('fullscreenchange', fullscreenChange)
+		})
 
-				if (!playing) {
-					video.pause()
-				}
+		const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>((e) => {
+			const video = e.currentTarget
+			if (!video) return
 
-				setIsLoaded(true)
-			},
-			[playing, time]
-		)
+			setIsLoaded(true)
+		}, [])
 
 		// If the current time changes and we're not editing the video, update the video time
 		useEffect(() => {
 			const video = rVideo.current
 			if (!video) return
 
-			if (isLoaded && !isEditing && time !== video.currentTime) {
-				video.currentTime = time
-			}
-
 			if (isEditing) {
 				if (document.activeElement !== video) {
 					video.focus()
 				}
 			}
-		}, [isEditing, isLoaded, time])
+		}, [isEditing, isLoaded])
 
 		useEffect(() => {
 			if (prefersReducedMotion) {
@@ -179,7 +116,9 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 													? { display: 'none' }
 													: undefined
 										}
-										className={`tl-video tl-video-shape-${shape.id.split(':')[1]}`}
+										className={classNames('tl-video', `tl-video-shape-${shape.id.split(':')[1]}`, {
+											'tl-video-is-fullscreen': isFullscreen,
+										})}
 										width="100%"
 										height="100%"
 										draggable={false}
@@ -190,9 +129,6 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 										disableRemotePlayback
 										disablePictureInPicture
 										controls={isEditing && showControls}
-										onPlay={handlePlay}
-										onPause={handlePause}
-										onTimeUpdate={handleSetCurrentTime}
 										onLoadedData={handleLoadedData}
 										hidden={!isLoaded}
 									>

commit 7d0433e91822f9a65a6b5d735918489822849bf0
Author: alex <alex@dytry.ch>
Date:   Wed Sep 4 16:33:26 2024 +0100

    add default <foreignObject> based export for shapes (#4403)
    
    Custom shapes (and our own bookmark shapes) now support SVG exports by
    default! The default implementation isn't the most efficient and won't
    work in all SVG environments, but you can still write your own if
    needed. It's pretty reliable though!
    
    ![Kapture 2024-08-27 at 17 29
    31](https://github.com/user-attachments/assets/3870e82b-b77b-486b-92b0-420921df8d51)
    
    This introduces a couple of new APIs for co-ordinating SVG exports. The
    main one is `useDelaySvgExport`. This is useful when your component
    might take a while to load, and you need to delay the export is until
    everything is ready & rendered. You use it like this:
    ```tsx
    function MyComponent() {
        const exportIsReady = useDelaySvgExport()
        const [dynamicData, setDynamicData] = useState(null)
    
        useEffect(() => {
            loadDynamicData.then((data) => {
                setDynamicData(data)
                exportIsReady()
            })
        })
    
        return <MyList data={data} />
    }
    ```
    
    This is a pretty low-level API that I wouldn't expect most people using
    these exports to need, but it does come in handy for some things.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    Custom shapes (and our own bookmark shapes) now render in image exports
    by default.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 1fa1f4e1b..5b5afb4b0 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -1,7 +1,9 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
+	Editor,
 	HTMLContainer,
+	MediaHelpers,
 	TLVideoShape,
 	toDomPrecision,
 	useEditorComponents,
@@ -151,20 +153,19 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
 
-	override toSvg(shape: TLVideoShape) {
-		return <image href={serializeVideo(shape.id)} width={shape.props.w} height={shape.props.h} />
+	override async toSvg(shape: TLVideoShape) {
+		const image = await serializeVideo(this.editor, shape)
+		if (!image) return null
+		return <image href={image} width={shape.props.w} height={shape.props.h} />
 	}
 }
 
-// Function from v1, could be improved but explicitly using this.model.time (?)
-function serializeVideo(id: string): string {
-	const splitId = id.split(':')[1]
-	const video = document.querySelector(`.tl-video-shape-${splitId}`) as HTMLVideoElement
-	if (video) {
-		const canvas = document.createElement('canvas')
-		canvas.width = video.videoWidth
-		canvas.height = video.videoHeight
-		canvas.getContext('2d')!.drawImage(video, 0, 0)
-		return canvas.toDataURL('image/png')
-	} else throw new Error('Video with not found when attempting serialization.')
+async function serializeVideo(editor: Editor, shape: TLVideoShape): Promise<string | null> {
+	const assetUrl = await editor.resolveAssetUrl(shape.props.assetId, {
+		shouldResolveToOriginal: true,
+	})
+	if (!assetUrl) return null
+
+	const video = await MediaHelpers.loadVideo(assetUrl)
+	return MediaHelpers.getVideoFrameAsDataUrl(video, 0)
 }

commit 7d81da31f4368656a9454107fd84be186d7a296c
Author: alex <alex@dytry.ch>
Date:   Tue Sep 24 11:22:11 2024 +0100

    publish useAsset, tweak docs (#4590)
    
    This was hidden and some of the docs around it were out of date.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    - Publish the `useAsset` media asset helper

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 5b5afb4b0..88ecba863 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -45,7 +45,11 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	component(shape: TLVideoShape) {
 		const { editor } = this
 		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
-		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
+		const { asset, url } = useAsset({
+			shapeId: shape.id,
+			assetId: shape.props.assetId,
+			width: shape.props.w,
+		})
 		const isEditing = useIsEditing(shape.id)
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const { Spinner } = useEditorComponents()

commit 29d7ecaa7c0d2bc67190f20efd5c1ba47305ce14
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Sat Oct 12 16:12:12 2024 +0100

    lod: memoize media assets so that zoom level doesn't re-render constantly (#4659)
    
    Related to a discussion on Discord:
    https://discord.com/channels/859816885297741824/1290992999186169898/1291681011758792756
    
    This works to memoize the rendering of the core part of the image/video
    react components b/c the `useValue` hook inside `useAsset` is called so
    often. If there's a better way to do this @SomeHats I'm all ears!
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improve performance of image/video rendering.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 88ecba863..d7700a9a9 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -4,6 +4,7 @@ import {
 	Editor,
 	HTMLContainer,
 	MediaHelpers,
+	TLAsset,
 	TLVideoShape,
 	toDomPrecision,
 	useEditorComponents,
@@ -12,10 +13,10 @@ import {
 	videoShapeProps,
 } from '@tldraw/editor'
 import classNames from 'classnames'
-import { ReactEventHandler, useCallback, useEffect, useRef, useState } from 'react'
+import { ReactEventHandler, memo, useCallback, useEffect, useRef, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
-import { useAsset } from '../shared/useAsset'
+import { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 /** @public */
@@ -43,114 +44,12 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 
 	component(shape: TLVideoShape) {
-		const { editor } = this
-		const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
-		const { asset, url } = useAsset({
+		const { asset, url } = useImageOrVideoAsset({
 			shapeId: shape.id,
 			assetId: shape.props.assetId,
-			width: shape.props.w,
 		})
-		const isEditing = useIsEditing(shape.id)
-		const prefersReducedMotion = usePrefersReducedMotion()
-		const { Spinner } = useEditorComponents()
 
-		const rVideo = useRef<HTMLVideoElement>(null!)
-
-		const [isLoaded, setIsLoaded] = useState(false)
-
-		const [isFullscreen, setIsFullscreen] = useState(false)
-
-		useEffect(() => {
-			const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current)
-			document.addEventListener('fullscreenchange', fullscreenChange)
-
-			return () => document.removeEventListener('fullscreenchange', fullscreenChange)
-		})
-
-		const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>((e) => {
-			const video = e.currentTarget
-			if (!video) return
-
-			setIsLoaded(true)
-		}, [])
-
-		// If the current time changes and we're not editing the video, update the video time
-		useEffect(() => {
-			const video = rVideo.current
-			if (!video) return
-
-			if (isEditing) {
-				if (document.activeElement !== video) {
-					video.focus()
-				}
-			}
-		}, [isEditing, isLoaded])
-
-		useEffect(() => {
-			if (prefersReducedMotion) {
-				const video = rVideo.current
-				if (!video) return
-				video.pause()
-				video.currentTime = 0
-			}
-		}, [rVideo, prefersReducedMotion])
-
-		return (
-			<>
-				<HTMLContainer
-					id={shape.id}
-					style={{
-						color: 'var(--color-text-3)',
-						backgroundColor: asset ? 'transparent' : 'var(--color-low)',
-						border: asset ? 'none' : '1px solid var(--color-low-border)',
-					}}
-				>
-					<div className="tl-counter-scaled">
-						<div className="tl-video-container">
-							{!asset ? (
-								<BrokenAssetIcon />
-							) : Spinner && !asset.props.src ? (
-								<Spinner />
-							) : url ? (
-								<>
-									<video
-										ref={rVideo}
-										style={
-											isEditing
-												? { pointerEvents: 'all' }
-												: !isLoaded
-													? { display: 'none' }
-													: undefined
-										}
-										className={classNames('tl-video', `tl-video-shape-${shape.id.split(':')[1]}`, {
-											'tl-video-is-fullscreen': isFullscreen,
-										})}
-										width="100%"
-										height="100%"
-										draggable={false}
-										playsInline
-										autoPlay
-										muted
-										loop
-										disableRemotePlayback
-										disablePictureInPicture
-										controls={isEditing && showControls}
-										onLoadedData={handleLoadedData}
-										hidden={!isLoaded}
-									>
-										<source src={url} />
-									</video>
-									{!isLoaded && Spinner && <Spinner />}
-								</>
-							) : null}
-						</div>
-					</div>
-				</HTMLContainer>
-				{'url' in shape.props && shape.props.url && (
-					<HyperlinkButton url={shape.props.url} zoomLevel={editor.getZoomLevel()} />
-				)}
-			</>
-		)
+		return <VideoShape editor={this.editor} shape={shape} asset={asset} url={url} />
 	}
 
 	indicator(shape: TLVideoShape) {
@@ -164,6 +63,119 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 }
 
+const VideoShape = memo(function VideoShape({
+	editor,
+	shape,
+	asset,
+	url,
+}: {
+	editor: Editor
+	shape: TLVideoShape
+	asset?: TLAsset | null
+	url: string | null
+}) {
+	const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
+	const isEditing = useIsEditing(shape.id)
+	const prefersReducedMotion = usePrefersReducedMotion()
+	const { Spinner } = useEditorComponents()
+
+	const rVideo = useRef<HTMLVideoElement>(null!)
+
+	const [isLoaded, setIsLoaded] = useState(false)
+
+	const [isFullscreen, setIsFullscreen] = useState(false)
+
+	useEffect(() => {
+		const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current)
+		document.addEventListener('fullscreenchange', fullscreenChange)
+
+		return () => document.removeEventListener('fullscreenchange', fullscreenChange)
+	})
+
+	const handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>((e) => {
+		const video = e.currentTarget
+		if (!video) return
+
+		setIsLoaded(true)
+	}, [])
+
+	// If the current time changes and we're not editing the video, update the video time
+	useEffect(() => {
+		const video = rVideo.current
+		if (!video) return
+
+		if (isEditing) {
+			if (document.activeElement !== video) {
+				video.focus()
+			}
+		}
+	}, [isEditing, isLoaded])
+
+	useEffect(() => {
+		if (prefersReducedMotion) {
+			const video = rVideo.current
+			if (!video) return
+			video.pause()
+			video.currentTime = 0
+		}
+	}, [rVideo, prefersReducedMotion])
+
+	return (
+		<>
+			<HTMLContainer
+				id={shape.id}
+				style={{
+					color: 'var(--color-text-3)',
+					backgroundColor: asset ? 'transparent' : 'var(--color-low)',
+					border: asset ? 'none' : '1px solid var(--color-low-border)',
+				}}
+			>
+				<div className="tl-counter-scaled">
+					<div className="tl-video-container">
+						{!asset ? (
+							<BrokenAssetIcon />
+						) : Spinner && !asset.props.src ? (
+							<Spinner />
+						) : url ? (
+							<>
+								<video
+									ref={rVideo}
+									style={
+										isEditing
+											? { pointerEvents: 'all' }
+											: !isLoaded
+												? { display: 'none' }
+												: undefined
+									}
+									className={classNames('tl-video', `tl-video-shape-${shape.id.split(':')[1]}`, {
+										'tl-video-is-fullscreen': isFullscreen,
+									})}
+									width="100%"
+									height="100%"
+									draggable={false}
+									playsInline
+									autoPlay
+									muted
+									loop
+									disableRemotePlayback
+									disablePictureInPicture
+									controls={isEditing && showControls}
+									onLoadedData={handleLoadedData}
+									hidden={!isLoaded}
+								>
+									<source src={url} />
+								</video>
+								{!isLoaded && Spinner && <Spinner />}
+							</>
+						) : null}
+					</div>
+				</div>
+			</HTMLContainer>
+			{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}
+		</>
+	)
+})
+
 async function serializeVideo(editor: Editor, shape: TLVideoShape): Promise<string | null> {
 	const assetUrl = await editor.resolveAssetUrl(shape.props.assetId, {
 		shouldResolveToOriginal: true,

commit e86a737fc512ccca686b016864b11faa0557580e
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Wed Dec 4 10:55:31 2024 +0000

    assets: fix up resolving when copy/pasting multiple items; also, videos (#5061)
    
    Fixes issue https://github.com/tldraw/tldraw/issues/5052
    
    This is a regression from https://github.com/tldraw/tldraw/pull/4682
    (which was rolled up into https://github.com/tldraw/tldraw/pull/4659 )
    
    Couple things were problematic here:
    - main issue was that `debounce`'d urls all rolled up into one single
    debounce call that was _shared_ for all assets. this needed to be split
    to be per asset, which is now the case. (see
    `getResolveAssetUrlDebounced`)
    - As long as I was looking at this it turns out videos weren't working
    at all. We weren't accounting for `data:video` as well as `data:image` -
    that's now been corrected. Not sure how long that's been broken for...
    - Noticed also that `isReady()` was not called appropriately in the
    non-preview case - that's now fixed as well.
    - finally, made `VideoShapeUtil`'s calling of `useImageOrVideoAsset`
    consistent with `ImageShapeUtil`
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fixed bugs with copy/pasting multilple assets from one board to
    another.
    - Fixed bug with copy/pasting videos from one board to another.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index d7700a9a9..759e22ca6 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -1,12 +1,11 @@
-/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
 	Editor,
 	HTMLContainer,
 	MediaHelpers,
-	TLAsset,
 	TLVideoShape,
 	toDomPrecision,
+	useEditor,
 	useEditorComponents,
 	useIsEditing,
 	videoShapeMigrations,
@@ -44,12 +43,7 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 
 	component(shape: TLVideoShape) {
-		const { asset, url } = useImageOrVideoAsset({
-			shapeId: shape.id,
-			assetId: shape.props.assetId,
-		})
-
-		return <VideoShape editor={this.editor} shape={shape} asset={asset} url={url} />
+		return <VideoShape shape={shape} />
 	}
 
 	indicator(shape: TLVideoShape) {
@@ -63,22 +57,18 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	}
 }
 
-const VideoShape = memo(function VideoShape({
-	editor,
-	shape,
-	asset,
-	url,
-}: {
-	editor: Editor
-	shape: TLVideoShape
-	asset?: TLAsset | null
-	url: string | null
-}) {
+const VideoShape = memo(function VideoShape({ shape }: { shape: TLVideoShape }) {
+	const editor = useEditor()
 	const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110
 	const isEditing = useIsEditing(shape.id)
 	const prefersReducedMotion = usePrefersReducedMotion()
 	const { Spinner } = useEditorComponents()
 
+	const { asset, url } = useImageOrVideoAsset({
+		shapeId: shape.id,
+		assetId: shape.props.assetId,
+	})
+
 	const rVideo = useRef<HTMLVideoElement>(null!)
 
 	const [isLoaded, setIsLoaded] = useState(false)

commit 5ed55f12f0508edec34292d7c1bdd08b4e8c21a1
Author: alex <alex@dytry.ch>
Date:   Mon Jan 20 18:19:00 2025 +0000

    Exports DX pass (#5114)
    
    Over the last few weeks we've had a lot of requests on discord around
    asset resolution, exports, and the two together. Some of the APIs here
    have evolved and change independently of each other over time, so I
    wanted to take a pass at making them make sense with each other a bit
    more. There are a few things going on in this diff:
    
    1. **BREAKING** The export/copy-as JSON option has been removed. I think
    this was only ever there as a debug helper, and it's impossible to
    actually make use of the JSON once copied (it's not the same as .tldr
    json which confuses people).
    2. `exportToBlob` is deprecated in favour of a new `Editor.toImage`
    method. `exportToBlob` has been the canonical 'turn the canvas into an
    image' helper for a while, but it has quite a weird looking signature
    and isn't very discoverable.
    3. the `copyAs` and `exportAs` helpers have had a couple of args merged
    into the options bag for consistency.
    4. The `jpeg` format has been removed from `copyAs`. This is technically
    a breaking API change, but since it never actually worked anyway due to
    browser limitations i think its fine.
    5. SVG exports now resolve assets according to how they'll be used:
    - if it's for an SVG, we still use the existing
    `shouldResolveToOriginal` behaviour
    - if it's for a bitmap export, we request an image downscaled according
    to the size it will appear in that resulting bitmap.
    6. Better reference docs for several APIs around this stuff.
    7. **BREAKING** the `useImageOrVideoAsset` hook now requires passing in
    `width`, instead of reading `shape.props.w`. This is so it can be used
    with shapes other than our own. Whilst this is technically a breaking
    change, this limitation means its unlikely that it was used with many
    custom shapes in practice.
    8. The clamping that we used to apply in to `steppedScreenScale` in
    `resolveAssetUrl` has been moved to our own implementations of
    `TLAssetStore`. This is so implementors can make their own decisions
    about the range of scalings they might want to use.
    9. The `steppedScreenScale` limit changed from 1/8 to 1/32. This is
    because when testing with full res photos from a modern smartphone, we
    were still downloading a 1000+px image in order to render it at a few
    hundred px across (and also we don't pay anything for these right now).
    Happy to change now/in the future if this doesn't seem right though.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    #### Breaking changes / user facing changes
    - The copy/export as JSON option has been removed. Data copied/exported
    from here could not be used anyway. If you need this in your app, look
    into `Editor.getContentFromCurrentPage`.
    - `useImageOrVideoAssetUrl` now expects a `width` parameter representing
    the rendered width of the asset.
    - `Editor.getSvgElement` and `Editor.getSvgString` will now export all
    shapes on the current page instead of returning undefined when passed an
    empty array of shape ids.
    
    #### Product improvement
    - When exporting to an image, image assets are now downloaded at a
    resolution appropriate for how they will appear in the export.
    
    #### API changes
    - There's a new `Editor.toImage` method that makes creating an image
    from your canvas easier. (`exportToBlob` is deprecated in favour of it)
    - `SvgExportContext` now exposes the `scale` and `pixelRatio` options of
    the current export
    - `SvgExportContext` now has a `resolveAssetUrl` method to resolve an
    asset at a resolution appropriate for the export.
    - `copyAs(editor, ids, format, opts)` has been deprecated in favour of
    `copyAs(editor, ids, opts)`.
    - `exportAs(editor, ids, format, name, opts)` has been deprecated in
    favour of `exportAs(editor, ids, opts)`

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 759e22ca6..859dc454b 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -1,8 +1,8 @@
 import {
 	BaseBoxShapeUtil,
-	Editor,
 	HTMLContainer,
 	MediaHelpers,
+	SvgExportContext,
 	TLVideoShape,
 	toDomPrecision,
 	useEditor,
@@ -50,9 +50,16 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
 
-	override async toSvg(shape: TLVideoShape) {
-		const image = await serializeVideo(this.editor, shape)
+	override async toSvg(shape: TLVideoShape, ctx: SvgExportContext) {
+		if (!shape.props.assetId) return null
+
+		const assetUrl = await ctx.resolveAssetUrl(shape.props.assetId, shape.props.w)
+		if (!assetUrl) return null
+
+		const video = await MediaHelpers.loadVideo(assetUrl)
+		const image = await MediaHelpers.getVideoFrameAsDataUrl(video, 0)
 		if (!image) return null
+
 		return <image href={image} width={shape.props.w} height={shape.props.h} />
 	}
 }
@@ -67,6 +74,7 @@ const VideoShape = memo(function VideoShape({ shape }: { shape: TLVideoShape })
 	const { asset, url } = useImageOrVideoAsset({
 		shapeId: shape.id,
 		assetId: shape.props.assetId,
+		width: shape.props.w,
 	})
 
 	const rVideo = useRef<HTMLVideoElement>(null!)
@@ -165,13 +173,3 @@ const VideoShape = memo(function VideoShape({ shape }: { shape: TLVideoShape })
 		</>
 	)
 })
-
-async function serializeVideo(editor: Editor, shape: TLVideoShape): Promise<string | null> {
-	const assetUrl = await editor.resolveAssetUrl(shape.props.assetId, {
-		shouldResolveToOriginal: true,
-	})
-	if (!assetUrl) return null
-
-	const video = await MediaHelpers.loadVideo(assetUrl)
-	return MediaHelpers.getVideoFrameAsDataUrl(video, 0)
-}

commit 7bd13bef2242ee7fe295607dfa87c248b6c0537c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Feb 25 16:43:51 2025 +0000

    [botcom] Fix slow export menu in big files (#5435)
    
    This PR fixes an issue where large files or files with GIFs / large
    images could freeze when opening the export menu.
    
    
    https://github.com/user-attachments/assets/af0b21c2-d50b-4106-bef6-7738868f863e
    
    ## GIFs
    
    Previously, we were inlining the entire GIF when creating an SVG. We now
    only inline the first frame. This was a crashing bug previously.
    
    ## Images / asset caching
    
    Previously, we were loading a URL for each image or video shape. We now
    cache the result of the previous generation, so that we only load one
    image per asset. This is especially important for GIFs because the work
    to generate the export image src associated with the asset was
    expensive.
    
    ## File size
    
    Previously, the image shown in the export panel could be very very large
    depending on the size of the canvas.
    
    **Problem**
    
    When we export images, we do so at 100% resolution. For large canvases,
    that can result in images which are very large (e.g. 5000x5000px or
    larger). Creating and displaying such a large image can be extremely
    hard on resources.
    
    **Solution**
    
    In this PR, we find a **scale** for the image based on the common bounds
    of the selected shapes, then apply that scale to keep the image small
    (under 500x500 pixels). We also use png instead of svg as the output
    format, which for small but dense images should work better. Together,
    these lead to preview images for even very large files (4000 draw
    shapes) being relatively quick. The actual exports are unaffected and
    slower.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Visit a very large file.
    2. Open the export menu.
    
    ### Release notes
    
    - Fixed a bug with export menu performance.

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 859dc454b..0d78345ef 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -3,6 +3,7 @@ import {
 	HTMLContainer,
 	MediaHelpers,
 	SvgExportContext,
+	TLAsset,
 	TLVideoShape,
 	toDomPrecision,
 	useEditor,
@@ -10,14 +11,17 @@ import {
 	useIsEditing,
 	videoShapeMigrations,
 	videoShapeProps,
+	WeakCache,
 } from '@tldraw/editor'
 import classNames from 'classnames'
-import { ReactEventHandler, memo, useCallback, useEffect, useRef, useState } from 'react'
+import { memo, ReactEventHandler, useCallback, useEffect, useRef, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
+const videoSvgExportCache = new WeakCache<TLAsset, Promise<string | null>>()
+
 /** @public */
 export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	static override type = 'video' as const
@@ -53,14 +57,19 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 	override async toSvg(shape: TLVideoShape, ctx: SvgExportContext) {
 		if (!shape.props.assetId) return null
 
-		const assetUrl = await ctx.resolveAssetUrl(shape.props.assetId, shape.props.w)
-		if (!assetUrl) return null
+		const asset = this.editor.getAsset<TLAsset>(shape.props.assetId)
+		if (!asset) return null
+
+		const src = await videoSvgExportCache.get(asset, async () => {
+			const assetUrl = await ctx.resolveAssetUrl(asset.id, shape.props.w)
+			if (!assetUrl) return null
+			const video = await MediaHelpers.loadVideo(assetUrl)
+			return await MediaHelpers.getVideoFrameAsDataUrl(video, 0)
+		})
 
-		const video = await MediaHelpers.loadVideo(assetUrl)
-		const image = await MediaHelpers.getVideoFrameAsDataUrl(video, 0)
-		if (!image) return null
+		if (!src) return null
 
-		return <image href={image} width={shape.props.w} height={shape.props.h} />
+		return <image href={src} width={shape.props.w} height={shape.props.h} />
 	}
 }
 

commit 4ecb34d3434dbd9ad3119d4dfc66b7af4e598faf
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Mon Apr 7 22:05:44 2025 +0100

    a11y: announce shapes as they're visited (#5773)
    
    Building off of https://github.com/tldraw/tldraw/pull/5634 and
    https://github.com/tldraw/tldraw/pull/5761 this is adding a11y live text
    to be read aloud when visiting a shape.
    
    We add an overridable method for shapes to customize this called
    `getAriaLiveText`.
    Furthermore, we lay the groundwork here to start letting media shapes
    have `altText`.
    Drive-by fix of `heart` being missing in `geo-styles` list.
    Also, drive-by fix of us calling our Image button "Asset" (what are we
    selling financial instruments here? :P) "Media" is a better word for
    this button, more human.
    
    Some of the i18n translation is funky. It's a shortcoming of our current
    system that we don't support interpolation :-/
    It sucks, and we'll revisit in the future.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - a11y: announce shapes as they're visited
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
index 0d78345ef..4fe93dc77 100644
--- a/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx
@@ -43,9 +43,14 @@ export class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
 			time: 0,
 			playing: true,
 			url: '',
+			altText: '',
 		}
 	}
 
+	override getAriaDescriptor(shape: TLVideoShape) {
+		return shape.props.altText
+	}
+
 	component(shape: TLVideoShape) {
 		return <VideoShape shape={shape} />
 	}

