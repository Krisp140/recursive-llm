# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactUpdates-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
new file mode 100644
index 0000000000..ab7acbb429
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -0,0 +1,1331 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var React;
+var ReactDOM;
+var ReactTestUtils;
+
+describe('ReactUpdates', () => {
+  beforeEach(() => {
+    React = require('react');
+    ReactDOM = require('react-dom');
+    ReactTestUtils = require('react-dom/test-utils');
+  });
+
+  it('should batch state when updating state twice', () => {
+    var updateCount = 0;
+
+    class Component extends React.Component {
+      state = {x: 0};
+
+      componentDidUpdate() {
+        updateCount++;
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    expect(instance.state.x).toBe(0);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1});
+      instance.setState({x: 2});
+      expect(instance.state.x).toBe(0);
+      expect(updateCount).toBe(0);
+    });
+
+    expect(instance.state.x).toBe(2);
+    expect(updateCount).toBe(1);
+  });
+
+  it('should batch state when updating two different state keys', () => {
+    var updateCount = 0;
+
+    class Component extends React.Component {
+      state = {x: 0, y: 0};
+
+      componentDidUpdate() {
+        updateCount++;
+      }
+
+      render() {
+        return <div>({this.state.x}, {this.state.y})</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    expect(instance.state.x).toBe(0);
+    expect(instance.state.y).toBe(0);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1});
+      instance.setState({y: 2});
+      expect(instance.state.x).toBe(0);
+      expect(instance.state.y).toBe(0);
+      expect(updateCount).toBe(0);
+    });
+
+    expect(instance.state.x).toBe(1);
+    expect(instance.state.y).toBe(2);
+    expect(updateCount).toBe(1);
+  });
+
+  it('should batch state and props together', () => {
+    var updateCount = 0;
+
+    class Component extends React.Component {
+      state = {y: 0};
+
+      componentDidUpdate() {
+        updateCount++;
+      }
+
+      render() {
+        return <div>({this.props.x}, {this.state.y})</div>;
+      }
+    }
+
+    var container = document.createElement('div');
+    var instance = ReactDOM.render(<Component x={0} />, container);
+    expect(instance.props.x).toBe(0);
+    expect(instance.state.y).toBe(0);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      ReactDOM.render(<Component x={1} />, container);
+      instance.setState({y: 2});
+      expect(instance.props.x).toBe(0);
+      expect(instance.state.y).toBe(0);
+      expect(updateCount).toBe(0);
+    });
+
+    expect(instance.props.x).toBe(1);
+    expect(instance.state.y).toBe(2);
+    expect(updateCount).toBe(1);
+  });
+
+  it('should batch parent/child state updates together', () => {
+    var parentUpdateCount = 0;
+
+    class Parent extends React.Component {
+      state = {x: 0};
+
+      componentDidUpdate() {
+        parentUpdateCount++;
+      }
+
+      render() {
+        return <div><Child ref="child" x={this.state.x} /></div>;
+      }
+    }
+
+    var childUpdateCount = 0;
+
+    class Child extends React.Component {
+      state = {y: 0};
+
+      componentDidUpdate() {
+        childUpdateCount++;
+      }
+
+      render() {
+        return <div>{this.props.x + this.state.y}</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Parent />);
+    var child = instance.refs.child;
+    expect(instance.state.x).toBe(0);
+    expect(child.state.y).toBe(0);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1});
+      child.setState({y: 2});
+      expect(instance.state.x).toBe(0);
+      expect(child.state.y).toBe(0);
+      expect(parentUpdateCount).toBe(0);
+      expect(childUpdateCount).toBe(0);
+    });
+
+    expect(instance.state.x).toBe(1);
+    expect(child.state.y).toBe(2);
+    expect(parentUpdateCount).toBe(1);
+    expect(childUpdateCount).toBe(1);
+  });
+
+  it('should batch child/parent state updates together', () => {
+    var parentUpdateCount = 0;
+
+    class Parent extends React.Component {
+      state = {x: 0};
+
+      componentDidUpdate() {
+        parentUpdateCount++;
+      }
+
+      render() {
+        return <div><Child ref="child" x={this.state.x} /></div>;
+      }
+    }
+
+    var childUpdateCount = 0;
+
+    class Child extends React.Component {
+      state = {y: 0};
+
+      componentDidUpdate() {
+        childUpdateCount++;
+      }
+
+      render() {
+        return <div>{this.props.x + this.state.y}</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Parent />);
+    var child = instance.refs.child;
+    expect(instance.state.x).toBe(0);
+    expect(child.state.y).toBe(0);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      child.setState({y: 2});
+      instance.setState({x: 1});
+      expect(instance.state.x).toBe(0);
+      expect(child.state.y).toBe(0);
+      expect(parentUpdateCount).toBe(0);
+      expect(childUpdateCount).toBe(0);
+    });
+
+    expect(instance.state.x).toBe(1);
+    expect(child.state.y).toBe(2);
+    expect(parentUpdateCount).toBe(1);
+
+    // Batching reduces the number of updates here to 1.
+    expect(childUpdateCount).toBe(1);
+  });
+
+  it('should support chained state updates', () => {
+    var updateCount = 0;
+
+    class Component extends React.Component {
+      state = {x: 0};
+
+      componentDidUpdate() {
+        updateCount++;
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    expect(instance.state.x).toBe(0);
+
+    var innerCallbackRun = false;
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1}, function() {
+        instance.setState({x: 2}, function() {
+          expect(this).toBe(instance);
+          innerCallbackRun = true;
+          expect(instance.state.x).toBe(2);
+          expect(updateCount).toBe(2);
+        });
+        expect(instance.state.x).toBe(1);
+        expect(updateCount).toBe(1);
+      });
+      expect(instance.state.x).toBe(0);
+      expect(updateCount).toBe(0);
+    });
+
+    expect(innerCallbackRun).toBeTruthy();
+    expect(instance.state.x).toBe(2);
+    expect(updateCount).toBe(2);
+  });
+
+  it('should batch forceUpdate together', () => {
+    var shouldUpdateCount = 0;
+    var updateCount = 0;
+
+    class Component extends React.Component {
+      state = {x: 0};
+
+      shouldComponentUpdate() {
+        shouldUpdateCount++;
+      }
+
+      componentDidUpdate() {
+        updateCount++;
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    expect(instance.state.x).toBe(0);
+
+    var callbacksRun = 0;
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1}, function() {
+        callbacksRun++;
+      });
+      instance.forceUpdate(function() {
+        callbacksRun++;
+      });
+      expect(instance.state.x).toBe(0);
+      expect(updateCount).toBe(0);
+    });
+
+    expect(callbacksRun).toBe(2);
+    // shouldComponentUpdate shouldn't be called since we're forcing
+    expect(shouldUpdateCount).toBe(0);
+    expect(instance.state.x).toBe(1);
+    expect(updateCount).toBe(1);
+  });
+
+  it('should update children even if parent blocks updates', () => {
+    var parentRenderCount = 0;
+    var childRenderCount = 0;
+
+    class Parent extends React.Component {
+      shouldComponentUpdate() {
+        return false;
+      }
+
+      render() {
+        parentRenderCount++;
+        return <Child ref="child" />;
+      }
+    }
+
+    class Child extends React.Component {
+      render() {
+        childRenderCount++;
+        return <div />;
+      }
+    }
+
+    expect(parentRenderCount).toBe(0);
+    expect(childRenderCount).toBe(0);
+
+    var instance = <Parent />;
+    instance = ReactTestUtils.renderIntoDocument(instance);
+
+    expect(parentRenderCount).toBe(1);
+    expect(childRenderCount).toBe(1);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.setState({x: 1});
+    });
+
+    expect(parentRenderCount).toBe(1);
+    expect(childRenderCount).toBe(1);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      instance.refs.child.setState({x: 1});
+    });
+
+    expect(parentRenderCount).toBe(1);
+    expect(childRenderCount).toBe(2);
+  });
+
+  it('should not reconcile children passed via props', () => {
+    var numMiddleRenders = 0;
+    var numBottomRenders = 0;
+
+    class Top extends React.Component {
+      render() {
+        return <Middle><Bottom /></Middle>;
+      }
+    }
+
+    class Middle extends React.Component {
+      componentDidMount() {
+        this.forceUpdate();
+      }
+
+      render() {
+        numMiddleRenders++;
+        return React.Children.only(this.props.children);
+      }
+    }
+
+    class Bottom extends React.Component {
+      render() {
+        numBottomRenders++;
+        return null;
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<Top />);
+    expect(numMiddleRenders).toBe(2);
+    expect(numBottomRenders).toBe(1);
+  });
+
+  it('should flow updates correctly', () => {
+    var willUpdates = [];
+    var didUpdates = [];
+
+    var UpdateLoggingMixin = {
+      componentWillUpdate: function() {
+        willUpdates.push(this.constructor.displayName);
+      },
+      componentDidUpdate: function() {
+        didUpdates.push(this.constructor.displayName);
+      },
+    };
+
+    class Box extends React.Component {
+      render() {
+        return <div ref="boxDiv">{this.props.children}</div>;
+      }
+    }
+    Object.assign(Box.prototype, UpdateLoggingMixin);
+
+    class Child extends React.Component {
+      render() {
+        return <span ref="span">child</span>;
+      }
+    }
+    Object.assign(Child.prototype, UpdateLoggingMixin);
+
+    class Switcher extends React.Component {
+      state = {tabKey: 'hello'};
+      render() {
+        var child = this.props.children;
+
+        return (
+          <Box ref="box">
+            <div
+              ref="switcherDiv"
+              style={{
+                display: this.state.tabKey === child.key ? '' : 'none',
+              }}>
+              {child}
+            </div>
+          </Box>
+        );
+      }
+    }
+    Object.assign(Switcher.prototype, UpdateLoggingMixin);
+
+    class App extends React.Component {
+      render() {
+        return (
+          <Switcher ref="switcher">
+            <Child key="hello" ref="child" />
+          </Switcher>
+        );
+      }
+    }
+    Object.assign(App.prototype, UpdateLoggingMixin);
+
+    var root = <App />;
+    root = ReactTestUtils.renderIntoDocument(root);
+
+    function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
+      var i;
+      for (i = 0; i < desiredWillUpdates; i++) {
+        expect(willUpdates).toContain(desiredWillUpdates[i]);
+      }
+      for (i = 0; i < desiredDidUpdates; i++) {
+        expect(didUpdates).toContain(desiredDidUpdates[i]);
+      }
+      willUpdates = [];
+      didUpdates = [];
+    }
+
+    function triggerUpdate(c) {
+      c.setState({x: 1});
+    }
+
+    function testUpdates(components, desiredWillUpdates, desiredDidUpdates) {
+      var i;
+
+      ReactDOM.unstable_batchedUpdates(function() {
+        for (i = 0; i < components.length; i++) {
+          triggerUpdate(components[i]);
+        }
+      });
+
+      expectUpdates(desiredWillUpdates, desiredDidUpdates);
+
+      // Try them in reverse order
+
+      ReactDOM.unstable_batchedUpdates(function() {
+        for (i = components.length - 1; i >= 0; i--) {
+          triggerUpdate(components[i]);
+        }
+      });
+
+      expectUpdates(desiredWillUpdates, desiredDidUpdates);
+    }
+    testUpdates(
+      [root.refs.switcher.refs.box, root.refs.switcher],
+      // Owner-child relationships have inverse will and did
+      ['Switcher', 'Box'],
+      ['Box', 'Switcher'],
+    );
+
+    testUpdates(
+      [root.refs.child, root.refs.switcher.refs.box],
+      // Not owner-child so reconcile independently
+      ['Box', 'Child'],
+      ['Box', 'Child'],
+    );
+
+    testUpdates(
+      [root.refs.child, root.refs.switcher],
+      // Switcher owns Box and Child, Box does not own Child
+      ['Switcher', 'Box', 'Child'],
+      ['Box', 'Switcher', 'Child'],
+    );
+  });
+
+  it('should queue mount-ready handlers across different roots', () => {
+    // We'll define two components A and B, then update both of them. When A's
+    // componentDidUpdate handlers is called, B's DOM should already have been
+    // updated.
+
+    var bContainer = document.createElement('div');
+
+    var a;
+    var b;
+
+    var aUpdated = false;
+
+    class A extends React.Component {
+      state = {x: 0};
+
+      componentDidUpdate() {
+        expect(ReactDOM.findDOMNode(b).textContent).toBe('B1');
+        aUpdated = true;
+      }
+
+      render() {
+        var portal = null;
+        // If we're using Fiber, we use Portals instead to achieve this.
+        portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
+        return <div>A{this.state.x}{portal}</div>;
+      }
+    }
+
+    class B extends React.Component {
+      state = {x: 0};
+
+      render() {
+        return <div>B{this.state.x}</div>;
+      }
+    }
+
+    a = ReactTestUtils.renderIntoDocument(<A />);
+    ReactDOM.unstable_batchedUpdates(function() {
+      a.setState({x: 1});
+      b.setState({x: 1});
+    });
+
+    expect(aUpdated).toBe(true);
+  });
+
+  it('should flush updates in the correct order', () => {
+    var updates = [];
+
+    class Outer extends React.Component {
+      state = {x: 0};
+
+      render() {
+        updates.push('Outer-render-' + this.state.x);
+        return <div><Inner x={this.state.x} ref="inner" /></div>;
+      }
+
+      componentDidUpdate() {
+        var x = this.state.x;
+        updates.push('Outer-didUpdate-' + x);
+        updates.push('Inner-setState-' + x);
+        this.refs.inner.setState({x: x}, function() {
+          updates.push('Inner-callback-' + x);
+        });
+      }
+    }
+
+    class Inner extends React.Component {
+      state = {x: 0};
+
+      render() {
+        updates.push('Inner-render-' + this.props.x + '-' + this.state.x);
+        return <div />;
+      }
+
+      componentDidUpdate() {
+        updates.push('Inner-didUpdate-' + this.props.x + '-' + this.state.x);
+      }
+    }
+
+    var instance = ReactTestUtils.renderIntoDocument(<Outer />);
+
+    updates.push('Outer-setState-1');
+    instance.setState({x: 1}, function() {
+      updates.push('Outer-callback-1');
+      updates.push('Outer-setState-2');
+      instance.setState({x: 2}, function() {
+        updates.push('Outer-callback-2');
+      });
+    });
+
+    /* eslint-disable indent */
+    expect(updates).toEqual([
+      'Outer-render-0',
+      'Inner-render-0-0',
+
+      'Outer-setState-1',
+      'Outer-render-1',
+      'Inner-render-1-0',
+      'Inner-didUpdate-1-0',
+      'Outer-didUpdate-1',
+      // Happens in a batch, so don't re-render yet
+      'Inner-setState-1',
+      'Outer-callback-1',
+
+      // Happens in a batch
+      'Outer-setState-2',
+
+      // Flush batched updates all at once
+      'Outer-render-2',
+      'Inner-render-2-1',
+      'Inner-didUpdate-2-1',
+      'Inner-callback-1',
+      'Outer-didUpdate-2',
+      'Inner-setState-2',
+      'Outer-callback-2',
+      'Inner-render-2-2',
+      'Inner-didUpdate-2-2',
+      'Inner-callback-2',
+    ]);
+    /* eslint-enable indent */
+  });
+
+  it('should flush updates in the correct order across roots', () => {
+    var instances = [];
+    var updates = [];
+
+    class MockComponent extends React.Component {
+      render() {
+        updates.push(this.props.depth);
+        return <div />;
+      }
+
+      componentDidMount() {
+        instances.push(this);
+        if (this.props.depth < this.props.count) {
+          ReactDOM.render(
+            <MockComponent
+              depth={this.props.depth + 1}
+              count={this.props.count}
+            />,
+            ReactDOM.findDOMNode(this),
+          );
+        }
+      }
+    }
+
+    ReactTestUtils.renderIntoDocument(<MockComponent depth={0} count={2} />);
+
+    expect(updates).toEqual([0, 1, 2]);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      // Simulate update on each component from top to bottom.
+      instances.forEach(function(instance) {
+        instance.forceUpdate();
+      });
+    });
+
+    expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
+  });
+
+  it('should queue nested updates', () => {
+    // See https://github.com/facebook/react/issues/1147
+
+    class X extends React.Component {
+      state = {s: 0};
+
+      render() {
+        if (this.state.s === 0) {
+          return (
+            <div>
+              <span>0</span>
+            </div>
+          );
+        } else {
+          return <div>1</div>;
+        }
+      }
+
+      go = () => {
+        this.setState({s: 1});
+        this.setState({s: 0});
+        this.setState({s: 1});
+      };
+    }
+
+    class Y extends React.Component {
+      render() {
+        return (
+          <div>
+            <Z />
+          </div>
+        );
+      }
+    }
+
+    class Z extends React.Component {
+      render() {
+        return <div />;
+      }
+
+      componentWillUpdate() {
+        x.go();
+      }
+    }
+
+    var x;
+    var y;
+
+    x = ReactTestUtils.renderIntoDocument(<X />);
+    y = ReactTestUtils.renderIntoDocument(<Y />);
+    expect(ReactDOM.findDOMNode(x).textContent).toBe('0');
+
+    y.forceUpdate();
+    expect(ReactDOM.findDOMNode(x).textContent).toBe('1');
+  });
+
+  it('should queue updates from during mount', () => {
+    // See https://github.com/facebook/react/issues/1353
+    var a;
+
+    class A extends React.Component {
+      state = {x: 0};
+
+      componentWillMount() {
+        a = this;
+      }
+
+      render() {
+        return <div>A{this.state.x}</div>;
+      }
+    }
+
+    class B extends React.Component {
+      componentWillMount() {
+        a.setState({x: 1});
+      }
+
+      render() {
+        return <div />;
+      }
+    }
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      ReactTestUtils.renderIntoDocument(
+        <div>
+          <A />
+          <B />
+        </div>,
+      );
+    });
+
+    expect(a.state.x).toBe(1);
+    expect(ReactDOM.findDOMNode(a).textContent).toBe('A1');
+  });
+
+  it('calls componentWillReceiveProps setState callback properly', () => {
+    var callbackCount = 0;
+
+    class A extends React.Component {
+      state = {x: this.props.x};
+
+      componentWillReceiveProps(nextProps) {
+        var newX = nextProps.x;
+        this.setState({x: newX}, function() {
+          // State should have updated by the time this callback gets called
+          expect(this.state.x).toBe(newX);
+          callbackCount++;
+        });
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    var container = document.createElement('div');
+    ReactDOM.render(<A x={1} />, container);
+    ReactDOM.render(<A x={2} />, container);
+    expect(callbackCount).toBe(1);
+  });
+
+  it('does not call render after a component as been deleted', () => {
+    var renderCount = 0;
+    var componentB = null;
+
+    class B extends React.Component {
+      state = {updates: 0};
+
+      componentDidMount() {
+        componentB = this;
+      }
+
+      render() {
+        renderCount++;
+        return <div />;
+      }
+    }
+
+    class A extends React.Component {
+      state = {showB: true};
+
+      render() {
+        return this.state.showB ? <B /> : <div />;
+      }
+    }
+
+    var component = ReactTestUtils.renderIntoDocument(<A />);
+
+    ReactDOM.unstable_batchedUpdates(function() {
+      // B will have scheduled an update but the batching should ensure that its
+      // update never fires.
+      componentB.setState({updates: 1});
+      component.setState({showB: false});
+    });
+
+    expect(renderCount).toBe(1);
+  });
+
+  it('throws in setState if the update callback is not a function', () => {
+    spyOn(console, 'error');
+
+    function Foo() {
+      this.a = 1;
+      this.b = 2;
+    }
+
+    class A extends React.Component {
+      state = {};
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var component = ReactTestUtils.renderIntoDocument(<A />);
+
+    expect(() => component.setState({}, 'no')).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: no',
+    );
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'setState(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: no.',
+    );
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => component.setState({}, {foo: 'bar'})).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
+    expectDev(console.error.calls.argsFor(1)[0]).toContain(
+      'setState(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: [object Object].',
+    );
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => component.setState({}, new Foo())).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
+    expectDev(console.error.calls.argsFor(2)[0]).toContain(
+      'setState(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: [object Object].',
+    );
+    expect(console.error.calls.count()).toBe(3);
+  });
+
+  it('throws in forceUpdate if the update callback is not a function', () => {
+    spyOn(console, 'error');
+
+    function Foo() {
+      this.a = 1;
+      this.b = 2;
+    }
+
+    class A extends React.Component {
+      state = {};
+
+      render() {
+        return <div />;
+      }
+    }
+
+    var component = ReactTestUtils.renderIntoDocument(<A />);
+
+    expect(() => component.forceUpdate('no')).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: no',
+    );
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: no.',
+    );
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => component.forceUpdate({foo: 'bar'})).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
+    expectDev(console.error.calls.argsFor(1)[0]).toContain(
+      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: [object Object].',
+    );
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => component.forceUpdate(new Foo())).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
+    expectDev(console.error.calls.argsFor(2)[0]).toContain(
+      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+        'a function. Instead received: [object Object].',
+    );
+    expect(console.error.calls.count()).toBe(3);
+  });
+
+  it('does not update one component twice in a batch (#2410)', () => {
+    class Parent extends React.Component {
+      getChild = () => {
+        return this.refs.child;
+      };
+
+      render() {
+        return <Child ref="child" />;
+      }
+    }
+
+    var renderCount = 0;
+    var postRenderCount = 0;
+    var once = false;
+
+    class Child extends React.Component {
+      state = {updated: false};
+
+      componentWillUpdate() {
+        if (!once) {
+          once = true;
+          this.setState({updated: true});
+        }
+      }
+
+      componentDidMount() {
+        expect(renderCount).toBe(postRenderCount + 1);
+        postRenderCount++;
+      }
+
+      componentDidUpdate() {
+        expect(renderCount).toBe(postRenderCount + 1);
+        postRenderCount++;
+      }
+
+      render() {
+        expect(renderCount).toBe(postRenderCount);
+        renderCount++;
+        return <div />;
+      }
+    }
+
+    var parent = ReactTestUtils.renderIntoDocument(<Parent />);
+    var child = parent.getChild();
+    ReactDOM.unstable_batchedUpdates(function() {
+      parent.forceUpdate();
+      child.forceUpdate();
+    });
+  });
+
+  it('does not update one component twice in a batch (#6371)', () => {
+    var callbacks = [];
+    function emitChange() {
+      callbacks.forEach(c => c());
+    }
+
+    class App extends React.Component {
+      constructor(props) {
+        super(props);
+        this.state = {showChild: true};
+      }
+      componentDidMount() {
+        this.setState({showChild: false});
+      }
+      render() {
+        return (
+          <div>
+            <ForceUpdatesOnChange />
+            {this.state.showChild && <EmitsChangeOnUnmount />}
+          </div>
+        );
+      }
+    }
+
+    class EmitsChangeOnUnmount extends React.Component {
+      componentWillUnmount() {
+        emitChange();
+      }
+      render() {
+        return null;
+      }
+    }
+
+    class ForceUpdatesOnChange extends React.Component {
+      componentDidMount() {
+        this.onChange = () => this.forceUpdate();
+        this.onChange();
+        callbacks.push(this.onChange);
+      }
+      componentWillUnmount() {
+        callbacks = callbacks.filter(c => c !== this.onChange);
+      }
+      render() {
+        return <div key={Math.random()} onClick={function() {}} />;
+      }
+    }
+
+    ReactDOM.render(<App />, document.createElement('div'));
+  });
+
+  it('unstable_batchedUpdates should return value from a callback', () => {
+    var result = ReactDOM.unstable_batchedUpdates(function() {
+      return 42;
+    });
+    expect(result).toEqual(42);
+  });
+
+  it('unmounts and remounts a root in the same batch', () => {
+    var container = document.createElement('div');
+    ReactDOM.render(<span>a</span>, container);
+    ReactDOM.unstable_batchedUpdates(function() {
+      ReactDOM.unmountComponentAtNode(container);
+      ReactDOM.render(<span>b</span>, container);
+    });
+    expect(container.textContent).toBe('b');
+  });
+
+  it('handles reentrant mounting in synchronous mode', () => {
+    var mounts = 0;
+    class Editor extends React.Component {
+      render() {
+        return <div>{this.props.text}</div>;
+      }
+      componentDidMount() {
+        mounts++;
+        // This should be called only once but we guard just in case.
+        if (!this.props.rendered) {
+          this.props.onChange({rendered: true});
+        }
+      }
+    }
+
+    var container = document.createElement('div');
+    function render() {
+      ReactDOM.render(
+        <Editor
+          onChange={newProps => {
+            props = {...props, ...newProps};
+            render();
+          }}
+          {...props}
+        />,
+        container,
+      );
+    }
+
+    var props = {text: 'hello', rendered: false};
+    render();
+    props = {...props, text: 'goodbye'};
+    render();
+    expect(container.textContent).toBe('goodbye');
+    expect(mounts).toBe(1);
+  });
+
+  it('mounts and unmounts are sync even in a batch', () => {
+    var ops = [];
+    var container = document.createElement('div');
+    ReactDOM.unstable_batchedUpdates(() => {
+      ReactDOM.render(<div>Hello</div>, container);
+      ops.push(container.textContent);
+      ReactDOM.unmountComponentAtNode(container);
+      ops.push(container.textContent);
+    });
+    expect(ops).toEqual(['Hello', '']);
+  });
+
+  it(
+    'in sync mode, updates in componentWillUpdate and componentDidUpdate ' +
+      'should both flush in the immediately subsequent commit',
+    () => {
+      let ops = [];
+      class Foo extends React.Component {
+        state = {a: false, b: false};
+        componentWillUpdate(_, nextState) {
+          if (!nextState.a) {
+            this.setState({a: true});
+          }
+        }
+        componentDidUpdate() {
+          ops.push('Foo updated');
+          if (!this.state.b) {
+            this.setState({b: true});
+          }
+        }
+        render() {
+          ops.push(`a: ${this.state.a}, b: ${this.state.b}`);
+          return null;
+        }
+      }
+
+      const container = document.createElement('div');
+      // Mount
+      ReactDOM.render(<Foo />, container);
+      // Root update
+      ReactDOM.render(<Foo />, container);
+      expect(ops).toEqual([
+        // Mount
+        'a: false, b: false',
+        // Root update
+        'a: false, b: false',
+        'Foo updated',
+        // Subsequent update (both a and b should have flushed)
+        'a: true, b: true',
+        'Foo updated',
+        // There should not be any additional updates
+      ]);
+    },
+  );
+
+  it(
+    'in sync mode, updates in componentWillUpdate and componentDidUpdate ' +
+      '(on a sibling) should both flush in the immediately subsequent commit',
+    () => {
+      let ops = [];
+      class Foo extends React.Component {
+        state = {a: false};
+        componentWillUpdate(_, nextState) {
+          if (!nextState.a) {
+            this.setState({a: true});
+          }
+        }
+        componentDidUpdate() {
+          ops.push('Foo updated');
+        }
+        render() {
+          ops.push(`a: ${this.state.a}`);
+          return null;
+        }
+      }
+
+      class Bar extends React.Component {
+        state = {b: false};
+        componentDidUpdate() {
+          ops.push('Bar updated');
+          if (!this.state.b) {
+            this.setState({b: true});
+          }
+        }
+        render() {
+          ops.push(`b: ${this.state.b}`);
+          return null;
+        }
+      }
+
+      const container = document.createElement('div');
+      // Mount
+      ReactDOM.render(<div><Foo /><Bar /></div>, container);
+      // Root update
+      ReactDOM.render(<div><Foo /><Bar /></div>, container);
+      expect(ops).toEqual([
+        // Mount
+        'a: false',
+        'b: false',
+        // Root update
+        'a: false',
+        'b: false',
+        'Foo updated',
+        'Bar updated',
+        // Subsequent update (both a and b should have flushed)
+        'a: true',
+        'b: true',
+        'Foo updated',
+        'Bar updated',
+        // There should not be any additional updates
+      ]);
+    },
+  );
+
+  it('uses correct base state for setState inside render phase', () => {
+    spyOn(console, 'error');
+
+    let ops = [];
+
+    class Foo extends React.Component {
+      state = {step: 0};
+      render() {
+        const memoizedStep = this.state.step;
+        this.setState(baseState => {
+          const baseStep = baseState.step;
+          ops.push(`base: ${baseStep}, memoized: ${memoizedStep}`);
+          return baseStep === 0 ? {step: 1} : null;
+        });
+        return null;
+      }
+    }
+
+    const container = document.createElement('div');
+    ReactDOM.render(<Foo />, container);
+    expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
+    expect(console.error.calls.count()).toBe(1);
+    expect(console.error.calls.argsFor(0)[0]).toContain(
+      'Cannot update during an existing state transition',
+    );
+  });
+
+  it('does not re-render if state update is null', () => {
+    let container = document.createElement('div');
+
+    let instance;
+    let ops = [];
+    class Foo extends React.Component {
+      render() {
+        instance = this;
+        ops.push('render');
+        return <div />;
+      }
+    }
+    ReactDOM.render(<Foo />, container);
+
+    ops = [];
+    instance.setState(() => null);
+    expect(ops).toEqual([]);
+  });
+
+  // Will change once we switch to async by default
+  it('synchronously renders hidden subtrees', () => {
+    const container = document.createElement('div');
+    let ops = [];
+
+    function Baz() {
+      ops.push('Baz');
+      return null;
+    }
+
+    function Bar() {
+      ops.push('Bar');
+      return null;
+    }
+
+    function Foo() {
+      ops.push('Foo');
+      return (
+        <div>
+          <div hidden={true}><Bar /></div>
+          <Baz />
+        </div>
+      );
+    }
+
+    // Mount
+    ReactDOM.render(<Foo />, container);
+    expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
+    ops = [];
+
+    // Update
+    ReactDOM.render(<Foo />, container);
+    expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
+  });
+
+  it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
+    class Foo extends React.Component {
+      componentDidMount() {
+        const limit = 1200;
+        for (let i = 0; i < limit; i++) {
+          if (i < limit - 1) {
+            ReactDOM.render(<div />, document.createElement('div'));
+          } else {
+            ReactDOM.render(<div />, document.createElement('div'), () => {
+              // The "nested update limit" error isn't thrown until setState
+              this.setState({});
+            });
+          }
+        }
+      }
+      render() {
+        return null;
+      }
+    }
+
+    const container = document.createElement('div');
+    ReactDOM.render(<Foo />, container);
+  });
+
+  it('does not fall into an infinite update loop', () => {
+    class NonTerminating extends React.Component {
+      state = {step: 0};
+      componentDidMount() {
+        this.setState({step: 1});
+      }
+      componentWillUpdate() {
+        this.setState({step: 2});
+      }
+      render() {
+        return <div>Hello {this.props.name}{this.state.step}</div>;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<NonTerminating />, container);
+    }).toThrow('Maximum');
+  });
+
+  it('does not fall into an infinite error loop', () => {
+    function BadRender() {
+      throw new Error('error');
+    }
+
+    class ErrorBoundary extends React.Component {
+      componentDidCatch() {
+        this.props.parent.remount();
+      }
+      render() {
+        return <BadRender />;
+      }
+    }
+
+    class NonTerminating extends React.Component {
+      state = {step: 0};
+      remount() {
+        this.setState(state => ({step: state.step + 1}));
+      }
+      render() {
+        return <ErrorBoundary key={this.state.step} parent={this} />;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<NonTerminating />, container);
+    }).toThrow('Maximum');
+  });
+});

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index ab7acbb429..676b17ac8d 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -60,7 +60,11 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        return <div>({this.state.x}, {this.state.y})</div>;
+        return (
+          <div>
+            ({this.state.x}, {this.state.y})
+          </div>
+        );
       }
     }
 
@@ -92,7 +96,11 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        return <div>({this.props.x}, {this.state.y})</div>;
+        return (
+          <div>
+            ({this.props.x}, {this.state.y})
+          </div>
+        );
       }
     }
 
@@ -125,7 +133,11 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        return <div><Child ref="child" x={this.state.x} /></div>;
+        return (
+          <div>
+            <Child ref="child" x={this.state.x} />
+          </div>
+        );
       }
     }
 
@@ -174,7 +186,11 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        return <div><Child ref="child" x={this.state.x} /></div>;
+        return (
+          <div>
+            <Child ref="child" x={this.state.x} />
+          </div>
+        );
       }
     }
 
@@ -347,7 +363,11 @@ describe('ReactUpdates', () => {
 
     class Top extends React.Component {
       render() {
-        return <Middle><Bottom /></Middle>;
+        return (
+          <Middle>
+            <Bottom />
+          </Middle>
+        );
       }
     }
 
@@ -518,7 +538,12 @@ describe('ReactUpdates', () => {
         var portal = null;
         // If we're using Fiber, we use Portals instead to achieve this.
         portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
-        return <div>A{this.state.x}{portal}</div>;
+        return (
+          <div>
+            A{this.state.x}
+            {portal}
+          </div>
+        );
       }
     }
 
@@ -547,7 +572,11 @@ describe('ReactUpdates', () => {
 
       render() {
         updates.push('Outer-render-' + this.state.x);
-        return <div><Inner x={this.state.x} ref="inner" /></div>;
+        return (
+          <div>
+            <Inner x={this.state.x} ref="inner" />
+          </div>
+        );
       }
 
       componentDidUpdate() {
@@ -1152,9 +1181,21 @@ describe('ReactUpdates', () => {
 
       const container = document.createElement('div');
       // Mount
-      ReactDOM.render(<div><Foo /><Bar /></div>, container);
+      ReactDOM.render(
+        <div>
+          <Foo />
+          <Bar />
+        </div>,
+        container,
+      );
       // Root update
-      ReactDOM.render(<div><Foo /><Bar /></div>, container);
+      ReactDOM.render(
+        <div>
+          <Foo />
+          <Bar />
+        </div>,
+        container,
+      );
       expect(ops).toEqual([
         // Mount
         'a: false',
@@ -1239,7 +1280,9 @@ describe('ReactUpdates', () => {
       ops.push('Foo');
       return (
         <div>
-          <div hidden={true}><Bar /></div>
+          <div hidden={true}>
+            <Bar />
+          </div>
           <Baz />
         </div>
       );
@@ -1289,7 +1332,12 @@ describe('ReactUpdates', () => {
         this.setState({step: 2});
       }
       render() {
-        return <div>Hello {this.props.name}{this.state.step}</div>;
+        return (
+          <div>
+            Hello {this.props.name}
+            {this.state.step}
+          </div>
+        );
       }
     }
 

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 676b17ac8d..8bca250ab1 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -842,7 +842,7 @@ describe('ReactUpdates', () => {
   });
 
   it('throws in setState if the update callback is not a function', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     function Foo() {
       this.a = 1;
@@ -863,33 +863,39 @@ describe('ReactUpdates', () => {
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'setState(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: no.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'setState(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: no.',
+      );
+    }
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => component.setState({}, {foo: 'bar'})).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    expectDev(console.error.calls.argsFor(1)[0]).toContain(
-      'setState(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: [object Object].',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(1)[0]).toContain(
+        'setState(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      );
+    }
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => component.setState({}, new Foo())).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    expectDev(console.error.calls.argsFor(2)[0]).toContain(
-      'setState(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: [object Object].',
-    );
-    expect(console.error.calls.count()).toBe(3);
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(2)[0]).toContain(
+        'setState(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      );
+      expect(console.error.calls.count()).toBe(3);
+    }
   });
 
   it('throws in forceUpdate if the update callback is not a function', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     function Foo() {
       this.a = 1;
@@ -910,29 +916,35 @@ describe('ReactUpdates', () => {
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: no.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: no.',
+      );
+    }
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => component.forceUpdate({foo: 'bar'})).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    expectDev(console.error.calls.argsFor(1)[0]).toContain(
-      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: [object Object].',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(1)[0]).toContain(
+        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      );
+    }
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => component.forceUpdate(new Foo())).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    expectDev(console.error.calls.argsFor(2)[0]).toContain(
-      'forceUpdate(...): Expected the last optional `callback` argument to be ' +
-        'a function. Instead received: [object Object].',
-    );
-    expect(console.error.calls.count()).toBe(3);
+    if (__DEV__) {
+      expect(console.error.calls.argsFor(2)[0]).toContain(
+        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      );
+      expect(console.error.calls.count()).toBe(3);
+    }
   });
 
   it('does not update one component twice in a batch (#2410)', () => {
@@ -1216,7 +1228,7 @@ describe('ReactUpdates', () => {
   );
 
   it('uses correct base state for setState inside render phase', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
 
     let ops = [];
 
@@ -1236,10 +1248,12 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     ReactDOM.render(<Foo />, container);
     expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
-    expect(console.error.calls.count()).toBe(1);
-    expect(console.error.calls.argsFor(0)[0]).toContain(
-      'Cannot update during an existing state transition',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Cannot update during an existing state transition',
+      );
+    }
   });
 
   it('does not re-render if state update is null', () => {

commit 48616e591fe23c0b89b0823c3ec99bae2d7b6853
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Tue Dec 5 16:29:22 2017 -0200

    react-dom: convert packages/react-dom/src/__tests__ (#11776)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 8bca250ab1..b033550641 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -9,9 +9,9 @@
 
 'use strict';
 
-var React;
-var ReactDOM;
-var ReactTestUtils;
+let React;
+let ReactDOM;
+let ReactTestUtils;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
@@ -21,7 +21,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch state when updating state twice', () => {
-    var updateCount = 0;
+    let updateCount = 0;
 
     class Component extends React.Component {
       state = {x: 0};
@@ -35,7 +35,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance.state.x).toBe(0);
 
     ReactDOM.unstable_batchedUpdates(function() {
@@ -50,7 +50,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch state when updating two different state keys', () => {
-    var updateCount = 0;
+    let updateCount = 0;
 
     class Component extends React.Component {
       state = {x: 0, y: 0};
@@ -68,7 +68,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance.state.x).toBe(0);
     expect(instance.state.y).toBe(0);
 
@@ -86,7 +86,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch state and props together', () => {
-    var updateCount = 0;
+    let updateCount = 0;
 
     class Component extends React.Component {
       state = {y: 0};
@@ -104,8 +104,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var container = document.createElement('div');
-    var instance = ReactDOM.render(<Component x={0} />, container);
+    const container = document.createElement('div');
+    const instance = ReactDOM.render(<Component x={0} />, container);
     expect(instance.props.x).toBe(0);
     expect(instance.state.y).toBe(0);
 
@@ -123,7 +123,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch parent/child state updates together', () => {
-    var parentUpdateCount = 0;
+    let parentUpdateCount = 0;
 
     class Parent extends React.Component {
       state = {x: 0};
@@ -141,7 +141,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var childUpdateCount = 0;
+    let childUpdateCount = 0;
 
     class Child extends React.Component {
       state = {y: 0};
@@ -155,8 +155,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    var child = instance.refs.child;
+    const instance = ReactTestUtils.renderIntoDocument(<Parent />);
+    const child = instance.refs.child;
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
@@ -176,7 +176,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch child/parent state updates together', () => {
-    var parentUpdateCount = 0;
+    let parentUpdateCount = 0;
 
     class Parent extends React.Component {
       state = {x: 0};
@@ -194,7 +194,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var childUpdateCount = 0;
+    let childUpdateCount = 0;
 
     class Child extends React.Component {
       state = {y: 0};
@@ -208,8 +208,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    var child = instance.refs.child;
+    const instance = ReactTestUtils.renderIntoDocument(<Parent />);
+    const child = instance.refs.child;
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
@@ -231,7 +231,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should support chained state updates', () => {
-    var updateCount = 0;
+    let updateCount = 0;
 
     class Component extends React.Component {
       state = {x: 0};
@@ -245,10 +245,10 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance.state.x).toBe(0);
 
-    var innerCallbackRun = false;
+    let innerCallbackRun = false;
     ReactDOM.unstable_batchedUpdates(function() {
       instance.setState({x: 1}, function() {
         instance.setState({x: 2}, function() {
@@ -270,8 +270,8 @@ describe('ReactUpdates', () => {
   });
 
   it('should batch forceUpdate together', () => {
-    var shouldUpdateCount = 0;
-    var updateCount = 0;
+    let shouldUpdateCount = 0;
+    let updateCount = 0;
 
     class Component extends React.Component {
       state = {x: 0};
@@ -289,10 +289,10 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const instance = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance.state.x).toBe(0);
 
-    var callbacksRun = 0;
+    let callbacksRun = 0;
     ReactDOM.unstable_batchedUpdates(function() {
       instance.setState({x: 1}, function() {
         callbacksRun++;
@@ -312,8 +312,8 @@ describe('ReactUpdates', () => {
   });
 
   it('should update children even if parent blocks updates', () => {
-    var parentRenderCount = 0;
-    var childRenderCount = 0;
+    let parentRenderCount = 0;
+    let childRenderCount = 0;
 
     class Parent extends React.Component {
       shouldComponentUpdate() {
@@ -336,7 +336,7 @@ describe('ReactUpdates', () => {
     expect(parentRenderCount).toBe(0);
     expect(childRenderCount).toBe(0);
 
-    var instance = <Parent />;
+    let instance = <Parent />;
     instance = ReactTestUtils.renderIntoDocument(instance);
 
     expect(parentRenderCount).toBe(1);
@@ -358,8 +358,8 @@ describe('ReactUpdates', () => {
   });
 
   it('should not reconcile children passed via props', () => {
-    var numMiddleRenders = 0;
-    var numBottomRenders = 0;
+    let numMiddleRenders = 0;
+    let numBottomRenders = 0;
 
     class Top extends React.Component {
       render() {
@@ -395,10 +395,10 @@ describe('ReactUpdates', () => {
   });
 
   it('should flow updates correctly', () => {
-    var willUpdates = [];
-    var didUpdates = [];
+    let willUpdates = [];
+    let didUpdates = [];
 
-    var UpdateLoggingMixin = {
+    const UpdateLoggingMixin = {
       componentWillUpdate: function() {
         willUpdates.push(this.constructor.displayName);
       },
@@ -424,7 +424,7 @@ describe('ReactUpdates', () => {
     class Switcher extends React.Component {
       state = {tabKey: 'hello'};
       render() {
-        var child = this.props.children;
+        const child = this.props.children;
 
         return (
           <Box ref="box">
@@ -452,11 +452,11 @@ describe('ReactUpdates', () => {
     }
     Object.assign(App.prototype, UpdateLoggingMixin);
 
-    var root = <App />;
+    let root = <App />;
     root = ReactTestUtils.renderIntoDocument(root);
 
     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
-      var i;
+      let i;
       for (i = 0; i < desiredWillUpdates; i++) {
         expect(willUpdates).toContain(desiredWillUpdates[i]);
       }
@@ -472,7 +472,7 @@ describe('ReactUpdates', () => {
     }
 
     function testUpdates(components, desiredWillUpdates, desiredDidUpdates) {
-      var i;
+      let i;
 
       ReactDOM.unstable_batchedUpdates(function() {
         for (i = 0; i < components.length; i++) {
@@ -519,12 +519,12 @@ describe('ReactUpdates', () => {
     // componentDidUpdate handlers is called, B's DOM should already have been
     // updated.
 
-    var bContainer = document.createElement('div');
+    const bContainer = document.createElement('div');
 
-    var a;
-    var b;
+    let a;
+    let b;
 
-    var aUpdated = false;
+    let aUpdated = false;
 
     class A extends React.Component {
       state = {x: 0};
@@ -535,7 +535,7 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        var portal = null;
+        let portal = null;
         // If we're using Fiber, we use Portals instead to achieve this.
         portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
         return (
@@ -565,7 +565,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should flush updates in the correct order', () => {
-    var updates = [];
+    const updates = [];
 
     class Outer extends React.Component {
       state = {x: 0};
@@ -580,7 +580,7 @@ describe('ReactUpdates', () => {
       }
 
       componentDidUpdate() {
-        var x = this.state.x;
+        const x = this.state.x;
         updates.push('Outer-didUpdate-' + x);
         updates.push('Inner-setState-' + x);
         this.refs.inner.setState({x: x}, function() {
@@ -602,7 +602,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var instance = ReactTestUtils.renderIntoDocument(<Outer />);
+    const instance = ReactTestUtils.renderIntoDocument(<Outer />);
 
     updates.push('Outer-setState-1');
     instance.setState({x: 1}, function() {
@@ -646,8 +646,8 @@ describe('ReactUpdates', () => {
   });
 
   it('should flush updates in the correct order across roots', () => {
-    var instances = [];
-    var updates = [];
+    const instances = [];
+    const updates = [];
 
     class MockComponent extends React.Component {
       render() {
@@ -728,8 +728,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var x;
-    var y;
+    let x;
+    let y;
 
     x = ReactTestUtils.renderIntoDocument(<X />);
     y = ReactTestUtils.renderIntoDocument(<Y />);
@@ -741,7 +741,7 @@ describe('ReactUpdates', () => {
 
   it('should queue updates from during mount', () => {
     // See https://github.com/facebook/react/issues/1353
-    var a;
+    let a;
 
     class A extends React.Component {
       state = {x: 0};
@@ -779,13 +779,13 @@ describe('ReactUpdates', () => {
   });
 
   it('calls componentWillReceiveProps setState callback properly', () => {
-    var callbackCount = 0;
+    let callbackCount = 0;
 
     class A extends React.Component {
       state = {x: this.props.x};
 
       componentWillReceiveProps(nextProps) {
-        var newX = nextProps.x;
+        const newX = nextProps.x;
         this.setState({x: newX}, function() {
           // State should have updated by the time this callback gets called
           expect(this.state.x).toBe(newX);
@@ -798,15 +798,15 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     ReactDOM.render(<A x={1} />, container);
     ReactDOM.render(<A x={2} />, container);
     expect(callbackCount).toBe(1);
   });
 
   it('does not call render after a component as been deleted', () => {
-    var renderCount = 0;
-    var componentB = null;
+    let renderCount = 0;
+    let componentB = null;
 
     class B extends React.Component {
       state = {updates: 0};
@@ -829,7 +829,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var component = ReactTestUtils.renderIntoDocument(<A />);
+    const component = ReactTestUtils.renderIntoDocument(<A />);
 
     ReactDOM.unstable_batchedUpdates(function() {
       // B will have scheduled an update but the batching should ensure that its
@@ -857,7 +857,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var component = ReactTestUtils.renderIntoDocument(<A />);
+    let component = ReactTestUtils.renderIntoDocument(<A />);
 
     expect(() => component.setState({}, 'no')).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
@@ -910,7 +910,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var component = ReactTestUtils.renderIntoDocument(<A />);
+    let component = ReactTestUtils.renderIntoDocument(<A />);
 
     expect(() => component.forceUpdate('no')).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
@@ -958,9 +958,9 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var renderCount = 0;
-    var postRenderCount = 0;
-    var once = false;
+    let renderCount = 0;
+    let postRenderCount = 0;
+    let once = false;
 
     class Child extends React.Component {
       state = {updated: false};
@@ -989,8 +989,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var parent = ReactTestUtils.renderIntoDocument(<Parent />);
-    var child = parent.getChild();
+    const parent = ReactTestUtils.renderIntoDocument(<Parent />);
+    const child = parent.getChild();
     ReactDOM.unstable_batchedUpdates(function() {
       parent.forceUpdate();
       child.forceUpdate();
@@ -998,7 +998,7 @@ describe('ReactUpdates', () => {
   });
 
   it('does not update one component twice in a batch (#6371)', () => {
-    var callbacks = [];
+    let callbacks = [];
     function emitChange() {
       callbacks.forEach(c => c());
     }
@@ -1048,14 +1048,14 @@ describe('ReactUpdates', () => {
   });
 
   it('unstable_batchedUpdates should return value from a callback', () => {
-    var result = ReactDOM.unstable_batchedUpdates(function() {
+    const result = ReactDOM.unstable_batchedUpdates(function() {
       return 42;
     });
     expect(result).toEqual(42);
   });
 
   it('unmounts and remounts a root in the same batch', () => {
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     ReactDOM.render(<span>a</span>, container);
     ReactDOM.unstable_batchedUpdates(function() {
       ReactDOM.unmountComponentAtNode(container);
@@ -1065,7 +1065,7 @@ describe('ReactUpdates', () => {
   });
 
   it('handles reentrant mounting in synchronous mode', () => {
-    var mounts = 0;
+    let mounts = 0;
     class Editor extends React.Component {
       render() {
         return <div>{this.props.text}</div>;
@@ -1079,7 +1079,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    var container = document.createElement('div');
+    const container = document.createElement('div');
     function render() {
       ReactDOM.render(
         <Editor
@@ -1093,7 +1093,7 @@ describe('ReactUpdates', () => {
       );
     }
 
-    var props = {text: 'hello', rendered: false};
+    let props = {text: 'hello', rendered: false};
     render();
     props = {...props, text: 'goodbye'};
     render();
@@ -1102,8 +1102,8 @@ describe('ReactUpdates', () => {
   });
 
   it('mounts and unmounts are sync even in a batch', () => {
-    var ops = [];
-    var container = document.createElement('div');
+    const ops = [];
+    const container = document.createElement('div');
     ReactDOM.unstable_batchedUpdates(() => {
       ReactDOM.render(<div>Hello</div>, container);
       ops.push(container.textContent);

commit 9f848f8ebec30b3aaa4844ecaef83b014359c5e3
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 13:55:37 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11957)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()
    
    * Updated several additional tests to use .toWarnDev() matcher
    
    * Updated ReactElementValidator to distinguish between Array and Object in its warning. Also updated its test to use .toWarnDev() matcher.
    
    * Updated a couple of additional tests
    
    * Removed unused normalizeCodeLocInfo() methods

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index b033550641..1b86a59db3 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -842,8 +842,6 @@ describe('ReactUpdates', () => {
   });
 
   it('throws in setState if the update callback is not a function', () => {
-    spyOnDev(console, 'error');
-
     function Foo() {
       this.a = 1;
       this.b = 2;
@@ -859,44 +857,38 @@ describe('ReactUpdates', () => {
 
     let component = ReactTestUtils.renderIntoDocument(<A />);
 
-    expect(() => component.setState({}, 'no')).toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(0)[0]).toContain(
+    expect(() => {
+      expect(() => component.setState({}, 'no')).toWarnDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       );
-    }
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.setState({}, {foo: 'bar'})).toThrowError(
+    }).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
+        'received: no',
     );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(1)[0]).toContain(
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => {
+      expect(() => component.setState({}, {foo: 'bar'})).toWarnDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
-    }
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.setState({}, new Foo())).toThrowError(
+    }).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(2)[0]).toContain(
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => {
+      expect(() => component.setState({}, new Foo())).toWarnDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
-      expect(console.error.calls.count()).toBe(3);
-    }
+    }).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
   });
 
   it('throws in forceUpdate if the update callback is not a function', () => {
-    spyOnDev(console, 'error');
-
     function Foo() {
       this.a = 1;
       this.b = 2;
@@ -912,39 +904,35 @@ describe('ReactUpdates', () => {
 
     let component = ReactTestUtils.renderIntoDocument(<A />);
 
-    expect(() => component.forceUpdate('no')).toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(0)[0]).toContain(
+    expect(() => {
+      expect(() => component.forceUpdate('no')).toWarnDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       );
-    }
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.forceUpdate({foo: 'bar'})).toThrowError(
+    }).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
+        'received: no',
     );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(1)[0]).toContain(
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => {
+      expect(() => component.forceUpdate({foo: 'bar'})).toWarnDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
-    }
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.forceUpdate(new Foo())).toThrowError(
+    }).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    if (__DEV__) {
-      expect(console.error.calls.argsFor(2)[0]).toContain(
+    component = ReactTestUtils.renderIntoDocument(<A />);
+    expect(() => {
+      expect(() => component.forceUpdate(new Foo())).toWarnDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
-      expect(console.error.calls.count()).toBe(3);
-    }
+    }).toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: [object Object]',
+    );
   });
 
   it('does not update one component twice in a batch (#2410)', () => {
@@ -1228,8 +1216,6 @@ describe('ReactUpdates', () => {
   );
 
   it('uses correct base state for setState inside render phase', () => {
-    spyOnDev(console, 'error');
-
     let ops = [];
 
     class Foo extends React.Component {
@@ -1246,14 +1232,10 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    ReactDOM.render(<Foo />, container);
+    expect(() => ReactDOM.render(<Foo />, container)).toWarnDev(
+      'Cannot update during an existing state transition',
+    );
     expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Cannot update during an existing state transition',
-      );
-    }
   });
 
   it('does not re-render if state update is null', () => {

commit 65aeb701955521551848a8a9cc8e9f279ef2e73c
Author: Shi Yan <yenshih95@gmail.com>
Date:   Sun Jan 7 19:52:52 2018 +0800

    Deduplicate warning on invalid callback (#11833) (#11833)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 1b86a59db3..d37f4dbb66 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -876,13 +876,9 @@ describe('ReactUpdates', () => {
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
+    // Make sure the warning is deduplicated and doesn't fire again
     component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => {
-      expect(() => component.setState({}, new Foo())).toWarnDev(
-        'setState(...): Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: [object Object].',
-      );
-    }).toThrowError(
+    expect(() => component.setState({}, new Foo())).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
@@ -923,13 +919,9 @@ describe('ReactUpdates', () => {
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
+    // Make sure the warning is deduplicated and doesn't fire again
     component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => {
-      expect(() => component.forceUpdate(new Foo())).toWarnDev(
-        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: [object Object].',
-      );
-    }).toThrowError(
+    expect(() => component.forceUpdate(new Foo())).toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );

commit 97e2911508a2a7af6f50cf87ae503abe39842bef
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri Jan 19 09:36:46 2018 -0800

    RFC 6: Deprecate unsafe lifecycles (#12028)
    
    * Added unsafe_* lifecycles and deprecation warnings
    If the old lifecycle hooks (componentWillMount, componentWillUpdate, componentWillReceiveProps) are detected, these methods will be called and a deprecation warning will be logged. (In other words, we do not check for both the presence of the old and new lifecycles.) This commit is expected to fail tests.
    
    * Ran lifecycle hook codemod over project
    This should handle the bulk of the updates. I will manually update TypeScript and CoffeeScript tests with another commit.
    The actual command run with this commit was: jscodeshift --parser=flow -t ../react-codemod/transforms/rename-unsafe-lifecycles.js ./packages/**/src/**/*.js
    
    * Manually migrated CoffeeScript and TypeScript tests
    
    * Added inline note to createReactClassIntegration-test
    Explaining why lifecycles hooks have not been renamed in this test.
    
    * Udated NativeMethodsMixin with new lifecycle hooks
    
    * Added static getDerivedStateFromProps to ReactPartialRenderer
    Also added a new set of tests focused on server side lifecycle hooks.
    
    * Added getDerivedStateFromProps to shallow renderer
    Also added warnings for several cases involving getDerivedStateFromProps() as well as the deprecated lifecycles.
    Also added tests for the above.
    
    * Dedupe and DEV-only deprecation warning in server renderer
    
    * Renamed unsafe_* prefix to UNSAFE_* to be more noticeable
    
    * Added getDerivedStateFromProps to ReactFiberClassComponent
    Also updated class component and lifecyle tests to cover the added functionality.
    
    * Warn about UNSAFE_componentWillRecieveProps misspelling
    
    * Added tests to createReactClassIntegration for new lifecycles
    
    * Added warning for stateless functional components with gDSFP
    
    * Added createReactClass test for static gDSFP
    
    * Moved lifecycle deprecation warnings behind (disabled) feature flag
    
    Updated tests accordingly, by temporarily splitting tests that were specific to this feature-flag into their own, internal tests. This was the only way I knew of to interact with the feature flag without breaking our build/dist tests.
    
    * Tidying up
    
    * Tweaked warning message wording slightly
    Replaced 'You may may have returned undefined.' with 'You may have returned undefined.'
    
    * Replaced truthy partialState checks with != null
    
    * Call getDerivedStateFromProps via .call(null) to prevent type access
    
    * Move shallow-renderer didWarn* maps off the instance
    
    * Only call getDerivedStateFromProps if props instance has changed
    
    * Avoid creating new state object if not necessary
    
    * Inject state as a param to callGetDerivedStateFromProps
    This value will be either workInProgress.memoizedState (for updates) or instance.state (for initialization).
    
    * Explicitly warn about uninitialized state before calling getDerivedStateFromProps.
    And added some new tests for this change.
    
    Also:
    * Improved a couple of falsy null/undefined checks to more explicitly check for null or undefined.
    * Made some small tweaks to ReactFiberClassComponent WRT when and how it reads instance.state and sets to null.
    
    * Improved wording for deprecation lifecycle warnings
    
    * Fix state-regression for module-pattern components
    Also add support for new static getDerivedStateFromProps method

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index d37f4dbb66..ecf5c34671 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -399,7 +399,7 @@ describe('ReactUpdates', () => {
     let didUpdates = [];
 
     const UpdateLoggingMixin = {
-      componentWillUpdate: function() {
+      UNSAFE_componentWillUpdate: function() {
         willUpdates.push(this.constructor.displayName);
       },
       componentDidUpdate: function() {
@@ -723,7 +723,7 @@ describe('ReactUpdates', () => {
         return <div />;
       }
 
-      componentWillUpdate() {
+      UNSAFE_componentWillUpdate() {
         x.go();
       }
     }
@@ -746,7 +746,7 @@ describe('ReactUpdates', () => {
     class A extends React.Component {
       state = {x: 0};
 
-      componentWillMount() {
+      UNSAFE_componentWillMount() {
         a = this;
       }
 
@@ -756,7 +756,7 @@ describe('ReactUpdates', () => {
     }
 
     class B extends React.Component {
-      componentWillMount() {
+      UNSAFE_componentWillMount() {
         a.setState({x: 1});
       }
 
@@ -784,7 +784,7 @@ describe('ReactUpdates', () => {
     class A extends React.Component {
       state = {x: this.props.x};
 
-      componentWillReceiveProps(nextProps) {
+      UNSAFE_componentWillReceiveProps(nextProps) {
         const newX = nextProps.x;
         this.setState({x: newX}, function() {
           // State should have updated by the time this callback gets called
@@ -945,7 +945,7 @@ describe('ReactUpdates', () => {
     class Child extends React.Component {
       state = {updated: false};
 
-      componentWillUpdate() {
+      UNSAFE_componentWillUpdate() {
         if (!once) {
           once = true;
           this.setState({updated: true});
@@ -1100,7 +1100,7 @@ describe('ReactUpdates', () => {
       let ops = [];
       class Foo extends React.Component {
         state = {a: false, b: false};
-        componentWillUpdate(_, nextState) {
+        UNSAFE_componentWillUpdate(_, nextState) {
           if (!nextState.a) {
             this.setState({a: true});
           }
@@ -1143,7 +1143,7 @@ describe('ReactUpdates', () => {
       let ops = [];
       class Foo extends React.Component {
         state = {a: false};
-        componentWillUpdate(_, nextState) {
+        UNSAFE_componentWillUpdate(_, nextState) {
           if (!nextState.a) {
             this.setState({a: true});
           }
@@ -1316,7 +1316,7 @@ describe('ReactUpdates', () => {
       componentDidMount() {
         this.setState({step: 1});
       }
-      componentWillUpdate() {
+      UNSAFE_componentWillUpdate() {
         this.setState({step: 2});
       }
       render() {

commit 3596e40b394385713049d996c5ba293f746b7561
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Jul 6 13:55:18 2018 -0700

    Fix nested update bug (#13160)
    
    A recent change to the scheduler caused a regression when scheduling
    many updates within a single batch. Added a test case that would
    have caught this.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index ecf5c34671..b29af8f52f 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1364,4 +1364,37 @@ describe('ReactUpdates', () => {
       ReactDOM.render(<NonTerminating />, container);
     }).toThrow('Maximum');
   });
+
+  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', () => {
+    const subscribers = [];
+
+    class Child extends React.Component {
+      state = {value: 'initial'};
+      componentDidMount() {
+        subscribers.push(this);
+      }
+      render() {
+        return null;
+      }
+    }
+
+    class App extends React.Component {
+      render() {
+        const children = [];
+        for (let i = 0; i < 1200; i++) {
+          children.push(<Child key={i} />);
+        }
+        return children;
+      }
+    }
+
+    const container = document.createElement('div');
+    ReactDOM.render(<App />, container);
+
+    ReactDOM.unstable_batchedUpdates(() => {
+      subscribers.forEach(s => {
+        s.setState({value: 'update'});
+      });
+    });
+  });
 });

commit 467d1391016dd2df8e1946aa33c6d6e1219c9dbb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 20:20:18 2018 +0100

    Enforce presence or absence of component stack in tests (#13215)
    
    * Enforce presence or absence of stack in tests
    
    * Rename expectNoStack to withoutStack
    
    * Fix lint
    
    * Add some tests for toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index b29af8f52f..184f289535 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1226,6 +1226,7 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     expect(() => ReactDOM.render(<Foo />, container)).toWarnDev(
       'Cannot update during an existing state transition',
+      {withoutStack: true},
     );
     expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
   });

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Hctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 184f289535..5f3dd684e3 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 806eebdaeec5a5b0e4e5df799bd98eb5f288bba5
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri Sep 28 13:05:01 2018 -0700

    Enable getDerivedStateFromError (#13746)
    
    * Removed the enableGetDerivedStateFromCatch feature flag (aka permanently enabled the feature)
    * Forked/copied ReactErrorBoundaries to ReactLegacyErrorBoundaries for testing componentDidCatch
    * Updated error boundaries tests to apply to getDerivedStateFromCatch
    * Renamed getDerivedStateFromCatch -> getDerivedStateFromError
    * Warn if boundary with only componentDidCatch swallows error
    * Fixed a subtle reconciliation bug with render phase error boundary

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 5f3dd684e3..a6b788902b 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1343,6 +1343,9 @@ describe('ReactUpdates', () => {
 
     class ErrorBoundary extends React.Component {
       componentDidCatch() {
+        // Schedule a no-op state update to avoid triggering a DEV warning in the test.
+        this.setState({});
+
         this.props.parent.remount();
       }
       render() {

commit 31518135c25aaa1b5c2799d2a18b6b9e9178409c
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Mar 21 14:52:51 2019 +0000

    Strengthen nested update counter test coverage (#15166)
    
    * Isolate ReactUpdates-test cases
    
    This ensures their behavior is consistent when run in isolation, and that they actually test the cases they're describing.
    
    * Add coverage for cases where we reset nestedUpdateCounter
    
    These cases explicitly verify that we reset the counter in right places.
    
    * Add a mutually recursive test case
    
    * Add test coverage for useLayoutEffect loop

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index a6b788902b..533ce0743a 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -15,6 +15,7 @@ let ReactTestUtils;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
+    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactTestUtils = require('react-dom/test-utils');
@@ -1311,6 +1312,46 @@ describe('ReactUpdates', () => {
     ReactDOM.render(<Foo />, container);
   });
 
+  it('resets the update counter for unrelated updates', () => {
+    const container = document.createElement('div');
+    const ref = React.createRef();
+
+    class EventuallyTerminating extends React.Component {
+      state = {step: 0};
+      componentDidMount() {
+        this.setState({step: 1});
+      }
+      componentDidUpdate() {
+        if (this.state.step < limit) {
+          this.setState({step: this.state.step + 1});
+        }
+      }
+      render() {
+        return this.state.step;
+      }
+    }
+
+    let limit = 55;
+    expect(() => {
+      ReactDOM.render(<EventuallyTerminating ref={ref} />, container);
+    }).toThrow('Maximum');
+
+    // Verify that we don't go over the limit if these updates are unrelated.
+    limit -= 10;
+    ReactDOM.render(<EventuallyTerminating ref={ref} />, container);
+    expect(container.textContent).toBe(limit.toString());
+    ref.current.setState({step: 0});
+    expect(container.textContent).toBe(limit.toString());
+    ref.current.setState({step: 0});
+    expect(container.textContent).toBe(limit.toString());
+
+    limit += 10;
+    expect(() => {
+      ref.current.setState({step: 0});
+    }).toThrow('Maximum');
+    expect(ref.current).toBe(null);
+  });
+
   it('does not fall into an infinite update loop', () => {
     class NonTerminating extends React.Component {
       state = {step: 0};
@@ -1336,6 +1377,88 @@ describe('ReactUpdates', () => {
     }).toThrow('Maximum');
   });
 
+  it('does not fall into an infinite update loop with useLayoutEffect', () => {
+    function NonTerminating() {
+      const [step, setStep] = React.useState(0);
+      React.useLayoutEffect(() => {
+        setStep(x => x + 1);
+      });
+      return step;
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<NonTerminating />, container);
+    }).toThrow('Maximum');
+  });
+
+  it('can recover after falling into an infinite update loop', () => {
+    class NonTerminating extends React.Component {
+      state = {step: 0};
+      componentDidMount() {
+        this.setState({step: 1});
+      }
+      componentDidUpdate() {
+        this.setState({step: 2});
+      }
+      render() {
+        return this.state.step;
+      }
+    }
+
+    class Terminating extends React.Component {
+      state = {step: 0};
+      componentDidMount() {
+        this.setState({step: 1});
+      }
+      render() {
+        return this.state.step;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<NonTerminating />, container);
+    }).toThrow('Maximum');
+
+    ReactDOM.render(<Terminating />, container);
+    expect(container.textContent).toBe('1');
+
+    expect(() => {
+      ReactDOM.render(<NonTerminating />, container);
+    }).toThrow('Maximum');
+
+    ReactDOM.render(<Terminating />, container);
+    expect(container.textContent).toBe('1');
+  });
+
+  it('does not fall into mutually recursive infinite update loop with same container', () => {
+    // Note: this test would fail if there were two or more different roots.
+
+    class A extends React.Component {
+      componentDidMount() {
+        ReactDOM.render(<B />, container);
+      }
+      render() {
+        return null;
+      }
+    }
+
+    class B extends React.Component {
+      componentDidMount() {
+        ReactDOM.render(<A />, container);
+      }
+      render() {
+        return null;
+      }
+    }
+
+    const container = document.createElement('div');
+    expect(() => {
+      ReactDOM.render(<A />, container);
+    }).toThrow('Maximum');
+  });
+
   it('does not fall into an infinite error loop', () => {
     function BadRender() {
       throw new Error('error');

commit 5c2b2c0852c715abda7296bd6e7a2e941ca66969
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Mar 22 20:04:34 2019 +0000

    Warn about async infinite useEffect loop (#15180)
    
    * Warn about async infinite useEffect loop
    
    * Make tests sync

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 533ce0743a..b86c78b295 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -12,6 +12,7 @@
 let React;
 let ReactDOM;
 let ReactTestUtils;
+let Scheduler;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
@@ -19,6 +20,7 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactTestUtils = require('react-dom/test-utils');
+    Scheduler = require('scheduler');
   });
 
   it('should batch state when updating state twice', () => {
@@ -1524,4 +1526,96 @@ describe('ReactUpdates', () => {
       });
     });
   });
+
+  if (__DEV__) {
+    it('warns about a deferred infinite update loop with useEffect', () => {
+      function NonTerminating() {
+        const [step, setStep] = React.useState(0);
+        React.useEffect(() => {
+          setStep(x => x + 1);
+          Scheduler.yieldValue(step);
+        });
+        return step;
+      }
+
+      function App() {
+        return <NonTerminating />;
+      }
+
+      let error = null;
+      let stack = null;
+      let originalConsoleError = console.error;
+      console.error = (e, s) => {
+        error = e;
+        stack = s;
+      };
+      try {
+        const container = document.createElement('div');
+        ReactDOM.render(<App />, container);
+        while (error === null) {
+          Scheduler.unstable_flushNumberOfYields(1);
+        }
+        expect(error).toContain('Warning: Maximum update depth exceeded.');
+        expect(stack).toContain('in NonTerminating');
+      } finally {
+        console.error = originalConsoleError;
+      }
+    });
+
+    it('can have nested updates if they do not cross the limit', () => {
+      let _setStep;
+      const LIMIT = 50;
+
+      function Terminating() {
+        const [step, setStep] = React.useState(0);
+        _setStep = setStep;
+        React.useEffect(() => {
+          if (step < LIMIT) {
+            setStep(x => x + 1);
+            Scheduler.yieldValue(step);
+          }
+        });
+        return step;
+      }
+
+      const container = document.createElement('div');
+      ReactDOM.render(<Terminating />, container);
+
+      // Verify we can flush them asynchronously without warning
+      for (let i = 0; i < LIMIT * 2; i++) {
+        Scheduler.unstable_flushNumberOfYields(1);
+      }
+      expect(container.textContent).toBe('50');
+
+      // Verify restarting from 0 doesn't cross the limit
+      expect(() => {
+        _setStep(0);
+      }).toWarnDev(
+        'An update to Terminating inside a test was not wrapped in act',
+      );
+      expect(container.textContent).toBe('0');
+      for (let i = 0; i < LIMIT * 2; i++) {
+        Scheduler.unstable_flushNumberOfYields(1);
+      }
+      expect(container.textContent).toBe('50');
+    });
+
+    it('can have many updates inside useEffect without triggering a warning', () => {
+      function Terminating() {
+        const [step, setStep] = React.useState(0);
+        React.useEffect(() => {
+          for (let i = 0; i < 1000; i++) {
+            setStep(x => x + 1);
+          }
+          Scheduler.yieldValue('Done');
+        }, []);
+        return step;
+      }
+
+      const container = document.createElement('div');
+      ReactDOM.render(<Terminating />, container);
+      expect(Scheduler).toFlushAndYield(['Done']);
+      expect(container.textContent).toBe('1000');
+    });
+  }
 });

commit 6da04b5d886b272e241178694e15ced22c5a2c05
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon May 6 12:59:48 2019 -0700

    Fix interaction tracing for batched update mounts (#15567)
    
    * Added failing test for act+interaction tracing
    * Mark pending interactions on root for legacy unbatched phase

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index b86c78b295..591ffa2d31 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1618,4 +1618,84 @@ describe('ReactUpdates', () => {
       expect(container.textContent).toBe('1000');
     });
   }
+
+  if (__DEV__) {
+    it('should properly trace interactions within batched udpates', () => {
+      const SchedulerTracing = require('scheduler/tracing');
+
+      let expectedInteraction;
+
+      const container = document.createElement('div');
+
+      const Component = jest.fn(() => {
+        expect(expectedInteraction).toBeDefined();
+
+        const interactions = SchedulerTracing.unstable_getCurrent();
+        expect(interactions.size).toBe(1);
+        expect(interactions).toContain(expectedInteraction);
+
+        return null;
+      });
+
+      ReactDOM.unstable_batchedUpdates(() => {
+        SchedulerTracing.unstable_trace(
+          'mount traced inside a batched update',
+          1,
+          () => {
+            const interactions = SchedulerTracing.unstable_getCurrent();
+            expect(interactions.size).toBe(1);
+            expectedInteraction = Array.from(interactions)[0];
+
+            ReactDOM.render(<Component />, container);
+          },
+        );
+      });
+
+      ReactDOM.unstable_batchedUpdates(() => {
+        SchedulerTracing.unstable_trace(
+          'update traced inside a batched update',
+          2,
+          () => {
+            const interactions = SchedulerTracing.unstable_getCurrent();
+            expect(interactions.size).toBe(1);
+            expectedInteraction = Array.from(interactions)[0];
+
+            ReactDOM.render(<Component />, container);
+          },
+        );
+      });
+
+      const secondContainer = document.createElement('div');
+
+      SchedulerTracing.unstable_trace(
+        'mount traced outside a batched update',
+        3,
+        () => {
+          ReactDOM.unstable_batchedUpdates(() => {
+            const interactions = SchedulerTracing.unstable_getCurrent();
+            expect(interactions.size).toBe(1);
+            expectedInteraction = Array.from(interactions)[0];
+
+            ReactDOM.render(<Component />, secondContainer);
+          });
+        },
+      );
+
+      SchedulerTracing.unstable_trace(
+        'update traced outside a batched update',
+        4,
+        () => {
+          ReactDOM.unstable_batchedUpdates(() => {
+            const interactions = SchedulerTracing.unstable_getCurrent();
+            expect(interactions.size).toBe(1);
+            expectedInteraction = Array.from(interactions)[0];
+
+            ReactDOM.render(<Component />, container);
+          });
+        },
+      );
+
+      expect(Component).toHaveBeenCalledTimes(4);
+    });
+  }
 });

commit bb89b4eacc4edc0954910955322296789d8e2089
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu May 16 11:12:05 2019 +0100

    Bail out of updates in offscreen trees (#15666)
    
    * Bail out of updates in offscreen trees
    
    * Address review

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 591ffa2d31..0b6a4b2792 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1290,6 +1290,78 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
+  it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
+    const container = document.createElement('div');
+
+    function Baz() {
+      Scheduler.yieldValue('Baz');
+      return <p>baz</p>;
+    }
+
+    let setCounter;
+    function Bar() {
+      const [counter, _setCounter] = React.useState(0);
+      setCounter = _setCounter;
+      Scheduler.yieldValue('Bar');
+      return <p>bar {counter}</p>;
+    }
+
+    function Foo() {
+      Scheduler.yieldValue('Foo');
+      React.useEffect(() => {
+        Scheduler.yieldValue('Foo#effect');
+      });
+      return (
+        <div>
+          <div hidden={true}>
+            <Bar />
+          </div>
+          <Baz />
+        </div>
+      );
+    }
+
+    const root = ReactDOM.unstable_createRoot(container);
+    root.render(<Foo />);
+    if (__DEV__) {
+      expect(Scheduler).toFlushAndYieldThrough([
+        'Foo',
+        'Foo',
+        'Baz',
+        'Foo#effect',
+      ]);
+    } else {
+      expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
+    }
+
+    const hiddenDiv = container.firstChild.firstChild;
+    expect(hiddenDiv.hidden).toBe(true);
+    expect(hiddenDiv.innerHTML).toBe('');
+
+    // Run offscreen update
+    if (__DEV__) {
+      expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+    } else {
+      expect(Scheduler).toFlushAndYield(['Bar']);
+    }
+    expect(hiddenDiv.hidden).toBe(true);
+    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+
+    ReactDOM.flushSync(() => {
+      setCounter(1);
+    });
+    // Should not flush yet
+    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+
+    // Run offscreen update
+    if (__DEV__) {
+      expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+    } else {
+      expect(Scheduler).toFlushAndYield(['Bar']);
+    }
+    expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
+  });
+
   it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
     class Foo extends React.Component {
       componentDidMount() {

commit e1c5e8720d5d47974c14c125dbaf3dc608a92936
Author: Sunil Pai <threepointone@fb.com>
Date:   Mon Jun 24 11:18:24 2019 +0100

    warn if passive effects get queued outside of an act() call. (#15763)
    
    * warn if passive effects get queued outside of an act() call
    
    While the code itself isn't much (it adds the warning to mountEffect() and updateEffect() in ReactFiberHooks), it does change a lot of our tests. We follow a bad-ish pattern here, which is doing asserts inside act() scopes, but it makes sense for *us* because we're testing intermediate states, and we're manually flush/yield what we need in these tests.
    
    This commit has one last failing test. Working on it.
    
    * pass lint
    
    * pass failing test, fixes another
    
    - a test was failing in ReactDOMServerIntegrationHooks while testing an effect; the behaviour of yields was different from browser and server when wrapped with act(). further, because of how we initialized modules, act() around renders wasn't working corrrectly. solved by passing in ReactTestUtils in initModules, and checking on the finally yielded values in the specific test.
    - in ReactUpdates, while testing an infinite recursion detection, the test needed to be wrapped in an act(), which would have caused the recusrsion error to throw. solived by rethrowing the error from inside the act().
    
    * pass ReactDOMServerSuspense
    
    * stray todo
    
    * a better message, consistent with the state update one.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 0b6a4b2792..6d7435fe4c 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -12,6 +12,7 @@
 let React;
 let ReactDOM;
 let ReactTestUtils;
+let act;
 let Scheduler;
 
 describe('ReactUpdates', () => {
@@ -20,6 +21,7 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactTestUtils = require('react-dom/test-utils');
+    act = ReactTestUtils.act;
     Scheduler = require('scheduler');
   });
 
@@ -1322,30 +1324,31 @@ describe('ReactUpdates', () => {
     }
 
     const root = ReactDOM.unstable_createRoot(container);
-    root.render(<Foo />);
-    if (__DEV__) {
-      expect(Scheduler).toFlushAndYieldThrough([
-        'Foo',
-        'Foo',
-        'Baz',
-        'Foo#effect',
-      ]);
-    } else {
-      expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
-    }
-
-    const hiddenDiv = container.firstChild.firstChild;
-    expect(hiddenDiv.hidden).toBe(true);
-    expect(hiddenDiv.innerHTML).toBe('');
-
-    // Run offscreen update
-    if (__DEV__) {
-      expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
-    } else {
-      expect(Scheduler).toFlushAndYield(['Bar']);
-    }
-    expect(hiddenDiv.hidden).toBe(true);
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+    let hiddenDiv;
+    act(() => {
+      root.render(<Foo />);
+      if (__DEV__) {
+        expect(Scheduler).toFlushAndYieldThrough([
+          'Foo',
+          'Foo',
+          'Baz',
+          'Foo#effect',
+        ]);
+      } else {
+        expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
+      }
+      hiddenDiv = container.firstChild.firstChild;
+      expect(hiddenDiv.hidden).toBe(true);
+      expect(hiddenDiv.innerHTML).toBe('');
+      // Run offscreen update
+      if (__DEV__) {
+        expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+      } else {
+        expect(Scheduler).toFlushAndYield(['Bar']);
+      }
+      expect(hiddenDiv.hidden).toBe(true);
+      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+    });
 
     ReactDOM.flushSync(() => {
       setCounter(1);
@@ -1623,12 +1626,18 @@ describe('ReactUpdates', () => {
       };
       try {
         const container = document.createElement('div');
-        ReactDOM.render(<App />, container);
-        while (error === null) {
-          Scheduler.unstable_flushNumberOfYields(1);
-        }
-        expect(error).toContain('Warning: Maximum update depth exceeded.');
-        expect(stack).toContain('in NonTerminating');
+        expect(() => {
+          act(() => {
+            ReactDOM.render(<App />, container);
+            while (error === null) {
+              Scheduler.unstable_flushNumberOfYields(1);
+            }
+            expect(error).toContain('Warning: Maximum update depth exceeded.');
+            expect(stack).toContain('in NonTerminating');
+            // rethrow error to prevent going into an infinite loop when act() exits
+            throw error;
+          });
+        }).toThrow('Maximum update depth exceeded.');
       } finally {
         console.error = originalConsoleError;
       }
@@ -1651,7 +1660,9 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      ReactDOM.render(<Terminating />, container);
+      act(() => {
+        ReactDOM.render(<Terminating />, container);
+      });
 
       // Verify we can flush them asynchronously without warning
       for (let i = 0; i < LIMIT * 2; i++) {
@@ -1660,16 +1671,16 @@ describe('ReactUpdates', () => {
       expect(container.textContent).toBe('50');
 
       // Verify restarting from 0 doesn't cross the limit
-      expect(() => {
+      act(() => {
         _setStep(0);
-      }).toWarnDev(
-        'An update to Terminating inside a test was not wrapped in act',
-      );
-      expect(container.textContent).toBe('0');
-      for (let i = 0; i < LIMIT * 2; i++) {
+        // flush once to update the dom
         Scheduler.unstable_flushNumberOfYields(1);
-      }
-      expect(container.textContent).toBe('50');
+        expect(container.textContent).toBe('0');
+        for (let i = 0; i < LIMIT * 2; i++) {
+          Scheduler.unstable_flushNumberOfYields(1);
+        }
+        expect(container.textContent).toBe('50');
+      });
     });
 
     it('can have many updates inside useEffect without triggering a warning', () => {
@@ -1685,8 +1696,11 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      ReactDOM.render(<Terminating />, container);
-      expect(Scheduler).toFlushAndYield(['Done']);
+      act(() => {
+        ReactDOM.render(<Terminating />, container);
+      });
+
+      expect(Scheduler).toHaveYielded(['Done']);
       expect(container.textContent).toBe('1000');
     });
   }

commit 4d307de458dfdf25e704cb2ca20b0578bba8998c
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Jun 26 12:16:08 2019 -0700

    Prefix mock Scheduler APIs with _unstable (#15999)
    
    For now this is only meant to be consumed via `act`.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 6d7435fe4c..66a3a89907 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1296,7 +1296,7 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
 
     function Baz() {
-      Scheduler.yieldValue('Baz');
+      Scheduler.unstable_yieldValue('Baz');
       return <p>baz</p>;
     }
 
@@ -1304,14 +1304,14 @@ describe('ReactUpdates', () => {
     function Bar() {
       const [counter, _setCounter] = React.useState(0);
       setCounter = _setCounter;
-      Scheduler.yieldValue('Bar');
+      Scheduler.unstable_yieldValue('Bar');
       return <p>bar {counter}</p>;
     }
 
     function Foo() {
-      Scheduler.yieldValue('Foo');
+      Scheduler.unstable_yieldValue('Foo');
       React.useEffect(() => {
-        Scheduler.yieldValue('Foo#effect');
+        Scheduler.unstable_yieldValue('Foo#effect');
       });
       return (
         <div>
@@ -1608,7 +1608,7 @@ describe('ReactUpdates', () => {
         const [step, setStep] = React.useState(0);
         React.useEffect(() => {
           setStep(x => x + 1);
-          Scheduler.yieldValue(step);
+          Scheduler.unstable_yieldValue(step);
         });
         return step;
       }
@@ -1653,7 +1653,7 @@ describe('ReactUpdates', () => {
         React.useEffect(() => {
           if (step < LIMIT) {
             setStep(x => x + 1);
-            Scheduler.yieldValue(step);
+            Scheduler.unstable_yieldValue(step);
           }
         });
         return step;
@@ -1690,7 +1690,7 @@ describe('ReactUpdates', () => {
           for (let i = 0; i < 1000; i++) {
             setStep(x => x + 1);
           }
-          Scheduler.yieldValue('Done');
+          Scheduler.unstable_yieldValue('Done');
         }, []);
         return step;
       }

commit d77c6232d37238013dd96f3c37b7e4f77384e0f9
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Aug 8 16:18:05 2019 -0700

    [Scheduler] Store Tasks on a Min Binary Heap (#16245)
    
    * [Scheduler] Store Tasks on a Min Binary Heap
    
    Switches Scheduler's priority queue implementation (for both tasks and
    timers) to an array-based min binary heap.
    
    This replaces the naive linked-list implementation that was left over
    from the queue we once used to schedule React roots. A list was arguably
    fine when it was only used for roots, since the total number of roots is
    usually small, and is only 1 in the common case of a single-page app.
    
    Since Scheduler is now used for many types of JavaScript tasks (e.g.
    including timers), the total number of tasks can be much larger.
    
    Binary heaps are the standard way to implement priority queues.
    Insertion is O(1) in the average case (append to the end) and O(log n)
    in the worst. Deletion is O(log n). Peek is O(1).
    
    * Sophie nits

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 66a3a89907..8e23a6d5c1 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1631,6 +1631,7 @@ describe('ReactUpdates', () => {
             ReactDOM.render(<App />, container);
             while (error === null) {
               Scheduler.unstable_flushNumberOfYields(1);
+              Scheduler.unstable_clearYields();
             }
             expect(error).toContain('Warning: Maximum update depth exceeded.');
             expect(stack).toContain('in NonTerminating');
@@ -1653,9 +1654,9 @@ describe('ReactUpdates', () => {
         React.useEffect(() => {
           if (step < LIMIT) {
             setStep(x => x + 1);
-            Scheduler.unstable_yieldValue(step);
           }
         });
+        Scheduler.unstable_yieldValue(step);
         return step;
       }
 
@@ -1663,24 +1664,11 @@ describe('ReactUpdates', () => {
       act(() => {
         ReactDOM.render(<Terminating />, container);
       });
-
-      // Verify we can flush them asynchronously without warning
-      for (let i = 0; i < LIMIT * 2; i++) {
-        Scheduler.unstable_flushNumberOfYields(1);
-      }
       expect(container.textContent).toBe('50');
-
-      // Verify restarting from 0 doesn't cross the limit
       act(() => {
         _setStep(0);
-        // flush once to update the dom
-        Scheduler.unstable_flushNumberOfYields(1);
-        expect(container.textContent).toBe('0');
-        for (let i = 0; i < LIMIT * 2; i++) {
-          Scheduler.unstable_flushNumberOfYields(1);
-        }
-        expect(container.textContent).toBe('50');
       });
+      expect(container.textContent).toBe('50');
     });
 
     it('can have many updates inside useEffect without triggering a warning', () => {

commit 30c5daf943bd3bed38e464ac79e38f0e8a27426b
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 15 15:09:19 2019 -0700

    Remove concurrent apis from stable (#17088)
    
    * Tests run in experimental mode by default
    
    For local development, you usually want experiments enabled. Unless
    the release channel is set with an environment variable, tests will
    run with __EXPERIMENTAL__ set to `true`.
    
    * Remove concurrent APIs from stable builds
    
    Those who want to try concurrent mode should use the experimental
    builds instead.
    
    I've left the `unstable_` prefixed APIs in the Facebook build so we
    can continue experimenting with them internally without blessing them
    for widespread use.
    
    * Turn on SSR flags in experimental build
    
    * Remove prefixed concurrent APIs from www build
    
    Instead we'll use the experimental builds when syncing to www.
    
    * Remove "canary" from internal React version string

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 8e23a6d5c1..04e69d591e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1292,78 +1292,84 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
-  it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
-    const container = document.createElement('div');
+  if (__EXPERIMENTAL__) {
+    it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
+      const container = document.createElement('div');
 
-    function Baz() {
-      Scheduler.unstable_yieldValue('Baz');
-      return <p>baz</p>;
-    }
+      function Baz() {
+        Scheduler.unstable_yieldValue('Baz');
+        return <p>baz</p>;
+      }
 
-    let setCounter;
-    function Bar() {
-      const [counter, _setCounter] = React.useState(0);
-      setCounter = _setCounter;
-      Scheduler.unstable_yieldValue('Bar');
-      return <p>bar {counter}</p>;
-    }
+      let setCounter;
+      function Bar() {
+        const [counter, _setCounter] = React.useState(0);
+        setCounter = _setCounter;
+        Scheduler.unstable_yieldValue('Bar');
+        return <p>bar {counter}</p>;
+      }
 
-    function Foo() {
-      Scheduler.unstable_yieldValue('Foo');
-      React.useEffect(() => {
-        Scheduler.unstable_yieldValue('Foo#effect');
-      });
-      return (
-        <div>
-          <div hidden={true}>
-            <Bar />
+      function Foo() {
+        Scheduler.unstable_yieldValue('Foo');
+        React.useEffect(() => {
+          Scheduler.unstable_yieldValue('Foo#effect');
+        });
+        return (
+          <div>
+            <div hidden={true}>
+              <Bar />
+            </div>
+            <Baz />
           </div>
-          <Baz />
-        </div>
-      );
-    }
-
-    const root = ReactDOM.unstable_createRoot(container);
-    let hiddenDiv;
-    act(() => {
-      root.render(<Foo />);
-      if (__DEV__) {
-        expect(Scheduler).toFlushAndYieldThrough([
-          'Foo',
-          'Foo',
-          'Baz',
-          'Foo#effect',
-        ]);
-      } else {
-        expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
+        );
       }
-      hiddenDiv = container.firstChild.firstChild;
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('');
+
+      const root = ReactDOM.createRoot(container);
+      let hiddenDiv;
+      act(() => {
+        root.render(<Foo />);
+        if (__DEV__) {
+          expect(Scheduler).toFlushAndYieldThrough([
+            'Foo',
+            'Foo',
+            'Baz',
+            'Foo#effect',
+          ]);
+        } else {
+          expect(Scheduler).toFlushAndYieldThrough([
+            'Foo',
+            'Baz',
+            'Foo#effect',
+          ]);
+        }
+        hiddenDiv = container.firstChild.firstChild;
+        expect(hiddenDiv.hidden).toBe(true);
+        expect(hiddenDiv.innerHTML).toBe('');
+        // Run offscreen update
+        if (__DEV__) {
+          expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
+        } else {
+          expect(Scheduler).toFlushAndYield(['Bar']);
+        }
+        expect(hiddenDiv.hidden).toBe(true);
+        expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+      });
+
+      ReactDOM.flushSync(() => {
+        setCounter(1);
+      });
+      // Should not flush yet
+      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+
       // Run offscreen update
       if (__DEV__) {
         expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
       } else {
         expect(Scheduler).toFlushAndYield(['Bar']);
       }
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+      expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
     });
-
-    ReactDOM.flushSync(() => {
-      setCounter(1);
-    });
-    // Should not flush yet
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
-
-    // Run offscreen update
-    if (__DEV__) {
-      expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
-    } else {
-      expect(Scheduler).toFlushAndYield(['Bar']);
-    }
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
-  });
+  }
 
   it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
     class Foo extends React.Component {

commit 349cf5acc3cda0010fa464a3c959c83a78a24bd7
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Oct 19 16:08:08 2019 -0700

    Experimental test helper: `it.experimental` (#17149)
    
    Special version of Jest's `it` for experimental tests. Tests marked as
    experimental will run **both** stable and experimental modes. In
    experimental mode, they work the same as the normal Jest methods. In
    stable mode, they are **expected to fail**. This means we can detect
    when a test previously marked as experimental can be un-marked when the
    feature becomes stable. It also reduces the chances that we accidentally
    add experimental APIs to the stable builds before we intend.
    
    I added corresponding methods for the focus and skip APIs:
    
    - `fit` -> `fit.experimental`
    - `it.only` -> `it.only.experimental` or `it.experimental.only`
    - `xit` -> `xit.experimental`
    - `it.skip` -> `it.skip.experimental` or `it.experimental.skip`
    
    Since `it` is an alias of `test`, `test.experimental` works, too.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 04e69d591e..cb4d8214c1 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1292,8 +1292,9 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
-  if (__EXPERIMENTAL__) {
-    it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
+  it.experimental(
+    'delays sync updates inside hidden subtrees in Concurrent Mode',
+    () => {
       const container = document.createElement('div');
 
       function Baz() {
@@ -1368,8 +1369,8 @@ describe('ReactUpdates', () => {
         expect(Scheduler).toFlushAndYield(['Bar']);
       }
       expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
-    });
-  }
+    },
+  );
 
   it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
     class Foo extends React.Component {

commit f6b8d31a76cbbcbbeb2f1d59074dfe72e0c82806
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Oct 23 15:04:39 2019 -0700

    Rename createSyncRoot to createBlockingRoot (#17165)
    
    * Rename createSyncRoot to createBlockingRoot
    
    * Fix up

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index cb4d8214c1..461581a375 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1099,7 +1099,7 @@ describe('ReactUpdates', () => {
   });
 
   it(
-    'in sync mode, updates in componentWillUpdate and componentDidUpdate ' +
+    'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
       'should both flush in the immediately subsequent commit',
     () => {
       let ops = [];
@@ -1142,7 +1142,7 @@ describe('ReactUpdates', () => {
   );
 
   it(
-    'in sync mode, updates in componentWillUpdate and componentDidUpdate ' +
+    'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
       '(on a sibling) should both flush in the immediately subsequent commit',
     () => {
       let ops = [];

commit b15bf36750ca4c4a5a09f2de76c5315ded1258d0
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 12 23:47:55 2019 +0000

    Add component stacks to (almost) all warnings (#17586)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 461581a375..3ccd799519 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1231,7 +1231,6 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     expect(() => ReactDOM.render(<Foo />, container)).toWarnDev(
       'Cannot update during an existing state transition',
-      {withoutStack: true},
     );
     expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
   });

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 3ccd799519..5d28562126 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -863,7 +863,7 @@ describe('ReactUpdates', () => {
     let component = ReactTestUtils.renderIntoDocument(<A />);
 
     expect(() => {
-      expect(() => component.setState({}, 'no')).toWarnDev(
+      expect(() => component.setState({}, 'no')).toErrorDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       );
@@ -873,7 +873,7 @@ describe('ReactUpdates', () => {
     );
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => {
-      expect(() => component.setState({}, {foo: 'bar'})).toWarnDev(
+      expect(() => component.setState({}, {foo: 'bar'})).toErrorDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
@@ -906,7 +906,7 @@ describe('ReactUpdates', () => {
     let component = ReactTestUtils.renderIntoDocument(<A />);
 
     expect(() => {
-      expect(() => component.forceUpdate('no')).toWarnDev(
+      expect(() => component.forceUpdate('no')).toErrorDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       );
@@ -916,7 +916,7 @@ describe('ReactUpdates', () => {
     );
     component = ReactTestUtils.renderIntoDocument(<A />);
     expect(() => {
-      expect(() => component.forceUpdate({foo: 'bar'})).toWarnDev(
+      expect(() => component.forceUpdate({foo: 'bar'})).toErrorDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       );
@@ -1229,7 +1229,7 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<Foo />, container)).toWarnDev(
+    expect(() => ReactDOM.render(<Foo />, container)).toErrorDev(
       'Cannot update during an existing state transition',
     );
     expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);

commit ba31ad40a9c6495e0d42def270178a7a74990c27
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Mon Mar 30 00:13:46 2020 +0200

    feat(StrictMode): Double-invoke render for every component (#18430)
    
    * feat(StrictMode): Double-invoke render for every component
    
    * fix: Mark ReactTestRendererAsync as internal

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 5d28562126..a9c3a4cf39 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1333,6 +1333,7 @@ describe('ReactUpdates', () => {
             'Foo',
             'Foo',
             'Baz',
+            'Baz',
             'Foo#effect',
           ]);
         } else {

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index a9c3a4cf39..79e0f6640b 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -526,7 +526,6 @@ describe('ReactUpdates', () => {
 
     const bContainer = document.createElement('div');
 
-    let a;
     let b;
 
     let aUpdated = false;
@@ -560,7 +559,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    a = ReactTestUtils.renderIntoDocument(<A />);
+    const a = ReactTestUtils.renderIntoDocument(<A />);
     ReactDOM.unstable_batchedUpdates(function() {
       a.setState({x: 1});
       b.setState({x: 1});
@@ -733,11 +732,8 @@ describe('ReactUpdates', () => {
       }
     }
 
-    let x;
-    let y;
-
-    x = ReactTestUtils.renderIntoDocument(<X />);
-    y = ReactTestUtils.renderIntoDocument(<Y />);
+    const x = ReactTestUtils.renderIntoDocument(<X />);
+    const y = ReactTestUtils.renderIntoDocument(<Y />);
     expect(ReactDOM.findDOMNode(x).textContent).toBe('0');
 
     y.forceUpdate();
@@ -1102,7 +1098,7 @@ describe('ReactUpdates', () => {
     'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
       'should both flush in the immediately subsequent commit',
     () => {
-      let ops = [];
+      const ops = [];
       class Foo extends React.Component {
         state = {a: false, b: false};
         UNSAFE_componentWillUpdate(_, nextState) {
@@ -1145,7 +1141,7 @@ describe('ReactUpdates', () => {
     'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
       '(on a sibling) should both flush in the immediately subsequent commit',
     () => {
-      let ops = [];
+      const ops = [];
       class Foo extends React.Component {
         state = {a: false};
         UNSAFE_componentWillUpdate(_, nextState) {
@@ -1213,7 +1209,7 @@ describe('ReactUpdates', () => {
   );
 
   it('uses correct base state for setState inside render phase', () => {
-    let ops = [];
+    const ops = [];
 
     class Foo extends React.Component {
       state = {step: 0};
@@ -1236,7 +1232,7 @@ describe('ReactUpdates', () => {
   });
 
   it('does not re-render if state update is null', () => {
-    let container = document.createElement('div');
+    const container = document.createElement('div');
 
     let instance;
     let ops = [];
@@ -1626,7 +1622,7 @@ describe('ReactUpdates', () => {
 
       let error = null;
       let stack = null;
-      let originalConsoleError = console.error;
+      const originalConsoleError = console.error;
       console.error = (e, s) => {
         error = e;
         stack = s;

commit 5474a83e258b497584bed9df95de1d554bc53f89
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Apr 8 16:43:51 2020 -0700

    Disable console.logs in the second render pass of DEV mode double render (#18547)
    
    * Disable console log during the second rerender
    
    * Use the disabled log to avoid double yielding values in scheduler mock
    
    * Reenable debugRenderPhaseSideEffectsForStrictMode in tests that can

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 79e0f6640b..29bccc13b6 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1324,30 +1324,12 @@ describe('ReactUpdates', () => {
       let hiddenDiv;
       act(() => {
         root.render(<Foo />);
-        if (__DEV__) {
-          expect(Scheduler).toFlushAndYieldThrough([
-            'Foo',
-            'Foo',
-            'Baz',
-            'Baz',
-            'Foo#effect',
-          ]);
-        } else {
-          expect(Scheduler).toFlushAndYieldThrough([
-            'Foo',
-            'Baz',
-            'Foo#effect',
-          ]);
-        }
+        expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
         hiddenDiv = container.firstChild.firstChild;
         expect(hiddenDiv.hidden).toBe(true);
         expect(hiddenDiv.innerHTML).toBe('');
         // Run offscreen update
-        if (__DEV__) {
-          expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
-        } else {
-          expect(Scheduler).toFlushAndYield(['Bar']);
-        }
+        expect(Scheduler).toFlushAndYield(['Bar']);
         expect(hiddenDiv.hidden).toBe(true);
         expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
       });
@@ -1359,11 +1341,7 @@ describe('ReactUpdates', () => {
       expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
 
       // Run offscreen update
-      if (__DEV__) {
-        expect(Scheduler).toFlushAndYield(['Bar', 'Bar']);
-      } else {
-        expect(Scheduler).toFlushAndYield(['Bar']);
-      }
+      expect(Scheduler).toFlushAndYield(['Bar']);
       expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
     },
   );

commit 98d410f5005988644d01c9ec79b7181c3dd6c847
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Fri Apr 10 13:32:12 2020 -0700

    Build Component Stacks from Native Stack Frames (#18561)
    
    * Implement component stack extraction hack
    
    * Normalize errors in tests
    
    This drops the requirement to include owner to pass the test.
    
    * Special case tests
    
    * Add destructuring to force toObject which throws before the side-effects
    
    This ensures that we don't double call yieldValue or advanceTime in tests.
    
    Ideally we could use empty destructuring but ES lint doesn't like it.
    
    * Cache the result in DEV
    
    In DEV it's somewhat likely that we'll see many logs that add component
    stacks. This could be slow so we cache the results of previous components.
    
    * Fixture
    
    * Add Reflect to lint
    
    * Log if out of range.
    
    * Fix special case when the function call throws in V8
    
    In V8 we need to ignore the first line. Normally we would never get there
    because the stacks would differ before that, but the stacks are the same if
    we end up throwing at the same place as the control.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 29bccc13b6..993869de6e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1615,7 +1615,7 @@ describe('ReactUpdates', () => {
               Scheduler.unstable_clearYields();
             }
             expect(error).toContain('Warning: Maximum update depth exceeded.');
-            expect(stack).toContain('in NonTerminating');
+            expect(stack).toContain(' NonTerminating');
             // rethrow error to prevent going into an infinite loop when act() exits
             throw error;
           });

commit 65237a237e15af3b3c983d46b401c6af988c5f74
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Apr 13 10:28:59 2020 -0700

    Codemod it.experimental to gate pragma (#18582)
    
    * Codemod it.experimental to gate pragma
    
    Find-and-replace followed by Prettier
    
    * Delete it.experimental
    
    Removes the API from our test setup script

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 993869de6e..9fc50d0f34 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1287,64 +1287,62 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
-  it.experimental(
-    'delays sync updates inside hidden subtrees in Concurrent Mode',
-    () => {
-      const container = document.createElement('div');
-
-      function Baz() {
-        Scheduler.unstable_yieldValue('Baz');
-        return <p>baz</p>;
-      }
-
-      let setCounter;
-      function Bar() {
-        const [counter, _setCounter] = React.useState(0);
-        setCounter = _setCounter;
-        Scheduler.unstable_yieldValue('Bar');
-        return <p>bar {counter}</p>;
-      }
+  // @gate experimental
+  it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
+    const container = document.createElement('div');
 
-      function Foo() {
-        Scheduler.unstable_yieldValue('Foo');
-        React.useEffect(() => {
-          Scheduler.unstable_yieldValue('Foo#effect');
-        });
-        return (
-          <div>
-            <div hidden={true}>
-              <Bar />
-            </div>
-            <Baz />
-          </div>
-        );
-      }
+    function Baz() {
+      Scheduler.unstable_yieldValue('Baz');
+      return <p>baz</p>;
+    }
 
-      const root = ReactDOM.createRoot(container);
-      let hiddenDiv;
-      act(() => {
-        root.render(<Foo />);
-        expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
-        hiddenDiv = container.firstChild.firstChild;
-        expect(hiddenDiv.hidden).toBe(true);
-        expect(hiddenDiv.innerHTML).toBe('');
-        // Run offscreen update
-        expect(Scheduler).toFlushAndYield(['Bar']);
-        expect(hiddenDiv.hidden).toBe(true);
-        expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
-      });
+    let setCounter;
+    function Bar() {
+      const [counter, _setCounter] = React.useState(0);
+      setCounter = _setCounter;
+      Scheduler.unstable_yieldValue('Bar');
+      return <p>bar {counter}</p>;
+    }
 
-      ReactDOM.flushSync(() => {
-        setCounter(1);
+    function Foo() {
+      Scheduler.unstable_yieldValue('Foo');
+      React.useEffect(() => {
+        Scheduler.unstable_yieldValue('Foo#effect');
       });
-      // Should not flush yet
-      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+      return (
+        <div>
+          <div hidden={true}>
+            <Bar />
+          </div>
+          <Baz />
+        </div>
+      );
+    }
 
+    const root = ReactDOM.createRoot(container);
+    let hiddenDiv;
+    act(() => {
+      root.render(<Foo />);
+      expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
+      hiddenDiv = container.firstChild.firstChild;
+      expect(hiddenDiv.hidden).toBe(true);
+      expect(hiddenDiv.innerHTML).toBe('');
       // Run offscreen update
       expect(Scheduler).toFlushAndYield(['Bar']);
-      expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
-    },
-  );
+      expect(hiddenDiv.hidden).toBe(true);
+      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+    });
+
+    ReactDOM.flushSync(() => {
+      setCounter(1);
+    });
+    // Should not flush yet
+    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+
+    // Run offscreen update
+    expect(Scheduler).toFlushAndYield(['Bar']);
+    expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
+  });
 
   it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
     class Foo extends React.Component {

commit fe7163e73dadceda2655736d97cdd745d7abc8ea
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 4 22:25:41 2020 -0700

    Add unstable prefix to experimental APIs (#18825)
    
    We've been shipping unprefixed experimental APIs (like `createRoot` and
    `useTransition`) to the Experimental release channel, with the rationale
    that because these APIs do not appear in any stable release, we're free
    to change or remove them later without breaking any downstream projects.
    
    What we didn't consider is that downstream projects might be tempted to
    use feature detection:
    
    ```js
    const useTransition = React.useTransition || fallbackUseTransition;
    ```
    
    This pattern assumes that the version of `useTransition` that exists in
    the Experimental channel today has the same API contract as the final
    `useTransition` API that we'll eventually ship to stable.
    
    To discourage feature detection, I've added an `unstable_` prefix to
    all of our unstable APIs.
    
    The Facebook builds still have the unprefixed APIs, though. We will
    continue to support those; if we make any breaking changes, we'll
    migrate the internal callers like we usually do. To make testing easier,
    I added the `unstable_`-prefixed APIs to the www builds, too. That way
    our tests can always use the prefixed ones without gating on the
    release channel.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9fc50d0f34..7b4af4f928 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1319,7 +1319,7 @@ describe('ReactUpdates', () => {
       );
     }
 
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOM.unstable_createRoot(container);
     let hiddenDiv;
     act(() => {
       root.render(<Foo />);

commit 8b9c4d1688333865e702fcd65ad2ab7d83b3c33c
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 11 20:02:08 2020 -0700

    Expose LegacyHidden type and disable <div hidden /> API in new fork (#18891)
    
    * Expose LegacyHidden type
    
    I will use this internally at Facebook to migrate away from
    <div hidden />. The end goal is to migrate to the Offscreen type, but
    that has different semantics. This is an incremental step.
    
    * Disable <div hidden /> API in new fork
    
    Migrates to the unstable_LegacyHidden type instead. The old fork does
    not support the new component type, so I updated the tests to use an
    indirection that picks the correct API. I will remove this once the
    LegacyHidden (and/or Offscreen) type has landed in both implementations.
    
    * Add gated warning for `<div hidden />` API
    
    Only exists so we can detect callers in www and migrate them to the new
    API. Should not visible to anyone outside React Core team.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 7b4af4f928..9c2b69b653 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -25,6 +25,25 @@ describe('ReactUpdates', () => {
     Scheduler = require('scheduler');
   });
 
+  // TODO: Delete this once new API exists in both forks
+  function LegacyHiddenDiv({hidden, children, ...props}) {
+    if (gate(flags => flags.new)) {
+      return (
+        <div hidden={hidden} {...props}>
+          <React.unstable_LegacyHidden mode={hidden ? 'hidden' : 'visible'}>
+            {children}
+          </React.unstable_LegacyHidden>
+        </div>
+      );
+    } else {
+      return (
+        <div hidden={hidden} {...props}>
+          {children}
+        </div>
+      );
+    }
+  }
+
   it('should batch state when updating state twice', () => {
     let updateCount = 0;
 
@@ -1288,6 +1307,7 @@ describe('ReactUpdates', () => {
   });
 
   // @gate experimental
+  // @gate enableLegacyHiddenType
   it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
     const container = document.createElement('div');
 
@@ -1311,9 +1331,9 @@ describe('ReactUpdates', () => {
       });
       return (
         <div>
-          <div hidden={true}>
+          <LegacyHiddenDiv hidden={true}>
             <Bar />
-          </div>
+          </LegacyHiddenDiv>
           <Baz />
         </div>
       );

commit b4a1a4980c98c6d8a7ced428a1adc9e278fec430
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 13 20:01:10 2020 -0700

    Disable <div hidden /> API in old fork, too (#18917)
    
    The motivation for doing this is to make it impossible for additional
    uses of pre-rendering to sneak into www without going through the
    LegacyHidden abstraction. Since this feature was already disabled in
    the new fork, this brings the two closer to parity.
    
    The LegacyHidden abstraction itself still needs to opt into
    pre-rendering somehow, so rather than totally disabling the feature, I
    updated the `hidden` prop check to be obnoxiously specific. Before, you
    could set it to any truthy value; now, you must set it to the string
    "unstable-do-not-use-legacy-hidden".
    
    The node will still be hidden in the DOM, since any truthy value will
    cause the browser to apply a style of `display: none`.
    
    I will have to update the LegacyHidden component in www to use the
    obnoxious string prop. This doesn't block merge, though, since the
    behavior is gated by a dynamic flag. I will update the component before
    I enable the flag.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9c2b69b653..b82fa9de01 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -29,7 +29,9 @@ describe('ReactUpdates', () => {
   function LegacyHiddenDiv({hidden, children, ...props}) {
     if (gate(flags => flags.new)) {
       return (
-        <div hidden={hidden} {...props}>
+        <div
+          hidden={hidden ? 'unstable-do-not-use-legacy-hidden' : false}
+          {...props}>
           <React.unstable_LegacyHidden mode={hidden ? 'hidden' : 'visible'}>
             {children}
           </React.unstable_LegacyHidden>
@@ -37,7 +39,9 @@ describe('ReactUpdates', () => {
       );
     } else {
       return (
-        <div hidden={hidden} {...props}>
+        <div
+          hidden={hidden ? 'unstable-do-not-use-legacy-hidden' : false}
+          {...props}>
           {children}
         </div>
       );

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index b82fa9de01..a3eb0455fc 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -25,27 +25,20 @@ describe('ReactUpdates', () => {
     Scheduler = require('scheduler');
   });
 
-  // TODO: Delete this once new API exists in both forks
-  function LegacyHiddenDiv({hidden, children, ...props}) {
-    if (gate(flags => flags.new)) {
-      return (
-        <div
-          hidden={hidden ? 'unstable-do-not-use-legacy-hidden' : false}
-          {...props}>
-          <React.unstable_LegacyHidden mode={hidden ? 'hidden' : 'visible'}>
-            {children}
-          </React.unstable_LegacyHidden>
-        </div>
-      );
-    } else {
-      return (
-        <div
-          hidden={hidden ? 'unstable-do-not-use-legacy-hidden' : false}
-          {...props}>
+  // Note: This is based on a similar component we use in www. We can delete
+  // once the extra div wrapper is no longer neccessary.
+  function LegacyHiddenDiv({children, mode}) {
+    return (
+      <div
+        hidden={
+          mode === 'hidden' ? 'unstable-do-not-use-legacy-hidden' : undefined
+        }>
+        <React.unstable_LegacyHidden
+          mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
           {children}
-        </div>
-      );
-    }
+        </React.unstable_LegacyHidden>
+      </div>
+    );
   }
 
   it('should batch state when updating state twice', () => {
@@ -1311,7 +1304,6 @@ describe('ReactUpdates', () => {
   });
 
   // @gate experimental
-  // @gate enableLegacyHiddenType
   it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
     const container = document.createElement('div');
 
@@ -1335,7 +1327,7 @@ describe('ReactUpdates', () => {
       });
       return (
         <div>
-          <LegacyHiddenDiv hidden={true}>
+          <LegacyHiddenDiv mode="hidden">
             <Bar />
           </LegacyHiddenDiv>
           <Baz />

commit 103ed08c46198d01119ef35c37d78c6bc89705db
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jun 12 12:57:20 2020 -0700

    Remove shouldDeprioritizeSubtree from host config (#19124)
    
    No longer being used.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index a3eb0455fc..174a22d92e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -29,10 +29,7 @@ describe('ReactUpdates', () => {
   // once the extra div wrapper is no longer neccessary.
   function LegacyHiddenDiv({children, mode}) {
     return (
-      <div
-        hidden={
-          mode === 'hidden' ? 'unstable-do-not-use-legacy-hidden' : undefined
-        }>
+      <div hidden={mode === 'hidden'}>
         <React.unstable_LegacyHidden
           mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
           {children}

commit 30b47103d4354d9187dc0f1fb804855a5208ca9f
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 15 19:59:44 2020 -0400

    Fix spelling errors and typos (#19138)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 174a22d92e..2bf80a2090 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -26,7 +26,7 @@ describe('ReactUpdates', () => {
   });
 
   // Note: This is based on a similar component we use in www. We can delete
-  // once the extra div wrapper is no longer neccessary.
+  // once the extra div wrapper is no longer necessary.
   function LegacyHiddenDiv({children, mode}) {
     return (
       <div hidden={mode === 'hidden'}>
@@ -1686,7 +1686,7 @@ describe('ReactUpdates', () => {
   }
 
   if (__DEV__) {
-    it('should properly trace interactions within batched udpates', () => {
+    it('should properly trace interactions within batched updates', () => {
       const SchedulerTracing = require('scheduler/tracing');
 
       let expectedInteraction;

commit d17086c7c813402a550d15a2f56dc43f1dbd1735
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 8 10:11:45 2020 -0500

    Decouple public, internal act implementation (#19745)
    
    In the next major release, we intend to drop support for using the `act`
    testing helper in production. (It already fires a warning.) The
    rationale is that, in order for `act` to work, you must either mock the
    testing environment or add extra logic at runtime. Mocking the testing
    environment isn't ideal because it requires extra set up for the user.
    Extra logic at runtime is fine only in development mode  we don't want
    to slow down the production builds.
    
    Since most people only run their tests in development mode, dropping
    support for production should be fine; if there's demand, we can add it
    back later using a special testing build that is identical to the
    production build except for the additional testing logic.
    
    One blocker for removing production support is that we currently use
    `act` to test React itself. We must test React in both development and
    production modes.
    
    So, the solution is to fork `act` into separate public and
    internal implementations:
    
    - *public implementation of `act`*  exposed to users, only works in
      development mode, uses special runtime logic, does not support partial
      rendering
    - *internal implementation of `act`*  private, works in both
      development and productionm modes, only used by the React Core test
      suite, uses no special runtime logic, supports partial rendering (i.e.
      `toFlushAndYieldThrough`)
    
    The internal implementation should mostly match the public
    implementation's behavior, but since it's a private API, it doesn't have
    to match exactly. It works by mocking the test environment: it uses a
    mock build of Scheduler to flush rendering tasks, and Jest's mock timers
    to flush Suspense placeholders.
    
    ---
    
    In this first commit, I've added the internal forks of `act` and
    migrated our tests to use them. The public `act` implementation is
    unaffected for now; I will leave refactoring/clean-up for a later step.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 2bf80a2090..f876158b67 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -21,7 +21,7 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactTestUtils = require('react-dom/test-utils');
-    act = ReactTestUtils.act;
+    act = ReactTestUtils.unstable_concurrentAct;
     Scheduler = require('scheduler');
   });
 

commit fc33f12bdee1d0ffbcc83d25199cdf4d47252736
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Apr 26 19:16:18 2021 -0400

    Remove unstable scheduler/tracing API (#20037)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index f876158b67..28dd03158b 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1684,84 +1684,4 @@ describe('ReactUpdates', () => {
       expect(container.textContent).toBe('1000');
     });
   }
-
-  if (__DEV__) {
-    it('should properly trace interactions within batched updates', () => {
-      const SchedulerTracing = require('scheduler/tracing');
-
-      let expectedInteraction;
-
-      const container = document.createElement('div');
-
-      const Component = jest.fn(() => {
-        expect(expectedInteraction).toBeDefined();
-
-        const interactions = SchedulerTracing.unstable_getCurrent();
-        expect(interactions.size).toBe(1);
-        expect(interactions).toContain(expectedInteraction);
-
-        return null;
-      });
-
-      ReactDOM.unstable_batchedUpdates(() => {
-        SchedulerTracing.unstable_trace(
-          'mount traced inside a batched update',
-          1,
-          () => {
-            const interactions = SchedulerTracing.unstable_getCurrent();
-            expect(interactions.size).toBe(1);
-            expectedInteraction = Array.from(interactions)[0];
-
-            ReactDOM.render(<Component />, container);
-          },
-        );
-      });
-
-      ReactDOM.unstable_batchedUpdates(() => {
-        SchedulerTracing.unstable_trace(
-          'update traced inside a batched update',
-          2,
-          () => {
-            const interactions = SchedulerTracing.unstable_getCurrent();
-            expect(interactions.size).toBe(1);
-            expectedInteraction = Array.from(interactions)[0];
-
-            ReactDOM.render(<Component />, container);
-          },
-        );
-      });
-
-      const secondContainer = document.createElement('div');
-
-      SchedulerTracing.unstable_trace(
-        'mount traced outside a batched update',
-        3,
-        () => {
-          ReactDOM.unstable_batchedUpdates(() => {
-            const interactions = SchedulerTracing.unstable_getCurrent();
-            expect(interactions.size).toBe(1);
-            expectedInteraction = Array.from(interactions)[0];
-
-            ReactDOM.render(<Component />, secondContainer);
-          });
-        },
-      );
-
-      SchedulerTracing.unstable_trace(
-        'update traced outside a batched update',
-        4,
-        () => {
-          ReactDOM.unstable_batchedUpdates(() => {
-            const interactions = SchedulerTracing.unstable_getCurrent();
-            expect(interactions.size).toBe(1);
-            expectedInteraction = Array.from(interactions)[0];
-
-            ReactDOM.render(<Component />, container);
-          });
-        },
-      );
-
-      expect(Component).toHaveBeenCalledTimes(4);
-    });
-  }
 });

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 28dd03158b..dfa1a51939 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1332,7 +1332,7 @@ describe('ReactUpdates', () => {
       );
     }
 
-    const root = ReactDOM.unstable_createRoot(container);
+    const root = ReactDOM.createRoot(container);
     let hiddenDiv;
     act(() => {
       root.render(<Foo />);

commit 86715efa23c02dd156e61a4476f28045bb5f4654
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Jun 2 21:03:29 2021 -0400

    Resolve the true entry point during tests (#21505)
    
    * Resolve the entry point for tests the same way builds do
    
    This way the source tests, test the same entry point configuration.
    
    * Gate test selectors on www
    
    These are currently only exposed in www builds
    
    * Gate createEventHandle / useFocus on www
    
    These are enabled in both www variants but not OSS experimental.
    
    * Temporarily disable www-modern entry point
    
    Use the main one that has all the exports until we fix more tests.
    
    * Remove enableCache override that's no longer correct
    
    * Open gates for www
    
    These used to not be covered because they used Cache which wasn't exposed.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index dfa1a51939..fd883f7e32 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1300,7 +1300,7 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
-  // @gate experimental
+  // @gate experimental || www
   it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
     const container = document.createElement('div');
 

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index fd883f7e32..a49b62062d 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -21,7 +21,7 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactTestUtils = require('react-dom/test-utils');
-    act = ReactTestUtils.unstable_concurrentAct;
+    act = require('jest-react').act;
     Scheduler = require('scheduler');
   });
 

commit 8f96c6b2ac3ff0e38f60c87b1f08deb9993526b5
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Sep 9 11:14:30 2021 -0400

    [Bugfix] Prevent infinite update loop caused by a synchronous update in a passive effect (#22277)
    
    * Add test that triggers infinite update loop
    
    In 18, passive effects are flushed synchronously if they are the
    result of a synchronous update. We have a guard for infinite update
    loops that occur in the layout phase, but it doesn't currently work for
    synchronous updates from a passive effect.
    
    The reason this probably hasn't come up yet is because synchronous
    updates inside the passive effect phase are relatively rare: you either
    have to imperatively dispatch a discrete event, like `el.focus`, or you
    have to call `ReactDOM.flushSync`, which triggers a warning. (In
    general, updates inside a passive effect are not encouraged.)
    
    I discovered this because `useSyncExternalStore` does sometimes
    trigger updates inside the passive effect phase.
    
    This commit adds a failing test to prove the issue exists. I will fix
    it in the next commit.
    
    * Fix failing test added in previous commit
    
    The way we detect a "nested update" is if there's synchronous work
    remaining at the end of the commit phase.
    
    Currently this check happens before we synchronously flush the passive
    effects. I moved it to after the effects are fired, so that it detects
    whether synchronous work was scheduled in that phase.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index a49b62062d..42647abf53 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1594,6 +1594,7 @@ describe('ReactUpdates', () => {
     });
   });
 
+  // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
     it('warns about a deferred infinite update loop with useEffect', () => {
       function NonTerminating() {
@@ -1684,4 +1685,35 @@ describe('ReactUpdates', () => {
       expect(container.textContent).toBe('1000');
     });
   }
+
+  it('prevents infinite update loop triggered by synchronous updates in useEffect', () => {
+    // Ignore flushSync warning
+    spyOnDev(console, 'error');
+
+    function NonTerminating() {
+      const [step, setStep] = React.useState(0);
+      React.useEffect(() => {
+        // Other examples of synchronous updates in useEffect are imperative
+        // event dispatches like `el.focus`, or `useSyncExternalStore`, which
+        // may schedule a synchronous update upon subscribing if it detects
+        // that the store has been mutated since the initial render.
+        //
+        // (Originally I wrote this test using `el.focus` but those errors
+        // get dispatched in a JSDOM event and I don't know how to "catch" those
+        // so that they don't fail the test.)
+        ReactDOM.flushSync(() => {
+          setStep(step + 1);
+        });
+      }, [step]);
+      return step;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOM.createRoot(container);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
+    }).toThrow('Maximum update depth exceeded');
+  });
 });

commit 17806594cc28284fe195f918e8d77de3516848ec
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 1 00:13:28 2022 -0500

    Move createRoot/hydrateRoot to react-dom/client (#23385)
    
    * Move createRoot/hydrateRoot to /client
    
    We want these APIs ideally to be imported separately from things you
    might use in arbitrary components (like flushSync). Those other methods
    are "isomorphic" to how the ReactDOM tree is rendered. Similar to hooks.
    
    E.g. importing flushSync into a component that only uses it on the client
    should ideally not also pull in the entry client implementation on the
    server.
    
    This also creates a nicer parity with /server where the roots are in a
    separate entry point.
    
    Unfortunately, I can't quite do this yet because we have some legacy APIs
    that we plan on removing (like findDOMNode) and we also haven't implemented
    flushSync using a flag like startTransition does yet.
    
    Another problem is that we currently encourage these APIs to be aliased by
    /profiling (or unstable_testing). In the future you don't have to alias
    them because you can just change your roots to just import those APIs and
    they'll still work with the isomorphic forms. Although we might also just
    use export conditions for them.
    
    For that all to work, I went with a different strategy for now where the
    real API is in / but it comes with a warning if you use it. If you instead
    import /client it disables the warning in a wrapper. That means that if you
    alias / then import /client that will inturn import the alias and it'll
    just work.
    
    In a future breaking changes (likely when we switch to ESM) we can just
    remove createRoot/hydrateRoot from / and move away from the aliasing
    strategy.
    
    * Update tests to import from react-dom/client
    
    * Fix fixtures
    
    * Update warnings
    
    * Add test for the warning
    
    * Update devtools
    
    * Change order of react-dom, react-dom/client alias
    
    I think the order matters here. The first one takes precedence.
    
    * Require react-dom through client so it can be aliased
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 42647abf53..9e81a3b20f 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -11,6 +11,7 @@
 
 let React;
 let ReactDOM;
+let ReactDOMClient;
 let ReactTestUtils;
 let act;
 let Scheduler;
@@ -20,6 +21,7 @@ describe('ReactUpdates', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
     ReactTestUtils = require('react-dom/test-utils');
     act = require('jest-react').act;
     Scheduler = require('scheduler');
@@ -1332,7 +1334,7 @@ describe('ReactUpdates', () => {
       );
     }
 
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     let hiddenDiv;
     act(() => {
       root.render(<Foo />);
@@ -1709,7 +1711,7 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    const root = ReactDOM.createRoot(container);
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
       ReactDOM.flushSync(() => {
         root.render(<NonTerminating />);

commit 72a933d2892dac9e5327678b6bd37af8d589bb22
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Mar 9 11:48:03 2022 -0500

    Gate legacy hidden (#24047)
    
    * Gate legacy hidden
    
    * Gate tests
    
    * Remove export from experimental

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9e81a3b20f..4fe596b9b7 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1302,7 +1302,7 @@ describe('ReactUpdates', () => {
     expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
   });
 
-  // @gate experimental || www
+  // @gate www
   it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
     const container = document.createElement('div');
 

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 4fe596b9b7..ec90ac5d29 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6fb8133ed3aa6b23063375dd345c6e413b05f0fe
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Nov 17 01:15:57 2022 +0100

    Turn on string ref deprecation warning for everybody (not codemoddable) (#25383)
    
    ## Summary
    
    Alternate to https://github.com/facebook/react/pull/25334 without any
    prod runtime changes i.e. the proposed codemod in
    https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-string-refs-and-remove-production-mode-_owner-field
    would not work.
    
    ## How did you test this change?
    
    - [x] CI
    - [x] `yarn test` with and without `warnAboutStringRefs`

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index ec90ac5d29..7ac8438691 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -147,6 +147,7 @@ describe('ReactUpdates', () => {
 
     class Parent extends React.Component {
       state = {x: 0};
+      childRef = React.createRef();
 
       componentDidUpdate() {
         parentUpdateCount++;
@@ -155,7 +156,7 @@ describe('ReactUpdates', () => {
       render() {
         return (
           <div>
-            <Child ref="child" x={this.state.x} />
+            <Child ref={this.childRef} x={this.state.x} />
           </div>
         );
       }
@@ -176,7 +177,7 @@ describe('ReactUpdates', () => {
     }
 
     const instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    const child = instance.refs.child;
+    const child = instance.childRef.current;
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
@@ -200,6 +201,7 @@ describe('ReactUpdates', () => {
 
     class Parent extends React.Component {
       state = {x: 0};
+      childRef = React.createRef();
 
       componentDidUpdate() {
         parentUpdateCount++;
@@ -208,7 +210,7 @@ describe('ReactUpdates', () => {
       render() {
         return (
           <div>
-            <Child ref="child" x={this.state.x} />
+            <Child ref={this.childRef} x={this.state.x} />
           </div>
         );
       }
@@ -229,7 +231,7 @@ describe('ReactUpdates', () => {
     }
 
     const instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    const child = instance.refs.child;
+    const child = instance.childRef.current;
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
@@ -336,13 +338,15 @@ describe('ReactUpdates', () => {
     let childRenderCount = 0;
 
     class Parent extends React.Component {
+      childRef = React.createRef();
+
       shouldComponentUpdate() {
         return false;
       }
 
       render() {
         parentRenderCount++;
-        return <Child ref="child" />;
+        return <Child ref={this.childRef} />;
       }
     }
 
@@ -370,7 +374,7 @@ describe('ReactUpdates', () => {
     expect(childRenderCount).toBe(1);
 
     ReactDOM.unstable_batchedUpdates(function() {
-      instance.refs.child.setState({x: 1});
+      instance.childRef.current.setState({x: 1});
     });
 
     expect(parentRenderCount).toBe(1);
@@ -428,28 +432,34 @@ describe('ReactUpdates', () => {
     };
 
     class Box extends React.Component {
+      boxDivRef = React.createRef();
+
       render() {
-        return <div ref="boxDiv">{this.props.children}</div>;
+        return <div ref={this.boxDivRef}>{this.props.children}</div>;
       }
     }
     Object.assign(Box.prototype, UpdateLoggingMixin);
 
     class Child extends React.Component {
+      spanRef = React.createRef();
+
       render() {
-        return <span ref="span">child</span>;
+        return <span ref={this.spanRef}>child</span>;
       }
     }
     Object.assign(Child.prototype, UpdateLoggingMixin);
 
     class Switcher extends React.Component {
       state = {tabKey: 'hello'};
+      boxRef = React.createRef();
+      switcherDivRef = React.createRef();
       render() {
         const child = this.props.children;
 
         return (
-          <Box ref="box">
+          <Box ref={this.boxRef}>
             <div
-              ref="switcherDiv"
+              ref={this.switcherDivRef}
               style={{
                 display: this.state.tabKey === child.key ? '' : 'none',
               }}>
@@ -462,10 +472,13 @@ describe('ReactUpdates', () => {
     Object.assign(Switcher.prototype, UpdateLoggingMixin);
 
     class App extends React.Component {
+      switcherRef = React.createRef();
+      childRef = React.createRef();
+
       render() {
         return (
-          <Switcher ref="switcher">
-            <Child key="hello" ref="child" />
+          <Switcher ref={this.switcherRef}>
+            <Child key="hello" ref={this.childRef} />
           </Switcher>
         );
       }
@@ -513,21 +526,21 @@ describe('ReactUpdates', () => {
       expectUpdates(desiredWillUpdates, desiredDidUpdates);
     }
     testUpdates(
-      [root.refs.switcher.refs.box, root.refs.switcher],
+      [root.switcherRef.current.boxRef.current, root.switcherRef.current],
       // Owner-child relationships have inverse will and did
       ['Switcher', 'Box'],
       ['Box', 'Switcher'],
     );
 
     testUpdates(
-      [root.refs.child, root.refs.switcher.refs.box],
+      [root.childRef.current, root.switcherRef.current.boxRef.current],
       // Not owner-child so reconcile independently
       ['Box', 'Child'],
       ['Box', 'Child'],
     );
 
     testUpdates(
-      [root.refs.child, root.refs.switcher],
+      [root.childRef.current, root.switcherRef.current],
       // Switcher owns Box and Child, Box does not own Child
       ['Switcher', 'Box', 'Child'],
       ['Box', 'Switcher', 'Child'],
@@ -588,12 +601,13 @@ describe('ReactUpdates', () => {
 
     class Outer extends React.Component {
       state = {x: 0};
+      innerRef = React.createRef();
 
       render() {
         updates.push('Outer-render-' + this.state.x);
         return (
           <div>
-            <Inner x={this.state.x} ref="inner" />
+            <Inner x={this.state.x} ref={this.innerRef} />
           </div>
         );
       }
@@ -602,7 +616,7 @@ describe('ReactUpdates', () => {
         const x = this.state.x;
         updates.push('Outer-didUpdate-' + x);
         updates.push('Inner-setState-' + x);
-        this.refs.inner.setState({x: x}, function() {
+        this.innerRef.current.setState({x: x}, function() {
           updates.push('Inner-callback-' + x);
         });
       }
@@ -945,12 +959,14 @@ describe('ReactUpdates', () => {
 
   it('does not update one component twice in a batch (#2410)', () => {
     class Parent extends React.Component {
+      childRef = React.createRef();
+
       getChild = () => {
-        return this.refs.child;
+        return this.childRef.current;
       };
 
       render() {
-        return <Child ref="child" />;
+        return <Child ref={this.childRef} />;
       }
     }
 

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 7ac8438691..af5dff0155 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -58,7 +58,7 @@ describe('ReactUpdates', () => {
     const instance = ReactTestUtils.renderIntoDocument(<Component />);
     expect(instance.state.x).toBe(0);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       instance.setState({x: 1});
       instance.setState({x: 2});
       expect(instance.state.x).toBe(0);
@@ -92,7 +92,7 @@ describe('ReactUpdates', () => {
     expect(instance.state.x).toBe(0);
     expect(instance.state.y).toBe(0);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       instance.setState({x: 1});
       instance.setState({y: 2});
       expect(instance.state.x).toBe(0);
@@ -129,7 +129,7 @@ describe('ReactUpdates', () => {
     expect(instance.props.x).toBe(0);
     expect(instance.state.y).toBe(0);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       ReactDOM.render(<Component x={1} />, container);
       instance.setState({y: 2});
       expect(instance.props.x).toBe(0);
@@ -181,7 +181,7 @@ describe('ReactUpdates', () => {
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       instance.setState({x: 1});
       child.setState({y: 2});
       expect(instance.state.x).toBe(0);
@@ -235,7 +235,7 @@ describe('ReactUpdates', () => {
     expect(instance.state.x).toBe(0);
     expect(child.state.y).toBe(0);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       child.setState({y: 2});
       instance.setState({x: 1});
       expect(instance.state.x).toBe(0);
@@ -271,9 +271,9 @@ describe('ReactUpdates', () => {
     expect(instance.state.x).toBe(0);
 
     let innerCallbackRun = false;
-    ReactDOM.unstable_batchedUpdates(function() {
-      instance.setState({x: 1}, function() {
-        instance.setState({x: 2}, function() {
+    ReactDOM.unstable_batchedUpdates(function () {
+      instance.setState({x: 1}, function () {
+        instance.setState({x: 2}, function () {
           expect(this).toBe(instance);
           innerCallbackRun = true;
           expect(instance.state.x).toBe(2);
@@ -315,11 +315,11 @@ describe('ReactUpdates', () => {
     expect(instance.state.x).toBe(0);
 
     let callbacksRun = 0;
-    ReactDOM.unstable_batchedUpdates(function() {
-      instance.setState({x: 1}, function() {
+    ReactDOM.unstable_batchedUpdates(function () {
+      instance.setState({x: 1}, function () {
         callbacksRun++;
       });
-      instance.forceUpdate(function() {
+      instance.forceUpdate(function () {
         callbacksRun++;
       });
       expect(instance.state.x).toBe(0);
@@ -366,14 +366,14 @@ describe('ReactUpdates', () => {
     expect(parentRenderCount).toBe(1);
     expect(childRenderCount).toBe(1);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       instance.setState({x: 1});
     });
 
     expect(parentRenderCount).toBe(1);
     expect(childRenderCount).toBe(1);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       instance.childRef.current.setState({x: 1});
     });
 
@@ -423,10 +423,10 @@ describe('ReactUpdates', () => {
     let didUpdates = [];
 
     const UpdateLoggingMixin = {
-      UNSAFE_componentWillUpdate: function() {
+      UNSAFE_componentWillUpdate: function () {
         willUpdates.push(this.constructor.displayName);
       },
-      componentDidUpdate: function() {
+      componentDidUpdate: function () {
         didUpdates.push(this.constructor.displayName);
       },
     };
@@ -507,7 +507,7 @@ describe('ReactUpdates', () => {
     function testUpdates(components, desiredWillUpdates, desiredDidUpdates) {
       let i;
 
-      ReactDOM.unstable_batchedUpdates(function() {
+      ReactDOM.unstable_batchedUpdates(function () {
         for (i = 0; i < components.length; i++) {
           triggerUpdate(components[i]);
         }
@@ -517,7 +517,7 @@ describe('ReactUpdates', () => {
 
       // Try them in reverse order
 
-      ReactDOM.unstable_batchedUpdates(function() {
+      ReactDOM.unstable_batchedUpdates(function () {
         for (i = components.length - 1; i >= 0; i--) {
           triggerUpdate(components[i]);
         }
@@ -588,7 +588,7 @@ describe('ReactUpdates', () => {
     }
 
     const a = ReactTestUtils.renderIntoDocument(<A />);
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       a.setState({x: 1});
       b.setState({x: 1});
     });
@@ -616,7 +616,7 @@ describe('ReactUpdates', () => {
         const x = this.state.x;
         updates.push('Outer-didUpdate-' + x);
         updates.push('Inner-setState-' + x);
-        this.innerRef.current.setState({x: x}, function() {
+        this.innerRef.current.setState({x: x}, function () {
           updates.push('Inner-callback-' + x);
         });
       }
@@ -638,10 +638,10 @@ describe('ReactUpdates', () => {
     const instance = ReactTestUtils.renderIntoDocument(<Outer />);
 
     updates.push('Outer-setState-1');
-    instance.setState({x: 1}, function() {
+    instance.setState({x: 1}, function () {
       updates.push('Outer-callback-1');
       updates.push('Outer-setState-2');
-      instance.setState({x: 2}, function() {
+      instance.setState({x: 2}, function () {
         updates.push('Outer-callback-2');
       });
     });
@@ -706,9 +706,9 @@ describe('ReactUpdates', () => {
 
     expect(updates).toEqual([0, 1, 2]);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       // Simulate update on each component from top to bottom.
-      instances.forEach(function(instance) {
+      instances.forEach(function (instance) {
         instance.forceUpdate();
       });
     });
@@ -795,7 +795,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       ReactTestUtils.renderIntoDocument(
         <div>
           <A />
@@ -816,7 +816,7 @@ describe('ReactUpdates', () => {
 
       UNSAFE_componentWillReceiveProps(nextProps) {
         const newX = nextProps.x;
-        this.setState({x: newX}, function() {
+        this.setState({x: newX}, function () {
           // State should have updated by the time this callback gets called
           expect(this.state.x).toBe(newX);
           callbackCount++;
@@ -861,7 +861,7 @@ describe('ReactUpdates', () => {
 
     const component = ReactTestUtils.renderIntoDocument(<A />);
 
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       // B will have scheduled an update but the batching should ensure that its
       // update never fires.
       componentB.setState({updates: 1});
@@ -1003,7 +1003,7 @@ describe('ReactUpdates', () => {
 
     const parent = ReactTestUtils.renderIntoDocument(<Parent />);
     const child = parent.getChild();
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       parent.forceUpdate();
       child.forceUpdate();
     });
@@ -1052,7 +1052,7 @@ describe('ReactUpdates', () => {
         callbacks = callbacks.filter(c => c !== this.onChange);
       }
       render() {
-        return <div key={Math.random()} onClick={function() {}} />;
+        return <div key={Math.random()} onClick={function () {}} />;
       }
     }
 
@@ -1060,7 +1060,7 @@ describe('ReactUpdates', () => {
   });
 
   it('unstable_batchedUpdates should return value from a callback', () => {
-    const result = ReactDOM.unstable_batchedUpdates(function() {
+    const result = ReactDOM.unstable_batchedUpdates(function () {
       return 42;
     });
     expect(result).toEqual(42);
@@ -1069,7 +1069,7 @@ describe('ReactUpdates', () => {
   it('unmounts and remounts a root in the same batch', () => {
     const container = document.createElement('div');
     ReactDOM.render(<span>a</span>, container);
-    ReactDOM.unstable_batchedUpdates(function() {
+    ReactDOM.unstable_batchedUpdates(function () {
       ReactDOM.unmountComponentAtNode(container);
       ReactDOM.render(<span>b</span>, container);
     });

commit 71cace4d3267e4527964db51ccaf5eab7234f37f
Author: Ming Ye <ymqyit@gmail.com>
Date:   Sat Feb 11 02:39:14 2023 +0800

    Migrate testRunner from jasmine2 to jest-circus (#26144)
    
    ## Summary
    
    In jest v27, jest-circus as default test runner
    (https://github.com/facebook/jest/pull/10686)
    
    ## How did you test this change?
    
    ci green

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index af5dff0155..9da24ed44f 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1706,7 +1706,7 @@ describe('ReactUpdates', () => {
 
   it('prevents infinite update loop triggered by synchronous updates in useEffect', () => {
     // Ignore flushSync warning
-    spyOnDev(console, 'error');
+    spyOnDev(console, 'error').mockImplementation(() => {});
 
     function NonTerminating() {
       const [step, setStep] = React.useState(0);

commit e64a8f4035024ce749bcbcf93b2618e66200a7f7
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 17:02:12 2023 -0500

    Codemod tests to waitFor pattern (3/?) (#26299)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9da24ed44f..87913c63df 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -15,6 +15,9 @@ let ReactDOMClient;
 let ReactTestUtils;
 let act;
 let Scheduler;
+let waitForAll;
+let waitFor;
+let assertLog;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
@@ -25,6 +28,11 @@ describe('ReactUpdates', () => {
     ReactTestUtils = require('react-dom/test-utils');
     act = require('jest-react').act;
     Scheduler = require('scheduler');
+
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
   });
 
   // Note: This is based on a similar component we use in www. We can delete
@@ -1319,7 +1327,7 @@ describe('ReactUpdates', () => {
   });
 
   // @gate www
-  it('delays sync updates inside hidden subtrees in Concurrent Mode', () => {
+  it('delays sync updates inside hidden subtrees in Concurrent Mode', async () => {
     const container = document.createElement('div');
 
     function Baz() {
@@ -1352,14 +1360,14 @@ describe('ReactUpdates', () => {
 
     const root = ReactDOMClient.createRoot(container);
     let hiddenDiv;
-    act(() => {
+    await act(async () => {
       root.render(<Foo />);
-      expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
+      await waitFor(['Foo', 'Baz', 'Foo#effect']);
       hiddenDiv = container.firstChild.firstChild;
       expect(hiddenDiv.hidden).toBe(true);
       expect(hiddenDiv.innerHTML).toBe('');
       // Run offscreen update
-      expect(Scheduler).toFlushAndYield(['Bar']);
+      await waitForAll(['Bar']);
       expect(hiddenDiv.hidden).toBe(true);
       expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
     });
@@ -1371,7 +1379,7 @@ describe('ReactUpdates', () => {
     expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
 
     // Run offscreen update
-    expect(Scheduler).toFlushAndYield(['Bar']);
+    await waitForAll(['Bar']);
     expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
   });
 
@@ -1699,7 +1707,7 @@ describe('ReactUpdates', () => {
         ReactDOM.render(<Terminating />, container);
       });
 
-      expect(Scheduler).toHaveYielded(['Done']);
+      assertLog(['Done']);
       expect(container.textContent).toBe('1000');
     });
   }

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 87913c63df..5555e1b074 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1331,7 +1331,7 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
 
     function Baz() {
-      Scheduler.unstable_yieldValue('Baz');
+      Scheduler.log('Baz');
       return <p>baz</p>;
     }
 
@@ -1339,14 +1339,14 @@ describe('ReactUpdates', () => {
     function Bar() {
       const [counter, _setCounter] = React.useState(0);
       setCounter = _setCounter;
-      Scheduler.unstable_yieldValue('Bar');
+      Scheduler.log('Bar');
       return <p>bar {counter}</p>;
     }
 
     function Foo() {
-      Scheduler.unstable_yieldValue('Foo');
+      Scheduler.log('Foo');
       React.useEffect(() => {
-        Scheduler.unstable_yieldValue('Foo#effect');
+        Scheduler.log('Foo#effect');
       });
       return (
         <div>
@@ -1627,7 +1627,7 @@ describe('ReactUpdates', () => {
         const [step, setStep] = React.useState(0);
         React.useEffect(() => {
           setStep(x => x + 1);
-          Scheduler.unstable_yieldValue(step);
+          Scheduler.log(step);
         });
         return step;
       }
@@ -1650,7 +1650,7 @@ describe('ReactUpdates', () => {
             ReactDOM.render(<App />, container);
             while (error === null) {
               Scheduler.unstable_flushNumberOfYields(1);
-              Scheduler.unstable_clearYields();
+              Scheduler.unstable_clearLog();
             }
             expect(error).toContain('Warning: Maximum update depth exceeded.');
             expect(stack).toContain(' NonTerminating');
@@ -1675,7 +1675,7 @@ describe('ReactUpdates', () => {
             setStep(x => x + 1);
           }
         });
-        Scheduler.unstable_yieldValue(step);
+        Scheduler.log(step);
         return step;
       }
 
@@ -1697,7 +1697,7 @@ describe('ReactUpdates', () => {
           for (let i = 0; i < 1000; i++) {
             setStep(x => x + 1);
           }
-          Scheduler.unstable_yieldValue('Done');
+          Scheduler.log('Done');
         }, []);
         return step;
       }

commit 703c67560d1b5e5d32170cd513cda52559933527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 7 10:15:34 2023 -0500

    Codemod act -> await act (1/?) (#26334)
    
    Similar to the rationale for `waitFor` (see
    https://github.com/facebook/react/pull/26285), we should always await
    the result of an `act` call so that microtasks have a chance to fire.
    
    This only affects the internal `act` that we use in our repo, for now.
    In the public `act` API, we don't yet require this; however, we
    effectively will for any update that triggers suspense once `use` lands.
    So we likely will start warning in an upcoming minor.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 5555e1b074..5e39cb88d5 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1622,7 +1622,7 @@ describe('ReactUpdates', () => {
 
   // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
-    it('warns about a deferred infinite update loop with useEffect', () => {
+    it('warns about a deferred infinite update loop with useEffect', async () => {
       function NonTerminating() {
         const [step, setStep] = React.useState(0);
         React.useEffect(() => {
@@ -1646,24 +1646,22 @@ describe('ReactUpdates', () => {
       try {
         const container = document.createElement('div');
         expect(() => {
-          act(() => {
-            ReactDOM.render(<App />, container);
-            while (error === null) {
-              Scheduler.unstable_flushNumberOfYields(1);
-              Scheduler.unstable_clearLog();
-            }
-            expect(error).toContain('Warning: Maximum update depth exceeded.');
-            expect(stack).toContain(' NonTerminating');
-            // rethrow error to prevent going into an infinite loop when act() exits
-            throw error;
-          });
+          ReactDOM.render(<App />, container);
+          while (error === null) {
+            Scheduler.unstable_flushNumberOfYields(1);
+            Scheduler.unstable_clearLog();
+          }
+          expect(error).toContain('Warning: Maximum update depth exceeded.');
+          expect(stack).toContain(' NonTerminating');
+          // rethrow error to prevent going into an infinite loop when act() exits
+          throw error;
         }).toThrow('Maximum update depth exceeded.');
       } finally {
         console.error = originalConsoleError;
       }
     });
 
-    it('can have nested updates if they do not cross the limit', () => {
+    it('can have nested updates if they do not cross the limit', async () => {
       let _setStep;
       const LIMIT = 50;
 
@@ -1680,17 +1678,17 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      act(() => {
+      await act(async () => {
         ReactDOM.render(<Terminating />, container);
       });
       expect(container.textContent).toBe('50');
-      act(() => {
+      await act(async () => {
         _setStep(0);
       });
       expect(container.textContent).toBe('50');
     });
 
-    it('can have many updates inside useEffect without triggering a warning', () => {
+    it('can have many updates inside useEffect without triggering a warning', async () => {
       function Terminating() {
         const [step, setStep] = React.useState(0);
         React.useEffect(() => {
@@ -1703,7 +1701,7 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      act(() => {
+      await act(async () => {
         ReactDOM.render(<Terminating />, container);
       });
 

commit 44d3807945700de8bb6bdbbf5c4d1ba513303747
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 12:58:31 2023 -0500

    Move internalAct to internal-test-utils package (#26344)
    
    This is not a public API. We only use it for our internal tests, the
    ones in this repo. Let's move it to this private package. Practically
    speaking this will also let us use async/await in the implementation.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 5e39cb88d5..56c2db3b72 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -26,7 +26,7 @@ describe('ReactUpdates', () => {
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
     ReactTestUtils = require('react-dom/test-utils');
-    act = require('jest-react').act;
+    act = require('internal-test-utils').act;
     Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');

commit 62cd5af08e2ac8b1d4691e75252487083cf7a4aa
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 16:40:23 2023 -0500

    Codemod redundant async act scopes (#26350)
    
    Prior to #26347, our internal `act` API (not the public API) behaved
    differently depending on whether the scope function returned a promise
    (i.e. was an async function), for historical reasons that no longer
    apply. Now that this is fixed, I've codemodded all async act scopes that
    don't contain an await to be sync.
    
    No pressing motivation other than it looks nicer and the codemod was
    easy. Might help avoid confusion for new contributors who see async act
    scopes with nothing async inside and infer it must be like that for a
    reason.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 56c2db3b72..ef9766da96 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1678,11 +1678,11 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      await act(async () => {
+      await act(() => {
         ReactDOM.render(<Terminating />, container);
       });
       expect(container.textContent).toBe('50');
-      await act(async () => {
+      await act(() => {
         _setStep(0);
       });
       expect(container.textContent).toBe('50');
@@ -1701,7 +1701,7 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      await act(async () => {
+      await act(() => {
         ReactDOM.render(<Terminating />, container);
       });
 

commit 87c803d1dad7e5fe8863436b0d2d18df3d462f21
Author: Tianyu Yao <skyyao@fb.com>
Date:   Thu Mar 16 12:27:15 2023 -0700

    Fix a test case in ReactUpdates-test (#26399)
    
    Just noticed the test isn't testing what it is meant to test properly.
    The error `Warning: ReactDOM.render is no longer supported in React 18.
    Use createRoot instead. Until you switch to the new API, your app will
    behave as if it's running React 17. Learn more:
    https://reactjs.org/link/switch-to-createroot` is thrown, the inner
    `expect(error).toContain('Warning: Maximum update depth exceeded.');`
    failed and threw jest error, and the outer `.toThrow('Maximum update
    depth exceeded.')` happens to catch it and makes the test pass.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index ef9766da96..3c900a1987 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1646,12 +1646,12 @@ describe('ReactUpdates', () => {
       try {
         const container = document.createElement('div');
         expect(() => {
-          ReactDOM.render(<App />, container);
+          const root = ReactDOMClient.createRoot(container);
+          root.render(<App />);
           while (error === null) {
             Scheduler.unstable_flushNumberOfYields(1);
             Scheduler.unstable_clearLog();
           }
-          expect(error).toContain('Warning: Maximum update depth exceeded.');
           expect(stack).toContain(' NonTerminating');
           // rethrow error to prevent going into an infinite loop when act() exits
           throw error;

commit fc90eb636876d54d99ace2773dd4923f3e848106
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 28 00:03:57 2023 -0400

    Codemod more tests to waitFor pattern (#26494)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 3c900a1987..67abeb6dd0 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1627,7 +1627,6 @@ describe('ReactUpdates', () => {
         const [step, setStep] = React.useState(0);
         React.useEffect(() => {
           setStep(x => x + 1);
-          Scheduler.log(step);
         });
         return step;
       }
@@ -1642,23 +1641,19 @@ describe('ReactUpdates', () => {
       console.error = (e, s) => {
         error = e;
         stack = s;
+        Scheduler.log('stop');
       };
       try {
         const container = document.createElement('div');
-        expect(() => {
-          const root = ReactDOMClient.createRoot(container);
-          root.render(<App />);
-          while (error === null) {
-            Scheduler.unstable_flushNumberOfYields(1);
-            Scheduler.unstable_clearLog();
-          }
-          expect(stack).toContain(' NonTerminating');
-          // rethrow error to prevent going into an infinite loop when act() exits
-          throw error;
-        }).toThrow('Maximum update depth exceeded.');
+        const root = ReactDOMClient.createRoot(container);
+        root.render(<App />);
+        await waitFor(['stop']);
       } finally {
         console.error = originalConsoleError;
       }
+
+      expect(error).toContain('Maximum update depth exceeded');
+      expect(stack).toContain('at NonTerminating');
     });
 
     it('can have nested updates if they do not cross the limit', async () => {

commit 822386f252fd1f0e949efa904a1ed790133329f7
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 27 13:26:35 2023 -0400

    Fix: Detect infinite update loops caused by render phase updates (#26625)
    
    This PR contains a regression test and two separate fixes: a targeted
    fix, and a more general one that's designed as a last-resort guard
    against these types of bugs (both bugs in app code and bugs in React).
    
    I confirmed that each of these fixes separately are sufficient to fix
    the regression test I added.
    
    We can't realistically detect all infinite update loop scenarios because
    they could be async; even a single microtask can foil our attempts to
    detect a cycle. But this improves our strategy for detecting the most
    common kind.
    
    See commit messages for more details.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 67abeb6dd0..9b1478cf39 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1620,6 +1620,64 @@ describe('ReactUpdates', () => {
     });
   });
 
+  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    expect(() => {
+      expect(() => ReactDOM.flushSync(() => root.render(<App />))).toThrow(
+        'Maximum update depth exceeded',
+      );
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
+  });
+
+  it("does not infinite loop if there's an async render phase update on another component", async () => {
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    await expect(async () => {
+      let error;
+      try {
+        await act(() => {
+          React.startTransition(() => root.render(<App />));
+        });
+      } catch (e) {
+        error = e;
+      }
+      expect(error.message).toMatch('Maximum update depth exceeded');
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
+  });
+
   // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
     it('warns about a deferred infinite update loop with useEffect', async () => {

commit 7f362de1588d98438787d652941533e21f2f332d
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Jun 30 12:51:11 2023 -0400

    Revert "Fix: Detect infinite update loops caused by render phase updates (#26625)" (#27027)
    
    This reverts commit 822386f252fd1f0e949efa904a1ed790133329f7.
    
    This broke a number of tests when synced internally. We'll need to
    investigate the breakages before relanding this.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9b1478cf39..67abeb6dd0 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1620,64 +1620,6 @@ describe('ReactUpdates', () => {
     });
   });
 
-  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    expect(() => {
-      expect(() => ReactDOM.flushSync(() => root.render(<App />))).toThrow(
-        'Maximum update depth exceeded',
-      );
-    }).toErrorDev(
-      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
-    );
-  });
-
-  it("does not infinite loop if there's an async render phase update on another component", async () => {
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      let error;
-      try {
-        await act(() => {
-          React.startTransition(() => root.render(<App />));
-        });
-      } catch (e) {
-        error = e;
-      }
-      expect(error.message).toMatch('Maximum update depth exceeded');
-    }).toErrorDev(
-      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
-    );
-  });
-
   // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
     it('warns about a deferred infinite update loop with useEffect', async () => {

commit 8bb6ee1d33ca6c7e34342bc4b17aac0449ab6899
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jan 25 01:17:03 2024 -0500

    Update ReactUpdates-test (#28061)
    
    ## Overview
    
    These tests are important for `ReactDOM.render`, so instead of just
    re-writing them to `createRoot` and losing coverage:
    - Moved the `.render` tests to `ReactLegacyUpdates`
    - Re-wrote the tests in `ReactUpdates` to use `createRoot`
    - Remove `unstable_batchedUpdates` from `ReactUpdates`
    
    In a future PR, when I flag `batchedUpdates` with a Noop, I can add the
    gate to just the tests in `ReactLegacyUpdates`.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 67abeb6dd0..b460e92476 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -48,226 +48,283 @@ describe('ReactUpdates', () => {
     );
   }
 
-  it('should batch state when updating state twice', () => {
-    let updateCount = 0;
-
-    class Component extends React.Component {
-      state = {x: 0};
-
-      componentDidUpdate() {
-        updateCount++;
-      }
+  it('should batch state when updating state twice', async () => {
+    let componentState;
+    let setState;
+
+    function Component() {
+      const [state, _setState] = React.useState(0);
+      componentState = state;
+      setState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Commit');
+      });
 
-      render() {
-        return <div>{this.state.x}</div>;
-      }
+      return <div>{state}</div>;
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Component />);
-    expect(instance.state.x).toBe(0);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
 
-    ReactDOM.unstable_batchedUpdates(function () {
-      instance.setState({x: 1});
-      instance.setState({x: 2});
-      expect(instance.state.x).toBe(0);
-      expect(updateCount).toBe(0);
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('0');
+
+    await act(() => {
+      setState(1);
+      setState(2);
+      expect(componentState).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      assertLog([]);
     });
 
-    expect(instance.state.x).toBe(2);
-    expect(updateCount).toBe(1);
+    expect(componentState).toBe(2);
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('2');
   });
 
-  it('should batch state when updating two different state keys', () => {
-    let updateCount = 0;
+  it('should batch state when updating two different states', async () => {
+    let componentStateA;
+    let componentStateB;
+    let setStateA;
+    let setStateB;
 
-    class Component extends React.Component {
-      state = {x: 0, y: 0};
+    function Component() {
+      const [stateA, _setStateA] = React.useState(0);
+      const [stateB, _setStateB] = React.useState(0);
+      componentStateA = stateA;
+      componentStateB = stateB;
+      setStateA = _setStateA;
+      setStateB = _setStateB;
 
-      componentDidUpdate() {
-        updateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Commit');
+      });
 
-      render() {
-        return (
-          <div>
-            ({this.state.x}, {this.state.y})
-          </div>
-        );
-      }
+      return (
+        <div>
+          {stateA} {stateB}
+        </div>
+      );
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Component />);
-    expect(instance.state.x).toBe(0);
-    expect(instance.state.y).toBe(0);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
 
-    ReactDOM.unstable_batchedUpdates(function () {
-      instance.setState({x: 1});
-      instance.setState({y: 2});
-      expect(instance.state.x).toBe(0);
-      expect(instance.state.y).toBe(0);
-      expect(updateCount).toBe(0);
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('0 0');
+
+    await act(() => {
+      setStateA(1);
+      setStateB(2);
+      expect(componentStateA).toBe(0);
+      expect(componentStateB).toBe(0);
+      expect(container.firstChild.textContent).toBe('0 0');
+      assertLog([]);
     });
 
-    expect(instance.state.x).toBe(1);
-    expect(instance.state.y).toBe(2);
-    expect(updateCount).toBe(1);
+    expect(componentStateA).toBe(1);
+    expect(componentStateB).toBe(2);
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('1 2');
   });
 
-  it('should batch state and props together', () => {
-    let updateCount = 0;
+  it('should batch state and props together', async () => {
+    let setState;
+    let componentProp;
+    let componentState;
 
-    class Component extends React.Component {
-      state = {y: 0};
+    function Component({prop}) {
+      const [state, _setState] = React.useState(0);
+      componentProp = prop;
+      componentState = state;
+      setState = _setState;
 
-      componentDidUpdate() {
-        updateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Commit');
+      });
 
-      render() {
-        return (
-          <div>
-            ({this.props.x}, {this.state.y})
-          </div>
-        );
-      }
+      return (
+        <div>
+          {prop} {state}
+        </div>
+      );
     }
 
     const container = document.createElement('div');
-    const instance = ReactDOM.render(<Component x={0} />, container);
-    expect(instance.props.x).toBe(0);
-    expect(instance.state.y).toBe(0);
-
-    ReactDOM.unstable_batchedUpdates(function () {
-      ReactDOM.render(<Component x={1} />, container);
-      instance.setState({y: 2});
-      expect(instance.props.x).toBe(0);
-      expect(instance.state.y).toBe(0);
-      expect(updateCount).toBe(0);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component prop={0} />);
+    });
+
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('0 0');
+
+    await act(() => {
+      root.render(<Component prop={1} />);
+      setState(2);
+      expect(componentProp).toBe(0);
+      expect(componentState).toBe(0);
+      expect(container.firstChild.textContent).toBe('0 0');
+      assertLog([]);
     });
 
-    expect(instance.props.x).toBe(1);
-    expect(instance.state.y).toBe(2);
-    expect(updateCount).toBe(1);
+    expect(componentProp).toBe(1);
+    expect(componentState).toBe(2);
+    assertLog(['Commit']);
+    expect(container.firstChild.textContent).toBe('1 2');
   });
 
-  it('should batch parent/child state updates together', () => {
-    let parentUpdateCount = 0;
+  it('should batch parent/child state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-    class Parent extends React.Component {
-      state = {x: 0};
-      childRef = React.createRef();
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
 
-      componentDidUpdate() {
-        parentUpdateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Parent Commit');
+      });
 
-      render() {
-        return (
-          <div>
-            <Child ref={this.childRef} x={this.state.x} />
-          </div>
-        );
-      }
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
     }
 
-    let childUpdateCount = 0;
-
-    class Child extends React.Component {
-      state = {y: 0};
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
 
-      componentDidUpdate() {
-        childUpdateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
+      });
 
-      render() {
-        return <div>{this.props.x + this.state.y}</div>;
-      }
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    const child = instance.childRef.current;
-    expect(instance.state.x).toBe(0);
-    expect(child.state.y).toBe(0);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
 
-    ReactDOM.unstable_batchedUpdates(function () {
-      instance.setState({x: 1});
-      child.setState({y: 2});
-      expect(instance.state.x).toBe(0);
-      expect(child.state.y).toBe(0);
-      expect(parentUpdateCount).toBe(0);
-      expect(childUpdateCount).toBe(0);
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Parent update first.
+      setParentState(1);
+      setChildState(2);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
     });
 
-    expect(instance.state.x).toBe(1);
-    expect(child.state.y).toBe(2);
-    expect(parentUpdateCount).toBe(1);
-    expect(childUpdateCount).toBe(1);
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('should batch child/parent state updates together', () => {
-    let parentUpdateCount = 0;
+  it('should batch child/parent state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-    class Parent extends React.Component {
-      state = {x: 0};
-      childRef = React.createRef();
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
 
-      componentDidUpdate() {
-        parentUpdateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Parent Commit');
+      });
 
-      render() {
-        return (
-          <div>
-            <Child ref={this.childRef} x={this.state.x} />
-          </div>
-        );
-      }
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
     }
 
-    let childUpdateCount = 0;
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
 
-    class Child extends React.Component {
-      state = {y: 0};
-
-      componentDidUpdate() {
-        childUpdateCount++;
-      }
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
+      });
 
-      render() {
-        return <div>{this.props.x + this.state.y}</div>;
-      }
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Parent />);
-    const child = instance.childRef.current;
-    expect(instance.state.x).toBe(0);
-    expect(child.state.y).toBe(0);
-
-    ReactDOM.unstable_batchedUpdates(function () {
-      child.setState({y: 2});
-      instance.setState({x: 1});
-      expect(instance.state.x).toBe(0);
-      expect(child.state.y).toBe(0);
-      expect(parentUpdateCount).toBe(0);
-      expect(childUpdateCount).toBe(0);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
     });
 
-    expect(instance.state.x).toBe(1);
-    expect(child.state.y).toBe(2);
-    expect(parentUpdateCount).toBe(1);
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Child update first.
+      setChildState(2);
+      setParentState(1);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
 
-    // Batching reduces the number of updates here to 1.
-    expect(childUpdateCount).toBe(1);
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('should support chained state updates', () => {
-    let updateCount = 0;
-
+  it('should support chained state updates', async () => {
+    let instance;
     class Component extends React.Component {
       state = {x: 0};
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
 
       componentDidUpdate() {
-        updateCount++;
+        Scheduler.log('Update');
       }
 
       render() {
@@ -275,43 +332,55 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
+
     expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
 
     let innerCallbackRun = false;
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       instance.setState({x: 1}, function () {
         instance.setState({x: 2}, function () {
-          expect(this).toBe(instance);
           innerCallbackRun = true;
           expect(instance.state.x).toBe(2);
-          expect(updateCount).toBe(2);
+          expect(container.firstChild.textContent).toBe('2');
+          assertLog(['Update']);
         });
         expect(instance.state.x).toBe(1);
-        expect(updateCount).toBe(1);
+        expect(container.firstChild.textContent).toBe('1');
+        assertLog(['Update']);
       });
       expect(instance.state.x).toBe(0);
-      expect(updateCount).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      assertLog([]);
     });
 
-    expect(innerCallbackRun).toBeTruthy();
+    assertLog([]);
     expect(instance.state.x).toBe(2);
-    expect(updateCount).toBe(2);
+    expect(innerCallbackRun).toBeTruthy();
+    expect(container.firstChild.textContent).toBe('2');
   });
 
-  it('should batch forceUpdate together', () => {
+  it('should batch forceUpdate together', async () => {
+    let instance;
     let shouldUpdateCount = 0;
-    let updateCount = 0;
-
     class Component extends React.Component {
       state = {x: 0};
 
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
       shouldComponentUpdate() {
         shouldUpdateCount++;
       }
 
       componentDidUpdate() {
-        updateCount++;
+        Scheduler.log('Update');
       }
 
       render() {
@@ -319,80 +388,82 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Component />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
+
+    assertLog([]);
     expect(instance.state.x).toBe(0);
 
-    let callbacksRun = 0;
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       instance.setState({x: 1}, function () {
-        callbacksRun++;
+        Scheduler.log('callback');
       });
       instance.forceUpdate(function () {
-        callbacksRun++;
+        Scheduler.log('forceUpdate');
       });
+      assertLog([]);
       expect(instance.state.x).toBe(0);
-      expect(updateCount).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
     });
 
-    expect(callbacksRun).toBe(2);
     // shouldComponentUpdate shouldn't be called since we're forcing
     expect(shouldUpdateCount).toBe(0);
+    assertLog(['Update', 'callback', 'forceUpdate']);
     expect(instance.state.x).toBe(1);
-    expect(updateCount).toBe(1);
+    expect(container.firstChild.textContent).toBe('1');
   });
 
-  it('should update children even if parent blocks updates', () => {
-    let parentRenderCount = 0;
-    let childRenderCount = 0;
-
+  it('should update children even if parent blocks updates', async () => {
+    let instance;
     class Parent extends React.Component {
       childRef = React.createRef();
 
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
       shouldComponentUpdate() {
         return false;
       }
 
       render() {
-        parentRenderCount++;
+        Scheduler.log('Parent render');
         return <Child ref={this.childRef} />;
       }
     }
 
     class Child extends React.Component {
       render() {
-        childRenderCount++;
+        Scheduler.log('Child render');
         return <div />;
       }
     }
 
-    expect(parentRenderCount).toBe(0);
-    expect(childRenderCount).toBe(0);
-
-    let instance = <Parent />;
-    instance = ReactTestUtils.renderIntoDocument(instance);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
 
-    expect(parentRenderCount).toBe(1);
-    expect(childRenderCount).toBe(1);
+    assertLog(['Parent render', 'Child render']);
 
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       instance.setState({x: 1});
     });
 
-    expect(parentRenderCount).toBe(1);
-    expect(childRenderCount).toBe(1);
+    assertLog([]);
 
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       instance.childRef.current.setState({x: 1});
     });
 
-    expect(parentRenderCount).toBe(1);
-    expect(childRenderCount).toBe(2);
+    assertLog(['Child render']);
   });
 
-  it('should not reconcile children passed via props', () => {
-    let numMiddleRenders = 0;
-    let numBottomRenders = 0;
-
+  it('should not reconcile children passed via props', async () => {
     class Top extends React.Component {
       render() {
         return (
@@ -409,26 +480,31 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        numMiddleRenders++;
+        Scheduler.log('Middle');
         return React.Children.only(this.props.children);
       }
     }
 
     class Bottom extends React.Component {
       render() {
-        numBottomRenders++;
+        Scheduler.log('Bottom');
         return null;
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<Top />);
-    expect(numMiddleRenders).toBe(2);
-    expect(numBottomRenders).toBe(1);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Top />);
+    });
+
+    assertLog(['Middle', 'Bottom', 'Middle']);
   });
 
-  it('should flow updates correctly', () => {
+  it('should flow updates correctly', async () => {
     let willUpdates = [];
     let didUpdates = [];
+    let instance;
 
     const UpdateLoggingMixin = {
       UNSAFE_componentWillUpdate: function () {
@@ -482,7 +558,10 @@ describe('ReactUpdates', () => {
     class App extends React.Component {
       switcherRef = React.createRef();
       childRef = React.createRef();
-
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
       render() {
         return (
           <Switcher ref={this.switcherRef}>
@@ -493,8 +572,10 @@ describe('ReactUpdates', () => {
     }
     Object.assign(App.prototype, UpdateLoggingMixin);
 
-    let root = <App />;
-    root = ReactTestUtils.renderIntoDocument(root);
+    const container = document.createElement('div');
+    await act(() => {
+      ReactDOMClient.createRoot(container).render(<App />);
+    });
 
     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
       let i;
@@ -512,10 +593,14 @@ describe('ReactUpdates', () => {
       c.setState({x: 1});
     }
 
-    function testUpdates(components, desiredWillUpdates, desiredDidUpdates) {
+    async function testUpdates(
+      components,
+      desiredWillUpdates,
+      desiredDidUpdates,
+    ) {
       let i;
 
-      ReactDOM.unstable_batchedUpdates(function () {
+      await act(() => {
         for (i = 0; i < components.length; i++) {
           triggerUpdate(components[i]);
         }
@@ -525,7 +610,7 @@ describe('ReactUpdates', () => {
 
       // Try them in reverse order
 
-      ReactDOM.unstable_batchedUpdates(function () {
+      await act(() => {
         for (i = components.length - 1; i >= 0; i--) {
           triggerUpdate(components[i]);
         }
@@ -533,42 +618,48 @@ describe('ReactUpdates', () => {
 
       expectUpdates(desiredWillUpdates, desiredDidUpdates);
     }
-    testUpdates(
-      [root.switcherRef.current.boxRef.current, root.switcherRef.current],
+    await testUpdates(
+      [
+        instance.switcherRef.current.boxRef.current,
+        instance.switcherRef.current,
+      ],
       // Owner-child relationships have inverse will and did
       ['Switcher', 'Box'],
       ['Box', 'Switcher'],
     );
 
-    testUpdates(
-      [root.childRef.current, root.switcherRef.current.boxRef.current],
+    await testUpdates(
+      [instance.childRef.current, instance.switcherRef.current.boxRef.current],
       // Not owner-child so reconcile independently
       ['Box', 'Child'],
       ['Box', 'Child'],
     );
 
-    testUpdates(
-      [root.childRef.current, root.switcherRef.current],
+    await testUpdates(
+      [instance.childRef.current, instance.switcherRef.current],
       // Switcher owns Box and Child, Box does not own Child
       ['Switcher', 'Box', 'Child'],
       ['Box', 'Switcher', 'Child'],
     );
   });
 
-  it('should queue mount-ready handlers across different roots', () => {
+  it('should queue mount-ready handlers across different roots', async () => {
     // We'll define two components A and B, then update both of them. When A's
     // componentDidUpdate handlers is called, B's DOM should already have been
     // updated.
 
     const bContainer = document.createElement('div');
-
+    let a;
     let b;
 
     let aUpdated = false;
 
     class A extends React.Component {
       state = {x: 0};
-
+      constructor(props) {
+        super(props);
+        a = this;
+      }
       componentDidUpdate() {
         expect(ReactDOM.findDOMNode(b).textContent).toBe('B1');
         aUpdated = true;
@@ -576,7 +667,6 @@ describe('ReactUpdates', () => {
 
       render() {
         let portal = null;
-        // If we're using Fiber, we use Portals instead to achieve this.
         portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
         return (
           <div>
@@ -595,8 +685,13 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const a = ReactTestUtils.renderIntoDocument(<A />);
-    ReactDOM.unstable_batchedUpdates(function () {
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A />);
+    });
+
+    await act(() => {
       a.setState({x: 1});
       b.setState({x: 1});
     });
@@ -604,13 +699,16 @@ describe('ReactUpdates', () => {
     expect(aUpdated).toBe(true);
   });
 
-  it('should flush updates in the correct order', () => {
+  it('should flush updates in the correct order', async () => {
     const updates = [];
-
+    let instance;
     class Outer extends React.Component {
       state = {x: 0};
       innerRef = React.createRef();
-
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
       render() {
         updates.push('Outer-render-' + this.state.x);
         return (
@@ -643,14 +741,20 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const instance = ReactTestUtils.renderIntoDocument(<Outer />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Outer />);
+    });
 
-    updates.push('Outer-setState-1');
-    instance.setState({x: 1}, function () {
-      updates.push('Outer-callback-1');
-      updates.push('Outer-setState-2');
-      instance.setState({x: 2}, function () {
-        updates.push('Outer-callback-2');
+    await act(() => {
+      updates.push('Outer-setState-1');
+      instance.setState({x: 1}, function () {
+        updates.push('Outer-callback-1');
+        updates.push('Outer-setState-2');
+        instance.setState({x: 2}, function () {
+          updates.push('Outer-callback-2');
+        });
       });
     });
 
@@ -686,7 +790,7 @@ describe('ReactUpdates', () => {
     /* eslint-enable indent */
   });
 
-  it('should flush updates in the correct order across roots', () => {
+  it('should flush updates in the correct order across roots', async () => {
     const instances = [];
     const updates = [];
 
@@ -699,22 +803,26 @@ describe('ReactUpdates', () => {
       componentDidMount() {
         instances.push(this);
         if (this.props.depth < this.props.count) {
-          ReactDOM.render(
+          const root = ReactDOMClient.createRoot(ReactDOM.findDOMNode(this));
+          root.render(
             <MockComponent
               depth={this.props.depth + 1}
               count={this.props.count}
             />,
-            ReactDOM.findDOMNode(this),
           );
         }
       }
     }
 
-    ReactTestUtils.renderIntoDocument(<MockComponent depth={0} count={2} />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<MockComponent depth={0} count={2} />);
+    });
 
     expect(updates).toEqual([0, 1, 2]);
 
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       // Simulate update on each component from top to bottom.
       instances.forEach(function (instance) {
         instance.forceUpdate();
@@ -777,7 +885,7 @@ describe('ReactUpdates', () => {
     expect(ReactDOM.findDOMNode(x).textContent).toBe('1');
   });
 
-  it('should queue updates from during mount', () => {
+  it('should queue updates from during mount', async () => {
     // See https://github.com/facebook/react/issues/1353
     let a;
 
@@ -803,8 +911,11 @@ describe('ReactUpdates', () => {
       }
     }
 
-    ReactDOM.unstable_batchedUpdates(function () {
-      ReactTestUtils.renderIntoDocument(
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    await act(() => {
+      root.render(
         <div>
           <A />
           <B />
@@ -812,13 +923,10 @@ describe('ReactUpdates', () => {
       );
     });
 
-    expect(a.state.x).toBe(1);
-    expect(ReactDOM.findDOMNode(a).textContent).toBe('A1');
+    expect(container.firstChild.textContent).toBe('A1');
   });
 
-  it('calls componentWillReceiveProps setState callback properly', () => {
-    let callbackCount = 0;
-
+  it('calls componentWillReceiveProps setState callback properly', async () => {
     class A extends React.Component {
       state = {x: this.props.x};
 
@@ -827,7 +935,7 @@ describe('ReactUpdates', () => {
         this.setState({x: newX}, function () {
           // State should have updated by the time this callback gets called
           expect(this.state.x).toBe(newX);
-          callbackCount++;
+          Scheduler.log('Callback');
         });
       }
 
@@ -837,13 +945,22 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    ReactDOM.render(<A x={1} />, container);
-    ReactDOM.render(<A x={2} />, container);
-    expect(callbackCount).toBe(1);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A x={1} />);
+    });
+    assertLog([]);
+
+    // Needs to be a separate act, or it will be batched.
+    await act(() => {
+      root.render(<A x={2} />);
+    });
+
+    assertLog(['Callback']);
   });
 
-  it('does not call render after a component as been deleted', () => {
-    let renderCount = 0;
+  it('does not call render after a component as been deleted', async () => {
+    let componentA = null;
     let componentB = null;
 
     class B extends React.Component {
@@ -854,7 +971,7 @@ describe('ReactUpdates', () => {
       }
 
       render() {
-        renderCount++;
+        Scheduler.log('B');
         return <div />;
       }
     }
@@ -862,21 +979,29 @@ describe('ReactUpdates', () => {
     class A extends React.Component {
       state = {showB: true};
 
+      componentDidMount() {
+        componentA = this;
+      }
       render() {
         return this.state.showB ? <B /> : <div />;
       }
     }
 
-    const component = ReactTestUtils.renderIntoDocument(<A />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A />);
+    });
+    assertLog(['B']);
 
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       // B will have scheduled an update but the batching should ensure that its
       // update never fires.
       componentB.setState({updates: 1});
-      component.setState({showB: false});
+      componentA.setState({showB: false});
     });
 
-    expect(renderCount).toBe(1);
+    assertLog([]);
   });
 
   it('throws in setState if the update callback is not a function', () => {
@@ -965,10 +1090,14 @@ describe('ReactUpdates', () => {
     );
   });
 
-  it('does not update one component twice in a batch (#2410)', () => {
+  it('does not update one component twice in a batch (#2410)', async () => {
+    let parent;
     class Parent extends React.Component {
       childRef = React.createRef();
 
+      componentDidMount() {
+        parent = this;
+      }
       getChild = () => {
         return this.childRef.current;
       };
@@ -1009,15 +1138,22 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const parent = ReactTestUtils.renderIntoDocument(<Parent />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+
     const child = parent.getChild();
-    ReactDOM.unstable_batchedUpdates(function () {
+    await act(() => {
       parent.forceUpdate();
       child.forceUpdate();
     });
+
+    expect.assertions(6);
   });
 
-  it('does not update one component twice in a batch (#6371)', () => {
+  it('does not update one component twice in a batch (#6371)', async () => {
     let callbacks = [];
     function emitChange() {
       callbacks.forEach(c => c());
@@ -1064,34 +1200,23 @@ describe('ReactUpdates', () => {
       }
     }
 
-    ReactDOM.render(<App />, document.createElement('div'));
-  });
-
-  it('unstable_batchedUpdates should return value from a callback', () => {
-    const result = ReactDOM.unstable_batchedUpdates(function () {
-      return 42;
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<App />);
     });
-    expect(result).toEqual(42);
-  });
 
-  it('unmounts and remounts a root in the same batch', () => {
-    const container = document.createElement('div');
-    ReactDOM.render(<span>a</span>, container);
-    ReactDOM.unstable_batchedUpdates(function () {
-      ReactDOM.unmountComponentAtNode(container);
-      ReactDOM.render(<span>b</span>, container);
-    });
-    expect(container.textContent).toBe('b');
+    // Error should not be thrown.
+    expect(true).toBe(true);
   });
 
-  it('handles reentrant mounting in synchronous mode', () => {
-    let mounts = 0;
+  it('handles reentrant mounting in synchronous mode', async () => {
+    let onChangeCalled = false;
     class Editor extends React.Component {
       render() {
         return <div>{this.props.text}</div>;
       }
       componentDidMount() {
-        mounts++;
+        Scheduler.log('Mount');
         // This should be called only once but we guard just in case.
         if (!this.props.rendered) {
           this.props.onChange({rendered: true});
@@ -1100,163 +1225,57 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     function render() {
-      ReactDOM.render(
+      root.render(
         <Editor
           onChange={newProps => {
+            onChangeCalled = true;
             props = {...props, ...newProps};
             render();
           }}
           {...props}
         />,
-        container,
       );
     }
 
     let props = {text: 'hello', rendered: false};
-    render();
+    await act(() => {
+      render();
+    });
+    assertLog(['Mount']);
     props = {...props, text: 'goodbye'};
-    render();
+    await act(() => {
+      render();
+    });
+
+    assertLog([]);
     expect(container.textContent).toBe('goodbye');
-    expect(mounts).toBe(1);
+    expect(onChangeCalled).toBeTruthy();
   });
 
-  it('mounts and unmounts are sync even in a batch', () => {
-    const ops = [];
+  it('mounts and unmounts are batched', async () => {
     const container = document.createElement('div');
-    ReactDOM.unstable_batchedUpdates(() => {
-      ReactDOM.render(<div>Hello</div>, container);
-      ops.push(container.textContent);
-      ReactDOM.unmountComponentAtNode(container);
-      ops.push(container.textContent);
-    });
-    expect(ops).toEqual(['Hello', '']);
-  });
-
-  it(
-    'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
-      'should both flush in the immediately subsequent commit',
-    () => {
-      const ops = [];
-      class Foo extends React.Component {
-        state = {a: false, b: false};
-        UNSAFE_componentWillUpdate(_, nextState) {
-          if (!nextState.a) {
-            this.setState({a: true});
-          }
-        }
-        componentDidUpdate() {
-          ops.push('Foo updated');
-          if (!this.state.b) {
-            this.setState({b: true});
-          }
-        }
-        render() {
-          ops.push(`a: ${this.state.a}, b: ${this.state.b}`);
-          return null;
-        }
-      }
-
-      const container = document.createElement('div');
-      // Mount
-      ReactDOM.render(<Foo />, container);
-      // Root update
-      ReactDOM.render(<Foo />, container);
-      expect(ops).toEqual([
-        // Mount
-        'a: false, b: false',
-        // Root update
-        'a: false, b: false',
-        'Foo updated',
-        // Subsequent update (both a and b should have flushed)
-        'a: true, b: true',
-        'Foo updated',
-        // There should not be any additional updates
-      ]);
-    },
-  );
-
-  it(
-    'in legacy mode, updates in componentWillUpdate and componentDidUpdate ' +
-      '(on a sibling) should both flush in the immediately subsequent commit',
-    () => {
-      const ops = [];
-      class Foo extends React.Component {
-        state = {a: false};
-        UNSAFE_componentWillUpdate(_, nextState) {
-          if (!nextState.a) {
-            this.setState({a: true});
-          }
-        }
-        componentDidUpdate() {
-          ops.push('Foo updated');
-        }
-        render() {
-          ops.push(`a: ${this.state.a}`);
-          return null;
-        }
-      }
+    const root = ReactDOMClient.createRoot(container);
 
-      class Bar extends React.Component {
-        state = {b: false};
-        componentDidUpdate() {
-          ops.push('Bar updated');
-          if (!this.state.b) {
-            this.setState({b: true});
-          }
-        }
-        render() {
-          ops.push(`b: ${this.state.b}`);
-          return null;
-        }
-      }
+    await act(() => {
+      root.render(<div>Hello</div>);
+      expect(container.textContent).toBe('');
+      root.unmount(container);
+      expect(container.textContent).toBe('');
+    });
 
-      const container = document.createElement('div');
-      // Mount
-      ReactDOM.render(
-        <div>
-          <Foo />
-          <Bar />
-        </div>,
-        container,
-      );
-      // Root update
-      ReactDOM.render(
-        <div>
-          <Foo />
-          <Bar />
-        </div>,
-        container,
-      );
-      expect(ops).toEqual([
-        // Mount
-        'a: false',
-        'b: false',
-        // Root update
-        'a: false',
-        'b: false',
-        'Foo updated',
-        'Bar updated',
-        // Subsequent update (both a and b should have flushed)
-        'a: true',
-        'b: true',
-        'Foo updated',
-        'Bar updated',
-        // There should not be any additional updates
-      ]);
-    },
-  );
-
-  it('uses correct base state for setState inside render phase', () => {
-    const ops = [];
+    expect(container.textContent).toBe('');
+  });
 
+  it('uses correct base state for setState inside render phase', async () => {
     class Foo extends React.Component {
       state = {step: 0};
       render() {
         const memoizedStep = this.state.step;
         this.setState(baseState => {
           const baseStep = baseState.step;
-          ops.push(`base: ${baseStep}, memoized: ${memoizedStep}`);
+          Scheduler.log(`base: ${baseStep}, memoized: ${memoizedStep}`);
           return baseStep === 0 ? {step: 1} : null;
         });
         return null;
@@ -1264,48 +1283,54 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    expect(() => ReactDOM.render(<Foo />, container)).toErrorDev(
-      'Cannot update during an existing state transition',
-    );
-    expect(ops).toEqual(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
+    const root = ReactDOMClient.createRoot(container);
+    await expect(async () => {
+      await act(() => {
+        root.render(<Foo />);
+      });
+    }).toErrorDev('Cannot update during an existing state transition');
+
+    assertLog(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
   });
 
-  it('does not re-render if state update is null', () => {
+  it('does not re-render if state update is null', async () => {
     const container = document.createElement('div');
 
     let instance;
-    let ops = [];
     class Foo extends React.Component {
       render() {
         instance = this;
-        ops.push('render');
+        Scheduler.log('render');
         return <div />;
       }
     }
-    ReactDOM.render(<Foo />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Foo />);
+    });
 
-    ops = [];
-    instance.setState(() => null);
-    expect(ops).toEqual([]);
+    assertLog(['render']);
+    await act(() => {
+      instance.setState(() => null);
+    });
+    assertLog([]);
   });
 
-  // Will change once we switch to async by default
-  it('synchronously renders hidden subtrees', () => {
+  it('synchronously renders hidden subtrees', async () => {
     const container = document.createElement('div');
-    let ops = [];
 
     function Baz() {
-      ops.push('Baz');
+      Scheduler.log('Baz');
       return null;
     }
 
     function Bar() {
-      ops.push('Bar');
+      Scheduler.log('Bar');
       return null;
     }
 
     function Foo() {
-      ops.push('Foo');
+      Scheduler.log('Foo');
       return (
         <div>
           <div hidden={true}>
@@ -1316,14 +1341,18 @@ describe('ReactUpdates', () => {
       );
     }
 
-    // Mount
-    ReactDOM.render(<Foo />, container);
-    expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
-    ops = [];
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      // Mount
+      root.render(<Foo />);
+    });
+    assertLog(['Foo', 'Bar', 'Baz']);
 
-    // Update
-    ReactDOM.render(<Foo />, container);
-    expect(ops).toEqual(['Foo', 'Bar', 'Baz']);
+    await act(() => {
+      // Update
+      root.render(<Foo />);
+    });
+    assertLog(['Foo', 'Bar', 'Baz']);
   });
 
   // @gate www
@@ -1383,18 +1412,33 @@ describe('ReactUpdates', () => {
     expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
   });
 
-  it('can render ridiculously large number of roots without triggering infinite update loop error', () => {
+  it('can render ridiculously large number of roots without triggering infinite update loop error', async () => {
+    function Component({trigger}) {
+      const [state, setState] = React.useState(0);
+
+      React.useEffect(() => {
+        if (trigger) {
+          Scheduler.log('Trigger');
+          setState(c => c + 1);
+        }
+      }, [trigger]);
+
+      return <div>{state}</div>;
+    }
+
     class Foo extends React.Component {
       componentDidMount() {
         const limit = 1200;
         for (let i = 0; i < limit; i++) {
           if (i < limit - 1) {
-            ReactDOM.render(<div />, document.createElement('div'));
+            ReactDOMClient.createRoot(document.createElement('div')).render(
+              <Component />,
+            );
           } else {
-            ReactDOM.render(<div />, document.createElement('div'), () => {
-              // The "nested update limit" error isn't thrown until setState
-              this.setState({});
-            });
+            // The "nested update limit" error isn't thrown until setState
+            ReactDOMClient.createRoot(document.createElement('div')).render(
+              <Component trigger={true} />,
+            );
           }
         }
       }
@@ -1403,11 +1447,16 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const container = document.createElement('div');
-    ReactDOM.render(<Foo />, container);
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Foo />);
+    });
+
+    // Make sure the setState trigger runs.
+    assertLog(['Trigger']);
   });
 
-  it('resets the update counter for unrelated updates', () => {
+  it('resets the update counter for unrelated updates', async () => {
     const container = document.createElement('div');
     const ref = React.createRef();
 
@@ -1427,22 +1476,35 @@ describe('ReactUpdates', () => {
     }
 
     let limit = 55;
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<EventuallyTerminating ref={ref} />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<EventuallyTerminating ref={ref} />);
+      });
     }).toThrow('Maximum');
 
     // Verify that we don't go over the limit if these updates are unrelated.
     limit -= 10;
-    ReactDOM.render(<EventuallyTerminating ref={ref} />, container);
+    await act(() => {
+      root.render(<EventuallyTerminating ref={ref} />);
+    });
     expect(container.textContent).toBe(limit.toString());
-    ref.current.setState({step: 0});
+
+    await act(() => {
+      ref.current.setState({step: 0});
+    });
     expect(container.textContent).toBe(limit.toString());
-    ref.current.setState({step: 0});
+
+    await act(() => {
+      ref.current.setState({step: 0});
+    });
     expect(container.textContent).toBe(limit.toString());
 
     limit += 10;
     expect(() => {
-      ref.current.setState({step: 0});
+      ReactDOM.flushSync(() => {
+        ref.current.setState({step: 0});
+      });
     }).toThrow('Maximum');
     expect(ref.current).toBe(null);
   });
@@ -1450,12 +1512,15 @@ describe('ReactUpdates', () => {
   it('does not fall into an infinite update loop', () => {
     class NonTerminating extends React.Component {
       state = {step: 0};
+
       componentDidMount() {
         this.setState({step: 1});
       }
-      UNSAFE_componentWillUpdate() {
+
+      componentDidUpdate() {
         this.setState({step: 2});
       }
+
       render() {
         return (
           <div>
@@ -1467,8 +1532,12 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
     expect(() => {
-      ReactDOM.render(<NonTerminating />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
     }).toThrow('Maximum');
   });
 
@@ -1482,12 +1551,15 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<NonTerminating />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
     }).toThrow('Maximum');
   });
 
-  it('can recover after falling into an infinite update loop', () => {
+  it('can recover after falling into an infinite update loop', async () => {
     class NonTerminating extends React.Component {
       state = {step: 0};
       componentDidMount() {
@@ -1512,27 +1584,36 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<NonTerminating />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
     }).toThrow('Maximum');
 
-    ReactDOM.render(<Terminating />, container);
+    await act(() => {
+      root.render(<Terminating />);
+    });
     expect(container.textContent).toBe('1');
 
     expect(() => {
-      ReactDOM.render(<NonTerminating />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
     }).toThrow('Maximum');
-
-    ReactDOM.render(<Terminating />, container);
+    await act(() => {
+      root.render(<Terminating />);
+    });
     expect(container.textContent).toBe('1');
   });
 
   it('does not fall into mutually recursive infinite update loop with same container', () => {
     // Note: this test would fail if there were two or more different roots.
-
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     class A extends React.Component {
       componentDidMount() {
-        ReactDOM.render(<B />, container);
+        root.render(<B />);
       }
       render() {
         return null;
@@ -1541,16 +1622,17 @@ describe('ReactUpdates', () => {
 
     class B extends React.Component {
       componentDidMount() {
-        ReactDOM.render(<A />, container);
+        root.render(<A />);
       }
       render() {
         return null;
       }
     }
 
-    const container = document.createElement('div');
     expect(() => {
-      ReactDOM.render(<A />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<A />);
+      });
     }).toThrow('Maximum');
   });
 
@@ -1582,14 +1664,17 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     expect(() => {
-      ReactDOM.render(<NonTerminating />, container);
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
     }).toThrow('Maximum');
   });
 
-  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', () => {
+  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
     const subscribers = [];
-
+    const limit = 1200;
     class Child extends React.Component {
       state = {value: 'initial'};
       componentDidMount() {
@@ -1603,7 +1688,7 @@ describe('ReactUpdates', () => {
     class App extends React.Component {
       render() {
         const children = [];
-        for (let i = 0; i < 1200; i++) {
+        for (let i = 0; i < limit; i++) {
           children.push(<Child key={i} />);
         }
         return children;
@@ -1611,13 +1696,18 @@ describe('ReactUpdates', () => {
     }
 
     const container = document.createElement('div');
-    ReactDOM.render(<App />, container);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<App />);
+    });
 
-    ReactDOM.unstable_batchedUpdates(() => {
+    await act(() => {
       subscribers.forEach(s => {
         s.setState({value: 'update'});
       });
     });
+
+    expect(subscribers.length).toBe(limit);
   });
 
   // TODO: Replace this branch with @gate pragmas
@@ -1673,8 +1763,9 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
       await act(() => {
-        ReactDOM.render(<Terminating />, container);
+        root.render(<Terminating />);
       });
       expect(container.textContent).toBe('50');
       await act(() => {
@@ -1696,8 +1787,9 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
       await act(() => {
-        ReactDOM.render(<Terminating />, container);
+        root.render(<Terminating />);
       });
 
       assertLog(['Done']);

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index b460e92476..cd37619374 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -21,7 +21,6 @@ let assertLog;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
-    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');

commit d8c1fa6b0b8da0512cb5acab9cd4f242451392f3
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Feb 9 11:14:37 2024 -0500

    Add infinite update loop detection (#28279)
    
    This is a partial redo of https://github.com/facebook/react/pull/26625.
    Since that was unlanded due to some detected breakages. This now
    includes a feature flag to be careful in rolling this out.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index cd37619374..cf6d0ccb9e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1709,6 +1709,70 @@ describe('ReactUpdates', () => {
     expect(subscribers.length).toBe(limit);
   });
 
+  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
+    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+      return;
+    }
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    expect(() => {
+      expect(() => ReactDOM.flushSync(() => root.render(<App />))).toThrow(
+        'Maximum update depth exceeded',
+      );
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
+  });
+
+  it("does not infinite loop if there's an async render phase update on another component", async () => {
+    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+      return;
+    }
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    await expect(async () => {
+      let error;
+      try {
+        await act(() => {
+          React.startTransition(() => root.render(<App />));
+        });
+      } catch (e) {
+        error = e;
+      }
+      expect(error.message).toMatch('Maximum update depth exceeded');
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
+  });
+
   // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
     it('warns about a deferred infinite update loop with useEffect', async () => {

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index cf6d0ccb9e..ea4d8480c7 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -21,6 +21,7 @@ let assertLog;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
+    jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');

commit 48ca0e82985a1f0cdd2787a281166a59af4b88d0
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Feb 20 16:52:11 2024 +0100

    Remove ReactTestUtils from ReactUpdates (#28378)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index ea4d8480c7..154772a168 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -12,7 +12,6 @@
 let React;
 let ReactDOM;
 let ReactDOMClient;
-let ReactTestUtils;
 let act;
 let Scheduler;
 let waitForAll;
@@ -25,7 +24,6 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    ReactTestUtils = require('react-dom/test-utils');
     act = require('internal-test-utils').act;
     Scheduler = require('scheduler');
 
@@ -832,7 +830,7 @@ describe('ReactUpdates', () => {
     expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
   });
 
-  it('should queue nested updates', () => {
+  it('should queue nested updates', async () => {
     // See https://github.com/facebook/react/issues/1147
 
     class X extends React.Component {
@@ -877,11 +875,25 @@ describe('ReactUpdates', () => {
       }
     }
 
-    const x = ReactTestUtils.renderIntoDocument(<X />);
-    const y = ReactTestUtils.renderIntoDocument(<Y />);
+    let container = document.createElement('div');
+    let root = ReactDOMClient.createRoot(container);
+    let x;
+    await act(() => {
+      root.render(<X ref={current => (x = current)} />);
+    });
+
+    container = document.createElement('div');
+    root = ReactDOMClient.createRoot(container);
+    let y;
+    await act(() => {
+      root.render(<Y ref={current => (y = current)} />);
+    });
+
     expect(ReactDOM.findDOMNode(x).textContent).toBe('0');
 
-    y.forceUpdate();
+    await act(() => {
+      y.forceUpdate();
+    });
     expect(ReactDOM.findDOMNode(x).textContent).toBe('1');
   });
 
@@ -1004,7 +1016,7 @@ describe('ReactUpdates', () => {
     assertLog([]);
   });
 
-  it('throws in setState if the update callback is not a function', () => {
+  it('throws in setState if the update callback is not a function', async () => {
     function Foo() {
       this.a = 1;
       this.b = 2;
@@ -1018,36 +1030,62 @@ describe('ReactUpdates', () => {
       }
     }
 
-    let component = ReactTestUtils.renderIntoDocument(<A />);
+    let container = document.createElement('div');
+    let root = ReactDOMClient.createRoot(container);
+    let component;
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
 
-    expect(() => {
-      expect(() => component.setState({}, 'no')).toErrorDev(
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.setState({}, 'no');
+        });
+      }).toErrorDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
-      );
-    }).toThrowError(
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => {
-      expect(() => component.setState({}, {foo: 'bar'})).toErrorDev(
+    container = document.createElement('div');
+    root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
+
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.setState({}, {foo: 'bar'});
+        });
+      }).toErrorDev(
         'setState(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
-      );
-    }).toThrowError(
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    // Make sure the warning is deduplicated and doesn't fire again
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.setState({}, new Foo())).toThrowError(
+    container = document.createElement('div');
+    root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
+
+    await expect(
+      act(() => {
+        component.setState({}, new Foo());
+      }),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
   });
 
-  it('throws in forceUpdate if the update callback is not a function', () => {
+  it('throws in forceUpdate if the update callback is not a function', async () => {
     function Foo() {
       this.a = 1;
       this.b = 2;
@@ -1061,30 +1099,57 @@ describe('ReactUpdates', () => {
       }
     }
 
-    let component = ReactTestUtils.renderIntoDocument(<A />);
+    let container = document.createElement('div');
+    let root = ReactDOMClient.createRoot(container);
+    let component;
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
 
-    expect(() => {
-      expect(() => component.forceUpdate('no')).toErrorDev(
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.forceUpdate('no');
+        });
+      }).toErrorDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
-      );
-    }).toThrowError(
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => {
-      expect(() => component.forceUpdate({foo: 'bar'})).toErrorDev(
+    container = document.createElement('div');
+    root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
+
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.forceUpdate({foo: 'bar'});
+        });
+      }).toErrorDev(
         'forceUpdate(...): Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
-      );
-    }).toThrowError(
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
     // Make sure the warning is deduplicated and doesn't fire again
-    component = ReactTestUtils.renderIntoDocument(<A />);
-    expect(() => component.forceUpdate(new Foo())).toThrowError(
+    container = document.createElement('div');
+    root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A ref={current => (component = current)} />);
+    });
+
+    await expect(
+      act(() => {
+        component.forceUpdate(new Foo());
+      }),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );

commit d579e7748218920331252b0528850943d5e2dd31
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Fri Feb 23 15:16:54 2024 -0500

    Remove method name prefix from warnings and errors (#28432)
    
    This pattern is a petpeeve of mine. I don't consider this best practice
    and so most don't have these prefixes. Very inconsistent.
    
    At best this is useless and noisey that you have to parse because the
    information is also in the stack trace.
    
    At worse these are misleading because they're highlighting something
    internal (like validateDOMNesting) which even suggests an internal bug.
    Even the ones public to React aren't necessarily what you called because
    you might be calling a wrapper around it.
    
    That would be properly reflected in a stack trace - which can also
    properly ignore list so that the first stack you see is your callsite,
    
    Which might be like `render()` in react-testing-library rather than
    `createRoot()` for example.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 154772a168..fb0c73fd25 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1043,7 +1043,7 @@ describe('ReactUpdates', () => {
           component.setState({}, 'no');
         });
       }).toErrorDev(
-        'setState(...): Expected the last optional `callback` argument to be ' +
+        'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       ),
     ).rejects.toThrowError(
@@ -1062,7 +1062,7 @@ describe('ReactUpdates', () => {
           component.setState({}, {foo: 'bar'});
         });
       }).toErrorDev(
-        'setState(...): Expected the last optional `callback` argument to be ' +
+        'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       ),
     ).rejects.toThrowError(
@@ -1112,7 +1112,7 @@ describe('ReactUpdates', () => {
           component.forceUpdate('no');
         });
       }).toErrorDev(
-        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+        'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
       ),
     ).rejects.toThrowError(
@@ -1131,7 +1131,7 @@ describe('ReactUpdates', () => {
           component.forceUpdate({foo: 'bar'});
         });
       }).toErrorDev(
-        'forceUpdate(...): Expected the last optional `callback` argument to be ' +
+        'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: [object Object].',
       ),
     ).rejects.toThrowError(

commit 6786563f3cbbc9b16d5a8187207b5bd904386e53
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 26 20:44:07 2024 -0700

    [Fiber] Don't Rethrow Errors at the Root (#28627)
    
    Stacked on top of #28498 for test fixes.
    
    ### Don't Rethrow
    
    When we started React it was 1:1 setState calls a series of renders and
    if they error, it errors where the setState was called. Simple. However,
    then batching came and the error actually got thrown somewhere else.
    With concurrent mode, it's not even possible to get setState itself to
    throw anymore.
    
    In fact, all APIs that can rethrow out of React are executed either at
    the root of the scheduler or inside a DOM event handler.
    If you throw inside a React.startTransition callback that's sync, then
    that will bubble out of the startTransition but if you throw inside an
    async callback or a useTransition we now need to handle it at the hook
    site. So in 19 we need to make all React.startTransition swallow the
    error (and report them to reportError).
    
    The only one remaining that can throw is flushSync but it doesn't really
    make sense for it to throw at the callsite neither because batching.
    Just because something rendered in this flush doesn't mean it was
    rendered due to what was just scheduled and doesn't mean that it should
    abort any of the remaining code afterwards. setState is fire and forget.
    It's send an instruction elsewhere, it's not part of the current
    imperative code.
    
    Error boundaries never rethrow. Since you should really always have
    error boundaries, most of the time, it wouldn't rethrow anyway.
    
    Rethrowing also actually currently drops errors on the floor since we
    can only rethrow the first error, so to avoid that we'd need to call
    reportError anyway. This happens in RN events.
    
    The other issue with rethrowing is that it logs an extra console.error.
    Since we're not sure that user code will actually log it anywhere we
    still log it too just like we do with errors inside error boundaries
    which leads all of these to log twice.
    The goal of this PR is to never rethrow out of React instead, errors
    outside of error boundaries get logged to reportError. Event system
    errors too.
    
    ### Breaking Changes
    
    The main thing this affects is testing where you want to inspect the
    errors thrown. To make it easier to port, if you're inside `act` we
    track the error into act in an aggregate error and then rethrow it at
    the root of `act`. Unlike before though, if you flush synchronously
    inside of act it'll still continue until the end of act before
    rethrowing.
    
    I expect most user code breakages would be to migrate from `flushSync`
    to `act` if you assert on throwing.
    
    However, in the React repo we also have `internalAct` and the
    `waitForThrow` helpers. Since these have to use public production
    implementations we track these using the global onerror or process
    uncaughtException. Unlike regular act, includes both event handler
    errors and onRecoverableError by default too. Not just render/commit
    errors. So I had to account for that in our tests.
    
    We restore logging an extra log for uncaught errors after the main log
    with the component stack in it. We use `console.warn`. This is not yet
    ignorable if you preventDefault to the main error event. To avoid
    confusion if you don't end up logging the error to console I just added
    `An error occurred`.
    
    ### Polyfill
    
    All browsers we support really supports `reportError` but not all test
    and server environments do, so I implemented a polyfill for browser and
    node in `shared/reportGlobalError`. I don't love that this is included
    in all builds and gets duplicated into isomorphic even though it's not
    actually needed in production. Maybe in the future we can require a
    polyfill for this.
    
    ### Follow Ups
    
    In a follow up, I'll make caught vs uncaught error handling be
    configurable too.
    
    ---------
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index fb0c73fd25..82d1955c0e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1542,11 +1542,11 @@ describe('ReactUpdates', () => {
 
     let limit = 55;
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<EventuallyTerminating ref={ref} />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
 
     // Verify that we don't go over the limit if these updates are unrelated.
     limit -= 10;
@@ -1566,15 +1566,15 @@ describe('ReactUpdates', () => {
     expect(container.textContent).toBe(limit.toString());
 
     limit += 10;
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         ref.current.setState({step: 0});
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
     expect(ref.current).toBe(null);
   });
 
-  it('does not fall into an infinite update loop', () => {
+  it('does not fall into an infinite update loop', async () => {
     class NonTerminating extends React.Component {
       state = {step: 0};
 
@@ -1599,14 +1599,14 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<NonTerminating />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
   });
 
-  it('does not fall into an infinite update loop with useLayoutEffect', () => {
+  it('does not fall into an infinite update loop with useLayoutEffect', async () => {
     function NonTerminating() {
       const [step, setStep] = React.useState(0);
       React.useLayoutEffect(() => {
@@ -1617,11 +1617,11 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<NonTerminating />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
   });
 
   it('can recover after falling into an infinite update loop', async () => {
@@ -1650,29 +1650,29 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<NonTerminating />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
 
     await act(() => {
       root.render(<Terminating />);
     });
     expect(container.textContent).toBe('1');
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<NonTerminating />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
     await act(() => {
       root.render(<Terminating />);
     });
     expect(container.textContent).toBe('1');
   });
 
-  it('does not fall into mutually recursive infinite update loop with same container', () => {
+  it('does not fall into mutually recursive infinite update loop with same container', async () => {
     // Note: this test would fail if there were two or more different roots.
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
@@ -1694,14 +1694,14 @@ describe('ReactUpdates', () => {
       }
     }
 
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<A />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
   });
 
-  it('does not fall into an infinite error loop', () => {
+  it('does not fall into an infinite error loop', async () => {
     function BadRender() {
       throw new Error('error');
     }
@@ -1730,11 +1730,11 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
+    await expect(async () => {
+      await act(() => {
         root.render(<NonTerminating />);
       });
-    }).toThrow('Maximum');
+    }).rejects.toThrow('Maximum');
   });
 
   it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
@@ -1775,7 +1775,7 @@ describe('ReactUpdates', () => {
     expect(subscribers.length).toBe(limit);
   });
 
-  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
+  it("does not infinite loop if there's a synchronous render phase update on another component", async () => {
     if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
       return;
     }
@@ -1795,10 +1795,10 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
 
-    expect(() => {
-      expect(() => ReactDOM.flushSync(() => root.render(<App />))).toThrow(
-        'Maximum update depth exceeded',
-      );
+    await expect(async () => {
+      await expect(async () => {
+        await act(() => ReactDOM.flushSync(() => root.render(<App />)));
+      }).rejects.toThrow('Maximum update depth exceeded');
     }).toErrorDev(
       'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
     );
@@ -1926,7 +1926,7 @@ describe('ReactUpdates', () => {
     });
   }
 
-  it('prevents infinite update loop triggered by synchronous updates in useEffect', () => {
+  it('prevents infinite update loop triggered by synchronous updates in useEffect', async () => {
     // Ignore flushSync warning
     spyOnDev(console, 'error').mockImplementation(() => {});
 
@@ -1950,10 +1950,12 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    expect(() => {
-      ReactDOM.flushSync(() => {
-        root.render(<NonTerminating />);
+    await expect(async () => {
+      await act(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<NonTerminating />);
+        });
       });
-    }).toThrow('Maximum update depth exceeded');
+    }).rejects.toThrow('Maximum update depth exceeded');
   });
 });

commit 9ad40b1440a2c0b61530f3710e5dae3847611b9c
Author: Josh Story <story@hey.com>
Date:   Wed Mar 27 14:43:12 2024 -0700

    [react-dom] Remove `findDOMNode` from OSS builds (#28267)
    
    In the next major `findDOMNode` is being removed. This PR removes the
    API from the react-dom entrypoints for OSS builds and re-exposes the
    implementation as part of internals.
    
    `findDOMNode` is being retained for Meta builds and so all tests that
    currently use it will continue to do so by accessing it from internals.
    Once the replacement API ships in an upcoming minor any tests that were
    using this API incidentally can be updated to use the new API and any
    tests asserting `findDOMNode`'s behavior directly can stick around until
    we remove it entirely (once Meta has moved away from it)

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 82d1955c0e..d4acfaa9b3 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -11,6 +11,7 @@
 
 let React;
 let ReactDOM;
+let findDOMNode;
 let ReactDOMClient;
 let act;
 let Scheduler;
@@ -23,6 +24,8 @@ describe('ReactUpdates', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
+    findDOMNode =
+      ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.findDOMNode;
     ReactDOMClient = require('react-dom/client');
     act = require('internal-test-utils').act;
     Scheduler = require('scheduler');
@@ -659,7 +662,7 @@ describe('ReactUpdates', () => {
         a = this;
       }
       componentDidUpdate() {
-        expect(ReactDOM.findDOMNode(b).textContent).toBe('B1');
+        expect(findDOMNode(b).textContent).toBe('B1');
         aUpdated = true;
       }
 
@@ -801,7 +804,7 @@ describe('ReactUpdates', () => {
       componentDidMount() {
         instances.push(this);
         if (this.props.depth < this.props.count) {
-          const root = ReactDOMClient.createRoot(ReactDOM.findDOMNode(this));
+          const root = ReactDOMClient.createRoot(findDOMNode(this));
           root.render(
             <MockComponent
               depth={this.props.depth + 1}
@@ -889,12 +892,12 @@ describe('ReactUpdates', () => {
       root.render(<Y ref={current => (y = current)} />);
     });
 
-    expect(ReactDOM.findDOMNode(x).textContent).toBe('0');
+    expect(findDOMNode(x).textContent).toBe('0');
 
     await act(() => {
       y.forceUpdate();
     });
-    expect(ReactDOM.findDOMNode(x).textContent).toBe('1');
+    expect(findDOMNode(x).textContent).toBe('1');
   });
 
   it('should queue updates from during mount', async () => {

commit f6131653570bbbf62d642ba9343b9cd0ab1ae97c
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Apr 9 12:20:22 2024 -0400

    Rename SECRET INTERNALS to `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE` (#28789)
    
    Follow up to #28783 and #28786.
    
    Since we've changed the implementations of these we can rename them to
    something a bit more descriptive while we're at it, since anyone
    depending on them will need to upgrade their code anyway.
    
    "react" with no condition:
    `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react" with "react-server" condition:
    `__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react-dom":
    `__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index d4acfaa9b3..d2a02f7956 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -25,7 +25,8 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     findDOMNode =
-      ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.findDOMNode;
+      ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
+        .findDOMNode;
     ReactDOMClient = require('react-dom/client');
     act = require('internal-test-utils').act;
     Scheduler = require('scheduler');

commit 6e1e2f2198b9c1f9259417cb569d92206ccf55f5
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Apr 10 10:34:11 2024 -0400

    [tests] assertLog before act in ReactUpdates (#28760)
    
    Fixes tests blocking https://github.com/facebook/react/pull/28737

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index d2a02f7956..322907635d 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1900,6 +1900,8 @@ describe('ReactUpdates', () => {
       await act(() => {
         root.render(<Terminating />);
       });
+
+      assertLog(Array.from({length: LIMIT + 1}, (_, k) => k));
       expect(container.textContent).toBe('50');
       await act(() => {
         _setStep(0);

commit cb151849e13f46ec64570519cb93d5939fb60cab
Author: Josh Story <story@hey.com>
Date:   Wed Apr 24 08:50:32 2024 -0700

    [react-dom] move all client code to `react-dom/client` (#28271)
    
    This PR reorganizes the `react-dom` entrypoint to only pull in code that
    is environment agnostic. Previously if you required anything from this
    entrypoint in any environment the entire client reconciler was loaded.
    In a prior release we added a server rendering stub which you could
    alias in server environments to omit this unecessary code. After landing
    this change this entrypoint should not load any environment specific
    code.
    
    While a few APIs are truly client (browser) only such as createRoot and
    hydrateRoot many of the APIs you import from this package are only
    useful in the browser but could concievably be imported in shared code
    (components running in Fizz or shared components as part of an RSC app).
    To avoid making these require opting into the client bundle we are
    keeping them in the `react-dom` entrypoint and changing their
    implementation so that in environments where they are not particularly
    useful they do something benign and expected.
    
    #### Removed APIs
    The following APIs are being removed in the next major. Largely they
    have all been deprecated already and are part of legacy rendering modes
    where concurrent features of React are not available
    * `render`
    * `hydrate`
    * `findDOMNode`
    * `unmountComponentAtNode`
    * `unstable_createEventHandle`
    * `unstable_renderSubtreeIntoContainer`
    * `unstable_runWithPrioirty`
    
    #### moved Client APIs
    These APIs were available on both `react-dom` (with a warning) and
    `react-dom/client`. After this change they are only available on
    `react-dom/client`
    * `createRoot`
    * `hydrateRoot`
    
    #### retained APIs
    These APIs still exist on the `react-dom` entrypoint but have normalized
    behavior depending on which renderers are currently in scope
    * `flushSync`: will execute the function (if provided) inside the
    flushSync implemention of FlightServer, Fizz, and Fiber DOM renderers.
    * `unstable_batchedUpdates`: This is a noop in concurrent mode because
    it is now the only supported behavior because there is no legacy
    rendering mode
    * `createPortal`: This just produces an object. It can be called from
    anywhere but since you will probably not have a handle on a DOM node to
    pass to it it will likely warn in environments other than the browser
    * preloading APIS such as `preload`: These methods will execute the
    preload across all renderers currently in scope. Since we resolve the
    Request object on the server using AsyncLocalStorage or the current
    function stack in practice only one renderer should act upon the
    preload.
    
    In addition to these changes the server rendering stub now just rexports
    everything from `react-dom`. In a future minor we will add a warning
    when using the stub and in the next major we will remove the stub
    altogether

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 322907635d..9a10a8d061 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -24,10 +24,10 @@ describe('ReactUpdates', () => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
     findDOMNode =
       ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
         .findDOMNode;
-    ReactDOMClient = require('react-dom/client');
     act = require('internal-test-utils').act;
     Scheduler = require('scheduler');
 

commit d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Sat May 25 11:58:17 2024 -0400

    [Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)
    
    This one should be fully behind the `enableOwnerStacks` flag.
    
    Instead of printing the parent Component stack all the way to the root,
    this now prints the owner stack of every JSX callsite. It also includes
    intermediate callsites between the Component and the JSX call so it has
    potentially more frames. Mainly it provides the line number of the JSX
    callsite. In terms of the number of components is a subset of the parent
    component stack so it's less information in that regard. This is usually
    better since it's more focused on components that might affect the
    output but if it's contextual based on rendering it's still good to have
    parent stack. Therefore, I still use the parent stack when printing DOM
    nesting warnings but I plan on switching that format to a diff view
    format instead (Next.js already reformats the parent stack like this).
    
    __Follow ups__
    
    - Server Components show up in the owner stack for client logs but logs
    done by Server Components don't yet get their owner stack printed as
    they're replayed. They're also not yet printed in the server logs of the
    RSC server.
    
    - Server Component stack frames are formatted as the server and added to
    the end but this might be a different format than the browser. E.g. if
    server is running V8 and browser is running JSC or vice versa. Ideally
    we can reformat them in terms of the client formatting.
    
    - This doesn't yet update Fizz or DevTools. Those will be follow ups.
    Fizz still prints parent stacks in the server side logs. The stacks
    added to user space `console.error` calls by DevTools still get the
    parent stacks instead.
    
    - It also doesn't yet expose these to user space so there's no way to
    get them inside `onCaughtError` for example or inside a custom
    `console.error` override.
    
    - In another follow up I'll use `console.createTask` instead and
    completely remove these stacks if it's available.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 9a10a8d061..1c40e72a78 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1848,7 +1848,7 @@ describe('ReactUpdates', () => {
     it('warns about a deferred infinite update loop with useEffect', async () => {
       function NonTerminating() {
         const [step, setStep] = React.useState(0);
-        React.useEffect(() => {
+        React.useEffect(function myEffect() {
           setStep(x => x + 1);
         });
         return step;
@@ -1860,10 +1860,12 @@ describe('ReactUpdates', () => {
 
       let error = null;
       let stack = null;
+      let nativeStack = null;
       const originalConsoleError = console.error;
       console.error = (e, s) => {
         error = e;
         stack = s;
+        nativeStack = new Error().stack;
         Scheduler.log('stop');
       };
       try {
@@ -1876,7 +1878,14 @@ describe('ReactUpdates', () => {
       }
 
       expect(error).toContain('Maximum update depth exceeded');
-      expect(stack).toContain('at NonTerminating');
+      // The currently executing effect should be on the native stack
+      expect(nativeStack).toContain('at myEffect');
+      if (!gate(flags => flags.enableOwnerStacks)) {
+        // The currently running component's name is not in the owner
+        // stack because it's just its JSX callsite.
+        expect(stack).toContain('at NonTerminating');
+      }
+      expect(stack).toContain('at App');
     });
 
     it('can have nested updates if they do not cross the limit', async () => {

commit 277420803947724b43c47bbc47d3a353553868f1
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Jun 10 18:41:56 2024 -0400

    Remove Warning: prefix and toString on console Arguments (#29839)
    
    Basically make `console.error` and `console.warn` behave like normal -
    when a component stack isn't appended. I need this because I need to be
    able to print rich logs with the component stack option and to be able
    to disable instrumentation completely in `console.createTask`
    environments that don't need it.
    
    Currently we can't print logs with richer objects because they're
    toString:ed first. In practice, pretty much all arguments we log are
    already toString:ed so it's not necessary anyway. Some might be like a
    number. So it would only be a problem if some environment can't handle
    proper consoles but then it's up to that environment to toString it
    before logging.
    
    The `Warning: ` prefix is historic and is both noisy and confusing. It's
    mostly unnecessary since the UI surrounding `console.error` and
    `console.warn` tend to have visual treatment around it anyway. However,
    it's actively misleading when `console.error` gets prefixed with a
    Warning that we consider an error level. There's an argument to be made
    that some of our `console.error` don't make the bar for an error but
    then the argument is to downgrade each of those to `console.warn` - not
    to brand all our actual error logging with `Warning: `.
    
    Apparently something needs to change in React Native before landing this
    because it depends on the prefix somehow which probably doesn't make
    sense already.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 1c40e72a78..a0c46a01d4 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1804,7 +1804,7 @@ describe('ReactUpdates', () => {
         await act(() => ReactDOM.flushSync(() => root.render(<App />)));
       }).rejects.toThrow('Maximum update depth exceeded');
     }).toErrorDev(
-      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+      'Cannot update a component (`App`) while rendering a different component (`Child`)',
     );
   });
 
@@ -1839,7 +1839,7 @@ describe('ReactUpdates', () => {
       }
       expect(error.message).toMatch('Maximum update depth exceeded');
     }).toErrorDev(
-      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+      'Cannot update a component (`App`) while rendering a different component (`Child`)',
     );
   });
 

commit b565373afd0cc1988497e1107106e851e8cfb261
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Jun 21 12:24:32 2024 -0400

    lint: enable reportUnusedDisableDirectives and remove unused suppressions (#28721)
    
    This enables linting against unused suppressions and removes the ones
    that were unused.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index a0c46a01d4..1d71c71476 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -760,7 +760,6 @@ describe('ReactUpdates', () => {
       });
     });
 
-    /* eslint-disable indent */
     expect(updates).toEqual([
       'Outer-render-0',
       'Inner-render-0-0',
@@ -789,7 +788,6 @@ describe('ReactUpdates', () => {
       'Inner-didUpdate-2-2',
       'Inner-callback-2',
     ]);
-    /* eslint-enable indent */
   });
 
   it('should flush updates in the correct order across roots', async () => {

commit 400e82227747f6b60fecbc3b43f7515b4fd89d8c
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Fri Jul 12 13:02:22 2024 -0400

    Remove Component Stack from React Logged Warnings and Error Reporting (#30308)
    
    React transpiles some of its own `console.error` calls into a helper
    that appends component stacks to those calls. However, this doesn't
    cover user space `console.error` calls - which includes React helpers
    that React has moved into third parties like createClass and prop-types.
    
    The idea is that any user space component can add a warning just like
    React can which is why React DevTools adds them too if they don't
    already exist. Having them appended in both places is tricky because now
    you have to know whether to remove them from React's logs.
    
    Similarly it's often common for server-side frameworks to forget to
    cover the `console.error` logs from other sources since React DevTools
    isn't active there. However, it's also annoying to get component stacks
    clogging the terminal - depending on where the log came from.
    
    In the future `console.createTask()` will cover this use case natively
    and when available we don't append them at all.
    
    The new strategy relies on either:
    
    - React DevTools existing to add them to React logs as well as third
    parties.
    - `console.createTask` being supported and surfaced.
    - A third party framework showing the component stack either in an Error
    Dialog or appended to terminal output.
    
    For a third party to be able to implement this they need to be able to
    get the component stack. To get the component stack from within a
    `console.error` call you need to use the `React.captureOwnerStack()`
    helper which is only available in `enableOwnerStacks` flag. However,
    it's possible to polyfill with parent stacks using internals as a stop
    gap. There's a question of whether React 19 should just go out with
    `enableOwnerStacks` to expose this but regardless I think it's best it
    doesn't include component stacks from the runtime for consistency.
    
    In practice it's not really a regression though because typically either
    of the other options exists and error dialogs don't implement
    `console.error` overrides anyway yet. SSR terminals might miss them but
    they'd only have them in DEV warnings to begin with an a subset of React
    warnings. Typically those are either going to happen on the client
    anyway or replayed.
    
    Our tests are written to assert that component stacks work in various
    scenarios all over the place. To ensure that this keeps working I
    implement a "polyfill" that is similar to that expected a server
    framework might do - in `assertConsoleErrorDev` and `toErrorDev`.
    
    This PR doesn't yet change www or RN since they have their own forks of
    consoleWithStackDev for now.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 1d71c71476..4916a72129 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1857,12 +1857,14 @@ describe('ReactUpdates', () => {
       }
 
       let error = null;
-      let stack = null;
+      let ownerStack = null;
       let nativeStack = null;
       const originalConsoleError = console.error;
-      console.error = (e, s) => {
+      console.error = e => {
         error = e;
-        stack = s;
+        ownerStack = gate(flags => flags.enableOwnerStacks)
+          ? React.captureOwnerStack()
+          : null;
         nativeStack = new Error().stack;
         Scheduler.log('stop');
       };
@@ -1878,12 +1880,11 @@ describe('ReactUpdates', () => {
       expect(error).toContain('Maximum update depth exceeded');
       // The currently executing effect should be on the native stack
       expect(nativeStack).toContain('at myEffect');
-      if (!gate(flags => flags.enableOwnerStacks)) {
-        // The currently running component's name is not in the owner
-        // stack because it's just its JSX callsite.
-        expect(stack).toContain('at NonTerminating');
+      if (gate(flags => flags.enableOwnerStacks)) {
+        expect(ownerStack).toContain('at App');
+      } else {
+        expect(ownerStack).toBe(null);
       }
-      expect(stack).toContain('at App');
     });
 
     it('can have nested updates if they do not cross the limit', async () => {

commit b15c1983dcf96f19400b0ca7337be1e1fb1a8717
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Jul 22 11:03:15 2024 -0400

    [Flight] Normalize Stack Using Fake Evals (#30401)
    
    Stacked on https://github.com/facebook/react/pull/30400 and
    https://github.com/facebook/react/pull/30369
    
    Previously we were using fake evals to recreate a stack for console
    replaying and thrown errors. However, for owner stacks we just used the
    raw string that came from the server.
    
    This means that the format of the owner stack could include different
    formats. Like Spidermonkey format for the client components and V8 for
    the server components. This means that this stack can't be parsed
    natively by the browser like when printing them as error like in
    https://github.com/facebook/react/pull/30289. Additionally, since
    there's no source file registered with that name and no source mapping
    url, it can't be source mapped.
    
    Before:
    
    <img width="1329" alt="before-firefox"
    src="https://github.com/user-attachments/assets/cbe03f9c-96ac-48fb-b58f-f3a224a774f4">
    
    Instead, we need to create a fake stack like we do for the other things.
    That way when it's printed as an Error it gets source mapped. It also
    means that the format is consistently in the native format of the
    current browser.
    
    After:
    
    <img width="753" alt="after-firefox"
    src="https://github.com/user-attachments/assets/b436f1f5-ca37-4203-b29f-df9828c9fad3">
    
    So this is nice because you can just take the result from
    `captureOwnerStack()` and append it to an `Error` stack and print it
    natively. E.g. this is what React DevTools will do.
    
    If you want to parse and present it yourself though it's a bit awkward
    though. The `captureOwnerStack()` API now includes a bunch of
    `rsc://React/` URLs. These don't really have any direct connection to
    the source map. Only the browser knows this connection from the eval.
    You basically have to strip the prefix and then manually pass the
    remainder to your own `findSourceMapURL`.
    
    Another awkward part is that since Safari doesn't support eval sourceURL
    exposed into `error.stack` - it means that `captureOwnerStack()` get an
    empty location for server components since the fake eval doesn't work
    there. That's not a big deal since these stacks are already broken even
    for client modules for many because the `eval-source-map` strategy in
    Webpack doesn't work in Safari for this same reason.
    
    A lot of this refactoring is just clarifying that there's three kind of
    ReactComponentInfo fields:
    
    - `stack` - The raw stack as described on the original server.
    - `debugStack` - The Error object containing the stack as represented in
    the current client as fake evals.
    - `debugTask` - The same thing as `debugStack` but described in terms of
    a native `console.createTask`.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 4916a72129..faf4b29551 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1858,14 +1858,14 @@ describe('ReactUpdates', () => {
 
       let error = null;
       let ownerStack = null;
-      let nativeStack = null;
+      let debugStack = null;
       const originalConsoleError = console.error;
       console.error = e => {
         error = e;
         ownerStack = gate(flags => flags.enableOwnerStacks)
           ? React.captureOwnerStack()
           : null;
-        nativeStack = new Error().stack;
+        debugStack = new Error().stack;
         Scheduler.log('stop');
       };
       try {
@@ -1879,7 +1879,7 @@ describe('ReactUpdates', () => {
 
       expect(error).toContain('Maximum update depth exceeded');
       // The currently executing effect should be on the native stack
-      expect(nativeStack).toContain('at myEffect');
+      expect(debugStack).toContain('at myEffect');
       if (gate(flags => flags.enableOwnerStacks)) {
         expect(ownerStack).toContain('at App');
       } else {

commit f9ebd85a196948be17efdd6774b4d0464b3b1f53
Author: Jack Pope <jackpope1@gmail.com>
Date:   Wed Sep 25 11:50:41 2024 -0400

    Increase nested update limit to 100 (#31061)
    
    We're seeing the limit hit in some tests after enabling sibling
    prerendering. Let's bump the limit so we can run more tests and gather
    more signal on the changes. When we understand the scope of the problem
    we can determine whether we need to change how the updates are counted
    in prerenders and/or fix specific areas of product code.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index faf4b29551..247a53531c 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1542,7 +1542,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    let limit = 55;
+    let limit = 105;
     const root = ReactDOMClient.createRoot(container);
     await expect(async () => {
       await act(() => {

commit d8c90fa48d3addefe4b805ec56a3c65e4ee39127
Author: Jack Pope <jackpope1@gmail.com>
Date:   Tue Oct 1 11:00:57 2024 -0400

    Disable infinite render loop detection (#31088)
    
    We're seeing issues with this feature internally including bugs with
    sibling prerendering and errors that are difficult for developers to
    action on. We'll turn off the feature for the time being until we can
    improve the stability and ergonomics.
    
    This PR does two things:
    - Turn off `enableInfiniteLoopDetection` everywhere while leaving it as
    a variant on www so we can do further experimentation.
    - Revert https://github.com/facebook/react/pull/31061 which was a
    temporary change for debugging. This brings the feature back to
    baseline.

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index 247a53531c..faf4b29551 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1542,7 +1542,7 @@ describe('ReactUpdates', () => {
       }
     }
 
-    let limit = 105;
+    let limit = 55;
     const root = ReactDOMClient.createRoot(container);
     await expect(async () => {
       await act(() => {

commit 03e4ec2d0fe7cd854d28634ba035dc8996ff244d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Jan 5 17:10:29 2025 -0500

    [assert helpers] react-dom (pt3) (#31983)
    
    moar assert helpers
    
    this finishes all of react-dom except the server integration tests which
    are tricky to convert

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index faf4b29551..fa1900002a 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -18,6 +18,7 @@ let Scheduler;
 let waitForAll;
 let waitFor;
 let assertLog;
+let assertConsoleErrorDev;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
@@ -29,6 +30,8 @@ describe('ReactUpdates', () => {
       ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
         .findDOMNode;
     act = require('internal-test-utils').act;
+    assertConsoleErrorDev =
+      require('internal-test-utils').assertConsoleErrorDev;
     Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');
@@ -1039,38 +1042,42 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(
-      expect(async () => {
-        await act(() => {
-          component.setState({}, 'no');
-        });
-      }).toErrorDev(
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ),
-    ).rejects.toThrowError(
+    await expect(async () => {
+      await act(() => {
+        component.setState({}, 'no');
+      });
+    }).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
+    assertConsoleErrorDev(
+      [
+        'Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: no.',
+      ],
+      {withoutStack: true},
+    );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
     await act(() => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(
-      expect(async () => {
-        await act(() => {
-          component.setState({}, {foo: 'bar'});
-        });
-      }).toErrorDev(
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: [object Object].',
-      ),
-    ).rejects.toThrowError(
+    await expect(async () => {
+      await act(() => {
+        component.setState({}, {foo: 'bar'});
+      });
+    }).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
+    assertConsoleErrorDev(
+      [
+        'Expected the last optional `callback` argument to be ' +
+          "a function. Instead received: { foo: 'bar' }.",
+      ],
+      {withoutStack: true},
+    );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
     await act(() => {
@@ -1108,38 +1115,42 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(
-      expect(async () => {
-        await act(() => {
-          component.forceUpdate('no');
-        });
-      }).toErrorDev(
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ),
-    ).rejects.toThrowError(
+    await expect(async () => {
+      await act(() => {
+        component.forceUpdate('no');
+      });
+    }).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: no',
     );
+    assertConsoleErrorDev(
+      [
+        'Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: no.',
+      ],
+      {withoutStack: true},
+    );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
     await act(() => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(
-      expect(async () => {
-        await act(() => {
-          component.forceUpdate({foo: 'bar'});
-        });
-      }).toErrorDev(
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: [object Object].',
-      ),
-    ).rejects.toThrowError(
+    await expect(async () => {
+      await act(() => {
+        component.forceUpdate({foo: 'bar'});
+      });
+    }).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
+    assertConsoleErrorDev(
+      [
+        'Expected the last optional `callback` argument to be ' +
+          "a function. Instead received: { foo: 'bar' }.",
+      ],
+      {withoutStack: true},
+    );
     // Make sure the warning is deduplicated and doesn't fire again
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
@@ -1351,11 +1362,14 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<Foo />);
-      });
-    }).toErrorDev('Cannot update during an existing state transition');
+    await act(() => {
+      root.render(<Foo />);
+    });
+    assertConsoleErrorDev([
+      'Cannot update during an existing state transition (such as within `render`). ' +
+        'Render methods should be a pure function of props and state.\n' +
+        '    in Foo (at **)',
+    ]);
 
     assertLog(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
   });
@@ -1798,12 +1812,14 @@ describe('ReactUpdates', () => {
     const root = ReactDOMClient.createRoot(container);
 
     await expect(async () => {
-      await expect(async () => {
-        await act(() => ReactDOM.flushSync(() => root.render(<App />)));
-      }).rejects.toThrow('Maximum update depth exceeded');
-    }).toErrorDev(
-      'Cannot update a component (`App`) while rendering a different component (`Child`)',
-    );
+      await act(() => ReactDOM.flushSync(() => root.render(<App />)));
+    }).rejects.toThrow('Maximum update depth exceeded');
+    assertConsoleErrorDev([
+      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
+        'To locate the bad setState() call inside `Child`, ' +
+        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
+        '    in App (at **)',
+    ]);
   });
 
   it("does not infinite loop if there's an async render phase update on another component", async () => {
@@ -1827,18 +1843,17 @@ describe('ReactUpdates', () => {
     const root = ReactDOMClient.createRoot(container);
 
     await expect(async () => {
-      let error;
-      try {
-        await act(() => {
-          React.startTransition(() => root.render(<App />));
-        });
-      } catch (e) {
-        error = e;
-      }
-      expect(error.message).toMatch('Maximum update depth exceeded');
-    }).toErrorDev(
-      'Cannot update a component (`App`) while rendering a different component (`Child`)',
-    );
+      await act(() => {
+        React.startTransition(() => root.render(<App />));
+      });
+    }).rejects.toThrow('Maximum update depth exceeded');
+
+    assertConsoleErrorDev([
+      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
+        'To locate the bad setState() call inside `Child`, ' +
+        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
+        '    in App (at **)',
+    ]);
   });
 
   // TODO: Replace this branch with @gate pragmas

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react-dom/src/__tests__/ReactUpdates-test.js b/packages/react-dom/src/__tests__/ReactUpdates-test.js
index fa1900002a..bc7767b12e 100644
--- a/packages/react-dom/src/__tests__/ReactUpdates-test.js
+++ b/packages/react-dom/src/__tests__/ReactUpdates-test.js
@@ -1877,9 +1877,7 @@ describe('ReactUpdates', () => {
       const originalConsoleError = console.error;
       console.error = e => {
         error = e;
-        ownerStack = gate(flags => flags.enableOwnerStacks)
-          ? React.captureOwnerStack()
-          : null;
+        ownerStack = React.captureOwnerStack();
         debugStack = new Error().stack;
         Scheduler.log('stop');
       };
@@ -1895,11 +1893,7 @@ describe('ReactUpdates', () => {
       expect(error).toContain('Maximum update depth exceeded');
       // The currently executing effect should be on the native stack
       expect(debugStack).toContain('at myEffect');
-      if (gate(flags => flags.enableOwnerStacks)) {
-        expect(ownerStack).toContain('at App');
-      } else {
-        expect(ownerStack).toBe(null);
-      }
+      expect(ownerStack).toContain('at App');
     });
 
     it('can have nested updates if they do not cross the limit', async () => {

