# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/segment_constructor/segment_builder.rs

commit 398da04aad196c6a40ba35ac004a4f3a6a256d5e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 30 01:54:55 2021 +0200

    add indexing optimizer + enable mmap and structure index rebuilding + fix issues

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
new file mode 100644
index 000000000..5520dff4c
--- /dev/null
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -0,0 +1,61 @@
+use crate::segment::Segment;
+use crate::entry::entry_point::{OperationResult, SegmentEntry, OperationError};
+use core::cmp;
+use crate::types::PayloadKeyType;
+use std::collections::HashSet;
+use std::convert::TryInto;
+
+/// Structure for constructing segment out of several other segments
+pub struct SegmentBuilder {
+    pub segment: Segment,
+    pub indexed_fields: HashSet<PayloadKeyType>
+}
+
+impl SegmentBuilder {
+
+    pub fn new(segment: Segment) -> Self {
+        SegmentBuilder {
+            segment,
+            indexed_fields: Default::default()
+        }
+    }
+
+    /// Update current segment builder with all (not deleted) vectors and payload form `other` segment
+    /// Perform index building at the end of update
+    pub fn update_from(&mut self, other: &Segment) -> OperationResult<()> {
+        self.segment.version = cmp::max(self.segment.version, other.version());
+
+        let other_id_mapper = other.id_mapper.borrow();
+        let other_vector_storage = other.vector_storage.borrow();
+        let other_payload_storage = other.payload_storage.borrow();
+
+        let new_internal_range = self.segment.vector_storage.borrow_mut().update_from(&*other_vector_storage)?;
+
+        let mut id_mapper = self.segment.id_mapper.borrow_mut();
+        let mut payload_storage = self.segment.payload_storage.borrow_mut();
+
+        for (new_internal_id, old_internal_id) in new_internal_range.zip(other.vector_storage.borrow().iter_ids()) {
+            let other_external_id = other_id_mapper.external_id(old_internal_id).unwrap();
+            id_mapper.set_link(other_external_id, new_internal_id)?;
+            payload_storage.assign_all(new_internal_id, other_payload_storage.payload(old_internal_id))?;
+        }
+
+        for field in other.payload_index.borrow().indexed_fields().into_iter() {
+            self.indexed_fields.insert(field);
+        }
+
+        Ok(())
+    }
+}
+
+impl TryInto<Segment> for SegmentBuilder {
+    type Error = OperationError;
+
+    fn try_into(mut self) -> Result<Segment, Self::Error> {
+        for field in self.indexed_fields.iter() {
+            self.segment.create_field_index(self.segment.version, field)?;
+        }
+        self.segment.query_planner.borrow_mut().build_index()?;
+        Ok(self.segment)
+    }
+}
\ No newline at end of file

commit e0636b492065b1c94604216be55bb3a97da0078e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 30 18:50:13 2021 +0200

    optimized segment building in a separate directory

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 5520dff4c..bc13ee3c7 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,50 +1,69 @@
 use crate::segment::Segment;
 use crate::entry::entry_point::{OperationResult, SegmentEntry, OperationError};
 use core::cmp;
-use crate::types::PayloadKeyType;
+use crate::types::{PayloadKeyType, SegmentConfig};
 use std::collections::HashSet;
 use std::convert::TryInto;
+use crate::segment_constructor::segment_constructor::{build_segment, load_segment};
+use std::path::{Path, PathBuf};
+use std::fs;
+use crate::common::error_logging::LogError;
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
-    pub segment: Segment,
-    pub indexed_fields: HashSet<PayloadKeyType>
+    pub segment: Option<Segment>,
+    pub destination_path: PathBuf,
+    pub temp_path: PathBuf,
+    pub indexed_fields: HashSet<PayloadKeyType>,
 }
 
 impl SegmentBuilder {
+    pub fn new(segment_path: &Path, temp_dir: &Path, segment_config: &SegmentConfig) -> OperationResult<Self> {
+        let segment = build_segment(temp_dir, segment_config)?;
+        let temp_path = segment.current_path.clone();
 
-    pub fn new(segment: Segment) -> Self {
-        SegmentBuilder {
-            segment,
-            indexed_fields: Default::default()
-        }
+        let destination_path = segment_path.join(temp_path.file_name().unwrap());
+
+        Ok(SegmentBuilder {
+            segment: Some(segment),
+            destination_path,
+            temp_path,
+            indexed_fields: Default::default(),
+        })
     }
 
     /// Update current segment builder with all (not deleted) vectors and payload form `other` segment
     /// Perform index building at the end of update
     pub fn update_from(&mut self, other: &Segment) -> OperationResult<()> {
-        self.segment.version = cmp::max(self.segment.version, other.version());
+        match &mut self.segment {
+            None => Err(OperationError::ServiceError {
+                description: "Segment building error: created segment not found".to_owned()
+            }),
+            Some(self_segment) => {
+                self_segment.version = cmp::max(self_segment.version, other.version());
 
-        let other_id_mapper = other.id_mapper.borrow();
-        let other_vector_storage = other.vector_storage.borrow();
-        let other_payload_storage = other.payload_storage.borrow();
+                let other_id_mapper = other.id_mapper.borrow();
+                let other_vector_storage = other.vector_storage.borrow();
+                let other_payload_storage = other.payload_storage.borrow();
 
-        let new_internal_range = self.segment.vector_storage.borrow_mut().update_from(&*other_vector_storage)?;
+                let new_internal_range = self_segment.vector_storage.borrow_mut().update_from(&*other_vector_storage)?;
 
-        let mut id_mapper = self.segment.id_mapper.borrow_mut();
-        let mut payload_storage = self.segment.payload_storage.borrow_mut();
+                let mut id_mapper = self_segment.id_mapper.borrow_mut();
+                let mut payload_storage = self_segment.payload_storage.borrow_mut();
 
-        for (new_internal_id, old_internal_id) in new_internal_range.zip(other.vector_storage.borrow().iter_ids()) {
-            let other_external_id = other_id_mapper.external_id(old_internal_id).unwrap();
-            id_mapper.set_link(other_external_id, new_internal_id)?;
-            payload_storage.assign_all(new_internal_id, other_payload_storage.payload(old_internal_id))?;
-        }
+                for (new_internal_id, old_internal_id) in new_internal_range.zip(other.vector_storage.borrow().iter_ids()) {
+                    let other_external_id = other_id_mapper.external_id(old_internal_id).unwrap();
+                    id_mapper.set_link(other_external_id, new_internal_id)?;
+                    payload_storage.assign_all(new_internal_id, other_payload_storage.payload(old_internal_id))?;
+                }
 
-        for field in other.payload_index.borrow().indexed_fields().into_iter() {
-            self.indexed_fields.insert(field);
-        }
+                for field in other.payload_index.borrow().indexed_fields().into_iter() {
+                    self.indexed_fields.insert(field);
+                }
 
-        Ok(())
+                Ok(())
+            }
+        }
     }
 }
 
@@ -52,10 +71,25 @@ impl TryInto<Segment> for SegmentBuilder {
     type Error = OperationError;
 
     fn try_into(mut self) -> Result<Segment, Self::Error> {
-        for field in self.indexed_fields.iter() {
-            self.segment.create_field_index(self.segment.version, field)?;
+        {
+            let mut segment = self.segment.ok_or(OperationError::ServiceError {
+                description: "Segment building error: created segment not found".to_owned()
+            })?;
+            self.segment = None;
+
+            for field in self.indexed_fields.iter() {
+                segment.create_field_index(segment.version, field)?;
+            }
+
+            segment.query_planner.borrow_mut().build_index()?;
+
+            segment.flush()?;
+            // Now segment is going to be evicted from RAM
         }
-        self.segment.query_planner.borrow_mut().build_index()?;
-        Ok(self.segment)
+
+        // Move fully constructed segment into collection directory and load back to RAM
+        fs::rename(&self.temp_path, &self.destination_path).describe("Moving segment data after optimization")?;
+
+        load_segment(&self.destination_path)
     }
 }
\ No newline at end of file

commit 3616631300ab6d2b2a2cefb002ff567448710e06
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun May 30 17:14:42 2021 +0200

    Filtrable hnsw (#26)
    
    * raw points scorer
    
    * raw point scorer for memmap storage
    
    * search interface prepare
    
    * graph binary saving + store PointOffsetId as u32
    
    * WIP: entry points
    
    * connect new link method
    
    * update libs + search layer method + visited list + search context + update rust
    
    * implement Euclid metric + always use MinHeap for priority queue
    
    * small refactor
    
    * search for 0 level entry
    
    * update visited pool to be lock free and thread safe
    
    * use ef_construct from graph layer struct + limit visited links to M
    
    * add metric pre-processing before on vector upsert
    
    * old hnsw heuristic
    
    * save hnsw graph for export
    
    * search method + tests
    
    * small fixes
    
    * add benchmark and profiler
    
    * build time optimizations
    
    * use SeaHash
    
    * remove unsed benchmark
    
    * merge hnsw graph function
    
    * WIP:HNSW index build function
    
    * HNSW build_index with additional indexing
    
    * refactor fixtures
    
    * graph save and load test
    
    * test and fixes for filterable HNSW
    
    * enable hnsw index for query planning
    
    * fix cardinality estimation tests + remove query planner as class
    
    * small refactor
    
    * store full copy of collection settings with collection + allow partial override on creation #16
    
    * API for updating collection parameters #16
    
    * refactor: move collection error -> types
    
    * report collection status in info API #17
    
    * update OpenAPI Schema

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index bc13ee3c7..03beca067 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -81,7 +81,7 @@ impl TryInto<Segment> for SegmentBuilder {
                 segment.create_field_index(segment.version, field)?;
             }
 
-            segment.query_planner.borrow_mut().build_index()?;
+            segment.vector_index.borrow_mut().build_index()?;
 
             segment.flush()?;
             // Now segment is going to be evicted from RAM

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 03beca067..3ee6aa357 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,13 +1,13 @@
+use crate::common::error_logging::LogError;
+use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
 use crate::segment::Segment;
-use crate::entry::entry_point::{OperationResult, SegmentEntry, OperationError};
-use core::cmp;
+use crate::segment_constructor::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, SegmentConfig};
+use core::cmp;
 use std::collections::HashSet;
 use std::convert::TryInto;
-use crate::segment_constructor::segment_constructor::{build_segment, load_segment};
-use std::path::{Path, PathBuf};
 use std::fs;
-use crate::common::error_logging::LogError;
+use std::path::{Path, PathBuf};
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
@@ -18,7 +18,11 @@ pub struct SegmentBuilder {
 }
 
 impl SegmentBuilder {
-    pub fn new(segment_path: &Path, temp_dir: &Path, segment_config: &SegmentConfig) -> OperationResult<Self> {
+    pub fn new(
+        segment_path: &Path,
+        temp_dir: &Path,
+        segment_config: &SegmentConfig,
+    ) -> OperationResult<Self> {
         let segment = build_segment(temp_dir, segment_config)?;
         let temp_path = segment.current_path.clone();
 
@@ -37,7 +41,7 @@ impl SegmentBuilder {
     pub fn update_from(&mut self, other: &Segment) -> OperationResult<()> {
         match &mut self.segment {
             None => Err(OperationError::ServiceError {
-                description: "Segment building error: created segment not found".to_owned()
+                description: "Segment building error: created segment not found".to_owned(),
             }),
             Some(self_segment) => {
                 self_segment.version = cmp::max(self_segment.version, other.version());
@@ -46,15 +50,23 @@ impl SegmentBuilder {
                 let other_vector_storage = other.vector_storage.borrow();
                 let other_payload_storage = other.payload_storage.borrow();
 
-                let new_internal_range = self_segment.vector_storage.borrow_mut().update_from(&*other_vector_storage)?;
+                let new_internal_range = self_segment
+                    .vector_storage
+                    .borrow_mut()
+                    .update_from(&*other_vector_storage)?;
 
                 let mut id_mapper = self_segment.id_mapper.borrow_mut();
                 let mut payload_storage = self_segment.payload_storage.borrow_mut();
 
-                for (new_internal_id, old_internal_id) in new_internal_range.zip(other.vector_storage.borrow().iter_ids()) {
+                for (new_internal_id, old_internal_id) in
+                    new_internal_range.zip(other.vector_storage.borrow().iter_ids())
+                {
                     let other_external_id = other_id_mapper.external_id(old_internal_id).unwrap();
                     id_mapper.set_link(other_external_id, new_internal_id)?;
-                    payload_storage.assign_all(new_internal_id, other_payload_storage.payload(old_internal_id))?;
+                    payload_storage.assign_all(
+                        new_internal_id,
+                        other_payload_storage.payload(old_internal_id),
+                    )?;
                 }
 
                 for field in other.payload_index.borrow().indexed_fields().into_iter() {
@@ -73,7 +85,7 @@ impl TryInto<Segment> for SegmentBuilder {
     fn try_into(mut self) -> Result<Segment, Self::Error> {
         {
             let mut segment = self.segment.ok_or(OperationError::ServiceError {
-                description: "Segment building error: created segment not found".to_owned()
+                description: "Segment building error: created segment not found".to_owned(),
             })?;
             self.segment = None;
 
@@ -88,8 +100,9 @@ impl TryInto<Segment> for SegmentBuilder {
         }
 
         // Move fully constructed segment into collection directory and load back to RAM
-        fs::rename(&self.temp_path, &self.destination_path).describe("Moving segment data after optimization")?;
+        fs::rename(&self.temp_path, &self.destination_path)
+            .describe("Moving segment data after optimization")?;
 
         load_segment(&self.destination_path)
     }
-}
\ No newline at end of file
+}

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 3ee6aa357..35d28cce0 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,7 +1,7 @@
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
 use crate::segment::Segment;
-use crate::segment_constructor::segment_constructor::{build_segment, load_segment};
+use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, SegmentConfig};
 use core::cmp;
 use std::collections::HashSet;

commit bf3d8c25753188b4ca5e69a13c7f26e3c383f05b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Oct 24 18:10:39 2021 +0200

    data consistency fixes and updates (#112)
    
    * update segment version after completed update only
    
    * more stable updates: check pre-existing points on update, fail recovery, WAL proper ack. check_unprocessed_points WIP
    
    * switch to async channel
    
    * perform update operations in a separate thread (#111)
    
    * perform update operations in a separate thread
    
    * ordered sending update signal
    
    * locate a segment merging versioning bug
    
    * rename id_mapper -> id_tracker
    
    * per-record versioning
    
    * clippy fixes
    
    * cargo fmt
    
    * rm limit of open files
    
    * fail recovery test
    
    * cargo fmt
    
    * wait for worker stops befor dropping the runtime

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 35d28cce0..ba4b322b9 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -44,29 +44,54 @@ impl SegmentBuilder {
                 description: "Segment building error: created segment not found".to_owned(),
             }),
             Some(self_segment) => {
-                self_segment.version = cmp::max(self_segment.version, other.version());
+                self_segment.version = cmp::max(self_segment.version(), other.version());
 
-                let other_id_mapper = other.id_mapper.borrow();
+                let other_id_tracker = other.id_tracker.borrow();
                 let other_vector_storage = other.vector_storage.borrow();
                 let other_payload_storage = other.payload_storage.borrow();
 
-                let new_internal_range = self_segment
-                    .vector_storage
-                    .borrow_mut()
-                    .update_from(&*other_vector_storage)?;
-
-                let mut id_mapper = self_segment.id_mapper.borrow_mut();
+                let mut id_tracker = self_segment.id_tracker.borrow_mut();
+                let mut vector_storage = self_segment.vector_storage.borrow_mut();
                 let mut payload_storage = self_segment.payload_storage.borrow_mut();
 
+                let new_internal_range = vector_storage.update_from(&*other_vector_storage)?;
+
                 for (new_internal_id, old_internal_id) in
-                    new_internal_range.zip(other.vector_storage.borrow().iter_ids())
+                    new_internal_range.zip(other_vector_storage.iter_ids())
                 {
-                    let other_external_id = other_id_mapper.external_id(old_internal_id).unwrap();
-                    id_mapper.set_link(other_external_id, new_internal_id)?;
-                    payload_storage.assign_all(
-                        new_internal_id,
-                        other_payload_storage.payload(old_internal_id),
-                    )?;
+                    let external_id = other_id_tracker.external_id(old_internal_id).unwrap();
+                    let other_version = other_id_tracker.version(external_id).unwrap();
+
+                    match id_tracker.version(external_id) {
+                        None => {
+                            // New point, just insert
+                            id_tracker.set_link(external_id, new_internal_id)?;
+                            id_tracker.set_version(external_id, other_version)?;
+                            payload_storage.assign_all(
+                                new_internal_id,
+                                other_payload_storage.payload(old_internal_id),
+                            )?;
+                        }
+                        Some(existing_version) => {
+                            if existing_version < other_version {
+                                // Other version is the newest, remove the existing one and replace
+                                let existing_internal_id =
+                                    id_tracker.internal_id(external_id).unwrap();
+                                vector_storage.delete(existing_internal_id)?;
+                                id_tracker.drop(external_id)?;
+                                id_tracker.set_link(external_id, new_internal_id)?;
+                                id_tracker.set_version(external_id, other_version)?;
+                                payload_storage.assign_all(
+                                    new_internal_id,
+                                    other_payload_storage.payload(old_internal_id),
+                                )?;
+                            } else {
+                                // Old version is still good, do not move anything else
+                                // Mark newly added vector as removed
+                                vector_storage.delete(new_internal_id)?;
+                            };
+                        }
+                    }
                 }
 
                 for field in other.payload_index.borrow().indexed_fields().into_iter() {
@@ -90,7 +115,7 @@ impl TryInto<Segment> for SegmentBuilder {
             self.segment = None;
 
             for field in self.indexed_fields.iter() {
-                segment.create_field_index(segment.version, field)?;
+                segment.create_field_index(segment.version(), field)?;
             }
 
             segment.vector_index.borrow_mut().build_index()?;

commit e196ce025bcbb1aad04c892205fe07deaa519f7a
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:21 2022 +0400

    fix clippy warnings (#175)
    
    * fix clippy warnings
    
    - doc links
    - explicit deref
    - if instead of match for single bool condition
    - combine similar match branches
    
    * revert removal of transmute
    
    * return Some when vec is not empty

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index ba4b322b9..62444c291 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -94,7 +94,7 @@ impl SegmentBuilder {
                     }
                 }
 
-                for field in other.payload_index.borrow().indexed_fields().into_iter() {
+                for field in other.payload_index.borrow().indexed_fields() {
                     self.indexed_fields.insert(field);
                 }
 
@@ -114,7 +114,7 @@ impl TryInto<Segment> for SegmentBuilder {
             })?;
             self.segment = None;
 
-            for field in self.indexed_fields.iter() {
+            for field in &self.indexed_fields {
                 segment.create_field_index(segment.version(), field)?;
             }
 

commit 0f91c9a5e29ef9065c79a20e0ace25be898beff8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jan 18 15:06:42 2022 +0100

    [WIP] Force optimization stop #31 (#161)
    
    * implement checking stop-flag in the optimization routine
    
    * wip: optimization cancel test
    
    * force optimization stop during the construction of vector index
    
    * fix clippy

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 62444c291..0fb2ab463 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -5,9 +5,9 @@ use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, SegmentConfig};
 use core::cmp;
 use std::collections::HashSet;
-use std::convert::TryInto;
 use std::fs;
 use std::path::{Path, PathBuf};
+use std::sync::atomic::{AtomicBool, Ordering};
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
@@ -38,7 +38,16 @@ impl SegmentBuilder {
 
     /// Update current segment builder with all (not deleted) vectors and payload form `other` segment
     /// Perform index building at the end of update
-    pub fn update_from(&mut self, other: &Segment) -> OperationResult<()> {
+    ///
+    /// # Arguments
+    ///
+    /// * `other` - segment to add into construction
+    ///
+    /// # Result
+    ///
+    /// * `bool` - if `true` - data successfully added, if `false` - process was interrupted
+    ///
+    pub fn update_from(&mut self, other: &Segment, stopped: &AtomicBool) -> OperationResult<bool> {
         match &mut self.segment {
             None => Err(OperationError::ServiceError {
                 description: "Segment building error: created segment not found".to_owned(),
@@ -59,6 +68,11 @@ impl SegmentBuilder {
                 for (new_internal_id, old_internal_id) in
                     new_internal_range.zip(other_vector_storage.iter_ids())
                 {
+                    if stopped.load(Ordering::Relaxed) {
+                        return Err(OperationError::Cancelled {
+                            description: "Cancelled by external thread".to_string(),
+                        });
+                    }
                     let external_id = other_id_tracker.external_id(old_internal_id).unwrap();
                     let other_version = other_id_tracker.version(external_id).unwrap();
 
@@ -98,16 +112,12 @@ impl SegmentBuilder {
                     self.indexed_fields.insert(field);
                 }
 
-                Ok(())
+                Ok(true)
             }
         }
     }
-}
 
-impl TryInto<Segment> for SegmentBuilder {
-    type Error = OperationError;
-
-    fn try_into(mut self) -> Result<Segment, Self::Error> {
+    pub fn build(mut self, stopped: &AtomicBool) -> Result<Segment, OperationError> {
         {
             let mut segment = self.segment.ok_or(OperationError::ServiceError {
                 description: "Segment building error: created segment not found".to_owned(),
@@ -116,9 +126,14 @@ impl TryInto<Segment> for SegmentBuilder {
 
             for field in &self.indexed_fields {
                 segment.create_field_index(segment.version(), field)?;
+                if stopped.load(Ordering::Relaxed) {
+                    return Err(OperationError::Cancelled {
+                        description: "Cancelled by external thread".to_string(),
+                    });
+                }
             }
 
-            segment.vector_index.borrow_mut().build_index()?;
+            segment.vector_index.borrow_mut().build_index(stopped)?;
 
             segment.flush()?;
             // Now segment is going to be evicted from RAM

commit 4483ea0d60bb4cf97df1267de6299556674d83fa
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Wed Feb 9 11:46:01 2022 -0300

    fix: #101 Payload type consistency is not enforced.

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0fb2ab463..c1b9969cd 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,5 +1,6 @@
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
+use crate::payload_storage::schema_storage::SchemaStorage;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, SegmentConfig};
@@ -8,6 +9,7 @@ use std::collections::HashSet;
 use std::fs;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::{AtomicBool, Ordering};
+use std::sync::Arc;
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
@@ -15,6 +17,7 @@ pub struct SegmentBuilder {
     pub destination_path: PathBuf,
     pub temp_path: PathBuf,
     pub indexed_fields: HashSet<PayloadKeyType>,
+    pub schema_store: Arc<SchemaStorage>,
 }
 
 impl SegmentBuilder {
@@ -22,8 +25,9 @@ impl SegmentBuilder {
         segment_path: &Path,
         temp_dir: &Path,
         segment_config: &SegmentConfig,
+        schema_store: Arc<SchemaStorage>,
     ) -> OperationResult<Self> {
-        let segment = build_segment(temp_dir, segment_config)?;
+        let segment = build_segment(temp_dir, segment_config, schema_store.clone())?;
         let temp_path = segment.current_path.clone();
 
         let destination_path = segment_path.join(temp_path.file_name().unwrap());
@@ -33,6 +37,7 @@ impl SegmentBuilder {
             destination_path,
             temp_path,
             indexed_fields: Default::default(),
+            schema_store,
         })
     }
 
@@ -143,6 +148,6 @@ impl SegmentBuilder {
         fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
-        load_segment(&self.destination_path)
+        load_segment(&self.destination_path, self.schema_store.clone())
     }
 }

commit e45379e4384062e92ee1c9be82c250047464c9ef
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 16 09:59:11 2022 +0100

    Better optimizer error reporting + small bug fixes (#316)
    
    * optimizer error reporting, decouple data removing, optimizator fix
    
    * fmt
    
    * fmt + clippy
    
    * update openapi

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index c1b9969cd..09cd69da3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -54,9 +54,9 @@ impl SegmentBuilder {
     ///
     pub fn update_from(&mut self, other: &Segment, stopped: &AtomicBool) -> OperationResult<bool> {
         match &mut self.segment {
-            None => Err(OperationError::ServiceError {
-                description: "Segment building error: created segment not found".to_owned(),
-            }),
+            None => Err(OperationError::service_error(
+                "Segment building error: created segment not found",
+            )),
             Some(self_segment) => {
                 self_segment.version = cmp::max(self_segment.version(), other.version());
 
@@ -124,8 +124,8 @@ impl SegmentBuilder {
 
     pub fn build(mut self, stopped: &AtomicBool) -> Result<Segment, OperationError> {
         {
-            let mut segment = self.segment.ok_or(OperationError::ServiceError {
-                description: "Segment building error: created segment not found".to_owned(),
+            let mut segment = self.segment.ok_or_else(|| {
+                OperationError::service_error("Segment building error: created segment not found")
             })?;
             self.segment = None;
 

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 09cd69da3..9a4bb6ab9 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,23 +1,20 @@
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
-use crate::payload_storage::schema_storage::SchemaStorage;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
-use crate::types::{PayloadKeyType, SegmentConfig};
+use crate::types::{PayloadKeyType, PayloadSchemaType, SegmentConfig};
 use core::cmp;
-use std::collections::HashSet;
+use std::collections::HashMap;
 use std::fs;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::{AtomicBool, Ordering};
-use std::sync::Arc;
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
     pub segment: Option<Segment>,
     pub destination_path: PathBuf,
     pub temp_path: PathBuf,
-    pub indexed_fields: HashSet<PayloadKeyType>,
-    pub schema_store: Arc<SchemaStorage>,
+    pub indexed_fields: HashMap<PayloadKeyType, PayloadSchemaType>,
 }
 
 impl SegmentBuilder {
@@ -25,9 +22,8 @@ impl SegmentBuilder {
         segment_path: &Path,
         temp_dir: &Path,
         segment_config: &SegmentConfig,
-        schema_store: Arc<SchemaStorage>,
     ) -> OperationResult<Self> {
-        let segment = build_segment(temp_dir, segment_config, schema_store.clone())?;
+        let segment = build_segment(temp_dir, segment_config)?;
         let temp_path = segment.current_path.clone();
 
         let destination_path = segment_path.join(temp_path.file_name().unwrap());
@@ -37,7 +33,6 @@ impl SegmentBuilder {
             destination_path,
             temp_path,
             indexed_fields: Default::default(),
-            schema_store,
         })
     }
 
@@ -86,9 +81,9 @@ impl SegmentBuilder {
                             // New point, just insert
                             id_tracker.set_link(external_id, new_internal_id)?;
                             id_tracker.set_version(external_id, other_version)?;
-                            payload_storage.assign_all(
+                            payload_storage.assign(
                                 new_internal_id,
-                                other_payload_storage.payload(old_internal_id),
+                                &other_payload_storage.payload(old_internal_id),
                             )?;
                         }
                         Some(existing_version) => {
@@ -100,9 +95,9 @@ impl SegmentBuilder {
                                 id_tracker.drop(external_id)?;
                                 id_tracker.set_link(external_id, new_internal_id)?;
                                 id_tracker.set_version(external_id, other_version)?;
-                                payload_storage.assign_all(
+                                payload_storage.assign(
                                     new_internal_id,
-                                    other_payload_storage.payload(old_internal_id),
+                                    &other_payload_storage.payload(old_internal_id),
                                 )?;
                             } else {
                                 // Old version is still good, do not move anything else
@@ -113,8 +108,8 @@ impl SegmentBuilder {
                     }
                 }
 
-                for field in other.payload_index.borrow().indexed_fields() {
-                    self.indexed_fields.insert(field);
+                for (field, payload_schema) in other.payload_index.borrow().indexed_fields() {
+                    self.indexed_fields.insert(field, payload_schema);
                 }
 
                 Ok(true)
@@ -129,8 +124,8 @@ impl SegmentBuilder {
             })?;
             self.segment = None;
 
-            for field in &self.indexed_fields {
-                segment.create_field_index(segment.version(), field)?;
+            for (field, payload_schema) in &self.indexed_fields {
+                segment.create_field_index(segment.version(), field, &Some(*payload_schema))?;
                 if stopped.load(Ordering::Relaxed) {
                     return Err(OperationError::Cancelled {
                         description: "Cancelled by external thread".to_string(),
@@ -148,6 +143,6 @@ impl SegmentBuilder {
         fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
-        load_segment(&self.destination_path, self.schema_store.clone())
+        load_segment(&self.destination_path)
     }
 }

commit bc6df8bd12327ea3a88aecf94a0a2a26b3b70506
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 19 16:04:55 2022 +0200

    Better use of column index (#461)
    
    * fmt
    
    * remove redundent condition checker
    
    * remove condition_checker from test
    
    * fmt
    
    * enum_dispatch for payload storage
    
    * rm unused imports
    
    * fmt
    
    * replace enum_dispatch with manual stuff
    
    * fmt
    
    * filter optiizer
    
    * cargo fix
    
    * fmt
    
    * refactor callback approach to payload checking
    
    * cargo fix
    
    * cargo fix
    
    * fix
    
    * fmt
    
    * more filtering condition random fixture types
    
    * clippy
    
    * fmt
    
    * restore lost value counts test
    
    * Update lib/segment/src/index/query_optimization/optimized_filter.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 9a4bb6ab9..df224f924 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,5 +1,6 @@
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
+use crate::payload_storage::PayloadStorage;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, PayloadSchemaType, SegmentConfig};

commit 1b458780eb196ebbbd7fb1f6c5d85ce3b15adb64
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 1 17:23:34 2022 +0200

    On disk payload storage (#634)
    
    * implement on-disk payload storage
    
    * fmt + clippy
    
    * config param for on-disk payload storage
    
    * upd openapi definitions
    
    * add integration test with on-disk payload
    
    * fix clippy
    
    * review fixes
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index df224f924..cc35dd8ed 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -84,7 +84,7 @@ impl SegmentBuilder {
                             id_tracker.set_version(external_id, other_version)?;
                             payload_storage.assign(
                                 new_internal_id,
-                                &other_payload_storage.payload(old_internal_id),
+                                &other_payload_storage.payload(old_internal_id)?,
                             )?;
                         }
                         Some(existing_version) => {
@@ -98,7 +98,7 @@ impl SegmentBuilder {
                                 id_tracker.set_version(external_id, other_version)?;
                                 payload_storage.assign(
                                     new_internal_id,
-                                    &other_payload_storage.payload(old_internal_id),
+                                    &other_payload_storage.payload(old_internal_id)?,
                                 )?;
                             } else {
                                 // Old version is still good, do not move anything else

commit c15981092ac33c7dde9541ab4a2df558e6abe4e6
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Jun 6 12:14:20 2022 -0300

    [WIP] [real-time index] Implement payloadstorage for structpayloadindex (#642)
    
    * [real-time index] Extend FieldIndex enum and StructPayloadIndex with method from PayloadStorage
    
    * [real-time index] add missing remove_point methods
    
    * [real-time index] add new index to FieldIndex enum
    
    * fix compile
    
    * are you happy fmt
    
    * merge load and remove
    
    * fix test generics
    
    * decrement points count
    
    * remove from histogram
    
    * simplify histogram usage
    
    * [real-time index] remove old tests and fix clippy warnings
    
    * histogram: method to derive range by size (#657)
    
    * [real-time index] add histogram based payload_blocks implementation.
    
    * payload blocks
    
    * fmt
    
    * clippy
    
    * [real-time index] refactor Segment to use PayloadIndex instead of PayloadStorage.
    
    * fix tests
    
    * fmt
    
    * clippy
    
    * rename indexes
    
    * remove redundent params
    
    * add struct payload deletion test + fix delete payload in map index
    
    * remove payload threshold
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index cc35dd8ed..d39b62f37 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,6 +1,6 @@
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
-use crate::payload_storage::PayloadStorage;
+use crate::index::PayloadIndex;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, PayloadSchemaType, SegmentConfig};
@@ -58,11 +58,11 @@ impl SegmentBuilder {
 
                 let other_id_tracker = other.id_tracker.borrow();
                 let other_vector_storage = other.vector_storage.borrow();
-                let other_payload_storage = other.payload_storage.borrow();
+                let other_payload_index = other.payload_index.borrow();
 
                 let mut id_tracker = self_segment.id_tracker.borrow_mut();
                 let mut vector_storage = self_segment.vector_storage.borrow_mut();
-                let mut payload_storage = self_segment.payload_storage.borrow_mut();
+                let mut payload_index = self_segment.payload_index.borrow_mut();
 
                 let new_internal_range = vector_storage.update_from(&*other_vector_storage)?;
 
@@ -82,9 +82,9 @@ impl SegmentBuilder {
                             // New point, just insert
                             id_tracker.set_link(external_id, new_internal_id)?;
                             id_tracker.set_version(external_id, other_version)?;
-                            payload_storage.assign(
+                            payload_index.assign(
                                 new_internal_id,
-                                &other_payload_storage.payload(old_internal_id)?,
+                                &other_payload_index.payload(old_internal_id)?,
                             )?;
                         }
                         Some(existing_version) => {
@@ -96,9 +96,9 @@ impl SegmentBuilder {
                                 id_tracker.drop(external_id)?;
                                 id_tracker.set_link(external_id, new_internal_id)?;
                                 id_tracker.set_version(external_id, other_version)?;
-                                payload_storage.assign(
+                                payload_index.assign(
                                     new_internal_id,
-                                    &other_payload_storage.payload(old_internal_id)?,
+                                    &other_payload_index.payload(old_internal_id)?,
                                 )?;
                             } else {
                                 // Old version is still good, do not move anything else

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index d39b62f37..b0654bb15 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,14 +1,15 @@
+use core::cmp;
+use std::collections::HashMap;
+use std::fs;
+use std::path::{Path, PathBuf};
+use std::sync::atomic::{AtomicBool, Ordering};
+
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
 use crate::index::PayloadIndex;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadKeyType, PayloadSchemaType, SegmentConfig};
-use core::cmp;
-use std::collections::HashMap;
-use std::fs;
-use std::path::{Path, PathBuf};
-use std::sync::atomic::{AtomicBool, Ordering};
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {

commit 70317d1bbc16f2bc51e8aee0497bd3fde02c53a0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 3 17:39:13 2022 +0200

    check for segment integrity by checking the version, skip on failure (#904)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index b0654bb15..b5f387dd6 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -145,6 +145,11 @@ impl SegmentBuilder {
         fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
-        load_segment(&self.destination_path)
+        load_segment(&self.destination_path)?.ok_or_else(|| {
+            OperationError::service_error(&format!(
+                "Segment loading error: {}",
+                self.destination_path.display()
+            ))
+        })
     }
 }

commit f357bd5d9bc8cdc05915111419894d4f25512d83
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 15 13:47:52 2022 +0400

    Allow to flush segment in separate thread (#927)
    
    * allow to flush segment in separate thread
    
    * flush as separate function (#928)
    
    * flush as separate function
    
    * review suggestion
    
    * reduce locks during vector scoring
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * don't run background flush twice
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * increase flush interval
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * are you happy fmt
    
    * test background flush
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index b5f387dd6..f95bcdcc3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -137,7 +137,7 @@ impl SegmentBuilder {
 
             segment.vector_index.borrow_mut().build_index(stopped)?;
 
-            segment.flush()?;
+            segment.flush(true)?;
             // Now segment is going to be evicted from RAM
         }
 

commit b9eee55a9fb6d53572622f62756a80e62484009e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Sep 1 12:50:12 2022 +0200

    Full text search (#963)
    
    * allow additional params for payload field index
    
    * fmt
    
    * wip: full text index building
    
    * fmt
    
    * text search request
    
    * text search request
    
    * full text index persitance and loading
    
    * fmt
    
    * enable fts index in mapping
    
    * clippy
    
    * fix tests + add integration test
    
    * review fixes: extend payload index test
    
    * revert incedental change

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index f95bcdcc3..47afc4555 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -9,14 +9,14 @@ use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
 use crate::index::PayloadIndex;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
-use crate::types::{PayloadKeyType, PayloadSchemaType, SegmentConfig};
+use crate::types::{PayloadFieldSchema, PayloadKeyType, SegmentConfig};
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
     pub segment: Option<Segment>,
     pub destination_path: PathBuf,
     pub temp_path: PathBuf,
-    pub indexed_fields: HashMap<PayloadKeyType, PayloadSchemaType>,
+    pub indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
 }
 
 impl SegmentBuilder {
@@ -127,7 +127,7 @@ impl SegmentBuilder {
             self.segment = None;
 
             for (field, payload_schema) in &self.indexed_fields {
-                segment.create_field_index(segment.version(), field, &Some(*payload_schema))?;
+                segment.create_field_index(segment.version(), field, Some(payload_schema))?;
                 if stopped.load(Ordering::Relaxed) {
                     return Err(OperationError::Cancelled {
                         description: "Cancelled by external thread".to_string(),

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 47afc4555..cab54de49 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -58,18 +58,56 @@ impl SegmentBuilder {
                 self_segment.version = cmp::max(self_segment.version(), other.version());
 
                 let other_id_tracker = other.id_tracker.borrow();
-                let other_vector_storage = other.vector_storage.borrow();
+                let other_vector_storages: HashMap<_, _> = other
+                    .vector_data
+                    .iter()
+                    .map(|(vector_name, vector_data)| {
+                        (vector_name.to_owned(), vector_data.vector_storage.borrow())
+                    })
+                    .collect();
                 let other_payload_index = other.payload_index.borrow();
 
                 let mut id_tracker = self_segment.id_tracker.borrow_mut();
-                let mut vector_storage = self_segment.vector_storage.borrow_mut();
+                let mut vector_storages: HashMap<_, _> = self_segment
+                    .vector_data
+                    .iter()
+                    .map(|(vector_name, vector_data)| {
+                        (
+                            vector_name.to_owned(),
+                            vector_data.vector_storage.borrow_mut(),
+                        )
+                    })
+                    .collect();
                 let mut payload_index = self_segment.payload_index.borrow_mut();
 
-                let new_internal_range = vector_storage.update_from(&*other_vector_storage)?;
+                if vector_storages.len() != other_vector_storages.len() {
+                    return Err(OperationError::ServiceError {
+                        description: format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
+                    });
+                }
 
-                for (new_internal_id, old_internal_id) in
-                    new_internal_range.zip(other_vector_storage.iter_ids())
-                {
+                let mut internal_id_iter = None;
+                for (vector_name, vector_storage) in &mut vector_storages {
+                    let other_vector_storage = other_vector_storages.get(vector_name);
+                    if other_vector_storage.is_none() {
+                        return Err(OperationError::ServiceError {
+                            description: format!("Cannot update from other segment because if missing vector name {}", vector_name),
+                        });
+                    }
+                    let other_vector_storage = other_vector_storage.unwrap();
+                    let new_internal_range = vector_storage.update_from(&**other_vector_storage)?;
+                    internal_id_iter =
+                        Some(new_internal_range.zip(other_vector_storage.iter_ids()));
+                }
+                if internal_id_iter.is_none() {
+                    return Err(OperationError::ServiceError {
+                        description:
+                            "Empty intersection between self segment names and other segment names"
+                                .to_owned(),
+                    });
+                }
+
+                for (new_internal_id, old_internal_id) in internal_id_iter.unwrap() {
                     if stopped.load(Ordering::Relaxed) {
                         return Err(OperationError::Cancelled {
                             description: "Cancelled by external thread".to_string(),
@@ -89,11 +127,10 @@ impl SegmentBuilder {
                             )?;
                         }
                         Some(existing_version) => {
-                            if existing_version < other_version {
+                            let remove_id = if existing_version < other_version {
                                 // Other version is the newest, remove the existing one and replace
                                 let existing_internal_id =
                                     id_tracker.internal_id(external_id).unwrap();
-                                vector_storage.delete(existing_internal_id)?;
                                 id_tracker.drop(external_id)?;
                                 id_tracker.set_link(external_id, new_internal_id)?;
                                 id_tracker.set_version(external_id, other_version)?;
@@ -101,11 +138,15 @@ impl SegmentBuilder {
                                     new_internal_id,
                                     &other_payload_index.payload(old_internal_id)?,
                                 )?;
+                                existing_internal_id
                             } else {
                                 // Old version is still good, do not move anything else
                                 // Mark newly added vector as removed
-                                vector_storage.delete(new_internal_id)?;
+                                new_internal_id
                             };
+                            for vector_storage in vector_storages.values_mut() {
+                                vector_storage.delete(remove_id)?;
+                            }
                         }
                     }
                 }
@@ -135,7 +176,9 @@ impl SegmentBuilder {
                 }
             }
 
-            segment.vector_index.borrow_mut().build_index(stopped)?;
+            for vector_data in segment.vector_data.values_mut() {
+                vector_data.vector_index.borrow_mut().build_index(stopped)?;
+            }
 
             segment.flush(true)?;
             // Now segment is going to be evicted from RAM

commit 54e085770811b3f157cf7f7af49b05a3594325a6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 10 20:17:33 2022 +0200

    ignore points with missing expernal ids instead of panic (#1109)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index cab54de49..5a1fb81cc 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -113,7 +113,19 @@ impl SegmentBuilder {
                             description: "Cancelled by external thread".to_string(),
                         });
                     }
-                    let external_id = other_id_tracker.external_id(old_internal_id).unwrap();
+                    let external_id =
+                        if let Some(external_id) = other_id_tracker.external_id(old_internal_id) {
+                            external_id
+                        } else {
+                            log::warn!(
+                                "Cannot find external id for internal id {}, skipping",
+                                old_internal_id
+                            );
+                            for vector_storage in vector_storages.values_mut() {
+                                vector_storage.delete(new_internal_id)?;
+                            }
+                            continue;
+                        };
                     let other_version = other_id_tracker.version(external_id).unwrap();
 
                     match id_tracker.version(external_id) {

commit e027db4d27255784715b727bbf67abd44dd0d5c0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Nov 9 14:03:49 2022 +0100

    V0.11.2 (#1209)
    
    * Update: unmaintained crate memmap -> memmap2 (#559) (#1160)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * Consensus q n a (#1169)
    
    * Expand comments and minor refactoring for raft state
    
    * fmt
    
    * add comments to consensus.rs
    
    * fix "Consensus q n a" compatibility
    
    * Use less ram for id tracker (#1176)
    
    * use less ram for id tracker
    
    * are you happy clippy
    
    * use vec for internals
    
    * use versions for internal ids
    
    * keys test
    
    * Use less ram for id tracker fixes (#1182)
    
    * WIP: internal_to_version
    
    * fmt
    
    * fix unit tests
    
    * add comment
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * remove suggesting changes in replications on replication factor change (#1177)
    
    * Bump actix-cors from 0.6.3 to 0.6.4 (#1185)
    
    Bumps [actix-cors](https://github.com/actix/actix-extras) from 0.6.3 to 0.6.4.
    - [Release notes](https://github.com/actix/actix-extras/releases)
    - [Commits](https://github.com/actix/actix-extras/compare/cors-v0.6.3...cors-v0.6.4)
    
    ---
    updated-dependencies:
    - dependency-name: actix-cors
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * enable HTTP compression middleware (#1184)
    
    * Use systematically assert_http_ok for better error reporting (#1183)
    
    * Use systematically assert_http_ok for better error reporting
    
    * extraction assertion to use it outside of pytest
    
    * Bump pprof from 0.10.1 to 0.11.0 (#1188)
    
    Bumps [pprof](https://github.com/tikv/pprof-rs) from 0.10.1 to 0.11.0.
    - [Release notes](https://github.com/tikv/pprof-rs/releases)
    - [Changelog](https://github.com/tikv/pprof-rs/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/tikv/pprof-rs/commits)
    
    ---
    updated-dependencies:
    - dependency-name: pprof
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Cosine dist zero vectors (#1198)
    
    * skip pre-processing of zero-length vector for cosine distance
    
    * fmt
    
    * Bump env_logger from 0.9.1 to 0.9.3 (#1201)
    
    Bumps [env_logger](https://github.com/env-logger-rs/env_logger) from 0.9.1 to 0.9.3.
    - [Release notes](https://github.com/env-logger-rs/env_logger/releases)
    - [Changelog](https://github.com/env-logger-rs/env_logger/blob/main/CHANGELOG.md)
    - [Commits](https://github.com/env-logger-rs/env_logger/compare/v0.9.1...v0.9.3)
    
    ---
    updated-dependencies:
    - dependency-name: env_logger
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump indicatif from 0.17.1 to 0.17.2 (#1202)
    
    Bumps [indicatif](https://github.com/console-rs/indicatif) from 0.17.1 to 0.17.2.
    - [Release notes](https://github.com/console-rs/indicatif/releases)
    - [Commits](https://github.com/console-rs/indicatif/compare/0.17.1...0.17.2)
    
    ---
    updated-dependencies:
    - dependency-name: indicatif
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump ordered-float from 3.3.0 to 3.4.0 (#1204)
    
    Bumps [ordered-float](https://github.com/reem/rust-ordered-float) from 3.3.0 to 3.4.0.
    - [Release notes](https://github.com/reem/rust-ordered-float/releases)
    - [Commits](https://github.com/reem/rust-ordered-float/compare/v3.3.0...v3.4.0)
    
    ---
    updated-dependencies:
    - dependency-name: ordered-float
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump clap from 4.0.18 to 4.0.22 (#1205)
    
    Bumps [clap](https://github.com/clap-rs/clap) from 4.0.18 to 4.0.22.
    - [Release notes](https://github.com/clap-rs/clap/releases)
    - [Changelog](https://github.com/clap-rs/clap/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/clap-rs/clap/compare/v4.0.18...v4.0.22)
    
    ---
    updated-dependencies:
    - dependency-name: clap
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump num_cpus from 1.13.1 to 1.14.0 (#1203)
    
    * wait for state deactivation on replica update failure (#1200)
    
    * wait for state deactivation on replica update failure
    
    * review fixes
    
    * upd version to 0.11.2
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: erare-humanum <116254494+erare-humanum@users.noreply.github.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 5a1fb81cc..b95fc1638 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -126,26 +126,29 @@ impl SegmentBuilder {
                             }
                             continue;
                         };
-                    let other_version = other_id_tracker.version(external_id).unwrap();
+                    let other_version = other_id_tracker.internal_version(old_internal_id).unwrap();
 
-                    match id_tracker.version(external_id) {
+                    match id_tracker.internal_id(external_id) {
                         None => {
                             // New point, just insert
                             id_tracker.set_link(external_id, new_internal_id)?;
-                            id_tracker.set_version(external_id, other_version)?;
+                            id_tracker.set_internal_version(new_internal_id, other_version)?;
                             payload_index.assign(
                                 new_internal_id,
                                 &other_payload_index.payload(old_internal_id)?,
                             )?;
                         }
-                        Some(existing_version) => {
+                        Some(existing_internal_id) => {
+                            // Point exists in both: newly constructed and old segments, so we need to merge them
+                            // Based on version
+                            let existing_version =
+                                id_tracker.internal_version(existing_internal_id).unwrap();
                             let remove_id = if existing_version < other_version {
                                 // Other version is the newest, remove the existing one and replace
-                                let existing_internal_id =
-                                    id_tracker.internal_id(external_id).unwrap();
                                 id_tracker.drop(external_id)?;
                                 id_tracker.set_link(external_id, new_internal_id)?;
-                                id_tracker.set_version(external_id, other_version)?;
+                                id_tracker.set_internal_version(new_internal_id, other_version)?;
+                                payload_index.drop(existing_internal_id)?;
                                 payload_index.assign(
                                     new_internal_id,
                                     &other_payload_index.payload(old_internal_id)?,

commit 6a0d90775574d00afc94e8aa567b596fd4e4a15f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Dec 6 12:31:38 2022 +0100

    include backtrace for service errors (#1256)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index b95fc1638..ee255ec5b 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -81,18 +81,19 @@ impl SegmentBuilder {
                 let mut payload_index = self_segment.payload_index.borrow_mut();
 
                 if vector_storages.len() != other_vector_storages.len() {
-                    return Err(OperationError::ServiceError {
-                        description: format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
-                    });
+                    return Err(OperationError::service_error(
+                        &format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
+                    ));
                 }
 
                 let mut internal_id_iter = None;
                 for (vector_name, vector_storage) in &mut vector_storages {
                     let other_vector_storage = other_vector_storages.get(vector_name);
                     if other_vector_storage.is_none() {
-                        return Err(OperationError::ServiceError {
-                            description: format!("Cannot update from other segment because if missing vector name {}", vector_name),
-                        });
+                        return Err(OperationError::service_error(&format!(
+                            "Cannot update from other segment because if missing vector name {}",
+                            vector_name
+                        )));
                     }
                     let other_vector_storage = other_vector_storage.unwrap();
                     let new_internal_range = vector_storage.update_from(&**other_vector_storage)?;
@@ -100,11 +101,9 @@ impl SegmentBuilder {
                         Some(new_internal_range.zip(other_vector_storage.iter_ids()));
                 }
                 if internal_id_iter.is_none() {
-                    return Err(OperationError::ServiceError {
-                        description:
-                            "Empty intersection between self segment names and other segment names"
-                                .to_owned(),
-                    });
+                    return Err(OperationError::service_error(
+                        "Empty intersection between self segment names and other segment names",
+                    ));
                 }
 
                 for (new_internal_id, old_internal_id) in internal_id_iter.unwrap() {

commit 8e8ed800f4cb4995d3449a6c1de0f41960042c8b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Dec 14 10:11:46 2022 +0100

    Shard build refactoring (#1280)
    
    * refactor some code of shard creation and optimizers
    
    * Shard build refactoring debug (#1279)
    
    * add debig code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * refactor stop-checking during the optimization
    
    * remove debug logs
    
    * improve delete-renaming schema
    
    * fmt
    
    * move collection file removing to the async task
    
    * rename check_optimization_stopped into more general check_process_stopped

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index ee255ec5b..97d98377e 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -2,10 +2,12 @@ use core::cmp;
 use std::collections::HashMap;
 use std::fs;
 use std::path::{Path, PathBuf};
-use std::sync::atomic::{AtomicBool, Ordering};
+use std::sync::atomic::AtomicBool;
 
 use crate::common::error_logging::LogError;
-use crate::entry::entry_point::{OperationError, OperationResult, SegmentEntry};
+use crate::entry::entry_point::{
+    check_process_stopped, OperationError, OperationResult, SegmentEntry,
+};
 use crate::index::PayloadIndex;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
@@ -88,6 +90,7 @@ impl SegmentBuilder {
 
                 let mut internal_id_iter = None;
                 for (vector_name, vector_storage) in &mut vector_storages {
+                    check_process_stopped(stopped)?;
                     let other_vector_storage = other_vector_storages.get(vector_name);
                     if other_vector_storage.is_none() {
                         return Err(OperationError::service_error(&format!(
@@ -96,7 +99,8 @@ impl SegmentBuilder {
                         )));
                     }
                     let other_vector_storage = other_vector_storage.unwrap();
-                    let new_internal_range = vector_storage.update_from(&**other_vector_storage)?;
+                    let new_internal_range =
+                        vector_storage.update_from(&**other_vector_storage, stopped)?;
                     internal_id_iter =
                         Some(new_internal_range.zip(other_vector_storage.iter_ids()));
                 }
@@ -107,11 +111,8 @@ impl SegmentBuilder {
                 }
 
                 for (new_internal_id, old_internal_id) in internal_id_iter.unwrap() {
-                    if stopped.load(Ordering::Relaxed) {
-                        return Err(OperationError::Cancelled {
-                            description: "Cancelled by external thread".to_string(),
-                        });
-                    }
+                    check_process_stopped(stopped)?;
+
                     let external_id =
                         if let Some(external_id) = other_id_tracker.external_id(old_internal_id) {
                             external_id
@@ -183,11 +184,7 @@ impl SegmentBuilder {
 
             for (field, payload_schema) in &self.indexed_fields {
                 segment.create_field_index(segment.version(), field, Some(payload_schema))?;
-                if stopped.load(Ordering::Relaxed) {
-                    return Err(OperationError::Cancelled {
-                        description: "Cancelled by external thread".to_string(),
-                    });
-                }
+                check_process_stopped(stopped)?;
             }
 
             for vector_data in segment.vector_data.values_mut() {

commit 6eca194f71bc20ca3e945560d47414eb10c14874
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 13 11:44:42 2023 +0100

    Fix segment snapshotting (#1321) (#1334)
    
    * WIP: Fix `Segment::take_snapshot`
    
    TODO:
    - This commit, probably, breaks snapshotting of segments with memmapped vector storage
    - `ProxySegment::take_snapshot` seems to potentially similar bug
    
    * WIP: Fix `Segment::take_snapshot`
    
    - Fix snapshotting of `StructPayloadIndex`
    - Fix snapshotting of segments with memmapped vector storage
    - Temporarily break `ProxySegment::take_snapshot`
    
    * Fix `ProxySegment::take_snapshot`
    
    * Remove `copy_segment_directory` test
    
    * nitpicking
    
    * clippy fixes
    
    * use OperationError::service_error
    
    * Cleanup `TinyMap` trait bounds and derive `Debug`
    
    * Fix `test_snapshot` test
    
    - Derive `Debug` for `NamedVectors`
    
    * Move utility functions from `segment.rs` to `utils` module
    
    * Contextualize `segment::utils::fs::move_all` a bit more carefully
    
    * Fix a typo
    
    * add backward compatibility with old snapshot formats
    
    * fmt
    
    * add snapshot for compatibility test
    
    * git lfs is a piece of shit
    
    * Nitpicking
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 97d98377e..a39f34f20 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -84,7 +84,7 @@ impl SegmentBuilder {
 
                 if vector_storages.len() != other_vector_storages.len() {
                     return Err(OperationError::service_error(
-                        &format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
+                        format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
                     ));
                 }
 
@@ -93,7 +93,7 @@ impl SegmentBuilder {
                     check_process_stopped(stopped)?;
                     let other_vector_storage = other_vector_storages.get(vector_name);
                     if other_vector_storage.is_none() {
-                        return Err(OperationError::service_error(&format!(
+                        return Err(OperationError::service_error(format!(
                             "Cannot update from other segment because if missing vector name {}",
                             vector_name
                         )));
@@ -200,7 +200,7 @@ impl SegmentBuilder {
             .describe("Moving segment data after optimization")?;
 
         load_segment(&self.destination_path)?.ok_or_else(|| {
-            OperationError::service_error(&format!(
+            OperationError::service_error(format!(
                 "Segment loading error: {}",
                 self.destination_path.display()
             ))

commit 26fc1ed5832df16d7d99214a8f7fef699da02924
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 19 07:58:45 2023 +0100

    Remove some blocking IO calls on Tokio threads (#1366)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index a39f34f20..841ac20f0 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,6 +1,5 @@
 use core::cmp;
 use std::collections::HashMap;
-use std::fs;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
@@ -196,7 +195,7 @@ impl SegmentBuilder {
         }
 
         // Move fully constructed segment into collection directory and load back to RAM
-        fs::rename(&self.temp_path, &self.destination_path)
+        std::fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
         load_segment(&self.destination_path)?.ok_or_else(|| {

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 841ac20f0..69a923719 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -93,8 +93,7 @@ impl SegmentBuilder {
                     let other_vector_storage = other_vector_storages.get(vector_name);
                     if other_vector_storage.is_none() {
                         return Err(OperationError::service_error(format!(
-                            "Cannot update from other segment because if missing vector name {}",
-                            vector_name
+                            "Cannot update from other segment because if missing vector name {vector_name}"
                         )));
                     }
                     let other_vector_storage = other_vector_storage.unwrap();

commit 128e49fcc3633e361df33818de6cca0aab95da10
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Mar 3 20:46:17 2023 +0400

    integrate quantized data to storages (#1311)
    
    * integrate quantized data to storages
    
    * revert gitignore
    
    * are you happy clippy
    
    * quantize in optimizer
    
    * provide flag
    
    * fix segfault
    
    * skip quantization flag, update scores
    
    * use quantization flag
    
    * are you happy fmt
    
    * use quantization flag
    
    * quantized search test
    
    * are you happy fmt
    
    * refactor test, refactor scorer choosing
    
    * are you happy fmt
    
    * run quantization on segment builder
    
    * decrease testing parameters
    
    * simplify segment
    
    * update version
    
    * remove use_quantization flag
    
    * provide quantization config
    
    * quantization version up
    
    * euclid dist
    
    * add euclid test
    
    * saveload
    
    * fix initialization bugs
    
    * quantization lib version up
    
    * fix arm build
    
    * refactor scorer selecting
    
    * quant lib version up
    
    * are you happy fmt
    
    * are you happy fmt
    
    * are you happy clippy
    
    * add save/load test for simple storage
    
    * add comments
    
    * quantiles
    
    * quantization mmap
    
    * remove f32
    
    * mmap test
    
    * fix mmap slice
    
    * fix mmap test
    
    * use chunks for quantization storage
    
    * fix build
    
    * are you happy fmt
    
    * update quantization library
    
    * update quantization lib
    
    * update quantization lib
    
    * integrate api changes
    
    * are you happy fmt
    
    * change quantization api
    
    * additional checks in tests
    
    * update quantization version
    
    * fix unit tests
    
    * add quantization to storage config
    
    * use quantization for all cardinality search cases
    
    * Integrate quantization suggestions 2 (#1520)
    
    * review api
    
    * wip: refactor quantization integrations
    
    * wip: refactor quantization integrations
    
    * wip: fmt
    
    * include quantization into snapshot
    
    * fmt
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 69a923719..9eb2ca08c 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -3,6 +3,7 @@ use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
+use super::get_vector_storage_path;
 use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{
     check_process_stopped, OperationError, OperationResult, SegmentEntry,
@@ -185,6 +186,8 @@ impl SegmentBuilder {
                 check_process_stopped(stopped)?;
             }
 
+            Self::update_quantization(&segment, stopped)?;
+
             for vector_data in segment.vector_data.values_mut() {
                 vector_data.vector_index.borrow_mut().build_index(stopped)?;
             }
@@ -197,11 +200,28 @@ impl SegmentBuilder {
         std::fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
-        load_segment(&self.destination_path)?.ok_or_else(|| {
+        let loaded_segment = load_segment(&self.destination_path)?.ok_or_else(|| {
             OperationError::service_error(format!(
                 "Segment loading error: {}",
                 self.destination_path.display()
             ))
-        })
+        })?;
+        Ok(loaded_segment)
+    }
+
+    fn update_quantization(segment: &Segment, stopped: &AtomicBool) -> OperationResult<()> {
+        if let Some(quantization) = &segment.config().quantization_config {
+            let segment_path = segment.current_path.as_path();
+            for (vector_name, vector_data) in &segment.vector_data {
+                check_process_stopped(stopped)?;
+
+                let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+                vector_data
+                    .vector_storage
+                    .borrow_mut()
+                    .quantize(&vector_storage_path, quantization)?;
+            }
+        }
+        Ok(())
     }
 }

commit 9bb29c26a6ddf3aa0092d45f797aca45735b9ba3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 9 09:43:20 2023 +0400

    Vector storages enum (#1533)
    
    * separate scoring and data containing
    
    * vector storage enum
    
    * fix test build
    
    * are you happy clippy
    
    * review fixes

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 9eb2ca08c..fc8855fbb 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -12,6 +12,7 @@ use crate::index::PayloadIndex;
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadFieldSchema, PayloadKeyType, SegmentConfig};
+use crate::vector_storage::VectorStorage;
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
@@ -99,7 +100,7 @@ impl SegmentBuilder {
                     }
                     let other_vector_storage = other_vector_storage.unwrap();
                     let new_internal_range =
-                        vector_storage.update_from(&**other_vector_storage, stopped)?;
+                        vector_storage.update_from(other_vector_storage, stopped)?;
                     internal_id_iter =
                         Some(new_internal_range.zip(other_vector_storage.iter_ids()));
                 }

commit c60ef44836ab749d39d8c99209f4a9fc086edfc8
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Mar 12 17:14:21 2023 +0400

    Enum vector index (#1539)
    
    * separate payload and vector index bases
    
    * vector index as enum

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index fc8855fbb..9a847eeb8 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -8,7 +8,7 @@ use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{
     check_process_stopped, OperationError, OperationResult, SegmentEntry,
 };
-use crate::index::PayloadIndex;
+use crate::index::{PayloadIndex, VectorIndex};
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{PayloadFieldSchema, PayloadKeyType, SegmentConfig};

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 9a847eeb8..268fbbf49 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -89,7 +89,7 @@ impl SegmentBuilder {
                     ));
                 }
 
-                let mut internal_id_iter = None;
+                let mut new_internal_range = None;
                 for (vector_name, vector_storage) in &mut vector_storages {
                     check_process_stopped(stopped)?;
                     let other_vector_storage = other_vector_storages.get(vector_name);
@@ -99,68 +99,70 @@ impl SegmentBuilder {
                         )));
                     }
                     let other_vector_storage = other_vector_storage.unwrap();
-                    let new_internal_range =
-                        vector_storage.update_from(other_vector_storage, stopped)?;
-                    internal_id_iter =
-                        Some(new_internal_range.zip(other_vector_storage.iter_ids()));
-                }
-                if internal_id_iter.is_none() {
-                    return Err(OperationError::service_error(
-                        "Empty intersection between self segment names and other segment names",
-                    ));
+                    let internal_range = vector_storage.update_from(
+                        other_vector_storage,
+                        &mut other_id_tracker.iter_ids(),
+                        stopped,
+                    )?;
+                    match new_internal_range.clone() {
+                        Some(new_internal_range) => {
+                            if new_internal_range != internal_range {
+                                return Err(OperationError::service_error(
+                                    "Internal ids range mismatch between self segment vectors and other segment vectors",
+                                ));
+                            }
+                        }
+                        None => new_internal_range = Some(internal_range.clone()),
+                    }
                 }
 
-                for (new_internal_id, old_internal_id) in internal_id_iter.unwrap() {
-                    check_process_stopped(stopped)?;
+                if let Some(new_internal_range) = new_internal_range {
+                    let internal_id_iter = new_internal_range.zip(other_id_tracker.iter_ids());
+
+                    for (new_internal_id, old_internal_id) in internal_id_iter {
+                        check_process_stopped(stopped)?;
 
-                    let external_id =
-                        if let Some(external_id) = other_id_tracker.external_id(old_internal_id) {
+                        let external_id = if let Some(external_id) =
+                            other_id_tracker.external_id(old_internal_id)
+                        {
                             external_id
                         } else {
                             log::warn!(
                                 "Cannot find external id for internal id {}, skipping",
                                 old_internal_id
                             );
-                            for vector_storage in vector_storages.values_mut() {
-                                vector_storage.delete(new_internal_id)?;
-                            }
                             continue;
                         };
-                    let other_version = other_id_tracker.internal_version(old_internal_id).unwrap();
-
-                    match id_tracker.internal_id(external_id) {
-                        None => {
-                            // New point, just insert
-                            id_tracker.set_link(external_id, new_internal_id)?;
-                            id_tracker.set_internal_version(new_internal_id, other_version)?;
-                            payload_index.assign(
-                                new_internal_id,
-                                &other_payload_index.payload(old_internal_id)?,
-                            )?;
-                        }
-                        Some(existing_internal_id) => {
-                            // Point exists in both: newly constructed and old segments, so we need to merge them
-                            // Based on version
-                            let existing_version =
-                                id_tracker.internal_version(existing_internal_id).unwrap();
-                            let remove_id = if existing_version < other_version {
-                                // Other version is the newest, remove the existing one and replace
-                                id_tracker.drop(external_id)?;
+                        let other_version =
+                            other_id_tracker.internal_version(old_internal_id).unwrap();
+
+                        match id_tracker.internal_id(external_id) {
+                            None => {
+                                // New point, just insert
                                 id_tracker.set_link(external_id, new_internal_id)?;
                                 id_tracker.set_internal_version(new_internal_id, other_version)?;
-                                payload_index.drop(existing_internal_id)?;
                                 payload_index.assign(
                                     new_internal_id,
                                     &other_payload_index.payload(old_internal_id)?,
                                 )?;
-                                existing_internal_id
-                            } else {
-                                // Old version is still good, do not move anything else
-                                // Mark newly added vector as removed
-                                new_internal_id
-                            };
-                            for vector_storage in vector_storages.values_mut() {
-                                vector_storage.delete(remove_id)?;
+                            }
+                            Some(existing_internal_id) => {
+                                // Point exists in both: newly constructed and old segments, so we need to merge them
+                                // Based on version
+                                let existing_version =
+                                    id_tracker.internal_version(existing_internal_id).unwrap();
+                                if existing_version < other_version {
+                                    // Other version is the newest, remove the existing one and replace
+                                    id_tracker.drop(external_id)?;
+                                    id_tracker.set_link(external_id, new_internal_id)?;
+                                    id_tracker
+                                        .set_internal_version(new_internal_id, other_version)?;
+                                    payload_index.drop(existing_internal_id)?;
+                                    payload_index.assign(
+                                        new_internal_id,
+                                        &other_payload_index.payload(old_internal_id)?,
+                                    )?;
+                                }
                             }
                         }
                     }

commit 623f3bffe1a53036bd3a6dda4b0159aea8c5cce1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 10 15:29:39 2023 +0200

    Try to fix dying shards (#1682)
    
    * use common channel pool for healthcheck requests
    
    * add dynamic channel pool
    
    * fmt
    
    * lower parallel connections num
    
    * fmt
    
    * fix clippy
    
    * fix clippy
    
    * better status error message
    
    * smarter channel dropping conditions
    
    * per-channel stats
    
    * refactor pool
    
    * rollback dockerfile
    
    * health-check timeout
    
    * prevent reporting last active peer as dead
    
    * introduce update rate limit
    
    * only rate-limit client requests
    
    * ability to save snapshot without locking wal (#1685)
    
    * ability to save snapshot without locking wal
    
    * fix empty wal saving
    
    * skip waiting on local shard in listener mode even if it is a direct request to listener shard
    
    * snapshot recovery test + better handling of segment versions
    
    * use latest wal
    
    * review changes

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 268fbbf49..cc01518b7 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -58,7 +58,7 @@ impl SegmentBuilder {
                 "Segment building error: created segment not found",
             )),
             Some(self_segment) => {
-                self_segment.version = cmp::max(self_segment.version(), other.version());
+                self_segment.version = Some(cmp::max(self_segment.version(), other.version()));
 
                 let other_id_tracker = other.id_tracker.borrow();
                 let other_vector_storages: HashMap<_, _> = other

commit 66ba8f17af136554e5a5a707c31d8d1fd801b70c
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 10 17:16:56 2023 +0200

    Add vector specific HNSW configuration (#1675)
    
    * Validate VectorConfig/VectorParams, remove obsolete validation
    
    * Add HNSW config diff to vector parameters
    
    * Validate params in collection config
    
    * Add HNSW config to segment vector data config
    
    * Add VectorsConfig params iterator for more elegant conversions
    
    * Prefer vector HNSW config over collection config for building HNSW index
    
    * Base segment vector param HNSW config on collection config
    
    * General improvements
    
    * Rewrite HNSW ef_construct extract function to also consider vector configs
    
    * Update OpenAPI specification
    
    * Add test to check if vector specific HNSW config is persisted
    
    * review changes
    
    * review changes
    
    * Regenerate gRPC docs
    
    * Fix test on Windows
    
    * Regenerate OpenAPI specification
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index cc01518b7..4e5c7b58f 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -127,10 +127,7 @@ impl SegmentBuilder {
                         {
                             external_id
                         } else {
-                            log::warn!(
-                                "Cannot find external id for internal id {}, skipping",
-                                old_internal_id
-                            );
+                            log::warn!("Cannot find external id for internal id {old_internal_id}, skipping");
                             continue;
                         };
                         let other_version =

commit 868626f409a7bcc4e2537dcf69b9b4bbe2c10208
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 10 21:39:43 2023 +0200

    Add vector specific quantization configuration (#1680)
    
    * Add QuantizationConfigDiff type
    
    * Add quantization config diff to vector parameters
    
    * Prefer vector config over collection config for quantization
    
    * Update OpenAPI specification
    
    * Validate quantization configuration quantile in 0.5-1.0 range
    
    As per https://github.com/qdrant/qdrant/pull/1681
    
    * Add test if check if vector specific quantization config is persisted
    
    * Alias quantization to quantization_config in vector parameters
    
    * Remove quantization config diff, use full vector specific config instead
    
    * Regenerate OpenAPI specification and gRPC docs
    
    * Fix compilation error
    
    * Add error handling to quantization config conversions
    
    * Fix quantization integration test, make HNSW test stricter

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 4e5c7b58f..97c190071 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -210,9 +210,10 @@ impl SegmentBuilder {
     }
 
     fn update_quantization(segment: &Segment, stopped: &AtomicBool) -> OperationResult<()> {
-        if let Some(quantization) = &segment.config().quantization_config {
-            let segment_path = segment.current_path.as_path();
-            for (vector_name, vector_data) in &segment.vector_data {
+        let config = segment.config();
+        for (vector_name, vector_data) in &segment.vector_data {
+            if let Some(quantization) = config.quantization_config(vector_name) {
+                let segment_path = segment.current_path.as_path();
                 check_process_stopped(stopped)?;
 
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);

commit 7edf599d73cd65b47476be72009684451b7533a9
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Apr 25 14:31:04 2023 +0200

    Make query planner aware of deleted points and vectors (#1757)
    
    * Exclude deleted vectors from HNSW graph building stage
    
    * When estimating query cardinality, use available points as baseline
    
    We should not use the total number of points in a segment, because a
    portion of it may be soft deleted. Instead, we use the available
    (non-deleted) points as baseline.
    
    * Add plain search check to unfiltered HNSW search due to deleted points
    
    * Cardinality sampling on available points, ignore deleted named vectors
    
    * Estimate available vectors in query planner, now consider deleted points
    
    In the query planner, we want to know the number of available points as
    accurately as possible. This isn't possible because we only know the
    number of deletions and vectors can be deleted in two places: as point
    or as vector. These deletions may overlap. This now estimates the number
    of deleted vectors based on the segment state. It assumes that point and
    vector deletions have an overlap of 20%. This is an arbitrary
    percentage, but reflects an almost-worst scenario.
    
    This improves because the number of deleted points wasn't considered at
    all before.
    
    * Remove unused function from trait
    
    * Fix bench compilation error
    
    * Fix typo in docs
    
    * Base whether to do plain search in HNSW upon full scan threshold
    
    * Remove index threshold from HNSW config, only use full scan threshold
    
    * Simplify timer aggregator assignment in HNSW search
    
    * Remove vector storage type from cardinality function parameters
    
    * Propagate point deletes to all its vectors
    
    * Check for deleted vectors first, this makes early return possible
    
    Since point deletes are now propagated to vectors, deleted points are
    included in vector deletions. Because of that we can check if the vector
    is deleted first so we can return early and skip the point deletion
    check.
    
    For integrity we also check if the point is deleted, if the vector was
    not. That is because it may happen that point deletions are not properly
    propagated to vectors.
    
    * Don't use arbitrary vector count estimation, use vector count directly
    
    Before we had to estimate the number of vectors (for a named vector)
    because vectors could be deleted as point or vector. Point deletes are
    now propagated to vector deletes, that means we can simply use the
    deleted vector count which is now much more accurate.
    
    * When sampling IDs, check deleted vecs before deleted points
    
    * On segment consistency check, delete vectors for deleted points
    
    * Fix vector delete state not being kept when updating storage from other
    
    * Fix segment builder skipping deleted vectors breaking offsets
    
    * update segment to handle optional vectors + add test (#1781)
    
    * update segment to handle optional vectors + add test
    
    * Only update stored record when deleting if it wasn't deleted already
    
    * Reformat comment
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Fix missed vector name test, these are now marked as deleted
    
    * upd test
    
    * upd test
    
    * Update consensus test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 97c190071..f55ac4ff7 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,4 +1,4 @@
-use core::cmp;
+use std::cmp::max;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
@@ -58,7 +58,7 @@ impl SegmentBuilder {
                 "Segment building error: created segment not found",
             )),
             Some(self_segment) => {
-                self_segment.version = Some(cmp::max(self_segment.version(), other.version()));
+                self_segment.version = Some(max(self_segment.version(), other.version()));
 
                 let other_id_tracker = other.id_tracker.borrow();
                 let other_vector_storages: HashMap<_, _> = other
@@ -92,16 +92,16 @@ impl SegmentBuilder {
                 let mut new_internal_range = None;
                 for (vector_name, vector_storage) in &mut vector_storages {
                     check_process_stopped(stopped)?;
-                    let other_vector_storage = other_vector_storages.get(vector_name);
-                    if other_vector_storage.is_none() {
-                        return Err(OperationError::service_error(format!(
+                    let other_vector_storage = match other_vector_storages.get(vector_name) {
+                        Some(vector_storage) => vector_storage,
+                        None => return Err(OperationError::service_error(format!(
                             "Cannot update from other segment because if missing vector name {vector_name}"
-                        )));
-                    }
-                    let other_vector_storage = other_vector_storage.unwrap();
+                        ))),
+                    };
+                    let mut other_ids = other_id_tracker.iter_ids();
                     let internal_range = vector_storage.update_from(
                         other_vector_storage,
-                        &mut other_id_tracker.iter_ids(),
+                        &mut other_ids,
                         stopped,
                     )?;
                     match new_internal_range.clone() {
@@ -149,11 +149,18 @@ impl SegmentBuilder {
                                 let existing_version =
                                     id_tracker.internal_version(existing_internal_id).unwrap();
                                 if existing_version < other_version {
-                                    // Other version is the newest, remove the existing one and replace
+                                    // Other version is the newest, reassign point to new internal ID
                                     id_tracker.drop(external_id)?;
                                     id_tracker.set_link(external_id, new_internal_id)?;
                                     id_tracker
                                         .set_internal_version(new_internal_id, other_version)?;
+
+                                    // Propagate deletes, delete all vectors for old internal ID
+                                    for vector_storage in vector_storages.values_mut() {
+                                        vector_storage.delete_vec(old_internal_id)?;
+                                    }
+
+                                    // Reassign payload point to new internal ID
                                     payload_index.drop(existing_internal_id)?;
                                     payload_index.assign(
                                         new_internal_id,

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Vise <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index f55ac4ff7..e5cf3b19a 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,4 +1,4 @@
-use std::cmp::max;
+use std::cmp;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
@@ -53,132 +53,133 @@ impl SegmentBuilder {
     /// * `bool` - if `true` - data successfully added, if `false` - process was interrupted
     ///
     pub fn update_from(&mut self, other: &Segment, stopped: &AtomicBool) -> OperationResult<bool> {
-        match &mut self.segment {
-            None => Err(OperationError::service_error(
-                "Segment building error: created segment not found",
-            )),
-            Some(self_segment) => {
-                self_segment.version = Some(max(self_segment.version(), other.version()));
-
-                let other_id_tracker = other.id_tracker.borrow();
-                let other_vector_storages: HashMap<_, _> = other
-                    .vector_data
-                    .iter()
-                    .map(|(vector_name, vector_data)| {
-                        (vector_name.to_owned(), vector_data.vector_storage.borrow())
-                    })
-                    .collect();
-                let other_payload_index = other.payload_index.borrow();
-
-                let mut id_tracker = self_segment.id_tracker.borrow_mut();
-                let mut vector_storages: HashMap<_, _> = self_segment
-                    .vector_data
-                    .iter()
-                    .map(|(vector_name, vector_data)| {
-                        (
-                            vector_name.to_owned(),
-                            vector_data.vector_storage.borrow_mut(),
-                        )
-                    })
-                    .collect();
-                let mut payload_index = self_segment.payload_index.borrow_mut();
-
-                if vector_storages.len() != other_vector_storages.len() {
-                    return Err(OperationError::service_error(
-                        format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
-                    ));
-                }
+        let self_segment = match &mut self.segment {
+            Some(segment) => segment,
+            None => {
+                return Err(OperationError::service_error(
+                    "Segment building error: created segment not found",
+                ))
+            }
+        };
+        self_segment.version = Some(cmp::max(self_segment.version(), other.version()));
+
+        let other_id_tracker = other.id_tracker.borrow();
+        let other_vector_storages: HashMap<_, _> = other
+            .vector_data
+            .iter()
+            .map(|(vector_name, vector_data)| {
+                (vector_name.to_owned(), vector_data.vector_storage.borrow())
+            })
+            .collect();
+        let other_payload_index = other.payload_index.borrow();
+
+        let mut id_tracker = self_segment.id_tracker.borrow_mut();
+        let mut vector_storages: HashMap<_, _> = self_segment
+            .vector_data
+            .iter()
+            .map(|(vector_name, vector_data)| {
+                (
+                    vector_name.to_owned(),
+                    vector_data.vector_storage.borrow_mut(),
+                )
+            })
+            .collect();
+        let mut payload_index = self_segment.payload_index.borrow_mut();
+
+        if vector_storages.len() != other_vector_storages.len() {
+            return Err(OperationError::service_error(
+                format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
+            ));
+        }
 
-                let mut new_internal_range = None;
-                for (vector_name, vector_storage) in &mut vector_storages {
-                    check_process_stopped(stopped)?;
-                    let other_vector_storage = match other_vector_storages.get(vector_name) {
-                        Some(vector_storage) => vector_storage,
-                        None => return Err(OperationError::service_error(format!(
-                            "Cannot update from other segment because if missing vector name {vector_name}"
-                        ))),
-                    };
-                    let mut other_ids = other_id_tracker.iter_ids();
-                    let internal_range = vector_storage.update_from(
-                        other_vector_storage,
-                        &mut other_ids,
-                        stopped,
-                    )?;
-                    match new_internal_range.clone() {
-                        Some(new_internal_range) => {
-                            if new_internal_range != internal_range {
-                                return Err(OperationError::service_error(
-                                    "Internal ids range mismatch between self segment vectors and other segment vectors",
-                                ));
-                            }
-                        }
-                        None => new_internal_range = Some(internal_range.clone()),
+        let mut new_internal_range = None;
+        for (vector_name, vector_storage) in &mut vector_storages {
+            check_process_stopped(stopped)?;
+            let other_vector_storage = other_vector_storages.get(vector_name);
+            if other_vector_storage.is_none() {
+                return Err(OperationError::service_error(format!(
+                    "Cannot update from other segment because if missing vector name {vector_name}"
+                )));
+            }
+            let other_vector_storage = other_vector_storage.unwrap();
+            let internal_range = vector_storage.update_from(
+                other_vector_storage,
+                &mut other_id_tracker.iter_ids(),
+                stopped,
+            )?;
+            match new_internal_range.clone() {
+                Some(new_internal_range) => {
+                    if new_internal_range != internal_range {
+                        return Err(OperationError::service_error(
+                            "Internal ids range mismatch between self segment vectors and other segment vectors",
+                        ));
                     }
                 }
+                None => new_internal_range = Some(internal_range.clone()),
+            }
+        }
 
-                if let Some(new_internal_range) = new_internal_range {
-                    let internal_id_iter = new_internal_range.zip(other_id_tracker.iter_ids());
+        if let Some(new_internal_range) = new_internal_range {
+            let internal_id_iter = new_internal_range.zip(other_id_tracker.iter_ids());
 
-                    for (new_internal_id, old_internal_id) in internal_id_iter {
-                        check_process_stopped(stopped)?;
+            for (new_internal_id, old_internal_id) in internal_id_iter {
+                check_process_stopped(stopped)?;
 
-                        let external_id = if let Some(external_id) =
-                            other_id_tracker.external_id(old_internal_id)
-                        {
-                            external_id
+                let external_id =
+                    if let Some(external_id) = other_id_tracker.external_id(old_internal_id) {
+                        external_id
+                    } else {
+                        log::warn!(
+                            "Cannot find external id for internal id {old_internal_id}, skipping"
+                        );
+                        continue;
+                    };
+                let other_version = other_id_tracker.internal_version(old_internal_id).unwrap();
+
+                match id_tracker.internal_id(external_id) {
+                    None => {
+                        // New point, just insert
+                        id_tracker.set_link(external_id, new_internal_id)?;
+                        id_tracker.set_internal_version(new_internal_id, other_version)?;
+                        payload_index.assign(
+                            new_internal_id,
+                            &other_payload_index.payload(old_internal_id)?,
+                        )?;
+                    }
+                    Some(existing_internal_id) => {
+                        // Point exists in both: newly constructed and old segments, so we need to merge them
+                        // Based on version
+                        let existing_version =
+                            id_tracker.internal_version(existing_internal_id).unwrap();
+                        let remove_id = if existing_version < other_version {
+                            // Other version is the newest, remove the existing one and replace
+                            id_tracker.drop(external_id)?;
+                            id_tracker.set_link(external_id, new_internal_id)?;
+                            id_tracker.set_internal_version(new_internal_id, other_version)?;
+                            payload_index.drop(existing_internal_id)?;
+                            payload_index.assign(
+                                new_internal_id,
+                                &other_payload_index.payload(old_internal_id)?,
+                            )?;
+                            existing_internal_id
                         } else {
-                            log::warn!("Cannot find external id for internal id {old_internal_id}, skipping");
-                            continue;
+                            // Old version is still good, do not move anything else
+                            // Mark newly added vector as removed
+                            new_internal_id
                         };
-                        let other_version =
-                            other_id_tracker.internal_version(old_internal_id).unwrap();
-
-                        match id_tracker.internal_id(external_id) {
-                            None => {
-                                // New point, just insert
-                                id_tracker.set_link(external_id, new_internal_id)?;
-                                id_tracker.set_internal_version(new_internal_id, other_version)?;
-                                payload_index.assign(
-                                    new_internal_id,
-                                    &other_payload_index.payload(old_internal_id)?,
-                                )?;
-                            }
-                            Some(existing_internal_id) => {
-                                // Point exists in both: newly constructed and old segments, so we need to merge them
-                                // Based on version
-                                let existing_version =
-                                    id_tracker.internal_version(existing_internal_id).unwrap();
-                                if existing_version < other_version {
-                                    // Other version is the newest, reassign point to new internal ID
-                                    id_tracker.drop(external_id)?;
-                                    id_tracker.set_link(external_id, new_internal_id)?;
-                                    id_tracker
-                                        .set_internal_version(new_internal_id, other_version)?;
-
-                                    // Propagate deletes, delete all vectors for old internal ID
-                                    for vector_storage in vector_storages.values_mut() {
-                                        vector_storage.delete_vec(old_internal_id)?;
-                                    }
-
-                                    // Reassign payload point to new internal ID
-                                    payload_index.drop(existing_internal_id)?;
-                                    payload_index.assign(
-                                        new_internal_id,
-                                        &other_payload_index.payload(old_internal_id)?,
-                                    )?;
-                                }
-                            }
+                        for vector_storage in vector_storages.values_mut() {
+                            vector_storage.delete_vector(remove_id)?;
                         }
                     }
                 }
-
-                for (field, payload_schema) in other.payload_index.borrow().indexed_fields() {
-                    self.indexed_fields.insert(field, payload_schema);
-                }
-
-                Ok(true)
             }
         }
+
+        for (field, payload_schema) in other.payload_index.borrow().indexed_fields() {
+            self.indexed_fields.insert(field, payload_schema);
+        }
+
+        Ok(true)
     }
 
     pub fn build(mut self, stopped: &AtomicBool) -> Result<Segment, OperationError> {

commit 75cb07c7e490f7654fe5908a9c8862e0912e0c99
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 10 20:20:52 2023 +0400

    Product quantization (#1615)
    
    * product quantization
    
    * update quantization version
    
    * refactor
    
    * change api
    
    * PQ -> product rename
    
    * fix grpc comment
    
    * fix tests
    
    * are you happy clippy
    
    * quantization version up
    
    * update quantization
    
    * provide max threads for kmeans
    
    * fix test build
    
    * pq unit tests
    
    * update quantization lib
    
    * update quantization version
    
    * update deleted flags for quantized raw scorer
    
    * fix build
    
    * are you happy fmt
    
    * update grpc docs
    
    * update openapi
    
    * restore storage_builder.try_reserve_exact
    
    * Update lib/segment/src/segment_constructor/segment_builder.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * Update lib/segment/src/vector_storage/quantized/quantized_raw_scorer.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * change pub to pub(super)
    
    * Update lib/segment/src/vector_storage/quantized/quantized_vectors.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * rename to config_exists
    
    * Product quantization compression api (#1834)
    
    * product quantization compression api
    
    * update openapi and grpc docs
    
    * Update lib/api/src/grpc/proto/collections.proto
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * fix test build
    
    * are you happy fmt
    
    * update grpc docs
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * product quantization with stopper (#1874)
    
    * product quantization with stopper
    
    * quantization version up
    
    * fix build
    
    * small comment fix
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index e5cf3b19a..cacddd4eb 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -8,10 +8,11 @@ use crate::common::error_logging::LogError;
 use crate::entry::entry_point::{
     check_process_stopped, OperationError, OperationResult, SegmentEntry,
 };
+use crate::index::hnsw_index::max_rayon_threads;
 use crate::index::{PayloadIndex, VectorIndex};
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
-use crate::types::{PayloadFieldSchema, PayloadKeyType, SegmentConfig};
+use crate::types::{Indexes, PayloadFieldSchema, PayloadKeyType, SegmentConfig};
 use crate::vector_storage::VectorStorage;
 
 /// Structure for constructing segment out of several other segments
@@ -225,10 +226,16 @@ impl SegmentBuilder {
                 check_process_stopped(stopped)?;
 
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-                vector_data
-                    .vector_storage
-                    .borrow_mut()
-                    .quantize(&vector_storage_path, quantization)?;
+                let max_threads = match segment.config().index {
+                    Indexes::Hnsw(hnsw) => max_rayon_threads(hnsw.max_indexing_threads),
+                    _ => 1,
+                };
+                vector_data.vector_storage.borrow_mut().quantize(
+                    &vector_storage_path,
+                    quantization,
+                    max_threads,
+                    stopped,
+                )?;
             }
         }
         Ok(())

commit df711b7c2e64ec4baf9c086fab2ba68dcdf0966e
Author: Tim Vise <tim+github@visee.me>
Date:   Wed May 17 09:49:55 2023 +0200

    Refactor segment config (#1894)
    
    * Clone current segment config to deprecated type
    
    * Remove segment level quantization config from segment config
    
    * Also deprecate current VectorDataConfig
    
    * Update old segment migration to work with new refactoring
    
    * Move index into vector data config
    
    * Move vector data config migration logic into segment level
    
    * Remove hnsw_config from vector data config
    
    * Rename collection params to vector data conversions function
    
    * Move storage type into vector data config
    
    * Set appendable flag correctly
    
    * Clean up and reformat
    
    * Make segment on disk flag not optional
    
    * Add appendable flag to segment config to replace storage type
    
    * Remove storage type from segment config
    
    * Deprecate storage type enum
    
    * Use consistent variable naming
    
    * Cleanup
    
    * Add segment config migration for v0.5.0 to current
    
    * Bump segment to 0.6.0
    
    * Remove serde defaults for new storage and vector data config types
    
    These default value configurations are not needed anymore, because these
    structs are not used to deserialize old data. All current fields should
    always be available in these structs. When new fields are added in new
    functions, the serde default annotation must be set again.
    
    * Cleanup
    
    * Update OpenAPI specification
    
    This updates the returned data structure on telemetry endpoints, as a
    result of segment configuration refactoring.
    
    * Fix quantization configuration not falling back to collection config
    
    * Fix compiler warning when building in release mode
    
    * Move deprecated type structs into compat module
    
    * Update allow deprecated attributes
    
    * Assign quantization config only in segment optimizer
    
    * Remove unsued parameter
    
    * Add vector storage type enum to vector data config
    
    * Remove appendable and on_disk flags from segment and vector config
    
    * Update OpenAPI specification
    
    * add tests
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index cacddd4eb..0b9dd33bb 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -226,8 +226,13 @@ impl SegmentBuilder {
                 check_process_stopped(stopped)?;
 
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-                let max_threads = match segment.config().index {
-                    Indexes::Hnsw(hnsw) => max_rayon_threads(hnsw.max_indexing_threads),
+                let max_threads = match segment
+                    .config()
+                    .vector_data
+                    .get(vector_name)
+                    .map(|config| &config.index)
+                {
+                    Some(Indexes::Hnsw(hnsw)) => max_rayon_threads(hnsw.max_indexing_threads),
                     _ => 1,
                 };
                 vector_data.vector_storage.borrow_mut().quantize(

commit 8797df02d4f9039db09e46af7b9cb0c26cc87e43
Author: Tim Vise <tim+github@visee.me>
Date:   Wed May 17 13:52:58 2023 +0200

    Don't store version of temp segment until payload indices are converted (#1913)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0b9dd33bb..c01caf4a9 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -29,7 +29,7 @@ impl SegmentBuilder {
         temp_dir: &Path,
         segment_config: &SegmentConfig,
     ) -> OperationResult<Self> {
-        let segment = build_segment(temp_dir, segment_config)?;
+        let segment = build_segment(temp_dir, segment_config, true)?;
         let temp_path = segment.current_path.clone();
 
         let destination_path = segment_path.join(temp_path.file_name().unwrap());

commit 7c100a19f7c8e205973999eb54a98cd9ef0b50f8
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Jun 14 12:57:06 2023 +0200

    Improve counting vectors in `SegmentInfo` (#2072)
    
    * Correctly count vectors in segment info for normal segment
    
    * Correctly count vectors in segment info for proxy segment
    
    * Simplify available point count method
    
    * Minor improvements
    
    * Add unit test for point and vector counts in segment
    
    * Add unit test for point and vector counts in proxy segment
    
    * Improve vector counting for proxy segment

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index c01caf4a9..a2b096d28 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -96,13 +96,11 @@ impl SegmentBuilder {
         let mut new_internal_range = None;
         for (vector_name, vector_storage) in &mut vector_storages {
             check_process_stopped(stopped)?;
-            let other_vector_storage = other_vector_storages.get(vector_name);
-            if other_vector_storage.is_none() {
-                return Err(OperationError::service_error(format!(
+            let other_vector_storage = other_vector_storages.get(vector_name).ok_or_else(|| {
+                OperationError::service_error(format!(
                     "Cannot update from other segment because if missing vector name {vector_name}"
-                )));
-            }
-            let other_vector_storage = other_vector_storage.unwrap();
+                ))
+            })?;
             let internal_range = vector_storage.update_from(
                 other_vector_storage,
                 &mut other_id_tracker.iter_ids(),
@@ -185,10 +183,9 @@ impl SegmentBuilder {
 
     pub fn build(mut self, stopped: &AtomicBool) -> Result<Segment, OperationError> {
         {
-            let mut segment = self.segment.ok_or_else(|| {
-                OperationError::service_error("Segment building error: created segment not found")
-            })?;
-            self.segment = None;
+            let mut segment = self.segment.take().ok_or(OperationError::service_error(
+                "Segment building error: created segment not found",
+            ))?;
 
             for (field, payload_schema) in &self.indexed_fields {
                 segment.create_field_index(segment.version(), field, Some(payload_schema))?;
@@ -202,7 +199,8 @@ impl SegmentBuilder {
             }
 
             segment.flush(true)?;
-            // Now segment is going to be evicted from RAM
+            drop(segment);
+            // Now segment is evicted from RAM
         }
 
         // Move fully constructed segment into collection directory and load back to RAM

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index a2b096d28..94c2de119 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -5,9 +5,8 @@ use std::sync::atomic::AtomicBool;
 
 use super::get_vector_storage_path;
 use crate::common::error_logging::LogError;
-use crate::entry::entry_point::{
-    check_process_stopped, OperationError, OperationResult, SegmentEntry,
-};
+use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
+use crate::entry::entry_point::SegmentEntry;
 use crate::index::hnsw_index::max_rayon_threads;
 use crate::index::{PayloadIndex, VectorIndex};
 use crate::segment::Segment;

commit 047e4bb8bec7d2526c26ce866cc56e1f2bf816ed
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 12 11:21:34 2023 +0200

    Quantization storage as separate entity (#2797)
    
    * quantization storage as separate entity
    
    * simplify max threads calculation

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 94c2de119..2f6fe6996 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -12,6 +12,7 @@ use crate::index::{PayloadIndex, VectorIndex};
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
 use crate::types::{Indexes, PayloadFieldSchema, PayloadKeyType, SegmentConfig};
+use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::VectorStorage;
 
 /// Structure for constructing segment out of several other segments
@@ -191,7 +192,7 @@ impl SegmentBuilder {
                 check_process_stopped(stopped)?;
             }
 
-            Self::update_quantization(&segment, stopped)?;
+            Self::update_quantization(&mut segment, stopped)?;
 
             for vector_data in segment.vector_data.values_mut() {
                 vector_data.vector_index.borrow_mut().build_index(stopped)?;
@@ -215,16 +216,11 @@ impl SegmentBuilder {
         Ok(loaded_segment)
     }
 
-    fn update_quantization(segment: &Segment, stopped: &AtomicBool) -> OperationResult<()> {
-        let config = segment.config();
-        for (vector_name, vector_data) in &segment.vector_data {
+    fn update_quantization(segment: &mut Segment, stopped: &AtomicBool) -> OperationResult<()> {
+        let config = segment.config().clone();
+        for (vector_name, vector_data) in &mut segment.vector_data {
             if let Some(quantization) = config.quantization_config(vector_name) {
-                let segment_path = segment.current_path.as_path();
-                check_process_stopped(stopped)?;
-
-                let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-                let max_threads = match segment
-                    .config()
+                let max_threads = match config
                     .vector_data
                     .get(vector_name)
                     .map(|config| &config.index)
@@ -232,12 +228,19 @@ impl SegmentBuilder {
                     Some(Indexes::Hnsw(hnsw)) => max_rayon_threads(hnsw.max_indexing_threads),
                     _ => 1,
                 };
-                vector_data.vector_storage.borrow_mut().quantize(
-                    &vector_storage_path,
+
+                let segment_path = segment.current_path.as_path();
+                check_process_stopped(stopped)?;
+
+                let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+                let vector_storage = vector_data.vector_storage.borrow();
+                vector_data.quantized_vectors = Some(QuantizedVectors::create(
+                    &vector_storage,
                     quantization,
+                    &vector_storage_path,
                     max_threads,
                     stopped,
-                )?;
+                )?);
             }
         }
         Ok(())

commit 86153086ecf8d821c07fa470a2fbbfdae1071025
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Nov 17 16:22:10 2023 +0100

    Sparse vectors api preparations (#3038)
    
    * Sparse vectors api preparations
    
    generic transpose
    
    remove features
    
    unnecessary local variable
    
    add snake case
    
    * distance in config function

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 2f6fe6996..0d0f70bd3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -218,21 +218,24 @@ impl SegmentBuilder {
 
     fn update_quantization(segment: &mut Segment, stopped: &AtomicBool) -> OperationResult<()> {
         let config = segment.config().clone();
+
         for (vector_name, vector_data) in &mut segment.vector_data {
-            if let Some(quantization) = config.quantization_config(vector_name) {
-                let max_threads = match config
-                    .vector_data
-                    .get(vector_name)
-                    .map(|config| &config.index)
-                {
-                    Some(Indexes::Hnsw(hnsw)) => max_rayon_threads(hnsw.max_indexing_threads),
+            let max_threads = if let Some(config) = config.vector_data.get(vector_name) {
+                match &config.index {
+                    Indexes::Hnsw(hnsw) => max_rayon_threads(hnsw.max_indexing_threads),
                     _ => 1,
-                };
+                }
+            } else {
+                // quantization is applied only for dense vectors
+                continue;
+            };
 
+            if let Some(quantization) = config.quantization_config(vector_name) {
                 let segment_path = segment.current_path.as_path();
                 check_process_stopped(stopped)?;
 
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
+
                 let vector_storage = vector_data.vector_storage.borrow();
                 vector_data.quantized_vectors = Some(QuantizedVectors::create(
                     &vector_storage,

commit 6a701089139466adb6c0417b87668f1a6ffd865e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Dec 4 10:38:58 2023 +0100

    build HNSW with quantized data (#3133)
    
    * build HNSW with quantized data
    
    * review fix

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0d0f70bd3..90f15d63a 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -237,13 +237,20 @@ impl SegmentBuilder {
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
 
                 let vector_storage = vector_data.vector_storage.borrow();
-                vector_data.quantized_vectors = Some(QuantizedVectors::create(
+
+                let quantized_vectors_arc = QuantizedVectors::create(
                     &vector_storage,
                     quantization,
                     &vector_storage_path,
                     max_threads,
                     stopped,
-                )?);
+                )?;
+
+                vector_data.quantized_vectors = Some(quantized_vectors_arc.clone());
+                vector_data
+                    .vector_index
+                    .borrow_mut()
+                    .set_quantized_vectors(Some(quantized_vectors_arc));
             }
         }
         Ok(())

commit b1aed910f23688aead01b484d3ddc9f2d5429e05
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 15 13:00:28 2023 +0000

    Remove quantization update from hnsw index (#3221)
    
    * remove quantization update from hnsw index
    
    * test that hnsw was builded with presented quantization
    
    * are you happy codespell
    
    * prefer method over public field
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 90f15d63a..789eb33d8 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -238,7 +238,7 @@ impl SegmentBuilder {
 
                 let vector_storage = vector_data.vector_storage.borrow();
 
-                let quantized_vectors_arc = QuantizedVectors::create(
+                let quantized_vectors = QuantizedVectors::create(
                     &vector_storage,
                     quantization,
                     &vector_storage_path,
@@ -246,11 +246,7 @@ impl SegmentBuilder {
                     stopped,
                 )?;
 
-                vector_data.quantized_vectors = Some(quantized_vectors_arc.clone());
-                vector_data
-                    .vector_index
-                    .borrow_mut()
-                    .set_quantized_vectors(Some(quantized_vectors_arc));
+                *vector_data.quantized_vectors.borrow_mut() = Some(quantized_vectors);
             }
         }
         Ok(())

commit 19514265330ac9a1049b9439517deb104a5a19ed
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Jan 31 11:56:34 2024 +0100

    Dynamic CPU saturation internals (#3364)
    
    * Move CPU count function to common, fix wrong CPU count in visited list
    
    * Change default number of rayon threads to 8
    
    * Use CPU budget and CPU permits for optimizer tasks to limit utilization
    
    * Respect configured thread limits, use new sane defaults in config
    
    * Fix spelling issues
    
    * Fix test compilation error
    
    * Improve breaking if there is no CPU budget
    
    * Block optimizations until CPU budget, fix potentially getting stuck
    
    Our optimization worker now blocks until CPU budget is available to
    perform the task.
    
    Fix potential issue where optimization worker could get stuck. This
    would happen if no optimization task is started because there's no
    available CPU budget. This ensures the worker is woken up again to
    retry.
    
    * Utilize n-1 CPUs with optimization tasks
    
    * Better handle situations where CPU budget is drained
    
    * Dynamically scale rayon CPU count based on CPU size
    
    * Fix incorrect default for max_indexing_threads conversion
    
    * Respect max_indexing_threads for collection
    
    * Make max_indexing_threads optional, use none to set no limit
    
    * Update property documentation and comments
    
    * Property max_optimization_threads is per shard, not per collection
    
    * If we reached shard optimization limit, skip further checks
    
    * Add remaining TODOs
    
    * Fix spelling mistake
    
    * Align gRPC comment blocks
    
    * Fix compilation errors since last rebase
    
    * Make tests aware of CPU budget
    
    * Use new CPU budget calculation function everywhere
    
    * Make CPU budget configurable in settings, move static budget to common
    
    * Do not use static CPU budget, instance it and pass it through
    
    * Update CPU budget description
    
    * Move heuristic into defaults
    
    * Fix spelling issues
    
    * Move cpu_budget property to a better place
    
    * Move some things around
    
    * Minor review improvements
    
    * Use range match statement for CPU count heuristics
    
    * Systems with 1 or 2 CPUs do not keep cores unallocated by default
    
    * Fix compilation errors since last rebase
    
    * Update lib/segment/src/types.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Update lib/storage/src/content_manager/toc/transfer.rs
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Rename cpu_budget to optimizer_cpu_budget
    
    * Update OpenAPI specification
    
    * Require at least half of the desired CPUs for optimizers
    
    This prevents running optimizations with just one CPU, which could be
    very slow.
    
    * Don't use wildcard in CPU heuristic match statements
    
    * Rename cpu_budget setting to optimizer_cpu_budget
    
    * Update CPU budget comments
    
    * Spell acquire correctly
    
    * Change if-else into match
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    
    * Rename max_rayon_threads to num_rayon_threads, add explanation
    
    * Explain limit in update handler
    
    * Remove numbers for automatic selection of indexing threads
    
    * Inline max_workers variable
    
    * Remove CPU budget from ShardTransferConsensus trait, it is in collection
    
    * small allow(dead_code) => cfg(test)
    
    * Remove now obsolete lazy_static
    
    * Fix incorrect CPU calculation in CPU saturation test
    
    * Make waiting for CPU budget async, don't block current thread
    
    * Prevent deadlock on optimizer signal channel
    
    Do not block the optimization worker task anymore to wait for CPU budget
    to be available. That prevents our optimizer signal channel from being
    drained, blocking incoming updates because the cannot send another
    optimizer signal. Now, prevent blocking this task all together and
    retrigger the optimizers separately when CPU budget is available again.
    
    * Fix incorrect CPU calculation in optimization cancel test
    
    * Rename CPU budget wait function to notify
    
    * Detach API changes from CPU saturation internals
    
    This allows us to merge into a patch version of Qdrant. We can
    reintroduce the API changes in the upcoming minor release to make all of
    it fully functional.
    
    ---------
    
    Co-authored-by: Luis Cosso <luis.cossio@qdrant.com>
    Co-authored-by: Luis Cosso <luis.cossio@outlook.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 789eb33d8..53248986c 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -2,12 +2,15 @@ use std::cmp;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
+
+use common::cpu::CpuPermit;
 
 use super::get_vector_storage_path;
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
-use crate::index::hnsw_index::max_rayon_threads;
+use crate::index::hnsw_index::num_rayon_threads;
 use crate::index::{PayloadIndex, VectorIndex};
 use crate::segment::Segment;
 use crate::segment_constructor::{build_segment, load_segment};
@@ -181,8 +184,15 @@ impl SegmentBuilder {
         Ok(true)
     }
 
-    pub fn build(mut self, stopped: &AtomicBool) -> Result<Segment, OperationError> {
+    pub fn build(
+        mut self,
+        permit: CpuPermit,
+        stopped: &AtomicBool,
+    ) -> Result<Segment, OperationError> {
         {
+            // Arc permit to share it with each vector store
+            let permit = Arc::new(permit);
+
             let mut segment = self.segment.take().ok_or(OperationError::service_error(
                 "Segment building error: created segment not found",
             ))?;
@@ -195,9 +205,20 @@ impl SegmentBuilder {
             Self::update_quantization(&mut segment, stopped)?;
 
             for vector_data in segment.vector_data.values_mut() {
-                vector_data.vector_index.borrow_mut().build_index(stopped)?;
+                vector_data
+                    .vector_index
+                    .borrow_mut()
+                    .build_index(permit.clone(), stopped)?;
             }
 
+            // We're done with CPU-intensive tasks, release CPU permit
+            debug_assert_eq!(
+                Arc::strong_count(&permit),
+                1,
+                "Must release CPU permit Arc everywhere",
+            );
+            drop(permit);
+
             segment.flush(true)?;
             drop(segment);
             // Now segment is evicted from RAM
@@ -222,7 +243,7 @@ impl SegmentBuilder {
         for (vector_name, vector_data) in &mut segment.vector_data {
             let max_threads = if let Some(config) = config.vector_data.get(vector_name) {
                 match &config.index {
-                    Indexes::Hnsw(hnsw) => max_rayon_threads(hnsw.max_indexing_threads),
+                    Indexes::Hnsw(hnsw) => num_rayon_threads(hnsw.max_indexing_threads),
                     _ => 1,
                 }
             } else {

commit 8ae92d47161cbb90b6c211400cc307069858ffc6
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:52:03 2024 +0100

    allow stopping segment loading (#3498)
    
    * allow stopping segment loading
    
    * fix benches

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 53248986c..e7e3bd17c 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -62,7 +62,7 @@ impl SegmentBuilder {
             None => {
                 return Err(OperationError::service_error(
                     "Segment building error: created segment not found",
-                ))
+                ));
             }
         };
         self_segment.version = Some(cmp::max(self_segment.version(), other.version()));
@@ -228,7 +228,7 @@ impl SegmentBuilder {
         std::fs::rename(&self.temp_path, &self.destination_path)
             .describe("Moving segment data after optimization")?;
 
-        let loaded_segment = load_segment(&self.destination_path)?.ok_or_else(|| {
+        let loaded_segment = load_segment(&self.destination_path, stopped)?.ok_or_else(|| {
             OperationError::service_error(format!(
                 "Segment loading error: {}",
                 self.destination_path.display()

commit 87b541bb41560adf4609190cc0a7c1ed1da6e2f3
Author: shylock <tcath2s@gmail.com>
Date:   Thu Feb 15 22:15:05 2024 +0800

    Feat/set payload by key (#3548)
    
    * Support set by key in low level.
    
    * Rename key field.
    
    * Format.
    
    * Pass key.
    
    * Format.
    
    * Test.
    
    * Clippy.
    
    * Fix ci lint.
    
    * Check grpc consistency.
    
    * Update openapi.
    
    * Fix empty key test case.
    
    * Support array index.
    
    * Format.
    
    * Add test for non exists key.
    
    * Clippy fix.
    
    * Add idempotence test.
    
    * Update index by updated payload.
    
    * Add ut for utils.
    
    * Add ut for 1 level key.
    
    * Fix ut.
    
    * Support no exits key.
    
    * Fix test result.
    
    * Fix after rebase
    
    * handle wildcart insertion into non-existing array
    
    * avoid double read of payload during update
    
    * fix missing removing data from index in case if set_payload removes indexed field
    
    ---------
    
    Co-authored-by: Shylock Hg <shylock@DESKTOP-40I855A>
    Co-authored-by: Albert Safin <xzfcpw@gmail.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index e7e3bd17c..41330449b 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -146,6 +146,7 @@ impl SegmentBuilder {
                         payload_index.assign(
                             new_internal_id,
                             &other_payload_index.payload(old_internal_id)?,
+                            &None,
                         )?;
                     }
                     Some(existing_internal_id) => {
@@ -162,6 +163,7 @@ impl SegmentBuilder {
                             payload_index.assign(
                                 new_internal_id,
                                 &other_payload_index.payload(old_internal_id)?,
+                                &None,
                             )?;
                             existing_internal_id
                         } else {

commit 44dafd2f28c1541d1236191e9cfbedcbe5df7560
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Feb 16 16:43:14 2024 +0100

    Do not make up empty payloads during optimization (#3633)
    
    * gRPC fix for empty PointStruct payload
    
    * Do not make up empty payloads during optimization

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 41330449b..520254cde 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -143,11 +143,11 @@ impl SegmentBuilder {
                         // New point, just insert
                         id_tracker.set_link(external_id, new_internal_id)?;
                         id_tracker.set_internal_version(new_internal_id, other_version)?;
-                        payload_index.assign(
-                            new_internal_id,
-                            &other_payload_index.payload(old_internal_id)?,
-                            &None,
-                        )?;
+                        let other_payload = other_payload_index.payload(old_internal_id)?;
+                        // Propagate payload to new segment
+                        if !other_payload.is_empty() {
+                            payload_index.assign(new_internal_id, &other_payload, &None)?;
+                        }
                     }
                     Some(existing_internal_id) => {
                         // Point exists in both: newly constructed and old segments, so we need to merge them
@@ -160,11 +160,11 @@ impl SegmentBuilder {
                             id_tracker.set_link(external_id, new_internal_id)?;
                             id_tracker.set_internal_version(new_internal_id, other_version)?;
                             payload_index.drop(existing_internal_id)?;
-                            payload_index.assign(
-                                new_internal_id,
-                                &other_payload_index.payload(old_internal_id)?,
-                                &None,
-                            )?;
+                            let other_payload = other_payload_index.payload(old_internal_id)?;
+                            // Propagate payload to new segment
+                            if !other_payload.is_empty() {
+                                payload_index.assign(new_internal_id, &other_payload, &None)?;
+                            }
                             existing_internal_id
                         } else {
                             // Old version is still good, do not move anything else

commit f43d9813b6de9a1f6d9833e8627b54ec4861742b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu May 2 16:54:39 2024 +0200

    Clean-up unversioned points (#4156)
    
    * allow unversioned points in optimized (with warning) + remove unversioned points after WAL recovery
    
    * Change unwrap with debug statement to match
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 520254cde..e79f4ca79 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -136,7 +136,16 @@ impl SegmentBuilder {
                         );
                         continue;
                     };
-                let other_version = other_id_tracker.internal_version(old_internal_id).unwrap();
+
+                let other_version = match other_id_tracker.internal_version(old_internal_id) {
+                    Some(version) => version,
+                    None => {
+                        log::debug!(
+                            "Internal version not found for internal id {old_internal_id}, using 0"
+                        );
+                        0
+                    }
+                };
 
                 match id_tracker.internal_id(external_id) {
                     None => {

commit 45b3d94a7f2aa8784535b4d32c41479f25155c35
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu May 16 21:47:43 2024 +0200

    Minor cleanup from Rover's lints (#4249)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index e79f4ca79..b87c7cd30 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -137,15 +137,14 @@ impl SegmentBuilder {
                         continue;
                     };
 
-                let other_version = match other_id_tracker.internal_version(old_internal_id) {
-                    Some(version) => version,
-                    None => {
+                let other_version = other_id_tracker
+                    .internal_version(old_internal_id)
+                    .unwrap_or_else(|| {
                         log::debug!(
                             "Internal version not found for internal id {old_internal_id}, using 0"
                         );
                         0
-                    }
-                };
+                    });
 
                 match id_tracker.internal_id(external_id) {
                     None => {

commit 96ecd2cca8ba311282b5d72c9e41ed71ddca036d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jun 4 11:16:11 2024 +0200

    Fix hnsw full scan threshold (#4369)
    
    * fix hnsw full scan threshold
    
    * add test
    
    * are you happy clippy
    
    * separate open_vector_storage
    
    * remove public fields from builder
    
    * wip: do not create segment in builder before build
    
    * avoid arc in storage test and low-level loading functions
    
    * WIP: remove internal segment from SegmentBuilder
    
    * fmt
    
    * finalize segment builder fixes
    
    * Revert "are you happy clippy"
    
    This reverts commit c04afa698995f75f8b589737c2a794aee03824d8.
    
    * Revert "add test"
    
    This reverts commit 8e7ad6207ed042f25dcd07a16fac7c109b9c5a9e.
    
    * Revert "fix hnsw full scan threshold"
    
    This reverts commit 8904443fcb849cca30885b0b6980b0113ed25c16.
    
    * remove _daatabse from builder
    
    * fix optimizer test
    
    * fix id tracker versions persistence
    
    * do flush for segment components on build
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index b87c7cd30..d349f6d16 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -4,26 +4,44 @@ use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
+use atomic_refcell::AtomicRefCell;
 use common::cpu::CpuPermit;
+use io::storage_version::StorageVersion;
 
-use super::get_vector_storage_path;
+use super::{
+    create_id_tracker, create_payload_storage, create_sparse_vector_index, create_vector_index,
+    get_payload_index_path, get_vector_index_path, get_vector_storage_path, new_segment_path,
+    open_segment_db, open_vector_storage,
+};
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
-use crate::index::hnsw_index::num_rayon_threads;
+use crate::id_tracker::{IdTracker, IdTrackerEnum};
+use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndex, VectorIndex};
-use crate::segment::Segment;
-use crate::segment_constructor::{build_segment, load_segment};
-use crate::types::{Indexes, PayloadFieldSchema, PayloadKeyType, SegmentConfig};
+use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
+use crate::payload_storage::PayloadStorage;
+use crate::segment::{Segment, SegmentVersion};
+use crate::segment_constructor::load_segment;
+use crate::types::{
+    PayloadFieldSchema, PayloadKeyType, SegmentConfig, SegmentState, SeqNumberType,
+};
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
-use crate::vector_storage::VectorStorage;
+use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
 /// Structure for constructing segment out of several other segments
 pub struct SegmentBuilder {
-    pub segment: Option<Segment>,
-    pub destination_path: PathBuf,
-    pub temp_path: PathBuf,
-    pub indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
+    version: SeqNumberType,
+    id_tracker: IdTrackerEnum,
+    payload_storage: PayloadStorageEnum,
+    vector_storages: HashMap<String, VectorStorageEnum>,
+    segment_config: SegmentConfig,
+
+    // The path, where fully created segment will be moved
+    destination_path: PathBuf,
+    // Path to the temporary segment directory
+    temp_path: PathBuf,
+    indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
 }
 
 impl SegmentBuilder {
@@ -32,19 +50,56 @@ impl SegmentBuilder {
         temp_dir: &Path,
         segment_config: &SegmentConfig,
     ) -> OperationResult<Self> {
-        let segment = build_segment(temp_dir, segment_config, true)?;
-        let temp_path = segment.current_path.clone();
+        // When we build a new segment, it is empty at first,
+        // so we can ignore the `stopped` flag
+        let stopped = AtomicBool::new(false);
+
+        let temp_path = new_segment_path(temp_dir);
+
+        let database = open_segment_db(&temp_path, segment_config)?;
+
+        let id_tracker = create_id_tracker(database.clone())?;
+
+        let payload_storage = create_payload_storage(database.clone(), segment_config)?;
+
+        let mut vector_storages = HashMap::new();
+
+        for (vector_name, vector_config) in &segment_config.vector_data {
+            let vector_storage_path = get_vector_storage_path(&temp_path, vector_name);
+            let vector_storage = open_vector_storage(
+                &database,
+                vector_config,
+                &stopped,
+                &vector_storage_path,
+                vector_name,
+            )?;
+
+            vector_storages.insert(vector_name.to_owned(), vector_storage);
+        }
 
         let destination_path = segment_path.join(temp_path.file_name().unwrap());
 
         Ok(SegmentBuilder {
-            segment: Some(segment),
+            version: Default::default(), // default version is 0
+            id_tracker,
+            payload_storage,
+            vector_storages,
+            segment_config: segment_config.clone(),
+
             destination_path,
             temp_path,
             indexed_fields: Default::default(),
         })
     }
 
+    pub fn remove_indexed_field(&mut self, field: &PayloadKeyType) {
+        self.indexed_fields.remove(field);
+    }
+
+    pub fn add_indexed_field(&mut self, field: PayloadKeyType, schema: PayloadFieldSchema) {
+        self.indexed_fields.insert(field, schema);
+    }
+
     /// Update current segment builder with all (not deleted) vectors and payload form `other` segment
     /// Perform index building at the end of update
     ///
@@ -57,15 +112,7 @@ impl SegmentBuilder {
     /// * `bool` - if `true` - data successfully added, if `false` - process was interrupted
     ///
     pub fn update_from(&mut self, other: &Segment, stopped: &AtomicBool) -> OperationResult<bool> {
-        let self_segment = match &mut self.segment {
-            Some(segment) => segment,
-            None => {
-                return Err(OperationError::service_error(
-                    "Segment building error: created segment not found",
-                ));
-            }
-        };
-        self_segment.version = Some(cmp::max(self_segment.version(), other.version()));
+        self.version = cmp::max(self.version, other.version());
 
         let other_id_tracker = other.id_tracker.borrow();
         let other_vector_storages: HashMap<_, _> = other
@@ -77,27 +124,16 @@ impl SegmentBuilder {
             .collect();
         let other_payload_index = other.payload_index.borrow();
 
-        let mut id_tracker = self_segment.id_tracker.borrow_mut();
-        let mut vector_storages: HashMap<_, _> = self_segment
-            .vector_data
-            .iter()
-            .map(|(vector_name, vector_data)| {
-                (
-                    vector_name.to_owned(),
-                    vector_data.vector_storage.borrow_mut(),
-                )
-            })
-            .collect();
-        let mut payload_index = self_segment.payload_index.borrow_mut();
+        let id_tracker = &mut self.id_tracker;
 
-        if vector_storages.len() != other_vector_storages.len() {
+        if self.vector_storages.len() != other_vector_storages.len() {
             return Err(OperationError::service_error(
-                format!("Self and other segments have different vector names count. Self count: {}, other count: {}", vector_storages.len(), other_vector_storages.len()),
+                format!("Self and other segments have different vector names count. Self count: {}, other count: {}", self.vector_storages.len(), other_vector_storages.len()),
             ));
         }
 
         let mut new_internal_range = None;
-        for (vector_name, vector_storage) in &mut vector_storages {
+        for (vector_name, vector_storage) in &mut self.vector_storages {
             check_process_stopped(stopped)?;
             let other_vector_storage = other_vector_storages.get(vector_name).ok_or_else(|| {
                 OperationError::service_error(format!(
@@ -154,7 +190,8 @@ impl SegmentBuilder {
                         let other_payload = other_payload_index.payload(old_internal_id)?;
                         // Propagate payload to new segment
                         if !other_payload.is_empty() {
-                            payload_index.assign(new_internal_id, &other_payload, &None)?;
+                            self.payload_storage
+                                .assign(new_internal_id, &other_payload)?;
                         }
                     }
                     Some(existing_internal_id) => {
@@ -167,11 +204,12 @@ impl SegmentBuilder {
                             id_tracker.drop(external_id)?;
                             id_tracker.set_link(external_id, new_internal_id)?;
                             id_tracker.set_internal_version(new_internal_id, other_version)?;
-                            payload_index.drop(existing_internal_id)?;
+                            self.payload_storage.drop(existing_internal_id)?;
                             let other_payload = other_payload_index.payload(old_internal_id)?;
                             // Propagate payload to new segment
                             if !other_payload.is_empty() {
-                                payload_index.assign(new_internal_id, &other_payload, &None)?;
+                                self.payload_storage
+                                    .assign(new_internal_id, &other_payload)?;
                             }
                             existing_internal_id
                         } else {
@@ -179,7 +217,7 @@ impl SegmentBuilder {
                             // Mark newly added vector as removed
                             new_internal_id
                         };
-                        for vector_storage in vector_storages.values_mut() {
+                        for vector_storage in self.vector_storages.values_mut() {
                             vector_storage.delete_vector(remove_id)?;
                         }
                     }
@@ -191,34 +229,113 @@ impl SegmentBuilder {
             self.indexed_fields.insert(field, payload_schema);
         }
 
+        id_tracker.mapping_flusher()()?;
+        id_tracker.versions_flusher()()?;
+
         Ok(true)
     }
 
-    pub fn build(
-        mut self,
-        permit: CpuPermit,
-        stopped: &AtomicBool,
-    ) -> Result<Segment, OperationError> {
-        {
+    pub fn build(self, permit: CpuPermit, stopped: &AtomicBool) -> Result<Segment, OperationError> {
+        let (temp_path, destination_path) = {
+            let SegmentBuilder {
+                version,
+                id_tracker,
+                payload_storage,
+                mut vector_storages,
+                segment_config,
+                destination_path,
+                temp_path,
+                indexed_fields,
+            } = self;
+
+            let appendable_flag = segment_config.is_appendable();
+
+            payload_storage.flusher()()?;
+            let payload_storage_arc = Arc::new(AtomicRefCell::new(payload_storage));
+
+            id_tracker.mapping_flusher()()?;
+            id_tracker.versions_flusher()()?;
+            let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
+
+            let payload_index_path = get_payload_index_path(temp_path.as_path());
+
+            let mut payload_index = StructPayloadIndex::open(
+                payload_storage_arc,
+                id_tracker_arc.clone(),
+                &payload_index_path,
+                appendable_flag,
+            )?;
+
+            for (field, payload_schema) in indexed_fields {
+                payload_index.set_indexed(&field, payload_schema)?;
+                check_process_stopped(stopped)?;
+            }
+
+            payload_index.flusher()()?;
+            let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
+
             // Arc permit to share it with each vector store
             let permit = Arc::new(permit);
 
-            let mut segment = self.segment.take().ok_or(OperationError::service_error(
-                "Segment building error: created segment not found",
-            ))?;
+            let mut quantized_vectors = Self::update_quantization(
+                &segment_config,
+                &vector_storages,
+                temp_path.as_path(),
+                &permit,
+                stopped,
+            )?;
+
+            for (vector_name, vector_config) in &segment_config.vector_data {
+                let vector_index_path = get_vector_index_path(&temp_path, vector_name);
 
-            for (field, payload_schema) in &self.indexed_fields {
-                segment.create_field_index(segment.version(), field, Some(payload_schema))?;
-                check_process_stopped(stopped)?;
+                let Some(vector_storage) = vector_storages.remove(vector_name) else {
+                    return Err(OperationError::service_error(format!(
+                        "Vector storage for vector name {vector_name} not found on segment build"
+                    )));
+                };
+
+                vector_storage.flusher()()?;
+
+                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+
+                let quantized_vectors = quantized_vectors.remove(vector_name);
+                let quantized_vectors_arc = Arc::new(AtomicRefCell::new(quantized_vectors));
+
+                let mut vector_index = create_vector_index(
+                    vector_config,
+                    &vector_index_path,
+                    id_tracker_arc.clone(),
+                    vector_storage_arc,
+                    payload_index_arc.clone(),
+                    quantized_vectors_arc,
+                )?;
+
+                vector_index.build_index(permit.clone(), stopped)?;
             }
 
-            Self::update_quantization(&mut segment, stopped)?;
+            for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
+                let vector_index_path = get_vector_index_path(&temp_path, vector_name);
+
+                let Some(vector_storage) = vector_storages.remove(vector_name) else {
+                    return Err(OperationError::service_error(format!(
+                        "Vector storage for vector name {vector_name} not found on sparse segment build"
+                    )));
+                };
+
+                vector_storage.flusher()()?;
+
+                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+
+                let mut vector_index = create_sparse_vector_index(
+                    sparse_vector_config.clone(),
+                    &vector_index_path,
+                    id_tracker_arc.clone(),
+                    vector_storage_arc,
+                    payload_index_arc.clone(),
+                    stopped,
+                )?;
 
-            for vector_data in segment.vector_data.values_mut() {
-                vector_data
-                    .vector_index
-                    .borrow_mut()
-                    .build_index(permit.clone(), stopped)?;
+                vector_index.build_index(permit.clone(), stopped)?;
             }
 
             // We're done with CPU-intensive tasks, release CPU permit
@@ -229,57 +346,77 @@ impl SegmentBuilder {
             );
             drop(permit);
 
-            segment.flush(true)?;
-            drop(segment);
-            // Now segment is evicted from RAM
-        }
+            // Finalize the newly created segment by saving config and version
+            Segment::save_state(
+                &SegmentState {
+                    version: Some(version),
+                    config: segment_config,
+                },
+                &temp_path,
+            )?;
+
+            // After version is saved, segment can be loaded on restart
+            SegmentVersion::save(&temp_path)?;
+            // All temp data is evicted from RAM
+            (temp_path, destination_path)
+        };
 
         // Move fully constructed segment into collection directory and load back to RAM
-        std::fs::rename(&self.temp_path, &self.destination_path)
+        std::fs::rename(temp_path, &destination_path)
             .describe("Moving segment data after optimization")?;
 
-        let loaded_segment = load_segment(&self.destination_path, stopped)?.ok_or_else(|| {
+        let loaded_segment = load_segment(&destination_path, stopped)?.ok_or_else(|| {
             OperationError::service_error(format!(
                 "Segment loading error: {}",
-                self.destination_path.display()
+                destination_path.display()
             ))
         })?;
         Ok(loaded_segment)
     }
 
-    fn update_quantization(segment: &mut Segment, stopped: &AtomicBool) -> OperationResult<()> {
-        let config = segment.config().clone();
+    fn update_quantization(
+        segment_config: &SegmentConfig,
+        vector_storages: &HashMap<String, VectorStorageEnum>,
+        temp_path: &Path,
+        permit: &CpuPermit,
+        stopped: &AtomicBool,
+    ) -> OperationResult<HashMap<String, QuantizedVectors>> {
+        let config = segment_config.clone();
 
-        for (vector_name, vector_data) in &mut segment.vector_data {
-            let max_threads = if let Some(config) = config.vector_data.get(vector_name) {
-                match &config.index {
-                    Indexes::Hnsw(hnsw) => num_rayon_threads(hnsw.max_indexing_threads),
-                    _ => 1,
-                }
-            } else {
-                // quantization is applied only for dense vectors
+        let mut quantized_vectors_map = HashMap::new();
+
+        for (vector_name, vector_storage) in vector_storages {
+            let Some(vector_config) = config.vector_data.get(vector_name) else {
                 continue;
             };
 
+            let is_appendable = vector_config.is_appendable();
+
+            // Don't build quantization for appendable vectors
+            if is_appendable {
+                continue;
+            }
+
+            let max_threads = permit.num_cpus as usize;
+
             if let Some(quantization) = config.quantization_config(vector_name) {
-                let segment_path = segment.current_path.as_path();
+                let segment_path = temp_path;
+
                 check_process_stopped(stopped)?;
 
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
 
-                let vector_storage = vector_data.vector_storage.borrow();
-
                 let quantized_vectors = QuantizedVectors::create(
-                    &vector_storage,
+                    vector_storage,
                     quantization,
                     &vector_storage_path,
                     max_threads,
                     stopped,
                 )?;
 
-                *vector_data.quantized_vectors.borrow_mut() = Some(quantized_vectors);
+                quantized_vectors_map.insert(vector_name.to_owned(), quantized_vectors);
             }
         }
-        Ok(())
+        Ok(quantized_vectors_map)
     }
 }

commit 8615ffb56d466ccd537c5f1a997c7e8eb0967566
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 5 12:01:20 2024 +0200

    initialize sparse vectors in the segment builder (#4396)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index d349f6d16..77fa6cd38 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -9,9 +9,10 @@ use common::cpu::CpuPermit;
 use io::storage_version::StorageVersion;
 
 use super::{
-    create_id_tracker, create_payload_storage, create_sparse_vector_index, create_vector_index,
-    get_payload_index_path, get_vector_index_path, get_vector_storage_path, new_segment_path,
-    open_segment_db, open_vector_storage,
+    create_id_tracker, create_payload_storage, create_sparse_vector_index,
+    create_sparse_vector_storage, create_vector_index, get_payload_index_path,
+    get_vector_index_path, get_vector_storage_path, new_segment_path, open_segment_db,
+    open_vector_storage,
 };
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
@@ -77,6 +78,16 @@ impl SegmentBuilder {
             vector_storages.insert(vector_name.to_owned(), vector_storage);
         }
 
+        #[allow(clippy::for_kv_map)]
+        for (vector_name, _sparse_vector_config) in &segment_config.sparse_vector_data {
+            // `_sparse_vector_config` should be used, once we are able to initialize storage with
+            // different datatypes
+
+            let vector_storage =
+                create_sparse_vector_storage(database.clone(), vector_name, &stopped)?;
+            vector_storages.insert(vector_name.to_owned(), vector_storage);
+        }
+
         let destination_path = segment_path.join(temp_path.file_name().unwrap());
 
         Ok(SegmentBuilder {

commit d62a455da1daaf0bcc23248bfa06c8803b0d3e8b
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 17 12:41:38 2024 +0000

    Integrate compressed posting list (attempt 2) (#4453)
    
    * Rename InvertedIndex* -> InvertedIndexCompressed*
    
    * Extract method VectorIndexEnum::fill_idf_statistics
    
    * Extend VectorIndexEnum with new variants
    
    * Introduce sparse::InvertedIndex::Version
    
    * Replace SparseVectorIndexVersion -> InvertedIndex::Version
    
    * Introduce sparse_vector_index::OpenArgs
    
    * SparseVectorIndex::open: do not build index if directory is empty
    
    Otherwise it would build the index twice since `SegmentBuilder::build()`
    calls `::open()`, then `::build_index()`. This restores the old (<=v1.9)
    behavior.
    
    * Renames

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 77fa6cd38..eb9b03755 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -18,6 +18,7 @@ use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
 use crate::id_tracker::{IdTracker, IdTrackerEnum};
+use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndex, VectorIndex};
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
@@ -337,14 +338,14 @@ impl SegmentBuilder {
 
                 let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
 
-                let mut vector_index = create_sparse_vector_index(
-                    sparse_vector_config.clone(),
-                    &vector_index_path,
-                    id_tracker_arc.clone(),
-                    vector_storage_arc,
-                    payload_index_arc.clone(),
+                let mut vector_index = create_sparse_vector_index(SparseVectorIndexOpenArgs {
+                    config: sparse_vector_config.index,
+                    id_tracker: id_tracker_arc.clone(),
+                    vector_storage: vector_storage_arc.clone(),
+                    payload_index: payload_index_arc.clone(),
+                    path: &vector_index_path,
                     stopped,
-                )?;
+                })?;
 
                 vector_index.build_index(permit.clone(), stopped)?;
             }

commit 1a4d8c827a4bc4b93d001c551db552dab17d0840
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jun 24 12:44:34 2024 +0000

    Move build_index out of VectorIndex (#4490)
    
    * Move build_index out of VectorIndex
    
    * Build index in HNSWIndex::open()
    
    * Introduce HnswIndexOpenArgs
    
    * Proper deletion
    
    * Improve tests
    
    * HNSW::open(): add warn, comment and assert
    
    * Revert to making up the config if it does not exist

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index eb9b03755..d21c24d41 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -20,7 +20,7 @@ use crate::entry::entry_point::SegmentEntry;
 use crate::id_tracker::{IdTracker, IdTrackerEnum};
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::{PayloadIndex, VectorIndex};
+use crate::index::PayloadIndex;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::PayloadStorage;
 use crate::segment::{Segment, SegmentVersion};
@@ -313,16 +313,16 @@ impl SegmentBuilder {
                 let quantized_vectors = quantized_vectors.remove(vector_name);
                 let quantized_vectors_arc = Arc::new(AtomicRefCell::new(quantized_vectors));
 
-                let mut vector_index = create_vector_index(
+                create_vector_index(
                     vector_config,
                     &vector_index_path,
                     id_tracker_arc.clone(),
                     vector_storage_arc,
                     payload_index_arc.clone(),
                     quantized_vectors_arc,
+                    Some(permit.clone()),
+                    stopped,
                 )?;
-
-                vector_index.build_index(permit.clone(), stopped)?;
             }
 
             for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
@@ -338,16 +338,15 @@ impl SegmentBuilder {
 
                 let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
 
-                let mut vector_index = create_sparse_vector_index(SparseVectorIndexOpenArgs {
+                create_sparse_vector_index(SparseVectorIndexOpenArgs {
                     config: sparse_vector_config.index,
                     id_tracker: id_tracker_arc.clone(),
                     vector_storage: vector_storage_arc.clone(),
                     payload_index: payload_index_arc.clone(),
                     path: &vector_index_path,
                     stopped,
+                    tick_progress: || (),
                 })?;
-
-                vector_index.build_index(permit.clone(), stopped)?;
             }
 
             // We're done with CPU-intensive tasks, release CPU permit

commit 6650e5885f6b622161741fb7ecfe181b81a346bf
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Jul 17 19:45:22 2024 +0200

    Merge pull request #4403
    
    * add immutable_id_tracker
    
    * add dirty flag in test
    
    * don't use immutable_id_tracker for now
    
    * improve and integrate new immutable_id_tracker
    
    * split external_to_internal into two BTreeMaps
    
    * apply rquested changes
    
    * delay mmap writes until flush
    
    * remove unnecessary clone
    
    * single source of truth for file path
    
    * use custom de/serialization for more performance
    
    * disable id tracker and fix codespell
    
    * improve code & test
    
    * Other minor nitpicks
    
    * Apply suggestions from code review
    
    * fix rebase issues
    
    * basic custom mappings storage implementation
    
    * add tests & fix bugs
    
    * add more tests and fix bugs
    
    * undo .codespellrc
    
    * disable immutable_id_tracker completely for now
    
    * fix clippy
    
    * Remove unnecessary pub
    
    * minor renaming

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index d21c24d41..6fb19ee8b 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -9,7 +9,7 @@ use common::cpu::CpuPermit;
 use io::storage_version::StorageVersion;
 
 use super::{
-    create_id_tracker, create_payload_storage, create_sparse_vector_index,
+    create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
     create_sparse_vector_storage, create_vector_index, get_payload_index_path,
     get_vector_index_path, get_vector_storage_path, new_segment_path, open_segment_db,
     open_vector_storage,
@@ -60,7 +60,8 @@ impl SegmentBuilder {
 
         let database = open_segment_db(&temp_path, segment_config)?;
 
-        let id_tracker = create_id_tracker(database.clone())?;
+        let id_tracker =
+            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(database.clone())?);
 
         let payload_storage = create_payload_storage(database.clone(), segment_config)?;
 
@@ -349,6 +350,16 @@ impl SegmentBuilder {
                 })?;
             }
 
+            // TODO: uncomment when releasing the next version! Also in segment_constructor_base.rs:403
+            // Make the IdTracker immutable if segment is not appendable.
+            /*
+            if !appendable_flag {
+                if let IdTrackerEnum::MutableIdTracker(mutable) = &*id_tracker_arc.borrow() {
+                    mutable.make_immutable(&temp_path)?;
+                }
+            }
+             */
+
             // We're done with CPU-intensive tasks, release CPU permit
             debug_assert_eq!(
                 Arc::strong_count(&permit),

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 6fb19ee8b..c4e1c43a7 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,12 +1,17 @@
 use std::cmp;
 use std::collections::HashMap;
+use std::hash::{Hash, Hasher};
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
+use ahash::AHasher;
 use atomic_refcell::AtomicRefCell;
+use bitvec::macros::internal::funty::Integral;
 use common::cpu::CpuPermit;
+use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
+use parking_lot::RwLock;
 
 use super::{
     create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
@@ -18,6 +23,7 @@ use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
 use crate::id_tracker::{IdTracker, IdTrackerEnum};
+use crate::index::field_index::FieldIndex;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::PayloadIndex;
@@ -26,7 +32,7 @@ use crate::payload_storage::PayloadStorage;
 use crate::segment::{Segment, SegmentVersion};
 use crate::segment_constructor::load_segment;
 use crate::types::{
-    PayloadFieldSchema, PayloadKeyType, SegmentConfig, SegmentState, SeqNumberType,
+    ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig, SegmentState, SeqNumberType,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
@@ -44,6 +50,9 @@ pub struct SegmentBuilder {
     // Path to the temporary segment directory
     temp_path: PathBuf,
     indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
+
+    // Payload key to deframent data to
+    defragment_keys: Vec<PayloadKeyType>,
 }
 
 impl SegmentBuilder {
@@ -102,9 +111,14 @@ impl SegmentBuilder {
             destination_path,
             temp_path,
             indexed_fields: Default::default(),
+            defragment_keys: vec![],
         })
     }
 
+    pub fn set_defragment_keys(&mut self, keys: Vec<PayloadKeyType>) {
+        self.defragment_keys = keys;
+    }
+
     pub fn remove_indexed_field(&mut self, field: &PayloadKeyType) {
         self.indexed_fields.remove(field);
     }
@@ -113,117 +127,225 @@ impl SegmentBuilder {
         self.indexed_fields.insert(field, schema);
     }
 
-    /// Update current segment builder with all (not deleted) vectors and payload form `other` segment
-    /// Perform index building at the end of update
+    /// Get ordering value from the payload index
     ///
-    /// # Arguments
+    /// Ordering value is used to sort points to keep points with the same payload together
+    /// Under the assumption that points are queried together, this will reduce the number of
+    /// random disk reads.
     ///
-    /// * `other` - segment to add into construction
+    /// Note: This value doesn't guarantee strict ordering in ambiguous cases.
+    ///       It should only be used in optimization purposes, not for correctness.
+    fn _get_ordering_value(internal_id: PointOffsetType, indices: &[FieldIndex]) -> u64 {
+        let mut ordering = 0;
+        for payload_index in indices {
+            match payload_index {
+                FieldIndex::IntMapIndex(index) => {
+                    if let Some(numbers) = index.get_values(internal_id) {
+                        for number in numbers {
+                            ordering = ordering.wrapping_add(*number as u64);
+                        }
+                    }
+                    break;
+                }
+                FieldIndex::KeywordIndex(index) => {
+                    if let Some(keywords) = index.get_values(internal_id) {
+                        for keyword in keywords {
+                            let mut hasher = AHasher::default();
+                            keyword.hash(&mut hasher);
+                            ordering = ordering.wrapping_add(hasher.finish());
+                        }
+                    }
+                    break;
+                }
+                FieldIndex::IntIndex(index) => {
+                    if let Some(numbers) = index.get_values(internal_id) {
+                        for number in numbers {
+                            ordering = ordering.wrapping_add(number as u64);
+                        }
+                    }
+                    break;
+                }
+                FieldIndex::FloatIndex(index) => {
+                    if let Some(numbers) = index.get_values(internal_id) {
+                        for number in numbers {
+                            // Bit-level conversion of f64 to u64 preserves ordering
+                            // (for positive numbers)
+                            //
+                            // 0.001 -> 4562254508917369340
+                            // 0.01  -> 4576918229304087675
+                            // 0.05  -> 4587366580439587226
+                            // 0.1   -> 4591870180066957722
+                            // 1     -> 4607182418800017408
+                            // 2     -> 4611686018427387904
+                            // 10    -> 4621819117588971520
+                            ordering = ordering.wrapping_add(number.to_bits());
+                        }
+                    }
+                    break;
+                }
+                FieldIndex::DatetimeIndex(index) => {
+                    if let Some(dates) = index.get_values(internal_id) {
+                        for date in dates {
+                            ordering = ordering.wrapping_add(date as u64);
+                        }
+                    }
+                    break;
+                }
+                FieldIndex::GeoIndex(_) => {}
+                FieldIndex::FullTextIndex(_) => {}
+                FieldIndex::BinaryIndex(_) => {}
+            }
+        }
+        ordering
+    }
+
+    /// Update current segment builder with all (not deleted) vectors and payload from `segments`.
+    /// Also defragments if the `defragment_key` is set.
+    /// However only points in the same call get defragmented and grouped together.
+    /// Therefore this function should only be called once, unless this behavior is desired.
     ///
     /// # Result
     ///
     /// * `bool` - if `true` - data successfully added, if `false` - process was interrupted
     ///
-    pub fn update_from(&mut self, other: &Segment, stopped: &AtomicBool) -> OperationResult<bool> {
-        self.version = cmp::max(self.version, other.version());
+    pub fn update(
+        &mut self,
+        segments: &[Arc<RwLock<Segment>>],
+        stopped: &AtomicBool,
+    ) -> OperationResult<bool> {
+        if segments.is_empty() {
+            return Ok(true);
+        }
+
+        let segment_guards: Vec<_> = segments.iter().map(|segment| segment.read()).collect();
 
-        let other_id_tracker = other.id_tracker.borrow();
-        let other_vector_storages: HashMap<_, _> = other
-            .vector_data
+        let mut merged_points: HashMap<ExtendedPointId, PositionedPointMetadata> = HashMap::new();
+
+        for (segment_index, segment) in segment_guards.iter().enumerate() {
+            for external_id in segment.iter_points() {
+                let version = segment.point_version(external_id).unwrap_or(0);
+                merged_points
+                    .entry(external_id)
+                    .and_modify(|entry| {
+                        if entry.version < version {
+                            entry.segment_index = segment_index;
+                            entry.version = version;
+                        }
+                    })
+                    .or_insert_with(|| {
+                        let internal_id = segment.get_internal_id(external_id).unwrap();
+                        PositionedPointMetadata {
+                            segment_index,
+                            internal_id,
+                            external_id,
+                            version,
+                            ordering: 0,
+                        }
+                    });
+            }
+        }
+
+        let payloads: Vec<_> = segment_guards
             .iter()
-            .map(|(vector_name, vector_data)| {
-                (vector_name.to_owned(), vector_data.vector_storage.borrow())
-            })
+            .map(|i| i.payload_index.borrow())
             .collect();
-        let other_payload_index = other.payload_index.borrow();
 
-        let id_tracker = &mut self.id_tracker;
+        let mut points_to_insert: Vec<_> = merged_points.into_values().collect();
 
-        if self.vector_storages.len() != other_vector_storages.len() {
-            return Err(OperationError::service_error(
-                format!("Self and other segments have different vector names count. Self count: {}, other count: {}", self.vector_storages.len(), other_vector_storages.len()),
-            ));
+        for defragment_key in &self.defragment_keys {
+            for point_data in &mut points_to_insert {
+                let Some(payload_indices) = payloads[point_data.segment_index]
+                    .field_indexes
+                    .get(defragment_key)
+                else {
+                    continue;
+                };
+
+                point_data.ordering = point_data.ordering.wrapping_add(Self::_get_ordering_value(
+                    point_data.internal_id,
+                    payload_indices,
+                ));
+            }
+        }
+
+        if !self.defragment_keys.is_empty() {
+            points_to_insert.sort_unstable_by_key(|i| i.ordering);
         }
 
+        let src_segment_max_version = segment_guards.iter().map(|i| i.version()).max().unwrap();
+        self.version = cmp::max(self.version, src_segment_max_version);
+
+        let vector_storages: Vec<_> = segment_guards.iter().map(|i| &i.vector_data).collect();
+
         let mut new_internal_range = None;
         for (vector_name, vector_storage) in &mut self.vector_storages {
             check_process_stopped(stopped)?;
-            let other_vector_storage = other_vector_storages.get(vector_name).ok_or_else(|| {
-                OperationError::service_error(format!(
+
+            let other_vector_storages = vector_storages
+                .iter()
+                .map(|i| {
+                    let other_vector_storage = i.get(vector_name).ok_or_else(|| {
+                        OperationError::service_error(format!(
                     "Cannot update from other segment because if missing vector name {vector_name}"
-                ))
-            })?;
-            let internal_range = vector_storage.update_from(
-                other_vector_storage,
-                &mut other_id_tracker.iter_ids(),
-                stopped,
-            )?;
-            match new_internal_range.clone() {
+                        ))
+                    })?;
+
+                    Ok(other_vector_storage.vector_storage.borrow())
+                })
+                .collect::<Result<Vec<_>, OperationError>>()?;
+
+            let mut iter = points_to_insert.iter().map(|point_data| {
+                let other_vector_storage = &other_vector_storages[point_data.segment_index];
+                let vec = other_vector_storage.get_vector(point_data.internal_id);
+                let vector_deleted = other_vector_storage.is_deleted_vector(point_data.internal_id);
+                (point_data.internal_id, vec, vector_deleted)
+            });
+
+            let internal_range = vector_storage.update_from(&mut iter, stopped)?;
+
+            match &new_internal_range {
                 Some(new_internal_range) => {
-                    if new_internal_range != internal_range {
+                    if new_internal_range != &internal_range {
                         return Err(OperationError::service_error(
                             "Internal ids range mismatch between self segment vectors and other segment vectors",
                         ));
                     }
                 }
-                None => new_internal_range = Some(internal_range.clone()),
+                None => new_internal_range = Some(internal_range),
             }
         }
 
         if let Some(new_internal_range) = new_internal_range {
-            let internal_id_iter = new_internal_range.zip(other_id_tracker.iter_ids());
+            let internal_id_iter = new_internal_range.zip(points_to_insert.iter());
 
-            for (new_internal_id, old_internal_id) in internal_id_iter {
+            for (new_internal_id, point_data) in internal_id_iter {
                 check_process_stopped(stopped)?;
 
-                let external_id =
-                    if let Some(external_id) = other_id_tracker.external_id(old_internal_id) {
-                        external_id
-                    } else {
-                        log::warn!(
-                            "Cannot find external id for internal id {old_internal_id}, skipping"
-                        );
-                        continue;
-                    };
-
-                let other_version = other_id_tracker
-                    .internal_version(old_internal_id)
-                    .unwrap_or_else(|| {
-                        log::debug!(
-                            "Internal version not found for internal id {old_internal_id}, using 0"
-                        );
-                        0
-                    });
+                let old_internal_id = point_data.internal_id;
 
-                match id_tracker.internal_id(external_id) {
-                    None => {
-                        // New point, just insert
-                        id_tracker.set_link(external_id, new_internal_id)?;
-                        id_tracker.set_internal_version(new_internal_id, other_version)?;
-                        let other_payload = other_payload_index.payload(old_internal_id)?;
-                        // Propagate payload to new segment
-                        if !other_payload.is_empty() {
-                            self.payload_storage
-                                .assign(new_internal_id, &other_payload)?;
-                        }
-                    }
+                let other_payload = payloads[point_data.segment_index].payload(old_internal_id)?;
+
+                match self.id_tracker.internal_id(point_data.external_id) {
                     Some(existing_internal_id) => {
-                        // Point exists in both: newly constructed and old segments, so we need to merge them
-                        // Based on version
-                        let existing_version =
-                            id_tracker.internal_version(existing_internal_id).unwrap();
-                        let remove_id = if existing_version < other_version {
+                        debug_assert!(
+                            false,
+                            "This code should not be reachable, cause points were resolved with `merged_points`"
+                        );
+
+                        let existing_external_version = self
+                            .id_tracker
+                            .internal_version(existing_internal_id)
+                            .unwrap();
+
+                        let remove_id = if existing_external_version < point_data.version {
                             // Other version is the newest, remove the existing one and replace
-                            id_tracker.drop(external_id)?;
-                            id_tracker.set_link(external_id, new_internal_id)?;
-                            id_tracker.set_internal_version(new_internal_id, other_version)?;
+                            self.id_tracker.drop(point_data.external_id)?;
+                            self.id_tracker
+                                .set_link(point_data.external_id, new_internal_id)?;
+                            self.id_tracker
+                                .set_internal_version(new_internal_id, point_data.version)?;
                             self.payload_storage.drop(existing_internal_id)?;
-                            let other_payload = other_payload_index.payload(old_internal_id)?;
-                            // Propagate payload to new segment
-                            if !other_payload.is_empty() {
-                                self.payload_storage
-                                    .assign(new_internal_id, &other_payload)?;
-                            }
+
                             existing_internal_id
                         } else {
                             // Old version is still good, do not move anything else
@@ -234,16 +356,30 @@ impl SegmentBuilder {
                             vector_storage.delete_vector(remove_id)?;
                         }
                     }
+                    None => {
+                        self.id_tracker
+                            .set_link(point_data.external_id, new_internal_id)?;
+                        self.id_tracker
+                            .set_internal_version(new_internal_id, point_data.version)?;
+                    }
+                }
+
+                // Propagate payload to new segment
+                if !other_payload.is_empty() {
+                    self.payload_storage
+                        .assign(new_internal_id, &other_payload)?;
                 }
             }
         }
 
-        for (field, payload_schema) in other.payload_index.borrow().indexed_fields() {
-            self.indexed_fields.insert(field, payload_schema);
+        for payload in payloads {
+            for (field, payload_schema) in payload.indexed_fields() {
+                self.indexed_fields.insert(field, payload_schema);
+            }
         }
 
-        id_tracker.mapping_flusher()()?;
-        id_tracker.versions_flusher()()?;
+        self.id_tracker.mapping_flusher()()?;
+        self.id_tracker.versions_flusher()()?;
 
         Ok(true)
     }
@@ -259,6 +395,7 @@ impl SegmentBuilder {
                 destination_path,
                 temp_path,
                 indexed_fields,
+                defragment_keys: _,
             } = self;
 
             let appendable_flag = segment_config.is_appendable();
@@ -442,3 +579,12 @@ impl SegmentBuilder {
         Ok(quantized_vectors_map)
     }
 }
+
+/// Internal point ID and metadata of a point.
+struct PositionedPointMetadata {
+    segment_index: usize,
+    internal_id: PointOffsetType,
+    external_id: ExtendedPointId,
+    version: SeqNumberType,
+    ordering: u64,
+}

commit 745b1621dffbbf13c23a6ba6514c65502f983ad2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 26 16:59:34 2024 +0200

    UUID payload index (#4738)
    
    * add UuidIndex
    
    * fix clippy
    
    * rebase to dev
    
    * update api docs
    
    * don't use wrapper type for Uuid index
    
    * rebase to `dev`
    
    * remove existence checking
    
    * rename UuidPayloadKeyType => UuidIntType
    
    * apply review changes
    
    * rebase to dev
    
    * post-rebase fixes
    
    * Improve estimation
    
    * Improve naming
    
    * Apply suggestions from code review
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * use u128 in histogram and improve uuid sorting
    
    * Also allow defragmentation for completely random Uuids
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index c4e1c43a7..109717997 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -12,6 +12,7 @@ use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
 use parking_lot::RwLock;
+use uuid::Uuid;
 
 use super::{
     create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
@@ -191,6 +192,28 @@ impl SegmentBuilder {
                     }
                     break;
                 }
+                FieldIndex::UuidIndex(index) => {
+                    if let Some(ids) = index.get_values(internal_id) {
+                        for id in ids {
+                            let uuid = Uuid::from_u128(id);
+
+                            // Not all Uuid versions hold timestamp data. The most common version, v4 for example is completely
+                            // random and can't be sorted. To still allow defragmentation, we assume that usually the same
+                            // version gets used for a payload key and implement an alternative sorting criteria, that just
+                            // takes the Uuids bytes to group equal Uuids together.
+                            if let Some(timestamp) = uuid.get_timestamp() {
+                                ordering = ordering.wrapping_add(timestamp.to_gregorian().0);
+                            } else {
+                                // First part of u128
+                                ordering = ordering.wrapping_add((id >> 64) as u64);
+
+                                // Second part of u128
+                                ordering = ordering.wrapping_add(id as u64);
+                            }
+                        }
+                    }
+                    break;
+                }
                 FieldIndex::GeoIndex(_) => {}
                 FieldIndex::FullTextIndex(_) => {}
                 FieldIndex::BinaryIndex(_) => {}

commit 30a6aa4e742db5a7f1e55bcb3f4485ff05046ae5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 26 18:38:35 2024 +0200

    Enable new idtracker (#4692)
    
    * enable immutable_id_tracker and in_memory_id_tracker
    
    * remove redundent flush
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 109717997..882cee73b 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -23,6 +23,8 @@ use super::{
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
+use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
+use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum};
 use crate::index::field_index::FieldIndex;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
@@ -70,8 +72,11 @@ impl SegmentBuilder {
 
         let database = open_segment_db(&temp_path, segment_config)?;
 
-        let id_tracker =
-            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(database.clone())?);
+        let id_tracker = if segment_config.is_appendable() {
+            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(database.clone())?)
+        } else {
+            IdTrackerEnum::InMemoryIdTracker(InMemoryIdTracker::new())
+        };
 
         let payload_storage = create_payload_storage(database.clone(), segment_config)?;
 
@@ -401,9 +406,6 @@ impl SegmentBuilder {
             }
         }
 
-        self.id_tracker.mapping_flusher()()?;
-        self.id_tracker.versions_flusher()()?;
-
         Ok(true)
     }
 
@@ -426,6 +428,19 @@ impl SegmentBuilder {
             payload_storage.flusher()()?;
             let payload_storage_arc = Arc::new(AtomicRefCell::new(payload_storage));
 
+            let id_tracker = match id_tracker {
+                IdTrackerEnum::InMemoryIdTracker(in_memory_id_tracker) => {
+                    let (versions, mappings) = in_memory_id_tracker.into_internal();
+                    let immutable_id_tracker =
+                        ImmutableIdTracker::new(&temp_path, &versions, mappings)?;
+                    IdTrackerEnum::ImmutableIdTracker(immutable_id_tracker)
+                }
+                IdTrackerEnum::MutableIdTracker(_) => id_tracker,
+                IdTrackerEnum::ImmutableIdTracker(_) => {
+                    unreachable!("ImmutableIdTracker should not be used for building segment")
+                }
+            };
+
             id_tracker.mapping_flusher()()?;
             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
@@ -510,16 +525,6 @@ impl SegmentBuilder {
                 })?;
             }
 
-            // TODO: uncomment when releasing the next version! Also in segment_constructor_base.rs:403
-            // Make the IdTracker immutable if segment is not appendable.
-            /*
-            if !appendable_flag {
-                if let IdTrackerEnum::MutableIdTracker(mutable) = &*id_tracker_arc.borrow() {
-                    mutable.make_immutable(&temp_path)?;
-                }
-            }
-             */
-
             // We're done with CPU-intensive tasks, release CPU permit
             debug_assert_eq!(
                 Arc::strong_count(&permit),

commit a9784f7f60822649d5251ccad533b50e5e29b028
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Aug 2 13:01:19 2024 +0200

    Mmap map index (#4779)
    
    * define mmap map index
    
    add point to values
    
    add mmap hash map
    
    are you happy fmt
    
    use new mmap hashmap methods
    
    build index
    
    saturating_sub
    
    are you happy clippy
    
    fix tests build
    
    * integrate facets for mmap index
    
    * mmap tests
    
    * fix ci
    
    * review remarks
    
    * review remarks

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 882cee73b..5e0d21e6f 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -148,7 +148,7 @@ impl SegmentBuilder {
                 FieldIndex::IntMapIndex(index) => {
                     if let Some(numbers) = index.get_values(internal_id) {
                         for number in numbers {
-                            ordering = ordering.wrapping_add(*number as u64);
+                            ordering = ordering.wrapping_add(number as u64);
                         }
                     }
                     break;

commit 624b29daa431fe3683174e738aba0c0c5e625119
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 20:00:03 2024 +0000

    Integration tests for on-disk payload indices (#4819)
    
    * refactor: let SegmentBuilder::update take unlocked segments
    
    * style: split long lines
    
    * refactor: introduce TestSegments
    
    * test: add tests for mmap indices

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 5e0d21e6f..666a7f883 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -11,7 +11,6 @@ use bitvec::macros::internal::funty::Integral;
 use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
-use parking_lot::RwLock;
 use uuid::Uuid;
 
 use super::{
@@ -236,20 +235,14 @@ impl SegmentBuilder {
     ///
     /// * `bool` - if `true` - data successfully added, if `false` - process was interrupted
     ///
-    pub fn update(
-        &mut self,
-        segments: &[Arc<RwLock<Segment>>],
-        stopped: &AtomicBool,
-    ) -> OperationResult<bool> {
+    pub fn update(&mut self, segments: &[&Segment], stopped: &AtomicBool) -> OperationResult<bool> {
         if segments.is_empty() {
             return Ok(true);
         }
 
-        let segment_guards: Vec<_> = segments.iter().map(|segment| segment.read()).collect();
-
         let mut merged_points: HashMap<ExtendedPointId, PositionedPointMetadata> = HashMap::new();
 
-        for (segment_index, segment) in segment_guards.iter().enumerate() {
+        for (segment_index, segment) in segments.iter().enumerate() {
             for external_id in segment.iter_points() {
                 let version = segment.point_version(external_id).unwrap_or(0);
                 merged_points
@@ -273,10 +266,7 @@ impl SegmentBuilder {
             }
         }
 
-        let payloads: Vec<_> = segment_guards
-            .iter()
-            .map(|i| i.payload_index.borrow())
-            .collect();
+        let payloads: Vec<_> = segments.iter().map(|i| i.payload_index.borrow()).collect();
 
         let mut points_to_insert: Vec<_> = merged_points.into_values().collect();
 
@@ -300,10 +290,10 @@ impl SegmentBuilder {
             points_to_insert.sort_unstable_by_key(|i| i.ordering);
         }
 
-        let src_segment_max_version = segment_guards.iter().map(|i| i.version()).max().unwrap();
+        let src_segment_max_version = segments.iter().map(|i| i.version()).max().unwrap();
         self.version = cmp::max(self.version, src_segment_max_version);
 
-        let vector_storages: Vec<_> = segment_guards.iter().map(|i| &i.vector_data).collect();
+        let vector_storages: Vec<_> = segments.iter().map(|i| &i.vector_data).collect();
 
         let mut new_internal_range = None;
         for (vector_name, vector_storage) in &mut self.vector_storages {

commit 564c085d4b0e20fbc3861dae0a8f25f07c9e1696
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Aug 7 19:45:42 2024 +0200

    On-disk Uuid hybrid-index (#4825)
    
    * Migrate uuid index to mmap
    
    * add uuid numeric index
    
    * select correct index + tenants
    
    * Only serialize if necessary
    
    * select correct index
    
    * reset Cargo.toml
    
    * review: use only map index for uuid for now
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 666a7f883..6792f37bb 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -196,25 +196,15 @@ impl SegmentBuilder {
                     }
                     break;
                 }
+                FieldIndex::UuidMapIndex(index) => {
+                    if let Some(ids) = index.get_values(internal_id) {
+                        uuid_hash(&mut ordering, ids);
+                    }
+                    break;
+                }
                 FieldIndex::UuidIndex(index) => {
                     if let Some(ids) = index.get_values(internal_id) {
-                        for id in ids {
-                            let uuid = Uuid::from_u128(id);
-
-                            // Not all Uuid versions hold timestamp data. The most common version, v4 for example is completely
-                            // random and can't be sorted. To still allow defragmentation, we assume that usually the same
-                            // version gets used for a payload key and implement an alternative sorting criteria, that just
-                            // takes the Uuids bytes to group equal Uuids together.
-                            if let Some(timestamp) = uuid.get_timestamp() {
-                                ordering = ordering.wrapping_add(timestamp.to_gregorian().0);
-                            } else {
-                                // First part of u128
-                                ordering = ordering.wrapping_add((id >> 64) as u64);
-
-                                // Second part of u128
-                                ordering = ordering.wrapping_add(id as u64);
-                            }
-                        }
+                        uuid_hash(&mut ordering, ids);
                     }
                     break;
                 }
@@ -598,6 +588,29 @@ impl SegmentBuilder {
     }
 }
 
+fn uuid_hash<I>(hash: &mut u64, ids: I)
+where
+    I: Iterator<Item = u128>,
+{
+    for id in ids {
+        let uuid = Uuid::from_u128(id);
+
+        // Not all Uuid versions hold timestamp data. The most common version, v4 for example is completely
+        // random and can't be sorted. To still allow defragmentation, we assume that usually the same
+        // version gets used for a payload key and implement an alternative sorting criteria, that just
+        // takes the Uuids bytes to group equal Uuids together.
+        if let Some(timestamp) = uuid.get_timestamp() {
+            *hash = hash.wrapping_add(timestamp.to_gregorian().0);
+        } else {
+            // First part of u128
+            *hash = hash.wrapping_add((id >> 64) as u64);
+
+            // Second part of u128
+            *hash = hash.wrapping_add(id as u64);
+        }
+    }
+}
+
 /// Internal point ID and metadata of a point.
 struct PositionedPointMetadata {
     segment_index: usize,

commit 6e48f588a1de3090b2959e1589fc08984634ebe6
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Aug 26 20:02:08 2024 +0200

    Fix point deletions on mmap segment optimization (#4952)
    
    * Don't use ID but current point offset when optimizing dense mmap storage
    
    This change now matches the implementation in all other storage types.
    
    * Remove now obsolete point offsets in update_from point iterator
    
    * Fix test

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 6792f37bb..4d1ada48e 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -306,7 +306,7 @@ impl SegmentBuilder {
                 let other_vector_storage = &other_vector_storages[point_data.segment_index];
                 let vec = other_vector_storage.get_vector(point_data.internal_id);
                 let vector_deleted = other_vector_storage.is_deleted_vector(point_data.internal_id);
-                (point_data.internal_id, vec, vector_deleted)
+                (vec, vector_deleted)
             });
 
             let internal_range = vector_storage.update_from(&mut iter, stopped)?;

commit 4b429214cc3feeede5d5ab2912fad76523219c4e
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Tue Aug 27 11:30:57 2024 -0400

    Integer and UUID facets (#4946)
    
    * move FacetIndex into facet_index.rs
    
    * add support for integer facets
    
    * add support for uuid facets
    
    * use separate internal structure
    
    * rename FacetValue::Keyword into FacetValue::String in REST
    
    * fix after rebase

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 4d1ada48e..b168f920e 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -147,7 +147,7 @@ impl SegmentBuilder {
                 FieldIndex::IntMapIndex(index) => {
                     if let Some(numbers) = index.get_values(internal_id) {
                         for number in numbers {
-                            ordering = ordering.wrapping_add(number as u64);
+                            ordering = ordering.wrapping_add(*number as u64);
                         }
                     }
                     break;
@@ -198,7 +198,7 @@ impl SegmentBuilder {
                 }
                 FieldIndex::UuidMapIndex(index) => {
                     if let Some(ids) = index.get_values(internal_id) {
-                        uuid_hash(&mut ordering, ids);
+                        uuid_hash(&mut ordering, ids.copied());
                     }
                     break;
                 }

commit 4f59f72c02e6b62f027c88888831c1bf60f24019
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 16 12:42:11 2024 +0200

    Rename payload storage operations for consistency (#5087)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index b168f920e..3100f9a5a 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -331,7 +331,8 @@ impl SegmentBuilder {
 
                 let old_internal_id = point_data.internal_id;
 
-                let other_payload = payloads[point_data.segment_index].payload(old_internal_id)?;
+                let other_payload =
+                    payloads[point_data.segment_index].get_payload(old_internal_id)?;
 
                 match self.id_tracker.internal_id(point_data.external_id) {
                     Some(existing_internal_id) => {
@@ -352,7 +353,7 @@ impl SegmentBuilder {
                                 .set_link(point_data.external_id, new_internal_id)?;
                             self.id_tracker
                                 .set_internal_version(new_internal_id, point_data.version)?;
-                            self.payload_storage.drop(existing_internal_id)?;
+                            self.payload_storage.clear(existing_internal_id)?;
 
                             existing_internal_id
                         } else {
@@ -374,8 +375,7 @@ impl SegmentBuilder {
 
                 // Propagate payload to new segment
                 if !other_payload.is_empty() {
-                    self.payload_storage
-                        .assign(new_internal_id, &other_payload)?;
+                    self.payload_storage.set(new_internal_id, &other_payload)?;
                 }
             }
         }

commit 0c755cdc0cdd9974c919fde3648b1bc37cb7e94d
Author: Dominik Kellner <dkellner@dkellner.de>
Date:   Mon Sep 16 20:47:31 2024 +0200

    Clean temporary segments if optimization is cancelled (#5090)
    
    This uses `TempDir` and comes with its caveats, e.g. the temporary segment
    directory will not be deleted if the process exits. This should not be a
    problem in practice, as all temporary segments get deleted when the shard is
    loaded (see PR #2319).
    
    Fixes #2978.

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 3100f9a5a..f483c1a75 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -11,6 +11,7 @@ use bitvec::macros::internal::funty::Integral;
 use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
+use tempfile::TempDir;
 use uuid::Uuid;
 
 use super::{
@@ -49,8 +50,8 @@ pub struct SegmentBuilder {
 
     // The path, where fully created segment will be moved
     destination_path: PathBuf,
-    // Path to the temporary segment directory
-    temp_path: PathBuf,
+    // The temporary segment directory
+    temp_dir: TempDir,
     indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
 
     // Payload key to deframent data to
@@ -67,9 +68,9 @@ impl SegmentBuilder {
         // so we can ignore the `stopped` flag
         let stopped = AtomicBool::new(false);
 
-        let temp_path = new_segment_path(temp_dir);
+        let temp_dir = create_temp_dir(temp_dir)?;
 
-        let database = open_segment_db(&temp_path, segment_config)?;
+        let database = open_segment_db(temp_dir.path(), segment_config)?;
 
         let id_tracker = if segment_config.is_appendable() {
             IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(database.clone())?)
@@ -82,7 +83,7 @@ impl SegmentBuilder {
         let mut vector_storages = HashMap::new();
 
         for (vector_name, vector_config) in &segment_config.vector_data {
-            let vector_storage_path = get_vector_storage_path(&temp_path, vector_name);
+            let vector_storage_path = get_vector_storage_path(temp_dir.path(), vector_name);
             let vector_storage = open_vector_storage(
                 &database,
                 vector_config,
@@ -104,7 +105,7 @@ impl SegmentBuilder {
             vector_storages.insert(vector_name.to_owned(), vector_storage);
         }
 
-        let destination_path = segment_path.join(temp_path.file_name().unwrap());
+        let destination_path = new_segment_path(segment_path);
 
         Ok(SegmentBuilder {
             version: Default::default(), // default version is 0
@@ -114,7 +115,7 @@ impl SegmentBuilder {
             segment_config: segment_config.clone(),
 
             destination_path,
-            temp_path,
+            temp_dir,
             indexed_fields: Default::default(),
             defragment_keys: vec![],
         })
@@ -390,7 +391,7 @@ impl SegmentBuilder {
     }
 
     pub fn build(self, permit: CpuPermit, stopped: &AtomicBool) -> Result<Segment, OperationError> {
-        let (temp_path, destination_path) = {
+        let (temp_dir, destination_path) = {
             let SegmentBuilder {
                 version,
                 id_tracker,
@@ -398,7 +399,7 @@ impl SegmentBuilder {
                 mut vector_storages,
                 segment_config,
                 destination_path,
-                temp_path,
+                temp_dir,
                 indexed_fields,
                 defragment_keys: _,
             } = self;
@@ -412,7 +413,7 @@ impl SegmentBuilder {
                 IdTrackerEnum::InMemoryIdTracker(in_memory_id_tracker) => {
                     let (versions, mappings) = in_memory_id_tracker.into_internal();
                     let immutable_id_tracker =
-                        ImmutableIdTracker::new(&temp_path, &versions, mappings)?;
+                        ImmutableIdTracker::new(temp_dir.path(), &versions, mappings)?;
                     IdTrackerEnum::ImmutableIdTracker(immutable_id_tracker)
                 }
                 IdTrackerEnum::MutableIdTracker(_) => id_tracker,
@@ -425,7 +426,7 @@ impl SegmentBuilder {
             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
 
-            let payload_index_path = get_payload_index_path(temp_path.as_path());
+            let payload_index_path = get_payload_index_path(temp_dir.path());
 
             let mut payload_index = StructPayloadIndex::open(
                 payload_storage_arc,
@@ -448,13 +449,13 @@ impl SegmentBuilder {
             let mut quantized_vectors = Self::update_quantization(
                 &segment_config,
                 &vector_storages,
-                temp_path.as_path(),
+                temp_dir.path(),
                 &permit,
                 stopped,
             )?;
 
             for (vector_name, vector_config) in &segment_config.vector_data {
-                let vector_index_path = get_vector_index_path(&temp_path, vector_name);
+                let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
 
                 let Some(vector_storage) = vector_storages.remove(vector_name) else {
                     return Err(OperationError::service_error(format!(
@@ -482,7 +483,7 @@ impl SegmentBuilder {
             }
 
             for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
-                let vector_index_path = get_vector_index_path(&temp_path, vector_name);
+                let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
 
                 let Some(vector_storage) = vector_storages.remove(vector_name) else {
                     return Err(OperationError::service_error(format!(
@@ -519,17 +520,17 @@ impl SegmentBuilder {
                     version: Some(version),
                     config: segment_config,
                 },
-                &temp_path,
+                temp_dir.path(),
             )?;
 
             // After version is saved, segment can be loaded on restart
-            SegmentVersion::save(&temp_path)?;
+            SegmentVersion::save(temp_dir.path())?;
             // All temp data is evicted from RAM
-            (temp_path, destination_path)
+            (temp_dir, destination_path)
         };
 
         // Move fully constructed segment into collection directory and load back to RAM
-        std::fs::rename(temp_path, &destination_path)
+        std::fs::rename(temp_dir.into_path(), &destination_path)
             .describe("Moving segment data after optimization")?;
 
         let loaded_segment = load_segment(&destination_path, stopped)?.ok_or_else(|| {
@@ -611,6 +612,19 @@ where
     }
 }
 
+fn create_temp_dir(parent_path: &Path) -> Result<TempDir, OperationError> {
+    // Ensure parent path exists
+    std::fs::create_dir_all(parent_path)
+        .and_then(|_| TempDir::with_prefix_in("segment_builder_", parent_path))
+        .map_err(|err| {
+            OperationError::service_error(format!(
+                "Could not create temp directory in `{}`: {}",
+                parent_path.display(),
+                err
+            ))
+        })
+}
+
 /// Internal point ID and metadata of a point.
 struct PositionedPointMetadata {
     segment_index: usize,

commit bcf05d9e231d55f0c4317081c36d3ebc0a2de8c8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Oct 25 18:47:03 2024 +0200

    HasVector filtering condition (#5303)
    
    * include vector storage into struct vector index
    
    * implement has_vector
    
    * generate schemas
    
    * refactor query filter optimizer so avoid too many function arguments
    
    * test + fix for sparse vectors
    
    * Update lib/segment/src/index/struct_payload_index.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * Update lib/segment/src/index/query_optimization/optimizer.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * fmt
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index f483c1a75..6836b52f3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -426,23 +426,6 @@ impl SegmentBuilder {
             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
 
-            let payload_index_path = get_payload_index_path(temp_dir.path());
-
-            let mut payload_index = StructPayloadIndex::open(
-                payload_storage_arc,
-                id_tracker_arc.clone(),
-                &payload_index_path,
-                appendable_flag,
-            )?;
-
-            for (field, payload_schema) in indexed_fields {
-                payload_index.set_indexed(&field, payload_schema)?;
-                check_process_stopped(stopped)?;
-            }
-
-            payload_index.flusher()()?;
-            let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
-
             // Arc permit to share it with each vector store
             let permit = Arc::new(permit);
 
@@ -454,9 +437,9 @@ impl SegmentBuilder {
                 stopped,
             )?;
 
-            for (vector_name, vector_config) in &segment_config.vector_data {
-                let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
+            let mut vector_storages_arc = HashMap::new();
 
+            for vector_name in segment_config.vector_data.keys() {
                 let Some(vector_storage) = vector_storages.remove(vector_name) else {
                     return Err(OperationError::service_error(format!(
                         "Vector storage for vector name {vector_name} not found on segment build"
@@ -467,6 +450,44 @@ impl SegmentBuilder {
 
                 let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
 
+                vector_storages_arc.insert(vector_name.to_owned(), vector_storage_arc);
+            }
+
+            for vector_name in segment_config.sparse_vector_data.keys() {
+                let Some(vector_storage) = vector_storages.remove(vector_name) else {
+                    return Err(OperationError::service_error(format!(
+                        "Vector storage for vector name {vector_name} not found on sparse segment build"
+                    )));
+                };
+
+                vector_storage.flusher()()?;
+
+                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+
+                vector_storages_arc.insert(vector_name.to_owned(), vector_storage_arc);
+            }
+
+            let payload_index_path = get_payload_index_path(temp_dir.path());
+
+            let mut payload_index = StructPayloadIndex::open(
+                payload_storage_arc,
+                id_tracker_arc.clone(),
+                vector_storages_arc.clone(),
+                &payload_index_path,
+                appendable_flag,
+            )?;
+
+            for (field, payload_schema) in indexed_fields {
+                payload_index.set_indexed(&field, payload_schema)?;
+                check_process_stopped(stopped)?;
+            }
+
+            payload_index.flusher()()?;
+            let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
+
+            for (vector_name, vector_config) in &segment_config.vector_data {
+                let vector_storage_arc = vector_storages_arc.remove(vector_name).unwrap();
+                let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
                 let quantized_vectors = quantized_vectors.remove(vector_name);
                 let quantized_vectors_arc = Arc::new(AtomicRefCell::new(quantized_vectors));
 
@@ -485,15 +506,7 @@ impl SegmentBuilder {
             for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
                 let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
 
-                let Some(vector_storage) = vector_storages.remove(vector_name) else {
-                    return Err(OperationError::service_error(format!(
-                        "Vector storage for vector name {vector_name} not found on sparse segment build"
-                    )));
-                };
-
-                vector_storage.flusher()()?;
-
-                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+                let vector_storage_arc = vector_storages_arc.remove(vector_name).unwrap();
 
                 create_sparse_vector_index(SparseVectorIndexOpenArgs {
                     config: sparse_vector_config.index,

commit 6c162656f3a23a6e6601a58cf69f44bdcea0ab00
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 13 08:49:42 2024 -0600

    Backward compatibility for mmap payload storage (#5398)
    
    * support mmap storage backward compat
    
    * fix clippy
    
    * review fixes + bump + restore Cargo.lock
    
    * fix clippy
    
    * map_err instead of match
    
    * add sanity tests for payload storage trait
    
    * fix clippy
    
    * error conversion
    
    * test persistance too
    
    * add config to enable mmap storage (#5434)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 6836b52f3..ab7671888 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -78,7 +78,8 @@ impl SegmentBuilder {
             IdTrackerEnum::InMemoryIdTracker(InMemoryIdTracker::new())
         };
 
-        let payload_storage = create_payload_storage(database.clone(), segment_config)?;
+        let payload_storage =
+            create_payload_storage(database.clone(), segment_config, segment_path)?;
 
         let mut vector_storages = HashMap::new();
 

commit 82daa2121c17402f55a6ff86095c1c225df4a593
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Tue Nov 26 11:33:27 2024 -0600

    Refactor bool index (#5524)
    
    * rename binary->bool
    
    * restructure bool_index module
    
    * rename Boolean->Bool
    
    * rename memory_bool_index -> simple_bool_index

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index ab7671888..7233c667e 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -212,7 +212,7 @@ impl SegmentBuilder {
                 }
                 FieldIndex::GeoIndex(_) => {}
                 FieldIndex::FullTextIndex(_) => {}
-                FieldIndex::BinaryIndex(_) => {}
+                FieldIndex::BoolIndex(_) => {}
             }
         }
         ordering

commit ec90e162ec49c5990ff0635e180da420d3af46f6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 27 16:59:46 2024 +0100

    Fix path to new payload storage for optimized segments (#5530)
    
    * Fix path to storage for optimized segment
    
    * add minimal test
    
    * clippy

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 7233c667e..662b4059e 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -54,13 +54,13 @@ pub struct SegmentBuilder {
     temp_dir: TempDir,
     indexed_fields: HashMap<PayloadKeyType, PayloadFieldSchema>,
 
-    // Payload key to deframent data to
+    // Payload key to defragment data to
     defragment_keys: Vec<PayloadKeyType>,
 }
 
 impl SegmentBuilder {
     pub fn new(
-        segment_path: &Path,
+        segments_path: &Path,
         temp_dir: &Path,
         segment_config: &SegmentConfig,
     ) -> OperationResult<Self> {
@@ -79,7 +79,7 @@ impl SegmentBuilder {
         };
 
         let payload_storage =
-            create_payload_storage(database.clone(), segment_config, segment_path)?;
+            create_payload_storage(database.clone(), segment_config, temp_dir.path())?;
 
         let mut vector_storages = HashMap::new();
 
@@ -106,7 +106,7 @@ impl SegmentBuilder {
             vector_storages.insert(vector_name.to_owned(), vector_storage);
         }
 
-        let destination_path = new_segment_path(segment_path);
+        let destination_path = new_segment_path(segments_path);
 
         Ok(SegmentBuilder {
             version: Default::default(), // default version is 0

commit c10c145a754b3825a60aaaa143fe91b5b98502b0
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Wed Nov 27 11:45:16 2024 -0600

    Compatibility for mmap sparse vectors (#5454)
    
    * implement mmap sparse vector storage
    
    * add to VectorStorageEnum
    
    * clippy
    
    * add tests, fix both simple and mmap storages
    
    * smol correction on total_vector_count
    
    * add sparse storage type to config
    
    * fix reading config without storage type
    
    * generate openapi
    
    * use blob_store by path
    
    * hidden setting to enable new storage
    
    * validate existing path in `BlobStore::open()`
    
    * use new dir for each sparse vector name
    
    * fix and rename `max_point_offset`
    
    Plus some extra refactors
    
    * add storage compat test, to always check both storages work
    
    * fix opening of storage + other misc fixes
    
    * FIX!!!
    
    `Unset` operations in the Tracker weren't updating the
    `next_pointer_id`. So, when reopening the storage, those points wouldn't
    get marked as deleted in the bitslice, thus creating the illusion that
    they should exist, when they did not.
    
    * refactor naming from `iter_*` to `for_each_*`
    
    * fix checking for BlobStore existance
    
    * fix typo
    
    * fix error message
    
    * better docs for open_or_create
    
    * fix after rebase

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 662b4059e..85feaaea8 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -96,13 +96,17 @@ impl SegmentBuilder {
             vector_storages.insert(vector_name.to_owned(), vector_storage);
         }
 
-        #[allow(clippy::for_kv_map)]
-        for (vector_name, _sparse_vector_config) in &segment_config.sparse_vector_data {
-            // `_sparse_vector_config` should be used, once we are able to initialize storage with
-            // different datatypes
+        for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
+            let vector_storage_path = get_vector_storage_path(temp_dir.path(), vector_name);
+
+            let vector_storage = create_sparse_vector_storage(
+                database.clone(),
+                &vector_storage_path,
+                vector_name,
+                &sparse_vector_config.storage_type,
+                &stopped,
+            )?;
 
-            let vector_storage =
-                create_sparse_vector_storage(database.clone(), vector_name, &stopped)?;
             vector_storages.insert(vector_name.to_owned(), vector_storage);
         }
 

commit eec20443090117ba3d485a1e30e977278bda923d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Nov 28 22:03:11 2024 +0100

    it is easy if you know where to look (#5543)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 85feaaea8..59fdb9e33 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -241,23 +241,22 @@ impl SegmentBuilder {
         for (segment_index, segment) in segments.iter().enumerate() {
             for external_id in segment.iter_points() {
                 let version = segment.point_version(external_id).unwrap_or(0);
+                let internal_id = segment.get_internal_id(external_id).unwrap();
                 merged_points
                     .entry(external_id)
                     .and_modify(|entry| {
                         if entry.version < version {
                             entry.segment_index = segment_index;
                             entry.version = version;
+                            entry.internal_id = internal_id;
                         }
                     })
-                    .or_insert_with(|| {
-                        let internal_id = segment.get_internal_id(external_id).unwrap();
-                        PositionedPointMetadata {
-                            segment_index,
-                            internal_id,
-                            external_id,
-                            version,
-                            ordering: 0,
-                        }
+                    .or_insert_with(|| PositionedPointMetadata {
+                        segment_index,
+                        internal_id,
+                        external_id,
+                        version,
+                        ordering: 0,
                     });
             }
         }

commit 4f99e728aa0aff938211c6085050a0c803d61765
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Dec 5 00:58:49 2024 +0100

    GPU HNSW integration (#5535)
    
    * gpu hnsw
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 59fdb9e33..3a220e3d1 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -394,7 +394,11 @@ impl SegmentBuilder {
         Ok(true)
     }
 
-    pub fn build(self, permit: CpuPermit, stopped: &AtomicBool) -> Result<Segment, OperationError> {
+    pub fn build(
+        self,
+        mut permit: CpuPermit,
+        stopped: &AtomicBool,
+    ) -> Result<Segment, OperationError> {
         let (temp_dir, destination_path) = {
             let SegmentBuilder {
                 version,
@@ -430,9 +434,6 @@ impl SegmentBuilder {
             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
 
-            // Arc permit to share it with each vector store
-            let permit = Arc::new(permit);
-
             let mut quantized_vectors = Self::update_quantization(
                 &segment_config,
                 &vector_storages,
@@ -489,6 +490,28 @@ impl SegmentBuilder {
             payload_index.flusher()()?;
             let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
 
+            // Try to lock GPU device.
+            #[cfg(feature = "gpu")]
+            let gpu_devices_manager = crate::index::hnsw_index::gpu::GPU_DEVICES_MANAGER.read();
+            #[cfg(feature = "gpu")]
+            let gpu_device = gpu_devices_manager
+                .as_ref()
+                .map(|devices_manager| devices_manager.lock_device(stopped))
+                .transpose()?
+                .flatten();
+            #[cfg(not(feature = "gpu"))]
+            let gpu_device = None;
+
+            // If GPU is enabled, release all CPU cores except one.
+            if let Some(_gpu_device) = &gpu_device {
+                if permit.num_cpus > 1 {
+                    permit.release_count(permit.num_cpus - 1);
+                }
+            }
+
+            // Arc permit to share it with each vector store
+            let permit = Arc::new(permit);
+
             for (vector_name, vector_config) in &segment_config.vector_data {
                 let vector_storage_arc = vector_storages_arc.remove(vector_name).unwrap();
                 let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
@@ -503,6 +526,7 @@ impl SegmentBuilder {
                     payload_index_arc.clone(),
                     quantized_vectors_arc,
                     Some(permit.clone()),
+                    gpu_device.as_ref(),
                     stopped,
                 )?;
             }

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 3a220e3d1..d816c01aa 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -8,6 +8,7 @@ use std::sync::Arc;
 use ahash::AHasher;
 use atomic_refcell::AtomicRefCell;
 use bitvec::macros::internal::funty::Integral;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::cpu::CpuPermit;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
@@ -336,8 +337,8 @@ impl SegmentBuilder {
 
                 let old_internal_id = point_data.internal_id;
 
-                let other_payload =
-                    payloads[point_data.segment_index].get_payload(old_internal_id)?;
+                let other_payload = payloads[point_data.segment_index]
+                    .get_payload(old_internal_id, &HardwareCounterCell::disposable())?; // Internal operation, no measurement needed!
 
                 match self.id_tracker.internal_id(point_data.external_id) {
                     Some(existing_internal_id) => {

commit 4c178230e3076243979dcab89c18079c11e42b54
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 22 14:21:27 2025 +0000

    Optimize `merged_points` computation in `SegmentBuilder::update()` (#5820)
    
    * Optimize `merged_points` computation in `SegmentBuilder::update()`
    
    * Fixes

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index d816c01aa..02b5fd2e3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -1,6 +1,7 @@
 use std::cmp;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
+use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
@@ -10,8 +11,10 @@ use atomic_refcell::AtomicRefCell;
 use bitvec::macros::internal::funty::Integral;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::cpu::CpuPermit;
+use common::small_uint::U24;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
+use itertools::Itertools;
 use tempfile::TempDir;
 use uuid::Uuid;
 
@@ -26,7 +29,7 @@ use crate::common::operation_error::{check_process_stopped, OperationError, Oper
 use crate::entry::entry_point::SegmentEntry;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
-use crate::id_tracker::{IdTracker, IdTrackerEnum};
+use crate::id_tracker::{for_each_unique_point, IdTracker, IdTrackerEnum};
 use crate::index::field_index::FieldIndex;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
@@ -36,7 +39,8 @@ use crate::payload_storage::PayloadStorage;
 use crate::segment::{Segment, SegmentVersion};
 use crate::segment_constructor::load_segment;
 use crate::types::{
-    ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig, SegmentState, SeqNumberType,
+    CompactExtendedPointId, ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig,
+    SegmentState, SeqNumberType,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
@@ -237,38 +241,38 @@ impl SegmentBuilder {
             return Ok(true);
         }
 
-        let mut merged_points: HashMap<ExtendedPointId, PositionedPointMetadata> = HashMap::new();
-
-        for (segment_index, segment) in segments.iter().enumerate() {
-            for external_id in segment.iter_points() {
-                let version = segment.point_version(external_id).unwrap_or(0);
-                let internal_id = segment.get_internal_id(external_id).unwrap();
-                merged_points
-                    .entry(external_id)
-                    .and_modify(|entry| {
-                        if entry.version < version {
-                            entry.segment_index = segment_index;
-                            entry.version = version;
-                            entry.internal_id = internal_id;
-                        }
-                    })
-                    .or_insert_with(|| PositionedPointMetadata {
-                        segment_index,
-                        internal_id,
-                        external_id,
-                        version,
-                        ordering: 0,
-                    });
-            }
+        struct PointData {
+            external_id: CompactExtendedPointId,
+            /// [`CompactExtendedPointId`] is 17 bytes, we reduce
+            /// `segment_index` to 3 bytes to avoid paddings and align nicely.
+            segment_index: U24,
+            internal_id: PointOffsetType,
+            version: u64,
+            ordering: u64,
         }
 
-        let payloads: Vec<_> = segments.iter().map(|i| i.payload_index.borrow()).collect();
+        if segments.len() > U24::MAX as usize {
+            return Err(OperationError::service_error("Too many segments to update"));
+        }
 
-        let mut points_to_insert: Vec<_> = merged_points.into_values().collect();
+        let mut points_to_insert = Vec::new();
+        let locked_id_trackers = segments.iter().map(|s| s.id_tracker.borrow()).collect_vec();
+        for_each_unique_point(locked_id_trackers.iter().map(|i| i.deref()), |item| {
+            points_to_insert.push(PointData {
+                external_id: CompactExtendedPointId::from(item.external_id),
+                segment_index: U24::new_wrapped(item.tracker_index as u32),
+                internal_id: item.internal_id,
+                version: item.version,
+                ordering: 0,
+            });
+        });
+        drop(locked_id_trackers);
+
+        let payloads: Vec<_> = segments.iter().map(|i| i.payload_index.borrow()).collect();
 
         for defragment_key in &self.defragment_keys {
             for point_data in &mut points_to_insert {
-                let Some(payload_indices) = payloads[point_data.segment_index]
+                let Some(payload_indices) = payloads[point_data.segment_index.get() as usize]
                     .field_indexes
                     .get(defragment_key)
                 else {
@@ -309,7 +313,8 @@ impl SegmentBuilder {
                 .collect::<Result<Vec<_>, OperationError>>()?;
 
             let mut iter = points_to_insert.iter().map(|point_data| {
-                let other_vector_storage = &other_vector_storages[point_data.segment_index];
+                let other_vector_storage =
+                    &other_vector_storages[point_data.segment_index.get() as usize];
                 let vec = other_vector_storage.get_vector(point_data.internal_id);
                 let vector_deleted = other_vector_storage.is_deleted_vector(point_data.internal_id);
                 (vec, vector_deleted)
@@ -337,10 +342,13 @@ impl SegmentBuilder {
 
                 let old_internal_id = point_data.internal_id;
 
-                let other_payload = payloads[point_data.segment_index]
+                let other_payload = payloads[point_data.segment_index.get() as usize]
                     .get_payload(old_internal_id, &HardwareCounterCell::disposable())?; // Internal operation, no measurement needed!
 
-                match self.id_tracker.internal_id(point_data.external_id) {
+                match self
+                    .id_tracker
+                    .internal_id(ExtendedPointId::from(point_data.external_id))
+                {
                     Some(existing_internal_id) => {
                         debug_assert!(
                             false,
@@ -354,9 +362,12 @@ impl SegmentBuilder {
 
                         let remove_id = if existing_external_version < point_data.version {
                             // Other version is the newest, remove the existing one and replace
-                            self.id_tracker.drop(point_data.external_id)?;
                             self.id_tracker
-                                .set_link(point_data.external_id, new_internal_id)?;
+                                .drop(ExtendedPointId::from(point_data.external_id))?;
+                            self.id_tracker.set_link(
+                                ExtendedPointId::from(point_data.external_id),
+                                new_internal_id,
+                            )?;
                             self.id_tracker
                                 .set_internal_version(new_internal_id, point_data.version)?;
                             self.payload_storage.clear(existing_internal_id)?;
@@ -372,8 +383,10 @@ impl SegmentBuilder {
                         }
                     }
                     None => {
-                        self.id_tracker
-                            .set_link(point_data.external_id, new_internal_id)?;
+                        self.id_tracker.set_link(
+                            ExtendedPointId::from(point_data.external_id),
+                            new_internal_id,
+                        )?;
                         self.id_tracker
                             .set_internal_version(new_internal_id, point_data.version)?;
                     }
@@ -666,12 +679,3 @@ fn create_temp_dir(parent_path: &Path) -> Result<TempDir, OperationError> {
             ))
         })
 }
-
-/// Internal point ID and metadata of a point.
-struct PositionedPointMetadata {
-    segment_index: usize,
-    internal_id: PointOffsetType,
-    external_id: ExtendedPointId,
-    version: SeqNumberType,
-    ordering: u64,
-}

commit b0eb8d3431b19ed8beaeb1ceee7872d07d620314
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 10:58:25 2025 +0100

    Io measurement rename functions (#5816)
    
    * replace _measured functions with original name
    
    * Rename more functions

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 02b5fd2e3..036691f69 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -394,7 +394,11 @@ impl SegmentBuilder {
 
                 // Propagate payload to new segment
                 if !other_payload.is_empty() {
-                    self.payload_storage.set(new_internal_id, &other_payload)?;
+                    self.payload_storage.set(
+                        new_internal_id,
+                        &other_payload,
+                        &HardwareCounterCell::disposable(),
+                    )?;
                 }
             }
         }

commit c815a1bd43fb326ad2c100b72e9d916b1f3b616e
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 12:23:47 2025 +0100

    Implement more IO measurements for PayloadStorage (#5822)
    
    * Finish io measurement for payload storage
    
    * Remove done TODOs
    
    * review remarks
    
    * make signature of `wipe()` consistent
    
    * Remove hardware_counter from tracker.rs and make interfaces consistent
    
    * Add hw_counter to payloads update_storage function from dev

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 036691f69..6506a4ee9 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -334,6 +334,8 @@ impl SegmentBuilder {
             }
         }
 
+        let hw_counter = HardwareCounterCell::disposable(); // Disposable counter for internal operations.
+
         if let Some(new_internal_range) = new_internal_range {
             let internal_id_iter = new_internal_range.zip(points_to_insert.iter());
 
@@ -343,7 +345,7 @@ impl SegmentBuilder {
                 let old_internal_id = point_data.internal_id;
 
                 let other_payload = payloads[point_data.segment_index.get() as usize]
-                    .get_payload(old_internal_id, &HardwareCounterCell::disposable())?; // Internal operation, no measurement needed!
+                    .get_payload(old_internal_id, &hw_counter)?; // Internal operation, no measurement needed!
 
                 match self
                     .id_tracker
@@ -370,7 +372,8 @@ impl SegmentBuilder {
                             )?;
                             self.id_tracker
                                 .set_internal_version(new_internal_id, point_data.version)?;
-                            self.payload_storage.clear(existing_internal_id)?;
+                            self.payload_storage
+                                .clear(existing_internal_id, &hw_counter)?;
 
                             existing_internal_id
                         } else {

commit dc421536eabcc3cfbfc428c316ff7412024c076f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 00:09:57 2025 +0000

    Split HNSWIndex::open and HNSWIndex::build (#5853)
    
    * HNSWSearchesTelemetry::new()
    
    * Split HNSWIndex::open and HNSWIndex::build

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 6506a4ee9..9ab5e9c59 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -20,9 +20,8 @@ use uuid::Uuid;
 
 use super::{
     create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
-    create_sparse_vector_storage, create_vector_index, get_payload_index_path,
-    get_vector_index_path, get_vector_storage_path, new_segment_path, open_segment_db,
-    open_vector_storage,
+    create_sparse_vector_storage, get_payload_index_path, get_vector_index_path,
+    get_vector_storage_path, new_segment_path, open_segment_db, open_vector_storage,
 };
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
@@ -37,7 +36,9 @@ use crate::index::PayloadIndex;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::PayloadStorage;
 use crate::segment::{Segment, SegmentVersion};
-use crate::segment_constructor::load_segment;
+use crate::segment_constructor::{
+    build_vector_index, load_segment, VectorIndexBuildArgs, VectorIndexOpenArgs,
+};
 use crate::types::{
     CompactExtendedPointId, ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig,
     SegmentState, SeqNumberType,
@@ -534,21 +535,22 @@ impl SegmentBuilder {
             let permit = Arc::new(permit);
 
             for (vector_name, vector_config) in &segment_config.vector_data {
-                let vector_storage_arc = vector_storages_arc.remove(vector_name).unwrap();
-                let vector_index_path = get_vector_index_path(temp_dir.path(), vector_name);
-                let quantized_vectors = quantized_vectors.remove(vector_name);
-                let quantized_vectors_arc = Arc::new(AtomicRefCell::new(quantized_vectors));
-
-                create_vector_index(
+                build_vector_index(
                     vector_config,
-                    &vector_index_path,
-                    id_tracker_arc.clone(),
-                    vector_storage_arc,
-                    payload_index_arc.clone(),
-                    quantized_vectors_arc,
-                    Some(permit.clone()),
-                    gpu_device.as_ref(),
-                    stopped,
+                    VectorIndexOpenArgs {
+                        path: &get_vector_index_path(temp_dir.path(), vector_name),
+                        id_tracker: id_tracker_arc.clone(),
+                        vector_storage: vector_storages_arc.remove(vector_name).unwrap(),
+                        payload_index: payload_index_arc.clone(),
+                        quantized_vectors: Arc::new(AtomicRefCell::new(
+                            quantized_vectors.remove(vector_name),
+                        )),
+                    },
+                    VectorIndexBuildArgs {
+                        permit: permit.clone(),
+                        gpu_device: gpu_device.as_ref(),
+                        stopped,
+                    },
                 )?;
             }
 

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 9ab5e9c59..0b1a83b67 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -41,7 +41,7 @@ use crate::segment_constructor::{
 };
 use crate::types::{
     CompactExtendedPointId, ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig,
-    SegmentState, SeqNumberType,
+    SegmentState, SeqNumberType, VectorNameBuf,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
@@ -51,7 +51,7 @@ pub struct SegmentBuilder {
     version: SeqNumberType,
     id_tracker: IdTrackerEnum,
     payload_storage: PayloadStorageEnum,
-    vector_storages: HashMap<String, VectorStorageEnum>,
+    vector_storages: HashMap<VectorNameBuf, VectorStorageEnum>,
     segment_config: SegmentConfig,
 
     // The path, where fully created segment will be moved
@@ -608,11 +608,11 @@ impl SegmentBuilder {
 
     fn update_quantization(
         segment_config: &SegmentConfig,
-        vector_storages: &HashMap<String, VectorStorageEnum>,
+        vector_storages: &HashMap<VectorNameBuf, VectorStorageEnum>,
         temp_path: &Path,
         permit: &CpuPermit,
         stopped: &AtomicBool,
-    ) -> OperationResult<HashMap<String, QuantizedVectors>> {
+    ) -> OperationResult<HashMap<VectorNameBuf, QuantizedVectors>> {
         let config = segment_config.clone();
 
         let mut quantized_vectors_map = HashMap::new();

commit 64d5beb141dd17acbfc9d5ab58a81b41bef30b08
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jan 27 06:54:13 2025 +0000

    Pass `old_indices` to `HNSWIndex::new` (#5835)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0b1a83b67..6cc9ebc63 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -32,7 +32,7 @@ use crate::id_tracker::{for_each_unique_point, IdTracker, IdTrackerEnum};
 use crate::index::field_index::FieldIndex;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
-use crate::index::PayloadIndex;
+use crate::index::{PayloadIndex, VectorIndexEnum};
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::PayloadStorage;
 use crate::segment::{Segment, SegmentVersion};
@@ -51,7 +51,7 @@ pub struct SegmentBuilder {
     version: SeqNumberType,
     id_tracker: IdTrackerEnum,
     payload_storage: PayloadStorageEnum,
-    vector_storages: HashMap<VectorNameBuf, VectorStorageEnum>,
+    vector_data: HashMap<VectorNameBuf, VectorData>,
     segment_config: SegmentConfig,
 
     // The path, where fully created segment will be moved
@@ -64,6 +64,11 @@ pub struct SegmentBuilder {
     defragment_keys: Vec<PayloadKeyType>,
 }
 
+struct VectorData {
+    vector_storage: VectorStorageEnum,
+    old_indices: Vec<Arc<AtomicRefCell<VectorIndexEnum>>>,
+}
+
 impl SegmentBuilder {
     pub fn new(
         segments_path: &Path,
@@ -87,7 +92,7 @@ impl SegmentBuilder {
         let payload_storage =
             create_payload_storage(database.clone(), segment_config, temp_dir.path())?;
 
-        let mut vector_storages = HashMap::new();
+        let mut vector_data = HashMap::new();
 
         for (vector_name, vector_config) in &segment_config.vector_data {
             let vector_storage_path = get_vector_storage_path(temp_dir.path(), vector_name);
@@ -99,7 +104,13 @@ impl SegmentBuilder {
                 vector_name,
             )?;
 
-            vector_storages.insert(vector_name.to_owned(), vector_storage);
+            vector_data.insert(
+                vector_name.to_owned(),
+                VectorData {
+                    vector_storage,
+                    old_indices: Vec::new(),
+                },
+            );
         }
 
         for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
@@ -113,7 +124,13 @@ impl SegmentBuilder {
                 &stopped,
             )?;
 
-            vector_storages.insert(vector_name.to_owned(), vector_storage);
+            vector_data.insert(
+                vector_name.to_owned(),
+                VectorData {
+                    vector_storage,
+                    old_indices: Vec::new(),
+                },
+            );
         }
 
         let destination_path = new_segment_path(segments_path);
@@ -122,7 +139,7 @@ impl SegmentBuilder {
             version: Default::default(), // default version is 0
             id_tracker,
             payload_storage,
-            vector_storages,
+            vector_data,
             segment_config: segment_config.clone(),
 
             destination_path,
@@ -297,19 +314,24 @@ impl SegmentBuilder {
         let vector_storages: Vec<_> = segments.iter().map(|i| &i.vector_data).collect();
 
         let mut new_internal_range = None;
-        for (vector_name, vector_storage) in &mut self.vector_storages {
+        for (vector_name, vector_data) in &mut self.vector_data {
             check_process_stopped(stopped)?;
 
             let other_vector_storages = vector_storages
                 .iter()
                 .map(|i| {
-                    let other_vector_storage = i.get(vector_name).ok_or_else(|| {
+                    let other_vector_data = i.get(vector_name).ok_or_else(|| {
                         OperationError::service_error(format!(
-                    "Cannot update from other segment because if missing vector name {vector_name}"
+                            "Cannot update from other segment because it is \
+                             missing vector name {vector_name}"
                         ))
                     })?;
 
-                    Ok(other_vector_storage.vector_storage.borrow())
+                    vector_data
+                        .old_indices
+                        .push(Arc::clone(&other_vector_data.vector_index));
+
+                    Ok(other_vector_data.vector_storage.borrow())
                 })
                 .collect::<Result<Vec<_>, OperationError>>()?;
 
@@ -321,7 +343,7 @@ impl SegmentBuilder {
                 (vec, vector_deleted)
             });
 
-            let internal_range = vector_storage.update_from(&mut iter, stopped)?;
+            let internal_range = vector_data.vector_storage.update_from(&mut iter, stopped)?;
 
             match &new_internal_range {
                 Some(new_internal_range) => {
@@ -382,8 +404,8 @@ impl SegmentBuilder {
                             // Mark newly added vector as removed
                             new_internal_id
                         };
-                        for vector_storage in self.vector_storages.values_mut() {
-                            vector_storage.delete_vector(remove_id)?;
+                        for vector_data in self.vector_data.values_mut() {
+                            vector_data.vector_storage.delete_vector(remove_id)?;
                         }
                     }
                     None => {
@@ -426,7 +448,7 @@ impl SegmentBuilder {
                 version,
                 id_tracker,
                 payload_storage,
-                mut vector_storages,
+                mut vector_data,
                 segment_config,
                 destination_path,
                 temp_dir,
@@ -458,38 +480,41 @@ impl SegmentBuilder {
 
             let mut quantized_vectors = Self::update_quantization(
                 &segment_config,
-                &vector_storages,
+                &vector_data,
                 temp_dir.path(),
                 &permit,
                 stopped,
             )?;
 
             let mut vector_storages_arc = HashMap::new();
+            let mut old_indices = HashMap::new();
 
             for vector_name in segment_config.vector_data.keys() {
-                let Some(vector_storage) = vector_storages.remove(vector_name) else {
+                let Some(vector_info) = vector_data.remove(vector_name) else {
                     return Err(OperationError::service_error(format!(
                         "Vector storage for vector name {vector_name} not found on segment build"
                     )));
                 };
 
-                vector_storage.flusher()()?;
+                vector_info.vector_storage.flusher()()?;
 
-                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_info.vector_storage));
+
+                old_indices.insert(vector_name, vector_info.old_indices);
 
                 vector_storages_arc.insert(vector_name.to_owned(), vector_storage_arc);
             }
 
             for vector_name in segment_config.sparse_vector_data.keys() {
-                let Some(vector_storage) = vector_storages.remove(vector_name) else {
+                let Some(vector_info) = vector_data.remove(vector_name) else {
                     return Err(OperationError::service_error(format!(
                         "Vector storage for vector name {vector_name} not found on sparse segment build"
                     )));
                 };
 
-                vector_storage.flusher()()?;
+                vector_info.vector_storage.flusher()()?;
 
-                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_storage));
+                let vector_storage_arc = Arc::new(AtomicRefCell::new(vector_info.vector_storage));
 
                 vector_storages_arc.insert(vector_name.to_owned(), vector_storage_arc);
             }
@@ -548,6 +573,7 @@ impl SegmentBuilder {
                     },
                     VectorIndexBuildArgs {
                         permit: permit.clone(),
+                        old_indices: &old_indices.remove(vector_name).unwrap(),
                         gpu_device: gpu_device.as_ref(),
                         stopped,
                     },
@@ -608,7 +634,7 @@ impl SegmentBuilder {
 
     fn update_quantization(
         segment_config: &SegmentConfig,
-        vector_storages: &HashMap<VectorNameBuf, VectorStorageEnum>,
+        vector_storages: &HashMap<VectorNameBuf, VectorData>,
         temp_path: &Path,
         permit: &CpuPermit,
         stopped: &AtomicBool,
@@ -617,7 +643,7 @@ impl SegmentBuilder {
 
         let mut quantized_vectors_map = HashMap::new();
 
-        for (vector_name, vector_storage) in vector_storages {
+        for (vector_name, vector_info) in vector_storages {
             let Some(vector_config) = config.vector_data.get(vector_name) else {
                 continue;
             };
@@ -639,7 +665,7 @@ impl SegmentBuilder {
                 let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
 
                 let quantized_vectors = QuantizedVectors::create(
-                    vector_storage,
+                    &vector_info.vector_storage,
                     quantization,
                     &vector_storage_path,
                     max_threads,

commit b4328bb7c5c5052ce68d31bb7c00055a3b33c5d6
Author: Luis Cosso <luis.cossio@qdrant.com>
Date:   Mon Feb 3 19:25:22 2025 -0300

    [mmap sparse vector storage] return cancelled error if stopped (#5938)
    
    * return cancelled error if stopped
    
    * add doc comment and renames

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 6cc9ebc63..0edb79d20 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -348,9 +348,10 @@ impl SegmentBuilder {
             match &new_internal_range {
                 Some(new_internal_range) => {
                     if new_internal_range != &internal_range {
-                        return Err(OperationError::service_error(
-                            "Internal ids range mismatch between self segment vectors and other segment vectors",
-                        ));
+                        return Err(OperationError::service_error( format!(
+                                "Internal ids range mismatch between self segment vectors and other segment vectors\n\
+                                vector_name: {vector_name}, self range: {new_internal_range:?}, other range: {internal_range:?}"
+                            )));
                     }
                 }
                 None => new_internal_range = Some(internal_range),

commit caed5729e5b7ff3db9dcb4531a4af0929b186682
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 09:05:00 2025 +0100

    IO resource usage permit (#6015)
    
    * rename cpu_budget -> resource_budget
    
    * clippy
    
    * add io budget to resources
    
    * fmt
    
    * move budget structures into a separate file
    
    * add extend permit function
    
    * dont extend existing permit
    
    * switch from IO to CPU permit
    
    * do not release resource before aquiring an extension
    
    * fmt
    
    * Review remarks
    
    * Improve resource permit number assertion
    
    * Make resource permit replace_with only acquire extra needed permits
    
    * Remove obsolete drop implementation
    
    * allocate IO budget same as CPU
    
    * review fixes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0edb79d20..45b36f540 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -9,8 +9,8 @@ use std::sync::Arc;
 use ahash::AHasher;
 use atomic_refcell::AtomicRefCell;
 use bitvec::macros::internal::funty::Integral;
+use common::budget::ResourcePermit;
 use common::counter::hardware_counter::HardwareCounterCell;
-use common::cpu::CpuPermit;
 use common::small_uint::U24;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
@@ -441,7 +441,7 @@ impl SegmentBuilder {
 
     pub fn build(
         self,
-        mut permit: CpuPermit,
+        mut permit: ResourcePermit,
         stopped: &AtomicBool,
     ) -> Result<Segment, OperationError> {
         let (temp_dir, destination_path) = {
@@ -553,7 +553,7 @@ impl SegmentBuilder {
             // If GPU is enabled, release all CPU cores except one.
             if let Some(_gpu_device) = &gpu_device {
                 if permit.num_cpus > 1 {
-                    permit.release_count(permit.num_cpus - 1);
+                    permit.release_cpu_count(permit.num_cpus - 1);
                 }
             }
 
@@ -637,7 +637,7 @@ impl SegmentBuilder {
         segment_config: &SegmentConfig,
         vector_storages: &HashMap<VectorNameBuf, VectorData>,
         temp_path: &Path,
-        permit: &CpuPermit,
+        permit: &ResourcePermit,
         stopped: &AtomicBool,
     ) -> OperationResult<HashMap<VectorNameBuf, QuantizedVectors>> {
         let config = segment_config.clone();

commit 66dd336cf7a2005a7c828eb35a32d81670380c68
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 14:21:05 2025 +0100

    Optimize immutable id tracker mapping (#6023)
    
    * clone PointMappings into CompressedPointMappings
    
    * fmt
    
    * compressed internal to external
    
    * implement compressed external to internal mapping
    
    * some autogenerated tests
    
    * fix test
    
    * Explicitly resize deleted flags, ensure length matches number of points
    
    * Review remarks
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 45b36f540..7dbc637ae 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -26,6 +26,7 @@ use super::{
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::entry::entry_point::SegmentEntry;
+use crate::id_tracker::compressed::compressed_point_mappings::CompressedPointMappings;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
 use crate::id_tracker::{for_each_unique_point, IdTracker, IdTrackerEnum};
@@ -465,8 +466,9 @@ impl SegmentBuilder {
             let id_tracker = match id_tracker {
                 IdTrackerEnum::InMemoryIdTracker(in_memory_id_tracker) => {
                     let (versions, mappings) = in_memory_id_tracker.into_internal();
+                    let compressed_mapping = CompressedPointMappings::from_mappings(mappings);
                     let immutable_id_tracker =
-                        ImmutableIdTracker::new(temp_dir.path(), &versions, mappings)?;
+                        ImmutableIdTracker::new(temp_dir.path(), &versions, compressed_mapping)?;
                     IdTrackerEnum::ImmutableIdTracker(immutable_id_tracker)
                 }
                 IdTrackerEnum::MutableIdTracker(_) => id_tracker,

commit f6d58b46bfb1f89112a9e1d14daa9d568fce5c8b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Feb 24 11:57:23 2025 +0100

    notify optimizers scheduler of the budget change (#6040)
    
    * notify optimizers scheduler of the budget change
    
    * Zero permit count when releasing CPU or IO
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 7dbc637ae..092d188cb 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -442,7 +442,7 @@ impl SegmentBuilder {
 
     pub fn build(
         self,
-        mut permit: ResourcePermit,
+        permit: ResourcePermit,
         stopped: &AtomicBool,
     ) -> Result<Segment, OperationError> {
         let (temp_dir, destination_path) = {
@@ -552,13 +552,6 @@ impl SegmentBuilder {
             #[cfg(not(feature = "gpu"))]
             let gpu_device = None;
 
-            // If GPU is enabled, release all CPU cores except one.
-            if let Some(_gpu_device) = &gpu_device {
-                if permit.num_cpus > 1 {
-                    permit.release_cpu_count(permit.num_cpus - 1);
-                }
-            }
-
             // Arc permit to share it with each vector store
             let permit = Arc::new(permit);
 

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vise <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 092d188cb..e6e56aedc 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -3,8 +3,8 @@ use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 
 use ahash::AHasher;
 use atomic_refcell::AtomicRefCell;
@@ -24,21 +24,21 @@ use super::{
     get_vector_storage_path, new_segment_path, open_segment_db, open_vector_storage,
 };
 use crate::common::error_logging::LogError;
-use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
+use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
 use crate::entry::entry_point::SegmentEntry;
 use crate::id_tracker::compressed::compressed_point_mappings::CompressedPointMappings;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::in_memory_id_tracker::InMemoryIdTracker;
-use crate::id_tracker::{for_each_unique_point, IdTracker, IdTrackerEnum};
+use crate::id_tracker::{IdTracker, IdTrackerEnum, for_each_unique_point};
 use crate::index::field_index::FieldIndex;
 use crate::index::sparse_index::sparse_vector_index::SparseVectorIndexOpenArgs;
 use crate::index::struct_payload_index::StructPayloadIndex;
 use crate::index::{PayloadIndex, VectorIndexEnum};
-use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::PayloadStorage;
+use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::segment::{Segment, SegmentVersion};
 use crate::segment_constructor::{
-    build_vector_index, load_segment, VectorIndexBuildArgs, VectorIndexOpenArgs,
+    VectorIndexBuildArgs, VectorIndexOpenArgs, build_vector_index, load_segment,
 };
 use crate::types::{
     CompactExtendedPointId, ExtendedPointId, PayloadFieldSchema, PayloadKeyType, SegmentConfig,
@@ -349,10 +349,10 @@ impl SegmentBuilder {
             match &new_internal_range {
                 Some(new_internal_range) => {
                     if new_internal_range != &internal_range {
-                        return Err(OperationError::service_error( format!(
-                                "Internal ids range mismatch between self segment vectors and other segment vectors\n\
+                        return Err(OperationError::service_error(format!(
+                            "Internal ids range mismatch between self segment vectors and other segment vectors\n\
                                 vector_name: {vector_name}, self range: {new_internal_range:?}, other range: {internal_range:?}"
-                            )));
+                        )));
                     }
                 }
                 None => new_internal_range = Some(internal_range),

commit 706b1a31665ee4a2e44a0a20845bb8065b0dbc28
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 4 13:19:50 2025 +0100

    IsEmpty/IsNull index (#6088)
    
    * create initial strucutres
    
    * clippy
    
    * start field-query refactoring
    
    * start field-query refactoring (2/N)
    
    * start field-query refactoring (3/N): duplicate is_empty/null condiftions as field condition
    
    * start field-query refactoring (4/N): re-instate is_empty fallback in case new index is not built yet
    
    * filter for is_empty/is_null
    
    * implement add/remove point
    
    * upd schema
    
    * open and create of null-index
    
    * create null-index
    
    * fix test
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vise <tim+github@visee.me>
    
    * unit test for null-index
    
    * more unit tests
    
    * add openapi tests
    
    * fmt
    
    * fix for integartion tests
    
    * rabbit review fix
    
    * make [null] non-empty
    
    ---------
    
    Co-authored-by: Tim Vise <tim+github@visee.me>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index e6e56aedc..ca538c7f6 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -241,6 +241,7 @@ impl SegmentBuilder {
                 FieldIndex::GeoIndex(_) => {}
                 FieldIndex::FullTextIndex(_) => {}
                 FieldIndex::BoolIndex(_) => {}
+                FieldIndex::NullIndex(_) => {}
             }
         }
         ordering

commit abf433e6c057686ca7770952a20219752af8a020
Author: Tim Vise <tim+github@visee.me>
Date:   Wed Mar 19 13:37:54 2025 +0100

    Mutable ID tracker integration (#6174)
    
    * Rename mutable ID tracker mappings file
    
    * Make new ID tracker the default, add new variant for RocksDB tracker
    
    * In mutable ID tracker, only list files if they exist on disk
    
    * Don't use the new mutable ID tracker yet
    
    * Feature flag usage of new mutable ID tracker
    
    * Simplify RocksDB check a bit
    
    * Rename both the mutable ID tracker files

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index ca538c7f6..bb7e5fe51 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -85,7 +85,7 @@ impl SegmentBuilder {
         let database = open_segment_db(temp_dir.path(), segment_config)?;
 
         let id_tracker = if segment_config.is_appendable() {
-            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(database.clone())?)
+            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(temp_dir.path())?)
         } else {
             IdTrackerEnum::InMemoryIdTracker(InMemoryIdTracker::new())
         };
@@ -476,6 +476,7 @@ impl SegmentBuilder {
                 IdTrackerEnum::ImmutableIdTracker(_) => {
                     unreachable!("ImmutableIdTracker should not be used for building segment")
                 }
+                IdTrackerEnum::RocksDbIdTracker(_) => id_tracker,
             };
 
             id_tracker.mapping_flusher()()?;

commit 03dc95c74c32510aba83961884b3a54a723def1f
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Mar 20 17:45:49 2025 +0100

    Check `use_mutable_id_tracker_without_rocksdb` feature flag when building new segment (#6211)

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index bb7e5fe51..702e07108 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -11,6 +11,7 @@ use atomic_refcell::AtomicRefCell;
 use bitvec::macros::internal::funty::Integral;
 use common::budget::ResourcePermit;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::flags::feature_flags;
 use common::small_uint::U24;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
@@ -19,9 +20,10 @@ use tempfile::TempDir;
 use uuid::Uuid;
 
 use super::{
-    create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
-    create_sparse_vector_storage, get_payload_index_path, get_vector_index_path,
-    get_vector_storage_path, new_segment_path, open_segment_db, open_vector_storage,
+    create_mutable_id_tracker, create_payload_storage, create_rocksdb_id_tracker,
+    create_sparse_vector_index, create_sparse_vector_storage, get_payload_index_path,
+    get_vector_index_path, get_vector_storage_path, new_segment_path, open_segment_db,
+    open_vector_storage,
 };
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
@@ -85,7 +87,11 @@ impl SegmentBuilder {
         let database = open_segment_db(temp_dir.path(), segment_config)?;
 
         let id_tracker = if segment_config.is_appendable() {
-            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(temp_dir.path())?)
+            if feature_flags().use_mutable_id_tracker_without_rocksdb {
+                IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(temp_dir.path())?)
+            } else {
+                IdTrackerEnum::RocksDbIdTracker(create_rocksdb_id_tracker(database.clone())?)
+            }
         } else {
             IdTrackerEnum::InMemoryIdTracker(InMemoryIdTracker::new())
         };

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 702e07108..c53b8ecba 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -451,6 +451,7 @@ impl SegmentBuilder {
         self,
         permit: ResourcePermit,
         stopped: &AtomicBool,
+        hw_counter: &HardwareCounterCell,
     ) -> Result<Segment, OperationError> {
         let (temp_dir, destination_path) = {
             let SegmentBuilder {
@@ -539,9 +540,8 @@ impl SegmentBuilder {
                 &payload_index_path,
                 appendable_flag,
             )?;
-
             for (field, payload_schema) in indexed_fields {
-                payload_index.set_indexed(&field, payload_schema)?;
+                payload_index.set_indexed(&field, payload_schema, hw_counter)?;
                 check_process_stopped(stopped)?;
             }
 

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index c53b8ecba..0db2f886a 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -534,7 +534,7 @@ impl SegmentBuilder {
             let payload_index_path = get_payload_index_path(temp_dir.path());
 
             let mut payload_index = StructPayloadIndex::open(
-                payload_storage_arc,
+                payload_storage_arc.clone(),
                 id_tracker_arc.clone(),
                 vector_storages_arc.clone(),
                 &payload_index_path,
@@ -564,16 +564,18 @@ impl SegmentBuilder {
             let permit = Arc::new(permit);
 
             for (vector_name, vector_config) in &segment_config.vector_data {
-                build_vector_index(
+                let vector_storage = vector_storages_arc.remove(vector_name).unwrap();
+                let quantized_vectors =
+                    Arc::new(AtomicRefCell::new(quantized_vectors.remove(vector_name)));
+
+                let index = build_vector_index(
                     vector_config,
                     VectorIndexOpenArgs {
                         path: &get_vector_index_path(temp_dir.path(), vector_name),
                         id_tracker: id_tracker_arc.clone(),
-                        vector_storage: vector_storages_arc.remove(vector_name).unwrap(),
+                        vector_storage: vector_storage.clone(),
                         payload_index: payload_index_arc.clone(),
-                        quantized_vectors: Arc::new(AtomicRefCell::new(
-                            quantized_vectors.remove(vector_name),
-                        )),
+                        quantized_vectors: quantized_vectors.clone(),
                     },
                     VectorIndexBuildArgs {
                         permit: permit.clone(),
@@ -582,6 +584,20 @@ impl SegmentBuilder {
                         stopped,
                     },
                 )?;
+
+                if vector_storage.borrow().is_on_disk() {
+                    // If vector storage is expected to be on-disk, we need to clear cache
+                    // to avoid cache pollution
+                    vector_storage.borrow().clear_cache()?;
+                }
+
+                if let Some(quantized_vectors) = quantized_vectors.borrow().as_ref() {
+                    quantized_vectors.clear_cache()?;
+                }
+
+                // Index if always loaded on-disk=true from build function
+                // So we may clear unconditionally
+                index.clear_cache()?;
             }
 
             for (vector_name, sparse_vector_config) in &segment_config.sparse_vector_data {
@@ -589,7 +605,7 @@ impl SegmentBuilder {
 
                 let vector_storage_arc = vector_storages_arc.remove(vector_name).unwrap();
 
-                create_sparse_vector_index(SparseVectorIndexOpenArgs {
+                let index = create_sparse_vector_index(SparseVectorIndexOpenArgs {
                     config: sparse_vector_config.index,
                     id_tracker: id_tracker_arc.clone(),
                     vector_storage: vector_storage_arc.clone(),
@@ -598,8 +614,27 @@ impl SegmentBuilder {
                     stopped,
                     tick_progress: || (),
                 })?;
+
+                if sparse_vector_config.storage_type.is_on_disk() {
+                    // If vector storage is expected to be on-disk, we need to clear cache
+                    // to avoid cache pollution
+                    vector_storage_arc.borrow().clear_cache()?;
+                }
+
+                if sparse_vector_config.index.index_type.is_on_disk() {
+                    index.clear_cache()?;
+                }
             }
 
+            if segment_config.payload_storage_type.is_on_disk() {
+                // If payload storage is expected to be on-disk, we need to clear cache
+                // to avoid cache pollution
+                payload_storage_arc.borrow().clear_cache()?;
+            }
+
+            // Clear cache for payload index to avoid cache pollution
+            payload_index_arc.borrow().clear_cache_if_on_disk()?;
+
             // We're done with CPU-intensive tasks, release CPU permit
             debug_assert_eq!(
                 Arc::strong_count(&permit),

commit 7a1a96e22be04e68ed899c3cd4f0e366f8db327e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 18:56:53 2025 +0000

    Incremental HNSW index building: append-only case  (#6325)
    
    * Pass FeatureFlags into VectorIndexBuildArgs
    
    * Incremental HNSW index building: append-only case
    
    * Use debug_assert
    
    * first_few_ids
    
    * Check deleted_point_count
    
    * Drop unused method

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 0db2f886a..63a4255c3 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -582,6 +582,7 @@ impl SegmentBuilder {
                         old_indices: &old_indices.remove(vector_name).unwrap(),
                         gpu_device: gpu_device.as_ref(),
                         stopped,
+                        feature_flags: feature_flags(),
                     },
                 )?;
 

commit a6d57e910a4d5d3bfc52bd134c417586baaa5469
Author: Tim Vise <tim+github@visee.me>
Date:   Mon Apr 21 00:13:40 2025 +0200

    Qdrant 1.14: enable mutable ID tracker by default (#6268)
    
    * Enable mutable ID tracker by default
    
    * Remove now obsolete feature flag for new mutable ID tracker

diff --git a/lib/segment/src/segment_constructor/segment_builder.rs b/lib/segment/src/segment_constructor/segment_builder.rs
index 63a4255c3..d72a33771 100644
--- a/lib/segment/src/segment_constructor/segment_builder.rs
+++ b/lib/segment/src/segment_constructor/segment_builder.rs
@@ -20,10 +20,9 @@ use tempfile::TempDir;
 use uuid::Uuid;
 
 use super::{
-    create_mutable_id_tracker, create_payload_storage, create_rocksdb_id_tracker,
-    create_sparse_vector_index, create_sparse_vector_storage, get_payload_index_path,
-    get_vector_index_path, get_vector_storage_path, new_segment_path, open_segment_db,
-    open_vector_storage,
+    create_mutable_id_tracker, create_payload_storage, create_sparse_vector_index,
+    create_sparse_vector_storage, get_payload_index_path, get_vector_index_path,
+    get_vector_storage_path, new_segment_path, open_segment_db, open_vector_storage,
 };
 use crate::common::error_logging::LogError;
 use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
@@ -87,11 +86,7 @@ impl SegmentBuilder {
         let database = open_segment_db(temp_dir.path(), segment_config)?;
 
         let id_tracker = if segment_config.is_appendable() {
-            if feature_flags().use_mutable_id_tracker_without_rocksdb {
-                IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(temp_dir.path())?)
-            } else {
-                IdTrackerEnum::RocksDbIdTracker(create_rocksdb_id_tracker(database.clone())?)
-            }
+            IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(temp_dir.path())?)
         } else {
             IdTrackerEnum::InMemoryIdTracker(InMemoryIdTracker::new())
         };

