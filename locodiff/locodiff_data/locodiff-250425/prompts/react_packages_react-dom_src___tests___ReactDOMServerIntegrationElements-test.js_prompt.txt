# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js

commit fa7a97fc46935e1611d52da2fdb7d53f6ab9577d
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 23 17:44:58 2017 +0000

    Run 90% of tests on compiled bundles (both development and production) (#11633)
    
    * Extract Jest config into a separate file
    
    * Refactor Jest scripts directory structure
    
    Introduces a more consistent naming scheme.
    
    * Add yarn test-bundles and yarn test-prod-bundles
    
    Only files ending with -test.public.js are opted in (so far we don't have any).
    
    * Fix error decoding for production bundles
    
    GCC seems to remove `new` from `new Error()` which broke our proxy.
    
    * Build production version of react-noop-renderer
    
    This lets us test more bundles.
    
    * Switch to blacklist (exclude .private.js tests)
    
    * Rename tests that are currently broken against bundles to *-test.internal.js
    
    Some of these are using private APIs. Some have other issues.
    
    * Add bundle tests to CI
    
    * Split private and public ReactJSXElementValidator tests
    
    * Remove internal deps from ReactServerRendering-test and make it public
    
    * Only run tests directly in __tests__
    
    This lets us share code between test files by placing them in __tests__/utils.
    
    * Remove ExecutionEnvironment dependency from DOMServerIntegrationTest
    
    It's not necessary since Stack.
    
    * Split up ReactDOMServerIntegration into test suite and utilities
    
    This enables us to further split it down. Good both for parallelization and extracting public parts.
    
    * Split Fragment tests from other DOMServerIntegration tests
    
    This enables them to opt other DOMServerIntegration tests into bundle testing.
    
    * Split ReactDOMServerIntegration into different test files
    
    It was way too slow to run all these in sequence.
    
    * Don't reset the cache twice in DOMServerIntegration tests
    
    We used to do this to simulate testing separate bundles.
    But now we actually *do* test bundles. So there is no need for this, as it makes tests slower.
    
    * Rename test-bundles* commands to test-build*
    
    Also add test-prod-build as alias for test-build-prod because I keep messing them up.
    
    * Use regenerator polyfill for react-noop
    
    This fixes other issues and finally lets us run ReactNoop tests against a prod bundle.
    
    * Run most Incremental tests against bundles
    
    Now that GCC generator issue is fixed, we can do this.
    I split ErrorLogging test separately because it does mocking. Other error handling tests don't need it.
    
    * Update sizes
    
    * Fix ReactMount test
    
    * Enable ReactDOMComponent test
    
    * Fix a warning issue uncovered by flat bundle testing
    
    With flat bundles, we couldn't produce a good warning for <div onclick={}> on SSR
    because it doesn't use the event system. However the issue was not visible in normal
    Jest runs because the event plugins have been injected by the time the test ran.
    
    To solve this, I am explicitly passing whether event system is available as an argument
    to the hook. This makes the behavior consistent between source and bundle tests. Then
    I change the tests to document the actual logic and _attempt_ to show a nice message
    (e.g. we know for sure `onclick` is a bad event but we don't know the right name for it
    on the server so we just say a generic message about camelCase naming convention).

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
new file mode 100644
index 0000000000..bdf2557534
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -0,0 +1,865 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+const ReactDOMServerIntegrationUtils = require('./utils/ReactDOMServerIntegrationTestUtils');
+
+const TEXT_NODE_TYPE = 3;
+
+let React;
+let ReactDOM;
+let ReactDOMServer;
+
+function initModules() {
+  jest.resetModuleRegistry();
+  React = require('react');
+  ReactDOM = require('react-dom');
+  ReactDOMServer = require('react-dom/server');
+
+  // Make them available to the helpers.
+  return {
+    ReactDOM,
+    ReactDOMServer,
+  };
+}
+
+const {
+  resetModules,
+  itRenders,
+  itThrowsWhenRendering,
+  serverRender,
+  streamRender,
+  clientRenderOnServerString,
+} = ReactDOMServerIntegrationUtils(initModules);
+
+describe('ReactDOMServerIntegration', () => {
+  beforeEach(() => {
+    resetModules();
+  });
+
+  describe('elements and children', function() {
+    function expectNode(node, type, value) {
+      expect(node).not.toBe(null);
+      expect(node.nodeType).toBe(type);
+      expect(node.nodeValue).toMatch(value);
+    }
+
+    function expectTextNode(node, text) {
+      expectNode(node, TEXT_NODE_TYPE, text);
+    }
+
+    describe('text children', function() {
+      itRenders('a div with text', async render => {
+        const e = await render(<div>Text</div>);
+        expect(e.tagName).toBe('DIV');
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.firstChild, TEXT_NODE_TYPE, 'Text');
+      });
+
+      itRenders('a div with text with flanking whitespace', async render => {
+        // prettier-ignore
+        const e = await render(<div>  Text </div>);
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.childNodes[0], TEXT_NODE_TYPE, '  Text ');
+      });
+
+      itRenders('a div with an empty text child', async render => {
+        const e = await render(<div>{''}</div>);
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('a div with multiple empty text children', async render => {
+        const e = await render(
+          <div>
+            {''}
+            {''}
+            {''}
+          </div>,
+        );
+        if (render === serverRender || render === streamRender) {
+          // For plain server markup result we should have no text nodes if
+          // they're all empty.
+          expect(e.childNodes.length).toBe(0);
+          expect(e.textContent).toBe('');
+        } else {
+          expect(e.childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[0], '');
+          expectTextNode(e.childNodes[1], '');
+          expectTextNode(e.childNodes[2], '');
+        }
+      });
+
+      itRenders('a div with multiple whitespace children', async render => {
+        // prettier-ignore
+        const e = await render(<div>{' '}{' '}{' '}</div>);
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          // For plain server markup result we have comments between.
+          // If we're able to hydrate, they remain.
+          expect(e.childNodes.length).toBe(5);
+          expectTextNode(e.childNodes[0], ' ');
+          expectTextNode(e.childNodes[2], ' ');
+          expectTextNode(e.childNodes[4], ' ');
+        } else {
+          expect(e.childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[0], ' ');
+          expectTextNode(e.childNodes[1], ' ');
+          expectTextNode(e.childNodes[2], ' ');
+        }
+      });
+
+      itRenders('a div with text sibling to a node', async render => {
+        const e = await render(
+          <div>
+            Text<span>More Text</span>
+          </div>,
+        );
+        let spanNode;
+        expect(e.childNodes.length).toBe(2);
+        spanNode = e.childNodes[1];
+        expectTextNode(e.childNodes[0], 'Text');
+        expect(spanNode.tagName).toBe('SPAN');
+        expect(spanNode.childNodes.length).toBe(1);
+        expectNode(spanNode.firstChild, TEXT_NODE_TYPE, 'More Text');
+      });
+
+      itRenders('a non-standard element with text', async render => {
+        const e = await render(<nonstandard>Text</nonstandard>);
+        expect(e.tagName).toBe('NONSTANDARD');
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.firstChild, TEXT_NODE_TYPE, 'Text');
+      });
+
+      itRenders('a custom element with text', async render => {
+        const e = await render(<custom-element>Text</custom-element>);
+        expect(e.tagName).toBe('CUSTOM-ELEMENT');
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.firstChild, TEXT_NODE_TYPE, 'Text');
+      });
+
+      itRenders('a leading blank child with a text sibling', async render => {
+        const e = await render(<div>{''}foo</div>);
+        if (render === serverRender || render === streamRender) {
+          expect(e.childNodes.length).toBe(1);
+          expectTextNode(e.childNodes[0], 'foo');
+        } else {
+          expect(e.childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[0], '');
+          expectTextNode(e.childNodes[1], 'foo');
+        }
+      });
+
+      itRenders('a trailing blank child with a text sibling', async render => {
+        const e = await render(<div>foo{''}</div>);
+        // with Fiber, there are just two text nodes.
+        if (render === serverRender || render === streamRender) {
+          expect(e.childNodes.length).toBe(1);
+          expectTextNode(e.childNodes[0], 'foo');
+        } else {
+          expect(e.childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[0], 'foo');
+          expectTextNode(e.childNodes[1], '');
+        }
+      });
+
+      itRenders('an element with two text children', async render => {
+        const e = await render(
+          <div>
+            {'foo'}
+            {'bar'}
+          </div>,
+        );
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          // In the server render output there's a comment between them.
+          expect(e.childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[0], 'foo');
+          expectTextNode(e.childNodes[2], 'bar');
+        } else {
+          expect(e.childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[0], 'foo');
+          expectTextNode(e.childNodes[1], 'bar');
+        }
+      });
+
+      itRenders(
+        'a component returning text node between two text nodes',
+        async render => {
+          const B = () => 'b';
+          const e = await render(
+            <div>
+              {'a'}
+              <B />
+              {'c'}
+            </div>,
+          );
+          if (
+            render === serverRender ||
+            render === clientRenderOnServerString ||
+            render === streamRender
+          ) {
+            // In the server render output there's a comment between them.
+            expect(e.childNodes.length).toBe(5);
+            expectTextNode(e.childNodes[0], 'a');
+            expectTextNode(e.childNodes[2], 'b');
+            expectTextNode(e.childNodes[4], 'c');
+          } else {
+            expect(e.childNodes.length).toBe(3);
+            expectTextNode(e.childNodes[0], 'a');
+            expectTextNode(e.childNodes[1], 'b');
+            expectTextNode(e.childNodes[2], 'c');
+          }
+        },
+      );
+
+      itRenders('a tree with sibling host and text nodes', async render => {
+        class X extends React.Component {
+          render() {
+            return [null, [<Y key="1" />], false];
+          }
+        }
+
+        function Y() {
+          return [<Z key="1" />, ['c']];
+        }
+
+        function Z() {
+          return null;
+        }
+
+        const e = await render(
+          <div>
+            {[['a'], 'b']}
+            <div>
+              <X key="1" />
+              d
+            </div>
+            e
+          </div>,
+        );
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          // In the server render output there's comments between text nodes.
+          expect(e.childNodes.length).toBe(5);
+          expectTextNode(e.childNodes[0], 'a');
+          expectTextNode(e.childNodes[2], 'b');
+          expect(e.childNodes[3].childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[3].childNodes[0], 'c');
+          expectTextNode(e.childNodes[3].childNodes[2], 'd');
+          expectTextNode(e.childNodes[4], 'e');
+        } else {
+          expect(e.childNodes.length).toBe(4);
+          expectTextNode(e.childNodes[0], 'a');
+          expectTextNode(e.childNodes[1], 'b');
+          expect(e.childNodes[2].childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[2].childNodes[0], 'c');
+          expectTextNode(e.childNodes[2].childNodes[1], 'd');
+          expectTextNode(e.childNodes[3], 'e');
+        }
+      });
+    });
+
+    describe('number children', function() {
+      itRenders('a number as single child', async render => {
+        const e = await render(<div>{3}</div>);
+        expect(e.textContent).toBe('3');
+      });
+
+      // zero is falsey, so it could look like no children if the code isn't careful.
+      itRenders('zero as single child', async render => {
+        const e = await render(<div>{0}</div>);
+        expect(e.textContent).toBe('0');
+      });
+
+      itRenders('an element with number and text children', async render => {
+        const e = await render(
+          <div>
+            {'foo'}
+            {40}
+          </div>,
+        );
+        // with Fiber, there are just two text nodes.
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          // In the server markup there's a comment between.
+          expect(e.childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[0], 'foo');
+          expectTextNode(e.childNodes[2], '40');
+        } else {
+          expect(e.childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[0], 'foo');
+          expectTextNode(e.childNodes[1], '40');
+        }
+      });
+    });
+
+    describe('null, false, and undefined children', function() {
+      itRenders('null single child as blank', async render => {
+        const e = await render(<div>{null}</div>);
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('false single child as blank', async render => {
+        const e = await render(<div>{false}</div>);
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('undefined single child as blank', async render => {
+        const e = await render(<div>{undefined}</div>);
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('a null component children as empty', async render => {
+        const NullComponent = () => null;
+        const e = await render(
+          <div>
+            <NullComponent />
+          </div>,
+        );
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('null children as blank', async render => {
+        const e = await render(<div>{null}foo</div>);
+        expect(e.childNodes.length).toBe(1);
+        expectTextNode(e.childNodes[0], 'foo');
+      });
+
+      itRenders('false children as blank', async render => {
+        const e = await render(<div>{false}foo</div>);
+        expect(e.childNodes.length).toBe(1);
+        expectTextNode(e.childNodes[0], 'foo');
+      });
+
+      itRenders('null and false children together as blank', async render => {
+        const e = await render(
+          <div>
+            {false}
+            {null}foo{null}
+            {false}
+          </div>,
+        );
+        expect(e.childNodes.length).toBe(1);
+        expectTextNode(e.childNodes[0], 'foo');
+      });
+
+      itRenders('only null and false children as blank', async render => {
+        const e = await render(
+          <div>
+            {false}
+            {null}
+            {null}
+            {false}
+          </div>,
+        );
+        expect(e.childNodes.length).toBe(0);
+      });
+    });
+
+    describe('elements with implicit namespaces', function() {
+      itRenders('an svg element', async render => {
+        const e = await render(<svg />);
+        expect(e.childNodes.length).toBe(0);
+        expect(e.tagName).toBe('svg');
+        expect(e.namespaceURI).toBe('http://www.w3.org/2000/svg');
+      });
+
+      itRenders('svg child element with an attribute', async render => {
+        let e = await render(<svg viewBox="0 0 0 0" />);
+        expect(e.childNodes.length).toBe(0);
+        expect(e.tagName).toBe('svg');
+        expect(e.namespaceURI).toBe('http://www.w3.org/2000/svg');
+        expect(e.getAttribute('viewBox')).toBe('0 0 0 0');
+      });
+
+      itRenders(
+        'svg child element with a namespace attribute',
+        async render => {
+          let e = await render(
+            <svg>
+              <image xlinkHref="http://i.imgur.com/w7GCRPb.png" />
+            </svg>,
+          );
+          e = e.firstChild;
+          expect(e.childNodes.length).toBe(0);
+          expect(e.tagName).toBe('image');
+          expect(e.namespaceURI).toBe('http://www.w3.org/2000/svg');
+          expect(e.getAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(
+            'http://i.imgur.com/w7GCRPb.png',
+          );
+        },
+      );
+
+      itRenders('svg child element with a badly cased alias', async render => {
+        let e = await render(
+          <svg>
+            <image xlinkhref="http://i.imgur.com/w7GCRPb.png" />
+          </svg>,
+          1,
+        );
+        e = e.firstChild;
+        expect(e.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')).toBe(
+          false,
+        );
+        expect(e.getAttribute('xlinkhref')).toBe(
+          'http://i.imgur.com/w7GCRPb.png',
+        );
+      });
+
+      itRenders('svg element with a tabIndex attribute', async render => {
+        let e = await render(<svg tabIndex="1" />);
+        expect(e.tabIndex).toBe(1);
+      });
+
+      itRenders(
+        'svg element with a badly cased tabIndex attribute',
+        async render => {
+          let e = await render(<svg tabindex="1" />, 1);
+          expect(e.tabIndex).toBe(1);
+        },
+      );
+
+      itRenders('svg element with a mixed case name', async render => {
+        let e = await render(
+          <svg>
+            <filter>
+              <feMorphology />
+            </filter>
+          </svg>,
+        );
+        e = e.firstChild.firstChild;
+        expect(e.childNodes.length).toBe(0);
+        expect(e.tagName).toBe('feMorphology');
+        expect(e.namespaceURI).toBe('http://www.w3.org/2000/svg');
+      });
+
+      itRenders('a math element', async render => {
+        const e = await render(<math />);
+        expect(e.childNodes.length).toBe(0);
+        expect(e.tagName).toBe('math');
+        expect(e.namespaceURI).toBe('http://www.w3.org/1998/Math/MathML');
+      });
+    });
+    // specially wrapped components
+    // (see the big switch near the beginning ofReactDOMComponent.mountComponent)
+    itRenders('an img', async render => {
+      const e = await render(<img />);
+      expect(e.childNodes.length).toBe(0);
+      expect(e.nextSibling).toBe(null);
+      expect(e.tagName).toBe('IMG');
+    });
+
+    itRenders('a button', async render => {
+      const e = await render(<button />);
+      expect(e.childNodes.length).toBe(0);
+      expect(e.nextSibling).toBe(null);
+      expect(e.tagName).toBe('BUTTON');
+    });
+
+    itRenders('a div with dangerouslySetInnerHTML', async render => {
+      const e = await render(
+        <div dangerouslySetInnerHTML={{__html: "<span id='child'/>"}} />,
+      );
+      expect(e.childNodes.length).toBe(1);
+      expect(e.firstChild.tagName).toBe('SPAN');
+      expect(e.firstChild.getAttribute('id')).toBe('child');
+      expect(e.firstChild.childNodes.length).toBe(0);
+    });
+
+    describe('newline-eating elements', function() {
+      itRenders(
+        'a newline-eating tag with content not starting with \\n',
+        async render => {
+          const e = await render(<pre>Hello</pre>);
+          expect(e.textContent).toBe('Hello');
+        },
+      );
+      itRenders(
+        'a newline-eating tag with content starting with \\n',
+        async render => {
+          const e = await render(<pre>{'\nHello'}</pre>);
+          expect(e.textContent).toBe('\nHello');
+        },
+      );
+      itRenders('a normal tag with content starting with \\n', async render => {
+        const e = await render(<div>{'\nHello'}</div>);
+        expect(e.textContent).toBe('\nHello');
+      });
+    });
+
+    describe('different component implementations', function() {
+      function checkFooDiv(e) {
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.firstChild, TEXT_NODE_TYPE, 'foo');
+      }
+
+      itRenders('stateless components', async render => {
+        const StatelessComponent = () => <div>foo</div>;
+        checkFooDiv(await render(<StatelessComponent />));
+      });
+
+      itRenders('ES6 class components', async render => {
+        class ClassComponent extends React.Component {
+          render() {
+            return <div>foo</div>;
+          }
+        }
+        checkFooDiv(await render(<ClassComponent />));
+      });
+
+      itRenders('factory components', async render => {
+        const FactoryComponent = () => {
+          return {
+            render: function() {
+              return <div>foo</div>;
+            },
+          };
+        };
+        checkFooDiv(await render(<FactoryComponent />));
+      });
+    });
+
+    describe('component hierarchies', async function() {
+      itRenders('single child hierarchies of components', async render => {
+        const Component = props => <div>{props.children}</div>;
+        let e = await render(
+          <Component>
+            <Component>
+              <Component>
+                <Component />
+              </Component>
+            </Component>
+          </Component>,
+        );
+        for (var i = 0; i < 3; i++) {
+          expect(e.tagName).toBe('DIV');
+          expect(e.childNodes.length).toBe(1);
+          e = e.firstChild;
+        }
+        expect(e.tagName).toBe('DIV');
+        expect(e.childNodes.length).toBe(0);
+      });
+
+      itRenders('multi-child hierarchies of components', async render => {
+        const Component = props => <div>{props.children}</div>;
+        const e = await render(
+          <Component>
+            <Component>
+              <Component />
+              <Component />
+            </Component>
+            <Component>
+              <Component />
+              <Component />
+            </Component>
+          </Component>,
+        );
+        expect(e.tagName).toBe('DIV');
+        expect(e.childNodes.length).toBe(2);
+        for (var i = 0; i < 2; i++) {
+          var child = e.childNodes[i];
+          expect(child.tagName).toBe('DIV');
+          expect(child.childNodes.length).toBe(2);
+          for (var j = 0; j < 2; j++) {
+            var grandchild = child.childNodes[j];
+            expect(grandchild.tagName).toBe('DIV');
+            expect(grandchild.childNodes.length).toBe(0);
+          }
+        }
+      });
+
+      itRenders('a div with a child', async render => {
+        const e = await render(
+          <div id="parent">
+            <div id="child" />
+          </div>,
+        );
+        expect(e.id).toBe('parent');
+        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes[0].id).toBe('child');
+        expect(e.childNodes[0].childNodes.length).toBe(0);
+      });
+
+      itRenders('a div with multiple children', async render => {
+        const e = await render(
+          <div id="parent">
+            <div id="child1" />
+            <div id="child2" />
+          </div>,
+        );
+        expect(e.id).toBe('parent');
+        expect(e.childNodes.length).toBe(2);
+        expect(e.childNodes[0].id).toBe('child1');
+        expect(e.childNodes[0].childNodes.length).toBe(0);
+        expect(e.childNodes[1].id).toBe('child2');
+        expect(e.childNodes[1].childNodes.length).toBe(0);
+      });
+
+      itRenders(
+        'a div with multiple children separated by whitespace',
+        async render => {
+          const e = await render(
+            <div id="parent">
+              <div id="child1" /> <div id="child2" />
+            </div>,
+          );
+          expect(e.id).toBe('parent');
+          let child1, child2, textNode;
+          expect(e.childNodes.length).toBe(3);
+          child1 = e.childNodes[0];
+          textNode = e.childNodes[1];
+          child2 = e.childNodes[2];
+          expect(child1.id).toBe('child1');
+          expect(child1.childNodes.length).toBe(0);
+          expectTextNode(textNode, ' ');
+          expect(child2.id).toBe('child2');
+          expect(child2.childNodes.length).toBe(0);
+        },
+      );
+
+      itRenders(
+        'a div with a single child surrounded by whitespace',
+        async render => {
+          // prettier-ignore
+          const e = await render(<div id="parent">  <div id="child" />   </div>); // eslint-disable-line no-multi-spaces
+          let textNode1, child, textNode2;
+          expect(e.childNodes.length).toBe(3);
+          textNode1 = e.childNodes[0];
+          child = e.childNodes[1];
+          textNode2 = e.childNodes[2];
+          expect(e.id).toBe('parent');
+          expectTextNode(textNode1, '  ');
+          expect(child.id).toBe('child');
+          expect(child.childNodes.length).toBe(0);
+          expectTextNode(textNode2, '   ');
+        },
+      );
+
+      itRenders('a composite with multiple children', async render => {
+        const Component = props => props.children;
+        const e = await render(
+          <Component>{['a', 'b', [undefined], [[false, 'c']]]}</Component>,
+        );
+
+        let parent = e.parentNode;
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          // For plain server markup result we have comments between.
+          // If we're able to hydrate, they remain.
+          expect(parent.childNodes.length).toBe(5);
+          expectTextNode(parent.childNodes[0], 'a');
+          expectTextNode(parent.childNodes[2], 'b');
+          expectTextNode(parent.childNodes[4], 'c');
+        } else {
+          expect(parent.childNodes.length).toBe(3);
+          expectTextNode(parent.childNodes[0], 'a');
+          expectTextNode(parent.childNodes[1], 'b');
+          expectTextNode(parent.childNodes[2], 'c');
+        }
+      });
+    });
+
+    describe('escaping >, <, and &', function() {
+      itRenders('>,<, and & as single child', async render => {
+        const e = await render(<div>{'<span>Text&quot;</span>'}</div>);
+        expect(e.childNodes.length).toBe(1);
+        expectNode(e.firstChild, TEXT_NODE_TYPE, '<span>Text&quot;</span>');
+      });
+
+      itRenders('>,<, and & as multiple children', async render => {
+        const e = await render(
+          <div>
+            {'<span>Text1&quot;</span>'}
+            {'<span>Text2&quot;</span>'}
+          </div>,
+        );
+        if (
+          render === serverRender ||
+          render === clientRenderOnServerString ||
+          render === streamRender
+        ) {
+          expect(e.childNodes.length).toBe(3);
+          expectTextNode(e.childNodes[0], '<span>Text1&quot;</span>');
+          expectTextNode(e.childNodes[2], '<span>Text2&quot;</span>');
+        } else {
+          expect(e.childNodes.length).toBe(2);
+          expectTextNode(e.childNodes[0], '<span>Text1&quot;</span>');
+          expectTextNode(e.childNodes[1], '<span>Text2&quot;</span>');
+        }
+      });
+    });
+
+    describe('carriage return and null character', () => {
+      // HTML parsing normalizes CR and CRLF to LF.
+      // It also ignores null character.
+      // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
+      // If we have a mismatch, it might be caused by that (and should not be reported).
+      // We won't be patching up in this case as that matches our past behavior.
+
+      itRenders(
+        'an element with one text child with special characters',
+        async render => {
+          const e = await render(<div>{'foo\rbar\r\nbaz\nqux\u0000'}</div>);
+          if (render === serverRender || render === streamRender) {
+            expect(e.childNodes.length).toBe(1);
+            // Everything becomes LF when parsed from server HTML.
+            // Null character is ignored.
+            expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar\nbaz\nqux');
+          } else {
+            expect(e.childNodes.length).toBe(1);
+            // Client rendering (or hydration) uses JS value with CR.
+            // Null character stays.
+            expectNode(
+              e.childNodes[0],
+              TEXT_NODE_TYPE,
+              'foo\rbar\r\nbaz\nqux\u0000',
+            );
+          }
+        },
+      );
+
+      itRenders(
+        'an element with two text children with special characters',
+        async render => {
+          const e = await render(
+            <div>
+              {'foo\rbar'}
+              {'\r\nbaz\nqux\u0000'}
+            </div>,
+          );
+          if (render === serverRender || render === streamRender) {
+            // We have three nodes because there is a comment between them.
+            expect(e.childNodes.length).toBe(3);
+            // Everything becomes LF when parsed from server HTML.
+            // Null character is ignored.
+            expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar');
+            expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\nbaz\nqux');
+          } else if (render === clientRenderOnServerString) {
+            // We have three nodes because there is a comment between them.
+            expect(e.childNodes.length).toBe(3);
+            // Hydration uses JS value with CR and null character.
+            expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\rbar');
+            expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\r\nbaz\nqux\u0000');
+          } else {
+            expect(e.childNodes.length).toBe(2);
+            // Client rendering uses JS value with CR and null character.
+            expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\rbar');
+            expectNode(e.childNodes[1], TEXT_NODE_TYPE, '\r\nbaz\nqux\u0000');
+          }
+        },
+      );
+
+      itRenders(
+        'an element with an attribute value with special characters',
+        async render => {
+          const e = await render(<a title={'foo\rbar\r\nbaz\nqux\u0000'} />);
+          if (
+            render === serverRender ||
+            render === streamRender ||
+            render === clientRenderOnServerString
+          ) {
+            // Everything becomes LF when parsed from server HTML.
+            // Null character in an attribute becomes the replacement character.
+            // Hydration also ends up with LF because we don't patch up attributes.
+            expect(e.title).toBe('foo\nbar\nbaz\nqux\uFFFD');
+          } else {
+            // Client rendering uses JS value with CR and null character.
+            expect(e.title).toBe('foo\rbar\r\nbaz\nqux\u0000');
+          }
+        },
+      );
+    });
+
+    describe('components that throw errors', function() {
+      itThrowsWhenRendering(
+        'a function returning undefined',
+        async render => {
+          const UndefinedComponent = () => undefined;
+          await render(<UndefinedComponent />, 1);
+        },
+        'UndefinedComponent(...): Nothing was returned from render. ' +
+          'This usually means a return statement is missing. Or, to ' +
+          'render nothing, return null.',
+      );
+
+      itThrowsWhenRendering(
+        'a class returning undefined',
+        async render => {
+          class UndefinedComponent extends React.Component {
+            render() {
+              return undefined;
+            }
+          }
+          await render(<UndefinedComponent />, 1);
+        },
+        'UndefinedComponent(...): Nothing was returned from render. ' +
+          'This usually means a return statement is missing. Or, to ' +
+          'render nothing, return null.',
+      );
+
+      itThrowsWhenRendering(
+        'a function returning an object',
+        async render => {
+          const ObjectComponent = () => ({x: 123});
+          await render(<ObjectComponent />, 1);
+        },
+        'Objects are not valid as a React child (found: object with keys {x}).' +
+          (__DEV__
+            ? ' If you meant to render a collection of children, use ' +
+              'an array instead.'
+            : ''),
+      );
+
+      itThrowsWhenRendering(
+        'a class returning an object',
+        async render => {
+          class ObjectComponent extends React.Component {
+            render() {
+              return {x: 123};
+            }
+          }
+          await render(<ObjectComponent />, 1);
+        },
+        'Objects are not valid as a React child (found: object with keys {x}).' +
+          (__DEV__
+            ? ' If you meant to render a collection of children, use ' +
+              'an array instead.'
+            : ''),
+      );
+
+      itThrowsWhenRendering(
+        'top-level object',
+        async render => {
+          await render({x: 123});
+        },
+        'Objects are not valid as a React child (found: object with keys {x}).' +
+          (__DEV__
+            ? ' If you meant to render a collection of children, use ' +
+              'an array instead.'
+            : ''),
+      );
+    });
+  });
+});

commit 48616e591fe23c0b89b0823c3ec99bae2d7b6853
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Tue Dec 5 16:29:22 2017 -0200

    react-dom: convert packages/react-dom/src/__tests__ (#11776)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index bdf2557534..9ec2227835 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -550,7 +550,7 @@ describe('ReactDOMServerIntegration', () => {
             </Component>
           </Component>,
         );
-        for (var i = 0; i < 3; i++) {
+        for (let i = 0; i < 3; i++) {
           expect(e.tagName).toBe('DIV');
           expect(e.childNodes.length).toBe(1);
           e = e.firstChild;
@@ -575,12 +575,12 @@ describe('ReactDOMServerIntegration', () => {
         );
         expect(e.tagName).toBe('DIV');
         expect(e.childNodes.length).toBe(2);
-        for (var i = 0; i < 2; i++) {
-          var child = e.childNodes[i];
+        for (let i = 0; i < 2; i++) {
+          const child = e.childNodes[i];
           expect(child.tagName).toBe('DIV');
           expect(child.childNodes.length).toBe(2);
-          for (var j = 0; j < 2; j++) {
-            var grandchild = child.childNodes[j];
+          for (let j = 0; j < 2; j++) {
+            const grandchild = child.childNodes[j];
             expect(grandchild.tagName).toBe('DIV');
             expect(grandchild.childNodes.length).toBe(0);
           }

commit d289d4b634749861199556e42174a3f4a3ce2b16
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 4 18:57:30 2018 +0000

    Update to Jest 22 (#11956)
    
    * Bump deps to Jest 22
    
    * Prevent jsdom from logging intentionally thrown errors
    
    This relies on our existing special field that we use to mute errors.
    Perhaps, it would be better to instead rely on preventDefault() directly.
    I outlined a possible strategy here: https://github.com/facebook/react/issues/11098#issuecomment-355032539
    
    * Update snapshots
    
    * Mock out a method called by ReactART that now throws
    
    * Calling .click() no longer works, dispatch event instead
    
    * Fix incorrect SVG element creation in test
    
    * Render SVG elements inside <svg> to avoid extra warnings
    
    * Fix range input test to use numeric value
    
    * Fix creating SVG element in test
    
    * Replace brittle test that relied on jsdom behavior
    
    The test passed in jsdom due to its implementation details.
    
    The original intention was to test the mutation method, but it was removed a while ago.
    
    Following @nhunzaker's suggestion, I moved the tests to ReactDOMInput and adjusted them to not rely on implementation details.
    
    * Add a workaround for the expected extra client-side warning
    
    This is a bit ugly but it's just two places. I think we can live with this.
    
    * Only warn once for mismatches caused by bad attribute casing
    
    We used to warn both about bad casing and about a mismatch.
    The mismatch warning was a bit confusing. We didn't know we warned twice because jsdom didn't faithfully emulate SVG.
    
    This changes the behavior to only leave the warning about bad casing if that's what caused the mismatch.
    It also adjusts the test to have an expectation that matches the real world behavior.
    
    * Add an expected warning per comment in the same test

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 9ec2227835..b03f9ed364 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -134,6 +134,16 @@ describe('ReactDOMServerIntegration', () => {
       });
 
       itRenders('a non-standard element with text', async render => {
+        // This test suite generally assumes that we get exactly
+        // the same warnings (or none) for all scenarios including
+        // SSR + innerHTML, hydration, and client-side rendering.
+        // However this particular warning fires only when creating
+        // DOM nodes on the client side. We force it to fire early
+        // so that it gets deduplicated later, and doesn't fail the test.
+        expect(() => {
+          ReactDOM.render(<nonstandard />, document.createElement('div'));
+        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.');
+
         const e = await render(<nonstandard>Text</nonstandard>);
         expect(e.tagName).toBe('NONSTANDARD');
         expect(e.childNodes.length).toBe(1);

commit 86914cb30a7654d13a17d34a3b3a5af97c2d2855
Author: Jordan Tepper <jstepper91@gmail.com>
Date:   Mon Feb 5 12:09:09 2018 -0500

    Clearer ssr error message 11902 (#11966)
    
    * Match error message to one in `ReactFiber.js`
    
    * Add undefined/null guard and tests
    
    * Update tests and element check
    
    * Remove beforeEach block

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index b03f9ed364..f50253904d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -871,5 +871,71 @@ describe('ReactDOMServerIntegration', () => {
             : ''),
       );
     });
+
+    describe('badly-typed elements', function() {
+      itThrowsWhenRendering(
+        'object',
+        async render => {
+          let EmptyComponent = {};
+          expect(() => {
+            EmptyComponent = <EmptyComponent />;
+          }).toWarnDev(
+            'Warning: React.createElement: type is invalid -- expected a string ' +
+              '(for built-in components) or a class/function (for composite ' +
+              'components) but got: object. You likely forgot to export your ' +
+              "component from the file it's defined in, or you might have mixed up " +
+              'default and named imports.',
+          );
+          await render(EmptyComponent);
+        },
+        'Element type is invalid: expected a string (for built-in components) or a class/function ' +
+          '(for composite components) but got: object.' +
+          (__DEV__
+            ? " You likely forgot to export your component from the file it's defined in, " +
+              'or you might have mixed up default and named imports.'
+            : ''),
+      );
+
+      itThrowsWhenRendering(
+        'null',
+        async render => {
+          let NullComponent = null;
+          expect(() => {
+            NullComponent = <NullComponent />;
+          }).toWarnDev(
+            'Warning: React.createElement: type is invalid -- expected a string ' +
+              '(for built-in components) or a class/function (for composite ' +
+              'components) but got: null.',
+          );
+          await render(NullComponent);
+        },
+        'Element type is invalid: expected a string (for built-in components) or a class/function ' +
+          '(for composite components) but got: null',
+      );
+
+      itThrowsWhenRendering(
+        'undefined',
+        async render => {
+          let UndefinedComponent = undefined;
+          expect(() => {
+            UndefinedComponent = <UndefinedComponent />;
+          }).toWarnDev(
+            'Warning: React.createElement: type is invalid -- expected a string ' +
+              '(for built-in components) or a class/function (for composite ' +
+              'components) but got: undefined. You likely forgot to export your ' +
+              "component from the file it's defined in, or you might have mixed up " +
+              'default and named imports.',
+          );
+
+          await render(UndefinedComponent);
+        },
+        'Element type is invalid: expected a string (for built-in components) or a class/function ' +
+          '(for composite components) but got: undefined.' +
+          (__DEV__
+            ? " You likely forgot to export your component from the file it's defined in, " +
+              'or you might have mixed up default and named imports.'
+            : ''),
+      );
+    });
   });
 });

commit 467d1391016dd2df8e1946aa33c6d6e1219c9dbb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Jul 16 20:20:18 2018 +0100

    Enforce presence or absence of component stack in tests (#13215)
    
    * Enforce presence or absence of stack in tests
    
    * Rename expectNoStack to withoutStack
    
    * Fix lint
    
    * Add some tests for toWarnDev()

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index f50253904d..087b66474c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -142,7 +142,9 @@ describe('ReactDOMServerIntegration', () => {
         // so that it gets deduplicated later, and doesn't fail the test.
         expect(() => {
           ReactDOM.render(<nonstandard />, document.createElement('div'));
-        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.');
+        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.', {
+          withoutStack: true, // TODO: add a stack
+        });
 
         const e = await render(<nonstandard>Text</nonstandard>);
         expect(e.tagName).toBe('NONSTANDARD');
@@ -885,6 +887,7 @@ describe('ReactDOMServerIntegration', () => {
               'components) but got: object. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +
               'default and named imports.',
+            {withoutStack: true},
           );
           await render(EmptyComponent);
         },
@@ -906,6 +909,7 @@ describe('ReactDOMServerIntegration', () => {
             'Warning: React.createElement: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: null.',
+            {withoutStack: true},
           );
           await render(NullComponent);
         },
@@ -925,6 +929,7 @@ describe('ReactDOMServerIntegration', () => {
               'components) but got: undefined. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +
               'default and named imports.',
+            {withoutStack: true},
           );
 
           await render(UndefinedComponent);

commit 82c7ca4cca90976cd1230e03ea1a4372a4276e67
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jul 17 20:15:03 2018 +0100

    Add component stacks to some warnings (#13218)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 087b66474c..dc0631d1d0 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -142,9 +142,7 @@ describe('ReactDOMServerIntegration', () => {
         // so that it gets deduplicated later, and doesn't fail the test.
         expect(() => {
           ReactDOM.render(<nonstandard />, document.createElement('div'));
-        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.', {
-          withoutStack: true, // TODO: add a stack
-        });
+        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.');
 
         const e = await render(<nonstandard>Text</nonstandard>);
         expect(e.tagName).toBe('NONSTANDARD');

commit be4533af7d29f020499d3c01931e55ef8666a419
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Aug 9 18:05:05 2018 +0100

    Fix hydration of non-string dangerousSetInnerHTML.__html (#13353)
    
    * Consistently handle non-string dangerousSetInnerHTML.__html in SSR
    
    * Add another test

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index dc0631d1d0..39f9cf4c2a 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -485,16 +485,97 @@ describe('ReactDOMServerIntegration', () => {
       expect(e.tagName).toBe('BUTTON');
     });
 
-    itRenders('a div with dangerouslySetInnerHTML', async render => {
-      const e = await render(
-        <div dangerouslySetInnerHTML={{__html: "<span id='child'/>"}} />,
-      );
+    itRenders('a div with dangerouslySetInnerHTML number', async render => {
+      // Put dangerouslySetInnerHTML one level deeper because otherwise
+      // hydrating from a bad markup would cause a mismatch (since we don't
+      // patch dangerouslySetInnerHTML as text content).
+      const e = (await render(
+        <div>
+          <span dangerouslySetInnerHTML={{__html: 0}} />
+        </div>,
+      )).firstChild;
+      expect(e.childNodes.length).toBe(1);
+      expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
+      expect(e.textContent).toBe('0');
+    });
+
+    itRenders('a div with dangerouslySetInnerHTML boolean', async render => {
+      // Put dangerouslySetInnerHTML one level deeper because otherwise
+      // hydrating from a bad markup would cause a mismatch (since we don't
+      // patch dangerouslySetInnerHTML as text content).
+      const e = (await render(
+        <div>
+          <span dangerouslySetInnerHTML={{__html: false}} />
+        </div>,
+      )).firstChild;
+      expect(e.childNodes.length).toBe(1);
+      expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
+      expect(e.firstChild.data).toBe('false');
+    });
+
+    itRenders(
+      'a div with dangerouslySetInnerHTML text string',
+      async render => {
+        // Put dangerouslySetInnerHTML one level deeper because otherwise
+        // hydrating from a bad markup would cause a mismatch (since we don't
+        // patch dangerouslySetInnerHTML as text content).
+        const e = (await render(
+          <div>
+            <span dangerouslySetInnerHTML={{__html: 'hello'}} />
+          </div>,
+        )).firstChild;
+        expect(e.childNodes.length).toBe(1);
+        expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
+        expect(e.textContent).toBe('hello');
+      },
+    );
+
+    itRenders(
+      'a div with dangerouslySetInnerHTML element string',
+      async render => {
+        const e = await render(
+          <div dangerouslySetInnerHTML={{__html: "<span id='child'/>"}} />,
+        );
+        expect(e.childNodes.length).toBe(1);
+        expect(e.firstChild.tagName).toBe('SPAN');
+        expect(e.firstChild.getAttribute('id')).toBe('child');
+        expect(e.firstChild.childNodes.length).toBe(0);
+      },
+    );
+
+    itRenders('a div with dangerouslySetInnerHTML object', async render => {
+      const obj = {
+        toString() {
+          return "<span id='child'/>";
+        },
+      };
+      const e = await render(<div dangerouslySetInnerHTML={{__html: obj}} />);
       expect(e.childNodes.length).toBe(1);
       expect(e.firstChild.tagName).toBe('SPAN');
       expect(e.firstChild.getAttribute('id')).toBe('child');
       expect(e.firstChild.childNodes.length).toBe(0);
     });
 
+    itRenders(
+      'a div with dangerouslySetInnerHTML set to null',
+      async render => {
+        const e = await render(
+          <div dangerouslySetInnerHTML={{__html: null}} />,
+        );
+        expect(e.childNodes.length).toBe(0);
+      },
+    );
+
+    itRenders(
+      'a div with dangerouslySetInnerHTML set to undefined',
+      async render => {
+        const e = await render(
+          <div dangerouslySetInnerHTML={{__html: undefined}} />,
+        );
+        expect(e.childNodes.length).toBe(0);
+      },
+    );
+
     describe('newline-eating elements', function() {
       itRenders(
         'a newline-eating tag with content not starting with \\n',

commit 0b74e95d7b7fabbd0cf502d0f3254a607ed30478
Author: Fredrik Hglund <fredrik.hoglund@gmail.com>
Date:   Mon Sep 3 18:17:53 2018 +0200

    Ignore noscript content on the client (#13537)
    
    * Ignore noscript content on the client (#11423)
    
    * Fix failing test for ignoring noscript content
    
    * Add a ServerIntegration test for noscript

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 39f9cf4c2a..24fc8cd49a 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -36,6 +36,7 @@ const {
   itThrowsWhenRendering,
   serverRender,
   streamRender,
+  clientCleanRender,
   clientRenderOnServerString,
 } = ReactDOMServerIntegrationUtils(initModules);
 
@@ -576,6 +577,24 @@ describe('ReactDOMServerIntegration', () => {
       },
     );
 
+    itRenders('a noscript with children', async render => {
+      const e = await render(
+        <noscript>
+          <div>Enable JavaScript to run this app.</div>
+        </noscript>,
+      );
+      if (render === clientCleanRender) {
+        // On the client we ignore the contents of a noscript
+        expect(e.childNodes.length).toBe(0);
+      } else {
+        // On the server or when hydrating the content should be correct
+        expect(e.childNodes.length).toBe(1);
+        expect(e.firstChild.textContent).toBe(
+          '<div>Enable JavaScript to run this app.</div>',
+        );
+      }
+    });
+
     describe('newline-eating elements', function() {
       itRenders(
         'a newline-eating tag with content not starting with \\n',

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Hctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 24fc8cd49a..e49e1f1ff4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 40a521aa7247872d0080d5a581120b64998152da
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 4 22:44:46 2018 +0100

    Terminology: Functional -> Function Component (#13775)
    
    * Terminology: Functional -> Function Component
    
    * Drop the "stateless" (functions are already stateless, right?)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index e49e1f1ff4..33f63a26f2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -623,8 +623,8 @@ describe('ReactDOMServerIntegration', () => {
       }
 
       itRenders('stateless components', async render => {
-        const StatelessComponent = () => <div>foo</div>;
-        checkFooDiv(await render(<StatelessComponent />));
+        const FunctionComponent = () => <div>foo</div>;
+        checkFooDiv(await render(<FunctionComponent />));
       });
 
       itRenders('ES6 class components', async render => {

commit acd65db5bc2cd1ab19be66318f3e931054796739
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 19 12:55:27 2019 -0700

    Deprecate module pattern (factory) components (#15145)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 33f63a26f2..535191d66e 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -644,7 +644,7 @@ describe('ReactDOMServerIntegration', () => {
             },
           };
         };
-        checkFooDiv(await render(<FactoryComponent />));
+        checkFooDiv(await render(<FactoryComponent />, 1));
       });
     });
 

commit e1c5e8720d5d47974c14c125dbaf3dc608a92936
Author: Sunil Pai <threepointone@fb.com>
Date:   Mon Jun 24 11:18:24 2019 +0100

    warn if passive effects get queued outside of an act() call. (#15763)
    
    * warn if passive effects get queued outside of an act() call
    
    While the code itself isn't much (it adds the warning to mountEffect() and updateEffect() in ReactFiberHooks), it does change a lot of our tests. We follow a bad-ish pattern here, which is doing asserts inside act() scopes, but it makes sense for *us* because we're testing intermediate states, and we're manually flush/yield what we need in these tests.
    
    This commit has one last failing test. Working on it.
    
    * pass lint
    
    * pass failing test, fixes another
    
    - a test was failing in ReactDOMServerIntegrationHooks while testing an effect; the behaviour of yields was different from browser and server when wrapped with act(). further, because of how we initialized modules, act() around renders wasn't working corrrectly. solved by passing in ReactTestUtils in initModules, and checking on the finally yielded values in the specific test.
    - in ReactUpdates, while testing an infinite recursion detection, the test needed to be wrapped in an act(), which would have caused the recusrsion error to throw. solived by rethrowing the error from inside the act().
    
    * pass ReactDOMServerSuspense
    
    * stray todo
    
    * a better message, consistent with the state update one.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 535191d66e..8b66321f86 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -16,17 +16,20 @@ const TEXT_NODE_TYPE = 3;
 let React;
 let ReactDOM;
 let ReactDOMServer;
+let ReactTestUtils;
 
 function initModules() {
   jest.resetModuleRegistry();
   React = require('react');
   ReactDOM = require('react-dom');
   ReactDOMServer = require('react-dom/server');
+  ReactTestUtils = require('react-dom/test-utils');
 
   // Make them available to the helpers.
   return {
     ReactDOM,
     ReactDOMServer,
+    ReactTestUtils,
   };
 }
 

commit e308a037beb6df9851d997ef1c8ea9de103b6adb
Author: Simen Bekkhus <sbekkhus91@gmail.com>
Date:   Wed Aug 14 13:32:26 2019 +0200

    chore: make tests compatible with Jest 24 (#15779)
    
    * chore: make tests compatible with Jest 24
    
    * remove fake rafs
    
    * rollback jsdom for localstorage compat
    
    * Apply suggestions from code review
    
    Co-Authored-By: Sunil Pai <threepointone@oculus.com>
    
    * chore: cleanup lockfile

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 8b66321f86..a16190db05 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -651,7 +651,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('component hierarchies', async function() {
+    describe('component hierarchies', function() {
       itRenders('single child hierarchies of components', async render => {
         const Component = props => <div>{props.children}</div>;
         let e = await render(

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index a16190db05..9c98f10cb2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -146,7 +146,7 @@ describe('ReactDOMServerIntegration', () => {
         // so that it gets deduplicated later, and doesn't fail the test.
         expect(() => {
           ReactDOM.render(<nonstandard />, document.createElement('div'));
-        }).toWarnDev('The tag <nonstandard> is unrecognized in this browser.');
+        }).toErrorDev('The tag <nonstandard> is unrecognized in this browser.');
 
         const e = await render(<nonstandard>Text</nonstandard>);
         expect(e.tagName).toBe('NONSTANDARD');
@@ -982,7 +982,7 @@ describe('ReactDOMServerIntegration', () => {
           let EmptyComponent = {};
           expect(() => {
             EmptyComponent = <EmptyComponent />;
-          }).toWarnDev(
+          }).toErrorDev(
             'Warning: React.createElement: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: object. You likely forgot to export your ' +
@@ -1006,7 +1006,7 @@ describe('ReactDOMServerIntegration', () => {
           let NullComponent = null;
           expect(() => {
             NullComponent = <NullComponent />;
-          }).toWarnDev(
+          }).toErrorDev(
             'Warning: React.createElement: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: null.',
@@ -1024,7 +1024,7 @@ describe('ReactDOMServerIntegration', () => {
           let UndefinedComponent = undefined;
           expect(() => {
             UndefinedComponent = <UndefinedComponent />;
-          }).toWarnDev(
+          }).toErrorDev(
             'Warning: React.createElement: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: undefined. You likely forgot to export your ' +

commit b979db4e7215957f03c4221622f0b115a868439a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 13:54:11 2020 +0000

    Bump Prettier (#17811)
    
    * Bump Prettier
    
    * Reformat
    
    * Use non-deprecated option

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 9c98f10cb2..5d56419a1a 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -258,8 +258,7 @@ describe('ReactDOMServerIntegration', () => {
           <div>
             {[['a'], 'b']}
             <div>
-              <X key="1" />
-              d
+              <X key="1" />d
             </div>
             e
           </div>,
@@ -493,11 +492,13 @@ describe('ReactDOMServerIntegration', () => {
       // Put dangerouslySetInnerHTML one level deeper because otherwise
       // hydrating from a bad markup would cause a mismatch (since we don't
       // patch dangerouslySetInnerHTML as text content).
-      const e = (await render(
-        <div>
-          <span dangerouslySetInnerHTML={{__html: 0}} />
-        </div>,
-      )).firstChild;
+      const e = (
+        await render(
+          <div>
+            <span dangerouslySetInnerHTML={{__html: 0}} />
+          </div>,
+        )
+      ).firstChild;
       expect(e.childNodes.length).toBe(1);
       expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
       expect(e.textContent).toBe('0');
@@ -507,11 +508,13 @@ describe('ReactDOMServerIntegration', () => {
       // Put dangerouslySetInnerHTML one level deeper because otherwise
       // hydrating from a bad markup would cause a mismatch (since we don't
       // patch dangerouslySetInnerHTML as text content).
-      const e = (await render(
-        <div>
-          <span dangerouslySetInnerHTML={{__html: false}} />
-        </div>,
-      )).firstChild;
+      const e = (
+        await render(
+          <div>
+            <span dangerouslySetInnerHTML={{__html: false}} />
+          </div>,
+        )
+      ).firstChild;
       expect(e.childNodes.length).toBe(1);
       expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
       expect(e.firstChild.data).toBe('false');
@@ -523,11 +526,13 @@ describe('ReactDOMServerIntegration', () => {
         // Put dangerouslySetInnerHTML one level deeper because otherwise
         // hydrating from a bad markup would cause a mismatch (since we don't
         // patch dangerouslySetInnerHTML as text content).
-        const e = (await render(
-          <div>
-            <span dangerouslySetInnerHTML={{__html: 'hello'}} />
-          </div>,
-        )).firstChild;
+        const e = (
+          await render(
+            <div>
+              <span dangerouslySetInnerHTML={{__html: 'hello'}} />
+            </div>,
+          )
+        ).firstChild;
         expect(e.childNodes.length).toBe(1);
         expect(e.firstChild.nodeType).toBe(TEXT_NODE_TYPE);
         expect(e.textContent).toBe('hello');

commit d8d2b6e89cdff27a1ac246c6e9e030c2cc8760e3
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Apr 1 18:31:59 2020 +0100

    Disable module components dynamically for WWW (#18446)
    
    * Make disableModulePatternComponents dynamic for WWW
    
    * Run both flags and tests and respect the flag in SSR

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 5d56419a1a..383bcd03e5 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -644,16 +644,33 @@ describe('ReactDOMServerIntegration', () => {
         checkFooDiv(await render(<ClassComponent />));
       });
 
-      itRenders('factory components', async render => {
-        const FactoryComponent = () => {
-          return {
-            render: function() {
-              return <div>foo</div>;
-            },
+      if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
+        itThrowsWhenRendering(
+          'factory components',
+          async render => {
+            const FactoryComponent = () => {
+              return {
+                render: function() {
+                  return <div>foo</div>;
+                },
+              };
+            };
+            await render(<FactoryComponent />, 1);
+          },
+          'Objects are not valid as a React child (found: object with keys {render})',
+        );
+      } else {
+        itRenders('factory components', async render => {
+          const FactoryComponent = () => {
+            return {
+              render: function() {
+                return <div>foo</div>;
+              },
+            };
           };
-        };
-        checkFooDiv(await render(<FactoryComponent />, 1));
-      });
+          checkFooDiv(await render(<FactoryComponent />, 1));
+        });
+      }
     });
 
     describe('component hierarchies', function() {

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 383bcd03e5..859647b39c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -128,9 +128,8 @@ describe('ReactDOMServerIntegration', () => {
             Text<span>More Text</span>
           </div>,
         );
-        let spanNode;
         expect(e.childNodes.length).toBe(2);
-        spanNode = e.childNodes[1];
+        const spanNode = e.childNodes[1];
         expectTextNode(e.childNodes[0], 'Text');
         expect(spanNode.tagName).toBe('SPAN');
         expect(spanNode.childNodes.length).toBe(1);
@@ -397,7 +396,7 @@ describe('ReactDOMServerIntegration', () => {
       });
 
       itRenders('svg child element with an attribute', async render => {
-        let e = await render(<svg viewBox="0 0 0 0" />);
+        const e = await render(<svg viewBox="0 0 0 0" />);
         expect(e.childNodes.length).toBe(0);
         expect(e.tagName).toBe('svg');
         expect(e.namespaceURI).toBe('http://www.w3.org/2000/svg');
@@ -439,14 +438,14 @@ describe('ReactDOMServerIntegration', () => {
       });
 
       itRenders('svg element with a tabIndex attribute', async render => {
-        let e = await render(<svg tabIndex="1" />);
+        const e = await render(<svg tabIndex="1" />);
         expect(e.tabIndex).toBe(1);
       });
 
       itRenders(
         'svg element with a badly cased tabIndex attribute',
         async render => {
-          let e = await render(<svg tabindex="1" />, 1);
+          const e = await render(<svg tabindex="1" />, 1);
           expect(e.tabIndex).toBe(1);
         },
       );
@@ -758,11 +757,10 @@ describe('ReactDOMServerIntegration', () => {
             </div>,
           );
           expect(e.id).toBe('parent');
-          let child1, child2, textNode;
           expect(e.childNodes.length).toBe(3);
-          child1 = e.childNodes[0];
-          textNode = e.childNodes[1];
-          child2 = e.childNodes[2];
+          const child1 = e.childNodes[0];
+          const textNode = e.childNodes[1];
+          const child2 = e.childNodes[2];
           expect(child1.id).toBe('child1');
           expect(child1.childNodes.length).toBe(0);
           expectTextNode(textNode, ' ');
@@ -776,11 +774,10 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           // prettier-ignore
           const e = await render(<div id="parent">  <div id="child" />   </div>); // eslint-disable-line no-multi-spaces
-          let textNode1, child, textNode2;
           expect(e.childNodes.length).toBe(3);
-          textNode1 = e.childNodes[0];
-          child = e.childNodes[1];
-          textNode2 = e.childNodes[2];
+          const textNode1 = e.childNodes[0];
+          const child = e.childNodes[1];
+          const textNode2 = e.childNodes[2];
           expect(e.id).toBe('parent');
           expectTextNode(textNode1, '  ');
           expect(child.id).toBe('child');
@@ -795,7 +792,7 @@ describe('ReactDOMServerIntegration', () => {
           <Component>{['a', 'b', [undefined], [[false, 'c']]]}</Component>,
         );
 
-        let parent = e.parentNode;
+        const parent = e.parentNode;
         if (
           render === serverRender ||
           render === clientRenderOnServerString ||

commit 14bac6193a334eda42e727336e8967419f08f5df
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Jul 13 15:48:11 2021 -0400

    Allow components to render undefined (#21869)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 859647b39c..c41170aa54 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -924,33 +924,37 @@ describe('ReactDOMServerIntegration', () => {
       );
     });
 
-    describe('components that throw errors', function() {
-      itThrowsWhenRendering(
-        'a function returning undefined',
-        async render => {
-          const UndefinedComponent = () => undefined;
-          await render(<UndefinedComponent />, 1);
-        },
-        'UndefinedComponent(...): Nothing was returned from render. ' +
-          'This usually means a return statement is missing. Or, to ' +
-          'render nothing, return null.',
-      );
+    describe('components that render nullish', function() {
+      itRenders('a function returning null', async render => {
+        const NullComponent = () => null;
+        await render(<NullComponent />);
+      });
 
-      itThrowsWhenRendering(
-        'a class returning undefined',
-        async render => {
-          class UndefinedComponent extends React.Component {
-            render() {
-              return undefined;
-            }
+      itRenders('a class returning null', async render => {
+        class NullComponent extends React.Component {
+          render() {
+            return null;
           }
-          await render(<UndefinedComponent />, 1);
-        },
-        'UndefinedComponent(...): Nothing was returned from render. ' +
-          'This usually means a return statement is missing. Or, to ' +
-          'render nothing, return null.',
-      );
+        }
+        await render(<NullComponent />);
+      });
+
+      itRenders('a function returning undefined', async render => {
+        const UndefinedComponent = () => undefined;
+        await render(<UndefinedComponent />);
+      });
+
+      itRenders('a class returning undefined', async render => {
+        class UndefinedComponent extends React.Component {
+          render() {
+            return undefined;
+          }
+        }
+        await render(<UndefinedComponent />);
+      });
+    });
 
+    describe('components that throw errors', function() {
       itThrowsWhenRendering(
         'a function returning an object',
         async render => {

commit c1220ebdde506de91c8b9693b5cb67ac710c8c89
Author: salazarm <salazarm@users.noreply.github.com>
Date:   Tue Nov 23 18:40:10 2021 -0500

    treat empty string as null (#22807)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index c41170aa54..a856bd42ed 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -87,17 +87,8 @@ describe('ReactDOMServerIntegration', () => {
             {''}
           </div>,
         );
-        if (render === serverRender || render === streamRender) {
-          // For plain server markup result we should have no text nodes if
-          // they're all empty.
-          expect(e.childNodes.length).toBe(0);
-          expect(e.textContent).toBe('');
-        } else {
-          expect(e.childNodes.length).toBe(3);
-          expectTextNode(e.childNodes[0], '');
-          expectTextNode(e.childNodes[1], '');
-          expectTextNode(e.childNodes[2], '');
-        }
+        expect(e.childNodes.length).toBe(0);
+        expect(e.textContent).toBe('');
       });
 
       itRenders('a div with multiple whitespace children', async render => {
@@ -162,27 +153,14 @@ describe('ReactDOMServerIntegration', () => {
 
       itRenders('a leading blank child with a text sibling', async render => {
         const e = await render(<div>{''}foo</div>);
-        if (render === serverRender || render === streamRender) {
-          expect(e.childNodes.length).toBe(1);
-          expectTextNode(e.childNodes[0], 'foo');
-        } else {
-          expect(e.childNodes.length).toBe(2);
-          expectTextNode(e.childNodes[0], '');
-          expectTextNode(e.childNodes[1], 'foo');
-        }
+        expect(e.childNodes.length).toBe(1);
+        expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('a trailing blank child with a text sibling', async render => {
         const e = await render(<div>foo{''}</div>);
-        // with Fiber, there are just two text nodes.
-        if (render === serverRender || render === streamRender) {
-          expect(e.childNodes.length).toBe(1);
-          expectTextNode(e.childNodes[0], 'foo');
-        } else {
-          expect(e.childNodes.length).toBe(2);
-          expectTextNode(e.childNodes[0], 'foo');
-          expectTextNode(e.childNodes[1], '');
-        }
+        expect(e.childNodes.length).toBe(1);
+        expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('an element with two text children', async render => {

commit 8d0d0e9a8aadc4bdddff3a40871dbc54c63264f3
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Thu Feb 24 20:09:03 2022 -0500

    Deprecate renderToNodeStream (and fix textarea bug) (#23359)
    
    * Deprecate renderToNodeStream
    
    * Use renderToPipeableStream in tests instead of renderToNodeStream
    
    This is the equivalent API. This means that we have way less test coverage
    of this API but I feel like that's fine since it has a deprecation warning
    in it and we have coverage on renderToString that is mostly the same.
    
    * Fix textarea bug
    
    The test changes revealed a bug with textarea. It happens because we
    currently always insert trailing comment nodes. We should optimize that
    away. However, we also don't really support complex children so we
    should toString it anyway which is what partial renderer used to do.
    
    * Update tests that assert number of nodes
    
    These tests are unnecessarily specific about number of nodes.
    
    I special case these, which these tests already do, because they're good
    tests to test that the optimization actually works later when we do
    fix it.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index a856bd42ed..6a777f3f43 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -101,7 +101,7 @@ describe('ReactDOMServerIntegration', () => {
         ) {
           // For plain server markup result we have comments between.
           // If we're able to hydrate, they remain.
-          expect(e.childNodes.length).toBe(5);
+          expect(e.childNodes.length).toBe(render === streamRender ? 6 : 5);
           expectTextNode(e.childNodes[0], ' ');
           expectTextNode(e.childNodes[2], ' ');
           expectTextNode(e.childNodes[4], ' ');
@@ -119,8 +119,8 @@ describe('ReactDOMServerIntegration', () => {
             Text<span>More Text</span>
           </div>,
         );
-        expect(e.childNodes.length).toBe(2);
-        const spanNode = e.childNodes[1];
+        expect(e.childNodes.length).toBe(render === streamRender ? 3 : 2);
+        const spanNode = e.childNodes[render === streamRender ? 2 : 1];
         expectTextNode(e.childNodes[0], 'Text');
         expect(spanNode.tagName).toBe('SPAN');
         expect(spanNode.childNodes.length).toBe(1);
@@ -147,19 +147,19 @@ describe('ReactDOMServerIntegration', () => {
       itRenders('a custom element with text', async render => {
         const e = await render(<custom-element>Text</custom-element>);
         expect(e.tagName).toBe('CUSTOM-ELEMENT');
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectNode(e.firstChild, TEXT_NODE_TYPE, 'Text');
       });
 
       itRenders('a leading blank child with a text sibling', async render => {
         const e = await render(<div>{''}foo</div>);
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('a trailing blank child with a text sibling', async render => {
         const e = await render(<div>foo{''}</div>);
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -176,7 +176,7 @@ describe('ReactDOMServerIntegration', () => {
           render === streamRender
         ) {
           // In the server render output there's a comment between them.
-          expect(e.childNodes.length).toBe(3);
+          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
           expectTextNode(e.childNodes[0], 'foo');
           expectTextNode(e.childNodes[2], 'bar');
         } else {
@@ -203,7 +203,7 @@ describe('ReactDOMServerIntegration', () => {
             render === streamRender
           ) {
             // In the server render output there's a comment between them.
-            expect(e.childNodes.length).toBe(5);
+            expect(e.childNodes.length).toBe(render === streamRender ? 6 : 5);
             expectTextNode(e.childNodes[0], 'a');
             expectTextNode(e.childNodes[2], 'b');
             expectTextNode(e.childNodes[4], 'c');
@@ -240,11 +240,7 @@ describe('ReactDOMServerIntegration', () => {
             e
           </div>,
         );
-        if (
-          render === serverRender ||
-          render === clientRenderOnServerString ||
-          render === streamRender
-        ) {
+        if (render === serverRender || render === clientRenderOnServerString) {
           // In the server render output there's comments between text nodes.
           expect(e.childNodes.length).toBe(5);
           expectTextNode(e.childNodes[0], 'a');
@@ -253,6 +249,15 @@ describe('ReactDOMServerIntegration', () => {
           expectTextNode(e.childNodes[3].childNodes[0], 'c');
           expectTextNode(e.childNodes[3].childNodes[2], 'd');
           expectTextNode(e.childNodes[4], 'e');
+        } else if (render === streamRender) {
+          // In the server render output there's comments after each text node.
+          expect(e.childNodes.length).toBe(7);
+          expectTextNode(e.childNodes[0], 'a');
+          expectTextNode(e.childNodes[2], 'b');
+          expect(e.childNodes[4].childNodes.length).toBe(4);
+          expectTextNode(e.childNodes[4].childNodes[0], 'c');
+          expectTextNode(e.childNodes[4].childNodes[2], 'd');
+          expectTextNode(e.childNodes[5], 'e');
         } else {
           expect(e.childNodes.length).toBe(4);
           expectTextNode(e.childNodes[0], 'a');
@@ -291,7 +296,7 @@ describe('ReactDOMServerIntegration', () => {
           render === streamRender
         ) {
           // In the server markup there's a comment between.
-          expect(e.childNodes.length).toBe(3);
+          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
           expectTextNode(e.childNodes[0], 'foo');
           expectTextNode(e.childNodes[2], '40');
         } else {
@@ -330,13 +335,13 @@ describe('ReactDOMServerIntegration', () => {
 
       itRenders('null children as blank', async render => {
         const e = await render(<div>{null}foo</div>);
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('false children as blank', async render => {
         const e = await render(<div>{false}foo</div>);
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -348,7 +353,7 @@ describe('ReactDOMServerIntegration', () => {
             {false}
           </div>,
         );
-        expect(e.childNodes.length).toBe(1);
+        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -735,10 +740,10 @@ describe('ReactDOMServerIntegration', () => {
             </div>,
           );
           expect(e.id).toBe('parent');
-          expect(e.childNodes.length).toBe(3);
+          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
           const child1 = e.childNodes[0];
           const textNode = e.childNodes[1];
-          const child2 = e.childNodes[2];
+          const child2 = e.childNodes[render === streamRender ? 3 : 2];
           expect(child1.id).toBe('child1');
           expect(child1.childNodes.length).toBe(0);
           expectTextNode(textNode, ' ');
@@ -752,10 +757,10 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           // prettier-ignore
           const e = await render(<div id="parent">  <div id="child" />   </div>); // eslint-disable-line no-multi-spaces
-          expect(e.childNodes.length).toBe(3);
+          expect(e.childNodes.length).toBe(render === streamRender ? 5 : 3);
           const textNode1 = e.childNodes[0];
-          const child = e.childNodes[1];
-          const textNode2 = e.childNodes[2];
+          const child = e.childNodes[render === streamRender ? 2 : 1];
+          const textNode2 = e.childNodes[render === streamRender ? 3 : 2];
           expect(e.id).toBe('parent');
           expectTextNode(textNode1, '  ');
           expect(child.id).toBe('child');
@@ -778,7 +783,9 @@ describe('ReactDOMServerIntegration', () => {
         ) {
           // For plain server markup result we have comments between.
           // If we're able to hydrate, they remain.
-          expect(parent.childNodes.length).toBe(5);
+          expect(parent.childNodes.length).toBe(
+            render === streamRender ? 6 : 5,
+          );
           expectTextNode(parent.childNodes[0], 'a');
           expectTextNode(parent.childNodes[2], 'b');
           expectTextNode(parent.childNodes[4], 'c');
@@ -810,7 +817,7 @@ describe('ReactDOMServerIntegration', () => {
           render === clientRenderOnServerString ||
           render === streamRender
         ) {
-          expect(e.childNodes.length).toBe(3);
+          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
           expectTextNode(e.childNodes[0], '<span>Text1&quot;</span>');
           expectTextNode(e.childNodes[2], '<span>Text2&quot;</span>');
         } else {
@@ -861,7 +868,7 @@ describe('ReactDOMServerIntegration', () => {
           );
           if (render === serverRender || render === streamRender) {
             // We have three nodes because there is a comment between them.
-            expect(e.childNodes.length).toBe(3);
+            expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
             // Everything becomes LF when parsed from server HTML.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar');

commit a2766387efe68b318b23d8c35c70b850d1e6a250
Author: Josh Story <story@hey.com>
Date:   Sat May 28 08:30:38 2022 -0700

    [Fizz] Improve text separator byte efficiency (#24630)
    
    * [Fizz] Improve text separator byte efficiency
    
    Previously text separators were inserted following any Text node in Fizz. This increases bytes sent when streaming and in some cases such as title elements these separators are not interpreted as comment nodes and leak into the visual aspects of a page as escaped text.
    
    The reason simple tracking on the last pushed type doesn't work is that Segments can be filled in asynchronously later and so you cannot know in a single pass whether the preceding content was a text node or not. This commit adds a concept of TextEmbedding which provides a best effort signal to Segments on whether they are embedded within text. This allows the later resolution of that Segment to add text separators when possibly necessary but avoid them when they are surely not.
    
    The current implementation can only "peek" head if the segment is a the Root Segment or a Suspense Boundary Segment. In these cases we know there is no trailing text embedding and we can eliminate the separator at the end of the segment if the last emitted element was Text. In normal Segments we cannot peek and thus have to assume there might be a trailing text embedding and we issue a separator defensively. This should be rare in practice as it is assumed most components that will cause segment creation will also emit some markup at the edges.
    
    * [Fizz] Improve separator efficiency when flushing delayed segments
    
    The method by which we get segment markup into the DOM differs depending on when the Segment resolves.
    
    If a Segment resolves before flushing begins for it's parent it will be emitted inline with the parent markup. In these cases separators may be necessary because they are how we clue the browser into breakup up text into distinct nodes that will later match up with what will be hydrated on the client.
    
    If a Segment resolves after flushing has happened a script will be used to patch up the DOM in the client. when this happens if there are any text nodes on the boundary of the patch they won't be "merged" and thus will continue to have distinct representation as Nodes in the DOM. Thus we can avoid doing any separators at the boundaries in these cases.
    
    After applying these changes the only time you will get text separators as follows
    
    * in between serial text nodes that emit at the same time - these are necessary and cannot be eliminated unless we stop relying on the browser to automatically parse the correct text nodes when processing this HTML
    * after a final text node in a non-boundary segment that resolves before it's parent has flushed - these are sometimes extraneous, like when the next emitted thing is a non-Text node.
    
    In all other cases text separators should be omitted which means the general byte efficiency of this approach should be pretty good

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 6a777f3f43..0dcfbbd78c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -101,7 +101,7 @@ describe('ReactDOMServerIntegration', () => {
         ) {
           // For plain server markup result we have comments between.
           // If we're able to hydrate, they remain.
-          expect(e.childNodes.length).toBe(render === streamRender ? 6 : 5);
+          expect(e.childNodes.length).toBe(5);
           expectTextNode(e.childNodes[0], ' ');
           expectTextNode(e.childNodes[2], ' ');
           expectTextNode(e.childNodes[4], ' ');
@@ -119,8 +119,8 @@ describe('ReactDOMServerIntegration', () => {
             Text<span>More Text</span>
           </div>,
         );
-        expect(e.childNodes.length).toBe(render === streamRender ? 3 : 2);
-        const spanNode = e.childNodes[render === streamRender ? 2 : 1];
+        expect(e.childNodes.length).toBe(2);
+        const spanNode = e.childNodes[1];
         expectTextNode(e.childNodes[0], 'Text');
         expect(spanNode.tagName).toBe('SPAN');
         expect(spanNode.childNodes.length).toBe(1);
@@ -147,19 +147,19 @@ describe('ReactDOMServerIntegration', () => {
       itRenders('a custom element with text', async render => {
         const e = await render(<custom-element>Text</custom-element>);
         expect(e.tagName).toBe('CUSTOM-ELEMENT');
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectNode(e.firstChild, TEXT_NODE_TYPE, 'Text');
       });
 
       itRenders('a leading blank child with a text sibling', async render => {
         const e = await render(<div>{''}foo</div>);
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('a trailing blank child with a text sibling', async render => {
         const e = await render(<div>foo{''}</div>);
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -176,7 +176,7 @@ describe('ReactDOMServerIntegration', () => {
           render === streamRender
         ) {
           // In the server render output there's a comment between them.
-          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
+          expect(e.childNodes.length).toBe(3);
           expectTextNode(e.childNodes[0], 'foo');
           expectTextNode(e.childNodes[2], 'bar');
         } else {
@@ -203,7 +203,7 @@ describe('ReactDOMServerIntegration', () => {
             render === streamRender
           ) {
             // In the server render output there's a comment between them.
-            expect(e.childNodes.length).toBe(render === streamRender ? 6 : 5);
+            expect(e.childNodes.length).toBe(5);
             expectTextNode(e.childNodes[0], 'a');
             expectTextNode(e.childNodes[2], 'b');
             expectTextNode(e.childNodes[4], 'c');
@@ -240,7 +240,11 @@ describe('ReactDOMServerIntegration', () => {
             e
           </div>,
         );
-        if (render === serverRender || render === clientRenderOnServerString) {
+        if (
+          render === serverRender ||
+          render === streamRender ||
+          render === clientRenderOnServerString
+        ) {
           // In the server render output there's comments between text nodes.
           expect(e.childNodes.length).toBe(5);
           expectTextNode(e.childNodes[0], 'a');
@@ -249,15 +253,6 @@ describe('ReactDOMServerIntegration', () => {
           expectTextNode(e.childNodes[3].childNodes[0], 'c');
           expectTextNode(e.childNodes[3].childNodes[2], 'd');
           expectTextNode(e.childNodes[4], 'e');
-        } else if (render === streamRender) {
-          // In the server render output there's comments after each text node.
-          expect(e.childNodes.length).toBe(7);
-          expectTextNode(e.childNodes[0], 'a');
-          expectTextNode(e.childNodes[2], 'b');
-          expect(e.childNodes[4].childNodes.length).toBe(4);
-          expectTextNode(e.childNodes[4].childNodes[0], 'c');
-          expectTextNode(e.childNodes[4].childNodes[2], 'd');
-          expectTextNode(e.childNodes[5], 'e');
         } else {
           expect(e.childNodes.length).toBe(4);
           expectTextNode(e.childNodes[0], 'a');
@@ -296,7 +291,7 @@ describe('ReactDOMServerIntegration', () => {
           render === streamRender
         ) {
           // In the server markup there's a comment between.
-          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
+          expect(e.childNodes.length).toBe(3);
           expectTextNode(e.childNodes[0], 'foo');
           expectTextNode(e.childNodes[2], '40');
         } else {
@@ -335,13 +330,13 @@ describe('ReactDOMServerIntegration', () => {
 
       itRenders('null children as blank', async render => {
         const e = await render(<div>{null}foo</div>);
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
       itRenders('false children as blank', async render => {
         const e = await render(<div>{false}foo</div>);
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -353,7 +348,7 @@ describe('ReactDOMServerIntegration', () => {
             {false}
           </div>,
         );
-        expect(e.childNodes.length).toBe(render === streamRender ? 2 : 1);
+        expect(e.childNodes.length).toBe(1);
         expectTextNode(e.childNodes[0], 'foo');
       });
 
@@ -740,10 +735,10 @@ describe('ReactDOMServerIntegration', () => {
             </div>,
           );
           expect(e.id).toBe('parent');
-          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
+          expect(e.childNodes.length).toBe(3);
           const child1 = e.childNodes[0];
           const textNode = e.childNodes[1];
-          const child2 = e.childNodes[render === streamRender ? 3 : 2];
+          const child2 = e.childNodes[2];
           expect(child1.id).toBe('child1');
           expect(child1.childNodes.length).toBe(0);
           expectTextNode(textNode, ' ');
@@ -757,10 +752,10 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           // prettier-ignore
           const e = await render(<div id="parent">  <div id="child" />   </div>); // eslint-disable-line no-multi-spaces
-          expect(e.childNodes.length).toBe(render === streamRender ? 5 : 3);
+          expect(e.childNodes.length).toBe(3);
           const textNode1 = e.childNodes[0];
-          const child = e.childNodes[render === streamRender ? 2 : 1];
-          const textNode2 = e.childNodes[render === streamRender ? 3 : 2];
+          const child = e.childNodes[1];
+          const textNode2 = e.childNodes[2];
           expect(e.id).toBe('parent');
           expectTextNode(textNode1, '  ');
           expect(child.id).toBe('child');
@@ -783,9 +778,7 @@ describe('ReactDOMServerIntegration', () => {
         ) {
           // For plain server markup result we have comments between.
           // If we're able to hydrate, they remain.
-          expect(parent.childNodes.length).toBe(
-            render === streamRender ? 6 : 5,
-          );
+          expect(parent.childNodes.length).toBe(5);
           expectTextNode(parent.childNodes[0], 'a');
           expectTextNode(parent.childNodes[2], 'b');
           expectTextNode(parent.childNodes[4], 'c');
@@ -817,7 +810,7 @@ describe('ReactDOMServerIntegration', () => {
           render === clientRenderOnServerString ||
           render === streamRender
         ) {
-          expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
+          expect(e.childNodes.length).toBe(3);
           expectTextNode(e.childNodes[0], '<span>Text1&quot;</span>');
           expectTextNode(e.childNodes[2], '<span>Text2&quot;</span>');
         } else {
@@ -868,7 +861,7 @@ describe('ReactDOMServerIntegration', () => {
           );
           if (render === serverRender || render === streamRender) {
             // We have three nodes because there is a comment between them.
-            expect(e.childNodes.length).toBe(render === streamRender ? 4 : 3);
+            expect(e.childNodes.length).toBe(3);
             // Everything becomes LF when parsed from server HTML.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar');

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 0dcfbbd78c..437b719cc1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 437b719cc1..3ac05bbdbb 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -48,7 +48,7 @@ describe('ReactDOMServerIntegration', () => {
     resetModules();
   });
 
-  describe('elements and children', function() {
+  describe('elements and children', function () {
     function expectNode(node, type, value) {
       expect(node).not.toBe(null);
       expect(node.nodeType).toBe(type);
@@ -59,7 +59,7 @@ describe('ReactDOMServerIntegration', () => {
       expectNode(node, TEXT_NODE_TYPE, text);
     }
 
-    describe('text children', function() {
+    describe('text children', function () {
       itRenders('a div with text', async render => {
         const e = await render(<div>Text</div>);
         expect(e.tagName).toBe('DIV');
@@ -265,7 +265,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('number children', function() {
+    describe('number children', function () {
       itRenders('a number as single child', async render => {
         const e = await render(<div>{3}</div>);
         expect(e.textContent).toBe('3');
@@ -302,7 +302,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('null, false, and undefined children', function() {
+    describe('null, false, and undefined children', function () {
       itRenders('null single child as blank', async render => {
         const e = await render(<div>{null}</div>);
         expect(e.childNodes.length).toBe(0);
@@ -365,7 +365,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('elements with implicit namespaces', function() {
+    describe('elements with implicit namespaces', function () {
       itRenders('an svg element', async render => {
         const e = await render(<svg />);
         expect(e.childNodes.length).toBe(0);
@@ -580,7 +580,7 @@ describe('ReactDOMServerIntegration', () => {
       }
     });
 
-    describe('newline-eating elements', function() {
+    describe('newline-eating elements', function () {
       itRenders(
         'a newline-eating tag with content not starting with \\n',
         async render => {
@@ -601,7 +601,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('different component implementations', function() {
+    describe('different component implementations', function () {
       function checkFooDiv(e) {
         expect(e.childNodes.length).toBe(1);
         expectNode(e.firstChild, TEXT_NODE_TYPE, 'foo');
@@ -627,7 +627,7 @@ describe('ReactDOMServerIntegration', () => {
           async render => {
             const FactoryComponent = () => {
               return {
-                render: function() {
+                render: function () {
                   return <div>foo</div>;
                 },
               };
@@ -640,7 +640,7 @@ describe('ReactDOMServerIntegration', () => {
         itRenders('factory components', async render => {
           const FactoryComponent = () => {
             return {
-              render: function() {
+              render: function () {
                 return <div>foo</div>;
               },
             };
@@ -650,7 +650,7 @@ describe('ReactDOMServerIntegration', () => {
       }
     });
 
-    describe('component hierarchies', function() {
+    describe('component hierarchies', function () {
       itRenders('single child hierarchies of components', async render => {
         const Component = props => <div>{props.children}</div>;
         let e = await render(
@@ -791,7 +791,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('escaping >, <, and &', function() {
+    describe('escaping >, <, and &', function () {
       itRenders('>,<, and & as single child', async render => {
         const e = await render(<div>{'<span>Text&quot;</span>'}</div>);
         expect(e.childNodes.length).toBe(1);
@@ -902,7 +902,7 @@ describe('ReactDOMServerIntegration', () => {
       );
     });
 
-    describe('components that render nullish', function() {
+    describe('components that render nullish', function () {
       itRenders('a function returning null', async render => {
         const NullComponent = () => null;
         await render(<NullComponent />);
@@ -932,7 +932,7 @@ describe('ReactDOMServerIntegration', () => {
       });
     });
 
-    describe('components that throw errors', function() {
+    describe('components that throw errors', function () {
       itThrowsWhenRendering(
         'a function returning an object',
         async render => {
@@ -976,7 +976,7 @@ describe('ReactDOMServerIntegration', () => {
       );
     });
 
-    describe('badly-typed elements', function() {
+    describe('badly-typed elements', function () {
       itThrowsWhenRendering(
         'object',
         async render => {

commit 59409349671d7c096975025ff21996c525e4ae2b
Author: Ming Ye <ymqyit@gmail.com>
Date:   Fri Feb 10 00:07:49 2023 +0800

    Update to Jest 29 (#26088)
    
    ## Summary
    
    - yarn.lock diff +-6249, **small pr**
    - use jest-environment-jsdom by default
    - uncaught error from jsdom is an error object instead of strings
    - abortSignal.reason is read-only in jsdom and node,
    https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason
    
    ## How did you test this change?
    
    ci green
    
    ---------
    
    Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 3ac05bbdbb..c482010d39 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -5,6 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @emails react-core
+ * @jest-environment ./scripts/jest/ReactDOMServerIntegrationEnvironment
  */
 
 'use strict';
@@ -19,7 +20,7 @@ let ReactDOMServer;
 let ReactTestUtils;
 
 function initModules() {
-  jest.resetModuleRegistry();
+  jest.resetModules();
   React = require('react');
   ReactDOM = require('react-dom');
   ReactDOMServer = require('react-dom/server');

commit c0d927713002fe27c4d58717d35cd930e6814c2b
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Feb 1 18:32:18 2024 -0500

    Add ReactDOMClient to ServerIntegrationElements (#28134)
    
    ## Overview
    
    Branched off https://github.com/facebook/react/pull/28130
    
    ## ~Failing~ Fixed by @eps1lon
    
    The tests are currently failing because of two tests covering special
    characters. I've tried a few ways to fix, but I'm stuck and will need
    some help understanding why they fail and how to fix.
    
    ---------
    
    Co-authored-by: Sebastian Silbermann <sebastian.silbermann@klarna.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index c482010d39..3bbdd37981 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -16,19 +16,23 @@ const TEXT_NODE_TYPE = 3;
 
 let React;
 let ReactDOM;
+let ReactDOMClient;
 let ReactDOMServer;
+let ReactFeatureFlags;
 let ReactTestUtils;
 
 function initModules() {
   jest.resetModules();
   React = require('react');
   ReactDOM = require('react-dom');
+  ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
+  ReactFeatureFlags = require('shared/ReactFeatureFlags');
   ReactTestUtils = require('react-dom/test-utils');
 
   // Make them available to the helpers.
   return {
-    ReactDOM,
+    ReactDOMClient,
     ReactDOMServer,
     ReactTestUtils,
   };
@@ -136,7 +140,13 @@ describe('ReactDOMServerIntegration', () => {
         // DOM nodes on the client side. We force it to fire early
         // so that it gets deduplicated later, and doesn't fail the test.
         expect(() => {
-          ReactDOM.render(<nonstandard />, document.createElement('div'));
+          ReactDOM.flushSync(() => {
+            const root = ReactDOMClient.createRoot(
+              document.createElement('div'),
+            );
+
+            root.render(<nonstandard />);
+          });
         }).toErrorDev('The tag <nonstandard> is unrecognized in this browser.');
 
         const e = await render(<nonstandard>Text</nonstandard>);
@@ -833,15 +843,21 @@ describe('ReactDOMServerIntegration', () => {
         'an element with one text child with special characters',
         async render => {
           const e = await render(<div>{'foo\rbar\r\nbaz\nqux\u0000'}</div>);
-          if (render === serverRender || render === streamRender) {
+          if (
+            render === serverRender ||
+            render === streamRender ||
+            (render === clientRenderOnServerString &&
+              ReactFeatureFlags.enableClientRenderFallbackOnTextMismatch)
+          ) {
             expect(e.childNodes.length).toBe(1);
-            // Everything becomes LF when parsed from server HTML.
+            // Everything becomes LF when parsed from server HTML or hydrated if enableClientRenderFallbackOnTextMismatch is on.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar\nbaz\nqux');
           } else {
             expect(e.childNodes.length).toBe(1);
-            // Client rendering (or hydration) uses JS value with CR.
+            // Client rendering (or hydration without enableClientRenderFallbackOnTextMismatch) uses JS value with CR.
             // Null character stays.
+
             expectNode(
               e.childNodes[0],
               TEXT_NODE_TYPE,
@@ -860,17 +876,23 @@ describe('ReactDOMServerIntegration', () => {
               {'\r\nbaz\nqux\u0000'}
             </div>,
           );
-          if (render === serverRender || render === streamRender) {
+          if (
+            render === serverRender ||
+            render === streamRender ||
+            (render === clientRenderOnServerString &&
+              ReactFeatureFlags.enableClientRenderFallbackOnTextMismatch)
+          ) {
             // We have three nodes because there is a comment between them.
             expect(e.childNodes.length).toBe(3);
-            // Everything becomes LF when parsed from server HTML.
+            // Everything becomes LF when parsed from server HTML or hydrated if enableClientRenderFallbackOnTextMismatch is on.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar');
             expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\nbaz\nqux');
           } else if (render === clientRenderOnServerString) {
             // We have three nodes because there is a comment between them.
             expect(e.childNodes.length).toBe(3);
-            // Hydration uses JS value with CR and null character.
+            // Hydration without enableClientRenderFallbackOnTextMismatch uses JS value with CR and null character.
+
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\rbar');
             expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\r\nbaz\nqux\u0000');
           } else {

commit 952aa74f8e45ed35ac6bf1de10ad5ed5410deac6
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 5 23:07:41 2024 -0500

    Upgrade tests to use react/jsx-runtime (#28252)
    
    Instead of createElement.
    
    We should have done this when we initially released jsx-runtime but
    better late than never. The general principle is that our tests should
    be written using the most up-to-date idioms that we recommend for users,
    except when explicitly testing an edge case or legacy behavior, like for
    backwards compatibility.
    
    Most of the diff is related to tweaking test output and isn't very
    interesting.
    
    I did have to workaround an issue related to component stacks. The
    component stack logic depends on shared state that lives in the React
    module. The problem is that most of our tests reset the React module
    state and re-require a fresh instance of React, React DOM, etc. However,
    the JSX runtime is not re-required because it's injected by the compiler
    as a static import. This means its copy of the shared state is no longer
    the same as the one used by React, causing any warning logged by the JSX
    runtime to not include a component stack. (This same issue also breaks
    string refs, but since we're removing those soon I'm not so concerned
    about that.) The solution I went with for now is to mock the JSX runtime
    with a proxy that re-requires the module on every function invocation. I
    don't love this but it will have to do for now. What we should really do
    is migrate our tests away from manually resetting the module state and
    use import syntax instead.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 3bbdd37981..ea30b45e3d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -1007,7 +1007,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             EmptyComponent = <EmptyComponent />;
           }).toErrorDev(
-            'Warning: React.createElement: type is invalid -- expected a string ' +
+            'Warning: React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: object. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +
@@ -1031,7 +1031,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             NullComponent = <NullComponent />;
           }).toErrorDev(
-            'Warning: React.createElement: type is invalid -- expected a string ' +
+            'Warning: React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: null.',
             {withoutStack: true},
@@ -1049,7 +1049,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             UndefinedComponent = <UndefinedComponent />;
           }).toErrorDev(
-            'Warning: React.createElement: type is invalid -- expected a string ' +
+            'Warning: React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: undefined. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index ea30b45e3d..2e1f419ca9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -22,7 +22,6 @@ let ReactFeatureFlags;
 let ReactTestUtils;
 
 function initModules() {
-  jest.resetModules();
   React = require('react');
   ReactDOM = require('react-dom');
   ReactDOMClient = require('react-dom/client');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 2e1f419ca9..ea30b45e3d 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -22,6 +22,7 @@ let ReactFeatureFlags;
 let ReactTestUtils;
 
 function initModules() {
+  jest.resetModules();
   React = require('react');
   ReactDOM = require('react-dom');
   ReactDOMClient = require('react-dom/client');

commit cefc1c66c179e5cca255f1ff53610a0ed9f8e710
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Feb 20 22:49:34 2024 +0100

    Remove unused ReactTestUtils from ReactDOMServerIntegration tests (#28379)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index ea30b45e3d..d7dc81d2d4 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -19,7 +19,6 @@ let ReactDOM;
 let ReactDOMClient;
 let ReactDOMServer;
 let ReactFeatureFlags;
-let ReactTestUtils;
 
 function initModules() {
   jest.resetModules();
@@ -28,13 +27,11 @@ function initModules() {
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
   ReactFeatureFlags = require('shared/ReactFeatureFlags');
-  ReactTestUtils = require('react-dom/test-utils');
 
   // Make them available to the helpers.
   return {
     ReactDOMClient,
     ReactDOMServer,
-    ReactTestUtils,
   };
 }
 

commit 84c84d72f11ff1961a103b3cd59919876e48f759
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Tue Mar 26 14:55:14 2024 -0700

    Remove enableClientRenderFallbackOnTextMismatch flag (#28458)
    
    Build on top of #28440.
    
    This lets us remove the path where updates are tracked on differences in
    text.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index d7dc81d2d4..a66cd12cd9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -18,7 +18,6 @@ let React;
 let ReactDOM;
 let ReactDOMClient;
 let ReactDOMServer;
-let ReactFeatureFlags;
 
 function initModules() {
   jest.resetModules();
@@ -26,7 +25,6 @@ function initModules() {
   ReactDOM = require('react-dom');
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
-  ReactFeatureFlags = require('shared/ReactFeatureFlags');
 
   // Make them available to the helpers.
   return {
@@ -843,16 +841,15 @@ describe('ReactDOMServerIntegration', () => {
           if (
             render === serverRender ||
             render === streamRender ||
-            (render === clientRenderOnServerString &&
-              ReactFeatureFlags.enableClientRenderFallbackOnTextMismatch)
+            render === clientRenderOnServerString
           ) {
             expect(e.childNodes.length).toBe(1);
-            // Everything becomes LF when parsed from server HTML or hydrated if enableClientRenderFallbackOnTextMismatch is on.
+            // Everything becomes LF when parsed from server HTML or hydrated.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar\nbaz\nqux');
           } else {
             expect(e.childNodes.length).toBe(1);
-            // Client rendering (or hydration without enableClientRenderFallbackOnTextMismatch) uses JS value with CR.
+            // Client rendering uses JS value with CR.
             // Null character stays.
 
             expectNode(
@@ -876,19 +873,18 @@ describe('ReactDOMServerIntegration', () => {
           if (
             render === serverRender ||
             render === streamRender ||
-            (render === clientRenderOnServerString &&
-              ReactFeatureFlags.enableClientRenderFallbackOnTextMismatch)
+            render === clientRenderOnServerString
           ) {
             // We have three nodes because there is a comment between them.
             expect(e.childNodes.length).toBe(3);
-            // Everything becomes LF when parsed from server HTML or hydrated if enableClientRenderFallbackOnTextMismatch is on.
+            // Everything becomes LF when parsed from server HTML or hydrated.
             // Null character is ignored.
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\nbar');
             expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\nbaz\nqux');
           } else if (render === clientRenderOnServerString) {
             // We have three nodes because there is a comment between them.
             expect(e.childNodes.length).toBe(3);
-            // Hydration without enableClientRenderFallbackOnTextMismatch uses JS value with CR and null character.
+            // Hydration uses JS value with CR and null character.
 
             expectNode(e.childNodes[0], TEXT_NODE_TYPE, 'foo\rbar');
             expectNode(e.childNodes[2], TEXT_NODE_TYPE, '\r\nbaz\nqux\u0000');

commit cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc
Author: Josh Story <story@hey.com>
Date:   Thu Mar 28 13:08:08 2024 -0700

    Remove module pattern function component support (#27742)
    
    The module pattern
    
    ```
    function MyComponent() {
      return {
        render() {
          return this.state.foo
        }
      }
    }
    ```
    
    has been deprecated for approximately 5 years now. This PR removes
    support for this pattern. It also simplifies a number of code paths in
    particular related to the concept of `IndeterminateComponent` types.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index a66cd12cd9..f492aebb45 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -627,23 +627,9 @@ describe('ReactDOMServerIntegration', () => {
         checkFooDiv(await render(<ClassComponent />));
       });
 
-      if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
-        itThrowsWhenRendering(
-          'factory components',
-          async render => {
-            const FactoryComponent = () => {
-              return {
-                render: function () {
-                  return <div>foo</div>;
-                },
-              };
-            };
-            await render(<FactoryComponent />, 1);
-          },
-          'Objects are not valid as a React child (found: object with keys {render})',
-        );
-      } else {
-        itRenders('factory components', async render => {
+      itThrowsWhenRendering(
+        'factory components',
+        async render => {
           const FactoryComponent = () => {
             return {
               render: function () {
@@ -651,9 +637,10 @@ describe('ReactDOMServerIntegration', () => {
               },
             };
           };
-          checkFooDiv(await render(<FactoryComponent />, 1));
-        });
-      }
+          await render(<FactoryComponent />, 1);
+        },
+        'Objects are not valid as a React child (found: object with keys {render})',
+      );
     });
 
     describe('component hierarchies', function () {

commit f2690747239533fa266612d2d4dd9ae88ea92fbc
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Mar 29 10:10:11 2024 -0400

    Revert "Remove module pattern function component support" (#28670)
    
    This breaks internal tests, so must be something in the refactor. Since
    it's the top commit let's revert and split into two PRs, one that
    removes the flag and one that does the refactor, so we can find the bug.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index f492aebb45..a66cd12cd9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -627,9 +627,23 @@ describe('ReactDOMServerIntegration', () => {
         checkFooDiv(await render(<ClassComponent />));
       });
 
-      itThrowsWhenRendering(
-        'factory components',
-        async render => {
+      if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
+        itThrowsWhenRendering(
+          'factory components',
+          async render => {
+            const FactoryComponent = () => {
+              return {
+                render: function () {
+                  return <div>foo</div>;
+                },
+              };
+            };
+            await render(<FactoryComponent />, 1);
+          },
+          'Objects are not valid as a React child (found: object with keys {render})',
+        );
+      } else {
+        itRenders('factory components', async render => {
           const FactoryComponent = () => {
             return {
               render: function () {
@@ -637,10 +651,9 @@ describe('ReactDOMServerIntegration', () => {
               },
             };
           };
-          await render(<FactoryComponent />, 1);
-        },
-        'Objects are not valid as a React child (found: object with keys {render})',
-      );
+          checkFooDiv(await render(<FactoryComponent />, 1));
+        });
+      }
     });
 
     describe('component hierarchies', function () {

commit a73c3450e1b528fa6cb3e94fa4d4359c7a4b61f1
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Mar 29 11:16:17 2024 -0400

    Remove module pattern function component support (flag only) (#28671)
    
    Remove module pattern function component support (flag only)
    
    > This is a redo of #27742, but only including the flag removal,
    excluding further simplifications.
    
    The module pattern
    
    ```
    function MyComponent() {
      return {
        render() {
          return this.state.foo
        }
      }
    }
    ```
    
    has been deprecated for approximately 5 years now. This PR removes
    support for this pattern.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index a66cd12cd9..f492aebb45 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -627,23 +627,9 @@ describe('ReactDOMServerIntegration', () => {
         checkFooDiv(await render(<ClassComponent />));
       });
 
-      if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
-        itThrowsWhenRendering(
-          'factory components',
-          async render => {
-            const FactoryComponent = () => {
-              return {
-                render: function () {
-                  return <div>foo</div>;
-                },
-              };
-            };
-            await render(<FactoryComponent />, 1);
-          },
-          'Objects are not valid as a React child (found: object with keys {render})',
-        );
-      } else {
-        itRenders('factory components', async render => {
+      itThrowsWhenRendering(
+        'factory components',
+        async render => {
           const FactoryComponent = () => {
             return {
               render: function () {
@@ -651,9 +637,10 @@ describe('ReactDOMServerIntegration', () => {
               },
             };
           };
-          checkFooDiv(await render(<FactoryComponent />, 1));
-        });
-      }
+          await render(<FactoryComponent />, 1);
+        },
+        'Objects are not valid as a React child (found: object with keys {render})',
+      );
     });
 
     describe('component hierarchies', function () {

commit 277420803947724b43c47bbc47d3a353553868f1
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Mon Jun 10 18:41:56 2024 -0400

    Remove Warning: prefix and toString on console Arguments (#29839)
    
    Basically make `console.error` and `console.warn` behave like normal -
    when a component stack isn't appended. I need this because I need to be
    able to print rich logs with the component stack option and to be able
    to disable instrumentation completely in `console.createTask`
    environments that don't need it.
    
    Currently we can't print logs with richer objects because they're
    toString:ed first. In practice, pretty much all arguments we log are
    already toString:ed so it's not necessary anyway. Some might be like a
    number. So it would only be a problem if some environment can't handle
    proper consoles but then it's up to that environment to toString it
    before logging.
    
    The `Warning: ` prefix is historic and is both noisy and confusing. It's
    mostly unnecessary since the UI surrounding `console.error` and
    `console.warn` tend to have visual treatment around it anyway. However,
    it's actively misleading when `console.error` gets prefixed with a
    Warning that we consider an error level. There's an argument to be made
    that some of our `console.error` don't make the bar for an error but
    then the argument is to downgrade each of those to `console.warn` - not
    to brand all our actual error logging with `Warning: `.
    
    Apparently something needs to change in React Native before landing this
    because it depends on the prefix somehow which probably doesn't make
    sense already.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index f492aebb45..258f9591f2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -987,7 +987,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             EmptyComponent = <EmptyComponent />;
           }).toErrorDev(
-            'Warning: React.jsx: type is invalid -- expected a string ' +
+            'React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: object. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +
@@ -1011,7 +1011,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             NullComponent = <NullComponent />;
           }).toErrorDev(
-            'Warning: React.jsx: type is invalid -- expected a string ' +
+            'React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: null.',
             {withoutStack: true},
@@ -1029,7 +1029,7 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             UndefinedComponent = <UndefinedComponent />;
           }).toErrorDev(
-            'Warning: React.jsx: type is invalid -- expected a string ' +
+            'React.jsx: type is invalid -- expected a string ' +
               '(for built-in components) or a class/function (for composite ' +
               'components) but got: undefined. You likely forgot to export your ' +
               "component from the file it's defined in, or you might have mixed up " +

commit b565373afd0cc1988497e1107106e851e8cfb261
Author: Jan Kassens <jkassens@meta.com>
Date:   Fri Jun 21 12:24:32 2024 -0400

    lint: enable reportUnusedDisableDirectives and remove unused suppressions (#28721)
    
    This enables linting against unused suppressions and removes the ones
    that were unused.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 258f9591f2..2912a4f401 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -744,7 +744,7 @@ describe('ReactDOMServerIntegration', () => {
         'a div with a single child surrounded by whitespace',
         async render => {
           // prettier-ignore
-          const e = await render(<div id="parent">  <div id="child" />   </div>); // eslint-disable-line no-multi-spaces
+          const e = await render(<div id="parent">  <div id="child" />   </div>);
           expect(e.childNodes.length).toBe(3);
           const textNode1 = e.childNodes[0];
           const child = e.childNodes[1];

commit e02baf6c92833a0d45a77fb2e741676f393c24f7
Author: Sebastian Markbge <sebastian@calyptus.eu>
Date:   Thu Jun 27 18:10:09 2024 +0200

    Warn for invalid type in renderer with the correct RSC stack (#30102)
    
    This is all behind the `enableOwnerStacks` flag.
    
    This is a follow up to #29088. In that I moved type validation into the
    renderer since that's the one that knows what types are allowed.
    However, I only removed it from `React.createElement` and not the JSX
    which was an oversight.
    
    However, I also noticed that for invalid types we don't have the right
    stack trace for throws because we're not yet inside the JSX element that
    itself is invalid. We should use its stack for the stack trace. That's
    the reason it's enough to just use the throw now because we can get a
    good stack trace from the owner stack. This is fixed by creating a fake
    Throw Fiber that gets assigned the right stack.
    
    Additionally, I noticed that for certain invalid types like the most
    common one `undefined` we error in Flight so a missing import in RSC
    leads to a generic error. Instead of erroring on the Flight side we
    should just let anything that's not a Server Component through to the
    client and then let the Client renderer determine whether it's a valid
    type or not. Since we now have owner stacks through the server too, this
    will still be able to provide a good stack trace on the client that
    points to the server in that case.
    
    <img width="571" alt="Screenshot 2024-06-25 at 6 46 35PM"
    src="https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4">
    
    To get the best stack you have to expand the little icon and the regular
    stack is noisy [due to this Chrome
    bug](https://issues.chromium.org/issues/345248263) which makes it a
    little harder to find but once that's fixed it might be easier.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 2912a4f401..0fcc314d39 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -987,11 +987,13 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             EmptyComponent = <EmptyComponent />;
           }).toErrorDev(
-            'React.jsx: type is invalid -- expected a string ' +
-              '(for built-in components) or a class/function (for composite ' +
-              'components) but got: object. You likely forgot to export your ' +
-              "component from the file it's defined in, or you might have mixed up " +
-              'default and named imports.',
+            gate(flags => flags.enableOwnerStacks)
+              ? []
+              : 'React.jsx: type is invalid -- expected a string ' +
+                  '(for built-in components) or a class/function (for composite ' +
+                  'components) but got: object. You likely forgot to export your ' +
+                  "component from the file it's defined in, or you might have mixed up " +
+                  'default and named imports.',
             {withoutStack: true},
           );
           await render(EmptyComponent);
@@ -1011,9 +1013,11 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             NullComponent = <NullComponent />;
           }).toErrorDev(
-            'React.jsx: type is invalid -- expected a string ' +
-              '(for built-in components) or a class/function (for composite ' +
-              'components) but got: null.',
+            gate(flags => flags.enableOwnerStacks)
+              ? []
+              : 'React.jsx: type is invalid -- expected a string ' +
+                  '(for built-in components) or a class/function (for composite ' +
+                  'components) but got: null.',
             {withoutStack: true},
           );
           await render(NullComponent);
@@ -1029,11 +1033,13 @@ describe('ReactDOMServerIntegration', () => {
           expect(() => {
             UndefinedComponent = <UndefinedComponent />;
           }).toErrorDev(
-            'React.jsx: type is invalid -- expected a string ' +
-              '(for built-in components) or a class/function (for composite ' +
-              'components) but got: undefined. You likely forgot to export your ' +
-              "component from the file it's defined in, or you might have mixed up " +
-              'default and named imports.',
+            gate(flags => flags.enableOwnerStacks)
+              ? []
+              : 'React.jsx: type is invalid -- expected a string ' +
+                  '(for built-in components) or a class/function (for composite ' +
+                  'components) but got: undefined. You likely forgot to export your ' +
+                  "component from the file it's defined in, or you might have mixed up " +
+                  'default and named imports.',
             {withoutStack: true},
           );
 

commit e0c893f51d6620ede7ad9a65102ac581da464680
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jan 6 14:13:03 2025 -0500

    [assert helpers] ServerIntegration tests (#31988)
    
    Based off: https://github.com/facebook/react/pull/31986

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 0fcc314d39..50d189cc08 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -18,6 +18,7 @@ let React;
 let ReactDOM;
 let ReactDOMClient;
 let ReactDOMServer;
+let assertConsoleErrorDev;
 
 function initModules() {
   jest.resetModules();
@@ -25,6 +26,7 @@ function initModules() {
   ReactDOM = require('react-dom');
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
+  assertConsoleErrorDev = require('internal-test-utils').assertConsoleErrorDev;
 
   // Make them available to the helpers.
   return {
@@ -48,6 +50,14 @@ describe('ReactDOMServerIntegration', () => {
     resetModules();
   });
 
+  afterEach(() => {
+    // TODO: This is a hack because expectErrors does not restore mock,
+    // however fixing it requires a major refactor to all these tests.
+    if (console.error.mockClear) {
+      console.error.mockRestore();
+    }
+  });
+
   describe('elements and children', function () {
     function expectNode(node, type, value) {
       expect(node).not.toBe(null);
@@ -134,15 +144,15 @@ describe('ReactDOMServerIntegration', () => {
         // However this particular warning fires only when creating
         // DOM nodes on the client side. We force it to fire early
         // so that it gets deduplicated later, and doesn't fail the test.
-        expect(() => {
-          ReactDOM.flushSync(() => {
-            const root = ReactDOMClient.createRoot(
-              document.createElement('div'),
-            );
-
-            root.render(<nonstandard />);
-          });
-        }).toErrorDev('The tag <nonstandard> is unrecognized in this browser.');
+        ReactDOM.flushSync(() => {
+          const root = ReactDOMClient.createRoot(document.createElement('div'));
+          root.render(<nonstandard />);
+        });
+        assertConsoleErrorDev([
+          'The tag <nonstandard> is unrecognized in this browser. ' +
+            'If you meant to render a React component, start its name with an uppercase letter.\n' +
+            '    in nonstandard (at **)',
+        ]);
 
         const e = await render(<nonstandard>Text</nonstandard>);
         expect(e.tagName).toBe('NONSTANDARD');
@@ -984,16 +994,17 @@ describe('ReactDOMServerIntegration', () => {
         'object',
         async render => {
           let EmptyComponent = {};
-          expect(() => {
-            EmptyComponent = <EmptyComponent />;
-          }).toErrorDev(
+          EmptyComponent = <EmptyComponent />;
+          assertConsoleErrorDev(
             gate(flags => flags.enableOwnerStacks)
               ? []
-              : 'React.jsx: type is invalid -- expected a string ' +
-                  '(for built-in components) or a class/function (for composite ' +
-                  'components) but got: object. You likely forgot to export your ' +
-                  "component from the file it's defined in, or you might have mixed up " +
-                  'default and named imports.',
+              : [
+                  'React.jsx: type is invalid -- expected a string ' +
+                    '(for built-in components) or a class/function (for composite ' +
+                    'components) but got: object. You likely forgot to export your ' +
+                    "component from the file it's defined in, or you might have mixed up " +
+                    'default and named imports.',
+                ],
             {withoutStack: true},
           );
           await render(EmptyComponent);
@@ -1010,14 +1021,15 @@ describe('ReactDOMServerIntegration', () => {
         'null',
         async render => {
           let NullComponent = null;
-          expect(() => {
-            NullComponent = <NullComponent />;
-          }).toErrorDev(
+          NullComponent = <NullComponent />;
+          assertConsoleErrorDev(
             gate(flags => flags.enableOwnerStacks)
               ? []
-              : 'React.jsx: type is invalid -- expected a string ' +
-                  '(for built-in components) or a class/function (for composite ' +
-                  'components) but got: null.',
+              : [
+                  'React.jsx: type is invalid -- expected a string ' +
+                    '(for built-in components) or a class/function (for composite ' +
+                    'components) but got: null.',
+                ],
             {withoutStack: true},
           );
           await render(NullComponent);
@@ -1030,16 +1042,17 @@ describe('ReactDOMServerIntegration', () => {
         'undefined',
         async render => {
           let UndefinedComponent = undefined;
-          expect(() => {
-            UndefinedComponent = <UndefinedComponent />;
-          }).toErrorDev(
+          UndefinedComponent = <UndefinedComponent />;
+          assertConsoleErrorDev(
             gate(flags => flags.enableOwnerStacks)
               ? []
-              : 'React.jsx: type is invalid -- expected a string ' +
-                  '(for built-in components) or a class/function (for composite ' +
-                  'components) but got: undefined. You likely forgot to export your ' +
-                  "component from the file it's defined in, or you might have mixed up " +
-                  'default and named imports.',
+              : [
+                  'React.jsx: type is invalid -- expected a string ' +
+                    '(for built-in components) or a class/function (for composite ' +
+                    'components) but got: undefined. You likely forgot to export your ' +
+                    "component from the file it's defined in, or you might have mixed up " +
+                    'default and named imports.',
+                ],
             {withoutStack: true},
           );
 

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
index 50d189cc08..04475485eb 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js
@@ -995,18 +995,6 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           let EmptyComponent = {};
           EmptyComponent = <EmptyComponent />;
-          assertConsoleErrorDev(
-            gate(flags => flags.enableOwnerStacks)
-              ? []
-              : [
-                  'React.jsx: type is invalid -- expected a string ' +
-                    '(for built-in components) or a class/function (for composite ' +
-                    'components) but got: object. You likely forgot to export your ' +
-                    "component from the file it's defined in, or you might have mixed up " +
-                    'default and named imports.',
-                ],
-            {withoutStack: true},
-          );
           await render(EmptyComponent);
         },
         'Element type is invalid: expected a string (for built-in components) or a class/function ' +
@@ -1022,16 +1010,6 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           let NullComponent = null;
           NullComponent = <NullComponent />;
-          assertConsoleErrorDev(
-            gate(flags => flags.enableOwnerStacks)
-              ? []
-              : [
-                  'React.jsx: type is invalid -- expected a string ' +
-                    '(for built-in components) or a class/function (for composite ' +
-                    'components) but got: null.',
-                ],
-            {withoutStack: true},
-          );
           await render(NullComponent);
         },
         'Element type is invalid: expected a string (for built-in components) or a class/function ' +
@@ -1043,19 +1021,6 @@ describe('ReactDOMServerIntegration', () => {
         async render => {
           let UndefinedComponent = undefined;
           UndefinedComponent = <UndefinedComponent />;
-          assertConsoleErrorDev(
-            gate(flags => flags.enableOwnerStacks)
-              ? []
-              : [
-                  'React.jsx: type is invalid -- expected a string ' +
-                    '(for built-in components) or a class/function (for composite ' +
-                    'components) but got: undefined. You likely forgot to export your ' +
-                    "component from the file it's defined in, or you might have mixed up " +
-                    'default and named imports.',
-                ],
-            {withoutStack: true},
-          );
-
           await render(UndefinedComponent);
         },
         'Element type is invalid: expected a string (for built-in components) or a class/function ' +

