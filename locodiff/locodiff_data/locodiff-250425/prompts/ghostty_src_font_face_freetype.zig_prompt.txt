# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/face/freetype.zig

commit 71ec50993096eda18001f802e84a2c28ddfa044d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:19:21 2022 -0700

    Make font face a compile time interface, stub for coretext

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
new file mode 100644
index 00000000..d0fa1f96
--- /dev/null
+++ b/src/font/face/freetype.zig
@@ -0,0 +1,457 @@
+//! Face represents a single font face. A single font face has a single set
+//! of properties associated with it such as style, weight, etc.
+//!
+//! A Face isn't typically meant to be used directly. It is usually used
+//! via a Family in order to store it in an Atlas.
+
+const std = @import("std");
+const builtin = @import("builtin");
+const freetype = @import("freetype");
+const harfbuzz = @import("harfbuzz");
+const assert = std.debug.assert;
+const testing = std.testing;
+const Allocator = std.mem.Allocator;
+const Atlas = @import("../../Atlas.zig");
+const font = @import("../main.zig");
+const Glyph = font.Glyph;
+const Library = font.Library;
+const Presentation = font.Presentation;
+
+const log = std.log.scoped(.font_face);
+
+pub const Face = struct {
+    /// Our font face.
+    face: freetype.Face,
+
+    /// Harfbuzz font corresponding to this face.
+    hb_font: harfbuzz.Font,
+
+    /// The presentation for this font. This is a heuristic since fonts don't have
+    /// a way to declare this. We just assume a font with color is an emoji font.
+    presentation: Presentation,
+
+    /// Metrics for this font face. These are useful for renderers.
+    metrics: Metrics,
+
+    /// Initialize a new font face with the given source in-memory.
+    pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
+        const face = try lib.lib.initFace(path, index);
+        errdefer face.deinit();
+        try face.selectCharmap(.unicode);
+        try setSize_(face, size);
+
+        const hb_font = try harfbuzz.freetype.createFont(face.handle);
+        errdefer hb_font.destroy();
+
+        return Face{
+            .face = face,
+            .hb_font = hb_font,
+            .presentation = if (face.hasColor()) .emoji else .text,
+            .metrics = calcMetrics(face),
+        };
+    }
+
+    /// Initialize a new font face with the given source in-memory.
+    pub fn init(lib: Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
+        const face = try lib.lib.initMemoryFace(source, 0);
+        errdefer face.deinit();
+        try face.selectCharmap(.unicode);
+        try setSize_(face, size);
+
+        const hb_font = try harfbuzz.freetype.createFont(face.handle);
+        errdefer hb_font.destroy();
+
+        return Face{
+            .face = face,
+            .hb_font = hb_font,
+            .presentation = if (face.hasColor()) .emoji else .text,
+            .metrics = calcMetrics(face),
+        };
+    }
+
+    pub fn deinit(self: *Face) void {
+        self.face.deinit();
+        self.hb_font.destroy();
+        self.* = undefined;
+    }
+
+    fn setSize_(face: freetype.Face, size: font.face.DesiredSize) !void {
+        // If we have fixed sizes, we just have to try to pick the one closest
+        // to what the user requested. Otherwise, we can choose an arbitrary
+        // pixel size.
+        if (!face.hasFixedSizes()) {
+            const size_26dot6 = @intCast(i32, size.points << 6); // mult by 64
+            try face.setCharSize(0, size_26dot6, size.xdpi, size.ydpi);
+        } else try selectSizeNearest(face, size.pixels());
+    }
+
+    /// Selects the fixed size in the loaded face that is closest to the
+    /// requested pixel size.
+    fn selectSizeNearest(face: freetype.Face, size: u32) !void {
+        var i: i32 = 0;
+        var best_i: i32 = 0;
+        var best_diff: i32 = 0;
+        while (i < face.handle.*.num_fixed_sizes) : (i += 1) {
+            const width = face.handle.*.available_sizes[@intCast(usize, i)].width;
+            const diff = @intCast(i32, size) - @intCast(i32, width);
+            if (i == 0 or diff < best_diff) {
+                best_diff = diff;
+                best_i = i;
+            }
+        }
+
+        try face.selectSize(best_i);
+    }
+
+    /// Returns the glyph index for the given Unicode code point. If this
+    /// face doesn't support this glyph, null is returned.
+    pub fn glyphIndex(self: Face, cp: u32) ?u32 {
+        return self.face.getCharIndex(cp);
+    }
+
+    /// Returns true if this font is colored. This can be used by callers to
+    /// determine what kind of atlas to pass in.
+    pub fn hasColor(self: Face) bool {
+        return self.face.hasColor();
+    }
+
+    /// Render a glyph using the glyph index. The rendered glyph is stored in the
+    /// given texture atlas.
+    pub fn renderGlyph(self: Face, alloc: Allocator, atlas: *Atlas, glyph_index: u32) !Glyph {
+        // If our glyph has color, we want to render the color
+        try self.face.loadGlyph(glyph_index, .{
+            .render = true,
+            .color = self.face.hasColor(),
+        });
+
+        const glyph = self.face.handle.*.glyph;
+        const bitmap_ft = glyph.*.bitmap;
+
+        // This bitmap is blank. I've seen it happen in a font, I don't know why.
+        // If it is empty, we just return a valid glyph struct that does nothing.
+        if (bitmap_ft.rows == 0) return Glyph{
+            .width = 0,
+            .height = 0,
+            .offset_x = 0,
+            .offset_y = 0,
+            .atlas_x = 0,
+            .atlas_y = 0,
+            .advance_x = 0,
+        };
+
+        // Ensure we know how to work with the font format. And assure that
+        // or color depth is as expected on the texture atlas. If format is null
+        // it means there is no native color format for our Atlas and we must try
+        // conversion.
+        const format: Atlas.Format = switch (bitmap_ft.pixel_mode) {
+            freetype.c.FT_PIXEL_MODE_GRAY => .greyscale,
+            freetype.c.FT_PIXEL_MODE_BGRA => .rgba,
+            else => {
+                log.warn("glyph={} pixel mode={}", .{ glyph_index, bitmap_ft.pixel_mode });
+                @panic("unsupported pixel mode");
+            },
+        };
+        assert(atlas.format == format);
+
+        const bitmap = bitmap_ft;
+        const tgt_w = bitmap.width;
+        const tgt_h = bitmap.rows;
+
+        const region = try atlas.reserve(alloc, tgt_w, tgt_h);
+
+        // If we have data, copy it into the atlas
+        if (region.width > 0 and region.height > 0) {
+            const depth = atlas.format.depth();
+
+            // We can avoid a buffer copy if our atlas width and bitmap
+            // width match and the bitmap pitch is just the width (meaning
+            // the data is tightly packed).
+            const needs_copy = !(tgt_w == bitmap.width and (bitmap.width * depth) == bitmap.pitch);
+
+            // If we need to copy the data, we copy it into a temporary buffer.
+            const buffer = if (needs_copy) buffer: {
+                var temp = try alloc.alloc(u8, tgt_w * tgt_h * depth);
+                var dst_ptr = temp;
+                var src_ptr = bitmap.buffer;
+                var i: usize = 0;
+                while (i < bitmap.rows) : (i += 1) {
+                    std.mem.copy(u8, dst_ptr, src_ptr[0 .. bitmap.width * depth]);
+                    dst_ptr = dst_ptr[tgt_w * depth ..];
+                    src_ptr += @intCast(usize, bitmap.pitch);
+                }
+                break :buffer temp;
+            } else bitmap.buffer[0..(tgt_w * tgt_h * depth)];
+            defer if (buffer.ptr != bitmap.buffer) alloc.free(buffer);
+
+            // Write the glyph information into the atlas
+            assert(region.width == tgt_w);
+            assert(region.height == tgt_h);
+            atlas.set(region, buffer);
+        }
+
+        const offset_y = offset_y: {
+            // For non-scalable colorized fonts, we assume they are pictographic
+            // and just center the glyph. So far this has only applied to emoji
+            // fonts. Emoji fonts don't always report a correct ascender/descender
+            // (mainly Apple Emoji) so we just center them. Also, since emoji font
+            // aren't scalable, cell_baseline is incorrect anyways.
+            //
+            // NOTE(mitchellh): I don't know if this is right, this doesn't
+            // _feel_ right, but it makes all my limited test cases work.
+            if (self.face.hasColor() and !self.face.isScalable()) {
+                break :offset_y @intCast(c_int, tgt_h);
+            }
+
+            // The Y offset is the offset of the top of our bitmap PLUS our
+            // baseline calculation. The baseline calculation is so that everything
+            // is properly centered when we render it out into a monospace grid.
+            // Note: we add here because our X/Y is actually reversed, adding goes UP.
+            break :offset_y glyph.*.bitmap_top + @floatToInt(c_int, self.metrics.cell_baseline);
+        };
+
+        // Store glyph metadata
+        return Glyph{
+            .width = tgt_w,
+            .height = tgt_h,
+            .offset_x = glyph.*.bitmap_left,
+            .offset_y = offset_y,
+            .atlas_x = region.x,
+            .atlas_y = region.y,
+            .advance_x = f26dot6ToFloat(glyph.*.advance.x),
+        };
+    }
+
+    /// Convert 16.6 pixel format to pixels based on the scale factor of the
+    /// current font size.
+    fn unitsToPxY(self: Face, units: i32) i32 {
+        return @intCast(i32, freetype.mulFix(
+            units,
+            @intCast(i32, self.face.handle.*.size.*.metrics.y_scale),
+        ) >> 6);
+    }
+
+    /// Convert 26.6 pixel format to f32
+    fn f26dot6ToFloat(v: freetype.c.FT_F26Dot6) f32 {
+        return @intToFloat(f32, v >> 6);
+    }
+
+    /// Metrics associated with the font that are useful for renderers to know.
+    pub const Metrics = struct {
+        /// Recommended cell width and height for a monospace grid using this font.
+        cell_width: f32,
+        cell_height: f32,
+
+        /// For monospace grids, the recommended y-value from the bottom to set
+        /// the baseline for font rendering. This is chosen so that things such
+        /// as the bottom of a "g" or "y" do not drop below the cell.
+        cell_baseline: f32,
+
+        /// The position of the underline from the top of the cell and the
+        /// thickness in pixels.
+        underline_position: f32,
+        underline_thickness: f32,
+
+        /// The position and thickness of a strikethrough. Same units/style
+        /// as the underline fields.
+        strikethrough_position: f32,
+        strikethrough_thickness: f32,
+    };
+
+    /// Calculate the metrics associated with a face. This is not public because
+    /// the metrics are calculated for every face and cached since they're
+    /// frequently required for renderers and take up next to little memory space
+    /// in the grand scheme of things.
+    ///
+    /// An aside: the proper way to limit memory usage due to faces is to limit
+    /// the faces with DeferredFaces and reload on demand. A Face can't be converted
+    /// into a DeferredFace but a Face that comes from a DeferredFace can be
+    /// deinitialized anytime and reloaded with the deferred face.
+    fn calcMetrics(face: freetype.Face) Metrics {
+        const size_metrics = face.handle.*.size.*.metrics;
+
+        // Cell width is calculated by preferring to use 'M' as the width of a
+        // cell since 'M' is generally the widest ASCII character. If loading 'M'
+        // fails then we use the max advance of the font face size metrics.
+        const cell_width: f32 = cell_width: {
+            if (face.getCharIndex('M')) |glyph_index| {
+                if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                    break :cell_width f26dot6ToFloat(face.handle.*.glyph.*.advance.x);
+                } else |_| {
+                    // Ignore the error since we just fall back to max_advance below
+                }
+            }
+
+            break :cell_width f26dot6ToFloat(size_metrics.max_advance);
+        };
+
+        // Cell height is calculated as the maximum of multiple things in order
+        // to handle edge cases in fonts: (1) the height as reported in metadata
+        // by the font designer (2) the maximum glyph height as measured in the
+        // font and (3) the height from the ascender to an underscore.
+        const cell_height: f32 = cell_height: {
+            // The height as reported by the font designer.
+            const face_height = f26dot6ToFloat(size_metrics.height);
+
+            // The maximum height a glyph can take in the font
+            const max_glyph_height = f26dot6ToFloat(size_metrics.ascender) -
+                f26dot6ToFloat(size_metrics.descender);
+
+            // The height of the underscore character
+            const underscore_height = underscore: {
+                if (face.getCharIndex('_')) |glyph_index| {
+                    if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                        var res: f32 = f26dot6ToFloat(size_metrics.ascender);
+                        res -= @intToFloat(f32, face.handle.*.glyph.*.bitmap_top);
+                        res += @intToFloat(f32, face.handle.*.glyph.*.bitmap.rows);
+                        break :underscore res;
+                    } else |_| {
+                        // Ignore the error since we just fall back below
+                    }
+                }
+
+                break :underscore 0;
+            };
+
+            break :cell_height @maximum(
+                face_height,
+                @maximum(max_glyph_height, underscore_height),
+            );
+        };
+
+        // The baseline is the descender amount for the font. This is the maximum
+        // that a font may go down. We switch signs because our coordinate system
+        // is reversed.
+        const cell_baseline = -1 * f26dot6ToFloat(size_metrics.descender);
+
+        // The underline position. This is a value from the top where the
+        // underline should go.
+        const underline_position = underline_pos: {
+            // The ascender is already scaled for scalable fonts, but the
+            // underline position is not.
+            const ascender_px = @intCast(i32, size_metrics.ascender) >> 6;
+            const declared_px = freetype.mulFix(
+                face.handle.*.underline_position,
+                @intCast(i32, face.handle.*.size.*.metrics.y_scale),
+            ) >> 6;
+
+            // We use the declared underline position if its available
+            const declared = ascender_px - declared_px;
+            if (declared > 0)
+                break :underline_pos @intToFloat(f32, declared);
+
+            // If we have no declared underline position, we go slightly under the
+            // cell height (mainly: non-scalable fonts, i.e. emoji)
+            break :underline_pos cell_height - 1;
+        };
+        const underline_thickness = @maximum(1, fontUnitsToPxY(
+            face,
+            face.handle.*.underline_thickness,
+        ));
+
+        // The strikethrough position. We use the position provided by the
+        // font if it exists otherwise we calculate a best guess.
+        const strikethrough: struct {
+            pos: f32,
+            thickness: f32,
+        } = if (face.getSfntTable(.os2)) |os2| .{
+            .pos = pos: {
+                // Ascender is scaled, strikeout pos is not
+                const ascender_px = @intCast(i32, size_metrics.ascender) >> 6;
+                const declared_px = freetype.mulFix(
+                    os2.yStrikeoutPosition,
+                    @intCast(i32, face.handle.*.size.*.metrics.y_scale),
+                ) >> 6;
+
+                break :pos @intToFloat(f32, ascender_px - declared_px);
+            },
+            .thickness = @maximum(1, fontUnitsToPxY(face, os2.yStrikeoutSize)),
+        } else .{
+            .pos = cell_baseline * 0.6,
+            .thickness = underline_thickness,
+        };
+
+        // log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
+        //     size_metrics,
+        //     cell_width,
+        //     cell_height,
+        //     cell_height - cell_baseline,
+        //     underline_position,
+        //     underline_thickness,
+        //     strikethrough,
+        // });
+
+        return .{
+            .cell_width = cell_width,
+            .cell_height = cell_height,
+            .cell_baseline = cell_baseline,
+            .underline_position = underline_position,
+            .underline_thickness = underline_thickness,
+            .strikethrough_position = strikethrough.pos,
+            .strikethrough_thickness = strikethrough.thickness,
+        };
+    }
+
+    /// Convert freetype "font units" to pixels using the Y scale.
+    fn fontUnitsToPxY(face: freetype.Face, x: i32) f32 {
+        const mul = freetype.mulFix(x, @intCast(i32, face.handle.*.size.*.metrics.y_scale));
+        const div = @intToFloat(f32, mul) / 64;
+        return @ceil(div);
+    }
+};
+
+test {
+    const testFont = @import("../test.zig").fontRegular;
+    const alloc = testing.allocator;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
+
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    defer ft_font.deinit();
+
+    try testing.expectEqual(Presentation.text, ft_font.presentation);
+
+    // Generate all visible ASCII
+    var i: u8 = 32;
+    while (i < 127) : (i += 1) {
+        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+    }
+}
+
+test "color emoji" {
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontEmoji;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var atlas = try Atlas.init(alloc, 512, .rgba);
+    defer atlas.deinit(alloc);
+
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    defer ft_font.deinit();
+
+    try testing.expectEqual(Presentation.emoji, ft_font.presentation);
+
+    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?);
+}
+
+test "mono to rgba" {
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontEmoji;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var atlas = try Atlas.init(alloc, 512, .rgba);
+    defer atlas.deinit(alloc);
+
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    defer ft_font.deinit();
+
+    // glyph 3 is mono in Noto
+    _ = try ft_font.renderGlyph(alloc, &atlas, 3);
+}

commit f393049988be016dd46525492e1d51673954a99a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 11:25:54 2022 -0700

    fix compilation

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d0fa1f96..9542414d 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -31,7 +31,7 @@ pub const Face = struct {
     presentation: Presentation,
 
     /// Metrics for this font face. These are useful for renderers.
-    metrics: Metrics,
+    metrics: font.face.Metrics,
 
     /// Initialize a new font face with the given source in-memory.
     pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
@@ -235,28 +235,6 @@ pub const Face = struct {
         return @intToFloat(f32, v >> 6);
     }
 
-    /// Metrics associated with the font that are useful for renderers to know.
-    pub const Metrics = struct {
-        /// Recommended cell width and height for a monospace grid using this font.
-        cell_width: f32,
-        cell_height: f32,
-
-        /// For monospace grids, the recommended y-value from the bottom to set
-        /// the baseline for font rendering. This is chosen so that things such
-        /// as the bottom of a "g" or "y" do not drop below the cell.
-        cell_baseline: f32,
-
-        /// The position of the underline from the top of the cell and the
-        /// thickness in pixels.
-        underline_position: f32,
-        underline_thickness: f32,
-
-        /// The position and thickness of a strikethrough. Same units/style
-        /// as the underline fields.
-        strikethrough_position: f32,
-        strikethrough_thickness: f32,
-    };
-
     /// Calculate the metrics associated with a face. This is not public because
     /// the metrics are calculated for every face and cached since they're
     /// frequently required for renderers and take up next to little memory space
@@ -266,7 +244,7 @@ pub const Face = struct {
     /// the faces with DeferredFaces and reload on demand. A Face can't be converted
     /// into a DeferredFace but a Face that comes from a DeferredFace can be
     /// deinitialized anytime and reloaded with the deferred face.
-    fn calcMetrics(face: freetype.Face) Metrics {
+    fn calcMetrics(face: freetype.Face) font.face.Metrics {
         const size_metrics = face.handle.*.size.*.metrics;
 
         // Cell width is calculated by preferring to use 'M' as the width of a

commit 22f437aac638f9cadca6864e3bb2309eb2428598
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 11:49:23 2022 -0700

    font: coretext cell width calculation

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 9542414d..7ba8895e 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -389,6 +389,7 @@ test {
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
     defer ft_font.deinit();
+    //log.warn("FT WIDTH={}", .{ft_font.metrics.cell_width});
 
     try testing.expectEqual(Presentation.text, ft_font.presentation);
 

commit a97f997f9abfd8d7e2797825c91f063145fd5a8f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 17:03:09 2022 -0700

    font: start working on core text cell height calcs

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 7ba8895e..5038a2c4 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -389,7 +389,7 @@ test {
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
     defer ft_font.deinit();
-    //log.warn("FT WIDTH={}", .{ft_font.metrics.cell_width});
+    log.warn("FT={}", .{ft_font.metrics});
 
     try testing.expectEqual(Presentation.text, ft_font.presentation);
 

commit 2e1bc7bb016f4b19ac06a491df68c64aef46e057
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 16 20:47:21 2022 -0700

    Bring back freetype font bitmap conversion
    
    Monaco on Mac is mono

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 5038a2c4..e168d50d 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -16,6 +16,7 @@ const font = @import("../main.zig");
 const Glyph = font.Glyph;
 const Library = font.Library;
 const Presentation = font.Presentation;
+const convert = @import("freetype_convert.zig");
 
 const log = std.log.scoped(.font_face);
 
@@ -143,7 +144,8 @@ pub const Face = struct {
         // or color depth is as expected on the texture atlas. If format is null
         // it means there is no native color format for our Atlas and we must try
         // conversion.
-        const format: Atlas.Format = switch (bitmap_ft.pixel_mode) {
+        const format: ?Atlas.Format = switch (bitmap_ft.pixel_mode) {
+            freetype.c.FT_PIXEL_MODE_MONO => null,
             freetype.c.FT_PIXEL_MODE_GRAY => .greyscale,
             freetype.c.FT_PIXEL_MODE_BGRA => .rgba,
             else => {
@@ -151,9 +153,26 @@ pub const Face = struct {
                 @panic("unsupported pixel mode");
             },
         };
-        assert(atlas.format == format);
 
-        const bitmap = bitmap_ft;
+        // If our atlas format doesn't match, look for conversions if possible.
+        const bitmap_converted = if (format == null or atlas.format != format.?) blk: {
+            const func = convert.map[bitmap_ft.pixel_mode].get(atlas.format) orelse {
+                log.warn("glyph={} pixel mode={}", .{ glyph_index, bitmap_ft.pixel_mode });
+                return error.UnsupportedPixelMode;
+            };
+
+            log.warn("converting from pixel_mode={} to atlas_format={}", .{
+                bitmap_ft.pixel_mode,
+                atlas.format,
+            });
+            break :blk try func(alloc, bitmap_ft);
+        } else null;
+        defer if (bitmap_converted) |bm| {
+            const len = bm.width * bm.rows * atlas.format.depth();
+            alloc.free(bm.buffer[0..len]);
+        };
+
+        const bitmap = bitmap_converted orelse bitmap_ft;
         const tgt_w = bitmap.width;
         const tgt_h = bitmap.rows;
 

commit a39fe6baed415acce320941488bbbd1ee61ecb1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 16 20:55:06 2022 -0700

    Use scalable check rather than fixed size check for setting char size

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index e168d50d..0bc7a995 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -80,7 +80,7 @@ pub const Face = struct {
         // If we have fixed sizes, we just have to try to pick the one closest
         // to what the user requested. Otherwise, we can choose an arbitrary
         // pixel size.
-        if (!face.hasFixedSizes()) {
+        if (face.isScalable()) {
             const size_26dot6 = @intCast(i32, size.points << 6); // mult by 64
             try face.setCharSize(0, size_26dot6, size.xdpi, size.ydpi);
         } else try selectSizeNearest(face, size.pixels());

commit 58c107dceb1596dc839067619c2e11aa2eb05a57
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Oct 17 19:04:39 2022 -0700

    freetype: resize glyphs that are too tall prior to storing in texture
    
    Most emoji fonts are massive glyphs (128x128, 256x256, etc.). This means
    the texture we need to store emoji is also massive. For a 128x128 emoji
    font (both Apple and Noto), we can only store 12 emoji before resizing
    prior to this commit.
    
    This commit now threads through a max height through to the font face
    and resizes the bitmap in memory before putting it in the atlas. This
    results in significant savings. The max height is the cell height. We
    allow the glyphs to be as wide as necessary due to double (and more)
    wide glyphs.
    
    For the unicode emoji test file, the atlas size before and after:
    
      Before: 262 MB
      After: 16 MB

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 0bc7a995..be09833a 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -8,6 +8,7 @@ const std = @import("std");
 const builtin = @import("builtin");
 const freetype = @import("freetype");
 const harfbuzz = @import("harfbuzz");
+const resize = @import("stb_image_resize");
 const assert = std.debug.assert;
 const testing = std.testing;
 const Allocator = std.mem.Allocator;
@@ -118,7 +119,13 @@ pub const Face = struct {
 
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
     /// given texture atlas.
-    pub fn renderGlyph(self: Face, alloc: Allocator, atlas: *Atlas, glyph_index: u32) !Glyph {
+    pub fn renderGlyph(
+        self: Face,
+        alloc: Allocator,
+        atlas: *Atlas,
+        glyph_index: u32,
+        max_height: ?u16,
+    ) !Glyph {
         // If our glyph has color, we want to render the color
         try self.face.loadGlyph(glyph_index, .{
             .render = true,
@@ -168,11 +175,58 @@ pub const Face = struct {
             break :blk try func(alloc, bitmap_ft);
         } else null;
         defer if (bitmap_converted) |bm| {
-            const len = bm.width * bm.rows * atlas.format.depth();
+            const len = @intCast(usize, bm.pitch) * @intCast(usize, bm.rows);
             alloc.free(bm.buffer[0..len]);
         };
 
-        const bitmap = bitmap_converted orelse bitmap_ft;
+        // Now we need to see if we need to resize this bitmap. This can happen
+        // in scenarios where we have fixed size glyphs. For example, emoji
+        // can be quite large (i.e. 128x128) when we have a cell width of 24!
+        // The issue with large bitmaps is they take a huge amount of space in
+        // the atlas and force resizes quite frequently. We pay some CPU cost
+        // up front to resize the glyph to avoid significant CPU cost to resize
+        // and copy the atlas.
+        const bitmap_resized: ?freetype.c.struct_FT_Bitmap_ = resized: {
+            const max = max_height orelse break :resized null;
+            const bm = bitmap_converted orelse bitmap_ft;
+            if (bm.rows <= max) break :resized null;
+
+            var result = bm;
+            result.rows = max;
+            result.width = (result.rows * bm.width) / bm.rows;
+            result.pitch = @intCast(c_int, result.width) * atlas.format.depth();
+
+            const buf = try alloc.alloc(
+                u8,
+                @intCast(usize, result.pitch) * @intCast(usize, result.rows),
+            );
+            result.buffer = buf.ptr;
+            errdefer alloc.free(buf);
+
+            if (resize.stbir_resize_uint8(
+                bm.buffer,
+                @intCast(c_int, bm.width),
+                @intCast(c_int, bm.rows),
+                bm.pitch,
+                result.buffer,
+                @intCast(c_int, result.width),
+                @intCast(c_int, result.rows),
+                result.pitch,
+                atlas.format.depth(),
+            ) == 0) {
+                // This should never fail because this is a fairly straightforward
+                // in-memory operation...
+                return error.GlyphResizeFailed;
+            }
+
+            break :resized result;
+        };
+        defer if (bitmap_resized) |bm| {
+            const len = @intCast(usize, bm.pitch) * @intCast(usize, bm.rows);
+            alloc.free(bm.buffer[0..len]);
+        };
+
+        const bitmap = bitmap_resized orelse (bitmap_converted orelse bitmap_ft);
         const tgt_w = bitmap.width;
         const tgt_h = bitmap.rows;
 
@@ -415,7 +469,7 @@ test {
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
-        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?, null);
     }
 }
 
@@ -434,7 +488,13 @@ test "color emoji" {
 
     try testing.expectEqual(Presentation.emoji, ft_font.presentation);
 
-    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?);
+    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, null);
+
+    // resize
+    {
+        const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, 24);
+        try testing.expectEqual(@as(u32, 24), glyph.height);
+    }
 }
 
 test "mono to rgba" {
@@ -451,5 +511,5 @@ test "mono to rgba" {
     defer ft_font.deinit();
 
     // glyph 3 is mono in Noto
-    _ = try ft_font.renderGlyph(alloc, &atlas, 3);
+    _ = try ft_font.renderGlyph(alloc, &atlas, 3, null);
 }

commit 79f69885cafe41dc04d36eb19fd99d9f17e74b84
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 19 10:42:31 2022 -0700

    update to latest zig which renames @min/@max

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index be09833a..746650e9 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -363,9 +363,9 @@ pub const Face = struct {
                 break :underscore 0;
             };
 
-            break :cell_height @maximum(
+            break :cell_height @max(
                 face_height,
-                @maximum(max_glyph_height, underscore_height),
+                @max(max_glyph_height, underscore_height),
             );
         };
 
@@ -394,7 +394,7 @@ pub const Face = struct {
             // cell height (mainly: non-scalable fonts, i.e. emoji)
             break :underline_pos cell_height - 1;
         };
-        const underline_thickness = @maximum(1, fontUnitsToPxY(
+        const underline_thickness = @max(1, fontUnitsToPxY(
             face,
             face.handle.*.underline_thickness,
         ));
@@ -415,7 +415,7 @@ pub const Face = struct {
 
                 break :pos @intToFloat(f32, ascender_px - declared_px);
             },
-            .thickness = @maximum(1, fontUnitsToPxY(face, os2.yStrikeoutSize)),
+            .thickness = @max(1, fontUnitsToPxY(face, os2.yStrikeoutSize)),
         } else .{
             .pos = cell_baseline * 0.6,
             .thickness = underline_thickness,

commit d1718e6cbfe6c0ba851f8c37c22ed0ef73d8e757
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 8 19:01:45 2022 -0800

    use libc memcpy/memmove instead of std.mem if available

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 746650e9..f892c377 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -18,6 +18,7 @@ const Glyph = font.Glyph;
 const Library = font.Library;
 const Presentation = font.Presentation;
 const convert = @import("freetype_convert.zig");
+const fastmem = @import("../../fastmem.zig");
 
 const log = std.log.scoped(.font_face);
 
@@ -248,7 +249,7 @@ pub const Face = struct {
                 var src_ptr = bitmap.buffer;
                 var i: usize = 0;
                 while (i < bitmap.rows) : (i += 1) {
-                    std.mem.copy(u8, dst_ptr, src_ptr[0 .. bitmap.width * depth]);
+                    fastmem.copy(u8, dst_ptr, src_ptr[0 .. bitmap.width * depth]);
                     dst_ptr = dst_ptr[tgt_w * depth ..];
                     src_ptr += @intCast(usize, bitmap.pitch);
                 }

commit 1c4552de3bb96f3b743c62f75033c07cdc21ed1e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 15 15:23:28 2022 -0800

    font: freetype eliminate some duplicated work on init

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index f892c377..1e02ce5b 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -40,24 +40,17 @@ pub const Face = struct {
     pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
         const face = try lib.lib.initFace(path, index);
         errdefer face.deinit();
-        try face.selectCharmap(.unicode);
-        try setSize_(face, size);
-
-        const hb_font = try harfbuzz.freetype.createFont(face.handle);
-        errdefer hb_font.destroy();
-
-        return Face{
-            .face = face,
-            .hb_font = hb_font,
-            .presentation = if (face.hasColor()) .emoji else .text,
-            .metrics = calcMetrics(face),
-        };
+        return try initFace(face, size);
     }
 
     /// Initialize a new font face with the given source in-memory.
     pub fn init(lib: Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
         const face = try lib.lib.initMemoryFace(source, 0);
         errdefer face.deinit();
+        return try initFace(face, size);
+    }
+
+    fn initFace(face: freetype.Face, size: font.face.DesiredSize) !Face {
         try face.selectCharmap(.unicode);
         try setSize_(face, size);
 

commit d759c7fb254e6b71d3cd0ac8b1e3b952edc0c96c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 15 15:37:16 2022 -0800

    font: freetype face supports resize

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 1e02ce5b..4c726b16 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -71,6 +71,13 @@ pub const Face = struct {
         self.* = undefined;
     }
 
+    /// Resize the font in-place. If this succeeds, the caller is responsible
+    /// for clearing any glyph caches, font atlas data, etc.
+    pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {
+        try setSize_(self.face, size);
+        self.metrics = calcMetrics(self.face);
+    }
+
     fn setSize_(face: freetype.Face, size: font.face.DesiredSize) !void {
         // If we have fixed sizes, we just have to try to pick the one closest
         // to what the user requested. Otherwise, we can choose an arbitrary
@@ -456,7 +463,6 @@ test {
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
     defer ft_font.deinit();
-    log.warn("FT={}", .{ft_font.metrics});
 
     try testing.expectEqual(Presentation.text, ft_font.presentation);
 
@@ -465,6 +471,16 @@ test {
     while (i < 127) : (i += 1) {
         _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?, null);
     }
+
+    // Test resizing
+    {
+        const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
+        try testing.expectEqual(@as(u32, 11), g1.height);
+
+        try ft_font.setSize(.{ .points = 24 });
+        const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
+        try testing.expectEqual(@as(u32, 21), g2.height);
+    }
 }
 
 test "color emoji" {
@@ -491,6 +507,42 @@ test "color emoji" {
     }
 }
 
+test "metrics" {
+    const testFont = @import("../test.zig").fontRegular;
+    const alloc = testing.allocator;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
+
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    defer ft_font.deinit();
+
+    try testing.expectEqual(font.face.Metrics{
+        .cell_width = 8,
+        .cell_height = 1.8e1,
+        .cell_baseline = 4,
+        .underline_position = 18,
+        .underline_thickness = 1,
+        .strikethrough_position = 10,
+        .strikethrough_thickness = 1,
+    }, ft_font.metrics);
+
+    // Resize should change metrics
+    try ft_font.setSize(.{ .points = 24 });
+    try testing.expectEqual(font.face.Metrics{
+        .cell_width = 16,
+        .cell_height = 35,
+        .cell_baseline = 7,
+        .underline_position = 36,
+        .underline_thickness = 2,
+        .strikethrough_position = 20,
+        .strikethrough_thickness = 2,
+    }, ft_font.metrics);
+}
+
 test "mono to rgba" {
     const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontEmoji;

commit da2942e083adb0eda4b19523813d9f5f1d6bb5f2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 17 15:49:14 2022 -0800

    font: specific codepoint lookup in internals

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 4c726b16..ccb057ce 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -461,7 +461,7 @@ test {
     var atlas = try Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
     defer ft_font.deinit();
 
     try testing.expectEqual(Presentation.text, ft_font.presentation);
@@ -477,7 +477,7 @@ test {
         const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
         try testing.expectEqual(@as(u32, 11), g1.height);
 
-        try ft_font.setSize(.{ .points = 24 });
+        try ft_font.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
         const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
         try testing.expectEqual(@as(u32, 21), g2.height);
     }
@@ -493,7 +493,7 @@ test "color emoji" {
     var atlas = try Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
     defer ft_font.deinit();
 
     try testing.expectEqual(Presentation.emoji, ft_font.presentation);
@@ -517,7 +517,7 @@ test "metrics" {
     var atlas = try Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
     defer ft_font.deinit();
 
     try testing.expectEqual(font.face.Metrics{
@@ -531,7 +531,7 @@ test "metrics" {
     }, ft_font.metrics);
 
     // Resize should change metrics
-    try ft_font.setSize(.{ .points = 24 });
+    try ft_font.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
     try testing.expectEqual(font.face.Metrics{
         .cell_width = 16,
         .cell_height = 35,

commit 2796a0b96460759326456d1854286c5672a53375
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 22:06:25 2022 -0800

    font: when resizing a glyph, scale metrics by same ratio
    
    We rely on the top/left offset to position the glyph properly. When we
    were resizing, we weren't properly recalculating this offset which led
    to some glyphs slightly (or majorly) off depending on how much they
    resized.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index ccb057ce..39d0949a 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -187,9 +187,10 @@ pub const Face = struct {
         // the atlas and force resizes quite frequently. We pay some CPU cost
         // up front to resize the glyph to avoid significant CPU cost to resize
         // and copy the atlas.
+        const bitmap_original = bitmap_converted orelse bitmap_ft;
         const bitmap_resized: ?freetype.c.struct_FT_Bitmap_ = resized: {
             const max = max_height orelse break :resized null;
-            const bm = bitmap_converted orelse bitmap_ft;
+            const bm = bitmap_original;
             if (bm.rows <= max) break :resized null;
 
             var result = bm;
@@ -231,6 +232,23 @@ pub const Face = struct {
         const tgt_w = bitmap.width;
         const tgt_h = bitmap.rows;
 
+        // If we resized our bitmap, we need to recalculate some metrics that
+        // we use such as the top/left offsets. These need to be scaled by the
+        // same ratio as the resize.
+        const glyph_metrics = if (bitmap_resized) |bm| metrics: {
+            // Our ratio for the resize
+            const ratio = ratio: {
+                const new = @intToFloat(f64, bm.rows);
+                const old = @intToFloat(f64, bitmap_original.rows);
+                break :ratio new / old;
+            };
+
+            var copy = glyph.*;
+            copy.bitmap_top = @floatToInt(c_int, @round(@intToFloat(f64, copy.bitmap_top) * ratio));
+            copy.bitmap_left = @floatToInt(c_int, @round(@intToFloat(f64, copy.bitmap_left) * ratio));
+            break :metrics copy;
+        } else glyph.*;
+
         const region = try atlas.reserve(alloc, tgt_w, tgt_h);
 
         // If we have data, copy it into the atlas
@@ -280,18 +298,18 @@ pub const Face = struct {
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph.*.bitmap_top + @floatToInt(c_int, self.metrics.cell_baseline);
+            break :offset_y glyph_metrics.bitmap_top + @floatToInt(c_int, self.metrics.cell_baseline);
         };
 
         // Store glyph metadata
         return Glyph{
             .width = tgt_w,
             .height = tgt_h,
-            .offset_x = glyph.*.bitmap_left,
+            .offset_x = glyph_metrics.bitmap_left,
             .offset_y = offset_y,
             .atlas_x = region.x,
             .atlas_y = region.y,
-            .advance_x = f26dot6ToFloat(glyph.*.advance.x),
+            .advance_x = f26dot6ToFloat(glyph_metrics.advance.x),
         };
     }
 

commit f871630fa40e6dbe035d55376a90d33c4470e5f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 28 10:35:46 2022 -0800

    move Atlas to font

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 39d0949a..eca1da33 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -12,7 +12,6 @@ const resize = @import("stb_image_resize");
 const assert = std.debug.assert;
 const testing = std.testing;
 const Allocator = std.mem.Allocator;
-const Atlas = @import("../../Atlas.zig");
 const font = @import("../main.zig");
 const Glyph = font.Glyph;
 const Library = font.Library;
@@ -123,7 +122,7 @@ pub const Face = struct {
     pub fn renderGlyph(
         self: Face,
         alloc: Allocator,
-        atlas: *Atlas,
+        atlas: *font.Atlas,
         glyph_index: u32,
         max_height: ?u16,
     ) !Glyph {
@@ -152,7 +151,7 @@ pub const Face = struct {
         // or color depth is as expected on the texture atlas. If format is null
         // it means there is no native color format for our Atlas and we must try
         // conversion.
-        const format: ?Atlas.Format = switch (bitmap_ft.pixel_mode) {
+        const format: ?font.Atlas.Format = switch (bitmap_ft.pixel_mode) {
             freetype.c.FT_PIXEL_MODE_MONO => null,
             freetype.c.FT_PIXEL_MODE_GRAY => .greyscale,
             freetype.c.FT_PIXEL_MODE_BGRA => .rgba,
@@ -476,7 +475,7 @@ test {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
@@ -508,7 +507,7 @@ test "color emoji" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try Atlas.init(alloc, 512, .rgba);
+    var atlas = try font.Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
@@ -532,7 +531,7 @@ test "metrics" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
@@ -568,7 +567,7 @@ test "mono to rgba" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try Atlas.init(alloc, 512, .rgba);
+    var atlas = try font.Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(lib, testFont, .{ .points = 12 });

commit 19e326dab67e719376bb764c687ef1738f6cd1a5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 5 10:54:40 2022 -0800

    font: working on rendering glyphs in canvas

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index eca1da33..526a980f 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -113,7 +113,7 @@ pub const Face = struct {
 
     /// Returns true if this font is colored. This can be used by callers to
     /// determine what kind of atlas to pass in.
-    pub fn hasColor(self: Face) bool {
+    fn hasColor(self: Face) bool {
         return self.face.hasColor();
     }
 

commit 20f9e98894962d7ffaa4a893800b0bd79ae44db0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 16 22:54:21 2023 -0700

    font/freetype: add a 1px border to each glyph in the texture atlas

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 526a980f..87ff689b 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -231,6 +231,11 @@ pub const Face = struct {
         const tgt_w = bitmap.width;
         const tgt_h = bitmap.rows;
 
+        // Must have non-empty bitmap because we return earlier
+        // if zero. We assume the rest of this that it is nont-zero so
+        // this is important.
+        assert(tgt_w > 0 and tgt_h > 0);
+
         // If we resized our bitmap, we need to recalculate some metrics that
         // we use such as the top/left offsets. These need to be scaled by the
         // same ratio as the resize.
@@ -248,10 +253,33 @@ pub const Face = struct {
             break :metrics copy;
         } else glyph.*;
 
-        const region = try atlas.reserve(alloc, tgt_w, tgt_h);
+        // Allocate our texture atlas region
+        const region = region: {
+            // We need to add a 1px padding to the font so that we don't
+            // get fuzzy issues when blending textures.
+            const padding = 1;
+
+            // Get the full padded region
+            var region = try atlas.reserve(
+                alloc,
+                tgt_w + (padding * 2), // * 2 because left+right
+                tgt_h + (padding * 2), // * 2 because top+bottom
+            );
+
+            // Modify the region so that we remove the padding so that
+            // we write to the non-zero location. The data in an Altlas
+            // is always initialized to zero (Atlas.clear) so we don't
+            // need to worry about zero-ing that.
+            region.x += padding;
+            region.y += padding;
+            region.width -= padding * 2;
+            region.height -= padding * 2;
+            break :region region;
+        };
 
-        // If we have data, copy it into the atlas
-        if (region.width > 0 and region.height > 0) {
+        // Copy the image into the region.
+        assert(region.width > 0 and region.height > 0);
+        {
             const depth = atlas.format.depth();
 
             // We can avoid a buffer copy if our atlas width and bitmap

commit 97d9157d225b2e0e430842cc12b47650ab0de8c7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun May 7 20:40:05 2023 -0700

    update zig version

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 87ff689b..19c886ed 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -440,7 +440,7 @@ pub const Face = struct {
             // cell height (mainly: non-scalable fonts, i.e. emoji)
             break :underline_pos cell_height - 1;
         };
-        const underline_thickness = @max(1, fontUnitsToPxY(
+        const underline_thickness = @max(@as(f32, 1), fontUnitsToPxY(
             face,
             face.handle.*.underline_thickness,
         ));
@@ -461,7 +461,7 @@ pub const Face = struct {
 
                 break :pos @intToFloat(f32, ascender_px - declared_px);
             },
-            .thickness = @max(1, fontUnitsToPxY(face, os2.yStrikeoutSize)),
+            .thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize)),
         } else .{
             .pos = cell_baseline * 0.6,
             .thickness = underline_thickness,

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 19c886ed..f84a0f19 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -242,14 +242,14 @@ pub const Face = struct {
         const glyph_metrics = if (bitmap_resized) |bm| metrics: {
             // Our ratio for the resize
             const ratio = ratio: {
-                const new = @intToFloat(f64, bm.rows);
-                const old = @intToFloat(f64, bitmap_original.rows);
+                const new = @floatFromInt(f64, bm.rows);
+                const old = @floatFromInt(f64, bitmap_original.rows);
                 break :ratio new / old;
             };
 
             var copy = glyph.*;
-            copy.bitmap_top = @floatToInt(c_int, @round(@intToFloat(f64, copy.bitmap_top) * ratio));
-            copy.bitmap_left = @floatToInt(c_int, @round(@intToFloat(f64, copy.bitmap_left) * ratio));
+            copy.bitmap_top = @intFromFloat(c_int, @round(@floatFromInt(f64, copy.bitmap_top) * ratio));
+            copy.bitmap_left = @intFromFloat(c_int, @round(@floatFromInt(f64, copy.bitmap_left) * ratio));
             break :metrics copy;
         } else glyph.*;
 
@@ -325,7 +325,7 @@ pub const Face = struct {
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph_metrics.bitmap_top + @floatToInt(c_int, self.metrics.cell_baseline);
+            break :offset_y glyph_metrics.bitmap_top + @intFromFloat(c_int, self.metrics.cell_baseline);
         };
 
         // Store glyph metadata
@@ -351,7 +351,7 @@ pub const Face = struct {
 
     /// Convert 26.6 pixel format to f32
     fn f26dot6ToFloat(v: freetype.c.FT_F26Dot6) f32 {
-        return @intToFloat(f32, v >> 6);
+        return @floatFromInt(f32, v >> 6);
     }
 
     /// Calculate the metrics associated with a face. This is not public because
@@ -398,8 +398,8 @@ pub const Face = struct {
                 if (face.getCharIndex('_')) |glyph_index| {
                     if (face.loadGlyph(glyph_index, .{ .render = true })) {
                         var res: f32 = f26dot6ToFloat(size_metrics.ascender);
-                        res -= @intToFloat(f32, face.handle.*.glyph.*.bitmap_top);
-                        res += @intToFloat(f32, face.handle.*.glyph.*.bitmap.rows);
+                        res -= @floatFromInt(f32, face.handle.*.glyph.*.bitmap_top);
+                        res += @floatFromInt(f32, face.handle.*.glyph.*.bitmap.rows);
                         break :underscore res;
                     } else |_| {
                         // Ignore the error since we just fall back below
@@ -434,7 +434,7 @@ pub const Face = struct {
             // We use the declared underline position if its available
             const declared = ascender_px - declared_px;
             if (declared > 0)
-                break :underline_pos @intToFloat(f32, declared);
+                break :underline_pos @floatFromInt(f32, declared);
 
             // If we have no declared underline position, we go slightly under the
             // cell height (mainly: non-scalable fonts, i.e. emoji)
@@ -459,7 +459,7 @@ pub const Face = struct {
                     @intCast(i32, face.handle.*.size.*.metrics.y_scale),
                 ) >> 6;
 
-                break :pos @intToFloat(f32, ascender_px - declared_px);
+                break :pos @floatFromInt(f32, ascender_px - declared_px);
             },
             .thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize)),
         } else .{
@@ -491,7 +491,7 @@ pub const Face = struct {
     /// Convert freetype "font units" to pixels using the Y scale.
     fn fontUnitsToPxY(face: freetype.Face, x: i32) f32 {
         const mul = freetype.mulFix(x, @intCast(i32, face.handle.*.size.*.metrics.y_scale));
-        const div = @intToFloat(f32, mul) / 64;
+        const div = @floatFromInt(f32, mul) / 64;
         return @ceil(div);
     }
 };

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index f84a0f19..fdeb27e8 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -82,7 +82,7 @@ pub const Face = struct {
         // to what the user requested. Otherwise, we can choose an arbitrary
         // pixel size.
         if (face.isScalable()) {
-            const size_26dot6 = @intCast(i32, size.points << 6); // mult by 64
+            const size_26dot6 = @as(i32, @intCast(size.points << 6)); // mult by 64
             try face.setCharSize(0, size_26dot6, size.xdpi, size.ydpi);
         } else try selectSizeNearest(face, size.pixels());
     }
@@ -94,8 +94,8 @@ pub const Face = struct {
         var best_i: i32 = 0;
         var best_diff: i32 = 0;
         while (i < face.handle.*.num_fixed_sizes) : (i += 1) {
-            const width = face.handle.*.available_sizes[@intCast(usize, i)].width;
-            const diff = @intCast(i32, size) - @intCast(i32, width);
+            const width = face.handle.*.available_sizes[@intCast(i)].width;
+            const diff = @as(i32, @intCast(size)) - @as(i32, @intCast(width));
             if (i == 0 or diff < best_diff) {
                 best_diff = diff;
                 best_i = i;
@@ -175,7 +175,7 @@ pub const Face = struct {
             break :blk try func(alloc, bitmap_ft);
         } else null;
         defer if (bitmap_converted) |bm| {
-            const len = @intCast(usize, bm.pitch) * @intCast(usize, bm.rows);
+            const len = @as(usize, @intCast(bm.pitch)) * @as(usize, @intCast(bm.rows));
             alloc.free(bm.buffer[0..len]);
         };
 
@@ -195,23 +195,23 @@ pub const Face = struct {
             var result = bm;
             result.rows = max;
             result.width = (result.rows * bm.width) / bm.rows;
-            result.pitch = @intCast(c_int, result.width) * atlas.format.depth();
+            result.pitch = @as(c_int, @intCast(result.width)) * atlas.format.depth();
 
             const buf = try alloc.alloc(
                 u8,
-                @intCast(usize, result.pitch) * @intCast(usize, result.rows),
+                @as(usize, @intCast(result.pitch)) * @as(usize, @intCast(result.rows)),
             );
             result.buffer = buf.ptr;
             errdefer alloc.free(buf);
 
             if (resize.stbir_resize_uint8(
                 bm.buffer,
-                @intCast(c_int, bm.width),
-                @intCast(c_int, bm.rows),
+                @intCast(bm.width),
+                @intCast(bm.rows),
                 bm.pitch,
                 result.buffer,
-                @intCast(c_int, result.width),
-                @intCast(c_int, result.rows),
+                @intCast(result.width),
+                @intCast(result.rows),
                 result.pitch,
                 atlas.format.depth(),
             ) == 0) {
@@ -223,7 +223,7 @@ pub const Face = struct {
             break :resized result;
         };
         defer if (bitmap_resized) |bm| {
-            const len = @intCast(usize, bm.pitch) * @intCast(usize, bm.rows);
+            const len = @as(usize, @intCast(bm.pitch)) * @as(usize, @intCast(bm.rows));
             alloc.free(bm.buffer[0..len]);
         };
 
@@ -242,14 +242,14 @@ pub const Face = struct {
         const glyph_metrics = if (bitmap_resized) |bm| metrics: {
             // Our ratio for the resize
             const ratio = ratio: {
-                const new = @floatFromInt(f64, bm.rows);
-                const old = @floatFromInt(f64, bitmap_original.rows);
+                const new: f64 = @floatFromInt(bm.rows);
+                const old: f64 = @floatFromInt(bitmap_original.rows);
                 break :ratio new / old;
             };
 
             var copy = glyph.*;
-            copy.bitmap_top = @intFromFloat(c_int, @round(@floatFromInt(f64, copy.bitmap_top) * ratio));
-            copy.bitmap_left = @intFromFloat(c_int, @round(@floatFromInt(f64, copy.bitmap_left) * ratio));
+            copy.bitmap_top = @as(c_int, @intFromFloat(@round(@as(f64, @floatFromInt(copy.bitmap_top)) * ratio)));
+            copy.bitmap_left = @as(c_int, @intFromFloat(@round(@as(f64, @floatFromInt(copy.bitmap_left)) * ratio)));
             break :metrics copy;
         } else glyph.*;
 
@@ -296,7 +296,7 @@ pub const Face = struct {
                 while (i < bitmap.rows) : (i += 1) {
                     fastmem.copy(u8, dst_ptr, src_ptr[0 .. bitmap.width * depth]);
                     dst_ptr = dst_ptr[tgt_w * depth ..];
-                    src_ptr += @intCast(usize, bitmap.pitch);
+                    src_ptr += @as(usize, @intCast(bitmap.pitch));
                 }
                 break :buffer temp;
             } else bitmap.buffer[0..(tgt_w * tgt_h * depth)];
@@ -308,7 +308,7 @@ pub const Face = struct {
             atlas.set(region, buffer);
         }
 
-        const offset_y = offset_y: {
+        const offset_y: c_int = offset_y: {
             // For non-scalable colorized fonts, we assume they are pictographic
             // and just center the glyph. So far this has only applied to emoji
             // fonts. Emoji fonts don't always report a correct ascender/descender
@@ -318,14 +318,14 @@ pub const Face = struct {
             // NOTE(mitchellh): I don't know if this is right, this doesn't
             // _feel_ right, but it makes all my limited test cases work.
             if (self.face.hasColor() and !self.face.isScalable()) {
-                break :offset_y @intCast(c_int, tgt_h);
+                break :offset_y @intCast(tgt_h);
             }
 
             // The Y offset is the offset of the top of our bitmap PLUS our
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph_metrics.bitmap_top + @intFromFloat(c_int, self.metrics.cell_baseline);
+            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intFromFloat(self.metrics.cell_baseline));
         };
 
         // Store glyph metadata
@@ -343,15 +343,15 @@ pub const Face = struct {
     /// Convert 16.6 pixel format to pixels based on the scale factor of the
     /// current font size.
     fn unitsToPxY(self: Face, units: i32) i32 {
-        return @intCast(i32, freetype.mulFix(
+        return @intCast(freetype.mulFix(
             units,
-            @intCast(i32, self.face.handle.*.size.*.metrics.y_scale),
+            @intCast(self.face.handle.*.size.*.metrics.y_scale),
         ) >> 6);
     }
 
     /// Convert 26.6 pixel format to f32
     fn f26dot6ToFloat(v: freetype.c.FT_F26Dot6) f32 {
-        return @floatFromInt(f32, v >> 6);
+        return @floatFromInt(v >> 6);
     }
 
     /// Calculate the metrics associated with a face. This is not public because
@@ -398,8 +398,8 @@ pub const Face = struct {
                 if (face.getCharIndex('_')) |glyph_index| {
                     if (face.loadGlyph(glyph_index, .{ .render = true })) {
                         var res: f32 = f26dot6ToFloat(size_metrics.ascender);
-                        res -= @floatFromInt(f32, face.handle.*.glyph.*.bitmap_top);
-                        res += @floatFromInt(f32, face.handle.*.glyph.*.bitmap.rows);
+                        res -= @floatFromInt(face.handle.*.glyph.*.bitmap_top);
+                        res += @floatFromInt(face.handle.*.glyph.*.bitmap.rows);
                         break :underscore res;
                     } else |_| {
                         // Ignore the error since we just fall back below
@@ -422,19 +422,19 @@ pub const Face = struct {
 
         // The underline position. This is a value from the top where the
         // underline should go.
-        const underline_position = underline_pos: {
+        const underline_position: f32 = underline_pos: {
             // The ascender is already scaled for scalable fonts, but the
             // underline position is not.
-            const ascender_px = @intCast(i32, size_metrics.ascender) >> 6;
+            const ascender_px = @as(i32, @intCast(size_metrics.ascender)) >> 6;
             const declared_px = freetype.mulFix(
                 face.handle.*.underline_position,
-                @intCast(i32, face.handle.*.size.*.metrics.y_scale),
+                @intCast(face.handle.*.size.*.metrics.y_scale),
             ) >> 6;
 
             // We use the declared underline position if its available
             const declared = ascender_px - declared_px;
             if (declared > 0)
-                break :underline_pos @floatFromInt(f32, declared);
+                break :underline_pos @floatFromInt(declared);
 
             // If we have no declared underline position, we go slightly under the
             // cell height (mainly: non-scalable fonts, i.e. emoji)
@@ -453,13 +453,13 @@ pub const Face = struct {
         } = if (face.getSfntTable(.os2)) |os2| .{
             .pos = pos: {
                 // Ascender is scaled, strikeout pos is not
-                const ascender_px = @intCast(i32, size_metrics.ascender) >> 6;
+                const ascender_px = @as(i32, @intCast(size_metrics.ascender)) >> 6;
                 const declared_px = freetype.mulFix(
                     os2.yStrikeoutPosition,
-                    @intCast(i32, face.handle.*.size.*.metrics.y_scale),
+                    @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)),
                 ) >> 6;
 
-                break :pos @floatFromInt(f32, ascender_px - declared_px);
+                break :pos @floatFromInt(ascender_px - declared_px);
             },
             .thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize)),
         } else .{
@@ -490,8 +490,8 @@ pub const Face = struct {
 
     /// Convert freetype "font units" to pixels using the Y scale.
     fn fontUnitsToPxY(face: freetype.Face, x: i32) f32 {
-        const mul = freetype.mulFix(x, @intCast(i32, face.handle.*.size.*.metrics.y_scale));
-        const div = @floatFromInt(f32, mul) / 64;
+        const mul = freetype.mulFix(x, @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)));
+        const div = @as(f32, @floatFromInt(mul)) / 64;
         return @ceil(div);
     }
 };

commit 552a1b51d06a4e00a172082e1fdca0a834c762f7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 14:47:59 2023 -0700

    coretext: rasterization looking cleaner

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index fdeb27e8..4e21ad96 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -467,15 +467,15 @@ pub const Face = struct {
             .thickness = underline_thickness,
         };
 
-        // log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
-        //     size_metrics,
-        //     cell_width,
-        //     cell_height,
-        //     cell_height - cell_baseline,
-        //     underline_position,
-        //     underline_thickness,
-        //     strikethrough,
-        // });
+        log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
+            size_metrics,
+            cell_width,
+            cell_height,
+            cell_height - cell_baseline,
+            underline_position,
+            underline_thickness,
+            strikethrough,
+        });
 
         return .{
             .cell_width = cell_width,

commit 362eeac74b12c00c7def4e73b0b60ea70d65473f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:28:09 2023 -0700

    coretext: do not treat color diffs special for offset

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 4e21ad96..41c21bd3 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -328,6 +328,14 @@ pub const Face = struct {
             break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intFromFloat(self.metrics.cell_baseline));
         };
 
+        // log.warn("renderGlyph width={} height={} offset_x={} offset_y={} glyph_metrics={}", .{
+        //     tgt_w,
+        //     tgt_h,
+        //     glyph_metrics.bitmap_left,
+        //     offset_y,
+        //     glyph_metrics,
+        // });
+
         // Store glyph metadata
         return Glyph{
             .width = tgt_w,

commit b5cc37e20c59b6617c41768db11a7b5febd8aa9c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:54:08 2023 -0700

    font: comment out debug logs

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 41c21bd3..eab180d6 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -475,15 +475,15 @@ pub const Face = struct {
             .thickness = underline_thickness,
         };
 
-        log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
-            size_metrics,
-            cell_width,
-            cell_height,
-            cell_height - cell_baseline,
-            underline_position,
-            underline_thickness,
-            strikethrough,
-        });
+        // log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
+        //     size_metrics,
+        //     cell_width,
+        //     cell_height,
+        //     cell_height - cell_baseline,
+        //     underline_position,
+        //     underline_thickness,
+        //     strikethrough,
+        // });
 
         return .{
             .cell_width = cell_width,

commit 3795cd6c2d8864e846c24a63f2f720244c79d783
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 09:55:19 2023 -0700

    font: turn rasterization options into a struct, add thicken

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index eab180d6..a09a523e 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -124,7 +124,7 @@ pub const Face = struct {
         alloc: Allocator,
         atlas: *font.Atlas,
         glyph_index: u32,
-        max_height: ?u16,
+        opts: font.face.RenderOptions,
     ) !Glyph {
         // If our glyph has color, we want to render the color
         try self.face.loadGlyph(glyph_index, .{
@@ -188,7 +188,7 @@ pub const Face = struct {
         // and copy the atlas.
         const bitmap_original = bitmap_converted orelse bitmap_ft;
         const bitmap_resized: ?freetype.c.struct_FT_Bitmap_ = resized: {
-            const max = max_height orelse break :resized null;
+            const max = opts.max_height orelse break :resized null;
             const bm = bitmap_original;
             if (bm.rows <= max) break :resized null;
 
@@ -522,16 +522,16 @@ test {
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
-        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?, null);
+        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?, .{});
     }
 
     // Test resizing
     {
-        const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
+        const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
         try testing.expectEqual(@as(u32, 11), g1.height);
 
         try ft_font.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
-        const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, null);
+        const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
         try testing.expectEqual(@as(u32, 21), g2.height);
     }
 }
@@ -551,11 +551,13 @@ test "color emoji" {
 
     try testing.expectEqual(Presentation.emoji, ft_font.presentation);
 
-    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, null);
+    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{});
 
     // resize
     {
-        const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, 24);
+        const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{
+            .max_height = 24,
+        });
         try testing.expectEqual(@as(u32, 24), glyph.height);
     }
 }
@@ -610,5 +612,5 @@ test "mono to rgba" {
     defer ft_font.deinit();
 
     // glyph 3 is mono in Noto
-    _ = try ft_font.renderGlyph(alloc, &atlas, 3, null);
+    _ = try ft_font.renderGlyph(alloc, &atlas, 3, .{});
 }

commit 0faf6097d069e097680fe4e5a74181d120431297
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 11:08:12 2023 -0700

    Change font metrics to all be integers, not floats.
    
    Font metrics realistically should be integral. Cell widths, cell
    heights, etc. do not make sense to be floats, since our grid is
    integral. There is no such thing as a "half cell" (or any point).
    
    The reason we historically had these all as f32 is simplicity mixed
    with history. OpenGL APIs and shaders all use f32 for their values, we
    originally only supported OpenGL, and all the font rendering used to be
    directly in the renderer code (like... a year+ ago).
    
    When we refactored the font metrics calculation to its own system and
    also added additional renderers like Metal (which use f64, not f32), we
    never updated anything. We just kept metrics as f32 and casted
    everywhere.
    
    With CoreText and #177 this finally reared its ugly head. By forgetting
    a simple rounding on cell metric calculation, our integral renderers
    (sprite fonts) were off by 1 pixel compared to the GPU renderers.
    Insidious.
    
    Let's represent font metrics with the types that actually make sense: a
    cell width/height, etc. is _integral_. When we get to the GPU, we now
    cast to floats. We also cast to floats whenever we're doing more precise
    math (i.e. mouse offset calculation). In this case, we're only
    converting to floats from a integral type which is going to be much
    safer and less prone to uncertain rounding than converting to an int
    from a float type.
    
    Fixes #177

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index a09a523e..c5dc85d4 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -325,7 +325,7 @@ pub const Face = struct {
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intFromFloat(self.metrics.cell_baseline));
+            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intCast(self.metrics.cell_baseline));
         };
 
         // log.warn("renderGlyph width={} height={} offset_x={} offset_y={} glyph_metrics={}", .{
@@ -475,25 +475,20 @@ pub const Face = struct {
             .thickness = underline_thickness,
         };
 
-        // log.warn("METRICS={} width={d} height={d} baseline={d} underline_pos={d} underline_thickness={d} strikethrough={}", .{
-        //     size_metrics,
-        //     cell_width,
-        //     cell_height,
-        //     cell_height - cell_baseline,
-        //     underline_position,
-        //     underline_thickness,
-        //     strikethrough,
-        // });
-
-        return .{
-            .cell_width = cell_width,
-            .cell_height = cell_height,
-            .cell_baseline = cell_baseline,
-            .underline_position = underline_position,
-            .underline_thickness = underline_thickness,
-            .strikethrough_position = strikethrough.pos,
-            .strikethrough_thickness = strikethrough.thickness,
+        const result = font.face.Metrics{
+            .cell_width = @intFromFloat(cell_width),
+            .cell_height = @intFromFloat(cell_height),
+            .cell_baseline = @intFromFloat(cell_baseline),
+            .underline_position = @intFromFloat(underline_position),
+            .underline_thickness = @intFromFloat(underline_thickness),
+            .strikethrough_position = @intFromFloat(strikethrough.pos),
+            .strikethrough_thickness = @intFromFloat(strikethrough.thickness),
         };
+
+        // std.log.warn("font size size={d}", .{ct_font.getSize()});
+        // std.log.warn("font metrics={}", .{result});
+
+        return result;
     }
 
     /// Convert freetype "font units" to pixels using the Y scale.

commit 369a7dda4c573195a85d3bb44791bf0bef7fc60a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 14:26:06 2023 -0700

    coretext: use alternate approach to calcaulate cell height and ascent
    
    Fixes #174

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index c5dc85d4..e25b947c 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -485,7 +485,6 @@ pub const Face = struct {
             .strikethrough_thickness = @intFromFloat(strikethrough.thickness),
         };
 
-        // std.log.warn("font size size={d}", .{ct_font.getSize()});
         // std.log.warn("font metrics={}", .{result});
 
         return result;

commit ec69644de6f9c926659518bf0792db6aaeb7e190
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 11:46:43 2023 -0700

    move stb to src/stb, add stb_image for png decoding

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index e25b947c..ac0c525f 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -8,7 +8,7 @@ const std = @import("std");
 const builtin = @import("builtin");
 const freetype = @import("freetype");
 const harfbuzz = @import("harfbuzz");
-const resize = @import("stb_image_resize");
+const stb = @import("../../stb/main.zig");
 const assert = std.debug.assert;
 const testing = std.testing;
 const Allocator = std.mem.Allocator;
@@ -204,7 +204,7 @@ pub const Face = struct {
             result.buffer = buf.ptr;
             errdefer alloc.free(buf);
 
-            if (resize.stbir_resize_uint8(
+            if (stb.stbir_resize_uint8(
                 bm.buffer,
                 @intCast(bm.width),
                 @intCast(bm.rows),

commit ea3b957bc7166909fb270f1c9c663f304e36bdbf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 09:29:15 2023 -0700

    quirks: Menlo/Monaco should disable ligatures by default (#331)
    
    * font: disable default font features for Menlo and Monaco
    
    Both of these fonts have a default ligature on "fi" which makes terminal
    rendering super ugly. The easiest thing to do is special-case these
    fonts and disable ligatures. It appears other terminals do the same
    thing.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index ac0c525f..c292e05b 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -70,6 +70,27 @@ pub const Face = struct {
         self.* = undefined;
     }
 
+    /// Returns the font name. If allocation is required, buf will be used,
+    /// but sometimes allocation isn't required and a static string is
+    /// returned.
+    pub fn name(self: *const Face, buf: []u8) Allocator.Error![]const u8 {
+        // We don't use this today but its possible the table below
+        // returns UTF-16 in which case we'd want to use this for conversion.
+        _ = buf;
+
+        const count = self.face.getSfntNameCount();
+
+        // We look for the font family entry.
+        for (0..count) |i| {
+            const entry = self.face.getSfntName(i) catch continue;
+            if (entry.name_id == freetype.c.TT_NAME_ID_FONT_FAMILY) {
+                return entry.string[0..entry.string_len];
+            }
+        }
+
+        return "";
+    }
+
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {

commit f4738210e14e2f0c758376b06a4b3107f5594ba1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 14:44:16 2023 -0700

    font: determine quirks modes on font face load

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index c292e05b..7b104eb0 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -18,6 +18,7 @@ const Library = font.Library;
 const Presentation = font.Presentation;
 const convert = @import("freetype_convert.zig");
 const fastmem = @import("../../fastmem.zig");
+const quirks = @import("../../quirks.zig");
 
 const log = std.log.scoped(.font_face);
 
@@ -35,6 +36,9 @@ pub const Face = struct {
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
+    /// Set quirks.disableDefaultFontFeatures
+    quirks_disable_default_font_features: bool = false,
+
     /// Initialize a new font face with the given source in-memory.
     pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
         const face = try lib.lib.initFace(path, index);
@@ -56,12 +60,14 @@ pub const Face = struct {
         const hb_font = try harfbuzz.freetype.createFont(face.handle);
         errdefer hb_font.destroy();
 
-        return Face{
+        var result: Face = .{
             .face = face,
             .hb_font = hb_font,
             .presentation = if (face.hasColor()) .emoji else .text,
             .metrics = calcMetrics(face),
         };
+        result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
+        return result;
     }
 
     pub fn deinit(self: *Face) void {

commit 1ee5b7f91c7e8d715110fe928a74e2ad60b19fce
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 27 19:58:25 2023 -0700

    font: freetype supports font variation settings

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 7b104eb0..9ae861c7 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -23,6 +23,9 @@ const quirks = @import("../../quirks.zig");
 const log = std.log.scoped(.font_face);
 
 pub const Face = struct {
+    /// Our freetype library
+    lib: freetype.Library,
+
     /// Our font face.
     face: freetype.Face,
 
@@ -43,30 +46,55 @@ pub const Face = struct {
     pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
         const face = try lib.lib.initFace(path, index);
         errdefer face.deinit();
-        return try initFace(face, size);
+        return try initFace(lib, face, size);
     }
 
     /// Initialize a new font face with the given source in-memory.
     pub fn init(lib: Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
         const face = try lib.lib.initMemoryFace(source, 0);
         errdefer face.deinit();
-        return try initFace(face, size);
+        return try initFace(lib, face, size);
     }
 
-    fn initFace(face: freetype.Face, size: font.face.DesiredSize) !Face {
+    fn initFace(lib: Library, face: freetype.Face, size: font.face.DesiredSize) !Face {
         try face.selectCharmap(.unicode);
         try setSize_(face, size);
 
-        const hb_font = try harfbuzz.freetype.createFont(face.handle);
+        var hb_font = try harfbuzz.freetype.createFont(face.handle);
         errdefer hb_font.destroy();
 
         var result: Face = .{
+            .lib = lib.lib,
             .face = face,
             .hb_font = hb_font,
             .presentation = if (face.hasColor()) .emoji else .text,
             .metrics = calcMetrics(face),
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
+
+        // In debug mode, we output information about available variation axes,
+        // if they exist.
+        if (comptime builtin.mode == .Debug) mm: {
+            if (!face.hasMultipleMasters()) break :mm;
+            var buf: [1024]u8 = undefined;
+            log.debug("variation axes font={s}", .{try result.name(&buf)});
+
+            const mm = try face.getMMVar();
+            defer lib.lib.doneMMVar(mm);
+            for (0..mm.num_axis) |i| {
+                const axis = mm.axis[i];
+                const id_raw = std.math.cast(c_int, axis.tag) orelse continue;
+                const id: font.face.Variation.Id = @bitCast(id_raw);
+                log.debug("variation axis: name={s} id={s} min={} max={} def={}", .{
+                    std.mem.sliceTo(axis.name, 0),
+                    id.str(),
+                    axis.minimum >> 16,
+                    axis.maximum >> 16,
+                    axis.def >> 16,
+                });
+            }
+        }
+
         return result;
     }
 
@@ -132,6 +160,50 @@ pub const Face = struct {
         try face.selectSize(best_i);
     }
 
+    /// Set the variation axes for this font. This will modify this font
+    /// in-place.
+    pub fn setVariations(
+        self: *Face,
+        vs: []const font.face.Variation,
+    ) !void {
+        // If this font doesn't support variations, we can't do anything.
+        if (!self.face.hasMultipleMasters() or vs.len == 0) return;
+
+        // Freetype requires that we send ALL coordinates in at once so the
+        // first thing we have to do is get all the vars and put them into
+        // an array.
+        const mm = try self.face.getMMVar();
+        defer self.lib.doneMMVar(mm);
+
+        // To avoid allocations, we cap the number of variation axes we can
+        // support. This is arbitrary but Firefox caps this at 16 so I
+        // feel like that's probably safe... and we do double cause its
+        // cheap.
+        var coords_buf: [32]freetype.c.FT_Fixed = undefined;
+        var coords = coords_buf[0..@min(coords_buf.len, mm.num_axis)];
+        try self.face.getVarDesignCoordinates(coords);
+
+        // Now we go through each axis and see if its set. This is slow
+        // but there usually aren't many axes and usually not many set
+        // variations, either.
+        for (0..mm.num_axis) |i| {
+            const axis = mm.axis[i];
+            const id = std.math.cast(u32, axis.tag) orelse continue;
+            for (vs) |v| {
+                if (id == @as(u32, @bitCast(v.id))) {
+                    coords[i] = @intFromFloat(v.value * 65536);
+                    break;
+                }
+            }
+        }
+
+        // Set them!
+        try self.face.setVarDesignCoordinates(coords);
+
+        // We need to recalculate font metrics which may have changed.
+        self.metrics = calcMetrics(self.face);
+    }
+
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
     pub fn glyphIndex(self: Face, cp: u32) ?u32 {

commit 16cfb142004625abdcd63bea0cce980e65224a10
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 21:48:51 2023 -0700

    font: modify font compiles for freetype

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 9ae861c7..66c27aa9 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -43,22 +43,22 @@ pub const Face = struct {
     quirks_disable_default_font_features: bool = false,
 
     /// Initialize a new font face with the given source in-memory.
-    pub fn initFile(lib: Library, path: [:0]const u8, index: i32, size: font.face.DesiredSize) !Face {
+    pub fn initFile(lib: Library, path: [:0]const u8, index: i32, opts: font.face.Options) !Face {
         const face = try lib.lib.initFace(path, index);
         errdefer face.deinit();
-        return try initFace(lib, face, size);
+        return try initFace(lib, face, opts);
     }
 
     /// Initialize a new font face with the given source in-memory.
-    pub fn init(lib: Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
+    pub fn init(lib: Library, source: [:0]const u8, opts: font.face.Options) !Face {
         const face = try lib.lib.initMemoryFace(source, 0);
         errdefer face.deinit();
-        return try initFace(lib, face, size);
+        return try initFace(lib, face, opts);
     }
 
-    fn initFace(lib: Library, face: freetype.Face, size: font.face.DesiredSize) !Face {
+    fn initFace(lib: Library, face: freetype.Face, opts: font.face.Options) !Face {
         try face.selectCharmap(.unicode);
-        try setSize_(face, size);
+        try setSize_(face, opts.size);
 
         var hb_font = try harfbuzz.freetype.createFont(face.handle);
         errdefer hb_font.destroy();
@@ -68,7 +68,7 @@ pub const Face = struct {
             .face = face,
             .hb_font = hb_font,
             .presentation = if (face.hasColor()) .emoji else .text,
-            .metrics = calcMetrics(face),
+            .metrics = calcMetrics(face, opts.metric_modifiers),
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
@@ -127,9 +127,9 @@ pub const Face = struct {
 
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
-    pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {
-        try setSize_(self.face, size);
-        self.metrics = calcMetrics(self.face);
+    pub fn setSize(self: *Face, opts: font.face.Options) !void {
+        try setSize_(self.face, opts.size);
+        self.metrics = calcMetrics(self.face, opts.metric_modifiers);
     }
 
     fn setSize_(face: freetype.Face, size: font.face.DesiredSize) !void {
@@ -165,6 +165,7 @@ pub const Face = struct {
     pub fn setVariations(
         self: *Face,
         vs: []const font.face.Variation,
+        opts: font.face.Options,
     ) !void {
         // If this font doesn't support variations, we can't do anything.
         if (!self.face.hasMultipleMasters() or vs.len == 0) return;
@@ -201,7 +202,7 @@ pub const Face = struct {
         try self.face.setVarDesignCoordinates(coords);
 
         // We need to recalculate font metrics which may have changed.
-        self.metrics = calcMetrics(self.face);
+        self.metrics = calcMetrics(self.face, opts.metric_modifiers);
     }
 
     /// Returns the glyph index for the given Unicode code point. If this
@@ -470,7 +471,10 @@ pub const Face = struct {
     /// the faces with DeferredFaces and reload on demand. A Face can't be converted
     /// into a DeferredFace but a Face that comes from a DeferredFace can be
     /// deinitialized anytime and reloaded with the deferred face.
-    fn calcMetrics(face: freetype.Face) font.face.Metrics {
+    fn calcMetrics(
+        face: freetype.Face,
+        modifiers: ?*const font.face.Metrics.ModifierSet,
+    ) font.face.Metrics {
         const size_metrics = face.handle.*.size.*.metrics;
 
         // Cell width is calculated by preferring to use 'M' as the width of a
@@ -574,7 +578,7 @@ pub const Face = struct {
             .thickness = underline_thickness,
         };
 
-        const result = font.face.Metrics{
+        var result = font.face.Metrics{
             .cell_width = @intFromFloat(cell_width),
             .cell_height = @intFromFloat(cell_height),
             .cell_baseline = @intFromFloat(cell_baseline),
@@ -583,6 +587,7 @@ pub const Face = struct {
             .strikethrough_position = @intFromFloat(strikethrough.pos),
             .strikethrough_thickness = @intFromFloat(strikethrough.thickness),
         };
+        if (modifiers) |m| result.apply(m.*);
 
         // std.log.warn("font metrics={}", .{result});
 
@@ -607,7 +612,11 @@ test {
     var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
+    var ft_font = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    );
     defer ft_font.deinit();
 
     try testing.expectEqual(Presentation.text, ft_font.presentation);
@@ -623,7 +632,7 @@ test {
         const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
         try testing.expectEqual(@as(u32, 11), g1.height);
 
-        try ft_font.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
+        try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
         const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
         try testing.expectEqual(@as(u32, 21), g2.height);
     }
@@ -639,7 +648,11 @@ test "color emoji" {
     var atlas = try font.Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
+    var ft_font = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    );
     defer ft_font.deinit();
 
     try testing.expectEqual(Presentation.emoji, ft_font.presentation);
@@ -665,7 +678,11 @@ test "metrics" {
     var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12, .xdpi = 96, .ydpi = 96 });
+    var ft_font = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    );
     defer ft_font.deinit();
 
     try testing.expectEqual(font.face.Metrics{
@@ -679,7 +696,7 @@ test "metrics" {
     }, ft_font.metrics);
 
     // Resize should change metrics
-    try ft_font.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
+    try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
     try testing.expectEqual(font.face.Metrics{
         .cell_width = 16,
         .cell_height = 35,
@@ -701,7 +718,7 @@ test "mono to rgba" {
     var atlas = try font.Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .points = 12 });
+    var ft_font = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer ft_font.deinit();
 
     // glyph 3 is mono in Noto

commit 44a48f62f1f3888d9f91f5592effdfeed9041f9a
Author: Krzysztof Wolicki <der.teufel.mail@gmail.com>
Date:   Fri Nov 17 15:40:59 2023 +0100

    change unmodified `var`s to `const`s in anticipation of zig changes

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 66c27aa9..c8cc3806 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -389,7 +389,7 @@ pub const Face = struct {
 
             // If we need to copy the data, we copy it into a temporary buffer.
             const buffer = if (needs_copy) buffer: {
-                var temp = try alloc.alloc(u8, tgt_w * tgt_h * depth);
+                const temp = try alloc.alloc(u8, tgt_w * tgt_h * depth);
                 var dst_ptr = temp;
                 var src_ptr = bitmap.buffer;
                 var i: usize = 0;

commit 7f4088174718781727031d9b4d55f9c8fdd90e26
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Dec 2 09:39:45 2023 -0800

    font: faces use primary grid metrics to better line up glyphs
    
    Fixes #895
    
    Every loaded font face calculates metrics for itself. One of the
    important metrics is the baseline to "sit" the glyph on top of. Prior to
    this commit, each rasterized glyph would sit on its own calculated
    baseline. However, this leads to off-center rendering when the font
    being rasterized isn't the font that defines the terminal grid.
    
    This commit passes in the font metrics for the font defining the
    terminal grid to all font rasterization requests. This can then be used
    by non-primary fonts to sit the glyph according to the primary grid.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index c8cc3806..362588e3 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -226,6 +226,8 @@ pub const Face = struct {
         glyph_index: u32,
         opts: font.face.RenderOptions,
     ) !Glyph {
+        const metrics = opts.grid_metrics orelse self.metrics;
+
         // If our glyph has color, we want to render the color
         try self.face.loadGlyph(glyph_index, .{
             .render = true,
@@ -288,7 +290,7 @@ pub const Face = struct {
         // and copy the atlas.
         const bitmap_original = bitmap_converted orelse bitmap_ft;
         const bitmap_resized: ?freetype.c.struct_FT_Bitmap_ = resized: {
-            const max = opts.max_height orelse break :resized null;
+            const max = metrics.cell_height;
             const bm = bitmap_original;
             if (bm.rows <= max) break :resized null;
 
@@ -425,7 +427,7 @@ pub const Face = struct {
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intCast(self.metrics.cell_baseline));
+            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intCast(metrics.cell_baseline));
         };
 
         // log.warn("renderGlyph width={} height={} offset_x={} offset_y={} glyph_metrics={}", .{
@@ -662,7 +664,15 @@ test "color emoji" {
     // resize
     {
         const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{
-            .max_height = 24,
+            .grid_metrics = .{
+                .cell_width = 10,
+                .cell_height = 24,
+                .cell_baseline = 0,
+                .underline_position = 0,
+                .underline_thickness = 0,
+                .strikethrough_position = 0,
+                .strikethrough_thickness = 0,
+            },
         });
         try testing.expectEqual(@as(u32, 24), glyph.height);
     }

commit 481529393baee295b929f99c88fb83e58346102c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Dec 16 20:56:57 2023 -0800

    font: center text when adjust-cell-width is used
    
    Fixes #1086

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 362588e3..75ec3e4a 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -430,6 +430,21 @@ pub const Face = struct {
             break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intCast(metrics.cell_baseline));
         };
 
+        const offset_x: i32 = offset_x: {
+            var result: i32 = glyph_metrics.bitmap_left;
+
+            // If our cell was resized to be wider then we center our
+            // glyph in the cell.
+            if (metrics.original_cell_width) |original_width| {
+                if (original_width < metrics.cell_width) {
+                    const diff = (metrics.cell_width - original_width) / 2;
+                    result += @intCast(diff);
+                }
+            }
+
+            break :offset_x result;
+        };
+
         // log.warn("renderGlyph width={} height={} offset_x={} offset_y={} glyph_metrics={}", .{
         //     tgt_w,
         //     tgt_h,
@@ -442,7 +457,7 @@ pub const Face = struct {
         return Glyph{
             .width = tgt_w,
             .height = tgt_h,
-            .offset_x = glyph_metrics.bitmap_left,
+            .offset_x = offset_x,
             .offset_y = offset_y,
             .atlas_x = region.x,
             .atlas_y = region.y,

commit e4515d44c5cbc8ccd6e1fa64ae9f74152b8e1270
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 1 08:28:33 2024 -0800

    font/freetype: disallow bitmap strikes in scalable fonts
    
    Fixes #1421

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 75ec3e4a..f130b409 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -232,6 +232,11 @@ pub const Face = struct {
         try self.face.loadGlyph(glyph_index, .{
             .render = true,
             .color = self.face.hasColor(),
+
+            // Disable bitmap strikes for now since it causes issues with
+            // our cell metrics and rasterization. In the future, this is
+            // all fixable so we can enable it.
+            .no_bitmap = true,
         });
 
         const glyph = self.face.handle.*.glyph;

commit 61b964b9586e53fa8ec5896c8d03a6ae9a6cebe1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 1 08:40:18 2024 -0800

    font/freetype: enable bitmap loading for colored faces

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index f130b409..5a8c69df 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -236,7 +236,10 @@ pub const Face = struct {
             // Disable bitmap strikes for now since it causes issues with
             // our cell metrics and rasterization. In the future, this is
             // all fixable so we can enable it.
-            .no_bitmap = true,
+            //
+            // This must be enabled for color faces though because those are
+            // often colored bitmaps, which we support.
+            .no_bitmap = !self.face.hasColor(),
         });
 
         const glyph = self.face.handle.*.glyph;

commit 552c97eea4d2d0fdd33f14b0baf9ba15182117ef
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 27 20:45:55 2024 -0700

    font/freetype: avoid overflows with u8 font size

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 5a8c69df..d32217a0 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -137,7 +137,7 @@ pub const Face = struct {
         // to what the user requested. Otherwise, we can choose an arbitrary
         // pixel size.
         if (face.isScalable()) {
-            const size_26dot6 = @as(i32, @intCast(size.points << 6)); // mult by 64
+            const size_26dot6 = @as(i32, @intCast(size.points)) << 6; // mult by 64
             try face.setCharSize(0, size_26dot6, size.xdpi, size.ydpi);
         } else try selectSizeNearest(face, size.pixels());
     }

commit a9daba6d6d1beefaa4a74073c497192c26cea27c
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed May 8 14:56:38 2024 -0400

    fix freetype face size calculation

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d32217a0..2860503b 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -137,7 +137,7 @@ pub const Face = struct {
         // to what the user requested. Otherwise, we can choose an arbitrary
         // pixel size.
         if (face.isScalable()) {
-            const size_26dot6 = @as(i32, @intCast(size.points)) << 6; // mult by 64
+            const size_26dot6: i32 = @intFromFloat(@round(size.points * 64));
             try face.setCharSize(0, size_26dot6, size.xdpi, size.ydpi);
         } else try selectSizeNearest(face, size.pixels());
     }

commit 9f4d4d3c61a83b4e6443c4fe9c9a581f1de17868
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun May 26 10:17:20 2024 -0700

    font: treated fonts with mixed color/non-color glyphs as text
    
    Related to #1768 but doesn't fix it properly.
    
    This is a temporary hack to avoid some issues with fonts that have mixed
    color/non-color glyphs. If there are mixed presentations and the font
    does not have emoji codepoints, then we assume it is text. This fixes
    the typical scenarios.
    
    This is not a long term solution. A proper long term solution is to
    detect this scenario and on a per-glyph basis handle colorization (or
    the lack thereof) correctly. It looks like to do this we'll have to
    parse some font tables which is considerably more work so I wanted to do
    this first.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 2860503b..858f14fc 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -72,6 +72,12 @@ pub const Face = struct {
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
+        // See coretext.zig which has a similar check for this.
+        if (result.presentation == .emoji and result.glyphIndex('ðŸ¥¸') == null) {
+            log.warn("font has colorized glyphs but isn't emoji, treating as text", .{});
+            result.presentation = .text;
+        }
+
         // In debug mode, we output information about available variation axes,
         // if they exist.
         if (comptime builtin.mode == .Debug) mm: {

commit 8920f45fd88ccd6424cb6f46838ce11863316fa5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 09:48:01 2024 -0700

    font/freetype: API to load font table

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 858f14fc..33eca002 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -631,6 +631,11 @@ pub const Face = struct {
         const div = @as(f32, @floatFromInt(mul)) / 64;
         return @ceil(div);
     }
+
+    /// Copy the font table data for the given tag.
+    pub fn copyTable(self: Face, alloc: Allocator, tag: *const [4]u8) !?[]u8 {
+        return try self.face.loadSfntTable(alloc, freetype.Tag.init(tag));
+    }
 };
 
 test {
@@ -763,3 +768,19 @@ test "mono to rgba" {
     // glyph 3 is mono in Noto
     _ = try ft_font.renderGlyph(alloc, &atlas, 3, .{});
 }
+
+test "svg font table" {
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontJuliaMono;
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    defer face.deinit();
+
+    const table = (try face.copyTable(alloc, "SVG ")).?;
+    defer alloc.free(table);
+
+    try testing.expectEqual(430, table.len);
+}

commit 4daa49fe27c5aea0ebfec6fde757fa0e529760ec
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:25:49 2024 -0700

    font/freetype: update to new presentation APIs

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 33eca002..6037f6c0 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -15,7 +15,6 @@ const Allocator = std.mem.Allocator;
 const font = @import("../main.zig");
 const Glyph = font.Glyph;
 const Library = font.Library;
-const Presentation = font.Presentation;
 const convert = @import("freetype_convert.zig");
 const fastmem = @import("../../fastmem.zig");
 const quirks = @import("../../quirks.zig");
@@ -32,10 +31,6 @@ pub const Face = struct {
     /// Harfbuzz font corresponding to this face.
     hb_font: harfbuzz.Font,
 
-    /// The presentation for this font. This is a heuristic since fonts don't have
-    /// a way to declare this. We just assume a font with color is an emoji font.
-    presentation: Presentation,
-
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
@@ -67,17 +62,10 @@ pub const Face = struct {
             .lib = lib.lib,
             .face = face,
             .hb_font = hb_font,
-            .presentation = if (face.hasColor()) .emoji else .text,
             .metrics = calcMetrics(face, opts.metric_modifiers),
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
-        // See coretext.zig which has a similar check for this.
-        if (result.presentation == .emoji and result.glyphIndex('ðŸ¥¸') == null) {
-            log.warn("font has colorized glyphs but isn't emoji, treating as text", .{});
-            result.presentation = .text;
-        }
-
         // In debug mode, we output information about available variation axes,
         // if they exist.
         if (comptime builtin.mode == .Debug) mm: {
@@ -219,10 +207,29 @@ pub const Face = struct {
 
     /// Returns true if this font is colored. This can be used by callers to
     /// determine what kind of atlas to pass in.
-    fn hasColor(self: Face) bool {
+    pub fn hasColor(self: Face) bool {
         return self.face.hasColor();
     }
 
+    /// Returns true if the given glyph ID is colorized.
+    pub fn isColorGlyph(self: *const Face, glyph_id: u32) bool {
+        // sbix table is always true for now
+        if (self.face.hasSBIX()) return true;
+
+        // Otherwise, load the glyph and see what format it is in.
+        self.face.loadGlyph(glyph_id, .{
+            .render = true,
+            .color = self.face.hasColor(),
+            .no_bitmap = !self.face.hasColor(),
+        }) catch return false;
+
+        // If the glyph is SVG we assume colorized
+        const glyph = self.face.handle.*.glyph;
+        if (glyph.*.format == freetype.c.FT_GLYPH_FORMAT_SVG) return true;
+
+        return false;
+    }
+
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
     /// given texture atlas.
     pub fn renderGlyph(
@@ -655,8 +662,6 @@ test {
     );
     defer ft_font.deinit();
 
-    try testing.expectEqual(Presentation.text, ft_font.presentation);
-
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
@@ -691,8 +696,6 @@ test "color emoji" {
     );
     defer ft_font.deinit();
 
-    try testing.expectEqual(Presentation.emoji, ft_font.presentation);
-
     _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{});
 
     // resize

commit adaeffb2b53477ed8edfbf8cf9ff52cd0116e8a7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:40:46 2024 -0700

    font/freetype: CBDT/CBLC tables imply color

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 6037f6c0..346d8aa8 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -216,6 +216,11 @@ pub const Face = struct {
         // sbix table is always true for now
         if (self.face.hasSBIX()) return true;
 
+        // CBDT/CBLC tables always imply colorized glyphs.
+        // These are used by Noto.
+        if (self.face.hasSfntTable(freetype.Tag.init("CBDT"))) return true;
+        if (self.face.hasSfntTable(freetype.Tag.init("CBLC"))) return true;
+
         // Otherwise, load the glyph and see what format it is in.
         self.face.loadGlyph(glyph_id, .{
             .render = true,
@@ -698,6 +703,13 @@ test "color emoji" {
 
     _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{});
 
+    // Make sure this glyph has color
+    {
+        try testing.expect(ft_font.hasColor());
+        const glyph_id = ft_font.glyphIndex('ðŸ¥¸').?;
+        try testing.expect(ft_font.isColorGlyph(glyph_id));
+    }
+
     // resize
     {
         const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{

commit 10b8ca3c694aa5e0b5cf7eaaae79a4990e3774c3
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Aug 11 18:02:12 2024 -0400

    spelling: normalize grey -> gray

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 346d8aa8..a182f165 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -281,7 +281,7 @@ pub const Face = struct {
         // conversion.
         const format: ?font.Atlas.Format = switch (bitmap_ft.pixel_mode) {
             freetype.c.FT_PIXEL_MODE_MONO => null,
-            freetype.c.FT_PIXEL_MODE_GRAY => .greyscale,
+            freetype.c.FT_PIXEL_MODE_GRAY => .grayscale,
             freetype.c.FT_PIXEL_MODE_BGRA => .rgba,
             else => {
                 log.warn("glyph={} pixel mode={}", .{ glyph_index, bitmap_ft.pixel_mode });
@@ -657,7 +657,7 @@ test {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(
@@ -734,7 +734,7 @@ test "metrics" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     var ft_font = try Face.init(

commit 5f0daa23b9d9329ba053f9a328d6254191dc9e49
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 24 20:51:26 2024 -0700

    font/freetype: synthetic italic

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index a182f165..d1e37564 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -37,6 +37,17 @@ pub const Face = struct {
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
+    /// Set to true to apply a synthetic italic to the face.
+    synthetic_italic: bool = false,
+
+    /// The matrix applied to a regular font to create a synthetic italic.
+    const italic_matrix: freetype.c.FT_Matrix = .{
+        .xx = 0x10000,
+        .xy = 0x044ED, // approx. tan(15)
+        .yx = 0,
+        .yy = 0x10000,
+    };
+
     /// Initialize a new font face with the given source in-memory.
     pub fn initFile(lib: Library, path: [:0]const u8, index: i32, opts: font.face.Options) !Face {
         const face = try lib.lib.initFace(path, index);
@@ -119,6 +130,24 @@ pub const Face = struct {
         return "";
     }
 
+    /// Return a new face that is the same as this but has a transformation
+    /// matrix applied to italicize it.
+    pub fn syntheticItalic(self: *const Face, opts: font.face.Options) !Face {
+        // Increase face ref count
+        self.face.ref();
+        errdefer self.face.deinit();
+
+        var f = try initFace(
+            .{ .lib = self.lib },
+            self.face,
+            opts,
+        );
+        errdefer f.deinit();
+        f.synthetic_italic = true;
+
+        return f;
+    }
+
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, opts: font.face.Options) !void {
@@ -246,6 +275,12 @@ pub const Face = struct {
     ) !Glyph {
         const metrics = opts.grid_metrics orelse self.metrics;
 
+        // If we have synthetic italic, then we apply a transformation matrix.
+        // We have to undo this because synthetic italic works by increasing
+        // the ref count of the base face.
+        if (self.synthetic_italic) self.face.setTransform(&italic_matrix, null);
+        defer if (self.synthetic_italic) self.face.setTransform(null, null);
+
         // If our glyph has color, we want to render the color
         try self.face.loadGlyph(glyph_index, .{
             .render = true,
@@ -265,7 +300,7 @@ pub const Face = struct {
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        if (bitmap_ft.rows == 0) return Glyph{
+        if (bitmap_ft.rows == 0) return .{
             .width = 0,
             .height = 0,
             .offset_x = 0,

commit 915ec029eefe2512c781855a8ebf79f2b4cc6f61
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 25 09:43:54 2024 -0700

    font/freetype: synthetic bold

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d1e37564..5004a040 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -38,7 +38,10 @@ pub const Face = struct {
     quirks_disable_default_font_features: bool = false,
 
     /// Set to true to apply a synthetic italic to the face.
-    synthetic_italic: bool = false,
+    synthetic: packed struct {
+        italic: bool = false,
+        bold: bool = false,
+    } = .{},
 
     /// The matrix applied to a regular font to create a synthetic italic.
     const italic_matrix: freetype.c.FT_Matrix = .{
@@ -130,6 +133,25 @@ pub const Face = struct {
         return "";
     }
 
+    /// Return a new face that is the same as this but also has synthetic
+    /// bold applied.
+    pub fn syntheticBold(self: *const Face, opts: font.face.Options) !Face {
+        // Increase face ref count
+        self.face.ref();
+        errdefer self.face.deinit();
+
+        var f = try initFace(
+            .{ .lib = self.lib },
+            self.face,
+            opts,
+        );
+        errdefer f.deinit();
+        f.synthetic = self.synthetic;
+        f.synthetic.bold = true;
+
+        return f;
+    }
+
     /// Return a new face that is the same as this but has a transformation
     /// matrix applied to italicize it.
     pub fn syntheticItalic(self: *const Face, opts: font.face.Options) !Face {
@@ -143,7 +165,8 @@ pub const Face = struct {
             opts,
         );
         errdefer f.deinit();
-        f.synthetic_italic = true;
+        f.synthetic = self.synthetic;
+        f.synthetic.italic = true;
 
         return f;
     }
@@ -278,14 +301,17 @@ pub const Face = struct {
         // If we have synthetic italic, then we apply a transformation matrix.
         // We have to undo this because synthetic italic works by increasing
         // the ref count of the base face.
-        if (self.synthetic_italic) self.face.setTransform(&italic_matrix, null);
-        defer if (self.synthetic_italic) self.face.setTransform(null, null);
+        if (self.synthetic.italic) self.face.setTransform(&italic_matrix, null);
+        defer if (self.synthetic.italic) self.face.setTransform(null, null);
 
         // If our glyph has color, we want to render the color
         try self.face.loadGlyph(glyph_index, .{
-            .render = true,
             .color = self.face.hasColor(),
 
+            // If we have synthetic bold, we have to set some additional
+            // glyph properties before render so we don't render here.
+            .render = !self.synthetic.bold,
+
             // Disable bitmap strikes for now since it causes issues with
             // our cell metrics and rasterization. In the future, this is
             // all fixable so we can enable it.
@@ -294,12 +320,23 @@ pub const Face = struct {
             // often colored bitmaps, which we support.
             .no_bitmap = !self.face.hasColor(),
         });
-
         const glyph = self.face.handle.*.glyph;
-        const bitmap_ft = glyph.*.bitmap;
+
+        // For synthetic bold, we embolden the glyph and render it.
+        if (self.synthetic.bold) {
+            // We need to scale the embolden amount based on the font size.
+            // This is a heuristic I found worked well across a variety of
+            // founts: 1 pixel per 64 units of height.
+            const height: f64 = @floatFromInt(self.face.handle.*.size.*.metrics.height);
+            const ratio: f64 = 64.0 / 2048.0;
+            const amount = @ceil(height * ratio);
+            _ = freetype.c.FT_Outline_Embolden(&glyph.*.outline, @intFromFloat(amount));
+            try self.face.renderGlyph(.normal);
+        }
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
+        const bitmap_ft = glyph.*.bitmap;
         if (bitmap_ft.rows == 0) return .{
             .width = 0,
             .height = 0,

commit c7d6227befef09a607b4b1c3858902c3a02eaf85
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 19:18:44 2024 -0600

    freetype: improve strikethrough position guess by using ex height

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 5004a040..04f037c8 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -607,6 +607,20 @@ pub const Face = struct {
             break :cell_width f26dot6ToFloat(size_metrics.max_advance);
         };
 
+        // Ex height is calculated by measuring the height of the `x` glyph.
+        // If that fails then we just pretend it's 65% of the ascent height.
+        const ex_height: f32 = ex_height: {
+            if (face.getCharIndex('x')) |glyph_index| {
+                if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                    break :ex_height f26dot6ToFloat(face.handle.*.glyph.*.metrics.height);
+                } else |_| {
+                    // Ignore the error since we just fall back to 65% of the ascent below
+                }
+            }
+
+            break :ex_height f26dot6ToFloat(size_metrics.ascender) * 0.65;
+        };
+
         // Cell height is calculated as the maximum of multiple things in order
         // to handle edge cases in fonts: (1) the height as reported in metadata
         // by the font designer (2) the maximum glyph height as measured in the
@@ -689,7 +703,9 @@ pub const Face = struct {
             },
             .thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize)),
         } else .{
-            .pos = cell_baseline * 0.6,
+            // Exactly 50% of the ex height so that our strikethrough is
+            // centered through lowercase text. This is a common choice.
+            .pos = cell_baseline - ex_height * 0.5 + 1,
             .thickness = underline_thickness,
         };
 

commit 7a1d304fa91ddd6961c0973be3a6ea2d99fb6538
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 22:10:43 2024 -0600

    font: further improve ul/st position calculations

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 04f037c8..32664a1f 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -660,52 +660,50 @@ pub const Face = struct {
         // is reversed.
         const cell_baseline = -1 * f26dot6ToFloat(size_metrics.descender);
 
+        const underline_thickness = @max(@as(f32, 1), fontUnitsToPxY(
+            face,
+            face.handle.*.underline_thickness,
+        ));
+
         // The underline position. This is a value from the top where the
         // underline should go.
         const underline_position: f32 = underline_pos: {
-            // The ascender is already scaled for scalable fonts, but the
-            // underline position is not.
-            const ascender_px = @as(i32, @intCast(size_metrics.ascender)) >> 6;
-            const declared_px = freetype.mulFix(
+            const declared_px = @as(f32, @floatFromInt(freetype.mulFix(
                 face.handle.*.underline_position,
                 @intCast(face.handle.*.size.*.metrics.y_scale),
-            ) >> 6;
+            ))) / 64;
 
             // We use the declared underline position if its available
-            const declared = ascender_px - declared_px;
+            const declared = cell_height - cell_baseline - declared_px;
             if (declared > 0)
-                break :underline_pos @floatFromInt(declared);
+                break :underline_pos declared;
 
             // If we have no declared underline position, we go slightly under the
             // cell height (mainly: non-scalable fonts, i.e. emoji)
             break :underline_pos cell_height - 1;
         };
-        const underline_thickness = @max(@as(f32, 1), fontUnitsToPxY(
-            face,
-            face.handle.*.underline_thickness,
-        ));
 
         // The strikethrough position. We use the position provided by the
         // font if it exists otherwise we calculate a best guess.
         const strikethrough: struct {
             pos: f32,
             thickness: f32,
-        } = if (face.getSfntTable(.os2)) |os2| .{
-            .pos = pos: {
-                // Ascender is scaled, strikeout pos is not
-                const ascender_px = @as(i32, @intCast(size_metrics.ascender)) >> 6;
-                const declared_px = freetype.mulFix(
-                    os2.yStrikeoutPosition,
-                    @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)),
-                ) >> 6;
-
-                break :pos @floatFromInt(ascender_px - declared_px);
-            },
-            .thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize)),
+        } = if (face.getSfntTable(.os2)) |os2| st: {
+            const thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize));
+
+            const pos = @as(f32, @floatFromInt(freetype.mulFix(
+                os2.yStrikeoutPosition,
+                @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)),
+            ))) / 64;
+
+            break :st .{
+                .pos = @ceil(cell_height - cell_baseline - pos + thickness + 1),
+                .thickness = thickness,
+            };
         } else .{
             // Exactly 50% of the ex height so that our strikethrough is
             // centered through lowercase text. This is a common choice.
-            .pos = cell_baseline - ex_height * 0.5 + 1,
+            .pos = @ceil(cell_height - cell_baseline - ex_height * 0.5 + underline_thickness),
             .thickness = underline_thickness,
         };
 

commit ac68686036012ad851367946baa884b8fd87be48
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 22:30:59 2024 -0600

    freetype: fix underline position calculation

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 32664a1f..f764ac61 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -668,13 +668,18 @@ pub const Face = struct {
         // The underline position. This is a value from the top where the
         // underline should go.
         const underline_position: f32 = underline_pos: {
+            // From the FreeType docs:
+            // > `underline_position`
+            // > The position, in font units, of the underline line for
+            // > this face. It is the center of the underlining stem.
+
             const declared_px = @as(f32, @floatFromInt(freetype.mulFix(
                 face.handle.*.underline_position,
                 @intCast(face.handle.*.size.*.metrics.y_scale),
             ))) / 64;
 
             // We use the declared underline position if its available
-            const declared = cell_height - cell_baseline - declared_px;
+            const declared = @ceil(cell_height - cell_baseline - declared_px - underline_thickness * 0.5 + 1);
             if (declared > 0)
                 break :underline_pos declared;
 

commit 003b100707a7125f1e84ce44b42e0b1bd8b3484d
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Sep 25 12:01:24 2024 -0600

    font: remove fudge factors in ul and st position calculations
    
    These were present because of an incorrect calculation in the underline
    sprite renderer, and are no longer necessary.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index f764ac61..dae46d6d 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -678,8 +678,8 @@ pub const Face = struct {
                 @intCast(face.handle.*.size.*.metrics.y_scale),
             ))) / 64;
 
-            // We use the declared underline position if its available
-            const declared = @ceil(cell_height - cell_baseline - declared_px - underline_thickness * 0.5 + 1);
+            // We use the declared underline position if its available.
+            const declared = @ceil(cell_height - cell_baseline - declared_px - underline_thickness * 0.5);
             if (declared > 0)
                 break :underline_pos declared;
 
@@ -702,13 +702,13 @@ pub const Face = struct {
             ))) / 64;
 
             break :st .{
-                .pos = @ceil(cell_height - cell_baseline - pos + thickness + 1),
+                .pos = @ceil(cell_height - cell_baseline - pos),
                 .thickness = thickness,
             };
         } else .{
             // Exactly 50% of the ex height so that our strikethrough is
             // centered through lowercase text. This is a common choice.
-            .pos = @ceil(cell_height - cell_baseline - ex_height * 0.5 + underline_thickness),
+            .pos = @ceil(cell_height - cell_baseline - ex_height * 0.5 - underline_thickness * 0.5),
             .thickness = underline_thickness,
         };
 

commit a0f017d6fdad3cf5ec4952498d7f09b12b997132
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Sep 25 12:11:04 2024 -0600

    freetype: update expected ul pos in tests to account for removed fudge factor

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index dae46d6d..3ff9e9ff 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -851,7 +851,7 @@ test "metrics" {
         .cell_width = 16,
         .cell_height = 35,
         .cell_baseline = 7,
-        .underline_position = 36,
+        .underline_position = 35,
         .underline_thickness = 2,
         .strikethrough_position = 20,
         .strikethrough_thickness = 2,

commit be3ae56bc8cdd8c6b15c3bcd885d572300b28953
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 2 14:45:34 2024 -0700

    font: add stylistic variants for built-in font, fix naming convention
    
    Fixes #2364
    
    This adds the bold, italic, and bold italic variants of JB Mono so it is
    built-in. This also fixes up the naming convention for the embedded font
    files across tests and removes redundant embedded font files.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 3ff9e9ff..7bb9ecba 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -742,7 +742,7 @@ pub const Face = struct {
 };
 
 test {
-    const testFont = @import("../test.zig").fontRegular;
+    const testFont = font.embedded.inconsolata;
     const alloc = testing.allocator;
 
     var lib = try Library.init();
@@ -771,13 +771,13 @@ test {
 
         try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
         const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
-        try testing.expectEqual(@as(u32, 21), g2.height);
+        try testing.expectEqual(@as(u32, 20), g2.height);
     }
 }
 
 test "color emoji" {
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontEmoji;
+    const testFont = font.embedded.emoji;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -819,7 +819,7 @@ test "color emoji" {
 }
 
 test "metrics" {
-    const testFont = @import("../test.zig").fontRegular;
+    const testFont = font.embedded.inconsolata;
     const alloc = testing.allocator;
 
     var lib = try Library.init();
@@ -860,7 +860,7 @@ test "metrics" {
 
 test "mono to rgba" {
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontEmoji;
+    const testFont = font.embedded.emoji;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -877,7 +877,7 @@ test "mono to rgba" {
 
 test "svg font table" {
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontJuliaMono;
+    const testFont = font.embedded.julia_mono;
 
     var lib = try font.Library.init();
     defer lib.deinit();

commit 74bda5a6ebd14d5a9d6891f3fc21953879a36d16
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Fri Nov 8 20:26:21 2024 +0100

    feat: implement configurable freetype load flags

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 7bb9ecba..e3ad5322 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -318,7 +318,13 @@ pub const Face = struct {
             //
             // This must be enabled for color faces though because those are
             // often colored bitmaps, which we support.
-            .no_bitmap = !self.face.hasColor(),
+            .no_bitmap = !self.face.hasColor() or !opts.load_flags.bitmap,
+
+            // use options from config
+            .no_hinting = !opts.load_flags.hinting,
+            .force_autohint = !opts.load_flags.@"force-autohint",
+            .monochrome = !opts.load_flags.monochrome,
+            .no_autohint = !opts.load_flags.autohint,
         });
         const glyph = self.face.handle.*.glyph;
 

commit 945a715b08d9955b759e06f0c7ce6726d4e2604f
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 00:41:55 2024 +0100

    refactor: handle freetype load flags in face instead of renderer

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index e3ad5322..ac173d6d 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -18,6 +18,7 @@ const Library = font.Library;
 const convert = @import("freetype_convert.zig");
 const fastmem = @import("../../fastmem.zig");
 const quirks = @import("../../quirks.zig");
+const FreetypeLoadFlags = @import("../../config/Config.zig").FreetypeLoadFlags;
 
 const log = std.log.scoped(.font_face);
 
@@ -34,6 +35,9 @@ pub const Face = struct {
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
+    /// Metrics for this font face. These are useful for renderers.
+    load_flags: FreetypeLoadFlags,
+
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
@@ -77,6 +81,7 @@ pub const Face = struct {
             .face = face,
             .hb_font = hb_font,
             .metrics = calcMetrics(face, opts.metric_modifiers),
+            .load_flags = opts.freetype_load_flags,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
@@ -318,13 +323,13 @@ pub const Face = struct {
             //
             // This must be enabled for color faces though because those are
             // often colored bitmaps, which we support.
-            .no_bitmap = !self.face.hasColor() or !opts.load_flags.bitmap,
+            .no_bitmap = !self.face.hasColor() or !self.load_flags.bitmap,
 
             // use options from config
-            .no_hinting = !opts.load_flags.hinting,
-            .force_autohint = !opts.load_flags.@"force-autohint",
-            .monochrome = !opts.load_flags.monochrome,
-            .no_autohint = !opts.load_flags.autohint,
+            .no_hinting = !self.load_flags.hinting,
+            .force_autohint = !self.load_flags.@"force-autohint",
+            .monochrome = !self.load_flags.monochrome,
+            .no_autohint = !self.load_flags.autohint,
         });
         const glyph = self.face.handle.*.glyph;
 

commit c0b24ee60d65bee135dea7c99ad9446e9649a574
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 01:35:39 2024 +0100

    refactor: make freetype flags void for non-freetype backend
    
    This is an attempt to use `void` as type for Freetype Load Flags when
    backend does not use these flags.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index ac173d6d..2715d664 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -18,7 +18,7 @@ const Library = font.Library;
 const convert = @import("freetype_convert.zig");
 const fastmem = @import("../../fastmem.zig");
 const quirks = @import("../../quirks.zig");
-const FreetypeLoadFlags = @import("../../config/Config.zig").FreetypeLoadFlags;
+const config = @import("../../config.zig");
 
 const log = std.log.scoped(.font_face);
 
@@ -36,7 +36,7 @@ pub const Face = struct {
     metrics: font.face.Metrics,
 
     /// Metrics for this font face. These are useful for renderers.
-    load_flags: FreetypeLoadFlags,
+    load_flags: config.FreetypeLoadFlags,
 
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,

commit e7f286d83fc5d43be519abd0e21a03fadb43377f
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 01:40:39 2024 +0100

    docs: describe `load_flags` field in `Face` struct

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 2715d664..5bbbb246 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -35,7 +35,7 @@ pub const Face = struct {
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
-    /// Metrics for this font face. These are useful for renderers.
+    /// Freetype load flags for this font face.
     load_flags: config.FreetypeLoadFlags,
 
     /// Set quirks.disableDefaultFontFeatures

commit 83c4d0077b7a06d487057fca3bddcc8a3685ed03
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 11:55:29 2024 +0100

    refactor: define `FreetypeLoadFlags` struct and default in `font.face`

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 5bbbb246..8a1465d7 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -36,7 +36,7 @@ pub const Face = struct {
     metrics: font.face.Metrics,
 
     /// Freetype load flags for this font face.
-    load_flags: config.FreetypeLoadFlags,
+    load_flags: font.face.FreetypeLoadFlags,
 
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,

commit 3ee6577154b8b78e4113dbaec4c153ee1535e073
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 9 09:37:03 2024 -0800

    some tweaks

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 8a1465d7..683f80cc 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -23,6 +23,11 @@ const config = @import("../../config.zig");
 const log = std.log.scoped(.font_face);
 
 pub const Face = struct {
+    comptime {
+        // If we have the freetype backend, we should have load flags.
+        assert(font.face.FreetypeLoadFlags != void);
+    }
+
     /// Our freetype library
     lib: freetype.Library,
 
@@ -323,7 +328,7 @@ pub const Face = struct {
             //
             // This must be enabled for color faces though because those are
             // often colored bitmaps, which we support.
-            .no_bitmap = !self.face.hasColor() or !self.load_flags.bitmap,
+            .no_bitmap = !self.face.hasColor(),
 
             // use options from config
             .no_hinting = !self.load_flags.hinting,

commit bd1845231011d2b445a78bef07a5b54f0b077479
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Dec 11 16:30:40 2024 -0500

    font: unify metrics calculations & separate sprite metrics
    
    Unify grid metrics calculations by relying on shared logic mostly based
    on values directly from the font tables, this deduplicates a lot of code
    and gives us more control over how we interpret various metrics.
    
    Also separate metrics for underlined, strikethrough, and overline
    thickness and position, and box drawing thickness, so that they can
    individually be adjusted as the user desires.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 683f80cc..d7fb2e4a 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -16,6 +16,7 @@ const font = @import("../main.zig");
 const Glyph = font.Glyph;
 const Library = font.Library;
 const convert = @import("freetype_convert.zig");
+const opentype = @import("../opentype.zig");
 const fastmem = @import("../../fastmem.zig");
 const quirks = @import("../../quirks.zig");
 const config = @import("../../config.zig");
@@ -85,7 +86,7 @@ pub const Face = struct {
             .lib = lib.lib,
             .face = face,
             .hb_font = hb_font,
-            .metrics = calcMetrics(face, opts.metric_modifiers),
+            .metrics = try calcMetrics(face, opts.metric_modifiers),
             .load_flags = opts.freetype_load_flags,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
@@ -185,7 +186,7 @@ pub const Face = struct {
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, opts: font.face.Options) !void {
         try setSize_(self.face, opts.size);
-        self.metrics = calcMetrics(self.face, opts.metric_modifiers);
+        self.metrics = try calcMetrics(self.face, opts.metric_modifiers);
     }
 
     fn setSize_(face: freetype.Face, size: font.face.DesiredSize) !void {
@@ -258,7 +259,7 @@ pub const Face = struct {
         try self.face.setVarDesignCoordinates(coords);
 
         // We need to recalculate font metrics which may have changed.
-        self.metrics = calcMetrics(self.face, opts.metric_modifiers);
+        self.metrics = try calcMetrics(self.face, opts.metric_modifiers);
     }
 
     /// Returns the glyph index for the given Unicode code point. If this
@@ -593,6 +594,10 @@ pub const Face = struct {
         return @floatFromInt(v >> 6);
     }
 
+    fn f26dot6ToF64(v: freetype.c.FT_F26Dot6) f64 {
+        return @as(opentype.sfnt.F26Dot6, @bitCast(@as(u32, @intCast(v)))).to(f64);
+    }
+
     /// Calculate the metrics associated with a face. This is not public because
     /// the metrics are calculated for every face and cached since they're
     /// frequently required for renderers and take up next to little memory space
@@ -605,138 +610,136 @@ pub const Face = struct {
     fn calcMetrics(
         face: freetype.Face,
         modifiers: ?*const font.face.Metrics.ModifierSet,
-    ) font.face.Metrics {
+    ) !font.face.Metrics {
         const size_metrics = face.handle.*.size.*.metrics;
 
-        // Cell width is calculated by preferring to use 'M' as the width of a
-        // cell since 'M' is generally the widest ASCII character. If loading 'M'
-        // fails then we use the max advance of the font face size metrics.
-        const cell_width: f32 = cell_width: {
-            if (face.getCharIndex('M')) |glyph_index| {
-                if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                    break :cell_width f26dot6ToFloat(face.handle.*.glyph.*.advance.x);
-                } else |_| {
-                    // Ignore the error since we just fall back to max_advance below
+        // This code relies on this assumption, and it should always be
+        // true since we don't do any non-uniform scaling on the font ever.
+        assert(size_metrics.x_ppem == size_metrics.y_ppem);
+
+        // Read the 'head' table out of the font data.
+        const head = face.getSfntTable(.head) orelse return error.CannotGetTable;
+
+        // Read the 'post' table out of the font data.
+        const post = face.getSfntTable(.post) orelse return error.CannotGetTable;
+
+        // Read the 'OS/2' table out of the font data.
+        const os2 = face.getSfntTable(.os2) orelse return error.CannotGetTable;
+
+        // Some fonts don't actually have an OS/2 table, which
+        // we need in order to do the metrics calculations, in
+        // such cases FreeType sets the version to 0xFFFF
+        if (os2.version == 0xFFFF) return error.MissingTable;
+
+        const units_per_em = head.Units_Per_EM;
+        const px_per_em: f64 = @floatFromInt(size_metrics.y_ppem);
+        const px_per_unit = px_per_em / @as(f64, @floatFromInt(units_per_em));
+
+        const ascent = @as(f64, @floatFromInt(os2.sTypoAscender)) * px_per_unit;
+        const descent = @as(f64, @floatFromInt(os2.sTypoDescender)) * px_per_unit;
+        const line_gap = @as(f64, @floatFromInt(os2.sTypoLineGap)) * px_per_unit;
+
+        // Some fonts have degenerate 'post' tables where the underline
+        // thickness (and often position) are 0. We consider them null
+        // if this is the case and use our own fallbacks when we calculate.
+        const has_broken_underline = post.underlineThickness == 0;
+
+        // If the underline position isn't 0 then we do use it,
+        // even if the thickness is't properly specified.
+        const underline_position = if (has_broken_underline and post.underlinePosition == 0)
+            null
+        else
+            @as(f64, @floatFromInt(post.underlinePosition)) * px_per_unit;
+
+        const underline_thickness = if (has_broken_underline)
+            null
+        else
+            @as(f64, @floatFromInt(post.underlineThickness)) * px_per_unit;
+
+        // Similar logic to the underline above.
+        const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+
+        const strikethrough_position = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+            null
+        else
+            @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+
+        const strikethrough_thickness = if (has_broken_strikethrough)
+            null
+        else
+            @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+
+        // Cell width is calculated by calculating the widest width of the
+        // visible ASCII characters. Usually 'M' is widest but we just take
+        // whatever is widest.
+        //
+        // If we fail to load any visible ASCII we just use max_advance from
+        // the metrics provided by FreeType.
+        const cell_width: f64 = cell_width: {
+            var c: u8 = ' ';
+            while (c < 127) : (c += 1) {
+                if (face.getCharIndex(c)) |glyph_index| {
+                    if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                        break :cell_width f26dot6ToF64(face.handle.*.glyph.*.advance.x);
+                    } else |_| {
+                        // Ignore the error since we just fall back to max_advance below
+                    }
                 }
             }
 
-            break :cell_width f26dot6ToFloat(size_metrics.max_advance);
+            break :cell_width f26dot6ToF64(size_metrics.max_advance);
         };
 
-        // Ex height is calculated by measuring the height of the `x` glyph.
-        // If that fails then we just pretend it's 65% of the ascent height.
-        const ex_height: f32 = ex_height: {
+        // The OS/2 table does not include sCapHeight or sxHeight in version 1.
+        const has_os2_height_metrics = os2.version >= 2;
+
+        // We use the cap height specified by the font if it's
+        // available, otherwise we try to measure the `H` glyph.
+        const cap_height: ?f64 = cap_height: {
+            if (has_os2_height_metrics) {
+                break :cap_height @as(f64, @floatFromInt(os2.sCapHeight)) * px_per_unit;
+            }
+            if (face.getCharIndex('H')) |glyph_index| {
+                if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                    break :cap_height f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
+                } else |_| {}
+            }
+
+            break :cap_height null;
+        };
+
+        // We use the ex height specified by the font if it's
+        // available, otherwise we try to measure the `x` glyph.
+        const ex_height: ?f64 = ex_height: {
+            if (has_os2_height_metrics) {
+                break :ex_height @as(f64, @floatFromInt(os2.sxHeight)) * px_per_unit;
+            }
             if (face.getCharIndex('x')) |glyph_index| {
                 if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                    break :ex_height f26dot6ToFloat(face.handle.*.glyph.*.metrics.height);
-                } else |_| {
-                    // Ignore the error since we just fall back to 65% of the ascent below
-                }
+                    break :ex_height f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
+                } else |_| {}
             }
 
-            break :ex_height f26dot6ToFloat(size_metrics.ascender) * 0.65;
+            break :ex_height null;
         };
 
-        // Cell height is calculated as the maximum of multiple things in order
-        // to handle edge cases in fonts: (1) the height as reported in metadata
-        // by the font designer (2) the maximum glyph height as measured in the
-        // font and (3) the height from the ascender to an underscore.
-        const cell_height: f32 = cell_height: {
-            // The height as reported by the font designer.
-            const face_height = f26dot6ToFloat(size_metrics.height);
-
-            // The maximum height a glyph can take in the font
-            const max_glyph_height = f26dot6ToFloat(size_metrics.ascender) -
-                f26dot6ToFloat(size_metrics.descender);
-
-            // The height of the underscore character
-            const underscore_height = underscore: {
-                if (face.getCharIndex('_')) |glyph_index| {
-                    if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                        var res: f32 = f26dot6ToFloat(size_metrics.ascender);
-                        res -= @floatFromInt(face.handle.*.glyph.*.bitmap_top);
-                        res += @floatFromInt(face.handle.*.glyph.*.bitmap.rows);
-                        break :underscore res;
-                    } else |_| {
-                        // Ignore the error since we just fall back below
-                    }
-                }
+        var result = font.face.Metrics.calc(.{
+            .cell_width = cell_width,
 
-                break :underscore 0;
-            };
+            .ascent = ascent,
+            .descent = descent,
+            .line_gap = line_gap,
 
-            break :cell_height @max(
-                face_height,
-                @max(max_glyph_height, underscore_height),
-            );
-        };
+            .underline_position = underline_position,
+            .underline_thickness = underline_thickness,
 
-        // The baseline is the descender amount for the font. This is the maximum
-        // that a font may go down. We switch signs because our coordinate system
-        // is reversed.
-        const cell_baseline = -1 * f26dot6ToFloat(size_metrics.descender);
-
-        const underline_thickness = @max(@as(f32, 1), fontUnitsToPxY(
-            face,
-            face.handle.*.underline_thickness,
-        ));
-
-        // The underline position. This is a value from the top where the
-        // underline should go.
-        const underline_position: f32 = underline_pos: {
-            // From the FreeType docs:
-            // > `underline_position`
-            // > The position, in font units, of the underline line for
-            // > this face. It is the center of the underlining stem.
-
-            const declared_px = @as(f32, @floatFromInt(freetype.mulFix(
-                face.handle.*.underline_position,
-                @intCast(face.handle.*.size.*.metrics.y_scale),
-            ))) / 64;
-
-            // We use the declared underline position if its available.
-            const declared = @ceil(cell_height - cell_baseline - declared_px - underline_thickness * 0.5);
-            if (declared > 0)
-                break :underline_pos declared;
-
-            // If we have no declared underline position, we go slightly under the
-            // cell height (mainly: non-scalable fonts, i.e. emoji)
-            break :underline_pos cell_height - 1;
-        };
+            .strikethrough_position = strikethrough_position,
+            .strikethrough_thickness = strikethrough_thickness,
 
-        // The strikethrough position. We use the position provided by the
-        // font if it exists otherwise we calculate a best guess.
-        const strikethrough: struct {
-            pos: f32,
-            thickness: f32,
-        } = if (face.getSfntTable(.os2)) |os2| st: {
-            const thickness = @max(@as(f32, 1), fontUnitsToPxY(face, os2.yStrikeoutSize));
-
-            const pos = @as(f32, @floatFromInt(freetype.mulFix(
-                os2.yStrikeoutPosition,
-                @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)),
-            ))) / 64;
-
-            break :st .{
-                .pos = @ceil(cell_height - cell_baseline - pos),
-                .thickness = thickness,
-            };
-        } else .{
-            // Exactly 50% of the ex height so that our strikethrough is
-            // centered through lowercase text. This is a common choice.
-            .pos = @ceil(cell_height - cell_baseline - ex_height * 0.5 - underline_thickness * 0.5),
-            .thickness = underline_thickness,
-        };
+            .cap_height = cap_height,
+            .ex_height = ex_height,
+        });
 
-        var result = font.face.Metrics{
-            .cell_width = @intFromFloat(cell_width),
-            .cell_height = @intFromFloat(cell_height),
-            .cell_baseline = @intFromFloat(cell_baseline),
-            .underline_position = @intFromFloat(underline_position),
-            .underline_thickness = @intFromFloat(underline_thickness),
-            .strikethrough_position = @intFromFloat(strikethrough.pos),
-            .strikethrough_thickness = @intFromFloat(strikethrough.thickness),
-        };
         if (modifiers) |m| result.apply(m.*);
 
         // std.log.warn("font metrics={}", .{result});
@@ -744,13 +747,6 @@ pub const Face = struct {
         return result;
     }
 
-    /// Convert freetype "font units" to pixels using the Y scale.
-    fn fontUnitsToPxY(face: freetype.Face, x: i32) f32 {
-        const mul = freetype.mulFix(x, @as(i32, @intCast(face.handle.*.size.*.metrics.y_scale)));
-        const div = @as(f32, @floatFromInt(mul)) / 64;
-        return @ceil(div);
-    }
-
     /// Copy the font table data for the given tag.
     pub fn copyTable(self: Face, alloc: Allocator, tag: *const [4]u8) !?[]u8 {
         return try self.face.loadSfntTable(alloc, freetype.Tag.init(tag));
@@ -828,6 +824,9 @@ test "color emoji" {
                 .underline_thickness = 0,
                 .strikethrough_position = 0,
                 .strikethrough_thickness = 0,
+                .overline_position = 0,
+                .overline_thickness = 0,
+                .box_thickness = 0,
             },
         });
         try testing.expectEqual(@as(u32, 24), glyph.height);
@@ -853,24 +852,42 @@ test "metrics" {
 
     try testing.expectEqual(font.face.Metrics{
         .cell_width = 8,
-        .cell_height = 1.8e1,
-        .cell_baseline = 4,
-        .underline_position = 18,
+        // The cell height is 17 px because the calculation is
+        //
+        //  ascender - descender + gap
+        //
+        // which, for inconsolata is
+        //
+        //  859 - -190 + 0
+        //
+        // font units, at 1000 units per em that works out to 1.049 em,
+        // and 1em should be the point size * dpi scale, so 12 * (96/72)
+        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
+        // to 17.
+        .cell_height = 17,
+        .cell_baseline = 3,
+        .underline_position = 17,
         .underline_thickness = 1,
         .strikethrough_position = 10,
         .strikethrough_thickness = 1,
+        .overline_position = 0,
+        .overline_thickness = 1,
+        .box_thickness = 1,
     }, ft_font.metrics);
 
     // Resize should change metrics
     try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
     try testing.expectEqual(font.face.Metrics{
         .cell_width = 16,
-        .cell_height = 35,
-        .cell_baseline = 7,
-        .underline_position = 35,
+        .cell_height = 34,
+        .cell_baseline = 6,
+        .underline_position = 34,
         .underline_thickness = 2,
-        .strikethrough_position = 20,
+        .strikethrough_position = 19,
         .strikethrough_thickness = 2,
+        .overline_position = 0,
+        .overline_thickness = 2,
+        .box_thickness = 2,
     }, ft_font.metrics);
 }
 

commit 586a7e517ed97b0e4ba3dfd840cfcd8454983724
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Thu Dec 12 21:30:01 2024 -0500

    font(freetype): actually take max ascii width instead of first

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d7fb2e4a..2849e52d 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -676,18 +676,25 @@ pub const Face = struct {
         // If we fail to load any visible ASCII we just use max_advance from
         // the metrics provided by FreeType.
         const cell_width: f64 = cell_width: {
+            var max: f64 = 0.0;
             var c: u8 = ' ';
             while (c < 127) : (c += 1) {
                 if (face.getCharIndex(c)) |glyph_index| {
                     if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                        break :cell_width f26dot6ToF64(face.handle.*.glyph.*.advance.x);
-                    } else |_| {
-                        // Ignore the error since we just fall back to max_advance below
-                    }
+                        max = @max(
+                            f26dot6ToF64(face.handle.*.glyph.*.advance.x),
+                            max,
+                        );
+                    } else |_| {}
                 }
             }
 
-            break :cell_width f26dot6ToF64(size_metrics.max_advance);
+            // If we couldn't get any widths, just use FreeType's max_advance.
+            if (max == 0.0) {
+                break :cell_width f26dot6ToF64(size_metrics.max_advance);
+            }
+
+            break :cell_width max;
         };
 
         // The OS/2 table does not include sCapHeight or sxHeight in version 1.

commit b7dc7672376bc2ade8ab9235ba895a826ea40c12
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Dec 12 19:42:35 2024 -0800

    face: add more RLS types and explicit error sets

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 2849e52d..c3d4a449 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -598,6 +598,11 @@ pub const Face = struct {
         return @as(opentype.sfnt.F26Dot6, @bitCast(@as(u32, @intCast(v)))).to(f64);
     }
 
+    const CalcMetricsError = error{
+        CopyTableError,
+        MissingOS2Table,
+    };
+
     /// Calculate the metrics associated with a face. This is not public because
     /// the metrics are calculated for every face and cached since they're
     /// frequently required for renderers and take up next to little memory space
@@ -610,7 +615,7 @@ pub const Face = struct {
     fn calcMetrics(
         face: freetype.Face,
         modifiers: ?*const font.face.Metrics.ModifierSet,
-    ) !font.face.Metrics {
+    ) CalcMetricsError!font.face.Metrics {
         const size_metrics = face.handle.*.size.*.metrics;
 
         // This code relies on this assumption, and it should always be
@@ -618,18 +623,18 @@ pub const Face = struct {
         assert(size_metrics.x_ppem == size_metrics.y_ppem);
 
         // Read the 'head' table out of the font data.
-        const head = face.getSfntTable(.head) orelse return error.CannotGetTable;
+        const head = face.getSfntTable(.head) orelse return error.CopyTableError;
 
         // Read the 'post' table out of the font data.
-        const post = face.getSfntTable(.post) orelse return error.CannotGetTable;
+        const post = face.getSfntTable(.post) orelse return error.CopyTableError;
 
         // Read the 'OS/2' table out of the font data.
-        const os2 = face.getSfntTable(.os2) orelse return error.CannotGetTable;
+        const os2 = face.getSfntTable(.os2) orelse return error.CopyTableError;
 
         // Some fonts don't actually have an OS/2 table, which
         // we need in order to do the metrics calculations, in
         // such cases FreeType sets the version to 0xFFFF
-        if (os2.version == 0xFFFF) return error.MissingTable;
+        if (os2.version == 0xFFFF) return error.MissingOS2Table;
 
         const units_per_em = head.Units_Per_EM;
         const px_per_em: f64 = @floatFromInt(size_metrics.y_ppem);

commit 8a5d4847297549823c3f7d2e0fc6ea145d3e2061
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Dec 13 12:46:36 2024 -0500

    font: more robust extraction of vertical metrics from tables
    
    Previously always assuming the typo metrics were good caused some fonts
    to have abnormally short cell heights.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index c3d4a449..e9f8d320 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -631,6 +631,9 @@ pub const Face = struct {
         // Read the 'OS/2' table out of the font data.
         const os2 = face.getSfntTable(.os2) orelse return error.CopyTableError;
 
+        // Read the 'hhea' table out of the font data.
+        const hhea = face.getSfntTable(.hhea) orelse return error.CopyTableError;
+
         // Some fonts don't actually have an OS/2 table, which
         // we need in order to do the metrics calculations, in
         // such cases FreeType sets the version to 0xFFFF
@@ -640,9 +643,56 @@ pub const Face = struct {
         const px_per_em: f64 = @floatFromInt(size_metrics.y_ppem);
         const px_per_unit = px_per_em / @as(f64, @floatFromInt(units_per_em));
 
-        const ascent = @as(f64, @floatFromInt(os2.sTypoAscender)) * px_per_unit;
-        const descent = @as(f64, @floatFromInt(os2.sTypoDescender)) * px_per_unit;
-        const line_gap = @as(f64, @floatFromInt(os2.sTypoLineGap)) * px_per_unit;
+        const ascent: f64, const descent: f64, const line_gap: f64 = vertical_metrics: {
+            const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
+            const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
+            const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+
+            // If the font says to use typo metrics, trust it.
+            // (The USE_TYPO_METRICS bit is bit 7)
+            if (os2.fsSelection & (1 << 7) != 0) {
+                break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
+            }
+
+            // Otherwise we prefer the height metrics from 'hhea' if they
+            // are available, or else OS/2 sTypo* metrics, and if all else
+            // fails then we use OS/2 usWin* metrics.
+            //
+            // This is not "standard" behavior, but it's our best bet to
+            // account for fonts being... just weird. It's pretty much what
+            // FreeType does to get its generic ascent and descent metrics.
+
+            if (hhea.Ascender != 0 or hhea.Descender != 0) {
+                const hhea_ascent: f64 = @floatFromInt(hhea.Ascender);
+                const hhea_descent: f64 = @floatFromInt(hhea.Descender);
+                const hhea_line_gap: f64 = @floatFromInt(hhea.Line_Gap);
+                break :vertical_metrics .{
+                    hhea_ascent * px_per_unit,
+                    hhea_descent * px_per_unit,
+                    hhea_line_gap * px_per_unit,
+                };
+            }
+
+            if (os2_ascent != 0 or os2_descent != 0) {
+                break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
+            }
+
+            const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
+            const win_descent: f64 = @floatFromInt(os2.usWinDescent);
+            break :vertical_metrics .{
+                win_ascent * px_per_unit,
+                win_descent * px_per_unit,
+                0.0,
+            };
+        };
 
         // Some fonts have degenerate 'post' tables where the underline
         // thickness (and often position) are 0. We consider them null

commit 4573890f22d52ea1f47f2a664f7db4aeb3de7543
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Dec 13 13:14:49 2024 -0500

    font: fix sign of usWinDescent interpretation

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index e9f8d320..7d34c70f 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -689,7 +689,9 @@ pub const Face = struct {
             const win_descent: f64 = @floatFromInt(os2.usWinDescent);
             break :vertical_metrics .{
                 win_ascent * px_per_unit,
-                win_descent * px_per_unit,
+                // usWinDescent is *positive* -> down unlike sTypoDescender
+                // and hhea.Descender, so we flip its sign to fix this.
+                -win_descent * px_per_unit,
                 0.0,
             };
         };

commit 13e4861dfffd738e3504c66c217596288ba1a3bc
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Dec 16 14:52:56 2024 -0500

    font(freetype): tolerate fonts without OS/2 tables
    
    This is more common than anticipated, so proper fallback logic has been
    added. Why must fonts be like this? -.-

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 7d34c70f..409b9547 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -600,7 +600,6 @@ pub const Face = struct {
 
     const CalcMetricsError = error{
         CopyTableError,
-        MissingOS2Table,
     };
 
     /// Calculate the metrics associated with a face. This is not public because
@@ -629,70 +628,80 @@ pub const Face = struct {
         const post = face.getSfntTable(.post) orelse return error.CopyTableError;
 
         // Read the 'OS/2' table out of the font data.
-        const os2 = face.getSfntTable(.os2) orelse return error.CopyTableError;
+        const maybe_os2: ?*freetype.c.TT_OS2 = os2: {
+            const os2 = face.getSfntTable(.os2) orelse break :os2 null;
+            if (os2.version == 0xFFFF) break :os2 null;
+            break :os2 os2;
+        };
 
         // Read the 'hhea' table out of the font data.
         const hhea = face.getSfntTable(.hhea) orelse return error.CopyTableError;
 
-        // Some fonts don't actually have an OS/2 table, which
-        // we need in order to do the metrics calculations, in
-        // such cases FreeType sets the version to 0xFFFF
-        if (os2.version == 0xFFFF) return error.MissingOS2Table;
-
         const units_per_em = head.Units_Per_EM;
         const px_per_em: f64 = @floatFromInt(size_metrics.y_ppem);
         const px_per_unit = px_per_em / @as(f64, @floatFromInt(units_per_em));
 
         const ascent: f64, const descent: f64, const line_gap: f64 = vertical_metrics: {
-            const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
-            const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
-            const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+            const hhea_ascent: f64 = @floatFromInt(hhea.Ascender);
+            const hhea_descent: f64 = @floatFromInt(hhea.Descender);
+            const hhea_line_gap: f64 = @floatFromInt(hhea.Line_Gap);
+
+            if (maybe_os2) |os2| {
+                const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
+                const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
+                const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+
+                // If the font says to use typo metrics, trust it.
+                // (The USE_TYPO_METRICS bit is bit 7)
+                if (os2.fsSelection & (1 << 7) != 0) {
+                    break :vertical_metrics .{
+                        os2_ascent * px_per_unit,
+                        os2_descent * px_per_unit,
+                        os2_line_gap * px_per_unit,
+                    };
+                }
 
-            // If the font says to use typo metrics, trust it.
-            // (The USE_TYPO_METRICS bit is bit 7)
-            if (os2.fsSelection & (1 << 7) != 0) {
-                break :vertical_metrics .{
-                    os2_ascent * px_per_unit,
-                    os2_descent * px_per_unit,
-                    os2_line_gap * px_per_unit,
-                };
-            }
+                // Otherwise we prefer the height metrics from 'hhea' if they
+                // are available, or else OS/2 sTypo* metrics, and if all else
+                // fails then we use OS/2 usWin* metrics.
+                //
+                // This is not "standard" behavior, but it's our best bet to
+                // account for fonts being... just weird. It's pretty much what
+                // FreeType does to get its generic ascent and descent metrics.
+
+                if (hhea.Ascender != 0 or hhea.Descender != 0) {
+                    break :vertical_metrics .{
+                        hhea_ascent * px_per_unit,
+                        hhea_descent * px_per_unit,
+                        hhea_line_gap * px_per_unit,
+                    };
+                }
 
-            // Otherwise we prefer the height metrics from 'hhea' if they
-            // are available, or else OS/2 sTypo* metrics, and if all else
-            // fails then we use OS/2 usWin* metrics.
-            //
-            // This is not "standard" behavior, but it's our best bet to
-            // account for fonts being... just weird. It's pretty much what
-            // FreeType does to get its generic ascent and descent metrics.
-
-            if (hhea.Ascender != 0 or hhea.Descender != 0) {
-                const hhea_ascent: f64 = @floatFromInt(hhea.Ascender);
-                const hhea_descent: f64 = @floatFromInt(hhea.Descender);
-                const hhea_line_gap: f64 = @floatFromInt(hhea.Line_Gap);
-                break :vertical_metrics .{
-                    hhea_ascent * px_per_unit,
-                    hhea_descent * px_per_unit,
-                    hhea_line_gap * px_per_unit,
-                };
-            }
+                if (os2_ascent != 0 or os2_descent != 0) {
+                    break :vertical_metrics .{
+                        os2_ascent * px_per_unit,
+                        os2_descent * px_per_unit,
+                        os2_line_gap * px_per_unit,
+                    };
+                }
 
-            if (os2_ascent != 0 or os2_descent != 0) {
+                const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
+                const win_descent: f64 = @floatFromInt(os2.usWinDescent);
                 break :vertical_metrics .{
-                    os2_ascent * px_per_unit,
-                    os2_descent * px_per_unit,
-                    os2_line_gap * px_per_unit,
+                    win_ascent * px_per_unit,
+                    // usWinDescent is *positive* -> down unlike sTypoDescender
+                    // and hhea.Descender, so we flip its sign to fix this.
+                    -win_descent * px_per_unit,
+                    0.0,
                 };
             }
 
-            const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
-            const win_descent: f64 = @floatFromInt(os2.usWinDescent);
+            // If our font has no OS/2 table, then we just
+            // blindly use the metrics from the hhea table.
             break :vertical_metrics .{
-                win_ascent * px_per_unit,
-                // usWinDescent is *positive* -> down unlike sTypoDescender
-                // and hhea.Descender, so we flip its sign to fix this.
-                -win_descent * px_per_unit,
-                0.0,
+                hhea_ascent * px_per_unit,
+                hhea_descent * px_per_unit,
+                hhea_line_gap * px_per_unit,
             };
         };
 
@@ -714,17 +723,25 @@ pub const Face = struct {
             @as(f64, @floatFromInt(post.underlineThickness)) * px_per_unit;
 
         // Similar logic to the underline above.
-        const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+        const strikethrough_position, const strikethrough_thickness = st: {
+            if (maybe_os2) |os2| {
+                const has_broken_strikethrough = os2.yStrikeoutSize == 0;
 
-        const strikethrough_position = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
-            null
-        else
-            @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+                const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+                    null
+                else
+                    @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
 
-        const strikethrough_thickness = if (has_broken_strikethrough)
-            null
-        else
-            @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+                const thick: ?f64 = if (has_broken_strikethrough)
+                    null
+                else
+                    @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+
+                break :st .{ pos, thick };
+            }
+
+            break :st .{ null, null };
+        };
 
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take
@@ -754,37 +771,33 @@ pub const Face = struct {
             break :cell_width max;
         };
 
-        // The OS/2 table does not include sCapHeight or sxHeight in version 1.
-        const has_os2_height_metrics = os2.version >= 2;
-
-        // We use the cap height specified by the font if it's
-        // available, otherwise we try to measure the `H` glyph.
-        const cap_height: ?f64 = cap_height: {
-            if (has_os2_height_metrics) {
-                break :cap_height @as(f64, @floatFromInt(os2.sCapHeight)) * px_per_unit;
-            }
-            if (face.getCharIndex('H')) |glyph_index| {
-                if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                    break :cap_height f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
-                } else |_| {}
-            }
-
-            break :cap_height null;
-        };
-
-        // We use the ex height specified by the font if it's
-        // available, otherwise we try to measure the `x` glyph.
-        const ex_height: ?f64 = ex_height: {
-            if (has_os2_height_metrics) {
-                break :ex_height @as(f64, @floatFromInt(os2.sxHeight)) * px_per_unit;
-            }
-            if (face.getCharIndex('x')) |glyph_index| {
-                if (face.loadGlyph(glyph_index, .{ .render = true })) {
-                    break :ex_height f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
-                } else |_| {}
+        // We use the cap and ex heights specified by the font if they're
+        // available, otherwise we try to measure the `H` and `x` glyphs.
+        const cap_height: ?f64, const ex_height: ?f64 = heights: {
+            if (maybe_os2) |os2| {
+                break :heights .{
+                    @as(f64, @floatFromInt(os2.sCapHeight)) * px_per_unit,
+                    @as(f64, @floatFromInt(os2.sxHeight)) * px_per_unit,
+                };
             }
-
-            break :ex_height null;
+            break :heights .{
+                cap: {
+                    if (face.getCharIndex('H')) |glyph_index| {
+                        if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                            break :cap f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
+                        } else |_| {}
+                    }
+                    break :cap null;
+                },
+                ex: {
+                    if (face.getCharIndex('x')) |glyph_index| {
+                        if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                            break :ex f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
+                        } else |_| {}
+                    }
+                    break :ex null;
+                },
+            };
         };
 
         var result = font.face.Metrics.calc(.{

commit a06388869dab03abda4eab5e4d5f52b4cbfd36ae
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Dec 16 15:20:26 2024 -0500

    fix: sCapHeight and sxHeight only exist when OS/2 version >= 2

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 409b9547..186ad9e1 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -775,10 +775,13 @@ pub const Face = struct {
         // available, otherwise we try to measure the `H` and `x` glyphs.
         const cap_height: ?f64, const ex_height: ?f64 = heights: {
             if (maybe_os2) |os2| {
-                break :heights .{
-                    @as(f64, @floatFromInt(os2.sCapHeight)) * px_per_unit,
-                    @as(f64, @floatFromInt(os2.sxHeight)) * px_per_unit,
-                };
+                // The OS/2 table does not include these metrics in version 1.
+                if (os2.version >= 2) {
+                    break :heights .{
+                        @as(f64, @floatFromInt(os2.sCapHeight)) * px_per_unit,
+                        @as(f64, @floatFromInt(os2.sxHeight)) * px_per_unit,
+                    };
+                }
             }
             break :heights .{
                 cap: {

commit 2b78ac4382c12686fa4aed7871db18256b48934c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 16 12:29:10 2024 -0800

    font: style edits for #2985

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 186ad9e1..f5ec9e7e 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -628,7 +628,7 @@ pub const Face = struct {
         const post = face.getSfntTable(.post) orelse return error.CopyTableError;
 
         // Read the 'OS/2' table out of the font data.
-        const maybe_os2: ?*freetype.c.TT_OS2 = os2: {
+        const os2_: ?*freetype.c.TT_OS2 = os2: {
             const os2 = face.getSfntTable(.os2) orelse break :os2 null;
             if (os2.version == 0xFFFF) break :os2 null;
             break :os2 os2;
@@ -646,7 +646,7 @@ pub const Face = struct {
             const hhea_descent: f64 = @floatFromInt(hhea.Descender);
             const hhea_line_gap: f64 = @floatFromInt(hhea.Line_Gap);
 
-            if (maybe_os2) |os2| {
+            if (os2_) |os2| {
                 const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
                 const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
                 const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
@@ -724,23 +724,21 @@ pub const Face = struct {
 
         // Similar logic to the underline above.
         const strikethrough_position, const strikethrough_thickness = st: {
-            if (maybe_os2) |os2| {
-                const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+            const os2 = os2_ orelse break :st .{ null, null };
 
-                const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
-                    null
-                else
-                    @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+            const has_broken_strikethrough = os2.yStrikeoutSize == 0;
 
-                const thick: ?f64 = if (has_broken_strikethrough)
-                    null
-                else
-                    @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+            const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+                null
+            else
+                @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
 
-                break :st .{ pos, thick };
-            }
+            const thick: ?f64 = if (has_broken_strikethrough)
+                null
+            else
+                @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
 
-            break :st .{ null, null };
+            break :st .{ pos, thick };
         };
 
         // Cell width is calculated by calculating the widest width of the
@@ -774,7 +772,7 @@ pub const Face = struct {
         // We use the cap and ex heights specified by the font if they're
         // available, otherwise we try to measure the `H` and `x` glyphs.
         const cap_height: ?f64, const ex_height: ?f64 = heights: {
-            if (maybe_os2) |os2| {
+            if (os2_) |os2| {
                 // The OS/2 table does not include these metrics in version 1.
                 if (os2.version >= 2) {
                     break :heights .{
@@ -783,6 +781,7 @@ pub const Face = struct {
                     };
                 }
             }
+
             break :heights .{
                 cap: {
                     if (face.getCharIndex('H')) |glyph_index| {

commit 08ebb6b64d048f3d3c50f2ebb513cdfcc5f53b66
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Dec 22 12:34:43 2024 -0500

    fix tests for freetype to include cursor_height metric

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index f5ec9e7e..bc503a3a 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -906,6 +906,7 @@ test "color emoji" {
                 .overline_position = 0,
                 .overline_thickness = 0,
                 .box_thickness = 0,
+                .cursor_height = 0,
             },
         });
         try testing.expectEqual(@as(u32, 24), glyph.height);
@@ -952,6 +953,7 @@ test "metrics" {
         .overline_position = 0,
         .overline_thickness = 1,
         .box_thickness = 1,
+        .cursor_height = 17,
     }, ft_font.metrics);
 
     // Resize should change metrics
@@ -967,6 +969,7 @@ test "metrics" {
         .overline_position = 0,
         .overline_thickness = 2,
         .box_thickness = 2,
+        .cursor_height = 34,
     }, ft_font.metrics);
 }
 

commit ea8fe9a4b0c438c3421ad030e70435a4efb65929
Author: sin-ack <sin-ack@protonmail.com>
Date:   Sun Dec 29 02:08:25 2024 +0000

    font/freetype: Enable bitmap glyphs for non-color faces
    
    This allows for crisp bitmap font rendering once again.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index bc503a3a..3f180ad6 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -288,7 +288,6 @@ pub const Face = struct {
         self.face.loadGlyph(glyph_id, .{
             .render = true,
             .color = self.face.hasColor(),
-            .no_bitmap = !self.face.hasColor(),
         }) catch return false;
 
         // If the glyph is SVG we assume colorized
@@ -323,14 +322,6 @@ pub const Face = struct {
             // glyph properties before render so we don't render here.
             .render = !self.synthetic.bold,
 
-            // Disable bitmap strikes for now since it causes issues with
-            // our cell metrics and rasterization. In the future, this is
-            // all fixable so we can enable it.
-            //
-            // This must be enabled for color faces though because those are
-            // often colored bitmaps, which we support.
-            .no_bitmap = !self.face.hasColor(),
-
             // use options from config
             .no_hinting = !self.load_flags.hinting,
             .force_autohint = !self.load_flags.@"force-autohint",

commit 1a6d9590a21ff600b5de49521cb08daccb35d53f
Author: sin-ack <sin-ack@protonmail.com>
Date:   Sun Dec 29 04:55:29 2024 +0000

    font/freetype: Add test for crisp bitmap font rendering
    
    Now we can be certain that bitmap fonts stay crisp. :^)

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 3f180ad6..0a822cbc 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -996,3 +996,55 @@ test "svg font table" {
 
     try testing.expectEqual(430, table.len);
 }
+
+const terminus_i =
+    \\........
+    \\........
+    \\...#....
+    \\...#....
+    \\........
+    \\..##....
+    \\...#....
+    \\...#....
+    \\...#....
+    \\...#....
+    \\...#....
+    \\..###...
+    \\........
+    \\........
+    \\........
+    \\........
+;
+// Including the newline
+const terminus_i_pitch = 9;
+
+test "bitmap glyph" {
+    const alloc = testing.allocator;
+    const testFont = font.embedded.terminus_ttf;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas.deinit(alloc);
+
+    // Any glyph at 12pt @ 96 DPI is a bitmap
+    var ft_font = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    defer ft_font.deinit();
+
+    // glyph 77 = 'i'
+    const glyph = try ft_font.renderGlyph(alloc, &atlas, 77, .{});
+
+    // should render crisp
+    try testing.expectEqual(8, glyph.width);
+    try testing.expectEqual(16, glyph.height);
+    for (0..glyph.height) |y| {
+        for (0..glyph.width) |x| {
+            const pixel = terminus_i[y * terminus_i_pitch + x];
+            try testing.expectEqual(
+                @as(u8, if (pixel == '#') 255 else 0),
+                atlas.data[(glyph.atlas_y + y) * atlas.size + (glyph.atlas_x + x)],
+            );
+        }
+    }
+}

commit 5e14b8e5013e5efe7bdd1a89c4efb26d0f909c69
Author: sin-ack <sin-ack@protonmail.com>
Date:   Sun Dec 29 04:56:17 2024 +0000

    font/freetype: Downgrade pixfmt conversion log to debug
    
    This is an expected occurrence with bitmap glyphs and causes unnecessary
    spam when using the terminal with one.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 0a822cbc..d63cf99f 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -376,7 +376,7 @@ pub const Face = struct {
                 return error.UnsupportedPixelMode;
             };
 
-            log.warn("converting from pixel_mode={} to atlas_format={}", .{
+            log.debug("converting from pixel_mode={} to atlas_format={}", .{
                 bitmap_ft.pixel_mode,
                 atlas.format,
             });

commit 41df2d980590de51c874783b2e9795dbb839c025
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 30 12:01:31 2024 -0800

    font/freetype: hardcode DPI in test to avoid variation between OS

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d63cf99f..630eaee2 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -1029,7 +1029,11 @@ test "bitmap glyph" {
     defer atlas.deinit(alloc);
 
     // Any glyph at 12pt @ 96 DPI is a bitmap
-    var ft_font = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    var ft_font = try Face.init(lib, testFont, .{ .size = .{
+        .points = 12,
+        .xdpi = 96,
+        .ydpi = 96,
+    } });
     defer ft_font.deinit();
 
     // glyph 77 = 'i'

commit 540fcc0b690901f185ca00465dafed2e9423b479
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 17:39:53 2025 -0500

    refactor(font): move `Metrics` out of `face`
    
    in preparation to move ownership of metrics from faces to collections

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 630eaee2..d919fd7b 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -39,7 +39,7 @@ pub const Face = struct {
     hb_font: harfbuzz.Font,
 
     /// Metrics for this font face. These are useful for renderers.
-    metrics: font.face.Metrics,
+    metrics: font.Metrics,
 
     /// Freetype load flags for this font face.
     load_flags: font.face.FreetypeLoadFlags,
@@ -604,8 +604,8 @@ pub const Face = struct {
     /// deinitialized anytime and reloaded with the deferred face.
     fn calcMetrics(
         face: freetype.Face,
-        modifiers: ?*const font.face.Metrics.ModifierSet,
-    ) CalcMetricsError!font.face.Metrics {
+        modifiers: ?*const font.Metrics.ModifierSet,
+    ) CalcMetricsError!font.Metrics {
         const size_metrics = face.handle.*.size.*.metrics;
 
         // This code relies on this assumption, and it should always be
@@ -793,7 +793,7 @@ pub const Face = struct {
             };
         };
 
-        var result = font.face.Metrics.calc(.{
+        var result = font.Metrics.calc(.{
             .cell_width = cell_width,
 
             .ascent = ascent,
@@ -921,7 +921,7 @@ test "metrics" {
     );
     defer ft_font.deinit();
 
-    try testing.expectEqual(font.face.Metrics{
+    try testing.expectEqual(font.Metrics{
         .cell_width = 8,
         // The cell height is 17 px because the calculation is
         //
@@ -949,7 +949,7 @@ test "metrics" {
 
     // Resize should change metrics
     try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
-    try testing.expectEqual(font.face.Metrics{
+    try testing.expectEqual(font.Metrics{
         .cell_width = 16,
         .cell_height = 34,
         .cell_baseline = 6,

commit 298aeb7536d69b8aef236569ee86ecfddd45d991
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 19:00:13 2025 -0500

    refactor(font): move ownership of `Metrics` to `Collection`
    
    This sets the stage for dynamically adjusting the sizes of fallback
    fonts based on the primary font's face metrics. It also removes a lot of
    unnecessary work when loading fallback fonts, since we only actually use
    the metrics based on the parimary font.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index d919fd7b..b56e9469 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -38,9 +38,6 @@ pub const Face = struct {
     /// Harfbuzz font corresponding to this face.
     hb_font: harfbuzz.Font,
 
-    /// Metrics for this font face. These are useful for renderers.
-    metrics: font.Metrics,
-
     /// Freetype load flags for this font face.
     load_flags: font.face.FreetypeLoadFlags,
 
@@ -86,7 +83,6 @@ pub const Face = struct {
             .lib = lib.lib,
             .face = face,
             .hb_font = hb_font,
-            .metrics = try calcMetrics(face, opts.metric_modifiers),
             .load_flags = opts.freetype_load_flags,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
@@ -186,7 +182,6 @@ pub const Face = struct {
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, opts: font.face.Options) !void {
         try setSize_(self.face, opts.size);
-        self.metrics = try calcMetrics(self.face, opts.metric_modifiers);
     }
 
     fn setSize_(face: freetype.Face, size: font.face.DesiredSize) !void {
@@ -224,6 +219,8 @@ pub const Face = struct {
         vs: []const font.face.Variation,
         opts: font.face.Options,
     ) !void {
+        _ = opts;
+
         // If this font doesn't support variations, we can't do anything.
         if (!self.face.hasMultipleMasters() or vs.len == 0) return;
 
@@ -257,9 +254,6 @@ pub const Face = struct {
 
         // Set them!
         try self.face.setVarDesignCoordinates(coords);
-
-        // We need to recalculate font metrics which may have changed.
-        self.metrics = try calcMetrics(self.face, opts.metric_modifiers);
     }
 
     /// Returns the glyph index for the given Unicode code point. If this
@@ -306,7 +300,7 @@ pub const Face = struct {
         glyph_index: u32,
         opts: font.face.RenderOptions,
     ) !Glyph {
-        const metrics = opts.grid_metrics orelse self.metrics;
+        const metrics = opts.grid_metrics;
 
         // If we have synthetic italic, then we apply a transformation matrix.
         // We have to undo this because synthetic italic works by increasing
@@ -589,23 +583,14 @@ pub const Face = struct {
         return @as(opentype.sfnt.F26Dot6, @bitCast(@as(u32, @intCast(v)))).to(f64);
     }
 
-    const CalcMetricsError = error{
+    pub const GetMetricsError = error{
         CopyTableError,
     };
 
-    /// Calculate the metrics associated with a face. This is not public because
-    /// the metrics are calculated for every face and cached since they're
-    /// frequently required for renderers and take up next to little memory space
-    /// in the grand scheme of things.
-    ///
-    /// An aside: the proper way to limit memory usage due to faces is to limit
-    /// the faces with DeferredFaces and reload on demand. A Face can't be converted
-    /// into a DeferredFace but a Face that comes from a DeferredFace can be
-    /// deinitialized anytime and reloaded with the deferred face.
-    fn calcMetrics(
-        face: freetype.Face,
-        modifiers: ?*const font.Metrics.ModifierSet,
-    ) CalcMetricsError!font.Metrics {
+    /// Get the `FaceMetrics` for this face.
+    pub fn getMetrics(self: *Face) GetMetricsError!font.Metrics.FaceMetrics {
+        const face = self.face;
+
         const size_metrics = face.handle.*.size.*.metrics;
 
         // This code relies on this assumption, and it should always be
@@ -793,7 +778,7 @@ pub const Face = struct {
             };
         };
 
-        var result = font.Metrics.calc(.{
+        return .{
             .cell_width = cell_width,
 
             .ascent = ascent,
@@ -808,13 +793,7 @@ pub const Face = struct {
 
             .cap_height = cap_height,
             .ex_height = ex_height,
-        });
-
-        if (modifiers) |m| result.apply(m.*);
-
-        // std.log.warn("font metrics={}", .{result});
-
-        return result;
+        };
     }
 
     /// Copy the font table data for the given tag.
@@ -843,16 +822,31 @@ test {
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
-        _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?, .{});
+        _ = try ft_font.renderGlyph(
+            alloc,
+            &atlas,
+            ft_font.glyphIndex(i).?,
+            .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+        );
     }
 
     // Test resizing
     {
-        const g1 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
+        const g1 = try ft_font.renderGlyph(
+            alloc,
+            &atlas,
+            ft_font.glyphIndex('A').?,
+            .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+        );
         try testing.expectEqual(@as(u32, 11), g1.height);
 
         try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
-        const g2 = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('A').?, .{});
+        const g2 = try ft_font.renderGlyph(
+            alloc,
+            &atlas,
+            ft_font.glyphIndex('A').?,
+            .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+        );
         try testing.expectEqual(@as(u32, 20), g2.height);
     }
 }
@@ -874,7 +868,12 @@ test "color emoji" {
     );
     defer ft_font.deinit();
 
-    _ = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{});
+    _ = try ft_font.renderGlyph(
+        alloc,
+        &atlas,
+        ft_font.glyphIndex('ðŸ¥¸').?,
+        .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+    );
 
     // Make sure this glyph has color
     {
@@ -885,8 +884,11 @@ test "color emoji" {
 
     // resize
     {
-        const glyph = try ft_font.renderGlyph(alloc, &atlas, ft_font.glyphIndex('ðŸ¥¸').?, .{
-            .grid_metrics = .{
+        const glyph = try ft_font.renderGlyph(
+            alloc,
+            &atlas,
+            ft_font.glyphIndex('ðŸ¥¸').?,
+            .{ .grid_metrics = .{
                 .cell_width = 10,
                 .cell_height = 24,
                 .cell_baseline = 0,
@@ -898,72 +900,12 @@ test "color emoji" {
                 .overline_thickness = 0,
                 .box_thickness = 0,
                 .cursor_height = 0,
-            },
-        });
+            } },
+        );
         try testing.expectEqual(@as(u32, 24), glyph.height);
     }
 }
 
-test "metrics" {
-    const testFont = font.embedded.inconsolata;
-    const alloc = testing.allocator;
-
-    var lib = try Library.init();
-    defer lib.deinit();
-
-    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
-    defer atlas.deinit(alloc);
-
-    var ft_font = try Face.init(
-        lib,
-        testFont,
-        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
-    );
-    defer ft_font.deinit();
-
-    try testing.expectEqual(font.Metrics{
-        .cell_width = 8,
-        // The cell height is 17 px because the calculation is
-        //
-        //  ascender - descender + gap
-        //
-        // which, for inconsolata is
-        //
-        //  859 - -190 + 0
-        //
-        // font units, at 1000 units per em that works out to 1.049 em,
-        // and 1em should be the point size * dpi scale, so 12 * (96/72)
-        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
-        // to 17.
-        .cell_height = 17,
-        .cell_baseline = 3,
-        .underline_position = 17,
-        .underline_thickness = 1,
-        .strikethrough_position = 10,
-        .strikethrough_thickness = 1,
-        .overline_position = 0,
-        .overline_thickness = 1,
-        .box_thickness = 1,
-        .cursor_height = 17,
-    }, ft_font.metrics);
-
-    // Resize should change metrics
-    try ft_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
-    try testing.expectEqual(font.Metrics{
-        .cell_width = 16,
-        .cell_height = 34,
-        .cell_baseline = 6,
-        .underline_position = 34,
-        .underline_thickness = 2,
-        .strikethrough_position = 19,
-        .strikethrough_thickness = 2,
-        .overline_position = 0,
-        .overline_thickness = 2,
-        .box_thickness = 2,
-        .cursor_height = 34,
-    }, ft_font.metrics);
-}
-
 test "mono to rgba" {
     const alloc = testing.allocator;
     const testFont = font.embedded.emoji;
@@ -974,11 +916,16 @@ test "mono to rgba" {
     var atlas = try font.Atlas.init(alloc, 512, .rgba);
     defer atlas.deinit(alloc);
 
-    var ft_font = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    var ft_font = try Face.init(lib, testFont, .{ .size = .{ .points = 12, .xdpi = 72, .ydpi = 72 } });
     defer ft_font.deinit();
 
     // glyph 3 is mono in Noto
-    _ = try ft_font.renderGlyph(alloc, &atlas, 3, .{});
+    _ = try ft_font.renderGlyph(
+        alloc,
+        &atlas,
+        3,
+        .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+    );
 }
 
 test "svg font table" {
@@ -988,7 +935,7 @@ test "svg font table" {
     var lib = try font.Library.init();
     defer lib.deinit();
 
-    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12, .xdpi = 72, .ydpi = 72 } });
     defer face.deinit();
 
     const table = (try face.copyTable(alloc, "SVG ")).?;
@@ -1037,7 +984,12 @@ test "bitmap glyph" {
     defer ft_font.deinit();
 
     // glyph 77 = 'i'
-    const glyph = try ft_font.renderGlyph(alloc, &atlas, 77, .{});
+    const glyph = try ft_font.renderGlyph(
+        alloc,
+        &atlas,
+        77,
+        .{ .grid_metrics = font.Metrics.calc(try ft_font.getMetrics()) },
+    );
 
     // should render crisp
     try testing.expectEqual(8, glyph.width);

commit 40c1140f7d37d52585410475594baab1b38e2405
Author: Tim Culverhouse <tim@timculverhouse.com>
Date:   Thu Mar 6 09:58:28 2025 -0600

    font(freetype): constrain emoji to 2 cells wide
    
    When scaling emoji, scale so that they entirely fit within 2 cells. The
    previous behavior was to scale to fill vertically, however with fonts
    which are narrow this would result in horizontal overflow.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index b56e9469..0e79f903 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -390,13 +390,28 @@ pub const Face = struct {
         // and copy the atlas.
         const bitmap_original = bitmap_converted orelse bitmap_ft;
         const bitmap_resized: ?freetype.c.struct_FT_Bitmap_ = resized: {
-            const max = metrics.cell_height;
-            const bm = bitmap_original;
-            if (bm.rows <= max) break :resized null;
+            const original_width = bitmap_original.width;
+            const original_height = bitmap_original.rows;
+            var result = bitmap_original;
+            // TODO: We are limiting this to only emoji. We can rework this after a future
+            // improvement (promised by Qwerasd) which implements more flexible resizing rules. For
+            // now, this will suffice
+            if (self.isColorGlyph(glyph_index) and opts.cell_width != null) {
+                const cell_width = opts.cell_width orelse unreachable;
+                // If we have a cell_width, we constrain the glyph to fit within the cell
+                result.width = metrics.cell_width * @as(u32, cell_width);
+                result.rows = (result.width * original_height) / original_width;
+            } else {
+                // If we don't have a cell_width, we scale to fill vertically
+                result.rows = metrics.cell_height;
+                result.width = (metrics.cell_height * original_width) / original_height;
+            }
+
+            // If we already fit, we don't need to resize
+            if (original_height <= result.rows and original_width <= result.width) {
+                break :resized null;
+            }
 
-            var result = bm;
-            result.rows = max;
-            result.width = (result.rows * bm.width) / bm.rows;
             result.pitch = @as(c_int, @intCast(result.width)) * atlas.format.depth();
 
             const buf = try alloc.alloc(
@@ -407,10 +422,10 @@ pub const Face = struct {
             errdefer alloc.free(buf);
 
             if (stb.stbir_resize_uint8(
-                bm.buffer,
-                @intCast(bm.width),
-                @intCast(bm.rows),
-                bm.pitch,
+                bitmap_original.buffer,
+                @intCast(original_width),
+                @intCast(original_height),
+                bitmap_original.pitch,
                 result.buffer,
                 @intCast(result.width),
                 @intCast(result.rows),
@@ -520,7 +535,7 @@ pub const Face = struct {
             // NOTE(mitchellh): I don't know if this is right, this doesn't
             // _feel_ right, but it makes all my limited test cases work.
             if (self.face.hasColor() and !self.face.isScalable()) {
-                break :offset_y @intCast(tgt_h);
+                break :offset_y @intCast(tgt_h + (metrics.cell_height -| tgt_h) / 2);
             }
 
             // The Y offset is the offset of the top of our bitmap PLUS our

commit 6f84a5d68268cc3142f4570424c5457b1d02622a
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Mar 19 12:39:34 2025 -0600

    font/freetype: disable SVG glyphs, simplify color check
    
    We don't currently support rendering SVG glyphs so they should be
    ignored when loading. Additionally, the check for whether a glyph is
    colored has been simplified by just checking the pixel mode of the
    rendered bitmap.
    
    This commit also fixes a bug caused by calling the color check inside of
    `renderGlyph`, which caused the bitmap to be freed creating a chance for
    memory corruption and garbled glyphs.

diff --git a/src/font/face/freetype.zig b/src/font/face/freetype.zig
index 0e79f903..c2eab459 100644
--- a/src/font/face/freetype.zig
+++ b/src/font/face/freetype.zig
@@ -270,25 +270,21 @@ pub const Face = struct {
 
     /// Returns true if the given glyph ID is colorized.
     pub fn isColorGlyph(self: *const Face, glyph_id: u32) bool {
-        // sbix table is always true for now
-        if (self.face.hasSBIX()) return true;
-
-        // CBDT/CBLC tables always imply colorized glyphs.
-        // These are used by Noto.
-        if (self.face.hasSfntTable(freetype.Tag.init("CBDT"))) return true;
-        if (self.face.hasSfntTable(freetype.Tag.init("CBLC"))) return true;
-
-        // Otherwise, load the glyph and see what format it is in.
+        // Load the glyph and see what pixel mode it renders with.
+        // All modes other than BGRA are non-color.
+        // If the glyph fails to load, just return false.
         self.face.loadGlyph(glyph_id, .{
             .render = true,
             .color = self.face.hasColor(),
+            // NO_SVG set to true because we don't currently support rendering
+            // SVG glyphs under FreeType, since that requires bundling another
+            // dependency to handle rendering the SVG.
+            .no_svg = true,
         }) catch return false;
 
-        // If the glyph is SVG we assume colorized
         const glyph = self.face.handle.*.glyph;
-        if (glyph.*.format == freetype.c.FT_GLYPH_FORMAT_SVG) return true;
 
-        return false;
+        return glyph.*.bitmap.pixel_mode == freetype.c.FT_PIXEL_MODE_BGRA;
     }
 
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
@@ -321,6 +317,11 @@ pub const Face = struct {
             .force_autohint = !self.load_flags.@"force-autohint",
             .monochrome = !self.load_flags.monochrome,
             .no_autohint = !self.load_flags.autohint,
+
+            // NO_SVG set to true because we don't currently support rendering
+            // SVG glyphs under FreeType, since that requires bundling another
+            // dependency to handle rendering the SVG.
+            .no_svg = true,
         });
         const glyph = self.face.handle.*.glyph;
 
@@ -393,12 +394,13 @@ pub const Face = struct {
             const original_width = bitmap_original.width;
             const original_height = bitmap_original.rows;
             var result = bitmap_original;
-            // TODO: We are limiting this to only emoji. We can rework this after a future
-            // improvement (promised by Qwerasd) which implements more flexible resizing rules. For
-            // now, this will suffice
-            if (self.isColorGlyph(glyph_index) and opts.cell_width != null) {
+            // TODO: We are limiting this to only color glyphs, so mainly emoji.
+            // We can rework this after a future improvement (promised by Qwerasd)
+            // which implements more flexible resizing rules.
+            if (atlas.format != .grayscale and opts.cell_width != null) {
                 const cell_width = opts.cell_width orelse unreachable;
-                // If we have a cell_width, we constrain the glyph to fit within the cell
+                // If we have a cell_width, we constrain
+                // the glyph to fit within the cell(s).
                 result.width = metrics.cell_width * @as(u32, cell_width);
                 result.rows = (result.width * original_height) / original_width;
             } else {
@@ -743,7 +745,10 @@ pub const Face = struct {
             var c: u8 = ' ';
             while (c < 127) : (c += 1) {
                 if (face.getCharIndex(c)) |glyph_index| {
-                    if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                    if (face.loadGlyph(glyph_index, .{
+                        .render = true,
+                        .no_svg = true,
+                    })) {
                         max = @max(
                             f26dot6ToF64(face.handle.*.glyph.*.advance.x),
                             max,
@@ -776,7 +781,10 @@ pub const Face = struct {
             break :heights .{
                 cap: {
                     if (face.getCharIndex('H')) |glyph_index| {
-                        if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                        if (face.loadGlyph(glyph_index, .{
+                            .render = true,
+                            .no_svg = true,
+                        })) {
                             break :cap f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
                         } else |_| {}
                     }
@@ -784,7 +792,10 @@ pub const Face = struct {
                 },
                 ex: {
                     if (face.getCharIndex('x')) |glyph_index| {
-                        if (face.loadGlyph(glyph_index, .{ .render = true })) {
+                        if (face.loadGlyph(glyph_index, .{
+                            .render = true,
+                            .no_svg = true,
+                        })) {
                             break :ex f26dot6ToF64(face.handle.*.glyph.*.metrics.height);
                         } else |_| {}
                     }

