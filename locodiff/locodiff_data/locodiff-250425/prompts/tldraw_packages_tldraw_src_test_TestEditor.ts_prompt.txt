# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/test/TestEditor.ts

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a ‚Äúcore‚Äù library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we‚Äôve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
new file mode 100644
index 000000000..eb5e48375
--- /dev/null
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -0,0 +1,635 @@
+import {
+	Box2dModel,
+	Editor,
+	PageRecordType,
+	ROTATE_CORNER_TO_SELECTION_CORNER,
+	RequiredKeys,
+	RotateCorner,
+	SelectionHandle,
+	TAU,
+	TLContent,
+	TLEditorOptions,
+	TLEventInfo,
+	TLKeyboardEventInfo,
+	TLPinchEventInfo,
+	TLPointerEventInfo,
+	TLShapeId,
+	TLShapePartial,
+	TLWheelEventInfo,
+	Vec2d,
+	VecLike,
+	createShapeId,
+	createTLStore,
+	rotateSelectionHandle,
+} from '@tldraw/editor'
+import { defaultShapeTools } from '../lib/defaultShapeTools'
+import { defaultShapeUtils } from '../lib/defaultShapeUtils'
+import { defaultTools } from '../lib/defaultTools'
+import { shapesFromJsx } from './test-jsx'
+
+jest.useFakeTimers()
+
+Object.assign(navigator, {
+	clipboard: {
+		write: () => {
+			//noop
+		},
+	},
+})
+
+// @ts-expect-error
+window.ClipboardItem = class {}
+
+declare global {
+	// eslint-disable-next-line @typescript-eslint/no-namespace
+	namespace jest {
+		// eslint-disable-next-line @typescript-eslint/no-unused-vars
+		interface Matchers<R> {
+			toCloselyMatchObject(value: any, precision?: number): void
+		}
+	}
+}
+
+export class TestEditor extends Editor {
+	constructor(options: Partial<Omit<TLEditorOptions, 'store'>> = {}) {
+		const elm = document.createElement('div')
+		elm.tabIndex = 0
+
+		const shapeUtilsWithDefaults = [...defaultShapeUtils, ...(options.shapeUtils ?? [])]
+
+		super({
+			...options,
+			shapeUtils: [...shapeUtilsWithDefaults],
+			tools: [...defaultTools, ...defaultShapeTools, ...(options.tools ?? [])],
+			store: createTLStore({ shapeUtils: [...shapeUtilsWithDefaults] }),
+			getContainer: () => elm,
+			initialState: 'select',
+		})
+
+		// Pretty hacky way to mock the screen bounds
+		this.elm = elm
+		this.elm.getBoundingClientRect = () => this.bounds as DOMRect
+		document.body.appendChild(this.elm)
+
+		this.textMeasure.measureText = (
+			textToMeasure: string,
+			opts: {
+				fontStyle: string
+				fontWeight: string
+				fontFamily: string
+				fontSize: number
+				lineHeight: number
+				width: string
+				maxWidth: string
+			}
+		): Box2dModel => {
+			const breaks = textToMeasure.split('\n')
+			const longest = breaks.reduce((acc, curr) => {
+				return curr.length > acc.length ? curr : acc
+			}, '')
+
+			const w = longest.length * (opts.fontSize / 2)
+
+			return {
+				x: 0,
+				y: 0,
+				w: opts.width.includes('px') ? Math.max(w, +opts.width.replace('px', '')) : w,
+				h:
+					(opts.width.includes('px')
+						? Math.ceil(w % +opts.width.replace('px', '')) + breaks.length
+						: breaks.length) * opts.fontSize,
+			}
+		}
+
+		this.textMeasure.measureTextSpans = (textToMeasure, opts) => {
+			const box = this.textMeasure.measureText(textToMeasure, {
+				...opts,
+				width: `${opts.width}px`,
+				padding: `${opts.padding}px`,
+				maxWidth: 'auto',
+			})
+			return [{ box, text: textToMeasure }]
+		}
+	}
+
+	elm: HTMLDivElement
+	bounds = { x: 0, y: 0, top: 0, left: 0, width: 1080, height: 720, bottom: 720, right: 1080 }
+
+	setScreenBounds(bounds: Box2dModel, center = false) {
+		this.bounds.x = bounds.x
+		this.bounds.y = bounds.y
+		this.bounds.top = bounds.y
+		this.bounds.left = bounds.x
+		this.bounds.width = bounds.w
+		this.bounds.height = bounds.h
+		this.bounds.right = bounds.x + bounds.w
+		this.bounds.bottom = bounds.y + bounds.h
+
+		this.updateViewportScreenBounds(center)
+		this.updateRenderingBounds()
+		return this
+	}
+
+	clipboard = null as TLContent | null
+
+	copy = (ids = this.selectedIds) => {
+		if (ids.length > 0) {
+			const content = this.getContent()
+			if (content) {
+				this.clipboard = content
+			}
+		}
+		return this
+	}
+
+	cut = (ids = this.selectedIds) => {
+		if (ids.length > 0) {
+			const content = this.getContent()
+			if (content) {
+				this.clipboard = content
+			}
+			this.deleteShapes(ids)
+		}
+		return this
+	}
+
+	paste = (point?: VecLike) => {
+		if (this.clipboard !== null) {
+			const p = this.inputs.shiftKey ? this.inputs.currentPagePoint : point
+
+			this.mark('pasting')
+			this.putContent(this.clipboard, {
+				point: p,
+				select: true,
+			})
+		}
+		return this
+	}
+
+	/**
+	 * If you need to trigger a double click, you can either mock the implementation of one of these
+	 * methods, or call mockRestore() to restore the actual implementation (e.g.
+	 * _transformPointerDownSpy.mockRestore())
+	 */
+	_transformPointerDownSpy = jest
+		.spyOn(this._clickManager, 'transformPointerDownEvent')
+		.mockImplementation((info) => {
+			return info
+		})
+	_transformPointerUpSpy = jest
+		.spyOn(this._clickManager, 'transformPointerDownEvent')
+		.mockImplementation((info) => {
+			return info
+		})
+
+	testShapeID(id: string) {
+		return createShapeId(id)
+	}
+	testPageID(id: string) {
+		return PageRecordType.createId(id)
+	}
+
+	expectToBeIn = (path: string) => {
+		expect(this.root.current.value!.path.value).toBe(path)
+		return this
+	}
+
+	expectPathToBe = (path: string) => {
+		expect(this.root.path.value).toBe(path)
+		return this
+	}
+
+	expectCameraToBe(x: number, y: number, z: number) {
+		const camera = this.camera
+
+		expect({
+			x: +camera.x.toFixed(2),
+			y: +camera.y.toFixed(2),
+			z: +camera.z.toFixed(2),
+		}).toCloselyMatchObject({ x, y, z })
+	}
+
+	expectShapeToMatch = (...model: RequiredKeys<TLShapePartial, 'id'>[]) => {
+		model.forEach((model) => {
+			const shape = this.getShapeById(model.id)!
+			const next = { ...shape, ...model }
+			expect(shape).toCloselyMatchObject(next)
+		})
+		return this
+	}
+
+	/* --------------------- Inputs --------------------- */
+
+	protected getInfo = <T extends TLEventInfo>(info: string | T): T => {
+		return typeof info === 'string'
+			? ({
+					target: 'shape',
+					shape: this.getShapeById(info as any),
+			  } as T)
+			: info
+	}
+
+	protected getPointerEventInfo = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: Partial<TLPointerEventInfo> | TLShapeId,
+		modifiers?: EventModifiers
+	): TLPointerEventInfo => {
+		if (typeof options === 'string') {
+			options = { target: 'shape', shape: this.getShapeById(options) }
+		} else if (options === undefined) {
+			options = { target: 'canvas' }
+		}
+		return {
+			name: 'pointer_down',
+			type: 'pointer',
+			pointerId: 1,
+			shiftKey: this.inputs.shiftKey,
+			ctrlKey: this.inputs.ctrlKey,
+			altKey: this.inputs.altKey,
+			point: { x, y, z: null },
+			button: 0,
+			isPen: false,
+			...options,
+			...modifiers,
+		} as TLPointerEventInfo
+	}
+
+	protected getKeyboardEventInfo = (
+		key: string,
+		name: TLKeyboardEventInfo['name'],
+		options = {} as Partial<Exclude<TLKeyboardEventInfo, 'point'>>
+	): TLKeyboardEventInfo => {
+		return {
+			shiftKey: key === 'Shift',
+			ctrlKey: key === 'Control' || key === 'Meta',
+			altKey: key === 'Alt',
+			...options,
+			name,
+			code:
+				key === 'Shift'
+					? 'ShiftLeft'
+					: key === 'Alt'
+					? 'AltLeft'
+					: key === 'Control' || key === 'Meta'
+					? 'CtrlLeft'
+					: key === ' '
+					? 'Space'
+					: key === 'Enter' ||
+					  key === 'ArrowRight' ||
+					  key === 'ArrowLeft' ||
+					  key === 'ArrowUp' ||
+					  key === 'ArrowDown'
+					? key
+					: 'Key' + key[0].toUpperCase() + key.slice(1),
+			type: 'keyboard',
+			key,
+		}
+	}
+
+	/* ------------------ Input Events ------------------ */
+
+	pointerMove = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_move',
+		})
+		return this
+	}
+
+	pointerDown = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_down',
+		})
+		return this
+	}
+
+	pointerUp = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_up',
+		})
+		return this
+	}
+
+	pointerEnter = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_enter',
+		})
+		return this
+	}
+
+	pointerLeave = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_leave',
+		})
+		return this
+	}
+
+	click = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.pointerDown(x, y, options, modifiers)
+		this.pointerUp(x, y, options, modifiers)
+		return this
+	}
+
+	doubleClick = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.pointerDown(x, y, options, modifiers)
+		this.pointerUp(x, y, options, modifiers)
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			type: 'click',
+			name: 'double_click',
+			phase: 'down',
+		})
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			type: 'click',
+			name: 'double_click',
+			phase: 'up',
+		})
+		return this
+	}
+
+	keyDown = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
+		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_down', options) })
+		return this
+	}
+
+	keyRepeat = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
+		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_repeat', options) })
+		return this
+	}
+
+	keyUp = (key: string, options = {} as Partial<Omit<TLKeyboardEventInfo, 'key'>>) => {
+		this.dispatch({
+			...this.getKeyboardEventInfo(key, 'key_up', {
+				shiftKey: this.inputs.shiftKey && key !== 'Shift',
+				ctrlKey: this.inputs.ctrlKey && !(key === 'Control' || key === 'Meta'),
+				altKey: this.inputs.altKey && key !== 'Alt',
+				...options,
+			}),
+		})
+		return this
+	}
+
+	wheel = (dx: number, dy: number, options = {} as Partial<Omit<TLWheelEventInfo, 'delta'>>) => {
+		this.dispatch({
+			type: 'wheel',
+			name: 'wheel',
+			shiftKey: this.inputs.shiftKey,
+			ctrlKey: this.inputs.ctrlKey,
+			altKey: this.inputs.altKey,
+			...options,
+			delta: { x: dx, y: dy },
+		})
+		return this
+	}
+
+	pinchStart = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		z: number,
+		dx: number,
+		dy: number,
+		dz: number,
+		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
+	) => {
+		this.dispatch({
+			type: 'pinch',
+			name: 'pinch_start',
+			shiftKey: this.inputs.shiftKey,
+			ctrlKey: this.inputs.ctrlKey,
+			altKey: this.inputs.altKey,
+			...options,
+			point: { x, y, z },
+			delta: { x: dx, y: dy, z: dz },
+		})
+		return this
+	}
+
+	pinchTo = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		z: number,
+		dx: number,
+		dy: number,
+		dz: number,
+		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
+	) => {
+		this.dispatch({
+			type: 'pinch',
+			name: 'pinch_start',
+			shiftKey: this.inputs.shiftKey,
+			ctrlKey: this.inputs.ctrlKey,
+			altKey: this.inputs.altKey,
+			...options,
+			point: { x, y, z },
+			delta: { x: dx, y: dy, z: dz },
+		})
+		return this
+	}
+
+	pinchEnd = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		z: number,
+		dx: number,
+		dy: number,
+		dz: number,
+		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
+	) => {
+		this.dispatch({
+			type: 'pinch',
+			name: 'pinch_end',
+			shiftKey: this.inputs.shiftKey,
+			ctrlKey: this.inputs.ctrlKey,
+			altKey: this.inputs.altKey,
+			...options,
+			point: { x, y, z },
+			delta: { x: dx, y: dy, z: dz },
+		})
+		return this
+	}
+	/* ------ Interaction Helpers ------ */
+
+	rotateSelection(
+		angleRadians: number,
+		{
+			handle = 'top_left_rotate',
+			shiftKey = false,
+		}: { handle?: RotateCorner; shiftKey?: boolean } = {}
+	) {
+		if (this.selectedIds.length === 0) {
+			throw new Error('No selection')
+		}
+
+		this.setCurrentTool('select')
+
+		const handlePoint = this.selectionBounds!.getHandlePoint(
+			ROTATE_CORNER_TO_SELECTION_CORNER[handle]
+		)
+			.clone()
+			.rotWith(this.selectionBounds!.point, this.selectionRotation)
+
+		const targetHandlePoint = Vec2d.RotWith(handlePoint, this.selectionPageCenter!, angleRadians)
+
+		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle })
+		this.pointerMove(targetHandlePoint.x, targetHandlePoint.y, { shiftKey })
+		this.pointerUp()
+		return this
+	}
+
+	translateSelection(dx: number, dy: number, options?: Partial<TLPointerEventInfo>) {
+		if (this.selectedIds.length === 0) {
+			throw new Error('No selection')
+		}
+		this.setCurrentTool('select')
+
+		const center = this.selectionPageCenter!
+
+		this.pointerDown(center.x, center.y, this.selectedIds[0])
+		const numSteps = 10
+		for (let i = 1; i < numSteps; i++) {
+			this.pointerMove(center.x + (i * dx) / numSteps, center.y + (i * dy) / numSteps, options)
+		}
+		this.pointerUp(center.x + dx, center.y + dy, options)
+		return this
+	}
+
+	resizeSelection(
+		{ scaleX = 1, scaleY = 1 },
+		handle: SelectionHandle,
+		options?: Partial<TLPointerEventInfo>
+	) {
+		if (this.selectedIds.length === 0) {
+			throw new Error('No selection')
+		}
+		this.setCurrentTool('select')
+		const bounds = this.selectionBounds!
+		const preRotationHandlePoint = bounds.getHandlePoint(handle)
+
+		const preRotationScaleOriginPoint = options?.altKey
+			? bounds.center
+			: bounds.getHandlePoint(rotateSelectionHandle(handle, Math.PI))
+
+		const preRotationTargetHandlePoint = Vec2d.Add(
+			Vec2d.Sub(preRotationHandlePoint, preRotationScaleOriginPoint).mulV({ x: scaleX, y: scaleY }),
+			preRotationScaleOriginPoint
+		)
+
+		const handlePoint = Vec2d.RotWith(preRotationHandlePoint, bounds.point, this.selectionRotation)
+		const targetHandlePoint = Vec2d.RotWith(
+			preRotationTargetHandlePoint,
+			bounds.point,
+			this.selectionRotation
+		)
+
+		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle }, options)
+		this.pointerMove(targetHandlePoint.x, targetHandlePoint.y, options)
+		this.pointerUp(targetHandlePoint.x, targetHandlePoint.y, options)
+		return this
+	}
+
+	createShapesFromJsx(shapesJsx: JSX.Element | JSX.Element[]): Record<string, TLShapeId> {
+		const { shapes, ids } = shapesFromJsx(shapesJsx)
+		this.createShapes(shapes)
+		return ids
+	}
+
+	static CreateShapeId(id?: string) {
+		return id ? createShapeId(id) : createShapeId()
+	}
+}
+
+export const defaultShapesIds = {
+	box1: createShapeId('box1'),
+	box2: createShapeId('box2'),
+	ellipse1: createShapeId('ellipse1'),
+}
+
+export const createDefaultShapes = (): TLShapePartial[] => [
+	{
+		id: defaultShapesIds.box1,
+		type: 'geo',
+		x: 100,
+		y: 100,
+		props: {
+			w: 100,
+			h: 100,
+			geo: 'rectangle',
+		},
+	},
+	{
+		id: defaultShapesIds.box2,
+		type: 'geo',
+		x: 200,
+		y: 200,
+		rotation: TAU / 2,
+		props: {
+			w: 100,
+			h: 100,
+			color: 'black',
+			fill: 'none',
+			dash: 'draw',
+			size: 'm',
+			geo: 'rectangle',
+		},
+	},
+	{
+		id: defaultShapesIds.ellipse1,
+		type: 'geo',
+		parentId: defaultShapesIds.box2,
+		x: 200,
+		y: 200,
+		props: {
+			w: 50,
+			h: 50,
+			color: 'black',
+			fill: 'none',
+			dash: 'draw',
+			size: 'm',
+			geo: 'ellipse',
+		},
+	},
+]
+
+type PointerEventInit = Partial<TLPointerEventInfo> | TLShapeId
+type EventModifiers = Partial<Pick<TLPointerEventInfo, 'shiftKey' | 'ctrlKey' | 'altKey'>>

commit 3e31ef2a7d01467ef92ca4f7aed13ee708db73ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 18 22:50:23 2023 +0100

    Remove helpers / extraneous API methods. (#1745)
    
    This PR removes several extraneous computed values from the editor. It
    adds some silly instance state onto the instance state record and
    unifies a few methods which were inconsistent. This is fit and finish
    work üßΩ
    
    ## Computed Values
    
    In general, where once we had a getter and setter for `isBlahMode`,
    which really masked either an `_isBlahMode` atom on the editor or
    `instanceState.isBlahMode`, these are merged into `instanceState`; they
    can be accessed / updated via `editor.instanceState` /
    `editor.updateInstanceState`.
    
    ## tldraw select tool specific things
    
    This PR also removes some tldraw specific state checks and creates new
    component overrides to allow us to include them in tldraw/tldraw.
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [tldraw] rename `useReadonly` to `useReadOnly`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isChangingStyle`
    - [editor] remove `Editor.isCoarsePointer`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isFocused`
    - [editor] remove `Editor.isGridMode`
    - [editor] remove `Editor.isPenMode`
    - [editor] remove `Editor.isReadOnly`
    - [editor] remove `Editor.isSnapMode`
    - [editor] remove `Editor.isToolLocked`
    - [editor] remove `Editor.locale`
    - [editor] rename `Editor.pageState` to `Editor.currentPageState`
    - [editor] add `Editor.pageStates`
    - [editor] add `Editor.setErasingIds`
    - [editor] add `Editor.setEditingId`
    - [editor] add several new component overrides

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index eb5e48375..64d197bb5 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -573,10 +573,6 @@ export class TestEditor extends Editor {
 		this.createShapes(shapes)
 		return ids
 	}
-
-	static CreateShapeId(id?: string) {
-		return id ? createShapeId(id) : createShapeId()
-	}
 }
 
 export const defaultShapesIds = {

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape‚Äîbut not focusing its input‚Äîwhile editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 64d197bb5..9c7ca27e1 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -1,6 +1,7 @@
 import {
 	Box2dModel,
 	Editor,
+	Matrix2d,
 	PageRecordType,
 	ROTATE_CORNER_TO_SELECTION_CORNER,
 	RequiredKeys,
@@ -13,6 +14,7 @@ import {
 	TLKeyboardEventInfo,
 	TLPinchEventInfo,
 	TLPointerEventInfo,
+	TLShape,
 	TLShapeId,
 	TLShapePartial,
 	TLWheelEventInfo,
@@ -132,9 +134,9 @@ export class TestEditor extends Editor {
 
 	clipboard = null as TLContent | null
 
-	copy = (ids = this.selectedIds) => {
+	copy = (ids = this.selectedShapeIds) => {
 		if (ids.length > 0) {
-			const content = this.getContent()
+			const content = this.getContent(ids)
 			if (content) {
 				this.clipboard = content
 			}
@@ -142,9 +144,9 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	cut = (ids = this.selectedIds) => {
+	cut = (ids = this.selectedShapeIds) => {
 		if (ids.length > 0) {
-			const content = this.getContent()
+			const content = this.getContent(ids)
 			if (content) {
 				this.clipboard = content
 			}
@@ -211,7 +213,7 @@ export class TestEditor extends Editor {
 
 	expectShapeToMatch = (...model: RequiredKeys<TLShapePartial, 'id'>[]) => {
 		model.forEach((model) => {
-			const shape = this.getShapeById(model.id)!
+			const shape = this.getShape(model.id)!
 			const next = { ...shape, ...model }
 			expect(shape).toCloselyMatchObject(next)
 		})
@@ -224,7 +226,7 @@ export class TestEditor extends Editor {
 		return typeof info === 'string'
 			? ({
 					target: 'shape',
-					shape: this.getShapeById(info as any),
+					shape: this.getShape(info as any),
 			  } as T)
 			: info
 	}
@@ -236,7 +238,7 @@ export class TestEditor extends Editor {
 		modifiers?: EventModifiers
 	): TLPointerEventInfo => {
 		if (typeof options === 'string') {
-			options = { target: 'shape', shape: this.getShapeById(options) }
+			options = { target: 'shape', shape: this.getShape(options) }
 		} else if (options === undefined) {
 			options = { target: 'canvas' }
 		}
@@ -328,32 +330,6 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pointerEnter = (
-		x = this.inputs.currentScreenPoint.x,
-		y = this.inputs.currentScreenPoint.y,
-		options?: PointerEventInit,
-		modifiers?: EventModifiers
-	) => {
-		this.dispatch({
-			...this.getPointerEventInfo(x, y, options, modifiers),
-			name: 'pointer_enter',
-		})
-		return this
-	}
-
-	pointerLeave = (
-		x = this.inputs.currentScreenPoint.x,
-		y = this.inputs.currentScreenPoint.y,
-		options?: PointerEventInit,
-		modifiers?: EventModifiers
-	) => {
-		this.dispatch({
-			...this.getPointerEventInfo(x, y, options, modifiers),
-			name: 'pointer_leave',
-		})
-		return this
-	}
-
 	click = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
@@ -497,7 +473,7 @@ export class TestEditor extends Editor {
 			shiftKey = false,
 		}: { handle?: RotateCorner; shiftKey?: boolean } = {}
 	) {
-		if (this.selectedIds.length === 0) {
+		if (this.selectedShapeIds.length === 0) {
 			throw new Error('No selection')
 		}
 
@@ -518,14 +494,14 @@ export class TestEditor extends Editor {
 	}
 
 	translateSelection(dx: number, dy: number, options?: Partial<TLPointerEventInfo>) {
-		if (this.selectedIds.length === 0) {
+		if (this.selectedShapeIds.length === 0) {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')
 
 		const center = this.selectionPageCenter!
 
-		this.pointerDown(center.x, center.y, this.selectedIds[0])
+		this.pointerDown(center.x, center.y, this.selectedShapeIds[0])
 		const numSteps = 10
 		for (let i = 1; i < numSteps; i++) {
 			this.pointerMove(center.x + (i * dx) / numSteps, center.y + (i * dy) / numSteps, options)
@@ -539,7 +515,7 @@ export class TestEditor extends Editor {
 		handle: SelectionHandle,
 		options?: Partial<TLPointerEventInfo>
 	) {
-		if (this.selectedIds.length === 0) {
+		if (this.selectedShapeIds.length === 0) {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')
@@ -573,6 +549,47 @@ export class TestEditor extends Editor {
 		this.createShapes(shapes)
 		return ids
 	}
+
+	/**
+	 * Get the page point (or absolute point) of a shape.
+	 *
+	 * @example
+	 * ```ts
+	 * editor.getPagePoint(myShape)
+	 * ```
+	 *
+	 * @param shape - The shape to get the page point for.
+	 *
+	 * @public
+	 */
+	getPageCenter(shape: TLShape) {
+		const pageTransform = this.getPageTransform(shape.id)
+		if (!pageTransform) return null
+		const center = this.getGeometry(shape).bounds.center
+		return Matrix2d.applyToPoint(pageTransform, center)
+	}
+
+	/**
+	 * Get the page rotation (or absolute rotation) of a shape by its id.
+	 *
+	 * @example
+	 * ```ts
+	 * editor.getPageRotationById(myShapeId)
+	 * ```
+	 *
+	 * @param id - The id of the shape to get the page rotation for.
+	 */
+	getPageRotationById(id: TLShapeId): number {
+		const pageTransform = this.getPageTransform(id)
+		if (pageTransform) {
+			return Matrix2d.Decompose(pageTransform).rotation
+		}
+		return 0
+	}
+
+	getPageRotation(shape: TLShape) {
+		return this.getPageRotationById(shape.id)
+	}
 }
 
 export const defaultShapesIds = {

commit 7e4fb59a486d6f5ae20743130f1cb52c2782617e
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 27 16:17:50 2023 +0100

    remove `selectionPageCenter` (#1766)
    
    This PR removes `Editor.selectionPageCenter` and moves its
    implementation inline where used (in two places).
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Release Notes
    
    - [dev] Removes `Editor.selectionPageCenter`

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 9c7ca27e1..cddc7c275 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -493,6 +493,18 @@ export class TestEditor extends Editor {
 		return this
 	}
 
+	/**
+	 * The center of the selection bounding box.
+	 *
+	 * @readonly
+	 * @public
+	 */
+	get selectionPageCenter() {
+		const { selectionBounds, selectionRotation } = this
+		if (!selectionBounds) return null
+		return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
+	}
+
 	translateSelection(dx: number, dy: number, options?: Partial<TLPointerEventInfo>) {
 		if (this.selectedShapeIds.length === 0) {
 			throw new Error('No selection')

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index cddc7c275..779e1506b 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -479,11 +479,11 @@ export class TestEditor extends Editor {
 
 		this.setCurrentTool('select')
 
-		const handlePoint = this.selectionBounds!.getHandlePoint(
+		const handlePoint = this.selectionRotatedPageBounds!.getHandlePoint(
 			ROTATE_CORNER_TO_SELECTION_CORNER[handle]
 		)
 			.clone()
-			.rotWith(this.selectionBounds!.point, this.selectionRotation)
+			.rotWith(this.selectionRotatedPageBounds!.point, this.selectionRotation)
 
 		const targetHandlePoint = Vec2d.RotWith(handlePoint, this.selectionPageCenter!, angleRadians)
 
@@ -500,7 +500,7 @@ export class TestEditor extends Editor {
 	 * @public
 	 */
 	get selectionPageCenter() {
-		const { selectionBounds, selectionRotation } = this
+		const { selectionRotatedPageBounds: selectionBounds, selectionRotation } = this
 		if (!selectionBounds) return null
 		return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
 	}
@@ -531,7 +531,7 @@ export class TestEditor extends Editor {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')
-		const bounds = this.selectionBounds!
+		const bounds = this.selectionRotatedPageBounds!
 		const preRotationHandlePoint = bounds.getHandlePoint(handle)
 
 		const preRotationScaleOriginPoint = options?.altKey
@@ -575,9 +575,9 @@ export class TestEditor extends Editor {
 	 * @public
 	 */
 	getPageCenter(shape: TLShape) {
-		const pageTransform = this.getPageTransform(shape.id)
+		const pageTransform = this.getShapePageTransform(shape.id)
 		if (!pageTransform) return null
-		const center = this.getGeometry(shape).bounds.center
+		const center = this.getShapeGeometry(shape).bounds.center
 		return Matrix2d.applyToPoint(pageTransform, center)
 	}
 
@@ -592,7 +592,7 @@ export class TestEditor extends Editor {
 	 * @param id - The id of the shape to get the page rotation for.
 	 */
 	getPageRotationById(id: TLShapeId): number {
-		const pageTransform = this.getPageTransform(id)
+		const pageTransform = this.getShapePageTransform(id)
 		if (pageTransform) {
 			return Matrix2d.Decompose(pageTransform).rotation
 		}

commit 89914684467c1e18ef06fa702c82ed0f88a2ea09
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Aug 5 12:21:07 2023 +0100

    history options / markId / createPage (#1796)
    
    This PR:
    
    - adds history options to several commands in order to allow them to
    support squashing and ephemeral data (previously, these commands had
    boolean values for squashing / ephemeral)
    
    It also:
    - changes `markId` to return the editor instance rather than the mark id
    passed into the command
    - removes `focus` and `blur` commands
    - changes `createPage` parameters
    - unifies `animateShape` / `animateShapes` options
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 779e1506b..8595e6a48 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -136,7 +136,7 @@ export class TestEditor extends Editor {
 
 	copy = (ids = this.selectedShapeIds) => {
 		if (ids.length > 0) {
-			const content = this.getContent(ids)
+			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
 				this.clipboard = content
 			}
@@ -146,7 +146,7 @@ export class TestEditor extends Editor {
 
 	cut = (ids = this.selectedShapeIds) => {
 		if (ids.length > 0) {
-			const content = this.getContent(ids)
+			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
 				this.clipboard = content
 			}
@@ -160,7 +160,7 @@ export class TestEditor extends Editor {
 			const p = this.inputs.shiftKey ? this.inputs.currentPagePoint : point
 
 			this.mark('pasting')
-			this.putContent(this.clipboard, {
+			this.putContentOntoCurrentPage(this.clipboard, {
 				point: p,
 				select: true,
 			})

commit f73bf9a7fea4ca6922b8effa10412fbb9f77c288
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Oct 2 12:30:53 2023 +0100

    Fix text-wrapping on Safari (#1980)
    
    Co-authored-by: Alex Alex@dytry.ch
    
    closes [#1978](https://github.com/tldraw/tldraw/issues/1978)
    
    Text was wrapping on Safari because the measure text div was rendered
    differently on different browsers. Interestingly, when forcing the
    text-measure div to be visible and on-screen in Chrome, the same
    text-wrapping behaviour was apparent. By setting white-space to 'pre'
    when width hasn't been set by the user, we can ensure that only line
    breaks the user has inputted are rendered by default on all browsers.
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. On Safari
    2. Make a new text shape and start typing
    3. At a certain point the text starts to wrap without the width having
    been set
    
    
    ### Release Notes
    
    - Fix text wrapping differently on Safari and Chrome/Firefox
    
    Before/After
    
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/320171b4-61e0-4a41-b8d3-830bd90bea65">
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/b42d7156-0ce9-4894-9692-9338dc931b79">

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 8595e6a48..d5d953c71 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -81,7 +81,7 @@ export class TestEditor extends Editor {
 				fontFamily: string
 				fontSize: number
 				lineHeight: number
-				width: string
+				width: null | number
 				maxWidth: string
 			}
 		): Box2dModel => {
@@ -95,18 +95,17 @@ export class TestEditor extends Editor {
 			return {
 				x: 0,
 				y: 0,
-				w: opts.width.includes('px') ? Math.max(w, +opts.width.replace('px', '')) : w,
+				w: opts.width === null ? w : Math.max(w, opts.width),
 				h:
-					(opts.width.includes('px')
-						? Math.ceil(w % +opts.width.replace('px', '')) + breaks.length
-						: breaks.length) * opts.fontSize,
+					(opts.width === null ? breaks.length : Math.ceil(w % opts.width) + breaks.length) *
+					opts.fontSize,
 			}
 		}
 
 		this.textMeasure.measureTextSpans = (textToMeasure, opts) => {
 			const box = this.textMeasure.measureText(textToMeasure, {
 				...opts,
-				width: `${opts.width}px`,
+				width: opts.width,
 				padding: `${opts.padding}px`,
 				maxWidth: 'auto',
 			})

commit 92886e1f40670018589d2c14dced119e47f8e6d1
Author: alex <alex@dytry.ch>
Date:   Tue Oct 3 15:26:13 2023 +0100

    fix text in geo shapes not causing its container to grow (#2003)
    
    We got things sliggghhhtly wrong in #1980. That diff was attempting to
    fix a bug where the text measurement element would refuse to go above
    the viewport size in safari. This was most obvious in the case where
    there was no fixed width on a text shape, and that diff fixed that case,
    but it was also happening when a fixed width text shape was wider than
    viewport - which wasn't covered by that fix. It turned out that that fix
    also introduced a bug where shapes would no longer grow along the y-axis
    - in part because the relationship between `width`, `maxWidth`, and
    `minWidth` is very confusing.
    
    The one-liner fix is to just use `max-content` instead of `fit-content`
    - that way, the div ignores the size of its container. But I also
    cleared up the API for text measurement to remove the `width` property
    entirely in favour of `maxWidth`. I think this makes things much clearer
    and as far as I can tell doesn't affect anything.
    
    Closes #1998
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    
    ### Test Plan
    
    1. Create an arrow & geo shape with labels, plus a note and text shape
    2. Try to break text measurement - overflow the bounds, make very wide
    text, experiment with fixed/auto-size text, etc.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index d5d953c71..e71c5db48 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -81,8 +81,7 @@ export class TestEditor extends Editor {
 				fontFamily: string
 				fontSize: number
 				lineHeight: number
-				width: null | number
-				maxWidth: string
+				maxWidth: null | number
 			}
 		): Box2dModel => {
 			const breaks = textToMeasure.split('\n')
@@ -95,9 +94,9 @@ export class TestEditor extends Editor {
 			return {
 				x: 0,
 				y: 0,
-				w: opts.width === null ? w : Math.max(w, opts.width),
+				w: opts.maxWidth === null ? w : Math.max(w, opts.maxWidth),
 				h:
-					(opts.width === null ? breaks.length : Math.ceil(w % opts.width) + breaks.length) *
+					(opts.maxWidth === null ? breaks.length : Math.ceil(w % opts.maxWidth) + breaks.length) *
 					opts.fontSize,
 			}
 		}
@@ -105,9 +104,8 @@ export class TestEditor extends Editor {
 		this.textMeasure.measureTextSpans = (textToMeasure, opts) => {
 			const box = this.textMeasure.measureText(textToMeasure, {
 				...opts,
-				width: opts.width,
+				maxWidth: opts.width,
 				padding: `${opts.padding}px`,
-				maxWidth: 'auto',
 			})
 			return [{ box, text: textToMeasure }]
 		}

commit 4af92421b3ad1258bdfa6581defd55afcc7f7979
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Tue Nov 7 14:51:28 2023 +0100

    Zooming improvement (#2149)
    
    This improves how zooming works when we zoom in an inactive window. With
    this change you should zoom towards the pointer position, while before
    it zoomed towards the last known pointer position before the window
    became inactive.
    
    Fixes #2165
    
    Before
    
    
    https://github.com/tldraw/tldraw/assets/2523721/50018782-533a-43bb-88a5-21fc4419b723
    
    After
    
    
    https://github.com/tldraw/tldraw/assets/2523721/c3859f84-ef56-4db8-96b9-50a2de060507
    
    
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Open the tldraw editor.
    2. Click away from the browser window so that it's not longer active.
    3. Hover over the browser window and start zooming.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Improves zooming for inactive windows.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index e71c5db48..d2415540a 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -387,6 +387,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			type: 'wheel',
 			name: 'wheel',
+			point: new Vec2d(this.inputs.currentScreenPoint.x, this.inputs.currentScreenPoint.y),
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,

commit 5db3c1553e14edd14aa5f7c0fc85fc5efc352335
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Nov 13 11:51:22 2023 +0000

    Replace Atom.value with Atom.get() (#2189)
    
    This PR replaces the `.value` getter for the atom with `.get()`
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index d2415540a..95d76ed6a 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -189,12 +189,12 @@ export class TestEditor extends Editor {
 	}
 
 	expectToBeIn = (path: string) => {
-		expect(this.root.current.value!.path.value).toBe(path)
+		expect(this.root.current.get()!.path.get()).toBe(path)
 		return this
 	}
 
 	expectPathToBe = (path: string) => {
-		expect(this.root.path.value).toBe(path)
+		expect(this.root.path.get()).toBe(path)
 		return this
 	}
 

commit 2ca2f81f2aac16790c73bd334eda53a35a9d9f45
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 12:42:07 2023 +0000

    No impure getters pt2 (#2202)
    
    follow up to #2189

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 95d76ed6a..eeb176f48 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -131,7 +131,7 @@ export class TestEditor extends Editor {
 
 	clipboard = null as TLContent | null
 
-	copy = (ids = this.selectedShapeIds) => {
+	copy = (ids = this.getSelectedShapeIds()) => {
 		if (ids.length > 0) {
 			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
@@ -141,7 +141,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	cut = (ids = this.selectedShapeIds) => {
+	cut = (ids = this.getSelectedShapeIds()) => {
 		if (ids.length > 0) {
 			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
@@ -471,7 +471,7 @@ export class TestEditor extends Editor {
 			shiftKey = false,
 		}: { handle?: RotateCorner; shiftKey?: boolean } = {}
 	) {
-		if (this.selectedShapeIds.length === 0) {
+		if (this.getSelectedShapeIds().length === 0) {
 			throw new Error('No selection')
 		}
 
@@ -504,14 +504,14 @@ export class TestEditor extends Editor {
 	}
 
 	translateSelection(dx: number, dy: number, options?: Partial<TLPointerEventInfo>) {
-		if (this.selectedShapeIds.length === 0) {
+		if (this.getSelectedShapeIds().length === 0) {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')
 
 		const center = this.selectionPageCenter!
 
-		this.pointerDown(center.x, center.y, this.selectedShapeIds[0])
+		this.pointerDown(center.x, center.y, this.getSelectedShapeIds()[0])
 		const numSteps = 10
 		for (let i = 1; i < numSteps; i++) {
 			this.pointerMove(center.x + (i * dx) / numSteps, center.y + (i * dy) / numSteps, options)
@@ -525,7 +525,7 @@ export class TestEditor extends Editor {
 		handle: SelectionHandle,
 		options?: Partial<TLPointerEventInfo>
 	) {
-		if (this.selectedShapeIds.length === 0) {
+		if (this.getSelectedShapeIds().length === 0) {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')

commit daf729d45c879d4e234d9417570149ad854f635b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 16:02:50 2023 +0000

    No impure getters pt4 (#2206)
    
    follow up to #2189 and #2203
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index eeb176f48..38eef2cac 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -477,11 +477,10 @@ export class TestEditor extends Editor {
 
 		this.setCurrentTool('select')
 
-		const handlePoint = this.selectionRotatedPageBounds!.getHandlePoint(
-			ROTATE_CORNER_TO_SELECTION_CORNER[handle]
-		)
+		const handlePoint = this.getSelectionRotatedPageBounds()!
+			.getHandlePoint(ROTATE_CORNER_TO_SELECTION_CORNER[handle])
 			.clone()
-			.rotWith(this.selectionRotatedPageBounds!.point, this.selectionRotation)
+			.rotWith(this.getSelectionRotatedPageBounds()!.point, this.getSelectionRotation())
 
 		const targetHandlePoint = Vec2d.RotWith(handlePoint, this.selectionPageCenter!, angleRadians)
 
@@ -498,7 +497,8 @@ export class TestEditor extends Editor {
 	 * @public
 	 */
 	get selectionPageCenter() {
-		const { selectionRotatedPageBounds: selectionBounds, selectionRotation } = this
+		const selectionRotation = this.getSelectionRotation()
+		const selectionBounds = this.getSelectionRotatedPageBounds()
 		if (!selectionBounds) return null
 		return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
 	}
@@ -529,7 +529,7 @@ export class TestEditor extends Editor {
 			throw new Error('No selection')
 		}
 		this.setCurrentTool('select')
-		const bounds = this.selectionRotatedPageBounds!
+		const bounds = this.getSelectionRotatedPageBounds()!
 		const preRotationHandlePoint = bounds.getHandlePoint(handle)
 
 		const preRotationScaleOriginPoint = options?.altKey
@@ -541,11 +541,15 @@ export class TestEditor extends Editor {
 			preRotationScaleOriginPoint
 		)
 
-		const handlePoint = Vec2d.RotWith(preRotationHandlePoint, bounds.point, this.selectionRotation)
+		const handlePoint = Vec2d.RotWith(
+			preRotationHandlePoint,
+			bounds.point,
+			this.getSelectionRotation()
+		)
 		const targetHandlePoint = Vec2d.RotWith(
 			preRotationTargetHandlePoint,
 			bounds.point,
-			this.selectionRotation
+			this.getSelectionRotation()
 		)
 
 		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle }, options)

commit 9d783f65cb522f1fc8009e8f3923124d8db131d3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 10:23:03 2023 +0000

    No impure getters pt5 (#2208)
    
    Follow up to #2189
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 38eef2cac..c32586305 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -199,7 +199,7 @@ export class TestEditor extends Editor {
 	}
 
 	expectCameraToBe(x: number, y: number, z: number) {
-		const camera = this.camera
+		const camera = this.getCamera()
 
 		expect({
 			x: +camera.x.toFixed(2),

commit 7186368f0d4cb7fbe59a59ffa4265908e8f48eae
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Nov 14 13:02:50 2023 +0000

    StateNode atoms (#2213)
    
    This PR extracts some improvements from #2198 into a separate PR.
    
    ### Release Notes
    - adds computed `StateNode.getPath`
    - adds computed StateNode.getCurrent`
    - adds computed StateNode.getIsActive`
    - adds computed `Editor.getPath()`
    - makes transition's second property optional
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index c32586305..28b5858cd 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -189,12 +189,7 @@ export class TestEditor extends Editor {
 	}
 
 	expectToBeIn = (path: string) => {
-		expect(this.root.current.get()!.path.get()).toBe(path)
-		return this
-	}
-
-	expectPathToBe = (path: string) => {
-		expect(this.root.path.get()).toBe(path)
+		expect(this.getPath()).toBe(path)
 		return this
 	}
 

commit 431ce73476f6116f3234b4d667fd3752f140ff89
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Nov 16 12:07:33 2023 +0000

    No impure getters pt10 (#2235)
    
    Follow up to #2189
    
    ### Change Type
    
    - [x] `patch` ‚Äî Bug fix

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 28b5858cd..09409315f 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -477,7 +477,11 @@ export class TestEditor extends Editor {
 			.clone()
 			.rotWith(this.getSelectionRotatedPageBounds()!.point, this.getSelectionRotation())
 
-		const targetHandlePoint = Vec2d.RotWith(handlePoint, this.selectionPageCenter!, angleRadians)
+		const targetHandlePoint = Vec2d.RotWith(
+			handlePoint,
+			this.getSelectionPageCenter()!,
+			angleRadians
+		)
 
 		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle })
 		this.pointerMove(targetHandlePoint.x, targetHandlePoint.y, { shiftKey })
@@ -491,7 +495,7 @@ export class TestEditor extends Editor {
 	 * @readonly
 	 * @public
 	 */
-	get selectionPageCenter() {
+	getSelectionPageCenter() {
 		const selectionRotation = this.getSelectionRotation()
 		const selectionBounds = this.getSelectionRotatedPageBounds()
 		if (!selectionBounds) return null
@@ -504,7 +508,7 @@ export class TestEditor extends Editor {
 		}
 		this.setCurrentTool('select')
 
-		const center = this.selectionPageCenter!
+		const center = this.getSelectionPageCenter()!
 
 		this.pointerDown(center.x, center.y, this.getSelectedShapeIds()[0])
 		const numSteps = 10

commit 4e50c9c16251f9d4ca7034f2519759e093a99dbf
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Sat Dec 16 00:37:03 2023 +0100

    Start scrolling if we are dragging close to the window edges. (#2299)
    
    Start scrolling when we get close to the edges of the window. This works
    for brush selecting, translating, and resizing.
    
    
    https://github.com/tldraw/tldraw/assets/2523721/4a5effc8-5445-411b-b317-36097233d36c
    
    
    ### Change Type
    
    - [ ] `patch` ‚Äî Bug fix
    - [x] `minor` ‚Äî New feature
    - [ ] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Select a shape.
    2. Move it towards the edge of the window. The camera position should
    change.
    3. Also try resizing, brush selecting.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Adds the logic to change the camera position when you get close to the
    edges of the window. This allows you to drag, resize, brush select past
    the edges of the current viewport.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 09409315f..e55e3c648 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -109,6 +109,9 @@ export class TestEditor extends Editor {
 			})
 			return [{ box, text: textToMeasure }]
 		}
+
+		// Turn off edge scrolling for tests. Tests that require this can turn it back on.
+		this.user.updateUserPreferences({ edgeScrollSpeed: 0 })
 	}
 
 	elm: HTMLDivElement

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index e55e3c648..48bcaaaa2 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -1,13 +1,13 @@
 import {
-	Box2dModel,
+	BoxModel,
 	Editor,
-	Matrix2d,
+	HALF_PI,
+	Mat,
 	PageRecordType,
 	ROTATE_CORNER_TO_SELECTION_CORNER,
 	RequiredKeys,
 	RotateCorner,
 	SelectionHandle,
-	TAU,
 	TLContent,
 	TLEditorOptions,
 	TLEventInfo,
@@ -18,7 +18,7 @@ import {
 	TLShapeId,
 	TLShapePartial,
 	TLWheelEventInfo,
-	Vec2d,
+	Vec,
 	VecLike,
 	createShapeId,
 	createTLStore,
@@ -83,7 +83,7 @@ export class TestEditor extends Editor {
 				lineHeight: number
 				maxWidth: null | number
 			}
-		): Box2dModel => {
+		): BoxModel => {
 			const breaks = textToMeasure.split('\n')
 			const longest = breaks.reduce((acc, curr) => {
 				return curr.length > acc.length ? curr : acc
@@ -117,7 +117,7 @@ export class TestEditor extends Editor {
 	elm: HTMLDivElement
 	bounds = { x: 0, y: 0, top: 0, left: 0, width: 1080, height: 720, bottom: 720, right: 1080 }
 
-	setScreenBounds(bounds: Box2dModel, center = false) {
+	setScreenBounds(bounds: BoxModel, center = false) {
 		this.bounds.x = bounds.x
 		this.bounds.y = bounds.y
 		this.bounds.top = bounds.y
@@ -385,7 +385,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			type: 'wheel',
 			name: 'wheel',
-			point: new Vec2d(this.inputs.currentScreenPoint.x, this.inputs.currentScreenPoint.y),
+			point: new Vec(this.inputs.currentScreenPoint.x, this.inputs.currentScreenPoint.y),
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
@@ -480,11 +480,7 @@ export class TestEditor extends Editor {
 			.clone()
 			.rotWith(this.getSelectionRotatedPageBounds()!.point, this.getSelectionRotation())
 
-		const targetHandlePoint = Vec2d.RotWith(
-			handlePoint,
-			this.getSelectionPageCenter()!,
-			angleRadians
-		)
+		const targetHandlePoint = Vec.RotWith(handlePoint, this.getSelectionPageCenter()!, angleRadians)
 
 		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle })
 		this.pointerMove(targetHandlePoint.x, targetHandlePoint.y, { shiftKey })
@@ -502,7 +498,7 @@ export class TestEditor extends Editor {
 		const selectionRotation = this.getSelectionRotation()
 		const selectionBounds = this.getSelectionRotatedPageBounds()
 		if (!selectionBounds) return null
-		return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
+		return Vec.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
 	}
 
 	translateSelection(dx: number, dy: number, options?: Partial<TLPointerEventInfo>) {
@@ -538,17 +534,17 @@ export class TestEditor extends Editor {
 			? bounds.center
 			: bounds.getHandlePoint(rotateSelectionHandle(handle, Math.PI))
 
-		const preRotationTargetHandlePoint = Vec2d.Add(
-			Vec2d.Sub(preRotationHandlePoint, preRotationScaleOriginPoint).mulV({ x: scaleX, y: scaleY }),
+		const preRotationTargetHandlePoint = Vec.Add(
+			Vec.Sub(preRotationHandlePoint, preRotationScaleOriginPoint).mulV({ x: scaleX, y: scaleY }),
 			preRotationScaleOriginPoint
 		)
 
-		const handlePoint = Vec2d.RotWith(
+		const handlePoint = Vec.RotWith(
 			preRotationHandlePoint,
 			bounds.point,
 			this.getSelectionRotation()
 		)
-		const targetHandlePoint = Vec2d.RotWith(
+		const targetHandlePoint = Vec.RotWith(
 			preRotationTargetHandlePoint,
 			bounds.point,
 			this.getSelectionRotation()
@@ -582,7 +578,7 @@ export class TestEditor extends Editor {
 		const pageTransform = this.getShapePageTransform(shape.id)
 		if (!pageTransform) return null
 		const center = this.getShapeGeometry(shape).bounds.center
-		return Matrix2d.applyToPoint(pageTransform, center)
+		return Mat.applyToPoint(pageTransform, center)
 	}
 
 	/**
@@ -598,7 +594,7 @@ export class TestEditor extends Editor {
 	getPageRotationById(id: TLShapeId): number {
 		const pageTransform = this.getShapePageTransform(id)
 		if (pageTransform) {
-			return Matrix2d.Decompose(pageTransform).rotation
+			return Mat.Decompose(pageTransform).rotation
 		}
 		return 0
 	}
@@ -631,7 +627,7 @@ export const createDefaultShapes = (): TLShapePartial[] => [
 		type: 'geo',
 		x: 200,
 		y: 200,
-		rotation: TAU / 2,
+		rotation: HALF_PI / 2,
 		props: {
 			w: 100,
 			h: 100,

commit 29044867dd2e49a3711e95c547fa9352e66720b9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 15 12:33:15 2024 +0000

    Add docs (#2470)
    
    This PR adds the docs app back into the tldraw monorepo.
    
    ## Deploying
    
    We'll want to update our deploy script to update the SOURCE_SHA to the
    newest release sha... and then deploy the docs pulling api.json files
    from that release. We _could_ update the docs on every push to main, but
    we don't have to unless something has changed. Right now there's no
    automated deployments from this repo.
    
    ## Side effects
    
    To make this one work, I needed to update the lock file. This might be
    ok (new year new lock file), and everything builds as expected, though
    we may want to spend some time with our scripts to be sure that things
    are all good.
    
    I also updated our prettier installation, which decided to add trailing
    commas to every generic type. Which is, I suppose, [correct
    behavior](https://github.com/prettier/prettier-vscode/issues/955)? But
    that caused diffs in every file, which is unfortunate.
    
    ### Change Type
    
    - [x] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 48bcaaaa2..4f388b997 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -222,7 +222,7 @@ export class TestEditor extends Editor {
 			? ({
 					target: 'shape',
 					shape: this.getShape(info as any),
-			  } as T)
+				} as T)
 			: info
 	}
 
@@ -267,18 +267,18 @@ export class TestEditor extends Editor {
 				key === 'Shift'
 					? 'ShiftLeft'
 					: key === 'Alt'
-					? 'AltLeft'
-					: key === 'Control' || key === 'Meta'
-					? 'CtrlLeft'
-					: key === ' '
-					? 'Space'
-					: key === 'Enter' ||
-					  key === 'ArrowRight' ||
-					  key === 'ArrowLeft' ||
-					  key === 'ArrowUp' ||
-					  key === 'ArrowDown'
-					? key
-					: 'Key' + key[0].toUpperCase() + key.slice(1),
+						? 'AltLeft'
+						: key === 'Control' || key === 'Meta'
+							? 'CtrlLeft'
+							: key === ' '
+								? 'Space'
+								: key === 'Enter' ||
+									  key === 'ArrowRight' ||
+									  key === 'ArrowLeft' ||
+									  key === 'ArrowUp' ||
+									  key === 'ArrowDown'
+									? key
+									: 'Key' + key[0].toUpperCase() + key.slice(1),
 			type: 'keyboard',
 			key,
 		}
@@ -556,7 +556,9 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	createShapesFromJsx(shapesJsx: JSX.Element | JSX.Element[]): Record<string, TLShapeId> {
+	createShapesFromJsx(
+		shapesJsx: React.JSX.Element | React.JSX.Element[]
+	): Record<string, TLShapeId> {
 		const { shapes, ids } = shapesFromJsx(shapesJsx)
 		this.createShapes(shapes)
 		return ids

commit e6e4e7f6cbac1cb72c0f530dae703c657dc8b6bf
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Feb 5 17:54:02 2024 +0000

    [dx] use Biome instead of Prettier, part 2 (#2731)
    
    Biome seems to be MUCH faster than Prettier. Unfortunately, it
    introduces some formatting changes around the ternary operator, so we
    have to update files in the repo. To make revert easier if we need it,
    the change is split into two PRs. This PR introduces a Biome CI check
    and reformats all files accordingly.
    
    ## Change Type
    - [x] `minor` ‚Äî New feature

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 4f388b997..c9d5f6d00 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -222,7 +222,7 @@ export class TestEditor extends Editor {
 			? ({
 					target: 'shape',
 					shape: this.getShape(info as any),
-				} as T)
+			  } as T)
 			: info
 	}
 
@@ -267,18 +267,18 @@ export class TestEditor extends Editor {
 				key === 'Shift'
 					? 'ShiftLeft'
 					: key === 'Alt'
-						? 'AltLeft'
-						: key === 'Control' || key === 'Meta'
-							? 'CtrlLeft'
-							: key === ' '
-								? 'Space'
-								: key === 'Enter' ||
+					  ? 'AltLeft'
+					  : key === 'Control' || key === 'Meta'
+						  ? 'CtrlLeft'
+						  : key === ' '
+							  ? 'Space'
+							  : key === 'Enter' ||
 									  key === 'ArrowRight' ||
 									  key === 'ArrowLeft' ||
 									  key === 'ArrowUp' ||
 									  key === 'ArrowDown'
-									? key
-									: 'Key' + key[0].toUpperCase() + key.slice(1),
+								  ? key
+								  : 'Key' + key[0].toUpperCase() + key.slice(1),
 			type: 'keyboard',
 			key,
 		}

commit 86cce6d161e2018f02fc4271bbcff803d07fa339
Author: Dan Groshev <git@dgroshev.com>
Date:   Wed Feb 7 16:02:22 2024 +0000

    Unbiome (#2776)
    
    Biome as it is now didn't work out for us üò¢
    
    Summary for posterity:
    
    * it IS much, much faster, fast enough to skip any sort of caching
    * we couldn't fully replace Prettier just yet. We use Prettier
    programmatically to format code in docs, and Biome's JS interface is
    officially alpha and [had legacy peer deps
    set](https://github.com/biomejs/biome/pull/1756) (which would fail our
    CI build as we don't allow installation warnings)
    * ternary formatting differs from Prettier, leading to a large diff
    https://github.com/biomejs/biome/issues/1661
    * import sorting differs from Prettier's
    `prettier-plugin-organize-imports`, making the diff even bigger
    * the deal breaker is a multi-second delay on saving large files (for us
    it's
    [Editor.ts](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/editor/Editor.ts))
    in VSCode when import sorting is enabled. There is a seemingly relevant
    Biome issue where I posted a small summary of our findings:
    https://github.com/biomejs/biome/issues/1569#issuecomment-1930411623
    
    Further actions:
    
    * reevaluate in a few months as Biome matures
    
    ### Change Type
    
    - [x] `internal` ‚Äî Any other changes that don't affect the published
    package

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index c9d5f6d00..4f388b997 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -222,7 +222,7 @@ export class TestEditor extends Editor {
 			? ({
 					target: 'shape',
 					shape: this.getShape(info as any),
-			  } as T)
+				} as T)
 			: info
 	}
 
@@ -267,18 +267,18 @@ export class TestEditor extends Editor {
 				key === 'Shift'
 					? 'ShiftLeft'
 					: key === 'Alt'
-					  ? 'AltLeft'
-					  : key === 'Control' || key === 'Meta'
-						  ? 'CtrlLeft'
-						  : key === ' '
-							  ? 'Space'
-							  : key === 'Enter' ||
+						? 'AltLeft'
+						: key === 'Control' || key === 'Meta'
+							? 'CtrlLeft'
+							: key === ' '
+								? 'Space'
+								: key === 'Enter' ||
 									  key === 'ArrowRight' ||
 									  key === 'ArrowLeft' ||
 									  key === 'ArrowUp' ||
 									  key === 'ArrowDown'
-								  ? key
-								  : 'Key' + key[0].toUpperCase() + key.slice(1),
+									? key
+									: 'Key' + key[0].toUpperCase() + key.slice(1),
 			type: 'keyboard',
 			key,
 		}

commit 79460cbf3a1084ac5b49e41d1e2570e4eee98e82
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Feb 12 15:03:25 2024 +0000

    Use canvas bounds for viewport bounds (#2798)
    
    This PR changes the way that viewport bounds are calculated by using the
    canvas element as the source of truth, rather than the container. This
    allows for cases where the canvas is not the same dimensions as the
    component. (Given the way our UI and context works, there are cases
    where this is desired, i.e. toolbars and other items overlaid on top of
    the canvas area).
    
    The editor's `getContainer` is now only used for the text measurement.
    It would be good to get that out somehow.
    
    # Pros
    
    We can inset the canvas
    
    # Cons
    
    We can no longer imperatively call `updateScreenBounds`, as we need to
    provide those bounds externally.
    
    ### Change Type
    
    - [x] `major` ‚Äî Breaking change
    
    ### Test Plan
    
    1. Use the examples, including the new inset canvas example.
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Changes the source of truth for the viewport page bounds to be the
    canvas instead.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 4f388b997..c676e5453 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -1,4 +1,5 @@
 import {
+	Box,
 	BoxModel,
 	Editor,
 	HALF_PI,
@@ -127,7 +128,7 @@ export class TestEditor extends Editor {
 		this.bounds.right = bounds.x + bounds.w
 		this.bounds.bottom = bounds.y + bounds.h
 
-		this.updateViewportScreenBounds(center)
+		this.updateViewportScreenBounds(Box.From(bounds), center)
 		this.updateRenderingBounds()
 		return this
 	}

commit 31ce1c1a89bea4adf96b14708a6c8993993724d5
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Feb 19 17:10:31 2024 +0000

    [handles] Line shape handles -> points (#2856)
    
    This PR replaces the line shape's `handles` prop with `points`, an array
    of `VecModel`s.
    
    ### Change Type
    
    - [x] `minor` ‚Äî New feature
    
    ### Test Plan
    
    - [x] Unit Tests
    - [ ] End to end tests

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index c676e5453..e103951a1 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -207,7 +207,9 @@ export class TestEditor extends Editor {
 		}).toCloselyMatchObject({ x, y, z })
 	}
 
-	expectShapeToMatch = (...model: RequiredKeys<TLShapePartial, 'id'>[]) => {
+	expectShapeToMatch = <T extends TLShape = TLShape>(
+		...model: RequiredKeys<TLShapePartial<T>, 'id'>[]
+	) => {
 		model.forEach((model) => {
 			const shape = this.getShape(model.id)!
 			const next = { ...shape, ...model }

commit b5aff00c8964a3513954fad7ca296c0b8c3bd4cf
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Mon Mar 11 14:17:31 2024 +0100

    Performance improvements (#2977)
    
    This PR does a few things to help with performance:
    1. Instead of doing changes on raf we now do them 60 times per second.
    This limits the number of updates on high refresh rate screens like the
    iPad. With the current code this only applied to the history updates (so
    when you subscribed to the updates), but the next point takes this a bit
    futher.
    2. We now trigger react updates 60 times per second. This is a change in
    `useValue` and `useStateTracking` hooks.
    3. We now throttle the inputs (like the `pointerMove`) in state nodes.
    This means we batch multiple inputs and only apply them at most 60 times
    per second.
    
    We had to adjust our own tests to pass after this change so I marked
    this as major as it might require the users of the library to do the
    same.
    
    Few observations:
    - The browser calls the raf callbacks when it can. If it gets
    overwhelmed it will call them further and further apart. As things call
    down it will start calling them more frequently again. You can clearly
    see this in the drawing example. When fps gets to a certain level we
    start to get fewer updates, then fps can recover a bit. This makes the
    experience quite janky. The updates can be kinda ok one second (dropping
    frames, but consistently) and then they can completely stop and you have
    to let go of the mouse to make them happen again. With the new logic it
    seems everything is a lot more consistent.
    - We might look into variable refresh rates to prevent this overtaxing
    of the browser. Like when we see that the times between our updates are
    getting higher we could make the updates less frequent. If we then see
    that they are happening more often we could ramp them back up. I had an
    [experiment for this
    here](https://github.com/tldraw/tldraw/pull/2977/commits/48348639669e556798296eee82fc53ca8ef444f2#diff-318e71563d7c47173f89ec084ca44417cf70fc72faac85b96f48b856a8aec466L30-L35).
    
    Few tests below. Used 6x slowdown for these.
    
    # Resizing
    
    ### Before
    
    
    https://github.com/tldraw/tldraw/assets/2523721/798a033f-5dfa-419e-9a2d-fd8908272ba0
    
    ### After
    
    
    https://github.com/tldraw/tldraw/assets/2523721/45870a0c-c310-4be0-b63c-6c92c20ca037
    
    # Drawing
    Comparison is not 100% fair, we don't store the intermediate inputs
    right now. That said, tick should still only produce once update so I do
    think we can get a sense of the differences.
    
    ### Before
    
    
    https://github.com/tldraw/tldraw/assets/2523721/2e8ac8c5-bbdf-484b-bb0c-70c967f4541c
    
    ### After
    
    
    https://github.com/tldraw/tldraw/assets/2523721/8f54b7a8-9a0e-4a39-b168-482caceb0149
    
    
    ### Change Type
    
    - [ ] `patch` ‚Äî Bug fix
    - [ ] `minor` ‚Äî New feature
    - [x] `major` ‚Äî Breaking change
    - [ ] `dependencies` ‚Äî Changes to package dependencies[^1]
    - [ ] `documentation` ‚Äî Changes to the documentation only[^2]
    - [ ] `tests` ‚Äî Changes to any test code only[^2]
    - [ ] `internal` ‚Äî Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    
    ### Release Notes
    
    - Improves the performance of rendering.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index e103951a1..bb8e8a2a0 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -289,6 +289,17 @@ export class TestEditor extends Editor {
 
 	/* ------------------ Input Events ------------------ */
 
+	/**
+	Some of our updates are not synchronous any longer. For example, drawing happens on tick instead of on pointer move.
+	You can use this helper to force the tick, which will then process all the updates.
+	*/
+	forceTick = (count = 1) => {
+		for (let i = 0; i < count; i++) {
+			this.emit('tick', 16)
+		}
+		return this
+	}
+
 	pointerMove = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
@@ -298,7 +309,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_move',
-		})
+		}).forceTick()
 		return this
 	}
 

commit 1951fc0e47cc44d4b9092607f91c5efdb882a15a
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Mar 18 16:03:44 2024 +0000

    Fix lag while panning + translating at the same time (#3186)
    
    Before
    
    ![Kapture 2024-03-18 at 09 42
    33](https://github.com/tldraw/tldraw/assets/1242537/d27c5852-9514-4e44-8b75-d2cb2571362a)
    
    
    After
    
    ![Kapture 2024-03-18 at 09 41
    27](https://github.com/tldraw/tldraw/assets/1242537/f5cbebfd-a45c-48d9-915b-18823f4555ff)
    
    The probelm was manifesting because our camera updates were not
    throttled and our render tick was on a different tick timeline to our
    tick manager. Fixing the latter gets rid of the lag without requiring us
    to throttle the camera updates.
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [x] `bugfix` ‚Äî Bug fix
    
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index bb8e8a2a0..edbb67700 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -3,6 +3,7 @@ import {
 	BoxModel,
 	Editor,
 	HALF_PI,
+	IdOf,
 	Mat,
 	PageRecordType,
 	ROTATE_CORNER_TO_SELECTION_CORNER,
@@ -205,6 +206,8 @@ export class TestEditor extends Editor {
 			y: +camera.y.toFixed(2),
 			z: +camera.z.toFixed(2),
 		}).toCloselyMatchObject({ x, y, z })
+
+		return this
 	}
 
 	expectShapeToMatch = <T extends TLShape = TLShape>(
@@ -218,6 +221,25 @@ export class TestEditor extends Editor {
 		return this
 	}
 
+	expectPageBoundsToBe = <T extends TLShape = TLShape>(id: IdOf<T>, bounds: Partial<BoxModel>) => {
+		const observedBounds = this.getShapePageBounds(id)!
+		expect(observedBounds).toCloselyMatchObject(bounds)
+		return this
+	}
+
+	expectScreenBoundsToBe = <T extends TLShape = TLShape>(
+		id: IdOf<T>,
+		bounds: Partial<BoxModel>
+	) => {
+		const pageBounds = this.getShapePageBounds(id)!
+		const screenPoint = this.pageToScreen(pageBounds.point)
+		const observedBounds = pageBounds.clone()
+		observedBounds.x = screenPoint.x
+		observedBounds.y = screenPoint.y
+		expect(observedBounds).toCloselyMatchObject(bounds)
+		return this
+	}
+
 	/* --------------------- Inputs --------------------- */
 
 	protected getInfo = <T extends TLEventInfo>(info: string | T): T => {
@@ -294,8 +316,9 @@ export class TestEditor extends Editor {
 	You can use this helper to force the tick, which will then process all the updates.
 	*/
 	forceTick = (count = 1) => {
+		const tick = (this as any)._tickManager as { tick(): void }
 		for (let i = 0; i < count; i++) {
-			this.emit('tick', 16)
+			tick.tick()
 		}
 		return this
 	}

commit cd02d03d063b50d93d840aa8194aeced43a6a9c5
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Thu Mar 21 11:05:44 2024 +0100

    Revert perf changes (#3217)
    
    Step 1 of the master plan üòÇ
    
    ![CleanShot 2024-03-19 at 16 05
    08](https://github.com/tldraw/tldraw/assets/2523721/7d2afed9-7b69-4fdb-8b9f-54a48c61258f)
    
    This:
    - Reverts #3186
    - Reverts #3160 (there were some conflicting changes so it's not a
    straight revert)
    - Reverts most of #2977
    
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [ ] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [x] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [ ] `improvement` ‚Äî Improving existing features
    - [x] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index edbb67700..b1d204c6d 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -311,18 +311,6 @@ export class TestEditor extends Editor {
 
 	/* ------------------ Input Events ------------------ */
 
-	/**
-	Some of our updates are not synchronous any longer. For example, drawing happens on tick instead of on pointer move.
-	You can use this helper to force the tick, which will then process all the updates.
-	*/
-	forceTick = (count = 1) => {
-		const tick = (this as any)._tickManager as { tick(): void }
-		for (let i = 0; i < count; i++) {
-			tick.tick()
-		}
-		return this
-	}
-
 	pointerMove = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
@@ -332,7 +320,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_move',
-		}).forceTick()
+		})
 		return this
 	}
 

commit 584380ba8b9176bd02942b8b154e0cdda0b888f3
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Tue Apr 2 16:29:14 2024 +0200

    Input buffering (#3223)
    
    This PR buffs input events.
    
    ## The story so far
    
    In the olde days, we throttled events from the canvas events hook so
    that a pointer event would only be sent every 1/60th of a second. This
    was fine but made drawing on the iPad / 120FPS displays a little sad.
    
    Then we removed this throttle. It seemed fine! Drawing at 120FPS was
    great. We improved some rendering speeds and tightened some loops so
    that the engine could keep up with 2x the number of points in a line.
    
    Then we started noticing that iPads and other screens could start
    choking on events as it received new inputs and tried to process and
    render inputs while still recovering from a previous dropped frame. Even
    worse, on iPad the work of rendering at 120FPS was causing the browser
    to throttle the app after some sustained drawing. Yikes!
    
    ### Batching
    
    I did an experimental PR (#3180) to bring back batching but do it in the
    editor instead. What we would do is: rather than immediately processing
    an event when we get it, we would instead put the event into a buffer.
    On the next 60FPS tick, we would flush the buffer and process all of the
    events. We'd have them all in the same transaction so that the app would
    only render once.
    
    ### Render batching?
    
    We then tried batching the renders, so that the app would only ever
    render once per (next) frame. This added a bunch of complexity around
    events that needed to happen synchronously, such as writing text in a
    text field. Some inputs could "lag" in a way familiar to anyone who's
    tried to update an input's state asynchronously. So we backed out of
    this.
    
    ### Coalescing?
    
    Another idea from @ds300 was to "coalesce" the events. This would be
    useful because, while some interactions like drawing would require the
    in-between frames in order to avoid data loss, most interactions (like
    resizing) didn't actually need the in-between frames, they could just
    use the last input of a given type.
    
    Coalescing turned out to be trickier than we thought, though. Often a
    state node required information from elsewhere in the app when
    processing an event (such as camera position or page point, which is
    derived from the camera position), and so the coalesced events would
    need to also include this information or else the handlers wouldn't work
    the way they should when processing the "final" event during a tick.
    
    So we backed out of the coalescing strategy for now. Here's the [PR that
    removes](https://github.com/tldraw/tldraw/pull/3223/commits/937469d69d4474fe9d1ff98604acb8f55a49f3fa)
    it.
    
    ### Let's just buffer the fuckers
    
    So this PR now should only include input buffering.
    
    I think there are ways to achieve the same coalescing-like results
    through the state nodes, which could gather information during the
    `onPointerMove` handler and then actually make changes during the
    `onTick` handler, so that the changes are only done as many time as
    necessary. This should help with e.g. resizing lots of shapes at once.
    
    But first let's land the buffering!
    
    ---
    
    Mitja's original text:
    
    This PR builds on top of Steve's [experiment
    PR](https://github.com/tldraw/tldraw/pull/3180) here. It also adds event
    coalescing for [`pointerMove`
    events](https://github.com/tldraw/tldraw/blob/mitja/input-buffering/packages/editor/src/lib/editor/Editor.ts#L8364-L8368).
    The API is [somewhat similar
    ](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents)
    to `getCoalescedEvent`. In `StateNodes` we register an `onPointerMove`
    handler. When the event happens it gets called with the event `info`.
    There's now an additional field on `TLMovePointerEvent` called
    `coalescedInfo` which includes all the events. It's then on the user to
    process all of these.
    
    I decided on this API since it allows us to only expose one event
    handler, but it still gives the users access to all events if they need
    them.
    
    We would otherwise either need to:
    
    - Expose two events (coalesced and non-coalesced one and complicate the
    api) so that state nodes like Resizing would not be triggered for each
    pointer move.
    - Offer some methods on the editor that would allow use to get the
    coalesced information. Then the nodes that need that info could request
    it. I [tried
    this](https://github.com/tldraw/tldraw/pull/3223/commits/9ad973da3aa287e7974067ac923193530d29c188#diff-32f1de9a5a9ec72aa49a8d18a237fbfff301610f4689a4af6b37f47af435aafcR67),
    but it didn't feel good.
    
    This also complicated the editor inputs. The events need to store
    information about the event (like the mouse position when the event
    happened for `onPointerMove`). But we cannot immediately update inputs
    when the event happens. To make this work for `pointerMove` events I've
    added `pagePoint`. It's
    [calculated](https://github.com/tldraw/tldraw/pull/3223/files#diff-980beb0aa0ee9aa6d1cd386cef3dc05a500c030638ffb58d45fd11b79126103fR71)
    when the event triggers and then consumers can get it straight from the
    event (like
    [Drawing](https://github.com/tldraw/tldraw/pull/3223/files#diff-32f1de9a5a9ec72aa49a8d18a237fbfff301610f4689a4af6b37f47af435aafcR104)).
    
    ### Change Type
    
    <!-- ‚ùó Please select a 'Scope' label ‚ùóÔ∏è -->
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [ ] `dotcom` ‚Äî Changes the tldraw.com web app
    - [ ] `docs` ‚Äî Changes to the documentation, examples, or templates.
    - [ ] `vs code` ‚Äî Changes to the vscode plugin
    - [ ] `internal` ‚Äî Does not affect user-facing stuff
    
    <!-- ‚ùó Please select a 'Type' label ‚ùóÔ∏è -->
    
    - [ ] `bugfix` ‚Äî Bug fix
    - [ ] `feature` ‚Äî New feature
    - [x] `improvement` ‚Äî Improving existing features
    - [ ] `chore` ‚Äî Updating dependencies, other boring stuff
    - [ ] `galaxy brain` ‚Äî Architectural changes
    - [ ] `tests` ‚Äî Changes to any test code
    - [ ] `tools` ‚Äî Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` ‚Äî I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    4.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index b1d204c6d..7f93e1417 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -311,6 +311,17 @@ export class TestEditor extends Editor {
 
 	/* ------------------ Input Events ------------------ */
 
+	/**
+	Some of our updates are not synchronous any longer. For example, drawing happens on tick instead of on pointer move.
+	You can use this helper to force the tick, which will then process all the updates.
+	*/
+	forceTick = (count = 1) => {
+		for (let i = 0; i < count; i++) {
+			this.emit('tick', 16)
+		}
+		return this
+	}
+
 	pointerMove = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
@@ -320,7 +331,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_move',
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -333,7 +344,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_down',
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -346,7 +357,7 @@ export class TestEditor extends Editor {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_up',
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -380,17 +391,17 @@ export class TestEditor extends Editor {
 			type: 'click',
 			name: 'double_click',
 			phase: 'up',
-		})
+		}).forceTick()
 		return this
 	}
 
 	keyDown = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
-		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_down', options) })
+		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_down', options) }).forceTick()
 		return this
 	}
 
 	keyRepeat = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
-		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_repeat', options) })
+		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_repeat', options) }).forceTick()
 		return this
 	}
 
@@ -402,7 +413,7 @@ export class TestEditor extends Editor {
 				altKey: this.inputs.altKey && key !== 'Alt',
 				...options,
 			}),
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -416,7 +427,7 @@ export class TestEditor extends Editor {
 			altKey: this.inputs.altKey,
 			...options,
 			delta: { x: dx, y: dy },
-		})
+		}).forceTick(2)
 		return this
 	}
 
@@ -438,7 +449,7 @@ export class TestEditor extends Editor {
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -482,7 +493,7 @@ export class TestEditor extends Editor {
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },
-		})
+		}).forceTick()
 		return this
 	}
 	/* ------ Interaction Helpers ------ */

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime ƒåuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 7f93e1417..9bb3b527d 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -85,7 +85,7 @@ export class TestEditor extends Editor {
 				lineHeight: number
 				maxWidth: null | number
 			}
-		): BoxModel => {
+		): BoxModel & { scrollWidth: number } => {
 			const breaks = textToMeasure.split('\n')
 			const longest = breaks.reduce((acc, curr) => {
 				return curr.length > acc.length ? curr : acc
@@ -100,6 +100,7 @@ export class TestEditor extends Editor {
 				h:
 					(opts.maxWidth === null ? breaks.length : Math.ceil(w % opts.maxWidth) + breaks.length) *
 					opts.fontSize,
+				scrollWidth: opts.maxWidth === null ? w : Math.max(w, opts.maxWidth),
 			}
 		}
 
@@ -114,6 +115,29 @@ export class TestEditor extends Editor {
 
 		// Turn off edge scrolling for tests. Tests that require this can turn it back on.
 		this.user.updateUserPreferences({ edgeScrollSpeed: 0 })
+
+		this.sideEffects.registerAfterCreateHandler('shape', (record) => {
+			this._lastCreatedShapes.push(record)
+		})
+	}
+
+	private _lastCreatedShapes: TLShape[] = []
+
+	/**
+	 * Get the last created shapes.
+	 *
+	 * @param count - The number of shapes to get.
+	 */
+	getLastCreatedShapes(count = 1) {
+		return this._lastCreatedShapes.slice(-count).map((s) => this.getShape(s)!)
+	}
+
+	/**
+	 * Get the last created shape.
+	 */
+	getLastCreatedShape<T extends TLShape>() {
+		const lastShape = this._lastCreatedShapes[this._lastCreatedShapes.length - 1] as T
+		return this.getShape<T>(lastShape)!
 	}
 
 	elm: HTMLDivElement

commit 0d0d38361d9e0357af27bc7fa2c4a8573f382c72
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Apr 27 18:30:24 2024 +0100

    Don't hover locked shapes (#3575)
    
    This PR:
    - updates `getHoveredId` to `getHoveredShapeId`
    - adds an option to ignore locked shapes to `Editor.getShapeAtPoint`.
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `improvement` ‚Äî Improving existing features
    
    ### Test Plan
    
    1. Put two shapes on top of eachother
    2. Lock the top shape
    3. Hover the shape
    4. The bottom shape should be hovered
    5. Right click
    6. The top shape should be selected
    
    - [x] Unit tests
    
    ### Release Notes
    
    - Fixed a bug with locked shapes being hoverable.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 9bb3b527d..220833cb7 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -396,6 +396,25 @@ export class TestEditor extends Editor {
 		return this
 	}
 
+	rightClick = (
+		x = this.inputs.currentScreenPoint.x,
+		y = this.inputs.currentScreenPoint.y,
+		options?: PointerEventInit,
+		modifiers?: EventModifiers
+	) => {
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_down',
+			button: 2,
+		}).forceTick()
+		this.dispatch({
+			...this.getPointerEventInfo(x, y, options, modifiers),
+			name: 'pointer_up',
+			button: 2,
+		}).forceTick()
+		return this
+	}
+
 	doubleClick = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,

commit fabba66c0f4b6c42ece30f409e70eb01e588f8e1
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat May 4 18:39:04 2024 +0100

    Camera options (#3282)
    
    This PR implements a camera options API.
    
    - [x] Initial PR
    - [x] Updated unit tests
    - [x] Feedback / review
    - [x] New unit tests
    - [x] Update use-case examples
    - [x] Ship?
    
    ## Public API
    
    A user can provide camera options to the `Tldraw` component via the
    `cameraOptions` prop. The prop is also available on the `TldrawEditor`
    component and the constructor parameters of the `Editor` class.
    
    ```tsx
    export default function CameraOptionsExample() {
            return (
                    <div className="tldraw__editor">
                            <Tldraw cameraOptions={CAMERA_OPTIONS} />
                    </div>
            )
    }
    ```
    
    At runtime, a user can:
    -  get the current camera options with `Editor.getCameraOptions`
    -  update the camera options with `Editor.setCameraOptions`
    
    Setting the camera options automatically applies them to the current
    camera.
    
    ```ts
    editor.setCameraOptions({...editor.getCameraOptions(), isLocked: true })
    ```
    
    A user can get the "camera fit zoom" via `editor.getCameraFitZoom()`.
    
    # Interface
    
    The camera options themselves can look a few different ways depending on
    the `type` provided.
    
    
    ```tsx
    export type TLCameraOptions = {
            /** Whether the camera is locked. */
            isLocked: boolean
            /** The speed of a scroll wheel / trackpad pan. Default is 1. */
            panSpeed: number
            /** The speed of a scroll wheel / trackpad zoom. Default is 1. */
            zoomSpeed: number
            /** The steps that a user can zoom between with zoom in / zoom out. The first and last value will determine the min and max zoom. */
            zoomSteps: number[]
            /** Controls whether the wheel pans or zooms.
             *
             * - `zoom`: The wheel will zoom in and out.
             * - `pan`: The wheel will pan the camera.
             * - `none`: The wheel will do nothing.
             */
            wheelBehavior: 'zoom' | 'pan' | 'none'
            /** The camera constraints. */
            constraints?: {
                    /** The bounds (in page space) of the constrained space */
                    bounds: BoxModel
                    /** The padding inside of the viewport (in screen space) */
                    padding: VecLike
                    /** The origin for placement. Used to position the bounds within the viewport when an axis is fixed or contained and zoom is below the axis fit. */
                    origin: VecLike
                    /** The camera's initial zoom, used also when the camera is reset.
                     *
                     * - `default`: Sets the initial zoom to 100%.
                     * - `fit-x`: The x axis will completely fill the viewport bounds.
                     * - `fit-y`: The y axis will completely fill the viewport bounds.
                     * - `fit-min`: The smaller axis will completely fill the viewport bounds.
                     * - `fit-max`: The larger axis will completely fill the viewport bounds.
                     * - `fit-x-100`: The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-y-100`: The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-min-100`: The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-max-100`: The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     */
                    initialZoom:
                            | 'fit-min'
                            | 'fit-max'
                            | 'fit-x'
                            | 'fit-y'
                            | 'fit-min-100'
                            | 'fit-max-100'
                            | 'fit-x-100'
                            | 'fit-y-100'
                            | 'default'
                    /** The camera's base for its zoom steps.
                     *
                     * - `default`: Sets the initial zoom to 100%.
                     * - `fit-x`: The x axis will completely fill the viewport bounds.
                     * - `fit-y`: The y axis will completely fill the viewport bounds.
                     * - `fit-min`: The smaller axis will completely fill the viewport bounds.
                     * - `fit-max`: The larger axis will completely fill the viewport bounds.
                     * - `fit-x-100`: The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-y-100`: The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-min-100`: The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-max-100`: The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     */
                    baseZoom:
                            | 'fit-min'
                            | 'fit-max'
                            | 'fit-x'
                            | 'fit-y'
                            | 'fit-min-100'
                            | 'fit-max-100'
                            | 'fit-x-100'
                            | 'fit-y-100'
                            | 'default'
                    /** The behavior for the constraints for both axes or each axis individually.
                     *
                     * - `free`: The bounds are ignored when moving the camera.
                     * - 'fixed': The bounds will be positioned within the viewport based on the origin
                     * - `contain`: The 'fixed' behavior will be used when the zoom is below the zoom level at which the bounds would fill the viewport; and when above this zoom, the bounds will use the 'inside' behavior.
                     * - `inside`: The bounds will stay completely within the viewport.
                     * - `outside`: The bounds will stay touching the viewport.
                     */
                    behavior:
                            | 'free'
                            | 'fixed'
                            | 'inside'
                            | 'outside'
                            | 'contain'
                            | {
                                            x: 'free' | 'fixed' | 'inside' | 'outside' | 'contain'
                                            y: 'free' | 'fixed' | 'inside' | 'outside' | 'contain'
                              }
            }
    }
    ```
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Test Plan
    
    These features combine in different ways, so we'll want to write some
    more tests to find surprises.
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - SDK: Adds camera options.
    
    ---------
    
    Co-authored-by: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 220833cb7..2e750c846 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -22,6 +22,7 @@ import {
 	TLWheelEventInfo,
 	Vec,
 	VecLike,
+	computed,
 	createShapeId,
 	createTLStore,
 	rotateSelectionHandle,
@@ -143,6 +144,15 @@ export class TestEditor extends Editor {
 	elm: HTMLDivElement
 	bounds = { x: 0, y: 0, top: 0, left: 0, width: 1080, height: 720, bottom: 720, right: 1080 }
 
+	/**
+	 * The center of the viewport in the current page space.
+	 *
+	 * @public
+	 */
+	@computed getViewportPageCenter() {
+		return this.getViewportPageBounds().center
+	}
+
 	setScreenBounds(bounds: BoxModel, center = false) {
 		this.bounds.x = bounds.x
 		this.bounds.y = bounds.y
@@ -154,7 +164,6 @@ export class TestEditor extends Editor {
 		this.bounds.bottom = bounds.y + bounds.h
 
 		this.updateViewportScreenBounds(Box.From(bounds), center)
-		this.updateRenderingBounds()
 		return this
 	}
 
@@ -200,12 +209,12 @@ export class TestEditor extends Editor {
 	 * _transformPointerDownSpy.mockRestore())
 	 */
 	_transformPointerDownSpy = jest
-		.spyOn(this._clickManager, 'transformPointerDownEvent')
+		.spyOn(this._clickManager, 'handlePointerEvent')
 		.mockImplementation((info) => {
 			return info
 		})
 	_transformPointerUpSpy = jest
-		.spyOn(this._clickManager, 'transformPointerDownEvent')
+		.spyOn(this._clickManager, 'handlePointerEvent')
 		.mockImplementation((info) => {
 			return info
 		})
@@ -474,6 +483,16 @@ export class TestEditor extends Editor {
 		return this
 	}
 
+	pan(offset: VecLike): this {
+		const { isLocked, panSpeed } = this.getCameraOptions()
+		if (isLocked) return this
+		const { x: cx, y: cy, z: cz } = this.getCamera()
+		this.setCamera(new Vec(cx + (offset.x * panSpeed) / cz, cy + (offset.y * panSpeed) / cz, cz), {
+			immediate: true,
+		})
+		return this
+	}
+
 	pinchStart = (
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,

commit da35f2bd75e43fd48d11a9a74f60ee01c84a41d1
Author: alex <alex@dytry.ch>
Date:   Wed May 8 13:37:31 2024 +0100

    Bindings (#3326)
    
    First draft of the new bindings API. We'll follow this up with some API
    refinements, tests, documentation, and examples.
    
    Bindings are a new record type for establishing relationships between
    two shapes so they can update at the same time.
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `feature` ‚Äî New feature
    
    ### Release Notes
    
    #### Breaking changes
    - The `start` and `end` properties on `TLArrowShape` no longer have
    `type: point | binding`. Instead, they're always a point, which may be
    out of date if a binding exists. To check for & retrieve arrow bindings,
    use `getArrowBindings(editor, shape)` instead.
    - `getArrowTerminalsInArrowSpace` must be passed a `TLArrowBindings` as
    a third argument: `getArrowTerminalsInArrowSpace(editor, shape,
    getArrowBindings(editor, shape))`
    - The following types have been renamed:
        - `ShapeProps` -> `RecordProps`
        - `ShapePropsType` -> `RecordPropsType`
        - `TLShapePropsMigrations` -> `TLPropsMigrations`
        - `SchemaShapeInfo` -> `SchemaPropsInfo`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 2e750c846..8b25a138d 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -27,6 +27,7 @@ import {
 	createTLStore,
 	rotateSelectionHandle,
 } from '@tldraw/editor'
+import { defaultBindingUtils } from '../lib/defaultBindingUtils'
 import { defaultShapeTools } from '../lib/defaultShapeTools'
 import { defaultShapeUtils } from '../lib/defaultShapeUtils'
 import { defaultTools } from '../lib/defaultTools'
@@ -61,12 +62,17 @@ export class TestEditor extends Editor {
 		elm.tabIndex = 0
 
 		const shapeUtilsWithDefaults = [...defaultShapeUtils, ...(options.shapeUtils ?? [])]
+		const bindingUtilsWithDefaults = [...defaultBindingUtils, ...(options.bindingUtils ?? [])]
 
 		super({
 			...options,
-			shapeUtils: [...shapeUtilsWithDefaults],
+			shapeUtils: shapeUtilsWithDefaults,
+			bindingUtils: bindingUtilsWithDefaults,
 			tools: [...defaultTools, ...defaultShapeTools, ...(options.tools ?? [])],
-			store: createTLStore({ shapeUtils: [...shapeUtilsWithDefaults] }),
+			store: createTLStore({
+				shapeUtils: shapeUtilsWithDefaults,
+				bindingUtils: bindingUtilsWithDefaults,
+			}),
 			getContainer: () => elm,
 			initialState: 'select',
 		})

commit 91903c97614f3645dcbdcf6986fd5e4ca3dd95dc
Author: alex <alex@dytry.ch>
Date:   Thu May 9 10:48:01 2024 +0100

    Move arrow helpers from editor to tldraw (#3721)
    
    With the new work on bindings, we no longer need to keep any arrows
    stuff hard-coded in `editor`, so let's move it to `tldraw` with the rest
    of the shapes.
    
    Couple other changes as part of this:
    - We had two different types of `WeakMap` backed cache, but we now only
    have one
    - There's a new free-standing version of `createComputedCache` that
    doesn't need access to the editor/store in order to create the cache.
    instead, it returns a `{get(editor, id)}` object and instantiates the
    cache on a per-editor basis for each call.
    - Fixed a bug in `createSelectedComputedCache` where the selector
    derivation would get re-created on every call to `get`
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `improvement` ‚Äî Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    - `editor.getArrowInfo(shape)` has been replaced with
    `getArrowInfo(editor, shape)`
    - `editor.getArrowsBoundTo(shape)` has been removed. Instead, use
    `editor.getBindingsToShape(shape, 'arrow')` and follow the `fromId` of
    each binding to the corresponding arrow shape
    - These types have moved from `@tldraw/editor` to `tldraw`:
        - `TLArcInfo`
        - `TLArrowInfo`
        - `TLArrowPoint`
    - `WeakMapCache` has been removed

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 8b25a138d..769d42328 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -10,6 +10,8 @@ import {
 	RequiredKeys,
 	RotateCorner,
 	SelectionHandle,
+	TLArrowBinding,
+	TLArrowShape,
 	TLContent,
 	TLEditorOptions,
 	TLEventInfo,
@@ -22,6 +24,7 @@ import {
 	TLWheelEventInfo,
 	Vec,
 	VecLike,
+	compact,
 	computed,
 	createShapeId,
 	createTLStore,
@@ -708,6 +711,13 @@ export class TestEditor extends Editor {
 	getPageRotation(shape: TLShape) {
 		return this.getPageRotationById(shape.id)
 	}
+
+	getArrowsBoundTo(shapeId: TLShapeId) {
+		const ids = new Set(
+			this.getBindingsToShape<TLArrowBinding>(shapeId, 'arrow').map((b) => b.fromId)
+		)
+		return compact(Array.from(ids, (id) => this.getShape<TLArrowShape>(id)))
+	}
 }
 
 export const defaultShapesIds = {

commit 87e3d60c9008e91dec81297f327fa5c6a8b76c6f
Author: alex <alex@dytry.ch>
Date:   Thu May 23 14:32:02 2024 +0100

    rework canBind callback (#3797)
    
    This PR reworks the `canBind` callback to work with customizable
    bindings. It now accepts an object with a the shape, the other shape
    (optional - it may not exist yet), the direction, and the type of the
    binding. Devs can use this to create shapes that only participate in
    certain binding types, can have bindings from but not to them, etc.
    
    If you're implementing a binding, you can see if binding two shapes is
    allowed using `editor.canBindShapes(fromShape, toShape, 'my binding
    type')`
    
    ### Change Type
    
    - [x] `sdk` ‚Äî Changes the tldraw SDK
    - [x] `improvement` ‚Äî Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    The `canBind` flag now accepts an options object instead of just the
    shape in question. If you're relying on its arguments, you need to
    change from `canBind(shape) {}` to `canBind({shape}) {}`.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 769d42328..bc0e75a70 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -253,10 +253,10 @@ export class TestEditor extends Editor {
 	}
 
 	expectShapeToMatch = <T extends TLShape = TLShape>(
-		...model: RequiredKeys<TLShapePartial<T>, 'id'>[]
+		...model: RequiredKeys<Partial<TLShapePartial<T>>, 'id'>[]
 	) => {
 		model.forEach((model) => {
-			const shape = this.getShape(model.id)!
+			const shape = this.getShape(model.id!)!
 			const next = { ...shape, ...model }
 			expect(shape).toCloselyMatchObject(next)
 		})

commit 01bc73e750a9450eb135ad080a7087f494020b48
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 15 15:10:09 2024 +0100

    Editor.run, locked shapes improvements (#4042)
    
    This PR:
    - creates `Editor.run` (previously `Editor.batch`)
    - deprecates `Editor.batch`
    - introduces a `ignoreShapeLock` option top the `Editor.run` method that
    allows the editor to update and delete locked shapes
    - fixes a bug with `updateShapes` that allowed updating locked shapes
    - fixes a bug with `ungroupShapes` that allowed ungrouping locked shapes
    - makes `Editor.history` private
    - adds `Editor.squashToMark`
    - adds `Editor.clearHistory`
    - removes `History.ignore`
    - removes `History.onBatchComplete`
    - makes `_updateCurrentPageState` private
    
    ```ts
    editor.run(() => {
      editor.updateShape({ ...myLockedShape })
      editor.deleteShape(myLockedShape)
    }, { ignoreShapeLock: true })
    ```
    
    It also:
    
    ## How it works
    
    Normally `updateShape`/`updateShapes` and `deleteShape`/`deleteShapes`
    do not effect locked shapes.
    
    ```ts
    const myLockedShape = editor.getShape(myShapeId)!
    
    // no change from update
    editor.updateShape({ ...myLockedShape, x: 100 })
    expect(editor.getShape(myShapeId)).toMatchObject(myLockedShape)
    
    // no change from delete
    editor.deleteShapes([myLockedShape])
    expect(editor.getShape(myShapeId)).toMatchObject(myLockedShape)
    ```
    
    The new `run` method adds the option to ignore shape lock.
    
    ```ts
    const myLockedShape = editor.getShape(myShapeId)!
    
    // update works
    editor.run(() => { editor.updateShape({ ...myLockedShape, x: 100 }) }, { ignoreShapeLock: true })
    expect(editor.getShape(myShapeId)).toMatchObject({ ...myLockedShape, x: 100 })
    
    // delete works
    editor.run(() => { editor.deleteShapes([myLockedShape]), { ignoreShapeLock: true })
    expect(editor.getShape(myShapeId)).toBeUndefined()
    ```
    
    ## History changes
    
    This is a related but not entirely related change in this PR.
    
    Previously, we had a few ways to run code that ignored the history.
    
    - `editor.history.ignore(() => { ... })`
    - `editor.batch(() => { ... }, { history: "ignore" })`
    - `editor.history.batch(() => { ... }, { history: "ignore" })`
    - `editor.updateCurrentPageState(() => { ... }, { history: "ignore" })`
    
    We now have one way to run code that ignores history:
    
    - `editor.run(() => { ... }, { history: "ignore" })`
    
    ## Design notes
    
    We want a user to be able to update or delete locked shapes
    programmatically.
    
    ### Callback vs. method options?
    
    We could have added a `{ force: boolean }` property to the
    `updateShapes` / `deleteShapes` methods, however there are places where
    those methods are called from other methods (such as
    `distributeShapes`). If we wanted to make these work, we would have also
    had to provide a `force` option / bag to those methods.
    
    Using a wrapper callback allows for "regular" tldraw editor code to work
    while allowing for updates and deletes.
    
    ### Interaction logic?
    
    We don't want this change to effect any of our interaction logic.
    
    A lot of our interaction logic depends on identifying which shapes are
    locked and which shapes aren't. For example, clicking on a locked shape
    will go to the `pointing_canvas` state rather than the `pointing_shape`.
    This PR has no effect on that part of the library.
    
    It only effects the updateShapes and deleteShapes methods. As an example
    of this, when `_force` is set to true by default, the only tests that
    should fail are in `lockedShapes.test.ts`. The "user land" experience of
    locked shapes is identical to what it is now.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape
    2. Lock it
    3. From the console, update it
    4. From the console, delete it
    
    - [x] Unit tests
    
    ### Release notes
    
    - SDK: Adds `Editor.force()` to permit updating / deleting locked shapes
    - Fixed a bug that would allow locked shapes to be updated
    programmatically
    - Fixed a bug that would allow locked group shapes to be ungrouped
    programmatically
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index bc0e75a70..5a3cdcb17 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -131,6 +131,10 @@ export class TestEditor extends Editor {
 		})
 	}
 
+	getHistory() {
+		return this.history
+	}
+
 	private _lastCreatedShapes: TLShape[] = []
 
 	/**

commit 2458db7a4e0936a3d954e05171a63335652b4691
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Jul 26 14:18:24 2024 +0100

    Deprecate editor.mark, fix cropping tests (#4250)
    
    So it turns out `editor.mark(id)` is a bit problematic unless you always
    pass in unique id, because it's quite easy to create situations where
    you will call `bailToMark(id)` but the mark that you were _intending_ to
    bail to has already been popped off the stack due to another previous
    call to `bailToMark`.
    
    I always suspected this might be the case (the original late 2022
    history api was designed to avoid this, but it got changed at some
    point) and indeed I ran into this bug while investigating a cropping
    undo/redo test error.
    
    To prevent issues for ourselves and our users, let's force people to use
    a randomly generated mark ID.
    
    Also `editor.mark` is a bad name. `mark` could mean a million things,
    even in the context of `editor.history.mark` it's a pretty bad name.
    Let's help people out and make it more descriptive.
    
    This PR deprecates the `editor.mark(id)` in favor of `id =
    editor.markHistoryStoppingPoint(name)`.
    
    I converted a couple of usages of editor.mark over but there's a lot
    left to do so I only want to do it if you don't object @steveruizok
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    This deprecates `Editor.mark()` in favour of
    `Editor.markHistoryStoppingPoint()`.
    
    This was done because calling `editor.mark(id)` is a potential footgun
    unless you always provide a random ID. So
    `editor.markHistoryStoppingPoint()` always returns a random id.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 5a3cdcb17..cb79107e3 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -207,7 +207,7 @@ export class TestEditor extends Editor {
 		if (this.clipboard !== null) {
 			const p = this.inputs.shiftKey ? this.inputs.currentPagePoint : point
 
-			this.mark('pasting')
+			this.markHistoryStoppingPoint('pasting')
 			this.putContentOntoCurrentPage(this.clipboard, {
 				point: p,
 				select: true,

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezen≈°ek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index cb79107e3..2e8c97dfb 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -182,7 +182,7 @@ export class TestEditor extends Editor {
 
 	clipboard = null as TLContent | null
 
-	copy = (ids = this.getSelectedShapeIds()) => {
+	copy(ids = this.getSelectedShapeIds()) {
 		if (ids.length > 0) {
 			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
@@ -192,7 +192,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	cut = (ids = this.getSelectedShapeIds()) => {
+	cut(ids = this.getSelectedShapeIds()) {
 		if (ids.length > 0) {
 			const content = this.getContentFromCurrentPage(ids)
 			if (content) {
@@ -203,7 +203,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	paste = (point?: VecLike) => {
+	paste(point?: VecLike) {
 		if (this.clipboard !== null) {
 			const p = this.inputs.shiftKey ? this.inputs.currentPagePoint : point
 
@@ -239,7 +239,7 @@ export class TestEditor extends Editor {
 		return PageRecordType.createId(id)
 	}
 
-	expectToBeIn = (path: string) => {
+	expectToBeIn(path: string) {
 		expect(this.getPath()).toBe(path)
 		return this
 	}
@@ -256,9 +256,9 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	expectShapeToMatch = <T extends TLShape = TLShape>(
+	expectShapeToMatch<T extends TLShape = TLShape>(
 		...model: RequiredKeys<Partial<TLShapePartial<T>>, 'id'>[]
-	) => {
+	) {
 		model.forEach((model) => {
 			const shape = this.getShape(model.id!)!
 			const next = { ...shape, ...model }
@@ -267,16 +267,13 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	expectPageBoundsToBe = <T extends TLShape = TLShape>(id: IdOf<T>, bounds: Partial<BoxModel>) => {
+	expectPageBoundsToBe<T extends TLShape = TLShape>(id: IdOf<T>, bounds: Partial<BoxModel>) {
 		const observedBounds = this.getShapePageBounds(id)!
 		expect(observedBounds).toCloselyMatchObject(bounds)
 		return this
 	}
 
-	expectScreenBoundsToBe = <T extends TLShape = TLShape>(
-		id: IdOf<T>,
-		bounds: Partial<BoxModel>
-	) => {
+	expectScreenBoundsToBe<T extends TLShape = TLShape>(id: IdOf<T>, bounds: Partial<BoxModel>) {
 		const pageBounds = this.getShapePageBounds(id)!
 		const screenPoint = this.pageToScreen(pageBounds.point)
 		const observedBounds = pageBounds.clone()
@@ -288,7 +285,7 @@ export class TestEditor extends Editor {
 
 	/* --------------------- Inputs --------------------- */
 
-	protected getInfo = <T extends TLEventInfo>(info: string | T): T => {
+	protected getInfo<T extends TLEventInfo>(info: string | T): T {
 		return typeof info === 'string'
 			? ({
 					target: 'shape',
@@ -297,12 +294,12 @@ export class TestEditor extends Editor {
 			: info
 	}
 
-	protected getPointerEventInfo = (
+	protected getPointerEventInfo(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: Partial<TLPointerEventInfo> | TLShapeId,
 		modifiers?: EventModifiers
-	): TLPointerEventInfo => {
+	) {
 		if (typeof options === 'string') {
 			options = { target: 'shape', shape: this.getShape(options) }
 		} else if (options === undefined) {
@@ -323,11 +320,11 @@ export class TestEditor extends Editor {
 		} as TLPointerEventInfo
 	}
 
-	protected getKeyboardEventInfo = (
+	protected getKeyboardEventInfo(
 		key: string,
 		name: TLKeyboardEventInfo['name'],
 		options = {} as Partial<Exclude<TLKeyboardEventInfo, 'point'>>
-	): TLKeyboardEventInfo => {
+	): TLKeyboardEventInfo {
 		return {
 			shiftKey: key === 'Shift',
 			ctrlKey: key === 'Control' || key === 'Meta',
@@ -361,19 +358,19 @@ export class TestEditor extends Editor {
 	Some of our updates are not synchronous any longer. For example, drawing happens on tick instead of on pointer move.
 	You can use this helper to force the tick, which will then process all the updates.
 	*/
-	forceTick = (count = 1) => {
+	forceTick(count = 1) {
 		for (let i = 0; i < count; i++) {
 			this.emit('tick', 16)
 		}
 		return this
 	}
 
-	pointerMove = (
+	pointerMove(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_move',
@@ -381,12 +378,12 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pointerDown = (
+	pointerDown(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_down',
@@ -394,12 +391,12 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pointerUp = (
+	pointerUp(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_up',
@@ -407,23 +404,23 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	click = (
+	click(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.pointerDown(x, y, options, modifiers)
 		this.pointerUp(x, y, options, modifiers)
 		return this
 	}
 
-	rightClick = (
+	rightClick(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.dispatch({
 			...this.getPointerEventInfo(x, y, options, modifiers),
 			name: 'pointer_down',
@@ -437,12 +434,12 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	doubleClick = (
+	doubleClick(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		options?: PointerEventInit,
 		modifiers?: EventModifiers
-	) => {
+	) {
 		this.pointerDown(x, y, options, modifiers)
 		this.pointerUp(x, y, options, modifiers)
 		this.dispatch({
@@ -460,17 +457,17 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	keyDown = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
+	keyDown(key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) {
 		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_down', options) }).forceTick()
 		return this
 	}
 
-	keyRepeat = (key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) => {
+	keyRepeat(key: string, options = {} as Partial<Exclude<TLKeyboardEventInfo, 'key'>>) {
 		this.dispatch({ ...this.getKeyboardEventInfo(key, 'key_repeat', options) }).forceTick()
 		return this
 	}
 
-	keyUp = (key: string, options = {} as Partial<Omit<TLKeyboardEventInfo, 'key'>>) => {
+	keyUp(key: string, options = {} as Partial<Omit<TLKeyboardEventInfo, 'key'>>) {
 		this.dispatch({
 			...this.getKeyboardEventInfo(key, 'key_up', {
 				shiftKey: this.inputs.shiftKey && key !== 'Shift',
@@ -482,7 +479,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	wheel = (dx: number, dy: number, options = {} as Partial<Omit<TLWheelEventInfo, 'delta'>>) => {
+	wheel(dx: number, dy: number, options = {} as Partial<Omit<TLWheelEventInfo, 'delta'>>) {
 		this.dispatch({
 			type: 'wheel',
 			name: 'wheel',
@@ -506,7 +503,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pinchStart = (
+	pinchStart(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		z: number,
@@ -514,7 +511,7 @@ export class TestEditor extends Editor {
 		dy: number,
 		dz: number,
 		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
-	) => {
+	) {
 		this.dispatch({
 			type: 'pinch',
 			name: 'pinch_start',
@@ -528,7 +525,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pinchTo = (
+	pinchTo(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		z: number,
@@ -536,7 +533,7 @@ export class TestEditor extends Editor {
 		dy: number,
 		dz: number,
 		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
-	) => {
+	) {
 		this.dispatch({
 			type: 'pinch',
 			name: 'pinch_start',
@@ -550,7 +547,7 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pinchEnd = (
+	pinchEnd(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
 		z: number,
@@ -558,7 +555,7 @@ export class TestEditor extends Editor {
 		dy: number,
 		dz: number,
 		options = {} as Partial<Omit<TLPinchEventInfo, 'point' | 'delta' | 'offset'>>
-	) => {
+	) {
 		this.dispatch({
 			type: 'pinch',
 			name: 'pinch_end',

commit 42de01d57230caac87ba34571b77c27e52d37a37
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Aug 13 08:15:41 2024 +0100

    Deep Links (#4333)
    
    Deep Links are URLs which point to a specific part of a document. We
    provide a comprehensive set of tools to help you create and manage deep
    links in your application.
    
    ## The `deepLinks` prop
    
    The highest-level API for managing deep links is the `deepLinks` prop on
    the `<Tldraw />` component. This prop is designed for manipulating
    `window.location` to add a search param which tldraw can use to navigate
    to a specific part of the document.
    
    e.g. `https://my-app.com/document-name?d=v1234.-234.3.21`
    
    If you set `deepLinks` to `true` e.g. `<Tldraw deepLinks />` the
    following default behavior will be enabled:
    
    1. When the editor initializes, before the initial render, it will check
    the current `window.location` for a search param called `d`. If found,
    it will try to parse the value of this param as a deep link and navigate
    to that part of the document.
    2. 500 milliseconds after every time the editor finishes navigating to a
    new part of the document, it will update `window.location` to add the
    latest version of the `d` param.
    
    You can customize this behavior by passing a configuration object as the
    `deepLinks` prop. e.g.
    
    ```tsx
    <Tldraw
            deepLinks={{
                    // change the param name to `page`
                    paramName: 'page',
                    // only link to the current page
                    getTarget(editor) {
                            return { type: 'page', pageId: editor.getCurrentPageId() }
                    },
                    // log the new search params to the console instead of updating `window.location`
                    onChange(url) {
                            console.log('the new search params are', url.searchParams)
                    },
                    // set the debounce interval to 100ms instead of 500ms
                    debounceMs: 100,
            }}
    />
    ```
    
    For full options see the [`TLDeepLinkOptions`](?) API reference.
    
    ## Handling deep links manually
    
    We expose the core functionality for managing deep links as a set of
    methods and utilities. This gives you more control e.g. if you prefer
    not to use search params in the URL.
    
    ### Creating a deep link
    
    You can create an isolated deep link string using the
    [`createDeepLinkString`](?) helper which takes a [`TLDeepLink`](?)
    descriptor object.
    
    ```tsx
    createDeepLinkString({ type: 'page', pageId: 'page:abc123' })
    // => 'pabc123'
    createDeepLinkString({ type: 'shapes', shapeIds: ['shape:foo', 'shape:bar'] })
    // => 'sfoo.bar'
    createDeepLinkString({
            type: 'viewport',
            pageId: 'page:abc123',
            bounds: {
                    x: 0,
                    y: 0,
                    w: 1024,
                    h: 768,
            },
    })
    // => 'v0.0.1024.768.abc123'
    ```
    
    If you do prefer to put this in a URL as a query param, you can use the
    [`Editor#createDeepLink`](?) method.
    
    ```tsx
    editor.createDeepLink({ to: { type: 'page', pageId: 'page:abc123' } })
    // => 'https://my-app.com/document-name?d=pabc123'
    ```
    
    ### Handling a deep link
    
    You can parse a deep link string with [`parseDeepLinkString`](?) which
    returns a [`TLDeepLink`](?) descriptor object.
    
    You can then call [`Editor#handleDeepLink`](?) with this descriptor to
    navigate to the part of the document described by the deep link.
    
    `Editor#handleDeepLink` also can take a plain URL if the deep link is
    encoded as a query param.
    
    ```tsx
    editor.handleDeepLink(parseDeepLinkString('pabc123'))
    // or pass in a url
    editor.handleDeepLink({ url: 'https://my-app.com/document-name?d=pabc123' })
    // or call without options to use the current `window.location`
    editor.handleDeepLink()
    ```
    
    ### Listening for deep link changes
    
    You can listen for deep link changes with the
    [`Editor#registerDeepLinkListener`](?) method, which takes the same
    options as the `deepLinks` prop.
    
    ```tsx
    useEffect(() => {
            const unlisten = editor.registerDeepLinkListener({
                    paramName: 'page',
                    getTarget(editor) {
                            return { type: 'page', pageId: editor.getCurrentPageId() }
                    },
                    onChange(url) {
                            console.log('the new search params are', url.searchParams)
                    },
                    debounceMs: 100,
            })
            return () => {
                    unlisten()
            }
    }, [])
    ```
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Added support for managing deep links.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 2e8c97dfb..cb1d2c890 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -62,7 +62,22 @@ declare global {
 export class TestEditor extends Editor {
 	constructor(options: Partial<Omit<TLEditorOptions, 'store'>> = {}) {
 		const elm = document.createElement('div')
+		const bounds = {
+			x: 0,
+			y: 0,
+			top: 0,
+			left: 0,
+			width: 1080,
+			height: 720,
+			bottom: 720,
+			right: 1080,
+		}
+		// make the app full screen for the sake of the insets property
+		jest.spyOn(document.body, 'scrollWidth', 'get').mockImplementation(() => bounds.width)
+		jest.spyOn(document.body, 'scrollHeight', 'get').mockImplementation(() => bounds.height)
+
 		elm.tabIndex = 0
+		elm.getBoundingClientRect = () => bounds as DOMRect
 
 		const shapeUtilsWithDefaults = [...defaultShapeUtils, ...(options.shapeUtils ?? [])]
 		const bindingUtilsWithDefaults = [...defaultBindingUtils, ...(options.bindingUtils ?? [])]
@@ -79,10 +94,10 @@ export class TestEditor extends Editor {
 			getContainer: () => elm,
 			initialState: 'select',
 		})
+		this.elm = elm
+		this.bounds = bounds
 
 		// Pretty hacky way to mock the screen bounds
-		this.elm = elm
-		this.elm.getBoundingClientRect = () => this.bounds as DOMRect
 		document.body.appendChild(this.elm)
 
 		this.textMeasure.measureText = (
@@ -155,7 +170,16 @@ export class TestEditor extends Editor {
 	}
 
 	elm: HTMLDivElement
-	bounds = { x: 0, y: 0, top: 0, left: 0, width: 1080, height: 720, bottom: 720, right: 1080 }
+	readonly bounds: {
+		x: number
+		y: number
+		top: number
+		left: number
+		width: number
+		height: number
+		bottom: number
+		right: number
+	}
 
 	/**
 	 * The center of the viewport in the current page space.

commit 70a3168046307c15784d628fbf2c28a155d7802e
Author: alex <alex@dytry.ch>
Date:   Tue Aug 27 14:22:57 2024 +0100

    faster (& more!) export snapshot tests (#4411)
    
    Our playwright snapshot tests take quite a long time because there's so
    many of them. For each one we have to open a page, load some content,
    generate the snapshot, and compare it to what we have stored.
    
    This is pretty time consuming, but a lot of the overhead in these steps
    is more or less constant, regardless of the size of the snapshot. This
    diff merges our individual snapshot tests into a smaller number of giant
    snapshots containing many test cases. It also adds some new tests that
    we didn't have before (images, geo shapes, frames).
    
    This revealed that right now, image snapshots are broken - they don't
    respect flip X/Y. I'll fix that in a follow-up.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index cb1d2c890..26620faa6 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -691,7 +691,8 @@ export class TestEditor extends Editor {
 	createShapesFromJsx(
 		shapesJsx: React.JSX.Element | React.JSX.Element[]
 	): Record<string, TLShapeId> {
-		const { shapes, ids } = shapesFromJsx(shapesJsx)
+		const { shapes, assets, ids } = shapesFromJsx(shapesJsx)
+		this.createAssets(assets)
 		this.createShapes(shapes)
 		return ids
 	}

commit 7d0433e91822f9a65a6b5d735918489822849bf0
Author: alex <alex@dytry.ch>
Date:   Wed Sep 4 16:33:26 2024 +0100

    add default <foreignObject> based export for shapes (#4403)
    
    Custom shapes (and our own bookmark shapes) now support SVG exports by
    default! The default implementation isn't the most efficient and won't
    work in all SVG environments, but you can still write your own if
    needed. It's pretty reliable though!
    
    ![Kapture 2024-08-27 at 17 29
    31](https://github.com/user-attachments/assets/3870e82b-b77b-486b-92b0-420921df8d51)
    
    This introduces a couple of new APIs for co-ordinating SVG exports. The
    main one is `useDelaySvgExport`. This is useful when your component
    might take a while to load, and you need to delay the export is until
    everything is ready & rendered. You use it like this:
    ```tsx
    function MyComponent() {
        const exportIsReady = useDelaySvgExport()
        const [dynamicData, setDynamicData] = useState(null)
    
        useEffect(() => {
            loadDynamicData.then((data) => {
                setDynamicData(data)
                exportIsReady()
            })
        })
    
        return <MyList data={data} />
    }
    ```
    
    This is a pretty low-level API that I wouldn't expect most people using
    these exports to need, but it does come in handy for some things.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    Custom shapes (and our own bookmark shapes) now render in image exports
    by default.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 26620faa6..cee67d428 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -169,7 +169,7 @@ export class TestEditor extends Editor {
 		return this.getShape<T>(lastShape)!
 	}
 
-	elm: HTMLDivElement
+	elm: HTMLElement
 	readonly bounds: {
 		x: number
 		y: number

commit a1d1bb6bca0e846f3b5e7ca667bac938f1d6cf2e
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Tue Oct 1 02:57:45 2024 +0100

    text: be able to keep tool locked (#4569)
    
    Noticed during the How-To sesh that you can't lock text shapes üò¢ This
    remedies that.
    
    
    
    https://github.com/user-attachments/assets/b627b2b1-728d-4531-a604-30c41528cc27
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Make text shape be lockable
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index cee67d428..ff61bd252 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -33,6 +33,7 @@ import {
 import { defaultBindingUtils } from '../lib/defaultBindingUtils'
 import { defaultShapeTools } from '../lib/defaultShapeTools'
 import { defaultShapeUtils } from '../lib/defaultShapeUtils'
+import { registerDefaultSideEffects } from '../lib/defaultSideEffects'
 import { defaultTools } from '../lib/defaultTools'
 import { shapesFromJsx } from './test-jsx'
 
@@ -144,6 +145,9 @@ export class TestEditor extends Editor {
 		this.sideEffects.registerAfterCreateHandler('shape', (record) => {
 			this._lastCreatedShapes.push(record)
 		})
+
+		// Wow! we'd forgotten these for a long time
+		registerDefaultSideEffects(this)
 	}
 
 	getHistory() {

commit 4aeb1496b83a80d46c934931f23adb25ea9cf35c
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Thu Oct 3 20:59:09 2024 +0100

    selection: allow cmd/ctrl to add to selection (#4570)
    
    In the How-To sesh, I noticed that using Shift of course lets you add to
    a selection of shapes, but Cmd/Ctrl does not.
    Typically, cmd/ctrl lets you do this in other contexts so some of that
    muscle memory doesn't get allowed in tldraw currently.
    This enables cmd/ctrl to have the same behavior as shift.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Selection: allow cmd/ctrl to add multiple shapes to the selection.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index ff61bd252..de9efd089 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -28,7 +28,9 @@ import {
 	computed,
 	createShapeId,
 	createTLStore,
+	isAccelKey,
 	rotateSelectionHandle,
+	tlenv,
 } from '@tldraw/editor'
 import { defaultBindingUtils } from '../lib/defaultBindingUtils'
 import { defaultShapeTools } from '../lib/defaultShapeTools'
@@ -340,6 +342,8 @@ export class TestEditor extends Editor {
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
+			metaKey: this.inputs.metaKey,
+			accelKey: isAccelKey(this.inputs),
 			point: { x, y, z: null },
 			button: 0,
 			isPen: false,
@@ -357,6 +361,8 @@ export class TestEditor extends Editor {
 			shiftKey: key === 'Shift',
 			ctrlKey: key === 'Control' || key === 'Meta',
 			altKey: key === 'Alt',
+			metaKey: key === 'Meta',
+			accelKey: tlenv.isDarwin ? key === 'Meta' : key === 'Control' || key === 'Meta',
 			...options,
 			name,
 			code:
@@ -364,17 +370,19 @@ export class TestEditor extends Editor {
 					? 'ShiftLeft'
 					: key === 'Alt'
 						? 'AltLeft'
-						: key === 'Control' || key === 'Meta'
+						: key === 'Control'
 							? 'CtrlLeft'
-							: key === ' '
-								? 'Space'
-								: key === 'Enter' ||
-									  key === 'ArrowRight' ||
-									  key === 'ArrowLeft' ||
-									  key === 'ArrowUp' ||
-									  key === 'ArrowDown'
-									? key
-									: 'Key' + key[0].toUpperCase() + key.slice(1),
+							: key === 'Meta'
+								? 'MetaLeft'
+								: key === ' '
+									? 'Space'
+									: key === 'Enter' ||
+										  key === 'ArrowRight' ||
+										  key === 'ArrowLeft' ||
+										  key === 'ArrowUp' ||
+										  key === 'ArrowDown'
+										? key
+										: 'Key' + key[0].toUpperCase() + key.slice(1),
 			type: 'keyboard',
 			key,
 		}
@@ -501,6 +509,7 @@ export class TestEditor extends Editor {
 				shiftKey: this.inputs.shiftKey && key !== 'Shift',
 				ctrlKey: this.inputs.ctrlKey && !(key === 'Control' || key === 'Meta'),
 				altKey: this.inputs.altKey && key !== 'Alt',
+				metaKey: this.inputs.metaKey && key !== 'Meta',
 				...options,
 			}),
 		}).forceTick()
@@ -515,6 +524,8 @@ export class TestEditor extends Editor {
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
+			metaKey: this.inputs.metaKey,
+			accelKey: isAccelKey(this.inputs),
 			...options,
 			delta: { x: dx, y: dy },
 		}).forceTick(2)
@@ -546,6 +557,8 @@ export class TestEditor extends Editor {
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
+			metaKey: this.inputs.metaKey,
+			accelKey: isAccelKey(this.inputs),
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },
@@ -568,6 +581,8 @@ export class TestEditor extends Editor {
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
+			metaKey: this.inputs.metaKey,
+			accelKey: isAccelKey(this.inputs),
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },
@@ -590,6 +605,8 @@ export class TestEditor extends Editor {
 			shiftKey: this.inputs.shiftKey,
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
+			metaKey: this.inputs.metaKey,
+			accelKey: isAccelKey(this.inputs),
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },

commit 9c14e0f1f9db3c37ac58d6df33b5404658132a9f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Oct 7 09:35:01 2024 +0100

    [sync] Set instance.isReadonly automatically  (#4673)
    
    Follow up to #4648 , extracted from #4660
    
    This PR adds a TLStore prop that contains a signal for setting the
    readonly mode. This allows the readonlyness to change on the fly, which
    is necessary for botcom. it's also just nice for tlsync users to be able
    to decide on the server whether something is readonly.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    - Puts the editor into readonly mode automatically when the tlsync
    server responds in readonly mode.
    - Adds the `editor.getIsReadonly()` method.
    - Fixes a bug where arrow labels could be edited in readonly mode.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index de9efd089..60175615d 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -21,6 +21,7 @@ import {
 	TLShape,
 	TLShapeId,
 	TLShapePartial,
+	TLStoreOptions,
 	TLWheelEventInfo,
 	Vec,
 	VecLike,
@@ -63,7 +64,10 @@ declare global {
 }
 
 export class TestEditor extends Editor {
-	constructor(options: Partial<Omit<TLEditorOptions, 'store'>> = {}) {
+	constructor(
+		options: Partial<Omit<TLEditorOptions, 'store'>> = {},
+		storeOptions: Partial<TLStoreOptions> = {}
+	) {
 		const elm = document.createElement('div')
 		const bounds = {
 			x: 0,
@@ -93,6 +97,7 @@ export class TestEditor extends Editor {
 			store: createTLStore({
 				shapeUtils: shapeUtilsWithDefaults,
 				bindingUtils: bindingUtilsWithDefaults,
+				...storeOptions,
 			}),
 			getContainer: () => elm,
 			initialState: 'select',

commit 53c1dbab0ba21083284aaf4d983e1848fae3f9ba
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Dec 9 20:51:33 2024 +0000

    Fix a bug when holding ctrl or meta and rotating (#5087)
    
    This PR fixes a bug that could occur when holding the meta key and
    dragging a rotate handle.
    https://github.com/tldraw/tldraw/issues/4845
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create an image shape
    2. Rotate it
    3. Rotate it while holding cmd, should go to brushing and not crash
    
    - [x] Unit tests
    
    ### Release notes
    
    - Fixed a bug with rotating image / croppable shapes.

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 60175615d..6797cef44 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -348,7 +348,7 @@ export class TestEditor extends Editor {
 			ctrlKey: this.inputs.ctrlKey,
 			altKey: this.inputs.altKey,
 			metaKey: this.inputs.metaKey,
-			accelKey: isAccelKey(this.inputs),
+			accelKey: isAccelKey({ ...this.inputs, ...modifiers }),
 			point: { x, y, z: null },
 			button: 0,
 			isPen: false,

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime ƒåuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists‚Üîheaders, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster ‚Äî I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool ‚Äî can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/test/TestEditor.ts b/packages/tldraw/src/test/TestEditor.ts
index 6797cef44..b0d39d66c 100644
--- a/packages/tldraw/src/test/TestEditor.ts
+++ b/packages/tldraw/src/test/TestEditor.ts
@@ -38,6 +38,7 @@ import { defaultShapeTools } from '../lib/defaultShapeTools'
 import { defaultShapeUtils } from '../lib/defaultShapeUtils'
 import { registerDefaultSideEffects } from '../lib/defaultSideEffects'
 import { defaultTools } from '../lib/defaultTools'
+import { defaultAddFontsFromNode, tipTapDefaultExtensions } from '../lib/utils/text/richText'
 import { shapesFromJsx } from './test-jsx'
 
 jest.useFakeTimers()
@@ -101,6 +102,12 @@ export class TestEditor extends Editor {
 			}),
 			getContainer: () => elm,
 			initialState: 'select',
+			textOptions: {
+				addFontsFromNode: defaultAddFontsFromNode,
+				tipTapConfig: {
+					extensions: tipTapDefaultExtensions,
+				},
+			},
 		})
 		this.elm = elm
 		this.bounds = bounds
@@ -117,6 +124,7 @@ export class TestEditor extends Editor {
 				fontSize: number
 				lineHeight: number
 				maxWidth: null | number
+				padding: string
 			}
 		): BoxModel & { scrollWidth: number } => {
 			const breaks = textToMeasure.split('\n')
@@ -137,6 +145,25 @@ export class TestEditor extends Editor {
 			}
 		}
 
+		this.textMeasure.measureHtml = (
+			html: string,
+			opts: {
+				fontStyle: string
+				fontWeight: string
+				fontFamily: string
+				fontSize: number
+				lineHeight: number
+				maxWidth: null | number
+				padding: string
+			}
+		): BoxModel & { scrollWidth: number } => {
+			const textToMeasure = html
+				.split('</p><p dir="auto">')
+				.join('\n')
+				.replace(/<[^>]+>/g, '')
+			return this.textMeasure.measureText(textToMeasure, opts)
+		}
+
 		this.textMeasure.measureTextSpans = (textToMeasure, opts) => {
 			const box = this.textMeasure.measureText(textToMeasure, {
 				...opts,

