# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/index/field_index/field_index_base.rs

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
new file mode 100644
index 000000000..e9ed36130
--- /dev/null
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -0,0 +1,74 @@
+use crate::index::field_index::map_index::PersistedMapIndex;
+use crate::index::field_index::numeric_index::PersistedNumericIndex;
+use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
+use crate::types::{
+    FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PayloadType, PointOffsetType,
+};
+use serde::{Deserialize, Serialize};
+
+pub trait PayloadFieldIndex {
+    /// Get iterator over points fitting given `condition`
+    fn filter(
+        &self,
+        condition: &FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>>;
+
+    /// Return estimation of points amount which satisfy given condition
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation>;
+
+    /// Iterate conditions for payload blocks with minimum size of `threshold`
+    /// Required for building HNSW index
+    fn payload_blocks(
+        &self,
+        threshold: usize,
+        key: PayloadKeyType,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_>;
+}
+
+pub trait PayloadFieldIndexBuilder {
+    fn add(&mut self, id: PointOffsetType, value: &PayloadType);
+
+    fn build(&mut self) -> FieldIndex;
+}
+
+#[derive(Serialize, Deserialize)]
+pub enum FieldIndex {
+    IntIndex(PersistedNumericIndex<IntPayloadType>),
+    IntMapIndex(PersistedMapIndex<IntPayloadType>),
+    KeywordIndex(PersistedMapIndex<String>),
+    FloatIndex(PersistedNumericIndex<FloatPayloadType>),
+}
+
+impl FieldIndex {
+    pub fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
+        match self {
+            FieldIndex::IntIndex(payload_field_index) => payload_field_index,
+            FieldIndex::IntMapIndex(payload_field_index) => payload_field_index,
+            FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
+            FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
+        }
+    }
+}
+
+impl PayloadFieldIndex for FieldIndex {
+    fn filter(
+        &self,
+        condition: &FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>> {
+        self.get_payload_field_index().filter(condition)
+    }
+
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+        self.get_payload_field_index()
+            .estimate_cardinality(condition)
+    }
+
+    fn payload_blocks(
+        &self,
+        threshold: usize,
+        key: PayloadKeyType,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+        self.get_payload_field_index()
+            .payload_blocks(threshold, key)
+    }
+}

commit 0bd0a1da427db9af97887a865c63a3977333dfc0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jul 30 23:49:02 2021 +0200

    fix new clippy suggestions

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index e9ed36130..6392ff5b0 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -31,6 +31,8 @@ pub trait PayloadFieldIndexBuilder {
     fn build(&mut self) -> FieldIndex;
 }
 
+/// ToDo: Rename with major release
+#[allow(clippy::enum_variant_names)]
 #[derive(Serialize, Deserialize)]
 pub enum FieldIndex {
     IntIndex(PersistedNumericIndex<IntPayloadType>),

commit 617b97d3f7faee4c44913c3adf68935f4e47c47b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Dec 9 11:06:25 2021 +0100

    add comments for segment entitites (#136)
    
    * add comments for segment entitites
    
    * fmt
    
    * cargo fmt

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 6392ff5b0..f41412b1a 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -31,6 +31,8 @@ pub trait PayloadFieldIndexBuilder {
     fn build(&mut self) -> FieldIndex;
 }
 
+/// Common interface for all possible types of field indexes
+/// Enables polymorphism on field indexes
 /// ToDo: Rename with major release
 #[allow(clippy::enum_variant_names)]
 #[derive(Serialize, Deserialize)]

commit e196ce025bcbb1aad04c892205fe07deaa519f7a
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:21 2022 +0400

    fix clippy warnings (#175)
    
    * fix clippy warnings
    
    - doc links
    - explicit deref
    - if instead of match for single bool condition
    - combine similar match branches
    
    * revert removal of transmute
    
    * return Some when vec is not empty

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f41412b1a..cb59d3d3b 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -33,7 +33,7 @@ pub trait PayloadFieldIndexBuilder {
 
 /// Common interface for all possible types of field indexes
 /// Enables polymorphism on field indexes
-/// ToDo: Rename with major release
+/// TODO: Rename with major release
 #[allow(clippy::enum_variant_names)]
 #[derive(Serialize, Deserialize)]
 pub enum FieldIndex {

commit 34048c6fed616fa28b000b964adf3a28ba96ecb7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Sun Mar 20 13:10:08 2022 +0100

    index geo payload (#366)
    
    * index geo payload
    
    * fix group_points_per_region
    
    * code review: use entry API
    
    * geohash into box for payload_blocks
    
    * add failing test for investigation
    
    * workaround for when exp < min
    
    * test with 2 geo values per point
    
    * fix rounding error in cardinality estimation
    
    * fmt
    
    * code review: decompose using Iterator of slices
    
    * code review: handle points with severak geo payloads
    
    * refactor
    
    * fix review comments
    
    * review fixes
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index cb59d3d3b..f23beb0ed 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,3 +1,4 @@
+use crate::index::field_index::geo_index::PersistedGeoMapIndex;
 use crate::index::field_index::map_index::PersistedMapIndex;
 use crate::index::field_index::numeric_index::PersistedNumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
@@ -41,6 +42,7 @@ pub enum FieldIndex {
     IntMapIndex(PersistedMapIndex<IntPayloadType>),
     KeywordIndex(PersistedMapIndex<String>),
     FloatIndex(PersistedNumericIndex<FloatPayloadType>),
+    GeoIndex(PersistedGeoMapIndex),
 }
 
 impl FieldIndex {
@@ -50,6 +52,7 @@ impl FieldIndex {
             FieldIndex::IntMapIndex(payload_field_index) => payload_field_index,
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
+            FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
         }
     }
 }

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f23beb0ed..e950ecbde 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -3,9 +3,10 @@ use crate::index::field_index::map_index::PersistedMapIndex;
 use crate::index::field_index::numeric_index::PersistedNumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::types::{
-    FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PayloadType, PointOffsetType,
+    FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PointOffsetType,
 };
 use serde::{Deserialize, Serialize};
+use serde_json::Value;
 
 pub trait PayloadFieldIndex {
     /// Get iterator over points fitting given `condition`
@@ -26,8 +27,27 @@ pub trait PayloadFieldIndex {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_>;
 }
 
+pub trait ValueIndexer<T> {
+    fn add_many(&mut self, id: PointOffsetType, values: Vec<T>);
+
+    fn get_value(&self, value: &Value) -> Option<T>;
+
+    fn add_point(&mut self, id: PointOffsetType, payload: &Value) {
+        match payload {
+            Value::Array(values) => {
+                self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
+            }
+            _ => {
+                if let Some(x) = self.get_value(payload) {
+                    self.add_many(id, vec![x])
+                }
+            }
+        }
+    }
+}
+
 pub trait PayloadFieldIndexBuilder {
-    fn add(&mut self, id: PointOffsetType, value: &PayloadType);
+    fn add(&mut self, id: PointOffsetType, value: &Value);
 
     fn build(&mut self) -> FieldIndex;
 }

commit 0d50690c47afa50f2ab839be08b791113ee6834d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Apr 1 14:58:00 2022 +0200

    Column index (#405)
    
    * add column storage to field index

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index e950ecbde..517670fef 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -28,10 +28,13 @@ pub trait PayloadFieldIndex {
 }
 
 pub trait ValueIndexer<T> {
+    /// Add multiple values associated with a single point
     fn add_many(&mut self, id: PointOffsetType, values: Vec<T>);
 
+    /// Extract index-able value from payload `Value`
     fn get_value(&self, value: &Value) -> Option<T>;
 
+    /// Add point with payload to index
     fn add_point(&mut self, id: PointOffsetType, payload: &Value) {
         match payload {
             Value::Array(values) => {

commit b07428f62011602b78567225026633592df4cc3c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Apr 3 16:55:51 2022 +0200

    Is empty condition (#423)
    
    * is-empty condition
    
    * fmt
    
    * better assert
    
    * fmt

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 517670fef..f1912e637 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -25,6 +25,9 @@ pub trait PayloadFieldIndex {
         threshold: usize,
         key: PayloadKeyType,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_>;
+
+    /// Returns an amount of unique indexed points
+    fn count_indexed_points(&self) -> usize;
 }
 
 pub trait ValueIndexer<T> {
@@ -101,4 +104,8 @@ impl PayloadFieldIndex for FieldIndex {
         self.get_payload_field_index()
             .payload_blocks(threshold, key)
     }
+
+    fn count_indexed_points(&self) -> usize {
+        self.get_payload_field_index().count_indexed_points()
+    }
 }

commit 493b7381b7293b1bb6d7bccf5591ffdb31427aef
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Wed May 25 11:25:40 2022 -0300

    [real-time index] Extend PayloadFieldIndex trait with load, update and flush (#625)
    
    [real-time index] Extend PayloadFieldIndex trait with load, update and flush methods

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f1912e637..e26f68a89 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,3 +1,4 @@
+use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::geo_index::PersistedGeoMapIndex;
 use crate::index::field_index::map_index::PersistedMapIndex;
 use crate::index::field_index::numeric_index::PersistedNumericIndex;
@@ -9,6 +10,12 @@ use serde::{Deserialize, Serialize};
 use serde_json::Value;
 
 pub trait PayloadFieldIndex {
+    /// Load index from disk.
+    fn load(&mut self) -> OperationResult<()>;
+
+    /// Flush all pending updates to disk.
+    fn flush(&self) -> OperationResult<()>;
+
     /// Get iterator over points fitting given `condition`
     fn filter(
         &self,
@@ -81,9 +88,26 @@ impl FieldIndex {
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
         }
     }
+    pub fn get_payload_field_index_mut(&mut self) -> &mut dyn PayloadFieldIndex {
+        match self {
+            FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index,
+        }
+    }
 }
 
 impl PayloadFieldIndex for FieldIndex {
+    fn load(&mut self) -> OperationResult<()> {
+        self.get_payload_field_index_mut().load()
+    }
+
+    fn flush(&self) -> OperationResult<()> {
+        self.get_payload_field_index().flush()
+    }
+
     fn filter(
         &self,
         condition: &FieldCondition,

commit c15981092ac33c7dde9541ab4a2df558e6abe4e6
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Jun 6 12:14:20 2022 -0300

    [WIP] [real-time index] Implement payloadstorage for structpayloadindex (#642)
    
    * [real-time index] Extend FieldIndex enum and StructPayloadIndex with method from PayloadStorage
    
    * [real-time index] add missing remove_point methods
    
    * [real-time index] add new index to FieldIndex enum
    
    * fix compile
    
    * are you happy fmt
    
    * merge load and remove
    
    * fix test generics
    
    * decrement points count
    
    * remove from histogram
    
    * simplify histogram usage
    
    * [real-time index] remove old tests and fix clippy warnings
    
    * histogram: method to derive range by size (#657)
    
    * [real-time index] add histogram based payload_blocks implementation.
    
    * payload blocks
    
    * fmt
    
    * clippy
    
    * [real-time index] refactor Segment to use PayloadIndex instead of PayloadStorage.
    
    * fix tests
    
    * fmt
    
    * clippy
    
    * rename indexes
    
    * remove redundent params
    
    * add struct payload deletion test + fix delete payload in map index
    
    * remove payload threshold
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index e26f68a89..a2fdb117e 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,22 +1,28 @@
 use crate::entry::entry_point::OperationResult;
-use crate::index::field_index::geo_index::PersistedGeoMapIndex;
-use crate::index::field_index::map_index::PersistedMapIndex;
-use crate::index::field_index::numeric_index::PersistedNumericIndex;
+use crate::index::field_index::geo_index::GeoMapIndex;
+use crate::index::field_index::map_index::MapIndex;
+use crate::index::field_index::numeric_index::NumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::types::{
     FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PointOffsetType,
 };
-use serde::{Deserialize, Serialize};
 use serde_json::Value;
 
 pub trait PayloadFieldIndex {
+    /// Return number of points with at least one value indexed in here
+    fn indexed_points(&self) -> usize;
+
     /// Load index from disk.
-    fn load(&mut self) -> OperationResult<()>;
+    fn load(&mut self) -> OperationResult<bool>;
+
+    /// Remove db content of the current payload index
+    fn clear(self) -> OperationResult<()>;
 
     /// Flush all pending updates to disk.
     fn flush(&self) -> OperationResult<()>;
 
     /// Get iterator over points fitting given `condition`
+    /// Return `None` if condition does not match the index type
     fn filter(
         &self,
         condition: &FieldCondition,
@@ -39,13 +45,13 @@ pub trait PayloadFieldIndex {
 
 pub trait ValueIndexer<T> {
     /// Add multiple values associated with a single point
-    fn add_many(&mut self, id: PointOffsetType, values: Vec<T>);
+    fn add_many(&mut self, id: PointOffsetType, values: Vec<T>) -> OperationResult<()>;
 
     /// Extract index-able value from payload `Value`
     fn get_value(&self, value: &Value) -> Option<T>;
 
     /// Add point with payload to index
-    fn add_point(&mut self, id: PointOffsetType, payload: &Value) {
+    fn add_point(&mut self, id: PointOffsetType, payload: &Value) -> OperationResult<()> {
         match payload {
             Value::Array(values) => {
                 self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
@@ -53,33 +59,31 @@ pub trait ValueIndexer<T> {
             _ => {
                 if let Some(x) = self.get_value(payload) {
                     self.add_many(id, vec![x])
+                } else {
+                    Ok(())
                 }
             }
         }
     }
-}
 
-pub trait PayloadFieldIndexBuilder {
-    fn add(&mut self, id: PointOffsetType, value: &Value);
-
-    fn build(&mut self) -> FieldIndex;
+    /// remove a point from the index
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()>;
 }
 
 /// Common interface for all possible types of field indexes
 /// Enables polymorphism on field indexes
 /// TODO: Rename with major release
 #[allow(clippy::enum_variant_names)]
-#[derive(Serialize, Deserialize)]
 pub enum FieldIndex {
-    IntIndex(PersistedNumericIndex<IntPayloadType>),
-    IntMapIndex(PersistedMapIndex<IntPayloadType>),
-    KeywordIndex(PersistedMapIndex<String>),
-    FloatIndex(PersistedNumericIndex<FloatPayloadType>),
-    GeoIndex(PersistedGeoMapIndex),
+    IntIndex(NumericIndex<IntPayloadType>),
+    IntMapIndex(MapIndex<IntPayloadType>),
+    KeywordIndex(MapIndex<String>),
+    FloatIndex(NumericIndex<FloatPayloadType>),
+    GeoIndex(GeoMapIndex),
 }
 
 impl FieldIndex {
-    pub fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
+    fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
         match self {
             FieldIndex::IntIndex(payload_field_index) => payload_field_index,
             FieldIndex::IntMapIndex(payload_field_index) => payload_field_index,
@@ -88,7 +92,9 @@ impl FieldIndex {
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
         }
     }
-    pub fn get_payload_field_index_mut(&mut self) -> &mut dyn PayloadFieldIndex {
+
+    #[allow(dead_code)]
+    fn get_payload_field_index_mut(&mut self) -> &mut dyn PayloadFieldIndex {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index,
@@ -97,30 +103,61 @@ impl FieldIndex {
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index,
         }
     }
-}
 
-impl PayloadFieldIndex for FieldIndex {
-    fn load(&mut self) -> OperationResult<()> {
-        self.get_payload_field_index_mut().load()
+    pub fn load(&mut self) -> OperationResult<bool> {
+        match self {
+            FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
+        }
+    }
+
+    pub fn clear(self) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(index) => index.clear(),
+            FieldIndex::IntMapIndex(index) => index.clear(),
+            FieldIndex::KeywordIndex(index) => index.clear(),
+            FieldIndex::FloatIndex(index) => index.clear(),
+            FieldIndex::GeoIndex(index) => index.clear(),
+        }
+    }
+
+    pub fn recreate(&self) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(index) => index.recreate(),
+            FieldIndex::IntMapIndex(index) => index.recreate(),
+            FieldIndex::KeywordIndex(index) => index.recreate(),
+            FieldIndex::FloatIndex(index) => index.recreate(),
+            FieldIndex::GeoIndex(index) => index.recreate(),
+        }
+    }
+
+    pub fn indexed_points(&self) -> usize {
+        self.get_payload_field_index().indexed_points()
     }
 
-    fn flush(&self) -> OperationResult<()> {
+    pub fn flush(&self) -> OperationResult<()> {
         self.get_payload_field_index().flush()
     }
 
-    fn filter(
+    pub fn filter(
         &self,
         condition: &FieldCondition,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>> {
         self.get_payload_field_index().filter(condition)
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    pub fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+    ) -> Option<CardinalityEstimation> {
         self.get_payload_field_index()
             .estimate_cardinality(condition)
     }
 
-    fn payload_blocks(
+    pub fn payload_blocks(
         &self,
         threshold: usize,
         key: PayloadKeyType,
@@ -129,7 +166,37 @@ impl PayloadFieldIndex for FieldIndex {
             .payload_blocks(threshold, key)
     }
 
-    fn count_indexed_points(&self) -> usize {
+    pub fn count_indexed_points(&self) -> usize {
         self.get_payload_field_index().count_indexed_points()
     }
+
+    pub fn add_point(&mut self, id: PointOffsetType, payload: &Value) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
+            FieldIndex::IntMapIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
+            FieldIndex::KeywordIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
+            FieldIndex::FloatIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
+            FieldIndex::GeoIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
+        }
+    }
+
+    pub fn remove_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(index) => index.remove_point(point_id),
+            FieldIndex::IntMapIndex(index) => index.remove_point(point_id),
+            FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
+            FieldIndex::FloatIndex(index) => index.remove_point(point_id),
+            FieldIndex::GeoIndex(index) => index.remove_point(point_id),
+        }
+    }
 }

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index a2fdb117e..fefae9df5 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,3 +1,5 @@
+use serde_json::Value;
+
 use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::map_index::MapIndex;
@@ -6,7 +8,6 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::types::{
     FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PointOffsetType,
 };
-use serde_json::Value;
 
 pub trait PayloadFieldIndex {
     /// Return number of points with at least one value indexed in here

commit 42e930ab8f2fbda080511d5f4fc1092ee70e8c88
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Jul 22 19:27:07 2022 +0400

    Segment telemetry (#814)
    
    * segment telemetry
    
    * anonymize trait
    
    * fix build
    
    * are you happy fmt
    
    * anonimyze implementations
    
    * sliding window avg (#826)
    
    * Actix web telemetry (#828)
    
    * actix web telemetry
    
    * small as move
    
    * use tokio mutex instead of std
    
    * add comments
    
    * are you happy fmt
    
    * use u16 as http status code
    
    * telemetry structs rename
    
    * fix build
    
    * using parking lot mutex
    
    * telemetry web api (#842)
    
    * telemetry web api
    
    * telemetry openapi (#843)
    
    * use async mutex for telemetry collector
    
    * use tokio mutex for telemetry collector
    
    * are you happy fmt

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index fefae9df5..5df05c2c4 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -5,6 +5,7 @@ use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::map_index::MapIndex;
 use crate::index::field_index::numeric_index::NumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
+use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PointOffsetType,
 };
@@ -200,4 +201,14 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
         }
     }
+
+    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
+        match self {
+            FieldIndex::IntIndex(index) => index.get_telemetry_data(),
+            FieldIndex::IntMapIndex(index) => index.get_telemetry_data(),
+            FieldIndex::KeywordIndex(index) => index.get_telemetry_data(),
+            FieldIndex::FloatIndex(index) => index.get_telemetry_data(),
+            FieldIndex::GeoIndex(index) => index.get_telemetry_data(),
+        }
+    }
 }

commit f357bd5d9bc8cdc05915111419894d4f25512d83
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 15 13:47:52 2022 +0400

    Allow to flush segment in separate thread (#927)
    
    * allow to flush segment in separate thread
    
    * flush as separate function (#928)
    
    * flush as separate function
    
    * review suggestion
    
    * reduce locks during vector scoring
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * don't run background flush twice
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * increase flush interval
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * are you happy fmt
    
    * test background flush
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 5df05c2c4..54bc21d55 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,5 +1,6 @@
 use serde_json::Value;
 
+use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::map_index::MapIndex;
@@ -20,8 +21,8 @@ pub trait PayloadFieldIndex {
     /// Remove db content of the current payload index
     fn clear(self) -> OperationResult<()>;
 
-    /// Flush all pending updates to disk.
-    fn flush(&self) -> OperationResult<()>;
+    /// Return function that flushes all pending updates to disk.
+    fn flusher(&self) -> Flusher;
 
     /// Get iterator over points fitting given `condition`
     /// Return `None` if condition does not match the index type
@@ -140,8 +141,8 @@ impl FieldIndex {
         self.get_payload_field_index().indexed_points()
     }
 
-    pub fn flush(&self) -> OperationResult<()> {
-        self.get_payload_field_index().flush()
+    pub fn flusher(&self) -> Flusher {
+        self.get_payload_field_index().flusher()
     }
 
     pub fn filter(

commit b9eee55a9fb6d53572622f62756a80e62484009e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Sep 1 12:50:12 2022 +0200

    Full text search (#963)
    
    * allow additional params for payload field index
    
    * fmt
    
    * wip: full text index building
    
    * fmt
    
    * text search request
    
    * text search request
    
    * full text index persitance and loading
    
    * fmt
    
    * enable fts index in mapping
    
    * clippy
    
    * fix tests + add integration test
    
    * review fixes: extend payload index test
    
    * revert incedental change

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 54bc21d55..5c3bcd471 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -2,6 +2,7 @@ use serde_json::Value;
 
 use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
+use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::map_index::MapIndex;
 use crate::index::field_index::numeric_index::NumericIndex;
@@ -83,6 +84,7 @@ pub enum FieldIndex {
     KeywordIndex(MapIndex<String>),
     FloatIndex(NumericIndex<FloatPayloadType>),
     GeoIndex(GeoMapIndex),
+    FullTextIndex(FullTextIndex),
 }
 
 impl FieldIndex {
@@ -93,6 +95,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
+            FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
         }
     }
 
@@ -104,6 +107,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index,
         }
     }
 
@@ -114,6 +118,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
         }
     }
 
@@ -124,6 +129,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.clear(),
             FieldIndex::FloatIndex(index) => index.clear(),
             FieldIndex::GeoIndex(index) => index.clear(),
+            FieldIndex::FullTextIndex(index) => index.clear(),
         }
     }
 
@@ -134,6 +140,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.recreate(),
             FieldIndex::FloatIndex(index) => index.recreate(),
             FieldIndex::GeoIndex(index) => index.recreate(),
+            FieldIndex::FullTextIndex(index) => index.recreate(),
         }
     }
 
@@ -190,6 +197,9 @@ impl FieldIndex {
             FieldIndex::GeoIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
+            FieldIndex::FullTextIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
         }
     }
 
@@ -200,6 +210,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
             FieldIndex::FloatIndex(index) => index.remove_point(point_id),
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
+            FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
         }
     }
 
@@ -210,6 +221,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.get_telemetry_data(),
             FieldIndex::FloatIndex(index) => index.get_telemetry_data(),
             FieldIndex::GeoIndex(index) => index.get_telemetry_data(),
+            FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
         }
     }
 }

commit bf480661458cb01af0291adb8992c76b71e2d553
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Oct 20 10:26:33 2022 +0200

    Full reassign payload on upsert (#1148)
    
    * set_full_payload on upsert
    
    * fmt
    
    * fix clippy

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 5c3bcd471..1043258ae 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -58,10 +58,12 @@ pub trait ValueIndexer<T> {
     fn add_point(&mut self, id: PointOffsetType, payload: &Value) -> OperationResult<()> {
         match payload {
             Value::Array(values) => {
+                self.remove_point(id)?;
                 self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
             }
             _ => {
                 if let Some(x) = self.get_value(payload) {
+                    self.remove_point(id)?;
                     self.add_many(id, vec![x])
                 } else {
                     Ok(())

commit 3d8b5131bd54079a534f840eaf0f69e570a68517
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Feb 23 15:57:12 2023 +0100

    Nested payload filters (#1487)
    
    * Nested payload filters
    
    * close ToDo + add parsing of multuiple array values
    
    * fmt
    
    * improve testing nested arrays
    
    * fix NumericIndex to accumulate points_to_values mapping
    
    * revert numberic index + strict array field access
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 1043258ae..183927c62 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,5 +1,6 @@
 use serde_json::Value;
 
+use crate::common::utils::MultiValue;
 use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
@@ -49,26 +50,50 @@ pub trait PayloadFieldIndex {
 
 pub trait ValueIndexer<T> {
     /// Add multiple values associated with a single point
+    /// This function should be called only once for each point
     fn add_many(&mut self, id: PointOffsetType, values: Vec<T>) -> OperationResult<()>;
 
     /// Extract index-able value from payload `Value`
     fn get_value(&self, value: &Value) -> Option<T>;
 
     /// Add point with payload to index
-    fn add_point(&mut self, id: PointOffsetType, payload: &Value) -> OperationResult<()> {
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &MultiValue<&Value>,
+    ) -> OperationResult<()> {
         match payload {
-            Value::Array(values) => {
+            MultiValue::Multiple(values) => {
+                self.remove_point(id)?;
+                let mut flatten_values: Vec<_> = vec![];
+
+                for value in values {
+                    match value {
+                        Value::Array(values) => {
+                            flatten_values.extend(values.iter().flat_map(|x| self.get_value(x)));
+                        }
+                        _ => {
+                            if let Some(x) = self.get_value(value) {
+                                flatten_values.push(x);
+                            }
+                        }
+                    }
+                }
+                self.add_many(id, flatten_values)
+            }
+            MultiValue::Single(Some(Value::Array(values))) => {
                 self.remove_point(id)?;
                 self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
             }
-            _ => {
-                if let Some(x) = self.get_value(payload) {
+            MultiValue::Single(Some(value)) => {
+                if let Some(x) = self.get_value(value) {
                     self.remove_point(id)?;
                     self.add_many(id, vec![x])
                 } else {
                     Ok(())
                 }
             }
+            MultiValue::Single(None) => Ok(()),
         }
     }
 
@@ -182,7 +207,11 @@ impl FieldIndex {
         self.get_payload_field_index().count_indexed_points()
     }
 
-    pub fn add_point(&mut self, id: PointOffsetType, payload: &Value) -> OperationResult<()> {
+    pub fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &MultiValue<&Value>,
+    ) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)

commit 0f0c213c2a94ee387a40e5309c3ae15e0e2c7c96
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed May 10 14:20:12 2023 +0200

    Nested object filter (#1602)
    
    * nested object filter
    
    * code review
    
    * add support for must_not in nested
    
    * extract functions
    
    * support and test must_not in SimpleConditionChecker
    
    * add index matching unit test (to be continued)
    
    * remove extra clone
    
    * test with should
    
    * WIP: Nested object filter suggestions (#1855)
    
    * switch to bitvec
    
    * fix clippy
    
    * more tests
    
    * fmt
    
    * fix some tests
    
    * add test with text
    
    * support for nested should
    
    * do not rely on indexes for nested queries & fix test
    
    * use index to make index-aware checks in nested payload
    
    * fix value-count tests
    
    * re-fa-cto-ring
    
    * fmt
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 183927c62..860e60cc2 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -10,7 +10,8 @@ use crate::index::field_index::numeric_index::NumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    FieldCondition, FloatPayloadType, IntPayloadType, PayloadKeyType, PointOffsetType,
+    FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText, PayloadKeyType,
+    PointOffsetType,
 };
 
 pub trait PayloadFieldIndex {
@@ -56,6 +57,14 @@ pub trait ValueIndexer<T> {
     /// Extract index-able value from payload `Value`
     fn get_value(&self, value: &Value) -> Option<T>;
 
+    /// Try to extract index-able values from payload `Value`, even if it is an array
+    fn get_values(&self, value: &Value) -> Vec<T> {
+        match value {
+            Value::Array(values) => values.iter().flat_map(|x| self.get_value(x)).collect(),
+            _ => self.get_value(value).map(|x| vec![x]).unwrap_or_default(),
+        }
+    }
+
     /// Add point with payload to index
     fn add_point(
         &mut self,
@@ -115,6 +124,40 @@ pub enum FieldIndex {
 }
 
 impl FieldIndex {
+    /// Try to check condition for a payload given a field index.
+    /// Required because some index parameters may influence the condition checking logic.
+    /// For example, full text index may have different tokenizers.
+    ///
+    /// Returns `None` if there is no special logic for the given index
+    /// returns `Some(true)` if condition is satisfied
+    /// returns `Some(false)` if condition is not satisfied
+    pub fn check_condition(
+        &self,
+        condition: &FieldCondition,
+        payload_value: &Value,
+    ) -> Option<bool> {
+        match self {
+            FieldIndex::IntIndex(_) => None,
+            FieldIndex::IntMapIndex(_) => None,
+            FieldIndex::KeywordIndex(_) => None,
+            FieldIndex::FloatIndex(_) => None,
+            FieldIndex::GeoIndex(_) => None,
+            FieldIndex::FullTextIndex(full_text_index) => match &condition.r#match {
+                Some(Match::Text(MatchText { text })) => {
+                    let query = full_text_index.parse_query(text);
+                    for value in full_text_index.get_values(payload_value) {
+                        let document = full_text_index.parse_document(&value);
+                        if query.check_match(&document) {
+                            return Some(true);
+                        }
+                    }
+                    Some(false)
+                }
+                _ => None,
+            },
+        }
+    }
+
     fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
         match self {
             FieldIndex::IntIndex(payload_field_index) => payload_field_index,

commit f5dfeeff4c4baf35045bc6904d88076f2e58d094
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 22 20:32:35 2023 +0200

    Fixes for group-by (#1938)
    
    * fix payload seletor
    
    * clippy
    
    * except cardinality estimation
    
    * implement match except iterator and api
    
    * use except instead of must-not + test
    
    * Fix doc error
    
    * Update lib/collection/src/grouping/group_by.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/vector_storage/mod.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/collection/src/grouping/group_by.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update lib/segment/src/index/field_index/map_index.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update lib/segment/src/index/field_index/map_index.rs [skip ci]
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * fix: `except_on` and `match_on` now produce `Vec<Condition>`s
    
    * Apply suggestions from code review (lib/segment/src/index/field_index/map_index.rs)
    
    * fix: reset review suggestion
    
    * Remove unnecessary move
    
    * Use Rust idiomatic map_else rather than match-none-false
    
    * is-null -> is-empty
    
    * de-comment drop_collection
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 860e60cc2..f3a266aab 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -29,10 +29,10 @@ pub trait PayloadFieldIndex {
 
     /// Get iterator over points fitting given `condition`
     /// Return `None` if condition does not match the index type
-    fn filter(
-        &self,
-        condition: &FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>>;
+    fn filter<'a>(
+        &'a self,
+        condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
 
     /// Return estimation of points amount which satisfy given condition
     fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation>;
@@ -222,10 +222,10 @@ impl FieldIndex {
         self.get_payload_field_index().flusher()
     }
 
-    pub fn filter(
-        &self,
-        condition: &FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + '_>> {
+    pub fn filter<'a>(
+        &'a self,
+        condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         self.get_payload_field_index().filter(condition)
     }
 
@@ -298,4 +298,15 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
         }
     }
+
+    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
+        match self {
+            FieldIndex::IntIndex(index) => index.values_count(point_id),
+            FieldIndex::IntMapIndex(index) => index.values_count(point_id),
+            FieldIndex::KeywordIndex(index) => index.values_count(point_id),
+            FieldIndex::FloatIndex(index) => index.values_count(point_id),
+            FieldIndex::GeoIndex(index) => index.values_count(point_id),
+            FieldIndex::FullTextIndex(index) => index.values_count(point_id),
+        }
+    }
 }

commit 4016aa6af5186c679649967d58df1eef1e43d104
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Jun 14 13:56:16 2023 -0400

    Optimize `is_empty` (#2073)
    
    * optimize is_empty condition for hitting index
    
    * Optimize is_null too, simplify checker
    
    * refactor: introduce values_is_empty() for indexes
    - use `.then()` instead of `&&`
    
    * cargo fmt
    
    * improve comments
    
    * Revert "Optimize is_null too, simplify checker"
    
    This reverts commit b9ebfe5ff28319090194cd5eb88a399b8f607fbf.
    
    * changes from review
    
    * update `test_is_empty_conditions` test for comparing indexed vs not indexed results

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f3a266aab..60344e816 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -309,4 +309,15 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
         }
     }
+
+    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
+        match self {
+            FieldIndex::IntIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::IntMapIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::KeywordIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::FloatIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::GeoIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
+        }
+    }
 }

commit df62ace403d2d5554078a346a96fe4988d6c1b21
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Jul 3 12:49:53 2023 -0400

    Add binary index (#2107)
    
    * nitpick: use CardinalityEstimation::exact() instead of explicit struct
    
    * wip: implement binary index
    
    * persist binary index
    
    * add tests, refactor binary memory
    
    * use bitflags for BinaryItem, use early return from @timvisee 's review
    
    * fix iterator's end +1
    
    * fix indexed_count, keep track of falses and trues counts
    
    * Fix true/false counts if flag for point was set already
    
    * Remove match in filter structure
    
    * - rename `*_count()`
    - fix set_or_insert to actually set
    - add more tests
    
    * review suggestions for binary index (#2186)
    
    * small taste refactors
    
    * move memory into its own module
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 60344e816..85298eb95 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -3,6 +3,7 @@ use serde_json::Value;
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
+use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::map_index::MapIndex;
@@ -121,6 +122,7 @@ pub enum FieldIndex {
     FloatIndex(NumericIndex<FloatPayloadType>),
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),
+    BinaryIndex(BinaryIndex),
 }
 
 impl FieldIndex {
@@ -142,6 +144,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(_) => None,
             FieldIndex::FloatIndex(_) => None,
             FieldIndex::GeoIndex(_) => None,
+            FieldIndex::BinaryIndex(_) => None,
             FieldIndex::FullTextIndex(full_text_index) => match &condition.r#match {
                 Some(Match::Text(MatchText { text })) => {
                     let query = full_text_index.parse_query(text);
@@ -165,6 +168,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
+            FieldIndex::BinaryIndex(payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
         }
     }
@@ -177,6 +181,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index,
         }
     }
@@ -188,6 +193,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
         }
     }
@@ -199,6 +205,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.clear(),
             FieldIndex::FloatIndex(index) => index.clear(),
             FieldIndex::GeoIndex(index) => index.clear(),
+            FieldIndex::BinaryIndex(index) => index.clear(),
             FieldIndex::FullTextIndex(index) => index.clear(),
         }
     }
@@ -210,6 +217,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.recreate(),
             FieldIndex::FloatIndex(index) => index.recreate(),
             FieldIndex::GeoIndex(index) => index.recreate(),
+            FieldIndex::BinaryIndex(index) => index.recreate(),
             FieldIndex::FullTextIndex(index) => index.recreate(),
         }
     }
@@ -271,6 +279,9 @@ impl FieldIndex {
             FieldIndex::GeoIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
+            FieldIndex::BinaryIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
             FieldIndex::FullTextIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
@@ -284,6 +295,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
             FieldIndex::FloatIndex(index) => index.remove_point(point_id),
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
+            FieldIndex::BinaryIndex(index) => index.remove_point(point_id),
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
         }
     }
@@ -295,6 +307,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.get_telemetry_data(),
             FieldIndex::FloatIndex(index) => index.get_telemetry_data(),
             FieldIndex::GeoIndex(index) => index.get_telemetry_data(),
+            FieldIndex::BinaryIndex(index) => index.get_telemetry_data(),
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
         }
     }
@@ -306,6 +319,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.values_count(point_id),
             FieldIndex::FloatIndex(index) => index.values_count(point_id),
             FieldIndex::GeoIndex(index) => index.values_count(point_id),
+            FieldIndex::BinaryIndex(index) => index.values_count(point_id),
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
         }
     }
@@ -317,6 +331,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FloatIndex(index) => index.values_is_empty(point_id),
             FieldIndex::GeoIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::BinaryIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
         }
     }

commit 0d9542b7114c68094cb1c5f4eb25e795e44f1ef9
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Jul 3 13:25:54 2023 -0400

    Small refactor: remove duplicated `indexed_points()` function (#2103)
    
    * remove duplicated `indexed_points()` function
    
    * update for binary index

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 85298eb95..2c45ab559 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -17,7 +17,7 @@ use crate::types::{
 
 pub trait PayloadFieldIndex {
     /// Return number of points with at least one value indexed in here
-    fn indexed_points(&self) -> usize;
+    fn count_indexed_points(&self) -> usize;
 
     /// Load index from disk.
     fn load(&mut self) -> OperationResult<bool>;
@@ -45,9 +45,6 @@ pub trait PayloadFieldIndex {
         threshold: usize,
         key: PayloadKeyType,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_>;
-
-    /// Returns an amount of unique indexed points
-    fn count_indexed_points(&self) -> usize;
 }
 
 pub trait ValueIndexer<T> {
@@ -222,8 +219,8 @@ impl FieldIndex {
         }
     }
 
-    pub fn indexed_points(&self) -> usize {
-        self.get_payload_field_index().indexed_points()
+    pub fn count_indexed_points(&self) -> usize {
+        self.get_payload_field_index().count_indexed_points()
     }
 
     pub fn flusher(&self) -> Flusher {
@@ -254,10 +251,6 @@ impl FieldIndex {
             .payload_blocks(threshold, key)
     }
 
-    pub fn count_indexed_points(&self) -> usize {
-        self.get_payload_field_index().count_indexed_points()
-    }
-
     pub fn add_point(
         &mut self,
         id: PointOffsetType,

commit 11e2029be339d65488fd6f8fdbe5038518fdef1a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Aug 10 14:01:38 2023 +0200

    Optimize strings ram usage for map index (#2388)
    
    * optimize strings ram usage for map index
    
    * conversion tests
    
    * are you happy fmt
    
    * better unicode test
    
    * better unicode test
    
    * are you happy clippy
    
    * better comment
    
    * are you happy fmt
    
    * Use SmolStr instead of custom string

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 2c45ab559..f3774b894 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,4 +1,5 @@
 use serde_json::Value;
+use smol_str::SmolStr;
 
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
@@ -115,7 +116,7 @@ pub trait ValueIndexer<T> {
 pub enum FieldIndex {
     IntIndex(NumericIndex<IntPayloadType>),
     IntMapIndex(MapIndex<IntPayloadType>),
-    KeywordIndex(MapIndex<String>),
+    KeywordIndex(MapIndex<SmolStr>),
     FloatIndex(NumericIndex<FloatPayloadType>),
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),

commit 9afca039556c1369faaf7b67133cea48015c7721
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Aug 16 15:27:46 2023 +0200

    Map index as a enum (#2446)
    
    * map index trait
    
    * remove trait and move into separate files

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f3774b894..60ec36b60 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,13 +1,13 @@
 use serde_json::Value;
 use smol_str::SmolStr;
 
+use super::map_index::MapIndex;
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
-use crate::index::field_index::map_index::MapIndex;
 use crate::index::field_index::numeric_index::NumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;

commit 1611deaf034a8ec219b4aab80abe31200bb8fc15
Author: Eugene Tolbakov <ev.tolbakov@gmail.com>
Date:   Mon Sep 25 14:10:45 2023 +0100

    Refactor: replace expect with ServiceError, remove repetive code (#2701)
    
    * Refactor: replace expect with ServiceError, remove repetive code
    
    * chore: remove unnecessary code
    
    * chore: apply cr suggestions
    
    * chore: apply clippy recommendations
    
    * Improve constructing errors
    
    * Improve test assertions
    
    * fix: replace max_regions assertion with operation error
    
    * fix: adjust according to CR
    
    * chore: replace Option with OperationResult for estimate_cardinality
    
    * chore: replace Option with OperationResult for filter
    
    * Better handling of transforming none into an error
    
    * Replace for loop with simple iterator, simply other iterator
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 60ec36b60..0d98ec624 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -34,10 +34,13 @@ pub trait PayloadFieldIndex {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
+    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
 
     /// Return estimation of points amount which satisfy given condition
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation>;
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+    ) -> OperationResult<CardinalityEstimation>;
 
     /// Iterate conditions for payload blocks with minimum size of `threshold`
     /// Required for building HNSW index
@@ -231,14 +234,14 @@ impl FieldIndex {
     pub fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         self.get_payload_field_index().filter(condition)
     }
 
     pub fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
-    ) -> Option<CardinalityEstimation> {
+    ) -> OperationResult<CardinalityEstimation> {
         self.get_payload_field_index()
             .estimate_cardinality(condition)
     }

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 0d98ec624..4e5948701 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,3 +1,4 @@
+use common::types::PointOffsetType;
 use serde_json::Value;
 use smol_str::SmolStr;
 
@@ -13,7 +14,6 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText, PayloadKeyType,
-    PointOffsetType,
 };
 
 pub trait PayloadFieldIndex {

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 4e5948701..25ca5bc09 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -3,9 +3,9 @@ use serde_json::Value;
 use smol_str::SmolStr;
 
 use super::map_index::MapIndex;
+use crate::common::operation_error::OperationResult;
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
-use crate::entry::entry_point::OperationResult;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;

commit dc61db86193308f2d0eeab48d4858ac800b1217f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Nov 6 09:43:06 2023 +0100

    Int indexing (#2927)
    
    * remove point from index if value was replaced with incompatible
    
    * fmt

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 25ca5bc09..ab04b4751 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -73,9 +73,9 @@ pub trait ValueIndexer<T> {
         id: PointOffsetType,
         payload: &MultiValue<&Value>,
     ) -> OperationResult<()> {
+        self.remove_point(id)?;
         match payload {
             MultiValue::Multiple(values) => {
-                self.remove_point(id)?;
                 let mut flatten_values: Vec<_> = vec![];
 
                 for value in values {
@@ -93,12 +93,10 @@ pub trait ValueIndexer<T> {
                 self.add_many(id, flatten_values)
             }
             MultiValue::Single(Some(Value::Array(values))) => {
-                self.remove_point(id)?;
                 self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
             }
             MultiValue::Single(Some(value)) => {
                 if let Some(x) = self.get_value(value) {
-                    self.remove_point(id)?;
                     self.add_many(id, vec![x])
                 } else {
                     Ok(())

commit 2f76603ddfbe5f995443c1e5e85c2d9345a55db0
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 31 10:14:31 2024 +0000

    DateTime payload index (#3395)
    
    * Datetime payload index
    
    * Introduce IndexMapItem
    
    * Drop FieldIndex::DatetimeIndex
    
    * Rename OpenAPI struct names
    
    * Switch to microseconds
    
    * Validate and serialize grpc timestamps
    
    * Add tests with different timezones
    
    * minor review fixes
    
    * Revert "Drop FieldIndex::DatetimeIndex"
    
    This reverts commit d55f251afdbb418ef732a3e6799b92f924fc3035.
    
    * Revert "Introduce IndexMapItem"
    
    This reverts commit c5255f6b1aafa2b9552bac5d1811f9e826eb8d61.
    
    * fix: back to microseconds after reverts
    
    * extract range conversion from boxed checker fn
    
    * add log to deps
    
    * don't run macro doctest
    
    * no_run -> ignore
    
    * remove prost-types in favor of prost-wkt-types
    
    * better assertion on test_payload_indexing.py
    
    * propagate unparsable datetime
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index ab04b4751..21b225344 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -13,7 +13,8 @@ use crate::index::field_index::numeric_index::NumericIndex;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText, PayloadKeyType,
+    DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
+    PayloadKeyType,
 };
 
 pub trait PayloadFieldIndex {
@@ -116,6 +117,7 @@ pub trait ValueIndexer<T> {
 #[allow(clippy::enum_variant_names)]
 pub enum FieldIndex {
     IntIndex(NumericIndex<IntPayloadType>),
+    DatetimeIndex(NumericIndex<IntPayloadType>),
     IntMapIndex(MapIndex<IntPayloadType>),
     KeywordIndex(MapIndex<SmolStr>),
     FloatIndex(NumericIndex<FloatPayloadType>),
@@ -139,6 +141,7 @@ impl FieldIndex {
     ) -> Option<bool> {
         match self {
             FieldIndex::IntIndex(_) => None,
+            FieldIndex::DatetimeIndex(_) => None,
             FieldIndex::IntMapIndex(_) => None,
             FieldIndex::KeywordIndex(_) => None,
             FieldIndex::FloatIndex(_) => None,
@@ -163,6 +166,7 @@ impl FieldIndex {
     fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
         match self {
             FieldIndex::IntIndex(payload_field_index) => payload_field_index,
+            FieldIndex::DatetimeIndex(payload_field_index) => payload_field_index,
             FieldIndex::IntMapIndex(payload_field_index) => payload_field_index,
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
@@ -176,6 +180,7 @@ impl FieldIndex {
     fn get_payload_field_index_mut(&mut self) -> &mut dyn PayloadFieldIndex {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index,
+            FieldIndex::DatetimeIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index,
@@ -188,6 +193,7 @@ impl FieldIndex {
     pub fn load(&mut self) -> OperationResult<bool> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::DatetimeIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
@@ -200,6 +206,7 @@ impl FieldIndex {
     pub fn clear(self) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(index) => index.clear(),
+            FieldIndex::DatetimeIndex(index) => index.clear(),
             FieldIndex::IntMapIndex(index) => index.clear(),
             FieldIndex::KeywordIndex(index) => index.clear(),
             FieldIndex::FloatIndex(index) => index.clear(),
@@ -212,6 +219,7 @@ impl FieldIndex {
     pub fn recreate(&self) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(index) => index.recreate(),
+            FieldIndex::DatetimeIndex(index) => index.recreate(),
             FieldIndex::IntMapIndex(index) => index.recreate(),
             FieldIndex::KeywordIndex(index) => index.recreate(),
             FieldIndex::FloatIndex(index) => index.recreate(),
@@ -260,7 +268,10 @@ impl FieldIndex {
     ) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                ValueIndexer::<IntPayloadType>::add_point(payload_field_index, id, payload)
+            }
+            FieldIndex::DatetimeIndex(ref mut payload_field_index) => {
+                ValueIndexer::<DateTimePayloadType>::add_point(payload_field_index, id, payload)
             }
             FieldIndex::IntMapIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
@@ -286,6 +297,7 @@ impl FieldIndex {
     pub fn remove_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(index) => index.remove_point(point_id),
+            FieldIndex::DatetimeIndex(index) => index.remove_point(point_id),
             FieldIndex::IntMapIndex(index) => index.remove_point(point_id),
             FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
             FieldIndex::FloatIndex(index) => index.remove_point(point_id),
@@ -298,6 +310,7 @@ impl FieldIndex {
     pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
         match self {
             FieldIndex::IntIndex(index) => index.get_telemetry_data(),
+            FieldIndex::DatetimeIndex(index) => index.get_telemetry_data(),
             FieldIndex::IntMapIndex(index) => index.get_telemetry_data(),
             FieldIndex::KeywordIndex(index) => index.get_telemetry_data(),
             FieldIndex::FloatIndex(index) => index.get_telemetry_data(),
@@ -310,6 +323,7 @@ impl FieldIndex {
     pub fn values_count(&self, point_id: PointOffsetType) -> usize {
         match self {
             FieldIndex::IntIndex(index) => index.values_count(point_id),
+            FieldIndex::DatetimeIndex(index) => index.values_count(point_id),
             FieldIndex::IntMapIndex(index) => index.values_count(point_id),
             FieldIndex::KeywordIndex(index) => index.values_count(point_id),
             FieldIndex::FloatIndex(index) => index.values_count(point_id),
@@ -322,6 +336,7 @@ impl FieldIndex {
     pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
         match self {
             FieldIndex::IntIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::DatetimeIndex(index) => index.values_is_empty(point_id),
             FieldIndex::IntMapIndex(index) => index.values_is_empty(point_id),
             FieldIndex::KeywordIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FloatIndex(index) => index.values_is_empty(point_id),

commit 320b7f2621f08d08fa6fbd1e8f82a277610af81c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Sun Feb 4 14:46:22 2024 -0300

    `order_by` in scroll (#3493)
    
    * first PR implementation (#2865)
    
    - fetch offset id
    - restructure tests
    - only let order_by with numeric
    - introduce order_by interface
    
    cargo fmt
    
    update openapi
    
    calculate range to fetch using offset + limit, do some cleanup
    
    enable index validation, fix test
    
    Fix pagination
    
    add e2e tests
    
    make test a little more strict
    
    select numeric index on read_ordered_filtered
    
    add filtering test 🫨
    
    fix filtering on order-by
    
    fix pip requirements
    
    add grpc interface, make read_ordered_filtered fallible
    
    fmt
    
    small optimization of `with_payload` and `with_vector`
    
    refactor common logic of point_ops and local_shard_operations
    
    Make filtering test harder and fix limit for worst case
    
    update openapi
    
    small clarity refactor
    
    avoid extra allocation when sorting with offset
    
    stream from numeric index btree instead of calculating range
    
    use payload to store order-by value, instead of modifying Record interface
    
    various fixes:
    - fix ordering at collection level, when merging shard results
    - fix offset at segment level, to take into account also value offset
    - make rust tests pass
    
    remove unused histogram changes
    
    fix error messages and make has_range_index exhaustive
    
    remove unused From impl
    
    Move OrderBy and Direction to segment::data_types::order_by
    
    Refactor normal scroll_by in local_shard_operations.rs
    
    More cleanup + rename OrderableRead to StreamWithValue
    
    empty commit
    
    optimization for merging results from shards and segments
    
    fix case of multi-valued fields
    
    fix IntegerIndexParams name after rebase
    
    precompute offset key
    
    use extracted `read_by_id_stream`
    
    Expose value_offset to user
    - rename offset -> value_offset
    - extract offset value fetching logic
    
    * remove offset functionality when using order_by
    
    * include order_by in ForwardProxyShard
    
    * extra nits
    
    * remove histogram changes
    
    * more nits
    
    * self review
    
    * resolve conflicts after rebase, not enable order-by with datetime index schema
    
    * make grpc start_from value extendable
    
    * gen grpc docs
    
    ---------
    
    Co-authored-by: kwkr <kawka.maciej.93@gmail.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 21b225344..3f2a41601 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,8 +1,11 @@
+use std::fmt::Formatter;
+
 use common::types::PointOffsetType;
 use serde_json::Value;
 use smol_str::SmolStr;
 
 use super::map_index::MapIndex;
+use super::numeric_index::StreamRange;
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
@@ -14,7 +17,7 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
-    PayloadKeyType,
+    PayloadKeyType, Range,
 };
 
 pub trait PayloadFieldIndex {
@@ -126,6 +129,21 @@ pub enum FieldIndex {
     BinaryIndex(BinaryIndex),
 }
 
+impl std::fmt::Debug for FieldIndex {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        match self {
+            FieldIndex::IntIndex(_index) => write!(f, "IntIndex"),
+            FieldIndex::DatetimeIndex(_index) => write!(f, "DatetimeIndex"),
+            FieldIndex::IntMapIndex(_index) => write!(f, "IntMapIndex"),
+            FieldIndex::KeywordIndex(_index) => write!(f, "KeywordIndex"),
+            FieldIndex::FloatIndex(_index) => write!(f, "FloatIndex"),
+            FieldIndex::GeoIndex(_index) => write!(f, "GeoIndex"),
+            FieldIndex::BinaryIndex(_index) => write!(f, "BinaryIndex"),
+            FieldIndex::FullTextIndex(_index) => write!(f, "FullTextIndex"),
+        }
+    }
+}
+
 impl FieldIndex {
     /// Try to check condition for a payload given a field index.
     /// Required because some index parameters may influence the condition checking logic.
@@ -345,4 +363,36 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
         }
     }
+
+    pub fn as_numeric(&self) -> Option<NumericFieldIndex> {
+        match self {
+            FieldIndex::IntIndex(index) => Some(NumericFieldIndex::IntIndex(index)),
+            FieldIndex::FloatIndex(index) => Some(NumericFieldIndex::FloatIndex(index)),
+            FieldIndex::IntMapIndex(_)
+            | FieldIndex::DatetimeIndex(_) // TODO(luis): move to Some(..) section when datetime index is enabled for order-by
+            | FieldIndex::KeywordIndex(_)
+            | FieldIndex::GeoIndex(_)
+            | FieldIndex::BinaryIndex(_)
+            | FieldIndex::FullTextIndex(_) => None,
+        }
+    }
+}
+
+pub enum NumericFieldIndex<'a> {
+    IntIndex(&'a NumericIndex<IntPayloadType>),
+    FloatIndex(&'a NumericIndex<FloatPayloadType>),
+}
+
+impl<'a> StreamRange<f64> for NumericFieldIndex<'a> {
+    fn stream_range(
+        &self,
+        range: &Range<FloatPayloadType>,
+    ) -> Box<dyn DoubleEndedIterator<Item = (f64, PointOffsetType)> + 'a> {
+        match self {
+            NumericFieldIndex::IntIndex(index) => {
+                Box::new(index.stream_range(range).map(|(v, p)| (v as f64, p)))
+            }
+            NumericFieldIndex::FloatIndex(index) => index.stream_range(range),
+        }
+    }
 }

commit ffa27c4fd2900458b6b07b06e799704cb11604ce
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Feb 7 09:54:40 2024 -0300

    Order-by: Introduce `OrderingValue` for ordering also based on int values (#3533)
    
    * introduce `OrderingValue` for ordering also based on int values
    
    * use `num-cmp` for comparing ints and floats
    
    * Update comparison logic
    
    ---------
    
    Co-authored-by: Albert Safin <xzfcpw@gmail.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 3f2a41601..a2890bb4d 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -9,6 +9,7 @@ use super::numeric_index::StreamRange;
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::MultiValue;
 use crate::common::Flusher;
+use crate::data_types::order_by::OrderingValue;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
@@ -383,16 +384,22 @@ pub enum NumericFieldIndex<'a> {
     FloatIndex(&'a NumericIndex<FloatPayloadType>),
 }
 
-impl<'a> StreamRange<f64> for NumericFieldIndex<'a> {
+impl<'a> StreamRange<OrderingValue> for NumericFieldIndex<'a> {
     fn stream_range(
         &self,
         range: &Range<FloatPayloadType>,
-    ) -> Box<dyn DoubleEndedIterator<Item = (f64, PointOffsetType)> + 'a> {
+    ) -> Box<dyn DoubleEndedIterator<Item = (OrderingValue, PointOffsetType)> + 'a> {
         match self {
-            NumericFieldIndex::IntIndex(index) => {
-                Box::new(index.stream_range(range).map(|(v, p)| (v as f64, p)))
-            }
-            NumericFieldIndex::FloatIndex(index) => index.stream_range(range),
+            NumericFieldIndex::IntIndex(index) => Box::new(
+                index
+                    .stream_range(range)
+                    .map(|(v, p)| (OrderingValue::from(v), p)),
+            ),
+            NumericFieldIndex::FloatIndex(index) => Box::new(
+                index
+                    .stream_range(range)
+                    .map(|(v, p)| (OrderingValue::from(v), p)),
+            ),
         }
     }
 }

commit e4044ea7386f538102615f7968e8a57a722117fd
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Feb 8 14:49:45 2024 -0300

    Order-by: use pre-filtering for high-constraining filters (#3562)
    
    * use pre-filtering for high-constraining filters
    
    * fix repeated points

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index a2890bb4d..17c2bca53 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -403,3 +403,29 @@ impl<'a> StreamRange<OrderingValue> for NumericFieldIndex<'a> {
         }
     }
 }
+
+impl<'a> NumericFieldIndex<'a> {
+    pub fn get_ordering_values(
+        &self,
+        idx: PointOffsetType,
+    ) -> Box<dyn Iterator<Item = OrderingValue> + 'a> {
+        match self {
+            NumericFieldIndex::IntIndex(index) => Box::new(
+                index
+                    .get_values(idx)
+                    .into_iter()
+                    .flatten()
+                    .copied()
+                    .map(OrderingValue::Int),
+            ),
+            NumericFieldIndex::FloatIndex(index) => Box::new(
+                index
+                    .get_values(idx)
+                    .into_iter()
+                    .flatten()
+                    .copied()
+                    .map(OrderingValue::Float),
+            ),
+        }
+    }
+}

commit fb46ec8af1cf1e1522276889846a93264d8215b6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Feb 8 18:44:22 2024 -0300

    Order-by: support datetimes (#3540)
    
    * support \`start_from\`: DateTime
    
    * add order by datetime test
    
    * generate openapi models and grpc docs
    
    * fixup after rebase
    
    * allow string representation of datetime in grpc
    
    * add TODO
    
    * fix `.start_from()`
    
    * use custom deserialization on datetime

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 17c2bca53..10746524f 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -18,7 +18,7 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
-    PayloadKeyType, Range,
+    PayloadKeyType, RangeInterface,
 };
 
 pub trait PayloadFieldIndex {
@@ -368,9 +368,9 @@ impl FieldIndex {
     pub fn as_numeric(&self) -> Option<NumericFieldIndex> {
         match self {
             FieldIndex::IntIndex(index) => Some(NumericFieldIndex::IntIndex(index)),
+            FieldIndex::DatetimeIndex(index) => Some(NumericFieldIndex::IntIndex(index)),
             FieldIndex::FloatIndex(index) => Some(NumericFieldIndex::FloatIndex(index)),
             FieldIndex::IntMapIndex(_)
-            | FieldIndex::DatetimeIndex(_) // TODO(luis): move to Some(..) section when datetime index is enabled for order-by
             | FieldIndex::KeywordIndex(_)
             | FieldIndex::GeoIndex(_)
             | FieldIndex::BinaryIndex(_)
@@ -387,7 +387,7 @@ pub enum NumericFieldIndex<'a> {
 impl<'a> StreamRange<OrderingValue> for NumericFieldIndex<'a> {
     fn stream_range(
         &self,
-        range: &Range<FloatPayloadType>,
+        range: &RangeInterface,
     ) -> Box<dyn DoubleEndedIterator<Item = (OrderingValue, PointOffsetType)> + 'a> {
         match self {
             NumericFieldIndex::IntIndex(index) => Box::new(

commit 395a19f2c1fc0266406f23bda3c6f77434188c7a
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Feb 20 23:07:15 2024 +0000

    Use SmallVec instead of MultiValue (#3639)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 10746524f..3e0437cc1 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -7,7 +7,6 @@ use smol_str::SmolStr;
 use super::map_index::MapIndex;
 use super::numeric_index::StreamRange;
 use crate::common::operation_error::OperationResult;
-use crate::common::utils::MultiValue;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderingValue;
 use crate::index::field_index::binary_index::BinaryIndex;
@@ -73,42 +72,22 @@ pub trait ValueIndexer<T> {
     }
 
     /// Add point with payload to index
-    fn add_point(
-        &mut self,
-        id: PointOffsetType,
-        payload: &MultiValue<&Value>,
-    ) -> OperationResult<()> {
+    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
         self.remove_point(id)?;
-        match payload {
-            MultiValue::Multiple(values) => {
-                let mut flatten_values: Vec<_> = vec![];
-
-                for value in values {
-                    match value {
-                        Value::Array(values) => {
-                            flatten_values.extend(values.iter().flat_map(|x| self.get_value(x)));
-                        }
-                        _ => {
-                            if let Some(x) = self.get_value(value) {
-                                flatten_values.push(x);
-                            }
-                        }
-                    }
+        let mut flatten_values: Vec<_> = vec![];
+        for value in payload.iter() {
+            match value {
+                Value::Array(values) => {
+                    flatten_values.extend(values.iter().flat_map(|x| self.get_value(x)));
                 }
-                self.add_many(id, flatten_values)
-            }
-            MultiValue::Single(Some(Value::Array(values))) => {
-                self.add_many(id, values.iter().flat_map(|x| self.get_value(x)).collect())
-            }
-            MultiValue::Single(Some(value)) => {
-                if let Some(x) = self.get_value(value) {
-                    self.add_many(id, vec![x])
-                } else {
-                    Ok(())
+                _ => {
+                    if let Some(x) = self.get_value(value) {
+                        flatten_values.push(x);
+                    }
                 }
             }
-            MultiValue::Single(None) => Ok(()),
         }
+        self.add_many(id, flatten_values)
     }
 
     /// remove a point from the index
@@ -280,11 +259,7 @@ impl FieldIndex {
             .payload_blocks(threshold, key)
     }
 
-    pub fn add_point(
-        &mut self,
-        id: PointOffsetType,
-        payload: &MultiValue<&Value>,
-    ) -> OperationResult<()> {
+    pub fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => {
                 ValueIndexer::<IntPayloadType>::add_point(payload_field_index, id, payload)

commit 4060f36b04a5fd849e3ed8c8289869addad1a7c6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Apr 30 09:57:49 2024 +0200

    Remove unecessary Clippy allows (#4142)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 3e0437cc1..bb7410180 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -96,8 +96,6 @@ pub trait ValueIndexer<T> {
 
 /// Common interface for all possible types of field indexes
 /// Enables polymorphism on field indexes
-/// TODO: Rename with major release
-#[allow(clippy::enum_variant_names)]
 pub enum FieldIndex {
     IntIndex(NumericIndex<IntPayloadType>),
     DatetimeIndex(NumericIndex<IntPayloadType>),

commit 9d8dd0471621d704f72ffbc3fae62852641207b9
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed May 22 09:56:31 2024 -0400

    universal-query: Introduce `order_value` field in `ScoredPoint` (#4291)
    
    * - Fix ordering in group-by for custom scoring
    - Rename `OrderingValue` -> `OrderedValue`
    - Introduce `order_value` field in `ScoredPoint`
    
    * modify `Ord` implementation
    
    * rename to `OrderValue`
    
    * `has_custom_scoring` -> `is_distance_scored`
    
    * regen apis
    
    * flip bools in `is_distance_scored`

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index bb7410180..bf44222bc 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -8,7 +8,7 @@ use super::map_index::MapIndex;
 use super::numeric_index::StreamRange;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
-use crate::data_types::order_by::OrderingValue;
+use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
@@ -357,21 +357,21 @@ pub enum NumericFieldIndex<'a> {
     FloatIndex(&'a NumericIndex<FloatPayloadType>),
 }
 
-impl<'a> StreamRange<OrderingValue> for NumericFieldIndex<'a> {
+impl<'a> StreamRange<OrderValue> for NumericFieldIndex<'a> {
     fn stream_range(
         &self,
         range: &RangeInterface,
-    ) -> Box<dyn DoubleEndedIterator<Item = (OrderingValue, PointOffsetType)> + 'a> {
+    ) -> Box<dyn DoubleEndedIterator<Item = (OrderValue, PointOffsetType)> + 'a> {
         match self {
             NumericFieldIndex::IntIndex(index) => Box::new(
                 index
                     .stream_range(range)
-                    .map(|(v, p)| (OrderingValue::from(v), p)),
+                    .map(|(v, p)| (OrderValue::from(v), p)),
             ),
             NumericFieldIndex::FloatIndex(index) => Box::new(
                 index
                     .stream_range(range)
-                    .map(|(v, p)| (OrderingValue::from(v), p)),
+                    .map(|(v, p)| (OrderValue::from(v), p)),
             ),
         }
     }
@@ -381,7 +381,7 @@ impl<'a> NumericFieldIndex<'a> {
     pub fn get_ordering_values(
         &self,
         idx: PointOffsetType,
-    ) -> Box<dyn Iterator<Item = OrderingValue> + 'a> {
+    ) -> Box<dyn Iterator<Item = OrderValue> + 'a> {
         match self {
             NumericFieldIndex::IntIndex(index) => Box::new(
                 index
@@ -389,7 +389,7 @@ impl<'a> NumericFieldIndex<'a> {
                     .into_iter()
                     .flatten()
                     .copied()
-                    .map(OrderingValue::Int),
+                    .map(OrderValue::Int),
             ),
             NumericFieldIndex::FloatIndex(index) => Box::new(
                 index
@@ -397,7 +397,7 @@ impl<'a> NumericFieldIndex<'a> {
                     .into_iter()
                     .flatten()
                     .copied()
-                    .map(OrderingValue::Float),
+                    .map(OrderValue::Float),
             ),
         }
     }

commit a06d20fb58a70f369c3a3b40178b726a291e6423
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 8 07:51:59 2024 +0000

    Remove dead code (#4623)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index bf44222bc..6dbb3ff1b 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -172,20 +172,6 @@ impl FieldIndex {
         }
     }
 
-    #[allow(dead_code)]
-    fn get_payload_field_index_mut(&mut self) -> &mut dyn PayloadFieldIndex {
-        match self {
-            FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::DatetimeIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index,
-            FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index,
-        }
-    }
-
     pub fn load(&mut self) -> OperationResult<bool> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index.load(),

commit c7d25b2096ae9c51d38ecd4476fe7581fbc1eb8d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Jul 12 11:37:20 2024 +0200

    Field index values as iterator instead of slice (#4644)
    
    * field index values as iterator instead of slice
    
    * Use consistent assertions
    
    * fix wrong values_count update
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 6dbb3ff1b..ff743dc74 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -374,7 +374,6 @@ impl<'a> NumericFieldIndex<'a> {
                     .get_values(idx)
                     .into_iter()
                     .flatten()
-                    .copied()
                     .map(OrderValue::Int),
             ),
             NumericFieldIndex::FloatIndex(index) => Box::new(
@@ -382,7 +381,6 @@ impl<'a> NumericFieldIndex<'a> {
                     .get_values(idx)
                     .into_iter()
                     .flatten()
-                    .copied()
                     .map(OrderValue::Float),
             ),
         }

commit 65964f86b07afd695243984f32f97c9604f50d00
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jul 16 13:36:50 2024 +0000

    Introduce MapIndexKey (#4676)
    
    * Introduce MapIndexKey
    
    * Review fixes
    
    * Remove unnecessary .borrow() call

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index ff743dc74..a17986327 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -2,7 +2,6 @@ use std::fmt::Formatter;
 
 use common::types::PointOffsetType;
 use serde_json::Value;
-use smol_str::SmolStr;
 
 use super::map_index::MapIndex;
 use super::numeric_index::StreamRange;
@@ -100,7 +99,7 @@ pub enum FieldIndex {
     IntIndex(NumericIndex<IntPayloadType>),
     DatetimeIndex(NumericIndex<IntPayloadType>),
     IntMapIndex(MapIndex<IntPayloadType>),
-    KeywordIndex(MapIndex<SmolStr>),
+    KeywordIndex(MapIndex<str>),
     FloatIndex(NumericIndex<FloatPayloadType>),
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),

commit 38a8a01b244c26c18e3efe0eeb449f6e37566d83
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jul 19 12:57:25 2024 +0000

    Make ValueIndexer trait non-generic (#4690)
    
    * Introduce NumericIndexInner
    
    * Make ValueIndexer trait non-generic

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index a17986327..a659b5676 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -4,14 +4,14 @@ use common::types::PointOffsetType;
 use serde_json::Value;
 
 use super::map_index::MapIndex;
-use super::numeric_index::StreamRange;
+use super::numeric_index::{NumericIndex, StreamRange};
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
-use crate::index::field_index::numeric_index::NumericIndex;
+use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
@@ -54,16 +54,22 @@ pub trait PayloadFieldIndex {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_>;
 }
 
-pub trait ValueIndexer<T> {
+pub trait ValueIndexer {
+    type ValueType;
+
     /// Add multiple values associated with a single point
     /// This function should be called only once for each point
-    fn add_many(&mut self, id: PointOffsetType, values: Vec<T>) -> OperationResult<()>;
+    fn add_many(
+        &mut self,
+        id: PointOffsetType,
+        values: Vec<Self::ValueType>,
+    ) -> OperationResult<()>;
 
     /// Extract index-able value from payload `Value`
-    fn get_value(&self, value: &Value) -> Option<T>;
+    fn get_value(&self, value: &Value) -> Option<Self::ValueType>;
 
     /// Try to extract index-able values from payload `Value`, even if it is an array
-    fn get_values(&self, value: &Value) -> Vec<T> {
+    fn get_values(&self, value: &Value) -> Vec<Self::ValueType> {
         match value {
             Value::Array(values) => values.iter().flat_map(|x| self.get_value(x)).collect(),
             _ => self.get_value(value).map(|x| vec![x]).unwrap_or_default(),
@@ -96,11 +102,11 @@ pub trait ValueIndexer<T> {
 /// Common interface for all possible types of field indexes
 /// Enables polymorphism on field indexes
 pub enum FieldIndex {
-    IntIndex(NumericIndex<IntPayloadType>),
-    DatetimeIndex(NumericIndex<IntPayloadType>),
+    IntIndex(NumericIndex<IntPayloadType, IntPayloadType>),
+    DatetimeIndex(NumericIndex<IntPayloadType, DateTimePayloadType>),
     IntMapIndex(MapIndex<IntPayloadType>),
     KeywordIndex(MapIndex<str>),
-    FloatIndex(NumericIndex<FloatPayloadType>),
+    FloatIndex(NumericIndex<FloatPayloadType, FloatPayloadType>),
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),
     BinaryIndex(BinaryIndex),
@@ -160,11 +166,11 @@ impl FieldIndex {
 
     fn get_payload_field_index(&self) -> &dyn PayloadFieldIndex {
         match self {
-            FieldIndex::IntIndex(payload_field_index) => payload_field_index,
-            FieldIndex::DatetimeIndex(payload_field_index) => payload_field_index,
+            FieldIndex::IntIndex(payload_field_index) => payload_field_index.inner(),
+            FieldIndex::DatetimeIndex(payload_field_index) => payload_field_index.inner(),
             FieldIndex::IntMapIndex(payload_field_index) => payload_field_index,
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
-            FieldIndex::FloatIndex(payload_field_index) => payload_field_index,
+            FieldIndex::FloatIndex(payload_field_index) => payload_field_index.inner(),
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
             FieldIndex::BinaryIndex(payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
@@ -245,10 +251,10 @@ impl FieldIndex {
     pub fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
         match self {
             FieldIndex::IntIndex(ref mut payload_field_index) => {
-                ValueIndexer::<IntPayloadType>::add_point(payload_field_index, id, payload)
+                payload_field_index.add_point(id, payload)
             }
             FieldIndex::DatetimeIndex(ref mut payload_field_index) => {
-                ValueIndexer::<DateTimePayloadType>::add_point(payload_field_index, id, payload)
+                payload_field_index.add_point(id, payload)
             }
             FieldIndex::IntMapIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
@@ -273,11 +279,11 @@ impl FieldIndex {
 
     pub fn remove_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
         match self {
-            FieldIndex::IntIndex(index) => index.remove_point(point_id),
-            FieldIndex::DatetimeIndex(index) => index.remove_point(point_id),
+            FieldIndex::IntIndex(index) => index.mut_inner().remove_point(point_id),
+            FieldIndex::DatetimeIndex(index) => index.mut_inner().remove_point(point_id),
             FieldIndex::IntMapIndex(index) => index.remove_point(point_id),
             FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
-            FieldIndex::FloatIndex(index) => index.remove_point(point_id),
+            FieldIndex::FloatIndex(index) => index.mut_inner().remove_point(point_id),
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
             FieldIndex::BinaryIndex(index) => index.remove_point(point_id),
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
@@ -325,9 +331,9 @@ impl FieldIndex {
 
     pub fn as_numeric(&self) -> Option<NumericFieldIndex> {
         match self {
-            FieldIndex::IntIndex(index) => Some(NumericFieldIndex::IntIndex(index)),
-            FieldIndex::DatetimeIndex(index) => Some(NumericFieldIndex::IntIndex(index)),
-            FieldIndex::FloatIndex(index) => Some(NumericFieldIndex::FloatIndex(index)),
+            FieldIndex::IntIndex(index) => Some(NumericFieldIndex::IntIndex(index.inner())),
+            FieldIndex::DatetimeIndex(index) => Some(NumericFieldIndex::IntIndex(index.inner())),
+            FieldIndex::FloatIndex(index) => Some(NumericFieldIndex::FloatIndex(index.inner())),
             FieldIndex::IntMapIndex(_)
             | FieldIndex::KeywordIndex(_)
             | FieldIndex::GeoIndex(_)
@@ -338,8 +344,8 @@ impl FieldIndex {
 }
 
 pub enum NumericFieldIndex<'a> {
-    IntIndex(&'a NumericIndex<IntPayloadType>),
-    FloatIndex(&'a NumericIndex<FloatPayloadType>),
+    IntIndex(&'a NumericIndexInner<IntPayloadType>),
+    FloatIndex(&'a NumericIndexInner<FloatPayloadType>),
 }
 
 impl<'a> StreamRange<OrderValue> for NumericFieldIndex<'a> {

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index a659b5676..a7df34495 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -71,7 +71,7 @@ pub trait ValueIndexer {
     /// Try to extract index-able values from payload `Value`, even if it is an array
     fn get_values(&self, value: &Value) -> Vec<Self::ValueType> {
         match value {
-            Value::Array(values) => values.iter().flat_map(|x| self.get_value(x)).collect(),
+            Value::Array(values) => values.iter().filter_map(|x| self.get_value(x)).collect(),
             _ => self.get_value(value).map(|x| vec![x]).unwrap_or_default(),
         }
     }
@@ -83,7 +83,7 @@ pub trait ValueIndexer {
         for value in payload.iter() {
             match value {
                 Value::Array(values) => {
-                    flatten_values.extend(values.iter().flat_map(|x| self.get_value(x)));
+                    flatten_values.extend(values.iter().filter_map(|x| self.get_value(x)));
                 }
                 _ => {
                     if let Some(x) = self.get_value(value) {

commit f35f512605437d671bb81eec83a24a6d3509bc13
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 10:19:23 2024 +0000

    Introduce FieldIndexBuilder (#4717)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index a7df34495..029b05fdf 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,10 +1,14 @@
 use std::fmt::Formatter;
 
 use common::types::PointOffsetType;
+use delegate::delegate;
 use serde_json::Value;
 
-use super::map_index::MapIndex;
-use super::numeric_index::{NumericIndex, StreamRange};
+use super::binary_index::BinaryIndexBuilder;
+use super::full_text_index::text_index::FullTextIndexBuilder;
+use super::geo_index::GeoMapIndexBuilder;
+use super::map_index::{MapIndex, MapIndexBuilder};
+use super::numeric_index::{NumericIndex, NumericIndexBuilder, StreamRange};
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderValue;
@@ -343,6 +347,62 @@ impl FieldIndex {
     }
 }
 
+pub trait FieldIndexBuilderTrait {
+    /// The resulting type of the index
+    type FieldIndexType;
+
+    fn init(&mut self) -> OperationResult<()>;
+
+    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
+
+    fn finalize(self) -> OperationResult<Self::FieldIndexType>;
+}
+
+/// Builders for all index types
+pub enum FieldIndexBuilder {
+    IntIndex(NumericIndexBuilder<IntPayloadType, IntPayloadType>),
+    DatetimeIndex(NumericIndexBuilder<IntPayloadType, DateTimePayloadType>),
+    IntMapIndex(MapIndexBuilder<IntPayloadType>),
+    KeywordIndex(MapIndexBuilder<str>),
+    FloatIndex(NumericIndexBuilder<FloatPayloadType, FloatPayloadType>),
+    GeoIndex(GeoMapIndexBuilder),
+    FullTextIndex(FullTextIndexBuilder),
+    BinaryIndex(BinaryIndexBuilder),
+}
+
+impl FieldIndexBuilderTrait for FieldIndexBuilder {
+    type FieldIndexType = FieldIndex;
+
+    delegate! {
+        to match self {
+            Self::IntIndex(index) => index,
+            Self::DatetimeIndex(index) => index,
+            Self::IntMapIndex(index) => index,
+            Self::KeywordIndex(index) => index,
+            Self::FloatIndex(index) => index,
+            Self::GeoIndex(index) => index,
+            Self::BinaryIndex(index) => index,
+            Self::FullTextIndex(index) => index,
+        } {
+            fn init(&mut self) -> OperationResult<()>;
+            fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
+        }
+    }
+
+    fn finalize(self) -> OperationResult<FieldIndex> {
+        Ok(match self {
+            Self::IntIndex(index) => FieldIndex::IntIndex(index.finalize()?),
+            Self::DatetimeIndex(index) => FieldIndex::DatetimeIndex(index.finalize()?),
+            Self::IntMapIndex(index) => FieldIndex::IntMapIndex(index.finalize()?),
+            Self::KeywordIndex(index) => FieldIndex::KeywordIndex(index.finalize()?),
+            Self::FloatIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
+            Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
+            Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
+            Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
+        })
+    }
+}
+
 pub enum NumericFieldIndex<'a> {
     IntIndex(&'a NumericIndexInner<IntPayloadType>),
     FloatIndex(&'a NumericIndexInner<FloatPayloadType>),

commit f77c98899a2771f4f6b178da46b2442f403dea61
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jul 23 13:53:08 2024 +0000

    Drop FieldIndex::recreate() method (#4735)
    
    * Drop FieldIndex::recreate() method
    
    * Make `make_empty()` return `Result`

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 029b05fdf..ec9fc4347 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -207,19 +207,6 @@ impl FieldIndex {
         }
     }
 
-    pub fn recreate(&self) -> OperationResult<()> {
-        match self {
-            FieldIndex::IntIndex(index) => index.recreate(),
-            FieldIndex::DatetimeIndex(index) => index.recreate(),
-            FieldIndex::IntMapIndex(index) => index.recreate(),
-            FieldIndex::KeywordIndex(index) => index.recreate(),
-            FieldIndex::FloatIndex(index) => index.recreate(),
-            FieldIndex::GeoIndex(index) => index.recreate(),
-            FieldIndex::BinaryIndex(index) => index.recreate(),
-            FieldIndex::FullTextIndex(index) => index.recreate(),
-        }
-    }
-
     pub fn count_indexed_points(&self) -> usize {
         self.get_payload_field_index().count_indexed_points()
     }
@@ -347,15 +334,28 @@ impl FieldIndex {
     }
 }
 
+/// Common interface for all index builders.
 pub trait FieldIndexBuilderTrait {
-    /// The resulting type of the index
+    /// The resulting type of the index.
     type FieldIndexType;
 
+    /// Start building the index, e.g. create a database column or a directory.
+    /// Expected to be called exactly once before any other method.
     fn init(&mut self) -> OperationResult<()>;
 
     fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
 
     fn finalize(self) -> OperationResult<Self::FieldIndexType>;
+
+    /// Create an empty index for testing purposes.
+    #[cfg(test)]
+    fn make_empty(mut self) -> OperationResult<Self::FieldIndexType>
+    where
+        Self: Sized,
+    {
+        self.init()?;
+        self.finalize()
+    }
 }
 
 /// Builders for all index types

commit 5df4231e2d7ab63c2e3e1931624fb039c1087375
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Jul 24 08:43:00 2024 +0200

    ValueIndexer get_value without self (#4740)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index ec9fc4347..605dc53b9 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -70,13 +70,13 @@ pub trait ValueIndexer {
     ) -> OperationResult<()>;
 
     /// Extract index-able value from payload `Value`
-    fn get_value(&self, value: &Value) -> Option<Self::ValueType>;
+    fn get_value(value: &Value) -> Option<Self::ValueType>;
 
     /// Try to extract index-able values from payload `Value`, even if it is an array
-    fn get_values(&self, value: &Value) -> Vec<Self::ValueType> {
+    fn get_values(value: &Value) -> Vec<Self::ValueType> {
         match value {
-            Value::Array(values) => values.iter().filter_map(|x| self.get_value(x)).collect(),
-            _ => self.get_value(value).map(|x| vec![x]).unwrap_or_default(),
+            Value::Array(values) => values.iter().filter_map(|x| Self::get_value(x)).collect(),
+            _ => Self::get_value(value).map(|x| vec![x]).unwrap_or_default(),
         }
     }
 
@@ -87,10 +87,10 @@ pub trait ValueIndexer {
         for value in payload.iter() {
             match value {
                 Value::Array(values) => {
-                    flatten_values.extend(values.iter().filter_map(|x| self.get_value(x)));
+                    flatten_values.extend(values.iter().filter_map(|x| Self::get_value(x)));
                 }
                 _ => {
-                    if let Some(x) = self.get_value(value) {
+                    if let Some(x) = Self::get_value(value) {
                         flatten_values.push(x);
                     }
                 }
@@ -155,7 +155,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(full_text_index) => match &condition.r#match {
                 Some(Match::Text(MatchText { text })) => {
                     let query = full_text_index.parse_query(text);
-                    for value in full_text_index.get_values(payload_value) {
+                    for value in FullTextIndex::get_values(payload_value) {
                         let document = full_text_index.parse_document(&value);
                         if query.check_match(&document) {
                             return Some(true);

commit ab714cdfecc3f70f330ecdc0d262b39fe6440be7
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Jul 25 16:05:12 2024 -0400

    Use option in `filter` and `estimate_cardinality` (#4747)
    
    * chore: filter returns option
    
    * chore: make estimate_cardinality return Option
    
    * better comment

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 605dc53b9..79f46bd00 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -41,13 +41,11 @@ pub trait PayloadFieldIndex {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
 
-    /// Return estimation of points amount which satisfy given condition
-    fn estimate_cardinality(
-        &self,
-        condition: &FieldCondition,
-    ) -> OperationResult<CardinalityEstimation>;
+    /// Return estimation of amount of points which satisfy given condition.
+    /// Returns `None` if the condition does not match the index type
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation>;
 
     /// Iterate conditions for payload blocks with minimum size of `threshold`
     /// Required for building HNSW index
@@ -218,14 +216,14 @@ impl FieldIndex {
     pub fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         self.get_payload_field_index().filter(condition)
     }
 
     pub fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
-    ) -> OperationResult<CardinalityEstimation> {
+    ) -> Option<CardinalityEstimation> {
         self.get_payload_field_index()
             .estimate_cardinality(condition)
     }

commit 745b1621dffbbf13c23a6ba6514c65502f983ad2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jul 26 16:59:34 2024 +0200

    UUID payload index (#4738)
    
    * add UuidIndex
    
    * fix clippy
    
    * rebase to dev
    
    * update api docs
    
    * don't use wrapper type for Uuid index
    
    * rebase to `dev`
    
    * remove existence checking
    
    * rename UuidPayloadKeyType => UuidIntType
    
    * apply review changes
    
    * rebase to dev
    
    * post-rebase fixes
    
    * Improve estimation
    
    * Improve naming
    
    * Apply suggestions from code review
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * use u128 in histogram and improve uuid sorting
    
    * Also allow defragmentation for completely random Uuids
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 79f46bd00..3bf759a82 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -20,7 +20,7 @@ use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
-    PayloadKeyType, RangeInterface,
+    PayloadKeyType, RangeInterface, UuidIntType, UuidPayloadType,
 };
 
 pub trait PayloadFieldIndex {
@@ -112,6 +112,7 @@ pub enum FieldIndex {
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),
     BinaryIndex(BinaryIndex),
+    UuidIndex(NumericIndex<UuidIntType, UuidPayloadType>),
 }
 
 impl std::fmt::Debug for FieldIndex {
@@ -125,6 +126,7 @@ impl std::fmt::Debug for FieldIndex {
             FieldIndex::GeoIndex(_index) => write!(f, "GeoIndex"),
             FieldIndex::BinaryIndex(_index) => write!(f, "BinaryIndex"),
             FieldIndex::FullTextIndex(_index) => write!(f, "FullTextIndex"),
+            FieldIndex::UuidIndex(_index) => write!(f, "UuidIndex"),
         }
     }
 }
@@ -163,6 +165,7 @@ impl FieldIndex {
                 }
                 _ => None,
             },
+            FieldIndex::UuidIndex(_) => None,
         }
     }
 
@@ -176,6 +179,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
             FieldIndex::BinaryIndex(payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
+            FieldIndex::UuidIndex(payload_field_index) => payload_field_index.inner(),
         }
     }
 
@@ -189,6 +193,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::UuidIndex(ref mut payload_field_index) => payload_field_index.load(),
         }
     }
 
@@ -202,6 +207,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.clear(),
             FieldIndex::BinaryIndex(index) => index.clear(),
             FieldIndex::FullTextIndex(index) => index.clear(),
+            FieldIndex::UuidIndex(index) => index.clear(),
         }
     }
 
@@ -263,6 +269,9 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
+            FieldIndex::UuidIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
         }
     }
 
@@ -276,6 +285,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
             FieldIndex::BinaryIndex(index) => index.remove_point(point_id),
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
+            FieldIndex::UuidIndex(index) => index.remove_point(point_id),
         }
     }
 
@@ -289,6 +299,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.get_telemetry_data(),
             FieldIndex::BinaryIndex(index) => index.get_telemetry_data(),
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
+            FieldIndex::UuidIndex(index) => index.get_telemetry_data(),
         }
     }
 
@@ -302,6 +313,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.values_count(point_id),
             FieldIndex::BinaryIndex(index) => index.values_count(point_id),
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
+            FieldIndex::UuidIndex(index) => index.values_count(point_id),
         }
     }
 
@@ -315,6 +327,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(index) => index.values_is_empty(point_id),
             FieldIndex::BinaryIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::UuidIndex(index) => index.values_is_empty(point_id),
         }
     }
 
@@ -327,6 +340,7 @@ impl FieldIndex {
             | FieldIndex::KeywordIndex(_)
             | FieldIndex::GeoIndex(_)
             | FieldIndex::BinaryIndex(_)
+            | FieldIndex::UuidIndex(_)
             | FieldIndex::FullTextIndex(_) => None,
         }
     }
@@ -366,6 +380,7 @@ pub enum FieldIndexBuilder {
     GeoIndex(GeoMapIndexBuilder),
     FullTextIndex(FullTextIndexBuilder),
     BinaryIndex(BinaryIndexBuilder),
+    UuidIndex(NumericIndexBuilder<UuidIntType, UuidPayloadType>),
 }
 
 impl FieldIndexBuilderTrait for FieldIndexBuilder {
@@ -381,6 +396,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => index,
             Self::BinaryIndex(index) => index,
             Self::FullTextIndex(index) => index,
+            Self::UuidIndex(index) => index,
         } {
             fn init(&mut self) -> OperationResult<()>;
             fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
@@ -397,6 +413,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
+            Self::UuidIndex(index) => FieldIndex::UuidIndex(index.finalize()?),
         })
     }
 }

commit eb679ff097c79aba3f11b0f0b01d307d2e163d0c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jul 30 13:18:19 2024 -0400

    Facets in segment (#4753)
    
    * faceting in segment
    
    * Add segment integration test
    
    * nits
    
    * count from filtered stream, not value->points map directly
    
    * drop AtomicRef from fn signature
    
    * count only unique values per point
    
    * use entry in hashmap
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 3bf759a82..f5cbd9eca 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -7,10 +7,11 @@ use serde_json::Value;
 use super::binary_index::BinaryIndexBuilder;
 use super::full_text_index::text_index::FullTextIndexBuilder;
 use super::geo_index::GeoMapIndexBuilder;
-use super::map_index::{MapIndex, MapIndexBuilder};
+use super::map_index::{IdRefIter, MapIndex, MapIndexBuilder};
 use super::numeric_index::{NumericIndex, NumericIndexBuilder, StreamRange};
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
+use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
@@ -344,6 +345,20 @@ impl FieldIndex {
             | FieldIndex::FullTextIndex(_) => None,
         }
     }
+
+    pub fn as_facet_index(&self) -> Option<FacetIndex> {
+        match self {
+            FieldIndex::KeywordIndex(index) => Some(FacetIndex::KeywordIndex(index)),
+            FieldIndex::IntMapIndex(_) // TODO(facets): use int map index too
+            | FieldIndex::UuidIndex(_) // TODO(facets): use uuid index too
+            | FieldIndex::IntIndex(_)
+            | FieldIndex::DatetimeIndex(_)
+            | FieldIndex::FloatIndex(_)
+            | FieldIndex::GeoIndex(_)
+            | FieldIndex::BinaryIndex(_)
+            | FieldIndex::FullTextIndex(_) => None,
+        }
+    }
 }
 
 /// Common interface for all index builders.
@@ -466,3 +481,61 @@ impl<'a> NumericFieldIndex<'a> {
         }
     }
 }
+
+pub enum FacetIndex<'a> {
+    KeywordIndex(&'a MapIndex<str>),
+}
+
+impl<'a> FacetIndex<'a> {
+    pub fn get_values(
+        &self,
+        point_id: PointOffsetType,
+    ) -> Box<dyn Iterator<Item = FacetValueRef<'a>> + 'a> {
+        match self {
+            FacetIndex::KeywordIndex(index) => {
+                let iter = index
+                    .get_values(point_id)
+                    .into_iter()
+                    .flatten() // flatten the Option
+                    .map(FacetValueRef::Keyword);
+
+                Box::new(iter)
+            }
+        }
+    }
+
+    pub fn iter_values_map<F>(
+        &'a self,
+        f: &'a F,
+    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + '_>
+    where
+        F: for<'b> Fn(IdRefIter<'b>) -> usize,
+    {
+        match self {
+            FacetIndex::KeywordIndex(index) => {
+                let iter = index
+                    .iter_values_map()
+                    .map(|(value, internal_ids_iter)| FacetHit {
+                        value: FacetValueRef::Keyword(value),
+                        count: f(internal_ids_iter),
+                    });
+                Box::new(iter)
+            }
+        }
+    }
+    pub fn iter_counts_per_value(
+        &'a self,
+    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + 'a> {
+        match self {
+            FacetIndex::KeywordIndex(index) => {
+                let iter = index
+                    .iter_counts_per_value()
+                    .map(|(value, count)| FacetHit {
+                        value: FacetValueRef::Keyword(value),
+                        count,
+                    });
+                Box::new(iter)
+            }
+        }
+    }
+}

commit 7ea8e1ec7d378739ae8a6bf524daf31df2bb5b87
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 19:45:14 2024 +0000

    Integrate map/numeric mmap indices (#4809)
    
    * Extend FieldIndexBuilder with mmap indices
    
    * Introduce PayloadFieldIndex::files()
    
    * Create and delete index dirs
    
    * Update index_selector and index_builder_selector

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f5cbd9eca..5e9d85385 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,4 +1,5 @@
 use std::fmt::Formatter;
+use std::path::PathBuf;
 
 use common::types::PointOffsetType;
 use delegate::delegate;
@@ -7,8 +8,10 @@ use serde_json::Value;
 use super::binary_index::BinaryIndexBuilder;
 use super::full_text_index::text_index::FullTextIndexBuilder;
 use super::geo_index::GeoMapIndexBuilder;
-use super::map_index::{IdRefIter, MapIndex, MapIndexBuilder};
-use super::numeric_index::{NumericIndex, NumericIndexBuilder, StreamRange};
+use super::map_index::{IdRefIter, MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
+use super::numeric_index::{
+    NumericIndex, NumericIndexBuilder, NumericIndexMmapBuilder, StreamRange,
+};
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::facets::{FacetHit, FacetValueRef};
@@ -37,6 +40,8 @@ pub trait PayloadFieldIndex {
     /// Return function that flushes all pending updates to disk.
     fn flusher(&self) -> Flusher;
 
+    fn files(&self) -> Vec<PathBuf>;
+
     /// Get iterator over points fitting given `condition`
     /// Return `None` if condition does not match the index type
     fn filter<'a>(
@@ -220,6 +225,10 @@ impl FieldIndex {
         self.get_payload_field_index().flusher()
     }
 
+    pub fn files(&self) -> Vec<PathBuf> {
+        self.get_payload_field_index().files()
+    }
+
     pub fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
@@ -388,14 +397,20 @@ pub trait FieldIndexBuilderTrait {
 /// Builders for all index types
 pub enum FieldIndexBuilder {
     IntIndex(NumericIndexBuilder<IntPayloadType, IntPayloadType>),
+    IntMmapIndex(NumericIndexMmapBuilder<IntPayloadType, IntPayloadType>),
     DatetimeIndex(NumericIndexBuilder<IntPayloadType, DateTimePayloadType>),
+    DatetimeMmapIndex(NumericIndexMmapBuilder<IntPayloadType, DateTimePayloadType>),
     IntMapIndex(MapIndexBuilder<IntPayloadType>),
+    IntMapMmapIndex(MapIndexMmapBuilder<IntPayloadType>),
     KeywordIndex(MapIndexBuilder<str>),
+    KeywordMmapIndex(MapIndexMmapBuilder<str>),
     FloatIndex(NumericIndexBuilder<FloatPayloadType, FloatPayloadType>),
+    FloatMmapIndex(NumericIndexMmapBuilder<FloatPayloadType, FloatPayloadType>),
     GeoIndex(GeoMapIndexBuilder),
     FullTextIndex(FullTextIndexBuilder),
     BinaryIndex(BinaryIndexBuilder),
     UuidIndex(NumericIndexBuilder<UuidIntType, UuidPayloadType>),
+    UuidMmapIndex(NumericIndexMmapBuilder<UuidIntType, UuidPayloadType>),
 }
 
 impl FieldIndexBuilderTrait for FieldIndexBuilder {
@@ -404,14 +419,20 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
     delegate! {
         to match self {
             Self::IntIndex(index) => index,
+            Self::IntMmapIndex(index) => index,
             Self::DatetimeIndex(index) => index,
+            Self::DatetimeMmapIndex(index) => index,
             Self::IntMapIndex(index) => index,
+            Self::IntMapMmapIndex(index) => index,
             Self::KeywordIndex(index) => index,
+            Self::KeywordMmapIndex(index) => index,
             Self::FloatIndex(index) => index,
+            Self::FloatMmapIndex(index) => index,
             Self::GeoIndex(index) => index,
             Self::BinaryIndex(index) => index,
             Self::FullTextIndex(index) => index,
             Self::UuidIndex(index) => index,
+            Self::UuidMmapIndex(index) => index,
         } {
             fn init(&mut self) -> OperationResult<()>;
             fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
@@ -421,14 +442,20 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
     fn finalize(self) -> OperationResult<FieldIndex> {
         Ok(match self {
             Self::IntIndex(index) => FieldIndex::IntIndex(index.finalize()?),
+            Self::IntMmapIndex(index) => FieldIndex::IntIndex(index.finalize()?),
             Self::DatetimeIndex(index) => FieldIndex::DatetimeIndex(index.finalize()?),
+            Self::DatetimeMmapIndex(index) => FieldIndex::DatetimeIndex(index.finalize()?),
             Self::IntMapIndex(index) => FieldIndex::IntMapIndex(index.finalize()?),
+            Self::IntMapMmapIndex(index) => FieldIndex::IntMapIndex(index.finalize()?),
             Self::KeywordIndex(index) => FieldIndex::KeywordIndex(index.finalize()?),
+            Self::KeywordMmapIndex(index) => FieldIndex::KeywordIndex(index.finalize()?),
             Self::FloatIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
+            Self::FloatMmapIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
             Self::UuidIndex(index) => FieldIndex::UuidIndex(index.finalize()?),
+            Self::UuidMmapIndex(index) => FieldIndex::UuidIndex(index.finalize()?),
         })
     }
 }

commit 564c085d4b0e20fbc3861dae0a8f25f07c9e1696
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Aug 7 19:45:42 2024 +0200

    On-disk Uuid hybrid-index (#4825)
    
    * Migrate uuid index to mmap
    
    * add uuid numeric index
    
    * select correct index + tenants
    
    * Only serialize if necessary
    
    * select correct index
    
    * reset Cargo.toml
    
    * review: use only map index for uuid for now
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 5e9d85385..9c2854068 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -119,6 +119,7 @@ pub enum FieldIndex {
     FullTextIndex(FullTextIndex),
     BinaryIndex(BinaryIndex),
     UuidIndex(NumericIndex<UuidIntType, UuidPayloadType>),
+    UuidMapIndex(MapIndex<UuidIntType>),
 }
 
 impl std::fmt::Debug for FieldIndex {
@@ -133,6 +134,7 @@ impl std::fmt::Debug for FieldIndex {
             FieldIndex::BinaryIndex(_index) => write!(f, "BinaryIndex"),
             FieldIndex::FullTextIndex(_index) => write!(f, "FullTextIndex"),
             FieldIndex::UuidIndex(_index) => write!(f, "UuidIndex"),
+            FieldIndex::UuidMapIndex(_index) => write!(f, "UuidMapIndex"),
         }
     }
 }
@@ -172,6 +174,7 @@ impl FieldIndex {
                 _ => None,
             },
             FieldIndex::UuidIndex(_) => None,
+            FieldIndex::UuidMapIndex(_) => None,
         }
     }
 
@@ -186,6 +189,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
             FieldIndex::UuidIndex(payload_field_index) => payload_field_index.inner(),
+            FieldIndex::UuidMapIndex(payload_field_index) => payload_field_index,
         }
     }
 
@@ -200,6 +204,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::UuidIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::UuidMapIndex(ref mut payload_field_index) => payload_field_index.load(),
         }
     }
 
@@ -214,6 +219,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(index) => index.clear(),
             FieldIndex::FullTextIndex(index) => index.clear(),
             FieldIndex::UuidIndex(index) => index.clear(),
+            FieldIndex::UuidMapIndex(index) => index.clear(),
         }
     }
 
@@ -282,6 +288,9 @@ impl FieldIndex {
             FieldIndex::UuidIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
+            FieldIndex::UuidMapIndex(ref mut payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
         }
     }
 
@@ -296,6 +305,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(index) => index.remove_point(point_id),
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
             FieldIndex::UuidIndex(index) => index.remove_point(point_id),
+            FieldIndex::UuidMapIndex(index) => index.remove_point(point_id),
         }
     }
 
@@ -310,6 +320,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(index) => index.get_telemetry_data(),
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
             FieldIndex::UuidIndex(index) => index.get_telemetry_data(),
+            FieldIndex::UuidMapIndex(index) => index.get_telemetry_data(),
         }
     }
 
@@ -324,6 +335,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(index) => index.values_count(point_id),
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
             FieldIndex::UuidIndex(index) => index.values_count(point_id),
+            FieldIndex::UuidMapIndex(index) => index.values_count(point_id),
         }
     }
 
@@ -338,6 +350,7 @@ impl FieldIndex {
             FieldIndex::BinaryIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
             FieldIndex::UuidIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::UuidMapIndex(index) => index.values_is_empty(point_id),
         }
     }
 
@@ -350,6 +363,7 @@ impl FieldIndex {
             | FieldIndex::KeywordIndex(_)
             | FieldIndex::GeoIndex(_)
             | FieldIndex::BinaryIndex(_)
+            | FieldIndex::UuidMapIndex(_)
             | FieldIndex::UuidIndex(_)
             | FieldIndex::FullTextIndex(_) => None,
         }
@@ -359,7 +373,8 @@ impl FieldIndex {
         match self {
             FieldIndex::KeywordIndex(index) => Some(FacetIndex::KeywordIndex(index)),
             FieldIndex::IntMapIndex(_) // TODO(facets): use int map index too
-            | FieldIndex::UuidIndex(_) // TODO(facets): use uuid index too
+            | FieldIndex::UuidMapIndex(_) // TODO(facets): use uuid index too
+            | FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
             | FieldIndex::DatetimeIndex(_)
             | FieldIndex::FloatIndex(_)
@@ -409,8 +424,8 @@ pub enum FieldIndexBuilder {
     GeoIndex(GeoMapIndexBuilder),
     FullTextIndex(FullTextIndexBuilder),
     BinaryIndex(BinaryIndexBuilder),
-    UuidIndex(NumericIndexBuilder<UuidIntType, UuidPayloadType>),
-    UuidMmapIndex(NumericIndexMmapBuilder<UuidIntType, UuidPayloadType>),
+    UuidIndex(MapIndexBuilder<UuidIntType>),
+    UuidMmapIndex(MapIndexMmapBuilder<UuidIntType>),
 }
 
 impl FieldIndexBuilderTrait for FieldIndexBuilder {
@@ -454,8 +469,8 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
-            Self::UuidIndex(index) => FieldIndex::UuidIndex(index.finalize()?),
-            Self::UuidMmapIndex(index) => FieldIndex::UuidIndex(index.finalize()?),
+            Self::UuidIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
+            Self::UuidMmapIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
         })
     }
 }

commit 3185dd23c50f02e8f38c10839ff622fc2bd3a072
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Aug 19 23:21:17 2024 -0400

    Exact facet mode (#4878)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 9c2854068..10101480c 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -546,6 +546,15 @@ impl<'a> FacetIndex<'a> {
         }
     }
 
+    pub fn iter_values(&self) -> Box<dyn Iterator<Item = FacetValueRef<'a>> + 'a> {
+        match self {
+            FacetIndex::KeywordIndex(index) => {
+                let iter = index.iter_values().map(FacetValueRef::Keyword);
+                Box::new(iter)
+            }
+        }
+    }
+
     pub fn iter_values_map<F>(
         &'a self,
         f: &'a F,

commit 90449b30d672bce523b4b01cf9ff30eabbaa702f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 20 10:12:20 2024 -0400

    perf: Limit bad performance of filtered faceting (#4903)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 10101480c..4c715ad13 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -3,12 +3,13 @@ use std::path::PathBuf;
 
 use common::types::PointOffsetType;
 use delegate::delegate;
+use itertools::Itertools;
 use serde_json::Value;
 
 use super::binary_index::BinaryIndexBuilder;
 use super::full_text_index::text_index::FullTextIndexBuilder;
 use super::geo_index::GeoMapIndexBuilder;
-use super::map_index::{IdRefIter, MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
+use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
 use super::numeric_index::{
     NumericIndex, NumericIndexBuilder, NumericIndexMmapBuilder, StreamRange,
 };
@@ -21,6 +22,8 @@ use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
+use crate::index::struct_filter_context::StructFilterContext;
+use crate::payload_storage::FilterContext;
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
@@ -555,20 +558,20 @@ impl<'a> FacetIndex<'a> {
         }
     }
 
-    pub fn iter_values_map<F>(
-        &'a self,
-        f: &'a F,
-    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + '_>
-    where
-        F: for<'b> Fn(IdRefIter<'b>) -> usize,
-    {
+    pub fn iter_filtered_counts_per_value(
+        &self,
+        context: &'a StructFilterContext,
+    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + 'a> {
         match self {
             FacetIndex::KeywordIndex(index) => {
                 let iter = index
                     .iter_values_map()
                     .map(|(value, internal_ids_iter)| FacetHit {
                         value: FacetValueRef::Keyword(value),
-                        count: f(internal_ids_iter),
+                        count: internal_ids_iter
+                            .unique()
+                            .filter(|point_id| context.check(**point_id))
+                            .count(),
                     });
                 Box::new(iter)
             }

commit 4b429214cc3feeede5d5ab2912fad76523219c4e
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 27 11:30:57 2024 -0400

    Integer and UUID facets (#4946)
    
    * move FacetIndex into facet_index.rs
    
    * add support for integer facets
    
    * add support for uuid facets
    
    * use separate internal structure
    
    * rename FacetValue::Keyword into FacetValue::String in REST
    
    * fix after rebase

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 4c715ad13..487134580 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -3,10 +3,10 @@ use std::path::PathBuf;
 
 use common::types::PointOffsetType;
 use delegate::delegate;
-use itertools::Itertools;
 use serde_json::Value;
 
 use super::binary_index::BinaryIndexBuilder;
+use super::facet_index::FacetIndex;
 use super::full_text_index::text_index::FullTextIndexBuilder;
 use super::geo_index::GeoMapIndexBuilder;
 use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
@@ -15,15 +15,12 @@ use super::numeric_index::{
 };
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
-use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::binary_index::BinaryIndex;
 use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
-use crate::index::struct_filter_context::StructFilterContext;
-use crate::payload_storage::FilterContext;
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     DateTimePayloadType, FieldCondition, FloatPayloadType, IntPayloadType, Match, MatchText,
@@ -374,8 +371,8 @@ impl FieldIndex {
 
     pub fn as_facet_index(&self) -> Option<FacetIndex> {
         match self {
-            FieldIndex::KeywordIndex(index) => Some(FacetIndex::KeywordIndex(index)),
-            FieldIndex::IntMapIndex(_) // TODO(facets): use int map index too
+            FieldIndex::KeywordIndex(index) => Some(FacetIndex::Keyword(index)),
+            FieldIndex::IntMapIndex(index) => Some(FacetIndex::Int(index)),
             | FieldIndex::UuidMapIndex(_) // TODO(facets): use uuid index too
             | FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
@@ -526,70 +523,3 @@ impl<'a> NumericFieldIndex<'a> {
         }
     }
 }
-
-pub enum FacetIndex<'a> {
-    KeywordIndex(&'a MapIndex<str>),
-}
-
-impl<'a> FacetIndex<'a> {
-    pub fn get_values(
-        &self,
-        point_id: PointOffsetType,
-    ) -> Box<dyn Iterator<Item = FacetValueRef<'a>> + 'a> {
-        match self {
-            FacetIndex::KeywordIndex(index) => {
-                let iter = index
-                    .get_values(point_id)
-                    .into_iter()
-                    .flatten() // flatten the Option
-                    .map(FacetValueRef::Keyword);
-
-                Box::new(iter)
-            }
-        }
-    }
-
-    pub fn iter_values(&self) -> Box<dyn Iterator<Item = FacetValueRef<'a>> + 'a> {
-        match self {
-            FacetIndex::KeywordIndex(index) => {
-                let iter = index.iter_values().map(FacetValueRef::Keyword);
-                Box::new(iter)
-            }
-        }
-    }
-
-    pub fn iter_filtered_counts_per_value(
-        &self,
-        context: &'a StructFilterContext,
-    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + 'a> {
-        match self {
-            FacetIndex::KeywordIndex(index) => {
-                let iter = index
-                    .iter_values_map()
-                    .map(|(value, internal_ids_iter)| FacetHit {
-                        value: FacetValueRef::Keyword(value),
-                        count: internal_ids_iter
-                            .unique()
-                            .filter(|point_id| context.check(**point_id))
-                            .count(),
-                    });
-                Box::new(iter)
-            }
-        }
-    }
-    pub fn iter_counts_per_value(
-        &'a self,
-    ) -> Box<dyn Iterator<Item = FacetHit<FacetValueRef<'a>>> + 'a> {
-        match self {
-            FacetIndex::KeywordIndex(index) => {
-                let iter = index
-                    .iter_counts_per_value()
-                    .map(|(value, count)| FacetHit {
-                        value: FacetValueRef::Keyword(value),
-                        count,
-                    });
-                Box::new(iter)
-            }
-        }
-    }
-}

commit f7de6c9017ab951c990a5b5e9e4b815fb8fe7df0
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Aug 28 09:18:02 2024 -0400

    Facets: add consistency param to openapi (#4969)
    
    * add consistency param to openapi
    
    * interpret uuid map index as facet index too

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 487134580..2fb0fb053 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -373,8 +373,8 @@ impl FieldIndex {
         match self {
             FieldIndex::KeywordIndex(index) => Some(FacetIndex::Keyword(index)),
             FieldIndex::IntMapIndex(index) => Some(FacetIndex::Int(index)),
-            | FieldIndex::UuidMapIndex(_) // TODO(facets): use uuid index too
-            | FieldIndex::UuidIndex(_)
+            FieldIndex::UuidMapIndex(index) => Some(FacetIndex::Uuid(index)),
+            FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
             | FieldIndex::DatetimeIndex(_)
             | FieldIndex::FloatIndex(_)

commit a9cedf18a6684c1dab50aec8b35a8a6b922030fd
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Sep 4 19:16:04 2024 +0200

    prefer explicit function definitions instead of macros (#5022)

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 2fb0fb053..13b991a32 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -2,7 +2,6 @@ use std::fmt::Formatter;
 use std::path::PathBuf;
 
 use common::types::PointOffsetType;
-use delegate::delegate;
 use serde_json::Value;
 
 use super::binary_index::BinaryIndexBuilder;
@@ -431,26 +430,43 @@ pub enum FieldIndexBuilder {
 impl FieldIndexBuilderTrait for FieldIndexBuilder {
     type FieldIndexType = FieldIndex;
 
-    delegate! {
-        to match self {
-            Self::IntIndex(index) => index,
-            Self::IntMmapIndex(index) => index,
-            Self::DatetimeIndex(index) => index,
-            Self::DatetimeMmapIndex(index) => index,
-            Self::IntMapIndex(index) => index,
-            Self::IntMapMmapIndex(index) => index,
-            Self::KeywordIndex(index) => index,
-            Self::KeywordMmapIndex(index) => index,
-            Self::FloatIndex(index) => index,
-            Self::FloatMmapIndex(index) => index,
-            Self::GeoIndex(index) => index,
-            Self::BinaryIndex(index) => index,
-            Self::FullTextIndex(index) => index,
-            Self::UuidIndex(index) => index,
-            Self::UuidMmapIndex(index) => index,
-        } {
-            fn init(&mut self) -> OperationResult<()>;
-            fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
+    fn init(&mut self) -> OperationResult<()> {
+        match self {
+            Self::IntIndex(index) => index.init(),
+            Self::IntMmapIndex(index) => index.init(),
+            Self::DatetimeIndex(index) => index.init(),
+            Self::DatetimeMmapIndex(index) => index.init(),
+            Self::IntMapIndex(index) => index.init(),
+            Self::IntMapMmapIndex(index) => index.init(),
+            Self::KeywordIndex(index) => index.init(),
+            Self::KeywordMmapIndex(index) => index.init(),
+            Self::FloatIndex(index) => index.init(),
+            Self::FloatMmapIndex(index) => index.init(),
+            Self::GeoIndex(index) => index.init(),
+            Self::BinaryIndex(index) => index.init(),
+            Self::FullTextIndex(index) => index.init(),
+            Self::UuidIndex(index) => index.init(),
+            Self::UuidMmapIndex(index) => index.init(),
+        }
+    }
+
+    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+        match self {
+            Self::IntIndex(index) => index.add_point(id, payload),
+            Self::IntMmapIndex(index) => index.add_point(id, payload),
+            Self::DatetimeIndex(index) => index.add_point(id, payload),
+            Self::DatetimeMmapIndex(index) => index.add_point(id, payload),
+            Self::IntMapIndex(index) => index.add_point(id, payload),
+            Self::IntMapMmapIndex(index) => index.add_point(id, payload),
+            Self::KeywordIndex(index) => index.add_point(id, payload),
+            Self::KeywordMmapIndex(index) => index.add_point(id, payload),
+            Self::FloatIndex(index) => index.add_point(id, payload),
+            Self::FloatMmapIndex(index) => index.add_point(id, payload),
+            Self::GeoIndex(index) => index.add_point(id, payload),
+            Self::BinaryIndex(index) => index.add_point(id, payload),
+            Self::FullTextIndex(index) => index.add_point(id, payload),
+            Self::UuidIndex(index) => index.add_point(id, payload),
+            Self::UuidMmapIndex(index) => index.add_point(id, payload),
         }
     }
 

commit 2d456df948f91bb770100f63f42a9ca5349e2113
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Sep 13 16:40:20 2024 -0300

    Refactor `FullTextIndex` as enum (#5067)
    
    * refactor inverted index into trait
    
    * create immutable and mutable versions of text index
    
    * migrate to full text index enum
    
    * fix clippy
    
    * review remarks

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 13b991a32..4800b701c 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -6,7 +6,7 @@ use serde_json::Value;
 
 use super::binary_index::BinaryIndexBuilder;
 use super::facet_index::FacetIndex;
-use super::full_text_index::text_index::FullTextIndexBuilder;
+use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
 use super::geo_index::GeoMapIndexBuilder;
 use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
 use super::numeric_index::{
@@ -16,7 +16,6 @@ use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::binary_index::BinaryIndex;
-use crate::index::field_index::full_text_index::text_index::FullTextIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};

commit cf8971503637f3d089670d74df81e31fb76f4fcf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Sep 16 16:27:30 2024 -0300

    Expose `on_disk` text index (#5074)
    
    * map index: fix reachable code marked as unreachable
    
    * plumber work to get mmap text index to interfaces
    
    * test: add fixture for mmap text index, always create mmap segment
    
    * various fixes
    
    - ensure dir is created for mmap
    - implement is_on_disk() for text index
    - invert deleted condition for filter in mmap inverted index
    
    * update grpc docs and openapi
    
    * implement return of files
    
    * review nit
    
    * fix after rebase
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 4800b701c..165106939 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -6,6 +6,7 @@ use serde_json::Value;
 
 use super::binary_index::BinaryIndexBuilder;
 use super::facet_index::FacetIndex;
+use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
 use super::geo_index::GeoMapIndexBuilder;
 use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
@@ -421,6 +422,7 @@ pub enum FieldIndexBuilder {
     FloatMmapIndex(NumericIndexMmapBuilder<FloatPayloadType, FloatPayloadType>),
     GeoIndex(GeoMapIndexBuilder),
     FullTextIndex(FullTextIndexBuilder),
+    FullTextMmapIndex(FullTextMmapIndexBuilder),
     BinaryIndex(BinaryIndexBuilder),
     UuidIndex(MapIndexBuilder<UuidIntType>),
     UuidMmapIndex(MapIndexMmapBuilder<UuidIntType>),
@@ -444,6 +446,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => index.init(),
             Self::BinaryIndex(index) => index.init(),
             Self::FullTextIndex(index) => index.init(),
+            Self::FullTextMmapIndex(builder) => builder.init(),
             Self::UuidIndex(index) => index.init(),
             Self::UuidMmapIndex(index) => index.init(),
         }
@@ -464,6 +467,9 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => index.add_point(id, payload),
             Self::BinaryIndex(index) => index.add_point(id, payload),
             Self::FullTextIndex(index) => index.add_point(id, payload),
+            Self::FullTextMmapIndex(builder) => {
+                FieldIndexBuilderTrait::add_point(builder, id, payload)
+            }
             Self::UuidIndex(index) => index.add_point(id, payload),
             Self::UuidMmapIndex(index) => index.add_point(id, payload),
         }
@@ -484,6 +490,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
+            Self::FullTextMmapIndex(builder) => FieldIndex::FullTextIndex(builder.finalize()?),
             Self::UuidIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
             Self::UuidMmapIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
         })

commit ad6b9734f37b2d28700ed4a14fe3d913abf7531c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Oct 1 09:17:50 2024 -0300

    Facets: Support for `bool` payload  (#5100)
    
    * enable faceting with boolean index
    
    * test and fix
    
    * also test uuid

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 165106939..9b1278cc5 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -373,12 +373,12 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => Some(FacetIndex::Keyword(index)),
             FieldIndex::IntMapIndex(index) => Some(FacetIndex::Int(index)),
             FieldIndex::UuidMapIndex(index) => Some(FacetIndex::Uuid(index)),
+            FieldIndex::BinaryIndex(index) => Some(FacetIndex::Bool(index)),
             FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
             | FieldIndex::DatetimeIndex(_)
             | FieldIndex::FloatIndex(_)
             | FieldIndex::GeoIndex(_)
-            | FieldIndex::BinaryIndex(_)
             | FieldIndex::FullTextIndex(_) => None,
         }
     }

commit aa7e33b68b1bbfc64cef22a7abc91c980f765f19
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Oct 7 14:35:17 2024 +0200

    mmap geo index api (#5163)
    
    * define mmap geo index
    
    fix compilation
    
    deleted flags
    
    load new mmap
    
    geo index tests
    
    fix tests
    
    fix build after rebase
    
    add files list
    
    * refactor get_stored_sub_regions output type
    
    * review remanings
    
    * mmap geo index api
    
    * fix after rebase

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 9b1278cc5..ef3bd8350 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -8,7 +8,7 @@ use super::binary_index::BinaryIndexBuilder;
 use super::facet_index::FacetIndex;
 use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
-use super::geo_index::GeoMapIndexBuilder;
+use super::geo_index::{GeoMapIndexBuilder, GeoMapIndexMmapBuilder};
 use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
 use super::numeric_index::{
     NumericIndex, NumericIndexBuilder, NumericIndexMmapBuilder, StreamRange,
@@ -421,6 +421,7 @@ pub enum FieldIndexBuilder {
     FloatIndex(NumericIndexBuilder<FloatPayloadType, FloatPayloadType>),
     FloatMmapIndex(NumericIndexMmapBuilder<FloatPayloadType, FloatPayloadType>),
     GeoIndex(GeoMapIndexBuilder),
+    GeoMmapIndex(GeoMapIndexMmapBuilder),
     FullTextIndex(FullTextIndexBuilder),
     FullTextMmapIndex(FullTextMmapIndexBuilder),
     BinaryIndex(BinaryIndexBuilder),
@@ -444,6 +445,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatIndex(index) => index.init(),
             Self::FloatMmapIndex(index) => index.init(),
             Self::GeoIndex(index) => index.init(),
+            Self::GeoMmapIndex(index) => index.init(),
             Self::BinaryIndex(index) => index.init(),
             Self::FullTextIndex(index) => index.init(),
             Self::FullTextMmapIndex(builder) => builder.init(),
@@ -465,6 +467,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatIndex(index) => index.add_point(id, payload),
             Self::FloatMmapIndex(index) => index.add_point(id, payload),
             Self::GeoIndex(index) => index.add_point(id, payload),
+            Self::GeoMmapIndex(index) => index.add_point(id, payload),
             Self::BinaryIndex(index) => index.add_point(id, payload),
             Self::FullTextIndex(index) => index.add_point(id, payload),
             Self::FullTextMmapIndex(builder) => {
@@ -488,6 +491,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
             Self::FloatMmapIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
+            Self::GeoMmapIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
             Self::FullTextMmapIndex(builder) => FieldIndex::FullTextIndex(builder.finalize()?),

commit 82daa2121c17402f55a6ff86095c1c225df4a593
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Nov 26 11:33:27 2024 -0600

    Refactor bool index (#5524)
    
    * rename binary->bool
    
    * restructure bool_index module
    
    * rename Boolean->Bool
    
    * rename memory_bool_index -> simple_bool_index

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index ef3bd8350..371cc4c71 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -4,7 +4,7 @@ use std::path::PathBuf;
 use common::types::PointOffsetType;
 use serde_json::Value;
 
-use super::binary_index::BinaryIndexBuilder;
+use super::bool_index::simple_bool_index::BoolIndexBuilder;
 use super::facet_index::FacetIndex;
 use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
@@ -16,7 +16,7 @@ use super::numeric_index::{
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderValue;
-use crate::index::field_index::binary_index::BinaryIndex;
+use crate::index::field_index::bool_index::simple_bool_index::BoolIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
@@ -116,7 +116,7 @@ pub enum FieldIndex {
     FloatIndex(NumericIndex<FloatPayloadType, FloatPayloadType>),
     GeoIndex(GeoMapIndex),
     FullTextIndex(FullTextIndex),
-    BinaryIndex(BinaryIndex),
+    BoolIndex(BoolIndex),
     UuidIndex(NumericIndex<UuidIntType, UuidPayloadType>),
     UuidMapIndex(MapIndex<UuidIntType>),
 }
@@ -130,7 +130,7 @@ impl std::fmt::Debug for FieldIndex {
             FieldIndex::KeywordIndex(_index) => write!(f, "KeywordIndex"),
             FieldIndex::FloatIndex(_index) => write!(f, "FloatIndex"),
             FieldIndex::GeoIndex(_index) => write!(f, "GeoIndex"),
-            FieldIndex::BinaryIndex(_index) => write!(f, "BinaryIndex"),
+            FieldIndex::BoolIndex(_index) => write!(f, "BoolIndex"),
             FieldIndex::FullTextIndex(_index) => write!(f, "FullTextIndex"),
             FieldIndex::UuidIndex(_index) => write!(f, "UuidIndex"),
             FieldIndex::UuidMapIndex(_index) => write!(f, "UuidMapIndex"),
@@ -158,7 +158,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(_) => None,
             FieldIndex::FloatIndex(_) => None,
             FieldIndex::GeoIndex(_) => None,
-            FieldIndex::BinaryIndex(_) => None,
+            FieldIndex::BoolIndex(_) => None,
             FieldIndex::FullTextIndex(full_text_index) => match &condition.r#match {
                 Some(Match::Text(MatchText { text })) => {
                     let query = full_text_index.parse_query(text);
@@ -185,7 +185,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(payload_field_index) => payload_field_index,
             FieldIndex::FloatIndex(payload_field_index) => payload_field_index.inner(),
             FieldIndex::GeoIndex(payload_field_index) => payload_field_index,
-            FieldIndex::BinaryIndex(payload_field_index) => payload_field_index,
+            FieldIndex::BoolIndex(payload_field_index) => payload_field_index,
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
             FieldIndex::UuidIndex(payload_field_index) => payload_field_index.inner(),
             FieldIndex::UuidMapIndex(payload_field_index) => payload_field_index,
@@ -200,7 +200,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::BinaryIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::BoolIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::UuidIndex(ref mut payload_field_index) => payload_field_index.load(),
             FieldIndex::UuidMapIndex(ref mut payload_field_index) => payload_field_index.load(),
@@ -215,7 +215,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.clear(),
             FieldIndex::FloatIndex(index) => index.clear(),
             FieldIndex::GeoIndex(index) => index.clear(),
-            FieldIndex::BinaryIndex(index) => index.clear(),
+            FieldIndex::BoolIndex(index) => index.clear(),
             FieldIndex::FullTextIndex(index) => index.clear(),
             FieldIndex::UuidIndex(index) => index.clear(),
             FieldIndex::UuidMapIndex(index) => index.clear(),
@@ -278,7 +278,7 @@ impl FieldIndex {
             FieldIndex::GeoIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::BinaryIndex(ref mut payload_field_index) => {
+            FieldIndex::BoolIndex(ref mut payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
             FieldIndex::FullTextIndex(ref mut payload_field_index) => {
@@ -301,7 +301,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.remove_point(point_id),
             FieldIndex::FloatIndex(index) => index.mut_inner().remove_point(point_id),
             FieldIndex::GeoIndex(index) => index.remove_point(point_id),
-            FieldIndex::BinaryIndex(index) => index.remove_point(point_id),
+            FieldIndex::BoolIndex(index) => index.remove_point(point_id),
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
             FieldIndex::UuidIndex(index) => index.remove_point(point_id),
             FieldIndex::UuidMapIndex(index) => index.remove_point(point_id),
@@ -316,7 +316,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.get_telemetry_data(),
             FieldIndex::FloatIndex(index) => index.get_telemetry_data(),
             FieldIndex::GeoIndex(index) => index.get_telemetry_data(),
-            FieldIndex::BinaryIndex(index) => index.get_telemetry_data(),
+            FieldIndex::BoolIndex(index) => index.get_telemetry_data(),
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
             FieldIndex::UuidIndex(index) => index.get_telemetry_data(),
             FieldIndex::UuidMapIndex(index) => index.get_telemetry_data(),
@@ -331,7 +331,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.values_count(point_id),
             FieldIndex::FloatIndex(index) => index.values_count(point_id),
             FieldIndex::GeoIndex(index) => index.values_count(point_id),
-            FieldIndex::BinaryIndex(index) => index.values_count(point_id),
+            FieldIndex::BoolIndex(index) => index.values_count(point_id),
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
             FieldIndex::UuidIndex(index) => index.values_count(point_id),
             FieldIndex::UuidMapIndex(index) => index.values_count(point_id),
@@ -346,7 +346,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FloatIndex(index) => index.values_is_empty(point_id),
             FieldIndex::GeoIndex(index) => index.values_is_empty(point_id),
-            FieldIndex::BinaryIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::BoolIndex(index) => index.values_is_empty(point_id),
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
             FieldIndex::UuidIndex(index) => index.values_is_empty(point_id),
             FieldIndex::UuidMapIndex(index) => index.values_is_empty(point_id),
@@ -361,7 +361,7 @@ impl FieldIndex {
             FieldIndex::IntMapIndex(_)
             | FieldIndex::KeywordIndex(_)
             | FieldIndex::GeoIndex(_)
-            | FieldIndex::BinaryIndex(_)
+            | FieldIndex::BoolIndex(_)
             | FieldIndex::UuidMapIndex(_)
             | FieldIndex::UuidIndex(_)
             | FieldIndex::FullTextIndex(_) => None,
@@ -373,7 +373,7 @@ impl FieldIndex {
             FieldIndex::KeywordIndex(index) => Some(FacetIndex::Keyword(index)),
             FieldIndex::IntMapIndex(index) => Some(FacetIndex::Int(index)),
             FieldIndex::UuidMapIndex(index) => Some(FacetIndex::Uuid(index)),
-            FieldIndex::BinaryIndex(index) => Some(FacetIndex::Bool(index)),
+            FieldIndex::BoolIndex(index) => Some(FacetIndex::Bool(index)),
             FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
             | FieldIndex::DatetimeIndex(_)
@@ -424,7 +424,7 @@ pub enum FieldIndexBuilder {
     GeoMmapIndex(GeoMapIndexMmapBuilder),
     FullTextIndex(FullTextIndexBuilder),
     FullTextMmapIndex(FullTextMmapIndexBuilder),
-    BinaryIndex(BinaryIndexBuilder),
+    BoolIndex(BoolIndexBuilder),
     UuidIndex(MapIndexBuilder<UuidIntType>),
     UuidMmapIndex(MapIndexMmapBuilder<UuidIntType>),
 }
@@ -446,7 +446,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatMmapIndex(index) => index.init(),
             Self::GeoIndex(index) => index.init(),
             Self::GeoMmapIndex(index) => index.init(),
-            Self::BinaryIndex(index) => index.init(),
+            Self::BoolIndex(index) => index.init(),
             Self::FullTextIndex(index) => index.init(),
             Self::FullTextMmapIndex(builder) => builder.init(),
             Self::UuidIndex(index) => index.init(),
@@ -468,7 +468,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatMmapIndex(index) => index.add_point(id, payload),
             Self::GeoIndex(index) => index.add_point(id, payload),
             Self::GeoMmapIndex(index) => index.add_point(id, payload),
-            Self::BinaryIndex(index) => index.add_point(id, payload),
+            Self::BoolIndex(index) => index.add_point(id, payload),
             Self::FullTextIndex(index) => index.add_point(id, payload),
             Self::FullTextMmapIndex(builder) => {
                 FieldIndexBuilderTrait::add_point(builder, id, payload)
@@ -492,7 +492,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FloatMmapIndex(index) => FieldIndex::FloatIndex(index.finalize()?),
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::GeoMmapIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
-            Self::BinaryIndex(index) => FieldIndex::BinaryIndex(index.finalize()?),
+            Self::BoolIndex(index) => FieldIndex::BoolIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
             Self::FullTextMmapIndex(builder) => FieldIndex::FullTextIndex(builder.finalize()?),
             Self::UuidIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),

commit c573f2f0a23e86cd1be27d67d17fa486a3ff9adf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Dec 6 17:29:19 2024 -0600

    Mmap bool index (#5526)
    
    * add `MmapBitSlice::extend` helper
    
    * mmap bool index implementation
    
    * unit test both implementations
    
    * switch to `DynamicMmapFlags`
    
    * tidy up
    
    * recalculate `indexed_count` on load
    
    * grow bitslice aligned to the mmap page size
    
    * ergonomic get_slice_for
    
    * fix for growing mmap
    
    * use more `get_slice_for()`

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 371cc4c71..b18e7b1c2 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -33,8 +33,8 @@ pub trait PayloadFieldIndex {
     /// Load index from disk.
     fn load(&mut self) -> OperationResult<bool>;
 
-    /// Remove db content of the current payload index
-    fn clear(self) -> OperationResult<()>;
+    /// Remove db content or files of the current payload index
+    fn cleanup(self) -> OperationResult<()>;
 
     /// Return function that flushes all pending updates to disk.
     fn flusher(&self) -> Flusher;
@@ -207,18 +207,18 @@ impl FieldIndex {
         }
     }
 
-    pub fn clear(self) -> OperationResult<()> {
+    pub fn cleanup(self) -> OperationResult<()> {
         match self {
-            FieldIndex::IntIndex(index) => index.clear(),
-            FieldIndex::DatetimeIndex(index) => index.clear(),
-            FieldIndex::IntMapIndex(index) => index.clear(),
-            FieldIndex::KeywordIndex(index) => index.clear(),
-            FieldIndex::FloatIndex(index) => index.clear(),
-            FieldIndex::GeoIndex(index) => index.clear(),
-            FieldIndex::BoolIndex(index) => index.clear(),
-            FieldIndex::FullTextIndex(index) => index.clear(),
-            FieldIndex::UuidIndex(index) => index.clear(),
-            FieldIndex::UuidMapIndex(index) => index.clear(),
+            FieldIndex::IntIndex(index) => index.cleanup(),
+            FieldIndex::DatetimeIndex(index) => index.cleanup(),
+            FieldIndex::IntMapIndex(index) => index.cleanup(),
+            FieldIndex::KeywordIndex(index) => index.cleanup(),
+            FieldIndex::FloatIndex(index) => index.cleanup(),
+            FieldIndex::GeoIndex(index) => index.cleanup(),
+            FieldIndex::BoolIndex(index) => index.cleanup(),
+            FieldIndex::FullTextIndex(index) => index.cleanup(),
+            FieldIndex::UuidIndex(index) => index.cleanup(),
+            FieldIndex::UuidMapIndex(index) => index.cleanup(),
         }
     }
 

commit 681506cea7bd6bf7ae80114775f39580ee8392e8
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Dec 16 23:35:10 2024 +0000

    Integrate mmap bool index (#5571)
    
    * add on_disk option for bool index
    
    * test that all files are covered
    
    * generate openapi and docs
    
    * clippy
    
    * remove `populate` changes
    
    * use `walkdir` crate
    
    * Apply clippy suggestions
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index b18e7b1c2..02be9f75f 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -4,7 +4,9 @@ use std::path::PathBuf;
 use common::types::PointOffsetType;
 use serde_json::Value;
 
+use super::bool_index::mmap_bool_index::MmapBoolIndexBuilder;
 use super::bool_index::simple_bool_index::BoolIndexBuilder;
+use super::bool_index::BoolIndex;
 use super::facet_index::FacetIndex;
 use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
@@ -16,7 +18,6 @@ use super::numeric_index::{
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::order_by::OrderValue;
-use crate::index::field_index::bool_index::simple_bool_index::BoolIndex;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
@@ -146,7 +147,7 @@ impl FieldIndex {
     /// Returns `None` if there is no special logic for the given index
     /// returns `Some(true)` if condition is satisfied
     /// returns `Some(false)` if condition is not satisfied
-    pub fn check_condition(
+    pub fn special_check_condition(
         &self,
         condition: &FieldCondition,
         payload_value: &Value,
@@ -425,6 +426,7 @@ pub enum FieldIndexBuilder {
     FullTextIndex(FullTextIndexBuilder),
     FullTextMmapIndex(FullTextMmapIndexBuilder),
     BoolIndex(BoolIndexBuilder),
+    BoolMmapIndex(MmapBoolIndexBuilder),
     UuidIndex(MapIndexBuilder<UuidIntType>),
     UuidMmapIndex(MapIndexMmapBuilder<UuidIntType>),
 }
@@ -447,6 +449,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => index.init(),
             Self::GeoMmapIndex(index) => index.init(),
             Self::BoolIndex(index) => index.init(),
+            Self::BoolMmapIndex(index) => index.init(),
             Self::FullTextIndex(index) => index.init(),
             Self::FullTextMmapIndex(builder) => builder.init(),
             Self::UuidIndex(index) => index.init(),
@@ -469,6 +472,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => index.add_point(id, payload),
             Self::GeoMmapIndex(index) => index.add_point(id, payload),
             Self::BoolIndex(index) => index.add_point(id, payload),
+            Self::BoolMmapIndex(index) => index.add_point(id, payload),
             Self::FullTextIndex(index) => index.add_point(id, payload),
             Self::FullTextMmapIndex(builder) => {
                 FieldIndexBuilderTrait::add_point(builder, id, payload)
@@ -493,6 +497,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::GeoIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::GeoMmapIndex(index) => FieldIndex::GeoIndex(index.finalize()?),
             Self::BoolIndex(index) => FieldIndex::BoolIndex(index.finalize()?),
+            Self::BoolMmapIndex(index) => FieldIndex::BoolIndex(index.finalize()?),
             Self::FullTextIndex(index) => FieldIndex::FullTextIndex(index.finalize()?),
             Self::FullTextMmapIndex(builder) => FieldIndex::FullTextIndex(builder.finalize()?),
             Self::UuidIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),

commit 97e3f4c824a98a3621b7d48cf3e70a2f5dc7ad3c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Dec 18 05:53:01 2024 -0300

    Introduce facet index trait (#5673)
    
    * introduce facet index trait
    
    * clippy
    
    * fix simple bool index's `get_point_values`

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 02be9f75f..33ab6ad5a 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -7,7 +7,7 @@ use serde_json::Value;
 use super::bool_index::mmap_bool_index::MmapBoolIndexBuilder;
 use super::bool_index::simple_bool_index::BoolIndexBuilder;
 use super::bool_index::BoolIndex;
-use super::facet_index::FacetIndex;
+use super::facet_index::FacetIndexEnum;
 use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
 use super::geo_index::{GeoMapIndexBuilder, GeoMapIndexMmapBuilder};
@@ -369,12 +369,12 @@ impl FieldIndex {
         }
     }
 
-    pub fn as_facet_index(&self) -> Option<FacetIndex> {
+    pub fn as_facet_index(&self) -> Option<FacetIndexEnum> {
         match self {
-            FieldIndex::KeywordIndex(index) => Some(FacetIndex::Keyword(index)),
-            FieldIndex::IntMapIndex(index) => Some(FacetIndex::Int(index)),
-            FieldIndex::UuidMapIndex(index) => Some(FacetIndex::Uuid(index)),
-            FieldIndex::BoolIndex(index) => Some(FacetIndex::Bool(index)),
+            FieldIndex::KeywordIndex(index) => Some(FacetIndexEnum::Keyword(index)),
+            FieldIndex::IntMapIndex(index) => Some(FacetIndexEnum::Int(index)),
+            FieldIndex::UuidMapIndex(index) => Some(FacetIndexEnum::Uuid(index)),
+            FieldIndex::BoolIndex(index) => Some(FacetIndexEnum::Bool(index)),
             FieldIndex::UuidIndex(_)
             | FieldIndex::IntIndex(_)
             | FieldIndex::DatetimeIndex(_)

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 33ab6ad5a..3d4517b25 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -4,9 +4,9 @@ use std::path::PathBuf;
 use common::types::PointOffsetType;
 use serde_json::Value;
 
+use super::bool_index::BoolIndex;
 use super::bool_index::mmap_bool_index::MmapBoolIndexBuilder;
 use super::bool_index::simple_bool_index::BoolIndexBuilder;
-use super::bool_index::BoolIndex;
 use super::facet_index::FacetIndexEnum;
 use super::full_text_index::mmap_text_index::FullTextMmapIndexBuilder;
 use super::full_text_index::text_index::{FullTextIndex, FullTextIndexBuilder};
@@ -15,8 +15,8 @@ use super::map_index::{MapIndex, MapIndexBuilder, MapIndexMmapBuilder};
 use super::numeric_index::{
     NumericIndex, NumericIndexBuilder, NumericIndexMmapBuilder, StreamRange,
 };
-use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
+use crate::common::operation_error::OperationResult;
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::geo_index::GeoMapIndex;
 use crate::index::field_index::numeric_index::NumericIndexInner;
@@ -195,16 +195,16 @@ impl FieldIndex {
 
     pub fn load(&mut self) -> OperationResult<bool> {
         match self {
-            FieldIndex::IntIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::DatetimeIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::IntMapIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::KeywordIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::FloatIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::GeoIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::BoolIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::FullTextIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::UuidIndex(ref mut payload_field_index) => payload_field_index.load(),
-            FieldIndex::UuidMapIndex(ref mut payload_field_index) => payload_field_index.load(),
+            FieldIndex::IntIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::DatetimeIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::IntMapIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::KeywordIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::FloatIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::GeoIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::BoolIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::FullTextIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::UuidIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::UuidMapIndex(payload_field_index) => payload_field_index.load(),
         }
     }
 
@@ -261,34 +261,30 @@ impl FieldIndex {
 
     pub fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
         match self {
-            FieldIndex::IntIndex(ref mut payload_field_index) => {
-                payload_field_index.add_point(id, payload)
-            }
-            FieldIndex::DatetimeIndex(ref mut payload_field_index) => {
-                payload_field_index.add_point(id, payload)
-            }
-            FieldIndex::IntMapIndex(ref mut payload_field_index) => {
+            FieldIndex::IntIndex(payload_field_index) => payload_field_index.add_point(id, payload),
+            FieldIndex::DatetimeIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::KeywordIndex(ref mut payload_field_index) => {
+            FieldIndex::IntMapIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::FloatIndex(ref mut payload_field_index) => {
+            FieldIndex::KeywordIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::GeoIndex(ref mut payload_field_index) => {
+            FieldIndex::FloatIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::BoolIndex(ref mut payload_field_index) => {
+            FieldIndex::GeoIndex(payload_field_index) => payload_field_index.add_point(id, payload),
+            FieldIndex::BoolIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::FullTextIndex(ref mut payload_field_index) => {
+            FieldIndex::FullTextIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::UuidIndex(ref mut payload_field_index) => {
+            FieldIndex::UuidIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
-            FieldIndex::UuidMapIndex(ref mut payload_field_index) => {
+            FieldIndex::UuidMapIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
         }

commit 706b1a31665ee4a2e44a0a20845bb8065b0dbc28
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 4 13:19:50 2025 +0100

    IsEmpty/IsNull index (#6088)
    
    * create initial strucutres
    
    * clippy
    
    * start field-query refactoring
    
    * start field-query refactoring (2/N)
    
    * start field-query refactoring (3/N): duplicate is_empty/null condiftions as field condition
    
    * start field-query refactoring (4/N): re-instate is_empty fallback in case new index is not built yet
    
    * filter for is_empty/is_null
    
    * implement add/remove point
    
    * upd schema
    
    * open and create of null-index
    
    * create null-index
    
    * fix test
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * unit test for null-index
    
    * more unit tests
    
    * add openapi tests
    
    * fmt
    
    * fix for integartion tests
    
    * rabbit review fix
    
    * make [null] non-empty
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 3d4517b25..f34a88a3c 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -19,6 +19,7 @@ use crate::common::Flusher;
 use crate::common::operation_error::OperationResult;
 use crate::data_types::order_by::OrderValue;
 use crate::index::field_index::geo_index::GeoMapIndex;
+use crate::index::field_index::null_index::mmap_null_index::{MmapNullIndex, MmapNullIndexBuilder};
 use crate::index::field_index::numeric_index::NumericIndexInner;
 use crate::index::field_index::{CardinalityEstimation, PayloadBlockCondition};
 use crate::telemetry::PayloadIndexTelemetry;
@@ -120,6 +121,7 @@ pub enum FieldIndex {
     BoolIndex(BoolIndex),
     UuidIndex(NumericIndex<UuidIntType, UuidPayloadType>),
     UuidMapIndex(MapIndex<UuidIntType>),
+    NullIndex(MmapNullIndex),
 }
 
 impl std::fmt::Debug for FieldIndex {
@@ -135,6 +137,7 @@ impl std::fmt::Debug for FieldIndex {
             FieldIndex::FullTextIndex(_index) => write!(f, "FullTextIndex"),
             FieldIndex::UuidIndex(_index) => write!(f, "UuidIndex"),
             FieldIndex::UuidMapIndex(_index) => write!(f, "UuidMapIndex"),
+            FieldIndex::NullIndex(_index) => write!(f, "NullIndex"),
         }
     }
 }
@@ -175,6 +178,7 @@ impl FieldIndex {
             },
             FieldIndex::UuidIndex(_) => None,
             FieldIndex::UuidMapIndex(_) => None,
+            FieldIndex::NullIndex(_) => None,
         }
     }
 
@@ -190,6 +194,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index,
             FieldIndex::UuidIndex(payload_field_index) => payload_field_index.inner(),
             FieldIndex::UuidMapIndex(payload_field_index) => payload_field_index,
+            FieldIndex::NullIndex(payload_field_index) => payload_field_index,
         }
     }
 
@@ -205,6 +210,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(payload_field_index) => payload_field_index.load(),
             FieldIndex::UuidIndex(payload_field_index) => payload_field_index.load(),
             FieldIndex::UuidMapIndex(payload_field_index) => payload_field_index.load(),
+            FieldIndex::NullIndex(payload_field_index) => payload_field_index.load(),
         }
     }
 
@@ -220,6 +226,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.cleanup(),
             FieldIndex::UuidIndex(index) => index.cleanup(),
             FieldIndex::UuidMapIndex(index) => index.cleanup(),
+            FieldIndex::NullIndex(index) => index.cleanup(),
         }
     }
 
@@ -287,6 +294,9 @@ impl FieldIndex {
             FieldIndex::UuidMapIndex(payload_field_index) => {
                 payload_field_index.add_point(id, payload)
             }
+            FieldIndex::NullIndex(payload_field_index) => {
+                payload_field_index.add_point(id, payload)
+            }
         }
     }
 
@@ -302,6 +312,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.remove_point(point_id),
             FieldIndex::UuidIndex(index) => index.remove_point(point_id),
             FieldIndex::UuidMapIndex(index) => index.remove_point(point_id),
+            FieldIndex::NullIndex(index) => index.remove_point(point_id),
         }
     }
 
@@ -317,6 +328,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.get_telemetry_data(),
             FieldIndex::UuidIndex(index) => index.get_telemetry_data(),
             FieldIndex::UuidMapIndex(index) => index.get_telemetry_data(),
+            FieldIndex::NullIndex(index) => index.get_telemetry_data(),
         }
     }
 
@@ -332,6 +344,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.values_count(point_id),
             FieldIndex::UuidIndex(index) => index.values_count(point_id),
             FieldIndex::UuidMapIndex(index) => index.values_count(point_id),
+            FieldIndex::NullIndex(index) => index.values_count(point_id),
         }
     }
 
@@ -347,6 +360,7 @@ impl FieldIndex {
             FieldIndex::FullTextIndex(index) => index.values_is_empty(point_id),
             FieldIndex::UuidIndex(index) => index.values_is_empty(point_id),
             FieldIndex::UuidMapIndex(index) => index.values_is_empty(point_id),
+            FieldIndex::NullIndex(index) => index.values_is_empty(point_id),
         }
     }
 
@@ -361,7 +375,8 @@ impl FieldIndex {
             | FieldIndex::BoolIndex(_)
             | FieldIndex::UuidMapIndex(_)
             | FieldIndex::UuidIndex(_)
-            | FieldIndex::FullTextIndex(_) => None,
+            | FieldIndex::FullTextIndex(_)
+            | FieldIndex::NullIndex(_) => None,
         }
     }
 
@@ -376,7 +391,8 @@ impl FieldIndex {
             | FieldIndex::DatetimeIndex(_)
             | FieldIndex::FloatIndex(_)
             | FieldIndex::GeoIndex(_)
-            | FieldIndex::FullTextIndex(_) => None,
+            | FieldIndex::FullTextIndex(_)
+            | FieldIndex::NullIndex(_) => None,
         }
     }
 }
@@ -425,6 +441,7 @@ pub enum FieldIndexBuilder {
     BoolMmapIndex(MmapBoolIndexBuilder),
     UuidIndex(MapIndexBuilder<UuidIntType>),
     UuidMmapIndex(MapIndexMmapBuilder<UuidIntType>),
+    NullIndex(MmapNullIndexBuilder),
 }
 
 impl FieldIndexBuilderTrait for FieldIndexBuilder {
@@ -450,6 +467,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FullTextMmapIndex(builder) => builder.init(),
             Self::UuidIndex(index) => index.init(),
             Self::UuidMmapIndex(index) => index.init(),
+            Self::NullIndex(index) => index.init(),
         }
     }
 
@@ -475,6 +493,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             }
             Self::UuidIndex(index) => index.add_point(id, payload),
             Self::UuidMmapIndex(index) => index.add_point(id, payload),
+            Self::NullIndex(index) => index.add_point(id, payload),
         }
     }
 
@@ -498,6 +517,7 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
             Self::FullTextMmapIndex(builder) => FieldIndex::FullTextIndex(builder.finalize()?),
             Self::UuidIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
             Self::UuidMmapIndex(index) => FieldIndex::UuidMapIndex(index.finalize()?),
+            Self::NullIndex(index) => FieldIndex::NullIndex(index.finalize()?),
         })
     }
 }

commit 6d53bd91845ee56bb252c08716fdf46d883c48aa
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Mar 12 14:31:48 2025 +0100

    IO read measurements for most Payload indices (#5951)
    
    * Add payload index filtering IO measurements for some indices
    
    * Add payload index metric to api and telemetry
    
    * Also account for index access overhead
    
    * Review remarks
    
    * Anonymize new HardwareUsage field
    
    * Fix tests

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index f34a88a3c..ab152bb7d 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,6 +1,7 @@
 use std::fmt::Formatter;
 use std::path::PathBuf;
 
+use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::types::PointOffsetType;
 use serde_json::Value;
 
@@ -48,6 +49,7 @@ pub trait PayloadFieldIndex {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
+        hw_counter: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
 
     /// Return estimation of amount of points which satisfy given condition.
@@ -245,8 +247,9 @@ impl FieldIndex {
     pub fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
+        hw_acc: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        self.get_payload_field_index().filter(condition)
+        self.get_payload_field_index().filter(condition, hw_acc)
     }
 
     pub fn estimate_cardinality(

commit 9554383a1e455dffa21d713b8622d0c991e24582
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Mar 13 09:32:24 2025 +0100

    Payload fulltext index IO read measurements (#5954)
    
    * FullTextIndex filter measurements
    
    * Clippy
    
    * Add test for `new_accumulator`

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index ab152bb7d..eb3f016c5 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -2,6 +2,7 @@ use std::fmt::Formatter;
 use std::path::PathBuf;
 
 use common::counter::hardware_accumulator::HwMeasurementAcc;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use serde_json::Value;
 
@@ -156,6 +157,7 @@ impl FieldIndex {
         &self,
         condition: &FieldCondition,
         payload_value: &Value,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<bool> {
         match self {
             FieldIndex::IntIndex(_) => None,
@@ -167,10 +169,10 @@ impl FieldIndex {
             FieldIndex::BoolIndex(_) => None,
             FieldIndex::FullTextIndex(full_text_index) => match &condition.r#match {
                 Some(Match::Text(MatchText { text })) => {
-                    let query = full_text_index.parse_query(text);
+                    let query = full_text_index.parse_query(text, hw_counter);
                     for value in FullTextIndex::get_values(payload_value) {
-                        let document = full_text_index.parse_document(&value);
-                        if query.check_match(&document) {
+                        let document = full_text_index.parse_document(&value, hw_counter);
+                        if query.check_match(&document, hw_counter) {
                             return Some(true);
                         }
                     }

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index eb3f016c5..4c2d6b701 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -1,7 +1,6 @@
 use std::fmt::Formatter;
 use std::path::PathBuf;
 
-use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use serde_json::Value;
@@ -50,12 +49,16 @@ pub trait PayloadFieldIndex {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_counter: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>>;
 
     /// Return estimation of amount of points which satisfy given condition.
     /// Returns `None` if the condition does not match the index type
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation>;
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation>;
 
     /// Iterate conditions for payload blocks with minimum size of `threshold`
     /// Required for building HNSW index
@@ -249,17 +252,18 @@ impl FieldIndex {
     pub fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_acc: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        self.get_payload_field_index().filter(condition, hw_acc)
+        self.get_payload_field_index().filter(condition, hw_counter)
     }
 
     pub fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<CardinalityEstimation> {
         self.get_payload_field_index()
-            .estimate_cardinality(condition)
+            .estimate_cardinality(condition, hw_counter)
     }
 
     pub fn payload_blocks(

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 4c2d6b701..7cb8c466a 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -78,6 +78,7 @@ pub trait ValueIndexer {
         &mut self,
         id: PointOffsetType,
         values: Vec<Self::ValueType>,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()>;
 
     /// Extract index-able value from payload `Value`
@@ -92,7 +93,12 @@ pub trait ValueIndexer {
     }
 
     /// Add point with payload to index
-    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         self.remove_point(id)?;
         let mut flatten_values: Vec<_> = vec![];
         for value in payload.iter() {
@@ -107,7 +113,7 @@ pub trait ValueIndexer {
                 }
             }
         }
-        self.add_many(id, flatten_values)
+        self.add_many(id, flatten_values, hw_counter)
     }
 
     /// remove a point from the index
@@ -275,36 +281,45 @@ impl FieldIndex {
             .payload_blocks(threshold, key)
     }
 
-    pub fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+    pub fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         match self {
-            FieldIndex::IntIndex(payload_field_index) => payload_field_index.add_point(id, payload),
+            FieldIndex::IntIndex(payload_field_index) => {
+                payload_field_index.add_point(id, payload, hw_counter)
+            }
             FieldIndex::DatetimeIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::IntMapIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::KeywordIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::FloatIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
+            }
+            FieldIndex::GeoIndex(payload_field_index) => {
+                payload_field_index.add_point(id, payload, hw_counter)
             }
-            FieldIndex::GeoIndex(payload_field_index) => payload_field_index.add_point(id, payload),
             FieldIndex::BoolIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::FullTextIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::UuidIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::UuidMapIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
             FieldIndex::NullIndex(payload_field_index) => {
-                payload_field_index.add_point(id, payload)
+                payload_field_index.add_point(id, payload, hw_counter)
             }
         }
     }
@@ -415,7 +430,12 @@ pub trait FieldIndexBuilderTrait {
     /// Expected to be called exactly once before any other method.
     fn init(&mut self) -> OperationResult<()>;
 
-    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()>;
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()>;
 
     fn finalize(self) -> OperationResult<Self::FieldIndexType>;
 
@@ -480,29 +500,34 @@ impl FieldIndexBuilderTrait for FieldIndexBuilder {
         }
     }
 
-    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         match self {
-            Self::IntIndex(index) => index.add_point(id, payload),
-            Self::IntMmapIndex(index) => index.add_point(id, payload),
-            Self::DatetimeIndex(index) => index.add_point(id, payload),
-            Self::DatetimeMmapIndex(index) => index.add_point(id, payload),
-            Self::IntMapIndex(index) => index.add_point(id, payload),
-            Self::IntMapMmapIndex(index) => index.add_point(id, payload),
-            Self::KeywordIndex(index) => index.add_point(id, payload),
-            Self::KeywordMmapIndex(index) => index.add_point(id, payload),
-            Self::FloatIndex(index) => index.add_point(id, payload),
-            Self::FloatMmapIndex(index) => index.add_point(id, payload),
-            Self::GeoIndex(index) => index.add_point(id, payload),
-            Self::GeoMmapIndex(index) => index.add_point(id, payload),
-            Self::BoolIndex(index) => index.add_point(id, payload),
-            Self::BoolMmapIndex(index) => index.add_point(id, payload),
-            Self::FullTextIndex(index) => index.add_point(id, payload),
+            Self::IntIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::IntMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::DatetimeIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::DatetimeMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::IntMapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::IntMapMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::KeywordIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::KeywordMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::FloatIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::FloatMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::GeoIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::GeoMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::BoolIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::BoolMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::FullTextIndex(index) => index.add_point(id, payload, hw_counter),
             Self::FullTextMmapIndex(builder) => {
-                FieldIndexBuilderTrait::add_point(builder, id, payload)
+                FieldIndexBuilderTrait::add_point(builder, id, payload, hw_counter)
             }
-            Self::UuidIndex(index) => index.add_point(id, payload),
-            Self::UuidMmapIndex(index) => index.add_point(id, payload),
-            Self::NullIndex(index) => index.add_point(id, payload),
+            Self::UuidIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::UuidMmapIndex(index) => index.add_point(id, payload, hw_counter),
+            Self::NullIndex(index) => index.add_point(id, payload, hw_counter),
         }
     }
 

commit 07fbe5465b5b4b412275480f7e4c1aeb6eca50b4
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Apr 3 19:43:32 2025 +0200

    Don't measure in-memory hw for full text indices (#6309)
    
    * Don't measure in-memory full text index
    
    * Clippy
    
    * Fix mmap_postings conditioned counting

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 7cb8c466a..2c0dc3aca 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -181,7 +181,7 @@ impl FieldIndex {
                     let query = full_text_index.parse_query(text, hw_counter);
                     for value in FullTextIndex::get_values(payload_value) {
                         let document = full_text_index.parse_document(&value, hw_counter);
-                        if query.check_match(&document, hw_counter) {
+                        if query.check_match(&document) {
                             return Some(true);
                         }
                     }

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/index/field_index/field_index_base.rs b/lib/segment/src/index/field_index/field_index_base.rs
index 2c0dc3aca..002cf25f9 100644
--- a/lib/segment/src/index/field_index/field_index_base.rs
+++ b/lib/segment/src/index/field_index/field_index_base.rs
@@ -419,6 +419,57 @@ impl FieldIndex {
             | FieldIndex::NullIndex(_) => None,
         }
     }
+
+    pub fn is_on_disk(&self) -> bool {
+        match self {
+            FieldIndex::IntIndex(index) => index.is_on_disk(),
+            FieldIndex::DatetimeIndex(index) => index.is_on_disk(),
+            FieldIndex::IntMapIndex(index) => index.is_on_disk(),
+            FieldIndex::KeywordIndex(index) => index.is_on_disk(),
+            FieldIndex::FloatIndex(index) => index.is_on_disk(),
+            FieldIndex::GeoIndex(index) => index.is_on_disk(),
+            FieldIndex::BoolIndex(index) => index.is_on_disk(),
+            FieldIndex::FullTextIndex(index) => index.is_on_disk(),
+            FieldIndex::UuidIndex(index) => index.is_on_disk(),
+            FieldIndex::UuidMapIndex(index) => index.is_on_disk(),
+            FieldIndex::NullIndex(index) => index.is_on_disk(),
+        }
+    }
+
+    /// Populate all pages in the mmap.
+    /// Block until all pages are populated.
+    pub fn populate(&self) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(index) => index.populate(),
+            FieldIndex::DatetimeIndex(index) => index.populate(),
+            FieldIndex::IntMapIndex(index) => index.populate(),
+            FieldIndex::KeywordIndex(index) => index.populate(),
+            FieldIndex::FloatIndex(index) => index.populate(),
+            FieldIndex::GeoIndex(index) => index.populate(),
+            FieldIndex::BoolIndex(index) => index.populate(),
+            FieldIndex::FullTextIndex(index) => index.populate(),
+            FieldIndex::UuidIndex(index) => index.populate(),
+            FieldIndex::UuidMapIndex(index) => index.populate(),
+            FieldIndex::NullIndex(index) => index.populate(),
+        }
+    }
+
+    /// Drop disk cache.
+    pub fn clear_cache(&self) -> OperationResult<()> {
+        match self {
+            FieldIndex::IntIndex(index) => index.clear_cache(),
+            FieldIndex::DatetimeIndex(index) => index.clear_cache(),
+            FieldIndex::IntMapIndex(index) => index.clear_cache(),
+            FieldIndex::KeywordIndex(index) => index.clear_cache(),
+            FieldIndex::FloatIndex(index) => index.clear_cache(),
+            FieldIndex::GeoIndex(index) => index.clear_cache(),
+            FieldIndex::BoolIndex(index) => index.clear_cache(),
+            FieldIndex::FullTextIndex(index) => index.clear_cache(),
+            FieldIndex::UuidIndex(index) => index.clear_cache(),
+            FieldIndex::UuidMapIndex(index) => index.clear_cache(),
+            FieldIndex::NullIndex(index) => index.clear_cache(),
+        }
+    }
 }
 
 /// Common interface for all index builders.

