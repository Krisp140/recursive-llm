# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/vector_storage/raw_scorer.rs

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
new file mode 100644
index 000000000..bfa84d3f4
--- /dev/null
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -0,0 +1,160 @@
+use std::marker::PhantomData;
+
+use bitvec::vec::BitVec;
+
+use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
+use crate::data_types::vectors::VectorElementType;
+use crate::spaces::metric::Metric;
+use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
+use crate::spaces::tools::peek_top_largest_iterable;
+use crate::types::{Distance, PointOffsetType, ScoreType};
+
+/// Optimized scorer for multiple scoring requests comparing with a single query
+/// Holds current query and params, receives only subset of points to score
+pub trait RawScorer {
+    fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
+
+    /// Return true if point satisfies current search context (exists and not deleted)
+    fn check_point(&self, point: PointOffsetType) -> bool;
+
+    /// Score stored vector with vector under the given index
+    fn score_point(&self, point: PointOffsetType) -> ScoreType;
+
+    /// Return distance between stored points selected by ids
+    /// Panics if any id is out of range
+    fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
+
+    fn peek_top_iter(
+        &self,
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+
+    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
+}
+
+pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
+    pub points_count: PointOffsetType,
+    pub query: Vec<VectorElementType>,
+    pub vector_storage: &'a TVectorStorage,
+    pub deleted: &'a BitVec,
+    pub metric: PhantomData<TMetric>,
+}
+
+pub fn new_raw_scorer<'a>(
+    vector: Vec<VectorElementType>,
+    vector_storage: &'a VectorStorageEnum,
+    deleted: &'a BitVec,
+) -> Box<dyn RawScorer + 'a> {
+    match vector_storage {
+        VectorStorageEnum::Simple(vector_storage) => {
+            raw_scorer_impl(vector, vector_storage, deleted)
+        }
+        VectorStorageEnum::Memmap(vector_storage) => {
+            raw_scorer_impl(vector, vector_storage.as_ref(), deleted)
+        }
+    }
+}
+
+fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
+    vector: Vec<VectorElementType>,
+    vector_storage: &'a TVectorStorage,
+    deleted: &'a BitVec,
+) -> Box<dyn RawScorer + 'a> {
+    let points_count = vector_storage.total_vector_count() as PointOffsetType;
+    match vector_storage.distance() {
+        Distance::Cosine => Box::new(RawScorerImpl::<'a, CosineMetric, TVectorStorage> {
+            points_count,
+            query: CosineMetric::preprocess(&vector).unwrap_or(vector),
+            vector_storage,
+            deleted,
+            metric: PhantomData,
+        }),
+        Distance::Euclid => Box::new(RawScorerImpl::<'a, EuclidMetric, TVectorStorage> {
+            points_count,
+            query: EuclidMetric::preprocess(&vector).unwrap_or(vector),
+            vector_storage,
+            deleted,
+            metric: PhantomData,
+        }),
+        Distance::Dot => Box::new(RawScorerImpl::<'a, DotProductMetric, TVectorStorage> {
+            points_count,
+            query: DotProductMetric::preprocess(&vector).unwrap_or(vector),
+            vector_storage,
+            deleted,
+            metric: PhantomData,
+        }),
+    }
+}
+
+impl<'a, TMetric, TVectorStorage> RawScorer for RawScorerImpl<'a, TMetric, TVectorStorage>
+where
+    TMetric: Metric,
+    TVectorStorage: VectorStorage,
+{
+    fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
+        let mut size: usize = 0;
+        for point_id in points.iter().copied() {
+            if self.deleted[point_id as usize] {
+                continue;
+            }
+            let other_vector = self.vector_storage.get_vector(point_id);
+            scores[size] = ScoredPointOffset {
+                idx: point_id,
+                score: TMetric::similarity(&self.query, other_vector),
+            };
+
+            size += 1;
+            if size == scores.len() {
+                return size;
+            }
+        }
+        size
+    }
+
+    fn check_point(&self, point: PointOffsetType) -> bool {
+        point < self.points_count && !self.deleted[point as usize]
+    }
+
+    fn score_point(&self, point: PointOffsetType) -> ScoreType {
+        let other_vector = self.vector_storage.get_vector(point);
+        TMetric::similarity(&self.query, other_vector)
+    }
+
+    fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType {
+        let vector_a = self.vector_storage.get_vector(point_a);
+        let vector_b = self.vector_storage.get_vector(point_b);
+        TMetric::similarity(vector_a, vector_b)
+    }
+
+    fn peek_top_iter(
+        &self,
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset> {
+        let scores = points
+            .filter(|point_id| !self.deleted[*point_id as usize])
+            .map(|point_id| {
+                let other_vector = self.vector_storage.get_vector(point_id);
+                ScoredPointOffset {
+                    idx: point_id,
+                    score: TMetric::similarity(&self.query, other_vector),
+                }
+            });
+        peek_top_largest_iterable(scores, top)
+    }
+
+    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
+        let scores = (0..self.points_count)
+            .filter(|point_id| self.check_point(*point_id))
+            .map(|point_id| {
+                let point_id = point_id as PointOffsetType;
+                let other_vector = &self.vector_storage.get_vector(point_id);
+                ScoredPointOffset {
+                    idx: point_id,
+                    score: TMetric::similarity(&self.query, other_vector),
+                }
+            });
+        peek_top_largest_iterable(scores, top)
+    }
+}

commit 1eb4ec4885096a9da32ba3af486c84d454544785
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 6 16:08:07 2023 +0300

    fix search one day bug (#1672)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index bfa84d3f4..4b741a597 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -113,7 +113,9 @@ where
     }
 
     fn check_point(&self, point: PointOffsetType) -> bool {
-        point < self.points_count && !self.deleted[point as usize]
+        point < self.points_count
+            && (point as usize) < self.deleted.len()
+            && !self.deleted[point as usize]
     }
 
     fn score_point(&self, point: PointOffsetType) -> ScoreType {

commit 199ecc60997325019139e46979f78bda431c0a89
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Apr 7 01:42:33 2023 +0300

    additional deleted checks in raw scorers (#1674)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 4b741a597..cf31bf2d8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -95,7 +95,7 @@ where
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
         let mut size: usize = 0;
         for point_id in points.iter().copied() {
-            if self.deleted[point_id as usize] {
+            if !self.check_point(point_id) {
                 continue;
             }
             let other_vector = self.vector_storage.get_vector(point_id);
@@ -135,7 +135,7 @@ where
         top: usize,
     ) -> Vec<ScoredPointOffset> {
         let scores = points
-            .filter(|point_id| !self.deleted[*point_id as usize])
+            .filter(|point_id| self.check_point(*point_id))
             .map(|point_id| {
                 let other_vector = self.vector_storage.get_vector(point_id);
                 ScoredPointOffset {

commit 511704d88d8f915eb142e5873edbf20d249c3132
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 20 12:06:29 2023 +0200

    Add support for deleted vectors in segments (#1724)
    
    * Use resize rather than while-push loop
    
    * Add deleted flags to simple vector storage
    
    * Add deleted flag to memmap vector storage
    
    * Map BitSlice on mmap file for deleted flags
    
    * Use vector specific deletion BitSlice in RawScorer
    
    * Use BitSlice for deleted points, fix check point logic, clarify names
    
    * Extract div_ceil function to shared module
    
    * We can use unchecked set and replace because we just checked the length
    
    * Add deleted count function to vector storage
    
    * Add vector storage point deletion tests
    
    * Keep deleted state in simple vector storage with update_from, add test
    
    * Keep deleted state in memmap vector storage with update_from, add test
    
    * Simplify div_ceil
    
    * Improve deletion handling in update_from in mmap vector storage
    
    * Improve performance, use trickery to get BitSlice view over deleted mmap
    
    * Use BitSlice where possible, construct BitVec more efficiently
    
    * Incorporate vector specific delete flags in quantized raw scorer
    
    * Don't pin MmapMut, it is not required
    
    * With quantization, keep mmap deleted flags in RAM for better performance
    
    * Advice the kernel to prepare deleted flags mmap for faster future access
    
    * Simplify deleted bitslice access, add bound check, remove unused function
    
    * Fix compilation on Windows
    
    * Cleanup
    
    * Rename delete functions to delete_{point,vec} to prevent confusion
    
    * Use then_some rather than match a boolean
    
    * Lock deleted flags in memory only when quantization is available
    
    * Add docs and stabilize issue link to dev_ceil
    
    * Flush deleted mmap when closing segment
    
    This requires us to to wrap the memory map struct in an Arc and Mutex.
    Though this may look inefficient, it doesn't have a negative side effect
    on deleted flag performance, because the flags are accessed through a
    BitSlice that is separate and doesn't use locking.
    
    * Rename some point functions to vec because that makes more sense
    
    * Simplify delete flag fetching option, use deref func instead of asterisk
    
    * Do not calculate slice size manually, use size_of_val
    
    * remove test raw scorer
    
    * use deref in check
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index cf31bf2d8..97973477f 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,6 +1,6 @@
 use std::marker::PhantomData;
 
-use bitvec::vec::BitVec;
+use bitvec::prelude::BitSlice;
 
 use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
 use crate::data_types::vectors::VectorElementType;
@@ -14,13 +14,16 @@ use crate::types::{Distance, PointOffsetType, ScoreType};
 pub trait RawScorer {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
 
-    /// Return true if point satisfies current search context (exists and not deleted)
-    fn check_point(&self, point: PointOffsetType) -> bool;
+    /// Return true if vector satisfies current search context for given point (exists and not deleted)
+    fn check_vec(&self, point: PointOffsetType) -> bool;
 
     /// Score stored vector with vector under the given index
     fn score_point(&self, point: PointOffsetType) -> ScoreType;
 
-    /// Return distance between stored points selected by ids
+    /// Return distance between stored points selected by IDs
+    ///
+    /// # Panics
+    ///
     /// Panics if any id is out of range
     fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
 
@@ -37,51 +40,54 @@ pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
     pub points_count: PointOffsetType,
     pub query: Vec<VectorElementType>,
     pub vector_storage: &'a TVectorStorage,
-    pub deleted: &'a BitVec,
+    /// [`BitSlice`] defining flags for deleted points (and thus these vectors).
+    pub point_deleted: &'a BitSlice,
+    /// [`BitSlice`] defining flags for deleted vectors in this segment.
+    pub vec_deleted: &'a BitSlice,
     pub metric: PhantomData<TMetric>,
 }
 
 pub fn new_raw_scorer<'a>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a VectorStorageEnum,
-    deleted: &'a BitVec,
+    point_deleted: &'a BitSlice,
 ) -> Box<dyn RawScorer + 'a> {
     match vector_storage {
-        VectorStorageEnum::Simple(vector_storage) => {
-            raw_scorer_impl(vector, vector_storage, deleted)
-        }
-        VectorStorageEnum::Memmap(vector_storage) => {
-            raw_scorer_impl(vector, vector_storage.as_ref(), deleted)
-        }
+        VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted),
+        VectorStorageEnum::Memmap(vs) => raw_scorer_impl(vector, vs.as_ref(), point_deleted),
     }
 }
 
-fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
+pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a TVectorStorage,
-    deleted: &'a BitVec,
+    point_deleted: &'a BitSlice,
 ) -> Box<dyn RawScorer + 'a> {
     let points_count = vector_storage.total_vector_count() as PointOffsetType;
+    let vec_deleted = vector_storage.deleted_vec_bitslice();
     match vector_storage.distance() {
         Distance::Cosine => Box::new(RawScorerImpl::<'a, CosineMetric, TVectorStorage> {
             points_count,
             query: CosineMetric::preprocess(&vector).unwrap_or(vector),
             vector_storage,
-            deleted,
+            point_deleted,
+            vec_deleted,
             metric: PhantomData,
         }),
         Distance::Euclid => Box::new(RawScorerImpl::<'a, EuclidMetric, TVectorStorage> {
             points_count,
             query: EuclidMetric::preprocess(&vector).unwrap_or(vector),
             vector_storage,
-            deleted,
+            point_deleted,
+            vec_deleted,
             metric: PhantomData,
         }),
         Distance::Dot => Box::new(RawScorerImpl::<'a, DotProductMetric, TVectorStorage> {
             points_count,
             query: DotProductMetric::preprocess(&vector).unwrap_or(vector),
             vector_storage,
-            deleted,
+            point_deleted,
+            vec_deleted,
             metric: PhantomData,
         }),
     }
@@ -95,7 +101,7 @@ where
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
         let mut size: usize = 0;
         for point_id in points.iter().copied() {
-            if !self.check_point(point_id) {
+            if !self.check_vec(point_id) {
                 continue;
             }
             let other_vector = self.vector_storage.get_vector(point_id);
@@ -112,10 +118,18 @@ where
         size
     }
 
-    fn check_point(&self, point: PointOffsetType) -> bool {
+    fn check_vec(&self, point: PointOffsetType) -> bool {
         point < self.points_count
-            && (point as usize) < self.deleted.len()
-            && !self.deleted[point as usize]
+            && !self
+                .point_deleted
+                .get(point as usize)
+                .map(|x| *x)
+                .unwrap_or(false)
+            && !self
+                .vec_deleted
+                .get(point as usize)
+                .map(|x| *x)
+                .unwrap_or(false)
     }
 
     fn score_point(&self, point: PointOffsetType) -> ScoreType {
@@ -135,7 +149,7 @@ where
         top: usize,
     ) -> Vec<ScoredPointOffset> {
         let scores = points
-            .filter(|point_id| self.check_point(*point_id))
+            .filter(|point_id| self.check_vec(*point_id))
             .map(|point_id| {
                 let other_vector = self.vector_storage.get_vector(point_id);
                 ScoredPointOffset {
@@ -148,7 +162,7 @@ where
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
         let scores = (0..self.points_count)
-            .filter(|point_id| self.check_point(*point_id))
+            .filter(|point_id| self.check_vec(*point_id))
             .map(|point_id| {
                 let point_id = point_id as PointOffsetType;
                 let other_vector = &self.vector_storage.get_vector(point_id);

commit 7edf599d73cd65b47476be72009684451b7533a9
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Apr 25 14:31:04 2023 +0200

    Make query planner aware of deleted points and vectors (#1757)
    
    * Exclude deleted vectors from HNSW graph building stage
    
    * When estimating query cardinality, use available points as baseline
    
    We should not use the total number of points in a segment, because a
    portion of it may be soft deleted. Instead, we use the available
    (non-deleted) points as baseline.
    
    * Add plain search check to unfiltered HNSW search due to deleted points
    
    * Cardinality sampling on available points, ignore deleted named vectors
    
    * Estimate available vectors in query planner, now consider deleted points
    
    In the query planner, we want to know the number of available points as
    accurately as possible. This isn't possible because we only know the
    number of deletions and vectors can be deleted in two places: as point
    or as vector. These deletions may overlap. This now estimates the number
    of deleted vectors based on the segment state. It assumes that point and
    vector deletions have an overlap of 20%. This is an arbitrary
    percentage, but reflects an almost-worst scenario.
    
    This improves because the number of deleted points wasn't considered at
    all before.
    
    * Remove unused function from trait
    
    * Fix bench compilation error
    
    * Fix typo in docs
    
    * Base whether to do plain search in HNSW upon full scan threshold
    
    * Remove index threshold from HNSW config, only use full scan threshold
    
    * Simplify timer aggregator assignment in HNSW search
    
    * Remove vector storage type from cardinality function parameters
    
    * Propagate point deletes to all its vectors
    
    * Check for deleted vectors first, this makes early return possible
    
    Since point deletes are now propagated to vectors, deleted points are
    included in vector deletions. Because of that we can check if the vector
    is deleted first so we can return early and skip the point deletion
    check.
    
    For integrity we also check if the point is deleted, if the vector was
    not. That is because it may happen that point deletions are not properly
    propagated to vectors.
    
    * Don't use arbitrary vector count estimation, use vector count directly
    
    Before we had to estimate the number of vectors (for a named vector)
    because vectors could be deleted as point or vector. Point deletes are
    now propagated to vector deletes, that means we can simply use the
    deleted vector count which is now much more accurate.
    
    * When sampling IDs, check deleted vecs before deleted points
    
    * On segment consistency check, delete vectors for deleted points
    
    * Fix vector delete state not being kept when updating storage from other
    
    * Fix segment builder skipping deleted vectors breaking offsets
    
    * update segment to handle optional vectors + add test (#1781)
    
    * update segment to handle optional vectors + add test
    
    * Only update stored record when deleting if it wasn't deleted already
    
    * Reformat comment
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Fix missed vector name test, these are now marked as deleted
    
    * upd test
    
    * upd test
    
    * Update consensus test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 97973477f..f6279f961 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -120,13 +120,15 @@ where
 
     fn check_vec(&self, point: PointOffsetType) -> bool {
         point < self.points_count
+            // Deleted points propagate to vectors; check vector deletion for possible early return
             && !self
-                .point_deleted
+                .vec_deleted
                 .get(point as usize)
                 .map(|x| *x)
                 .unwrap_or(false)
+            // Additionally check point deletion for integrity if delete propagation to vector failed
             && !self
-                .vec_deleted
+                .point_deleted
                 .get(point as usize)
                 .map(|x| *x)
                 .unwrap_or(false)

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index f6279f961..291e719a1 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -15,7 +15,7 @@ pub trait RawScorer {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
 
     /// Return true if vector satisfies current search context for given point (exists and not deleted)
-    fn check_vec(&self, point: PointOffsetType) -> bool;
+    fn check_vector(&self, point: PointOffsetType) -> bool;
 
     /// Score stored vector with vector under the given index
     fn score_point(&self, point: PointOffsetType) -> ScoreType;
@@ -64,7 +64,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
     point_deleted: &'a BitSlice,
 ) -> Box<dyn RawScorer + 'a> {
     let points_count = vector_storage.total_vector_count() as PointOffsetType;
-    let vec_deleted = vector_storage.deleted_vec_bitslice();
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
     match vector_storage.distance() {
         Distance::Cosine => Box::new(RawScorerImpl::<'a, CosineMetric, TVectorStorage> {
             points_count,
@@ -101,7 +101,7 @@ where
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
         let mut size: usize = 0;
         for point_id in points.iter().copied() {
-            if !self.check_vec(point_id) {
+            if !self.check_vector(point_id) {
                 continue;
             }
             let other_vector = self.vector_storage.get_vector(point_id);
@@ -118,7 +118,7 @@ where
         size
     }
 
-    fn check_vec(&self, point: PointOffsetType) -> bool {
+    fn check_vector(&self, point: PointOffsetType) -> bool {
         point < self.points_count
             // Deleted points propagate to vectors; check vector deletion for possible early return
             && !self
@@ -151,7 +151,7 @@ where
         top: usize,
     ) -> Vec<ScoredPointOffset> {
         let scores = points
-            .filter(|point_id| self.check_vec(*point_id))
+            .filter(|point_id| self.check_vector(*point_id))
             .map(|point_id| {
                 let other_vector = self.vector_storage.get_vector(point_id);
                 ScoredPointOffset {
@@ -164,7 +164,7 @@ where
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
         let scores = (0..self.points_count)
-            .filter(|point_id| self.check_vec(*point_id))
+            .filter(|point_id| self.check_vector(*point_id))
             .map(|point_id| {
                 let point_id = point_id as PointOffsetType;
                 let other_vector = &self.vector_storage.get_vector(point_id);

commit 45ae3e048b15f10e71b5825a9fc00ee7b7676390
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue May 9 18:01:01 2023 +0200

    Dynamic mmap vector storage (#1838)
    
    * wip: chunked mmap
    
    * Fix typo
    
    * insert and get methods
    
    * dynamic bitvec
    
    * clippy
    
    * wip: vector storage
    
    * wip: fmt
    
    * wip: mmap chunks
    
    * wip: mmap problems
    
    * Share transmuted mutable reference over mmap
    
    * option to enable appendable mmap vectors
    
    * fmt
    
    * rename storage status file
    
    * update tests
    
    * fix get deleted value range
    
    * add recovery to vector storage tests
    
    * add flush to tests
    
    * fix transmute from immutable to mutable
    
    * make transmuted pointer private
    
    * remove unused unsafe functions
    
    * force WAL flush if wait=true
    
    * move wal flush into updater thread
    
    * remove flush from update api
    
    * Minimize pub visibility for specialized/dangerous functions
    
    * Allocate vector with predefined capacity
    
    * Inline format parameters
    
    * Assert we have multiple chunks while testing, test is useless otherwise
    
    * Remove unnecessary scope
    
    * Remove unnecessary dereference
    
    * Random bool has 0.5 as standard distribution, use iter::repeat_with
    
    * Replace RemovableMmap::new with Default derive
    
    * Rename len to num_flags
    
    * Use Option replace as it is convention alongside take
    
    * Add FileId enum to replace error prone manual ID rotating
    
    * Use debug_assert_eq where applicable
    
    * Refactor drop and set to replace
    
    * Change default chunk size for chunked mmap vectors to 32MB
    
    This change is made as per GitHub review, because allocating a few
    storages with 128MB would take a significant amount of time and storage.
    
    See: https://github.com/qdrant/qdrant/pull/1838#discussion_r1187215475
    
    * Replace for-loops with iterators
    
    * Draft: add typed mmap to improve code safety (#1860)
    
    * Add typed mmap
    
    * Replace some crude mmap usages with typed mmap
    
    * Use typed mmap for deleted flags
    
    * Simplify dynamic mmap flags a lot with new typed mmap, remove flags option
    
    * Reformat
    
    * Remove old mmap functions that are now unused
    
    * Reimplement mmap locking for mmap_vectors
    
    * Add MmapBitSlice tests
    
    * Replace MmapChunk with new typed mmap
    
    * Update docs
    
    * Clean-up
    
    * Disable alignment assertions on Windows for now
    
    * Rename mmap lock to mlock to prevent confusion with lockable types
    
    * one more small test
    
    * Some review fixes
    
    * Add aliasing note
    
    * Add basic error handling in typed mmap constructors
    
    * Use typed mmap error handling throughout project
    
    * Move mmap type module to common
    
    * Fix transmute functions being unsound
    
    See https://github.com/qdrant/qdrant/pull/1860#discussion_r1188593854
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 291e719a1..84d3f2ed8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -55,6 +55,9 @@ pub fn new_raw_scorer<'a>(
     match vector_storage {
         VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted),
         VectorStorageEnum::Memmap(vs) => raw_scorer_impl(vector, vs.as_ref(), point_deleted),
+        VectorStorageEnum::AppendableMemmap(vs) => {
+            raw_scorer_impl(vector, vs.as_ref(), point_deleted)
+        }
     }
 }
 

commit 3867bf85c75c290128a83477c76415093c8c4dac
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jun 12 19:53:23 2023 +0200

    WIP: Async uring vector storage (#2024)
    
    * async raw scorer
    
    * fmt
    
    * Disable `async_raw_scorer` on non-Linux platforms
    
    * Refactor `async_raw_scorer.rs`
    
    * Conditionally enable `async_raw_scorer` in `segment` crate
    
    * Add `async_scorer` config parameter to the config...
    
    ...and enable `async_raw_scorer`, if config parameter is set to `true`
    
    * fixup! Add `async_scorer` config parameter to the config...
    
    Fix tests
    
    * Add basic `async_raw_scorer` test
    
    * Extend `async_raw_scorer` tests to be more extensive
    
    * Async uring vector storage io uring (#2041)
    
    * replace tokio-uring with just low level io-uring
    
    * fnt
    
    * minor fixes
    
    * add sync
    
    * wip: try to use less submissions
    
    * fmt
    
    * fix uring size
    
    * larger buffer
    
    * check for overflow
    
    * submit with re-try
    
    * mmap owns uring context
    
    * large disk parallelism
    
    * rollbacK: large disk parallelism
    
    * fix windows build
    
    * explicitly panic on uring fail
    
    * fix windows build again
    
    * use async scorer in the quantization re-scoring
    
    * refactor
    
    * rename UringReader
    
    * refactor buffers
    
    * fix for windows
    
    * error checking
    
    * fix handing
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 84d3f2ed8..099b2c721 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,4 +1,5 @@
 use std::marker::PhantomData;
+use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 
@@ -14,6 +15,20 @@ use crate::types::{Distance, PointOffsetType, ScoreType};
 pub trait RawScorer {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
 
+    /// Score points without excluding deleted and filtered points
+    ///
+    /// # Arguments
+    ///
+    /// * `points` - points to score
+    ///
+    /// # Returns
+    ///
+    /// Vector of scored points
+    fn score_points_unfiltered(
+        &self,
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+    ) -> Vec<ScoredPointOffset>;
+
     /// Return true if vector satisfies current search context for given point (exists and not deleted)
     fn check_vector(&self, point: PointOffsetType) -> bool;
 
@@ -47,6 +62,16 @@ pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
     pub metric: PhantomData<TMetric>,
 }
 
+static ASYNC_SCORER: AtomicBool = AtomicBool::new(false);
+
+pub fn set_async_scorer(async_scorer: bool) {
+    ASYNC_SCORER.store(async_scorer, Ordering::Relaxed);
+}
+
+pub fn get_async_scorer() -> bool {
+    ASYNC_SCORER.load(Ordering::Relaxed)
+}
+
 pub fn new_raw_scorer<'a>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a VectorStorageEnum,
@@ -54,7 +79,22 @@ pub fn new_raw_scorer<'a>(
 ) -> Box<dyn RawScorer + 'a> {
     match vector_storage {
         VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted),
-        VectorStorageEnum::Memmap(vs) => raw_scorer_impl(vector, vs.as_ref(), point_deleted),
+
+        VectorStorageEnum::Memmap(vs) => {
+            if get_async_scorer() {
+                #[cfg(target_os = "linux")]
+                match super::async_raw_scorer::new(vector.clone(), vs, point_deleted) {
+                    Ok(raw_scorer) => return raw_scorer,
+                    Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
+                }
+
+                #[cfg(not(target_os = "linux"))]
+                log::warn!("async raw scorer is only supported on Linux");
+            }
+
+            raw_scorer_impl(vector, vs.as_ref(), point_deleted)
+        }
+
         VectorStorageEnum::AppendableMemmap(vs) => {
             raw_scorer_impl(vector, vs.as_ref(), point_deleted)
         }
@@ -121,6 +161,21 @@ where
         size
     }
 
+    fn score_points_unfiltered(
+        &self,
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+    ) -> Vec<ScoredPointOffset> {
+        let mut scores = vec![];
+        for point_id in points {
+            let other_vector = self.vector_storage.get_vector(point_id);
+            scores.push(ScoredPointOffset {
+                idx: point_id,
+                score: TMetric::similarity(&self.query, other_vector),
+            });
+        }
+        scores
+    }
+
     fn check_vector(&self, point: PointOffsetType) -> bool {
         point < self.points_count
             // Deleted points propagate to vectors; check vector deletion for possible early return

commit 9e04139967217a8a8b78a1d1c63b48382f3ce8c3
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Jun 13 15:44:57 2023 +0200

    Assume points with no mapping/delete flag are deleted (#2061)
    
    * In scorers, assume a point is deleted if it has no deleted flag
    
    * Cleanup

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 099b2c721..a6a5c68d2 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -183,13 +183,15 @@ where
                 .vec_deleted
                 .get(point as usize)
                 .map(|x| *x)
+                // Default to not deleted if our deleted flags failed grow
                 .unwrap_or(false)
             // Additionally check point deletion for integrity if delete propagation to vector failed
             && !self
                 .point_deleted
                 .get(point as usize)
                 .map(|x| *x)
-                .unwrap_or(false)
+                // Default to deleted if the point mapping was removed from the ID tracker
+                .unwrap_or(true)
     }
 
     fn score_point(&self, point: PointOffsetType) -> ScoreType {

commit 76f7d2fc68b124d3fe788900fd022b8daee0c60e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 24 12:45:33 2023 +0200

    Search timeout (#2293)
    
    * pass atomic bool from local shard to raw scorer
    
    * pass atomic bool from local shard to raw scorer
    
    * is_stopped in async scorer
    
    * fmt
    
    * is_stopped in quantized scorer
    
    * terminating scorer if stopped
    
    * enable timeout in local_shard
    
    * allow timeout configuration
    
    * use tokio spawn to ensure timeout handling if request is dropped
    
    * Revert "use tokio spawn to ensure timeout handling if request is dropped"
    
    This reverts commit 1068cf48d481b8856da41869b71b1f9a361f7e2d.
    
    * use stopping guard instead of task
    
    * report error if search request is stopped
    
    * fmt
    
    * refactor transient error handelling

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index a6a5c68d2..972086be0 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -60,6 +60,9 @@ pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
     /// [`BitSlice`] defining flags for deleted vectors in this segment.
     pub vec_deleted: &'a BitSlice,
     pub metric: PhantomData<TMetric>,
+    /// This flag indicates that the search process is stopped externally,
+    /// the search result is no longer needed and the search process should be stopped as soon as possible.
+    pub is_stopped: &'a AtomicBool,
 }
 
 static ASYNC_SCORER: AtomicBool = AtomicBool::new(false);
@@ -72,18 +75,19 @@ pub fn get_async_scorer() -> bool {
     ASYNC_SCORER.load(Ordering::Relaxed)
 }
 
-pub fn new_raw_scorer<'a>(
+pub fn new_stoppable_raw_scorer<'a>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
     match vector_storage {
-        VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted),
+        VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted, is_stopped),
 
         VectorStorageEnum::Memmap(vs) => {
             if get_async_scorer() {
                 #[cfg(target_os = "linux")]
-                match super::async_raw_scorer::new(vector.clone(), vs, point_deleted) {
+                match super::async_raw_scorer::new(vector.clone(), vs, point_deleted, is_stopped) {
                     Ok(raw_scorer) => return raw_scorer,
                     Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
                 }
@@ -92,19 +96,30 @@ pub fn new_raw_scorer<'a>(
                 log::warn!("async raw scorer is only supported on Linux");
             }
 
-            raw_scorer_impl(vector, vs.as_ref(), point_deleted)
+            raw_scorer_impl(vector, vs.as_ref(), point_deleted, is_stopped)
         }
 
         VectorStorageEnum::AppendableMemmap(vs) => {
-            raw_scorer_impl(vector, vs.as_ref(), point_deleted)
+            raw_scorer_impl(vector, vs.as_ref(), point_deleted, is_stopped)
         }
     }
 }
 
+pub static DEFAULT_STOPPED: AtomicBool = AtomicBool::new(false);
+
+pub fn new_raw_scorer<'a>(
+    vector: Vec<VectorElementType>,
+    vector_storage: &'a VectorStorageEnum,
+    point_deleted: &'a BitSlice,
+) -> Box<dyn RawScorer + 'a> {
+    new_stoppable_raw_scorer(vector, vector_storage, point_deleted, &DEFAULT_STOPPED)
+}
+
 pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
     let points_count = vector_storage.total_vector_count() as PointOffsetType;
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -116,6 +131,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
             point_deleted,
             vec_deleted,
             metric: PhantomData,
+            is_stopped,
         }),
         Distance::Euclid => Box::new(RawScorerImpl::<'a, EuclidMetric, TVectorStorage> {
             points_count,
@@ -124,6 +140,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
             point_deleted,
             vec_deleted,
             metric: PhantomData,
+            is_stopped,
         }),
         Distance::Dot => Box::new(RawScorerImpl::<'a, DotProductMetric, TVectorStorage> {
             points_count,
@@ -132,6 +149,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
             point_deleted,
             vec_deleted,
             metric: PhantomData,
+            is_stopped,
         }),
     }
 }
@@ -142,6 +160,9 @@ where
     TVectorStorage: VectorStorage,
 {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
+        if self.is_stopped.load(Ordering::Relaxed) {
+            return 0;
+        }
         let mut size: usize = 0;
         for point_id in points.iter().copied() {
             if !self.check_vector(point_id) {
@@ -165,6 +186,9 @@ where
         &self,
         points: &mut dyn Iterator<Item = PointOffsetType>,
     ) -> Vec<ScoredPointOffset> {
+        if self.is_stopped.load(Ordering::Relaxed) {
+            return vec![];
+        }
         let mut scores = vec![];
         for point_id in points {
             let other_vector = self.vector_storage.get_vector(point_id);
@@ -211,6 +235,7 @@ where
         top: usize,
     ) -> Vec<ScoredPointOffset> {
         let scores = points
+            .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
             .filter(|point_id| self.check_vector(*point_id))
             .map(|point_id| {
                 let other_vector = self.vector_storage.get_vector(point_id);
@@ -224,6 +249,7 @@ where
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
         let scores = (0..self.points_count)
+            .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
             .filter(|point_id| self.check_vector(*point_id))
             .map(|point_id| {
                 let point_id = point_id as PointOffsetType;

commit 3839e75081fd22f607b83df70b580c3af8d6cdde
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 2 12:46:26 2023 +0200

    do not initialize io-uring object if async scorer is not enabled (#2372)
    
    * do not initialize io-uring object if async scorer is not enabled
    
    * explicilty example async scorer in test
    
    * fmt

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 972086be0..32eafd1f3 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -9,6 +9,7 @@ use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::{Distance, PointOffsetType, ScoreType};
+use crate::vector_storage;
 
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score
@@ -65,16 +66,6 @@ pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
     pub is_stopped: &'a AtomicBool,
 }
 
-static ASYNC_SCORER: AtomicBool = AtomicBool::new(false);
-
-pub fn set_async_scorer(async_scorer: bool) {
-    ASYNC_SCORER.store(async_scorer, Ordering::Relaxed);
-}
-
-pub fn get_async_scorer() -> bool {
-    ASYNC_SCORER.load(Ordering::Relaxed)
-}
-
 pub fn new_stoppable_raw_scorer<'a>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a VectorStorageEnum,
@@ -85,7 +76,7 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted, is_stopped),
 
         VectorStorageEnum::Memmap(vs) => {
-            if get_async_scorer() {
+            if vector_storage::common::get_async_scorer() {
                 #[cfg(target_os = "linux")]
                 match super::async_raw_scorer::new(vector.clone(), vs, point_deleted, is_stopped) {
                     Ok(raw_scorer) => return raw_scorer,

commit e6b25c46af23a113cfa3e5ed4d1b02e91edc7b73
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 2 19:12:51 2023 +0200

    create async reader based on vector storage state (#2376)
    
    * create async reader based on vector storage state
    
    * do not use statics in tests

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 32eafd1f3..c4d585154 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -9,7 +9,6 @@ use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::{Distance, PointOffsetType, ScoreType};
-use crate::vector_storage;
 
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score
@@ -76,7 +75,7 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted, is_stopped),
 
         VectorStorageEnum::Memmap(vs) => {
-            if vector_storage::common::get_async_scorer() {
+            if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
                 match super::async_raw_scorer::new(vector.clone(), vs, point_deleted, is_stopped) {
                     Ok(raw_scorer) => return raw_scorer,

commit 47274b2e634244b3af6bac131eee2dc885f112fe
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 15 11:57:20 2023 +0200

    Query scorer refactoring (#2430)
    
    * refactor query_scorer for simple raw_scorer impl
    
    * fmt
    
    * refactor query_scorer for simple raw_scorer impl
    
    * refactor query_scorer for simple raw_scorer impl
    
    * decouple scorer and storage, move storage into query scorer
    
    * eliminate quantized raw scorer
    
    * Update lib/api/src/grpc/google.protobuf.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index c4d585154..45e30f96f 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,15 +1,27 @@
-use std::marker::PhantomData;
 use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 
 use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
 use crate::data_types::vectors::VectorElementType;
-use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::{Distance, PointOffsetType, ScoreType};
+use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
+use crate::vector_storage::query_scorer::QueryScorer;
 
+/// RawScorer            QueryScorer        Metric
+/// ┌────────────────┐   ┌──────────────┐   ┌───────────────────┐
+/// │                │   │              │   │  - Cosine         │
+/// │       ┌─────┐  │   │     ┌─────┐  │   │  - Dot            │
+/// │       │     │◄─┼───┤     │     │◄─┼───┤  - Euclidean      │
+/// │       └─────┘  │   │     └─────┘  │   │                   │
+/// │                │   │              │   │                   │
+/// └────────────────┘   └──────────────┘   └───────────────────┘
+/// - Deletions          - Scoring logic    - Vector Distance
+/// - Stopping           - Query holding
+/// - Access patterns    - Complex Queries
+///
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score
 pub trait RawScorer {
@@ -51,15 +63,15 @@ pub trait RawScorer {
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
 }
 
-pub struct RawScorerImpl<'a, TMetric: Metric, TVectorStorage: VectorStorage> {
-    pub points_count: PointOffsetType,
-    pub query: Vec<VectorElementType>,
-    pub vector_storage: &'a TVectorStorage,
+pub struct RawScorerImpl<'a, TQueryScorer: QueryScorer> {
+    pub query_scorer: TQueryScorer,
+    /// Point deleted flags should be explicitly present as `false`
+    /// for each existing point in the segment.
+    /// If there are no flags for some points, they are considered deleted.
     /// [`BitSlice`] defining flags for deleted points (and thus these vectors).
     pub point_deleted: &'a BitSlice,
     /// [`BitSlice`] defining flags for deleted vectors in this segment.
     pub vec_deleted: &'a BitSlice,
-    pub metric: PhantomData<TMetric>,
     /// This flag indicates that the search process is stopped externally,
     /// the search result is no longer needed and the search process should be stopped as soon as possible.
     pub is_stopped: &'a AtomicBool,
@@ -111,43 +123,46 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
-    let points_count = vector_storage.total_vector_count() as PointOffsetType;
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match vector_storage.distance() {
-        Distance::Cosine => Box::new(RawScorerImpl::<'a, CosineMetric, TVectorStorage> {
-            points_count,
-            query: CosineMetric::preprocess(&vector).unwrap_or(vector),
-            vector_storage,
+        Distance::Cosine => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<CosineMetric, TVectorStorage>::new(vector, vector_storage),
             point_deleted,
             vec_deleted,
-            metric: PhantomData,
             is_stopped,
-        }),
-        Distance::Euclid => Box::new(RawScorerImpl::<'a, EuclidMetric, TVectorStorage> {
-            points_count,
-            query: EuclidMetric::preprocess(&vector).unwrap_or(vector),
-            vector_storage,
+        ),
+        Distance::Euclid => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<EuclidMetric, TVectorStorage>::new(vector, vector_storage),
             point_deleted,
             vec_deleted,
-            metric: PhantomData,
             is_stopped,
-        }),
-        Distance::Dot => Box::new(RawScorerImpl::<'a, DotProductMetric, TVectorStorage> {
-            points_count,
-            query: DotProductMetric::preprocess(&vector).unwrap_or(vector),
-            vector_storage,
+        ),
+        Distance::Dot => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<DotProductMetric, TVectorStorage>::new(vector, vector_storage),
             point_deleted,
             vec_deleted,
-            metric: PhantomData,
             is_stopped,
-        }),
+        ),
     }
 }
 
-impl<'a, TMetric, TVectorStorage> RawScorer for RawScorerImpl<'a, TMetric, TVectorStorage>
+pub fn raw_scorer_from_query_scorer<'a, TQueryScorer: QueryScorer + 'a>(
+    query_scorer: TQueryScorer,
+    point_deleted: &'a BitSlice,
+    vec_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> Box<dyn RawScorer + 'a> {
+    Box::new(RawScorerImpl::<TQueryScorer> {
+        query_scorer,
+        point_deleted,
+        vec_deleted,
+        is_stopped,
+    })
+}
+
+impl<'a, TQueryScorer> RawScorer for RawScorerImpl<'a, TQueryScorer>
 where
-    TMetric: Metric,
-    TVectorStorage: VectorStorage,
+    TQueryScorer: QueryScorer,
 {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
         if self.is_stopped.load(Ordering::Relaxed) {
@@ -158,10 +173,9 @@ where
             if !self.check_vector(point_id) {
                 continue;
             }
-            let other_vector = self.vector_storage.get_vector(point_id);
             scores[size] = ScoredPointOffset {
                 idx: point_id,
-                score: TMetric::similarity(&self.query, other_vector),
+                score: self.query_scorer.score_stored(point_id),
             };
 
             size += 1;
@@ -181,19 +195,17 @@ where
         }
         let mut scores = vec![];
         for point_id in points {
-            let other_vector = self.vector_storage.get_vector(point_id);
             scores.push(ScoredPointOffset {
                 idx: point_id,
-                score: TMetric::similarity(&self.query, other_vector),
+                score: self.query_scorer.score_stored(point_id),
             });
         }
         scores
     }
 
     fn check_vector(&self, point: PointOffsetType) -> bool {
-        point < self.points_count
-            // Deleted points propagate to vectors; check vector deletion for possible early return
-            && !self
+        // Deleted points propagate to vectors; check vector deletion for possible early return
+        !self
                 .vec_deleted
                 .get(point as usize)
                 .map(|x| *x)
@@ -209,14 +221,11 @@ where
     }
 
     fn score_point(&self, point: PointOffsetType) -> ScoreType {
-        let other_vector = self.vector_storage.get_vector(point);
-        TMetric::similarity(&self.query, other_vector)
+        self.query_scorer.score_stored(point)
     }
 
     fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType {
-        let vector_a = self.vector_storage.get_vector(point_a);
-        let vector_b = self.vector_storage.get_vector(point_b);
-        TMetric::similarity(vector_a, vector_b)
+        self.query_scorer.score_internal(point_a, point_b)
     }
 
     fn peek_top_iter(
@@ -227,26 +236,22 @@ where
         let scores = points
             .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
             .filter(|point_id| self.check_vector(*point_id))
-            .map(|point_id| {
-                let other_vector = self.vector_storage.get_vector(point_id);
-                ScoredPointOffset {
-                    idx: point_id,
-                    score: TMetric::similarity(&self.query, other_vector),
-                }
+            .map(|point_id| ScoredPointOffset {
+                idx: point_id,
+                score: self.query_scorer.score_stored(point_id),
             });
         peek_top_largest_iterable(scores, top)
     }
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
-        let scores = (0..self.points_count)
+        let scores = (0..self.point_deleted.len() as PointOffsetType)
             .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
             .filter(|point_id| self.check_vector(*point_id))
             .map(|point_id| {
                 let point_id = point_id as PointOffsetType;
-                let other_vector = &self.vector_storage.get_vector(point_id);
                 ScoredPointOffset {
                     idx: point_id,
-                    score: TMetric::similarity(&self.query, other_vector),
+                    score: self.query_scorer.score_stored(point_id),
                 }
             });
         peek_top_largest_iterable(scores, top)

commit c8bdec7b0616c47e1c3057b3f8ef8435833dc74f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Sep 5 09:26:24 2023 -0300

    Refactor batch search to allow different scorers (#2529)
    
    * add enum for vector query on segment search
    
    * rename newly introduced types
    
    * fix: handle QueryVector on async scorer
    
    * handle QueryVector in QuantizedVectors impl
    
    * fix async scorer test after refactor
    
    * rebase + refactor on queue_proxy_shard.rs
    
    * constrain refactor propagation to segment_searcher
    
    * fmt
    
    * fix after rebase

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 45e30f96f..d201527b7 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -3,7 +3,7 @@ use std::sync::atomic::{AtomicBool, Ordering};
 use bitvec::prelude::BitSlice;
 
 use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
-use crate::data_types::vectors::VectorElementType;
+use crate::data_types::vectors::{QueryVector, VectorElementType};
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::{Distance, PointOffsetType, ScoreType};
@@ -78,7 +78,7 @@ pub struct RawScorerImpl<'a, TQueryScorer: QueryScorer> {
 }
 
 pub fn new_stoppable_raw_scorer<'a>(
-    vector: Vec<VectorElementType>,
+    vector: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
@@ -89,9 +89,19 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::Memmap(vs) => {
             if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
-                match super::async_raw_scorer::new(vector.clone(), vs, point_deleted, is_stopped) {
-                    Ok(raw_scorer) => return raw_scorer,
-                    Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
+                {
+                    let scorer_result = match vector {
+                        QueryVector::Nearest(ref vector) => super::async_raw_scorer::new(
+                            vector.clone(),
+                            vs,
+                            point_deleted,
+                            is_stopped,
+                        ),
+                    };
+                    match scorer_result {
+                        Ok(raw_scorer) => return raw_scorer,
+                        Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
+                    };
                 }
 
                 #[cfg(not(target_os = "linux"))]
@@ -110,7 +120,7 @@ pub fn new_stoppable_raw_scorer<'a>(
 pub static DEFAULT_STOPPED: AtomicBool = AtomicBool::new(false);
 
 pub fn new_raw_scorer<'a>(
-    vector: Vec<VectorElementType>,
+    vector: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
 ) -> Box<dyn RawScorer + 'a> {
@@ -118,6 +128,19 @@ pub fn new_raw_scorer<'a>(
 }
 
 pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
+    vector: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> Box<dyn RawScorer + 'a> {
+    match vector {
+        QueryVector::Nearest(vector) => {
+            new_metric_scorer(vector.to_vec(), vector_storage, point_deleted, is_stopped)
+        }
+    }
+}
+
+pub fn new_metric_scorer<'a, TVectorStorage: VectorStorage>(
     vector: Vec<VectorElementType>,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,

commit 67c2a414d67318ff0528e3374e41f96b7d6874fb
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Sep 14 12:37:14 2023 -0300

    Recommendation scorer internals (#2538)
    
    * use enum_dispatch on vector_index_base.rs
    
    * add reco_query_scorer.rs
    
    * smol refactor on reco_query_scorer
    
    * add PositiveNegative variant
    
    * recommend query scorer internals
    
    - missing tests
    
    * add test for RecoQuery
    
    * Revert "use enum_dispatch on vector_index_base.rs"
    
    This reverts commit 016e831d00d67ef01e64b4f7a76854e555cd9697.
    
    * remove enum_dispatch usage
    
    * disable score_internal implementation for QuantizedRecoQueryScorer
    
    * refactor test
    
    * refactor with latest preprocess changes
    
    * add reco scorer for async scorer
    
    * add iter_all() helper for RecoQuery
    
    * rename PositiveNegative -> Recommend,
    change variable names,
    refactor quantized query scorer
    
    * refactor new raw scorer
    
    * add tests for comparison raw against async and u8 quant
    
    * smol test improvements
    
    * fix error after rebase
    
    * fmt
    
    * finish score equivalency test, remove dbgs
    
    * make scorer builder for quantized storage
    
    * move query preprocessing to `new()` of quantized query scorers
    
    * self review
    
    * review suggestions
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d201527b7..f02d10e79 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -2,8 +2,10 @@ use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 
+use super::query_scorer::reco_query_scorer::RecoQueryScorer;
 use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
-use crate::data_types::vectors::{QueryVector, VectorElementType};
+use crate::data_types::vectors::QueryVector;
+use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::{Distance, PointOffsetType, ScoreType};
@@ -78,26 +80,20 @@ pub struct RawScorerImpl<'a, TQueryScorer: QueryScorer> {
 }
 
 pub fn new_stoppable_raw_scorer<'a>(
-    vector: QueryVector,
+    query: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
     match vector_storage {
-        VectorStorageEnum::Simple(vs) => raw_scorer_impl(vector, vs, point_deleted, is_stopped),
+        VectorStorageEnum::Simple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
 
         VectorStorageEnum::Memmap(vs) => {
             if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
                 {
-                    let scorer_result = match vector {
-                        QueryVector::Nearest(ref vector) => super::async_raw_scorer::new(
-                            vector.clone(),
-                            vs,
-                            point_deleted,
-                            is_stopped,
-                        ),
-                    };
+                    let scorer_result =
+                        super::async_raw_scorer::new(query.clone(), vs, point_deleted, is_stopped);
                     match scorer_result {
                         Ok(raw_scorer) => return raw_scorer,
                         Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
@@ -108,11 +104,11 @@ pub fn new_stoppable_raw_scorer<'a>(
                 log::warn!("async raw scorer is only supported on Linux");
             }
 
-            raw_scorer_impl(vector, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
 
         VectorStorageEnum::AppendableMemmap(vs) => {
-            raw_scorer_impl(vector, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
     }
 }
@@ -128,40 +124,49 @@ pub fn new_raw_scorer<'a>(
 }
 
 pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
-    vector: QueryVector,
+    query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
-    match vector {
-        QueryVector::Nearest(vector) => {
-            new_metric_scorer(vector.to_vec(), vector_storage, point_deleted, is_stopped)
-        }
+    match vector_storage.distance() {
+        Distance::Cosine => new_scorer_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_scorer_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_scorer_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
     }
 }
 
-pub fn new_metric_scorer<'a, TVectorStorage: VectorStorage>(
-    vector: Vec<VectorElementType>,
+fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: VectorStorage>(
+    query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
 ) -> Box<dyn RawScorer + 'a> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
-    match vector_storage.distance() {
-        Distance::Cosine => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<CosineMetric, TVectorStorage>::new(vector, vector_storage),
-            point_deleted,
-            vec_deleted,
-            is_stopped,
-        ),
-        Distance::Euclid => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<EuclidMetric, TVectorStorage>::new(vector, vector_storage),
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<TMetric, TVectorStorage>::new(vector, vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,
         ),
-        Distance::Dot => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<DotProductMetric, TVectorStorage>::new(vector, vector_storage),
+        QueryVector::Recommend(reco_query) => raw_scorer_from_query_scorer(
+            RecoQueryScorer::<TMetric, TVectorStorage>::new(reco_query, vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index f02d10e79..8ff12a331 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,14 +1,15 @@
 use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
+use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 
 use super::query_scorer::reco_query_scorer::RecoQueryScorer;
-use super::{ScoredPointOffset, VectorStorage, VectorStorageEnum};
+use super::{VectorStorage, VectorStorageEnum};
 use crate::data_types::vectors::QueryVector;
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
-use crate::types::{Distance, PointOffsetType, ScoreType};
+use crate::types::Distance;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
 

commit 3a1a4343273e9883c33c620d77e926e24ec3d2da
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Oct 13 22:30:49 2023 +0200

    dense vector storage (#2817)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 8ff12a331..6d9ceeb02 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -4,7 +4,7 @@ use bitvec::prelude::BitSlice;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 
 use super::query_scorer::reco_query_scorer::RecoQueryScorer;
-use super::{VectorStorage, VectorStorageEnum};
+use super::{DenseVectorStorage, VectorStorageEnum};
 use crate::data_types::vectors::QueryVector;
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
@@ -124,7 +124,7 @@ pub fn new_raw_scorer<'a>(
     new_stoppable_raw_scorer(vector, vector_storage, point_deleted, &DEFAULT_STOPPED)
 }
 
-pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
+pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
@@ -152,7 +152,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: VectorStorage>(
     }
 }
 
-fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: VectorStorage>(
+fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorStorage>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,

commit ebe0a01685253fbb3ea5f817c79f5e0f917a816d
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Sun Oct 15 18:52:02 2023 -0300

    Add `QueryVector::Discovery` (#2809)
    
    * - add DiscoveryQuery to QueryVector
    - merge reco_query_scorer and discovery_query_scorer into custom_query_scorer
    - reuse reco_query_scorer equivalency tests for discovery scorer
    
    * self review
    
    * empty commit

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 6d9ceeb02..8c104704a 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -3,7 +3,7 @@ use std::sync::atomic::{AtomicBool, Ordering};
 use bitvec::prelude::BitSlice;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 
-use super::query_scorer::reco_query_scorer::RecoQueryScorer;
+use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::{DenseVectorStorage, VectorStorageEnum};
 use crate::data_types::vectors::QueryVector;
 use crate::spaces::metric::Metric;
@@ -161,13 +161,19 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<TMetric, TVectorStorage>::new(vector, vector_storage),
+            MetricQueryScorer::<TMetric, _>::new(vector, vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => raw_scorer_from_query_scorer(
-            RecoQueryScorer::<TMetric, TVectorStorage>::new(reco_query, vector_storage),
+            CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Discovery(discovery_query) => raw_scorer_from_query_scorer(
+            CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,

commit 7801661d79665281643a81a72f468afc383be9e7
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Oct 19 15:29:37 2023 -0300

    Add discovery context scorer (#2820)
    
    * add discovery context query
    
    * add tests
    
    * small optimization for loss_by
    
    * fix async raw scorer
    
    * ditch micro-optimization
    
    * remove sigmoid,  rename `iter_all` -> `flat_iter`
    
    * fix tests, add more cases

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 8c104704a..f63ea11e9 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -178,6 +178,12 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             vec_deleted,
             is_stopped,
         ),
+        QueryVector::Context(discovery_context_query) => raw_scorer_from_query_scorer(
+            CustomQueryScorer::<TMetric, _, _>::new(discovery_context_query, vector_storage),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
     }
 }
 

commit 027779dd55a1d3512657afb1c63cdc3709e116a1
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Oct 20 17:07:02 2023 +0200

    Sparse vector in QueryVector (#2854)
    
    * Sparse vector in QueryVector
    
    * remove experimental sparse raw scorer
    
    * code review
    
    * code review

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index f63ea11e9..a377bf7fd 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -161,7 +161,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<TMetric, _>::new(vector, vector_storage),
+            MetricQueryScorer::<TMetric, _>::new(vector.into(), vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,

commit 847422fdb166f438715ef64b6199c480e4563771
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 26 15:40:28 2023 +0200

    propagate vector type into QueryVector (#2878)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index a377bf7fd..dd20be89a 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -3,9 +3,12 @@ use std::sync::atomic::{AtomicBool, Ordering};
 use bitvec::prelude::BitSlice;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 
+use super::query::context_query::ContextQuery;
+use super::query::discovery_query::DiscoveryQuery;
+use super::query::reco_query::RecoQuery;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::{DenseVectorStorage, VectorStorageEnum};
-use crate::data_types::vectors::QueryVector;
+use crate::data_types::vectors::{QueryVector, VectorType};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
@@ -166,24 +169,33 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => raw_scorer_from_query_scorer(
-            CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
-            point_deleted,
-            vec_deleted,
-            is_stopped,
-        ),
-        QueryVector::Discovery(discovery_query) => raw_scorer_from_query_scorer(
-            CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
-            point_deleted,
-            vec_deleted,
-            is_stopped,
-        ),
-        QueryVector::Context(discovery_context_query) => raw_scorer_from_query_scorer(
-            CustomQueryScorer::<TMetric, _, _>::new(discovery_context_query, vector_storage),
-            point_deleted,
-            vec_deleted,
-            is_stopped,
-        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<VectorType> = reco_query.into();
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.into();
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<VectorType> = context_query.into();
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
     }
 }
 

commit cc69ec7fec5b8ec3d1b2cf4f63fdac33bf1c50da
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Oct 30 11:27:36 2023 +0100

    Simple sparse vector storage (#2806)
    
    * Simple sparse vector storage
    
    * better todo

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index dd20be89a..d65bbfc5e 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -114,6 +114,7 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::AppendableMemmap(vs) => {
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::SparseSimple(_vs) => panic!("sparse vector raw scorer"), // TODO(sparse)
     }
 }
 

commit 7134ba7dc25ad7a2dccbbf9c3bd4f3072e46f6c5
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Oct 31 23:44:20 2023 +0100

    raw scorer with operation result (#2897)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d65bbfc5e..dc852422a 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -8,6 +8,7 @@ use super::query::discovery_query::DiscoveryQuery;
 use super::query::reco_query::RecoQuery;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::{DenseVectorStorage, VectorStorageEnum};
+use crate::common::operation_error::OperationResult;
 use crate::data_types::vectors::{QueryVector, VectorType};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
@@ -88,7 +89,7 @@ pub fn new_stoppable_raw_scorer<'a>(
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
-) -> Box<dyn RawScorer + 'a> {
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage {
         VectorStorageEnum::Simple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
 
@@ -99,7 +100,7 @@ pub fn new_stoppable_raw_scorer<'a>(
                     let scorer_result =
                         super::async_raw_scorer::new(query.clone(), vs, point_deleted, is_stopped);
                     match scorer_result {
-                        Ok(raw_scorer) => return raw_scorer,
+                        Ok(raw_scorer) => return Ok(raw_scorer),
                         Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
                     };
                 }
@@ -124,7 +125,7 @@ pub fn new_raw_scorer<'a>(
     vector: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
-) -> Box<dyn RawScorer + 'a> {
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
     new_stoppable_raw_scorer(vector, vector_storage, point_deleted, &DEFAULT_STOPPED)
 }
 
@@ -133,7 +134,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage>(
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
-) -> Box<dyn RawScorer + 'a> {
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_scorer_with_metric::<CosineMetric, _>(
             query,
@@ -161,7 +162,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
-) -> Box<dyn RawScorer + 'a> {
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
@@ -205,13 +206,13 @@ pub fn raw_scorer_from_query_scorer<'a, TQueryScorer: QueryScorer + 'a>(
     point_deleted: &'a BitSlice,
     vec_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
-) -> Box<dyn RawScorer + 'a> {
-    Box::new(RawScorerImpl::<TQueryScorer> {
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    Ok(Box::new(RawScorerImpl::<TQueryScorer> {
         query_scorer,
         point_deleted,
         vec_deleted,
         is_stopped,
-    })
+    }))
 }
 
 impl<'a, TQueryScorer> RawScorer for RawScorerImpl<'a, TQueryScorer>

commit 28da79223e64394ac1472461828cd0cd9bb23526
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 1 11:30:08 2023 -0400

    Add `DiscoveryRequest` and preprocessing (#2867)
    
    * add `DiscoverRequest` and batch preprocessing logic
    
    * Add description for DiscoverRequest, use serde(default)  on offset
    
    * review fixes

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index dc852422a..6cde8f7d2 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -6,6 +6,7 @@ use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 use super::query::context_query::ContextQuery;
 use super::query::discovery_query::DiscoveryQuery;
 use super::query::reco_query::RecoQuery;
+use super::query::TransformInto;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::{DenseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::OperationResult;
@@ -172,7 +173,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<VectorType> = reco_query.into();
+            let reco_query: RecoQuery<VectorType> = reco_query.transform_into();
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
                 point_deleted,
@@ -181,7 +182,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.into();
+            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.transform_into();
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
                 point_deleted,
@@ -190,7 +191,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<VectorType> = context_query.into();
+            let context_query: ContextQuery<VectorType> = context_query.transform_into();
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
                 point_deleted,

commit cbf1811eaa3e2e0de68c07fb2cd484a16faf8b3d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Nov 2 14:59:18 2023 +0100

    Raw scorer for sparse vectors (#2915)
    
    * Raw scorer for sparse vectors
    
    * sparse vector storage trait
    
    * use get sparse vector fn
    
    * remove dedicated types
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 6cde8f7d2..f105bbff7 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -2,14 +2,15 @@ use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
+use sparse::common::sparse_vector::SparseVector;
 
 use super::query::context_query::ContextQuery;
 use super::query::discovery_query::DiscoveryQuery;
 use super::query::reco_query::RecoQuery;
 use super::query::TransformInto;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
-use super::{DenseVectorStorage, VectorStorageEnum};
-use crate::common::operation_error::OperationResult;
+use super::{DenseVectorStorage, SparseVectorStorage, VectorStorageEnum};
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::vectors::{QueryVector, VectorType};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
@@ -17,6 +18,7 @@ use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::Distance;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
+use crate::vector_storage::sparse_raw_scorer::SparseRawScorer;
 
 /// RawScorer            QueryScorer        Metric
 /// ┌────────────────┐   ┌──────────────┐   ┌───────────────────┐
@@ -116,12 +118,34 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::AppendableMemmap(vs) => {
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
-        VectorStorageEnum::SparseSimple(_vs) => panic!("sparse vector raw scorer"), // TODO(sparse)
+        VectorStorageEnum::SparseSimple(vs) => {
+            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
+        }
     }
 }
 
 pub static DEFAULT_STOPPED: AtomicBool = AtomicBool::new(false);
 
+pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match query {
+        QueryVector::Nearest(vector) => Ok(raw_sparse_scorer_from_query_scorer(
+            vector.try_into()?,
+            vector_storage,
+            point_deleted,
+            vector_storage.deleted_vector_bitslice(),
+            is_stopped,
+        )),
+        QueryVector::Recommend(_) => Err(OperationError::WrongSparse),
+        QueryVector::Discovery(_) => Err(OperationError::WrongSparse),
+        QueryVector::Context(_) => Err(OperationError::WrongSparse),
+    }
+}
+
 pub fn new_raw_scorer<'a>(
     vector: QueryVector,
     vector_storage: &'a VectorStorageEnum,
@@ -216,6 +240,22 @@ pub fn raw_scorer_from_query_scorer<'a, TQueryScorer: QueryScorer + 'a>(
     }))
 }
 
+pub fn raw_sparse_scorer_from_query_scorer<'a, TVectorStorage: SparseVectorStorage>(
+    vector: SparseVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    vec_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> Box<dyn RawScorer + 'a> {
+    Box::new(SparseRawScorer::new(
+        vector,
+        vector_storage,
+        point_deleted,
+        vec_deleted,
+        is_stopped,
+    ))
+}
+
 impl<'a, TQueryScorer> RawScorer for RawScorerImpl<'a, TQueryScorer>
 where
     TQueryScorer: QueryScorer,

commit 6638f735ad4d2a448ee643295852c4397af712f0
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Nov 3 08:52:28 2023 -0400

    update RawScorer composition diagram (#2916)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index f105bbff7..bc6df7a8d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -20,17 +20,26 @@ use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
 use crate::vector_storage::sparse_raw_scorer::SparseRawScorer;
 
-/// RawScorer            QueryScorer        Metric
-/// ┌────────────────┐   ┌──────────────┐   ┌───────────────────┐
-/// │                │   │              │   │  - Cosine         │
-/// │       ┌─────┐  │   │     ┌─────┐  │   │  - Dot            │
-/// │       │     │◄─┼───┤     │     │◄─┼───┤  - Euclidean      │
-/// │       └─────┘  │   │     └─────┘  │   │                   │
-/// │                │   │              │   │                   │
-/// └────────────────┘   └──────────────┘   └───────────────────┘
-/// - Deletions          - Scoring logic    - Vector Distance
-/// - Stopping           - Query holding
-/// - Access patterns    - Complex Queries
+/// RawScorer composition:
+///                                              Metric
+///                                             ┌───────────────────┐
+///                                             │  - Cosine         │
+///   RawScorer            QueryScorer          │  - Dot            │
+///  ┌────────────────┐   ┌──────────────┐  ┌───┤  - Euclidean      │
+///  │                │   │              │  │   │                   │
+///  │       ┌─────┐  │   │    ┌─────┐   │  │   └───────────────────┘
+///  │       │     │◄─┼───┤    │     │◄──┼──┘   - Vector Distance
+///  │       └─────┘  │   │    └─────┘   │
+///  │                │   │              │
+///  └────────────────┘   │    ┌─────┐   │        Query
+///  - Deletions          │    │     │◄──┼───┐   ┌───────────────────┐
+///  - Stopping           │    └─────┘   │   │   │  - RecoQuery      │
+///  - Access patterns    │              │   │   │  - DiscoveryQuery │
+///                       └──────────────┘   └───┤  - ContextQuery   │
+///                       - Query holding        │                   │
+///                       - Vector storage       └───────────────────┘
+///                                              - Scoring logic
+///                                              - Complex queries
 ///
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score

commit d5cea5730b6e9ce006a478b5e0f75153d2cd2f65
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Nov 16 10:43:09 2023 +0100

    integrate sparse vectors into queries (#3028)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index bc6df7a8d..9b2a6fcc2 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -200,13 +200,13 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<TMetric, _>::new(vector.into(), vector_storage),
+            MetricQueryScorer::<TMetric, _>::new(vector.try_into()?, vector_storage),
             point_deleted,
             vec_deleted,
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<VectorType> = reco_query.transform_into();
+            let reco_query: RecoQuery<VectorType> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
                 point_deleted,
@@ -215,7 +215,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.transform_into();
+            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
                 point_deleted,
@@ -224,7 +224,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<VectorType> = context_query.transform_into();
+            let context_query: ContextQuery<VectorType> = context_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
                 point_deleted,

commit 8f19257f70e639047cd7e90a6eb8e520ed505460
Author: Kaan C. Fidan <kaancfidan@gmail.com>
Date:   Sat Dec 2 23:28:38 2023 +0300

    Manhattan distance (#3079)
    
    * implemented Manhattan distance
    
    * updated quantization dependency
    
    * fixed negative distances and doc consistency
    
    * fixed neon implementation
    
    * updated quantization dependency
    
    * updated quantization dependency
    
    * removed redundant copy operation
    
    * updated quantization dependency
    
    * Change back to upstream quantization dependency
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 9b2a6fcc2..e8fb9e960 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -13,7 +13,7 @@ use super::{DenseVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::vectors::{QueryVector, VectorType};
 use crate::spaces::metric::Metric;
-use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
+use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::Distance;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
@@ -188,6 +188,12 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage>(
             point_deleted,
             is_stopped,
         ),
+        Distance::Manhattan => new_scorer_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
     }
 }
 

commit d5a705e0faaf667641b82e53708fb2119a44d272
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Dec 5 20:32:23 2023 +0100

    Sparse vectors advanced search api support (#3128)
    
    * sparse vectors query scorer
    
    plain search test without internals
    
    fix sparse_vector_index_plain_search
    
    fix async scorer build
    
    fix unit tests
    
    are you happy fmt
    
    sparse index with full query support
    
    fix benches, use exact flag to force plain search
    
    add alias and comment to exact flag
    
    fix tests
    
    recommendations TODOs fix
    
    add simple test
    
    add todo
    
    refactor index
    
    test vs comparison dense and sparse discovery
    
    are you happy fmt
    
    propogate error from avg negatives
    
    reuse filtered points list
    
    rollback api changes
    
    better discovery test
    
    are you happy fmt
    
    rollback openapi
    
    fix build
    
    fix tests
    
    review remark recommendations
    
    review remarks
    
    review remarks
    
    codespell
    
    integrate plain search
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    fix comment of plain search
    
    Update lib/collection/src/recommendations.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    fix tests
    
    * simplify search query function

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index e8fb9e960..b0d2a8ea8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -9,6 +9,7 @@ use super::query::discovery_query::DiscoveryQuery;
 use super::query::reco_query::RecoQuery;
 use super::query::TransformInto;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
+use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::vectors::{QueryVector, VectorType};
@@ -18,7 +19,6 @@ use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::Distance;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
-use crate::vector_storage::sparse_raw_scorer::SparseRawScorer;
 
 /// RawScorer composition:
 ///                                              Metric
@@ -82,7 +82,10 @@ pub trait RawScorer {
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
 }
 
-pub struct RawScorerImpl<'a, TQueryScorer: QueryScorer> {
+pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
+where
+    TQueryScorer: QueryScorer<TVector>,
+{
     pub query_scorer: TQueryScorer,
     /// Point deleted flags should be explicitly present as `false`
     /// for each existing point in the segment.
@@ -94,6 +97,8 @@ pub struct RawScorerImpl<'a, TQueryScorer: QueryScorer> {
     /// This flag indicates that the search process is stopped externally,
     /// the search result is no longer needed and the search process should be stopped as soon as possible.
     pub is_stopped: &'a AtomicBool,
+
+    vector: std::marker::PhantomData<*const TVector>,
 }
 
 pub fn new_stoppable_raw_scorer<'a>(
@@ -141,17 +146,38 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
-        QueryVector::Nearest(vector) => Ok(raw_sparse_scorer_from_query_scorer(
-            vector.try_into()?,
-            vector_storage,
-            point_deleted,
-            vector_storage.deleted_vector_bitslice(),
-            is_stopped,
+        QueryVector::Nearest(_vector) => Err(OperationError::service_error(
+            "Raw scorer must not be used for nearest queries",
         )),
-        QueryVector::Recommend(_) => Err(OperationError::WrongSparse),
-        QueryVector::Discovery(_) => Err(OperationError::WrongSparse),
-        QueryVector::Context(_) => Err(OperationError::WrongSparse),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                SparseCustomQueryScorer::<_, _>::new(reco_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<SparseVector> = discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                SparseCustomQueryScorer::<_, _>::new(discovery_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<SparseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                SparseCustomQueryScorer::<_, _>::new(context_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
     }
 }
 
@@ -241,39 +267,29 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     }
 }
 
-pub fn raw_scorer_from_query_scorer<'a, TQueryScorer: QueryScorer + 'a>(
+pub fn raw_scorer_from_query_scorer<'a, TVector, TQueryScorer>(
     query_scorer: TQueryScorer,
     point_deleted: &'a BitSlice,
     vec_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
-) -> OperationResult<Box<dyn RawScorer + 'a>> {
-    Ok(Box::new(RawScorerImpl::<TQueryScorer> {
+) -> OperationResult<Box<dyn RawScorer + 'a>>
+where
+    TVector: ?Sized + 'a,
+    TQueryScorer: QueryScorer<TVector> + 'a,
+{
+    Ok(Box::new(RawScorerImpl::<TVector, TQueryScorer> {
         query_scorer,
         point_deleted,
         vec_deleted,
         is_stopped,
+        vector: std::marker::PhantomData,
     }))
 }
 
-pub fn raw_sparse_scorer_from_query_scorer<'a, TVectorStorage: SparseVectorStorage>(
-    vector: SparseVector,
-    vector_storage: &'a TVectorStorage,
-    point_deleted: &'a BitSlice,
-    vec_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
-) -> Box<dyn RawScorer + 'a> {
-    Box::new(SparseRawScorer::new(
-        vector,
-        vector_storage,
-        point_deleted,
-        vec_deleted,
-        is_stopped,
-    ))
-}
-
-impl<'a, TQueryScorer> RawScorer for RawScorerImpl<'a, TQueryScorer>
+impl<'a, TVector, TQueryScorer> RawScorer for RawScorerImpl<'a, TVector, TQueryScorer>
 where
-    TQueryScorer: QueryScorer,
+    TVector: ?Sized,
+    TQueryScorer: QueryScorer<TVector>,
 {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
         if self.is_stopped.load(Ordering::Relaxed) {
@@ -315,20 +331,7 @@ where
     }
 
     fn check_vector(&self, point: PointOffsetType) -> bool {
-        // Deleted points propagate to vectors; check vector deletion for possible early return
-        !self
-                .vec_deleted
-                .get(point as usize)
-                .map(|x| *x)
-                // Default to not deleted if our deleted flags failed grow
-                .unwrap_or(false)
-            // Additionally check point deletion for integrity if delete propagation to vector failed
-            && !self
-                .point_deleted
-                .get(point as usize)
-                .map(|x| *x)
-                // Default to deleted if the point mapping was removed from the ID tracker
-                .unwrap_or(true)
+        check_deleted_condition(point, self.vec_deleted, self.point_deleted)
     }
 
     fn score_point(&self, point: PointOffsetType) -> ScoreType {
@@ -368,3 +371,23 @@ where
         peek_top_largest_iterable(scores, top)
     }
 }
+
+#[inline]
+pub fn check_deleted_condition(
+    point: PointOffsetType,
+    vec_deleted: &BitSlice,
+    point_deleted: &BitSlice,
+) -> bool {
+    // Deleted points propagate to vectors; check vector deletion for possible early return
+    !vec_deleted
+            .get(point as usize)
+            .map(|x| *x)
+            // Default to not deleted if our deleted flags failed grow
+            .unwrap_or(false)
+        // Additionally check point deletion for integrity if delete propagation to vector failed
+        && !point_deleted
+            .get(point as usize)
+            .map(|x| *x)
+            // Default to deleted if the point mapping was removed from the ID tracker
+            .unwrap_or(true)
+}

commit bd6bd55033c0bf42fc8f9430c45a7e183de1048e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 13 17:20:23 2023 +0100

    Rename `VectorType` to `DenseVector` (#3192)
    
    * rename vectortype to densevector
    
    * rename enums
    
    * are you happy fmt
    
    * openapi
    
    * revert type renamings

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index b0d2a8ea8..72c4b93a0 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -12,7 +12,7 @@ use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::data_types::vectors::{QueryVector, VectorType};
+use crate::data_types::vectors::{DenseVector, QueryVector};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
@@ -238,7 +238,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<VectorType> = reco_query.transform_into()?;
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
                 point_deleted,
@@ -247,7 +247,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<VectorType> = discovery_query.transform_into()?;
+            let discovery_query: DiscoveryQuery<DenseVector> = discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
                 point_deleted,
@@ -256,7 +256,7 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<VectorType> = context_query.transform_into()?;
+            let context_query: ContextQuery<DenseVector> = context_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
                 point_deleted,

commit 8c93500998e7fb1fa8d6435d6561dd4316ab7b2d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 13 17:08:37 2023 +0000

    Rename SimpleDenseVectorStorage (#3223)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 72c4b93a0..ce0e4204e 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -108,7 +108,7 @@ pub fn new_stoppable_raw_scorer<'a>(
     is_stopped: &'a AtomicBool,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage {
-        VectorStorageEnum::Simple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
+        VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
 
         VectorStorageEnum::Memmap(vs) => {
             if vs.has_async_reader() {

commit d1d69d12e6d9b8c0f8d2302c494bc7c1e2601e40
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Feb 28 12:30:44 2024 +0100

    Clearer names for dense storage implementations (#3712)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index ce0e4204e..f4974df51 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -110,7 +110,7 @@ pub fn new_stoppable_raw_scorer<'a>(
     match vector_storage {
         VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
 
-        VectorStorageEnum::Memmap(vs) => {
+        VectorStorageEnum::DenseMemmap(vs) => {
             if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
                 {
@@ -129,7 +129,7 @@ pub fn new_stoppable_raw_scorer<'a>(
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
 
-        VectorStorageEnum::AppendableMemmap(vs) => {
+        VectorStorageEnum::DenseAppendableMemmap(vs) => {
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
         VectorStorageEnum::SparseSimple(vs) => {

commit 1808d2a9c11c1d67aaa43febbe0191681c4b48ae
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Mar 20 19:11:22 2024 +0100

    Multi dense vector simple storage (#3718)
    
    * Multi dense vector simple storage
    
    * code review first pass
    
    * fix in-memory storage
    
    * comment type
    
    * fix vector insertion for open as well

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index f4974df51..d7e87f1cd 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -135,6 +135,10 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseSimple(_vs) => {
+            // TODO(colbert)
+            unimplemented!("multidense vector")
+        }
     }
 }
 

commit 1e6998e2508bd141f5b606dbcd192e97b0ef242c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 21 13:58:02 2024 +0100

    Multivector hnsw test (#3880)
    
    * colbert query scorers (#3713)
    
    * colbert query scorers
    
    fix build after rebase
    
    * review remarks
    
    multivector hnsw test
    
    * fixes after rebase
    
    * fix test
    
    * fix build after rebase
    
    * review remark

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d7e87f1cd..d640995e5 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -9,15 +9,17 @@ use super::query::discovery_query::DiscoveryQuery;
 use super::query::reco_query::RecoQuery;
 use super::query::TransformInto;
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
+use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
-use super::{DenseVectorStorage, SparseVectorStorage, VectorStorageEnum};
+use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::data_types::vectors::{DenseVector, QueryVector};
+use crate::data_types::vectors::{DenseVector, MultiDenseVector, QueryVector};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::Distance;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
+use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
 
 /// RawScorer composition:
@@ -135,9 +137,8 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
-        VectorStorageEnum::MultiDenseSimple(_vs) => {
-            // TODO(colbert)
-            unimplemented!("multidense vector")
+        VectorStorageEnum::MultiDenseSimple(vs) => {
+            raw_multi_scorer_impl(query, vs, point_deleted, is_stopped)
         }
     }
 }
@@ -290,6 +291,85 @@ where
     }))
 }
 
+pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match vector_storage.distance() {
+        Distance::Cosine => new_multi_scorer_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_multi_scorer_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_multi_scorer_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Manhattan => new_multi_scorer_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+    }
+}
+
+fn new_multi_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: MultiVectorStorage>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MultiMetricQueryScorer::<TMetric, _>::new(vector.try_into()?, vector_storage),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+                discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+    }
+}
+
 impl<'a, TVector, TQueryScorer> RawScorer for RawScorerImpl<'a, TVector, TQueryScorer>
 where
     TVector: ?Sized,

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d640995e5..b7f7e9f40 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -13,7 +13,7 @@ use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::data_types::vectors::{DenseVector, MultiDenseVector, QueryVector};
+use crate::data_types::vectors::{DenseVector, MultiDenseVector, QueryVector, VectorElementType};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
@@ -194,7 +194,7 @@ pub fn new_raw_scorer<'a>(
     new_stoppable_raw_scorer(vector, vector_storage, point_deleted, &DEFAULT_STOPPED)
 }
 
-pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage>(
+pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
@@ -228,7 +228,11 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage>(
     }
 }
 
-fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorStorage>(
+fn new_scorer_with_metric<
+    'a,
+    TMetric: Metric<VectorElementType> + 'a,
+    TVectorStorage: DenseVectorStorage<VectorElementType>,
+>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
@@ -237,7 +241,10 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
-            MetricQueryScorer::<TMetric, _>::new(vector.try_into()?, vector_storage),
+            MetricQueryScorer::<VectorElementType, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
             point_deleted,
             vec_deleted,
             is_stopped,
@@ -245,7 +252,10 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
         QueryVector::Recommend(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                CustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
+                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -254,7 +264,10 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
         QueryVector::Discovery(discovery_query) => {
             let discovery_query: DiscoveryQuery<DenseVector> = discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                CustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
+                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -263,7 +276,10 @@ fn new_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: DenseVectorS
         QueryVector::Context(context_query) => {
             let context_query: ContextQuery<DenseVector> = context_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                CustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
+                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -325,7 +341,11 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage>(
     }
 }
 
-fn new_multi_scorer_with_metric<'a, TMetric: Metric + 'a, TVectorStorage: MultiVectorStorage>(
+fn new_multi_scorer_with_metric<
+    'a,
+    TMetric: Metric<VectorElementType> + 'a,
+    TVectorStorage: MultiVectorStorage,
+>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index b7f7e9f40..72b203db2 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -13,7 +13,9 @@ use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::data_types::vectors::{DenseVector, MultiDenseVector, QueryVector, VectorElementType};
+use crate::data_types::vectors::{
+    DenseVector, MultiDenseVector, QueryVector, VectorElementType, VectorElementTypeByte,
+};
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::spaces::tools::peek_top_largest_iterable;
@@ -111,6 +113,9 @@ pub fn new_stoppable_raw_scorer<'a>(
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage {
         VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
+        VectorStorageEnum::DenseSimpleByte(vs) => {
+            raw_scorer_byte_impl(query, vs, point_deleted, is_stopped)
+        }
 
         VectorStorageEnum::DenseMemmap(vs) => {
             if vs.has_async_reader() {
@@ -131,9 +136,17 @@ pub fn new_stoppable_raw_scorer<'a>(
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
 
+        // TODO(byte_storage): Implement async raw scorer for DenseAppendableMemmapByte
+        VectorStorageEnum::DenseMemmapByte(vs) => {
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
+
         VectorStorageEnum::DenseAppendableMemmap(vs) => {
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::DenseAppendableMemmapByte(vs) => {
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
@@ -288,6 +301,100 @@ fn new_scorer_with_metric<
     }
 }
 
+pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementTypeByte>>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match vector_storage.distance() {
+        Distance::Cosine => new_scorer_byte_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_scorer_byte_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_scorer_byte_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Manhattan => new_scorer_byte_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+    }
+}
+
+fn new_scorer_byte_with_metric<
+    'a,
+    TMetric: Metric<VectorElementTypeByte> + 'a,
+    TVectorStorage: DenseVectorStorage<VectorElementTypeByte>,
+>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<VectorElementTypeByte, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<DenseVector> = discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<DenseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+    }
+}
+
 pub fn raw_scorer_from_query_scorer<'a, TVector, TQueryScorer>(
     query_scorer: TQueryScorer,
     point_deleted: &'a BitSlice,

commit e452b6f3adef40afad594773e102e273f888e5d9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Apr 24 11:35:16 2024 +0200

    generic multidense vector storage (#4104)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 72b203db2..3cf3ebf50 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -414,7 +414,7 @@ where
     }))
 }
 
-pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage>(
+pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage<VectorElementType>>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
@@ -451,7 +451,7 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage>(
 fn new_multi_scorer_with_metric<
     'a,
     TMetric: Metric<VectorElementType> + 'a,
-    TVectorStorage: MultiVectorStorage,
+    TVectorStorage: MultiVectorStorage<VectorElementType>,
 >(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,

commit 916c7c7607bd0e5f1e6918d9de27328a228af137
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 25 13:41:16 2024 +0200

    generic multivector scorer (#4115)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 3cf3ebf50..37b0a0a0d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -461,7 +461,10 @@ fn new_multi_scorer_with_metric<
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
-            MultiMetricQueryScorer::<TMetric, _>::new(vector.try_into()?, vector_storage),
+            MultiMetricQueryScorer::<VectorElementType, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
             point_deleted,
             vec_deleted,
             is_stopped,
@@ -469,7 +472,10 @@ fn new_multi_scorer_with_metric<
         QueryVector::Recommend(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                MultiCustomQueryScorer::<TMetric, _, _>::new(reco_query, vector_storage),
+                MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -479,7 +485,10 @@ fn new_multi_scorer_with_metric<
             let discovery_query: DiscoveryQuery<MultiDenseVector> =
                 discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                MultiCustomQueryScorer::<TMetric, _, _>::new(discovery_query, vector_storage),
+                MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -488,7 +497,10 @@ fn new_multi_scorer_with_metric<
         QueryVector::Context(context_query) => {
             let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                MultiCustomQueryScorer::<TMetric, _, _>::new(context_query, vector_storage),
+                MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,

commit 8bdc8a3caf49d34f7bd6f90239f791684a473a5a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 10:28:31 2024 +0200

    Mmap multivector storage (#4106)
    
    * mmap multivector storage
    
    update_from
    
    fix build
    
    are you happy fmt
    
    fix bug
    
    share multivector storages tests
    
    * review remarks

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 37b0a0a0d..af554314f 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -153,6 +153,9 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::MultiDenseSimple(vs) => {
             raw_multi_scorer_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
     }
 }
 

commit f7113e678c2be8eec0866631fc14e887dbd6e06e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 13:27:58 2024 +0200

    integrate multivector mmap and byte storages (#4194)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index af554314f..a23c19588 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -153,9 +153,15 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::MultiDenseSimple(vs) => {
             raw_multi_scorer_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseSimpleByte(vs) => {
+            raw_multi_scorer_byte_impl(query, vs, point_deleted, is_stopped)
+        }
         VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
             raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => {
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
     }
 }
 
@@ -512,6 +518,101 @@ fn new_multi_scorer_with_metric<
     }
 }
 
+pub fn raw_multi_scorer_byte_impl<'a, TVectorStorage: MultiVectorStorage<VectorElementTypeByte>>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match vector_storage.distance() {
+        Distance::Cosine => new_multi_scorer_byte_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_multi_scorer_byte_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_multi_scorer_byte_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Manhattan => new_multi_scorer_byte_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+    }
+}
+
+fn new_multi_scorer_byte_with_metric<
+    'a,
+    TMetric: Metric<VectorElementTypeByte> + 'a,
+    TVectorStorage: MultiVectorStorage<VectorElementTypeByte>,
+>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MultiMetricQueryScorer::<VectorElementTypeByte, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+                discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+    }
+}
+
 impl<'a, TVector, TQueryScorer> RawScorer for RawScorerImpl<'a, TVector, TQueryScorer>
 where
     TVector: ?Sized,

commit 78b16a16a40919218339114bfc723048731ab4b3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 15 10:36:55 2024 +0200

    Float16 integration and API (#4234)
    
    * f16 integration
    
    tests
    
    api
    
    fix test
    
    are you happy clippy
    
    * fix build

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index a23c19588..0398dbe5d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -15,6 +15,7 @@ use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorS
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::vectors::{
     DenseVector, MultiDenseVector, QueryVector, VectorElementType, VectorElementTypeByte,
+    VectorElementTypeHalf,
 };
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
@@ -116,6 +117,9 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::DenseSimpleByte(vs) => {
             raw_scorer_byte_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::DenseSimpleHalf(vs) => {
+            raw_scorer_half_impl(query, vs, point_deleted, is_stopped)
+        }
 
         VectorStorageEnum::DenseMemmap(vs) => {
             if vs.has_async_reader() {
@@ -136,10 +140,13 @@ pub fn new_stoppable_raw_scorer<'a>(
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
 
-        // TODO(byte_storage): Implement async raw scorer for DenseAppendableMemmapByte
+        // TODO(byte_storage): Implement async raw scorer for DenseMemmapByte and DenseMemmapHalf
         VectorStorageEnum::DenseMemmapByte(vs) => {
             raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::DenseMemmapHalf(vs) => {
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
 
         VectorStorageEnum::DenseAppendableMemmap(vs) => {
             raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
@@ -147,6 +154,9 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::DenseAppendableMemmapByte(vs) => {
             raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::DenseAppendableMemmapHalf(vs) => {
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
@@ -156,12 +166,18 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::MultiDenseSimpleByte(vs) => {
             raw_multi_scorer_byte_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseSimpleHalf(vs) => {
+            raw_multi_scorer_half_impl(query, vs, point_deleted, is_stopped)
+        }
         VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
             raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
         VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => {
             raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => {
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
     }
 }
 
@@ -404,6 +420,100 @@ fn new_scorer_byte_with_metric<
     }
 }
 
+pub fn raw_scorer_half_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementTypeHalf>>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match vector_storage.distance() {
+        Distance::Cosine => new_scorer_half_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_scorer_half_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_scorer_half_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Manhattan => new_scorer_half_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+    }
+}
+
+fn new_scorer_half_with_metric<
+    'a,
+    TMetric: Metric<VectorElementTypeHalf> + 'a,
+    TVectorStorage: DenseVectorStorage<VectorElementTypeHalf>,
+>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MetricQueryScorer::<VectorElementTypeHalf, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<DenseVector> = discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<DenseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+    }
+}
+
 pub fn raw_scorer_from_query_scorer<'a, TVector, TQueryScorer>(
     query_scorer: TQueryScorer,
     point_deleted: &'a BitSlice,
@@ -613,6 +723,101 @@ fn new_multi_scorer_byte_with_metric<
     }
 }
 
+pub fn raw_multi_scorer_half_impl<'a, TVectorStorage: MultiVectorStorage<VectorElementTypeHalf>>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    match vector_storage.distance() {
+        Distance::Cosine => new_multi_scorer_half_with_metric::<CosineMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Euclid => new_multi_scorer_half_with_metric::<EuclidMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Dot => new_multi_scorer_half_with_metric::<DotProductMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+        Distance::Manhattan => new_multi_scorer_half_with_metric::<ManhattanMetric, _>(
+            query,
+            vector_storage,
+            point_deleted,
+            is_stopped,
+        ),
+    }
+}
+
+fn new_multi_scorer_half_with_metric<
+    'a,
+    TMetric: Metric<VectorElementTypeHalf> + 'a,
+    TVectorStorage: MultiVectorStorage<VectorElementTypeHalf>,
+>(
+    query: QueryVector,
+    vector_storage: &'a TVectorStorage,
+    point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    let vec_deleted = vector_storage.deleted_vector_bitslice();
+    match query {
+        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
+            MultiMetricQueryScorer::<VectorElementTypeHalf, TMetric, _>::new(
+                vector.try_into()?,
+                vector_storage,
+            ),
+            point_deleted,
+            vec_deleted,
+            is_stopped,
+        ),
+        QueryVector::Recommend(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    reco_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Discovery(discovery_query) => {
+            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+                discovery_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    discovery_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::Context(context_query) => {
+            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    context_query,
+                    vector_storage,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+    }
+}
+
 impl<'a, TVector, TQueryScorer> RawScorer for RawScorerImpl<'a, TVector, TQueryScorer>
 where
     TVector: ?Sized,

commit bd16dfa0173c727019d61feb0579d8bcdbc28354
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed May 15 09:36:46 2024 -0400

    universal-query: Add `query()` to `ShardOperation` trait (#4210)
    
    * add `query` to shard trait
    
    * add missing conversions for query
    
    * update grpc docs
    
    * Query response has intermediate results
    
    * add ShardQueryResponse description
    
    * move pub use to the top, keep only one way of reaching reexports

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 0398dbe5d..4fe0b4738 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -4,10 +4,7 @@ use bitvec::prelude::BitSlice;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 use sparse::common::sparse_vector::SparseVector;
 
-use super::query::context_query::ContextQuery;
-use super::query::discovery_query::DiscoveryQuery;
-use super::query::reco_query::RecoQuery;
-use super::query::TransformInto;
+use super::query::{ContextQuery, DiscoveryQuery, RecoQuery, TransformInto};
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;

commit 49a9d05e7c180c2a4828686a54b9a7a8fbc946f3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 18 20:38:24 2024 +0200

    Fix multivector for unnamed vectors (#4482)
    
    * minor conversion improvement
    
    * use NamedVectors in update_vectors
    
    * remove merge from VectorStruct
    
    * rename Multi -> Named in vector struct
    
    * add multi-dense vectors option into VectorStruct
    
    * generate openapi
    
    * rename VectorStruct -> VectorStructInternal
    
    * add conversion for anonymous multivec in grpc
    
    * renames for BatchVectorStruct
    
    * implement multi-dense for batch
    
    * allow multi-dense in batch upserts
    
    * test and fixes

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 4fe0b4738..1215310f8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -11,7 +11,7 @@ use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::vectors::{
-    DenseVector, MultiDenseVector, QueryVector, VectorElementType, VectorElementTypeByte,
+    DenseVector, MultiDenseVectorInternal, QueryVector, VectorElementType, VectorElementTypeByte,
     VectorElementTypeHalf,
 };
 use crate::spaces::metric::Metric;
@@ -586,7 +586,7 @@ fn new_multi_scorer_with_metric<
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     reco_query,
@@ -598,7 +598,7 @@ fn new_multi_scorer_with_metric<
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+            let discovery_query: DiscoveryQuery<MultiDenseVectorInternal> =
                 discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
@@ -611,7 +611,8 @@ fn new_multi_scorer_with_metric<
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            let context_query: ContextQuery<MultiDenseVectorInternal> =
+                context_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     context_query,
@@ -681,7 +682,7 @@ fn new_multi_scorer_byte_with_metric<
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     reco_query,
@@ -693,7 +694,7 @@ fn new_multi_scorer_byte_with_metric<
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+            let discovery_query: DiscoveryQuery<MultiDenseVectorInternal> =
                 discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
@@ -706,7 +707,8 @@ fn new_multi_scorer_byte_with_metric<
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            let context_query: ContextQuery<MultiDenseVectorInternal> =
+                context_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     context_query,
@@ -776,7 +778,7 @@ fn new_multi_scorer_half_with_metric<
             is_stopped,
         ),
         QueryVector::Recommend(reco_query) => {
-            let reco_query: RecoQuery<MultiDenseVector> = reco_query.transform_into()?;
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     reco_query,
@@ -788,7 +790,7 @@ fn new_multi_scorer_half_with_metric<
             )
         }
         QueryVector::Discovery(discovery_query) => {
-            let discovery_query: DiscoveryQuery<MultiDenseVector> =
+            let discovery_query: DiscoveryQuery<MultiDenseVectorInternal> =
                 discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
@@ -801,7 +803,8 @@ fn new_multi_scorer_half_with_metric<
             )
         }
         QueryVector::Context(context_query) => {
-            let context_query: ContextQuery<MultiDenseVector> = context_query.transform_into()?;
+            let context_query: ContextQuery<MultiDenseVectorInternal> =
+                context_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     context_query,

commit 649560fefd0cce811d8ada7d5c280991bfbb233f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 7 16:34:58 2024 +0200

    Use mmap lock as default vector storage (#4828)
    
    * add force_ram parameter to chuncked mmap vector storage
    
    * enable mlocked mmap vector storage on unix by default
    
    * regen openapi
    
    * add mlock on creation of chunck
    
    * minor unrelated renaming
    
    * rollback changes in LockedChunkedMmap
    
    * fmt
    
    * make AppendableMmapDenseVectorStorage generic of storage type
    
    * make AppendableMmapMultiDenseVectorStorage generic of storage type
    
    * implement initialization of InRamChunkedMmap
    
    * implement MultiDenseAppendableInRam and variations
    
    * enable InRamChunkedMmap for multivectors
    
    * use same CHUNK_SIZE for mmap and regular chuncked vectors
    
    * enable InRamChunkedMmap by default
    
    * fix tests
    
    * rollback usage of InRamChunkedMmap by default
    
    * review changes
    
    * add assertion on chunk_capacity [skip-ci]

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 1215310f8..af817fb44 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -154,6 +154,15 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::DenseAppendableMemmapHalf(vs) => {
             raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::DenseAppendableInRam(vs) => {
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
+        VectorStorageEnum::DenseAppendableInRamByte(vs) => {
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
+        VectorStorageEnum::DenseAppendableInRamHalf(vs) => {
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
@@ -175,6 +184,15 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => {
             raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
         }
+        VectorStorageEnum::MultiDenseAppendableInRam(vs) => {
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
+        VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => {
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
+        VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => {
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+        }
     }
 }
 

commit d4716da8e7be0111ba7ef810b3525e5bde2ae56a
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Oct 14 13:13:58 2024 +0200

    fix lints for Clippy 1.82 (#5229)
    
    * fix lints for Clippy 1.82
    
    * regen openapi

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index af817fb44..2cf618b96 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -23,6 +23,7 @@ use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQ
 use crate::vector_storage::query_scorer::QueryScorer;
 
 /// RawScorer composition:
+///
 ///                                              Metric
 ///                                             ┌───────────────────┐
 ///                                             │  - Cosine         │

commit 4c9cda4ad83c6f01f7d2d19ef616042b82a4a154
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Oct 18 09:58:02 2024 +0200

    Add CPU measurement for multivectors (#5241)
    
    * Add CPU measurement for multivectors
    
    * add further test sparse vector search
    
    * make updating vector_query_context consistent
    
    * review fix + take element type into consideration
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 2cf618b96..0cc208679 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,6 +1,7 @@
 use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 use sparse::common::sparse_vector::SparseVector;
 
@@ -83,6 +84,8 @@ pub trait RawScorer {
     ) -> Vec<ScoredPointOffset>;
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
+
+    fn hardware_counter(&self) -> HardwareCounterCell;
 }
 
 pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
@@ -921,6 +924,10 @@ where
             });
         peek_top_largest_iterable(scores, top)
     }
+
+    fn hardware_counter(&self) -> HardwareCounterCell {
+        self.query_scorer.hardware_counter()
+    }
 }
 
 #[inline]

commit cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Oct 25 09:52:18 2024 +0200

    Hw counter utilization checks (#5288)
    
    * Enforce usage of hardware counter values
    
    * improve comments
    
    * log a warning in release mode
    
    * some minor improvements
    
    * avoid cloning for hardware counter
    
    * fmt
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 0cc208679..96c1f79f8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -25,6 +25,7 @@ use crate::vector_storage::query_scorer::QueryScorer;
 
 /// RawScorer composition:
 ///
+/// ```plaintext
 ///                                              Metric
 ///                                             ┌───────────────────┐
 ///                                             │  - Cosine         │
@@ -45,6 +46,8 @@ use crate::vector_storage::query_scorer::QueryScorer;
 ///                                              - Scoring logic
 ///                                              - Complex queries
 ///
+/// ```
+///
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score
 pub trait RawScorer {
@@ -85,7 +88,7 @@ pub trait RawScorer {
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
 
-    fn hardware_counter(&self) -> HardwareCounterCell;
+    fn take_hardware_counter(&self) -> HardwareCounterCell;
 }
 
 pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
@@ -925,8 +928,8 @@ where
         peek_top_largest_iterable(scores, top)
     }
 
-    fn hardware_counter(&self) -> HardwareCounterCell {
-        self.query_scorer.hardware_counter()
+    fn take_hardware_counter(&self) -> HardwareCounterCell {
+        self.query_scorer.take_hardware_counter()
     }
 }
 

commit 98633cbd3fdd01ee3c486a3573ff27dc180e3b6d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 11 10:26:17 2024 +0100

    Use references for less cloning when possible (#5409)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 96c1f79f8..62d680b6d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -603,7 +603,7 @@ fn new_multi_scorer_with_metric<
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
             MultiMetricQueryScorer::<VectorElementType, TMetric, _>::new(
-                vector.try_into()?,
+                &vector.try_into()?,
                 vector_storage,
             ),
             point_deleted,
@@ -699,7 +699,7 @@ fn new_multi_scorer_byte_with_metric<
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
             MultiMetricQueryScorer::<VectorElementTypeByte, TMetric, _>::new(
-                vector.try_into()?,
+                &vector.try_into()?,
                 vector_storage,
             ),
             point_deleted,
@@ -795,7 +795,7 @@ fn new_multi_scorer_half_with_metric<
     match query {
         QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
             MultiMetricQueryScorer::<VectorElementTypeHalf, TMetric, _>::new(
-                vector.try_into()?,
+                &vector.try_into()?,
                 vector_storage,
             ),
             point_deleted,

commit d15ef49719c6d3ef3bc66da73d510e386553596b
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 15 17:14:37 2024 +0100

    Optimize mmap sequential access for large scoring (#5440)
    
    * Optimize mmap sequential access for large scoring
    
    * use it
    
    * make windows happy
    
    * add missing CPU counters
    
    * Will not need
    
    * more unix build
    
    * add benchmark
    
    * fix and bench cmp
    
    * larger batch size
    
    * start appendable mmap implem
    
    * reenable debug for bench
    
    * remove old impl for comparison
    
    * impl for chunk mmap
    
    * fix windows
    
    * debug assert
    
    * errare human est
    
    * windows cfg
    
    * generalize peek_top_iter
    
    * remove blanket implementation to force explicit decision
    
    * less TODO
    
    * account for size of T
    
    * fmr
    
    * simplify chunk impl
    
    * relax constraint on contiguous ids
    
    * remove madvice WILLNEED and clean batching infra
    
    * some premature optimizations
    
    * extra sequential mmap for MMapVectorStorage
    
    * add read-only typed mmap
    
    * add read-only typed mmap
    
    * fix comments
    
    * implement batch reads for chuncked mmap
    
    * fix is_read_with_prefetch_efficient
    
    * cleanup
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 62d680b6d..ba8dfca9b 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -2,7 +2,9 @@ use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
+use itertools::Itertools;
 use sparse::common::sparse_vector::SparseVector;
 
 use super::query::{ContextQuery, DiscoveryQuery, RecoQuery, TransformInto};
@@ -17,8 +19,8 @@ use crate::data_types::vectors::{
 };
 use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
-use crate::spaces::tools::peek_top_largest_iterable;
 use crate::types::Distance;
+use crate::vector_storage::common::VECTOR_READ_BATCH_SIZE;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQueryScorer;
 use crate::vector_storage::query_scorer::QueryScorer;
@@ -904,28 +906,45 @@ where
         points: &mut dyn Iterator<Item = PointOffsetType>,
         top: usize,
     ) -> Vec<ScoredPointOffset> {
-        let scores = points
+        if top == 0 {
+            return vec![];
+        }
+
+        let chunks = points
             .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
             .filter(|point_id| self.check_vector(*point_id))
-            .map(|point_id| ScoredPointOffset {
-                idx: point_id,
-                score: self.query_scorer.score_stored(point_id),
-            });
-        peek_top_largest_iterable(scores, top)
+            .chunks(VECTOR_READ_BATCH_SIZE); // batch points to leverage storage sequential access
+
+        let mut pq = FixedLengthPriorityQueue::new(top);
+
+        // Reuse the same buffer for all chunks, to avoid reallocation
+        let mut chunk = [0; VECTOR_READ_BATCH_SIZE];
+        let mut scores_buffer = [0.0; VECTOR_READ_BATCH_SIZE];
+
+        for points_chunk in &chunks {
+            let mut chunk_size = 0;
+            for (i, point_id) in points_chunk.enumerate() {
+                chunk[i] = point_id;
+                chunk_size += 1;
+            }
+
+            self.query_scorer
+                .score_stored_batch(&chunk[..chunk_size], &mut scores_buffer[..chunk_size]);
+
+            for i in 0..chunk_size {
+                pq.push(ScoredPointOffset {
+                    idx: chunk[i],
+                    score: scores_buffer[i],
+                });
+            }
+        }
+
+        pq.into_vec()
     }
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
-        let scores = (0..self.point_deleted.len() as PointOffsetType)
-            .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
-            .filter(|point_id| self.check_vector(*point_id))
-            .map(|point_id| {
-                let point_id = point_id as PointOffsetType;
-                ScoredPointOffset {
-                    idx: point_id,
-                    score: self.query_scorer.score_stored(point_id),
-                }
-            });
-        peek_top_largest_iterable(scores, top)
+        let mut point_ids = 0..self.point_deleted.len() as PointOffsetType;
+        self.peek_top_iter(&mut point_ids, top)
     }
 
     fn take_hardware_counter(&self) -> HardwareCounterCell {

commit f416f2b98f08fc7749814b0725f9035459b5c057
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 27 11:24:58 2024 +0100

    Clippy 1.83 (#5513)
    
    * Clippy 1.83
    
    * there is more

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index ba8dfca9b..273685ff6 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -845,7 +845,7 @@ fn new_multi_scorer_half_with_metric<
     }
 }
 
-impl<'a, TVector, TQueryScorer> RawScorer for RawScorerImpl<'a, TVector, TQueryScorer>
+impl<TVector, TQueryScorer> RawScorer for RawScorerImpl<'_, TVector, TQueryScorer>
 where
     TVector: ?Sized,
     TQueryScorer: QueryScorer<TVector>,

commit c10c145a754b3825a60aaaa143fe91b5b98502b0
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 27 11:45:16 2024 -0600

    Compatibility for mmap sparse vectors (#5454)
    
    * implement mmap sparse vector storage
    
    * add to VectorStorageEnum
    
    * clippy
    
    * add tests, fix both simple and mmap storages
    
    * smol correction on total_vector_count
    
    * add sparse storage type to config
    
    * fix reading config without storage type
    
    * generate openapi
    
    * use blob_store by path
    
    * hidden setting to enable new storage
    
    * validate existing path in `BlobStore::open()`
    
    * use new dir for each sparse vector name
    
    * fix and rename `max_point_offset`
    
    Plus some extra refactors
    
    * add storage compat test, to always check both storages work
    
    * fix opening of storage + other misc fixes
    
    * FIX!!!
    
    `Unset` operations in the Tracker weren't updating the
    `next_pointer_id`. So, when reopening the storage, those points wouldn't
    get marked as deleted in the bitslice, thus creating the illusion that
    they should exist, when they did not.
    
    * refactor naming from `iter_*` to `for_each_*`
    
    * fix checking for BlobStore existance
    
    * fix typo
    
    * fix error message
    
    * better docs for open_or_create
    
    * fix after rebase

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 273685ff6..1f288c7a4 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -175,6 +175,9 @@ pub fn new_stoppable_raw_scorer<'a>(
         VectorStorageEnum::SparseSimple(vs) => {
             raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
         }
+        VectorStorageEnum::SparseMmap(vs) => {
+            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
+        }
         VectorStorageEnum::MultiDenseSimple(vs) => {
             raw_multi_scorer_impl(query, vs, point_deleted, is_stopped)
         }

commit 8bbe66c0fb4e4a1d3dd2bf565e68ab1a20a2c804
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Dec 2 14:33:35 2024 +0000

    Reduce debug size (#5556)
    
    * debug size: RawScorerImpl::peek_top_iter
    
    * debug size: TypedMultiDenseVector::multi_vectors() uses
    
    * debug size: stop_condition -> stopped

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 1f288c7a4..890aa9e81 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -4,7 +4,6 @@ use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
-use itertools::Itertools;
 use sparse::common::sparse_vector::SparseVector;
 
 use super::query::{ContextQuery, DiscoveryQuery, RecoQuery, TransformInto};
@@ -913,22 +912,29 @@ where
             return vec![];
         }
 
-        let chunks = points
-            .take_while(|_| !self.is_stopped.load(Ordering::Relaxed))
-            .filter(|point_id| self.check_vector(*point_id))
-            .chunks(VECTOR_READ_BATCH_SIZE); // batch points to leverage storage sequential access
-
         let mut pq = FixedLengthPriorityQueue::new(top);
 
         // Reuse the same buffer for all chunks, to avoid reallocation
         let mut chunk = [0; VECTOR_READ_BATCH_SIZE];
         let mut scores_buffer = [0.0; VECTOR_READ_BATCH_SIZE];
-
-        for points_chunk in &chunks {
+        loop {
             let mut chunk_size = 0;
-            for (i, point_id) in points_chunk.enumerate() {
-                chunk[i] = point_id;
+            for point_id in &mut *points {
+                if self.is_stopped.load(Ordering::Relaxed) {
+                    break;
+                }
+                if !self.check_vector(point_id) {
+                    continue;
+                }
+                chunk[chunk_size] = point_id;
                 chunk_size += 1;
+                if chunk_size == VECTOR_READ_BATCH_SIZE {
+                    break;
+                }
+            }
+
+            if chunk_size == 0 {
+                break;
             }
 
             self.query_scorer

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 890aa9e81..d960b7d15 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -88,8 +88,6 @@ pub trait RawScorer {
     ) -> Vec<ScoredPointOffset>;
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
-
-    fn take_hardware_counter(&self) -> HardwareCounterCell;
 }
 
 pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
@@ -116,22 +114,30 @@ pub fn new_stoppable_raw_scorer<'a>(
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hc: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage {
-        VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, is_stopped),
+        VectorStorageEnum::DenseSimple(vs) => {
+            raw_scorer_impl(query, vs, point_deleted, is_stopped, hc)
+        }
         VectorStorageEnum::DenseSimpleByte(vs) => {
-            raw_scorer_byte_impl(query, vs, point_deleted, is_stopped)
+            raw_scorer_byte_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseSimpleHalf(vs) => {
-            raw_scorer_half_impl(query, vs, point_deleted, is_stopped)
+            raw_scorer_half_impl(query, vs, point_deleted, is_stopped, hc)
         }
 
         VectorStorageEnum::DenseMemmap(vs) => {
             if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
                 {
-                    let scorer_result =
-                        super::async_raw_scorer::new(query.clone(), vs, point_deleted, is_stopped);
+                    let scorer_result = super::async_raw_scorer::new(
+                        query.clone(),
+                        vs,
+                        point_deleted,
+                        is_stopped,
+                        hc.fork(),
+                    );
                     match scorer_result {
                         Ok(raw_scorer) => return Ok(raw_scorer),
                         Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
@@ -142,67 +148,67 @@ pub fn new_stoppable_raw_scorer<'a>(
                 log::warn!("async raw scorer is only supported on Linux");
             }
 
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
 
         // TODO(byte_storage): Implement async raw scorer for DenseMemmapByte and DenseMemmapHalf
         VectorStorageEnum::DenseMemmapByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseMemmapHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
 
         VectorStorageEnum::DenseAppendableMemmap(vs) => {
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseAppendableMemmapByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseAppendableMemmapHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseAppendableInRam(vs) => {
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseAppendableInRamByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::DenseAppendableInRamHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::SparseSimple(vs) => {
-            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
+            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::SparseMmap(vs) => {
-            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped)
+            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseSimple(vs) => {
-            raw_multi_scorer_impl(query, vs, point_deleted, is_stopped)
+            raw_multi_scorer_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseSimpleByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs, point_deleted, is_stopped)
+            raw_multi_scorer_byte_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseSimpleHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs, point_deleted, is_stopped)
+            raw_multi_scorer_half_impl(query, vs, point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
-            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRam(vs) => {
-            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped)
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
         }
     }
 }
@@ -214,6 +220,7 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -223,7 +230,7 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
         QueryVector::Recommend(reco_query) => {
             let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                SparseCustomQueryScorer::<_, _>::new(reco_query, vector_storage),
+                SparseCustomQueryScorer::<_, _>::new(reco_query, vector_storage, hardware_counter),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -232,7 +239,11 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
         QueryVector::Discovery(discovery_query) => {
             let discovery_query: DiscoveryQuery<SparseVector> = discovery_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                SparseCustomQueryScorer::<_, _>::new(discovery_query, vector_storage),
+                SparseCustomQueryScorer::<_, _>::new(
+                    discovery_query,
+                    vector_storage,
+                    hardware_counter,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -241,7 +252,11 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
         QueryVector::Context(context_query) => {
             let context_query: ContextQuery<SparseVector> = context_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                SparseCustomQueryScorer::<_, _>::new(context_query, vector_storage),
+                SparseCustomQueryScorer::<_, _>::new(
+                    context_query,
+                    vector_storage,
+                    hardware_counter,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -250,12 +265,35 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
     }
 }
 
+#[cfg(feature = "testing")]
+pub fn new_raw_scorer_for_test<'a>(
+    vector: QueryVector,
+    vector_storage: &'a VectorStorageEnum,
+    point_deleted: &'a BitSlice,
+) -> OperationResult<Box<dyn RawScorer + 'a>> {
+    new_stoppable_raw_scorer(
+        vector,
+        vector_storage,
+        point_deleted,
+        &DEFAULT_STOPPED,
+        HardwareCounterCell::new(),
+    )
+}
+
 pub fn new_raw_scorer<'a>(
     vector: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
+    is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
-    new_stoppable_raw_scorer(vector, vector_storage, point_deleted, &DEFAULT_STOPPED)
+    new_stoppable_raw_scorer(
+        vector,
+        vector_storage,
+        point_deleted,
+        is_stopped,
+        hardware_counter,
+    )
 }
 
 pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>>(
@@ -263,6 +301,7 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_scorer_with_metric::<CosineMetric, _>(
@@ -270,24 +309,28 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_scorer_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_scorer_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_scorer_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -301,6 +344,7 @@ fn new_scorer_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -308,6 +352,7 @@ fn new_scorer_with_metric<
             MetricQueryScorer::<VectorElementType, TMetric, _>::new(
                 vector.try_into()?,
                 vector_storage,
+                hardware_counter,
             ),
             point_deleted,
             vec_deleted,
@@ -319,6 +364,7 @@ fn new_scorer_with_metric<
                 CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -331,6 +377,7 @@ fn new_scorer_with_metric<
                 CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -343,6 +390,7 @@ fn new_scorer_with_metric<
                 CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -357,6 +405,7 @@ pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_scorer_byte_with_metric::<CosineMetric, _>(
@@ -364,24 +413,28 @@ pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_scorer_byte_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_scorer_byte_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_scorer_byte_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -395,6 +448,7 @@ fn new_scorer_byte_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -402,6 +456,7 @@ fn new_scorer_byte_with_metric<
             MetricQueryScorer::<VectorElementTypeByte, TMetric, _>::new(
                 vector.try_into()?,
                 vector_storage,
+                hardware_counter,
             ),
             point_deleted,
             vec_deleted,
@@ -413,6 +468,7 @@ fn new_scorer_byte_with_metric<
                 CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -425,6 +481,7 @@ fn new_scorer_byte_with_metric<
                 CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -437,6 +494,7 @@ fn new_scorer_byte_with_metric<
                 CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -451,6 +509,7 @@ pub fn raw_scorer_half_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_scorer_half_with_metric::<CosineMetric, _>(
@@ -458,24 +517,28 @@ pub fn raw_scorer_half_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_scorer_half_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_scorer_half_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_scorer_half_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -489,6 +552,7 @@ fn new_scorer_half_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter_cell: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -496,6 +560,7 @@ fn new_scorer_half_with_metric<
             MetricQueryScorer::<VectorElementTypeHalf, TMetric, _>::new(
                 vector.try_into()?,
                 vector_storage,
+                hardware_counter_cell,
             ),
             point_deleted,
             vec_deleted,
@@ -507,6 +572,7 @@ fn new_scorer_half_with_metric<
                 CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter_cell,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -519,6 +585,7 @@ fn new_scorer_half_with_metric<
                 CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter_cell,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -531,6 +598,7 @@ fn new_scorer_half_with_metric<
                 CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter_cell,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -564,6 +632,7 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage<VectorElemen
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_multi_scorer_with_metric::<CosineMetric, _>(
@@ -571,24 +640,28 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage<VectorElemen
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -602,6 +675,7 @@ fn new_multi_scorer_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -609,6 +683,7 @@ fn new_multi_scorer_with_metric<
             MultiMetricQueryScorer::<VectorElementType, TMetric, _>::new(
                 &vector.try_into()?,
                 vector_storage,
+                hardware_counter,
             ),
             point_deleted,
             vec_deleted,
@@ -620,6 +695,7 @@ fn new_multi_scorer_with_metric<
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -633,6 +709,7 @@ fn new_multi_scorer_with_metric<
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -646,6 +723,7 @@ fn new_multi_scorer_with_metric<
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -660,6 +738,7 @@ pub fn raw_multi_scorer_byte_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_multi_scorer_byte_with_metric::<CosineMetric, _>(
@@ -667,24 +746,28 @@ pub fn raw_multi_scorer_byte_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_byte_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_byte_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_byte_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -698,6 +781,7 @@ fn new_multi_scorer_byte_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -705,6 +789,7 @@ fn new_multi_scorer_byte_with_metric<
             MultiMetricQueryScorer::<VectorElementTypeByte, TMetric, _>::new(
                 &vector.try_into()?,
                 vector_storage,
+                hardware_counter,
             ),
             point_deleted,
             vec_deleted,
@@ -716,6 +801,7 @@ fn new_multi_scorer_byte_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -729,6 +815,7 @@ fn new_multi_scorer_byte_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -742,6 +829,7 @@ fn new_multi_scorer_byte_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -756,6 +844,7 @@ pub fn raw_multi_scorer_half_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
         Distance::Cosine => new_multi_scorer_half_with_metric::<CosineMetric, _>(
@@ -763,24 +852,28 @@ pub fn raw_multi_scorer_half_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_half_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_half_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_half_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
             is_stopped,
+            hardware_counter,
         ),
     }
 }
@@ -794,6 +887,7 @@ fn new_multi_scorer_half_with_metric<
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
     is_stopped: &'a AtomicBool,
+    hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
     match query {
@@ -801,6 +895,7 @@ fn new_multi_scorer_half_with_metric<
             MultiMetricQueryScorer::<VectorElementTypeHalf, TMetric, _>::new(
                 &vector.try_into()?,
                 vector_storage,
+                hardware_counter,
             ),
             point_deleted,
             vec_deleted,
@@ -812,6 +907,7 @@ fn new_multi_scorer_half_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     reco_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -825,6 +921,7 @@ fn new_multi_scorer_half_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     discovery_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -838,6 +935,7 @@ fn new_multi_scorer_half_with_metric<
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
                     context_query,
                     vector_storage,
+                    hardware_counter,
                 ),
                 point_deleted,
                 vec_deleted,
@@ -955,10 +1053,6 @@ where
         let mut point_ids = 0..self.point_deleted.len() as PointOffsetType;
         self.peek_top_iter(&mut point_ids, top)
     }
-
-    fn take_hardware_counter(&self) -> HardwareCounterCell {
-        self.query_scorer.take_hardware_counter()
-    }
 }
 
 #[inline]

commit 012e293e04bc2b8cbe0dbc21d51d4de8e1376144
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 22 14:21:11 2025 +0000

    FixedLengthPriorityQueue: explicit sorted/unsorted methods (#5837)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d960b7d15..9f00b303d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1046,7 +1046,7 @@ where
             }
         }
 
-        pq.into_vec()
+        pq.into_sorted_vec()
     }
 
     fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index 9f00b303d..b077357d8 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -20,9 +20,9 @@ use crate::spaces::metric::Metric;
 use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
 use crate::types::Distance;
 use crate::vector_storage::common::VECTOR_READ_BATCH_SIZE;
+use crate::vector_storage::query_scorer::QueryScorer;
 use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
 use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQueryScorer;
-use crate::vector_storage::query_scorer::QueryScorer;
 
 /// RawScorer composition:
 ///

commit 724b45f18208ac2eba779a21bbf4646d3f9f6d49
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Mar 12 20:27:51 2025 +0000

    Add BitSliceExt::get_bit (#6162)

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index b077357d8..b838c1ddb 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -2,6 +2,7 @@ use std::sync::atomic::{AtomicBool, Ordering};
 
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::ext::BitSliceExt as _;
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 use sparse::common::sparse_vector::SparseVector;
@@ -1062,15 +1063,9 @@ pub fn check_deleted_condition(
     point_deleted: &BitSlice,
 ) -> bool {
     // Deleted points propagate to vectors; check vector deletion for possible early return
-    !vec_deleted
-            .get(point as usize)
-            .map(|x| *x)
-            // Default to not deleted if our deleted flags failed grow
-            .unwrap_or(false)
+    // Default to not deleted if our deleted flags failed grow
+    !vec_deleted.get_bit(point as usize).unwrap_or(false)
         // Additionally check point deletion for integrity if delete propagation to vector failed
-        && !point_deleted
-            .get(point as usize)
-            .map(|x| *x)
-            // Default to deleted if the point mapping was removed from the ID tracker
-            .unwrap_or(true)
+        // Default to deleted if the point mapping was removed from the ID tracker
+        && !point_deleted.get_bit(point as usize).unwrap_or(true)
 }

commit e114801ebfde19c080a39aa4fada7b50bafd1248
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Apr 3 04:01:39 2025 -0300

    `sum_scores` recommendation strategy (#6256)
    
    * Add in rest and grpc
    
    * add to QueryEnum
    
    * implement Query trait
    
    * connect to scorer creation
    
    * upd tests
    
    * additional changes
    
    * fmt
    
    * gen openapi and grpc docs
    
    * coderabbit fix
    
    * add changes in async scorer
    
    * test sum_scores in more places, refactor to remove repetition

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index b838c1ddb..d4653143d 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -7,7 +7,9 @@ use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
 use sparse::common::sparse_vector::SparseVector;
 
-use super::query::{ContextQuery, DiscoveryQuery, RecoQuery, TransformInto};
+use super::query::{
+    ContextQuery, DiscoveryQuery, RecoBestScoreQuery, RecoQuery, RecoSumScoresQuery, TransformInto,
+};
 use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
@@ -228,10 +230,27 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
         QueryVector::Nearest(_vector) => Err(OperationError::service_error(
             "Raw scorer must not be used for nearest queries",
         )),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
-                SparseCustomQueryScorer::<_, _>::new(reco_query, vector_storage, hardware_counter),
+                SparseCustomQueryScorer::<_, _>::new(
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
+            let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                SparseCustomQueryScorer::<_, _>::new(
+                    RecoSumScoresQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
                 point_deleted,
                 vec_deleted,
                 is_stopped,
@@ -359,11 +378,24 @@ fn new_scorer_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter,
                 ),
@@ -463,11 +495,24 @@ fn new_scorer_byte_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter,
                 ),
@@ -567,11 +612,24 @@ fn new_scorer_half_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
+            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter_cell,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 CustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter_cell,
                 ),
@@ -690,11 +748,24 @@ fn new_multi_scorer_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter,
                 ),
@@ -796,11 +867,24 @@ fn new_multi_scorer_byte_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeByte, TMetric, _, _, _>::new(
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter,
                 ),
@@ -902,11 +986,24 @@ fn new_multi_scorer_half_with_metric<
             vec_deleted,
             is_stopped,
         ),
-        QueryVector::Recommend(reco_query) => {
+        QueryVector::RecommendBestScore(reco_query) => {
+            let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
+            raw_scorer_from_query_scorer(
+                MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
+                    RecoBestScoreQuery::from(reco_query),
+                    vector_storage,
+                    hardware_counter,
+                ),
+                point_deleted,
+                vec_deleted,
+                is_stopped,
+            )
+        }
+        QueryVector::RecommendSumScores(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
             raw_scorer_from_query_scorer(
                 MultiCustomQueryScorer::<VectorElementTypeHalf, TMetric, _, _, _>::new(
-                    reco_query,
+                    RecoSumScoresQuery::from(reco_query),
                     vector_storage,
                     hardware_counter,
                 ),

commit 3d988e66c49c5edf7d3daceea801f30b01303afe
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 08:54:42 2025 +0000

    Remove is_stopped from RawScorer  (#6305)
    
    * Introduce CancelledError
    
    * Remove is_stopped from RawScorer

diff --git a/lib/segment/src/vector_storage/raw_scorer.rs b/lib/segment/src/vector_storage/raw_scorer.rs
index d4653143d..d2810b743 100644
--- a/lib/segment/src/vector_storage/raw_scorer.rs
+++ b/lib/segment/src/vector_storage/raw_scorer.rs
@@ -1,4 +1,4 @@
-use std::sync::atomic::{AtomicBool, Ordering};
+use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
@@ -14,7 +14,9 @@ use super::query_scorer::custom_query_scorer::CustomQueryScorer;
 use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
 use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
 use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
-use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::operation_error::{
+    CancellableResult, OperationError, OperationResult, check_process_stopped,
+};
 use crate::data_types::vectors::{
     DenseVector, MultiDenseVectorInternal, QueryVector, VectorElementType, VectorElementTypeByte,
     VectorElementTypeHalf,
@@ -42,8 +44,8 @@ use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQ
 ///  │                │   │              │
 ///  └────────────────┘   │    ┌─────┐   │        Query
 ///  - Deletions          │    │     │◄──┼───┐   ┌───────────────────┐
-///  - Stopping           │    └─────┘   │   │   │  - RecoQuery      │
-///  - Access patterns    │              │   │   │  - DiscoveryQuery │
+///  - Access patterns    │    └─────┘   │   │   │  - RecoQuery      │
+///                       │              │   │   │  - DiscoveryQuery │
 ///                       └──────────────┘   └───┤  - ContextQuery   │
 ///                       - Query holding        │                   │
 ///                       - Vector storage       └───────────────────┘
@@ -88,9 +90,14 @@ pub trait RawScorer {
         &self,
         points: &mut dyn Iterator<Item = PointOffsetType>,
         top: usize,
-    ) -> Vec<ScoredPointOffset>;
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<Vec<ScoredPointOffset>>;
 
-    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
+    fn peek_top_all(
+        &self,
+        top: usize,
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<Vec<ScoredPointOffset>>;
 }
 
 pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
@@ -105,42 +112,31 @@ where
     pub point_deleted: &'a BitSlice,
     /// [`BitSlice`] defining flags for deleted vectors in this segment.
     pub vec_deleted: &'a BitSlice,
-    /// This flag indicates that the search process is stopped externally,
-    /// the search result is no longer needed and the search process should be stopped as soon as possible.
-    pub is_stopped: &'a AtomicBool,
 
     vector: std::marker::PhantomData<*const TVector>,
 }
 
-pub fn new_stoppable_raw_scorer<'a>(
+pub fn new_raw_scorer<'a>(
     query: QueryVector,
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hc: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage {
-        VectorStorageEnum::DenseSimple(vs) => {
-            raw_scorer_impl(query, vs, point_deleted, is_stopped, hc)
-        }
+        VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, hc),
         VectorStorageEnum::DenseSimpleByte(vs) => {
-            raw_scorer_byte_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_scorer_byte_impl(query, vs, point_deleted, hc)
         }
         VectorStorageEnum::DenseSimpleHalf(vs) => {
-            raw_scorer_half_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_scorer_half_impl(query, vs, point_deleted, hc)
         }
 
         VectorStorageEnum::DenseMemmap(vs) => {
             if vs.has_async_reader() {
                 #[cfg(target_os = "linux")]
                 {
-                    let scorer_result = super::async_raw_scorer::new(
-                        query.clone(),
-                        vs,
-                        point_deleted,
-                        is_stopped,
-                        hc.fork(),
-                    );
+                    let scorer_result =
+                        super::async_raw_scorer::new(query.clone(), vs, point_deleted, hc.fork());
                     match scorer_result {
                         Ok(raw_scorer) => return Ok(raw_scorer),
                         Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
@@ -151,67 +147,63 @@ pub fn new_stoppable_raw_scorer<'a>(
                 log::warn!("async raw scorer is only supported on Linux");
             }
 
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
         }
 
         // TODO(byte_storage): Implement async raw scorer for DenseMemmapByte and DenseMemmapHalf
         VectorStorageEnum::DenseMemmapByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseMemmapHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
         }
 
         VectorStorageEnum::DenseAppendableMemmap(vs) => {
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseAppendableMemmapByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseAppendableMemmapHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseAppendableInRam(vs) => {
-            raw_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseAppendableInRamByte(vs) => {
-            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::DenseAppendableInRamHalf(vs) => {
-            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
-        }
-        VectorStorageEnum::SparseSimple(vs) => {
-            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped, hc)
-        }
-        VectorStorageEnum::SparseMmap(vs) => {
-            raw_sparse_scorer_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
         }
+        VectorStorageEnum::SparseSimple(vs) => raw_sparse_scorer_impl(query, vs, point_deleted, hc),
+        VectorStorageEnum::SparseMmap(vs) => raw_sparse_scorer_impl(query, vs, point_deleted, hc),
         VectorStorageEnum::MultiDenseSimple(vs) => {
-            raw_multi_scorer_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_multi_scorer_impl(query, vs, point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseSimpleByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_multi_scorer_byte_impl(query, vs, point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseSimpleHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs, point_deleted, is_stopped, hc)
+            raw_multi_scorer_half_impl(query, vs, point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
-            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRam(vs) => {
-            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => {
-            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
         }
         VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => {
-            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, is_stopped, hc)
+            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
         }
     }
 }
@@ -222,7 +214,6 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -240,7 +231,6 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -253,7 +243,6 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -266,7 +255,6 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -279,7 +267,6 @@ pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -291,36 +278,18 @@ pub fn new_raw_scorer_for_test<'a>(
     vector_storage: &'a VectorStorageEnum,
     point_deleted: &'a BitSlice,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
-    new_stoppable_raw_scorer(
+    new_raw_scorer(
         vector,
         vector_storage,
         point_deleted,
-        &DEFAULT_STOPPED,
         HardwareCounterCell::new(),
     )
 }
 
-pub fn new_raw_scorer<'a>(
-    vector: QueryVector,
-    vector_storage: &'a VectorStorageEnum,
-    point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
-    hardware_counter: HardwareCounterCell,
-) -> OperationResult<Box<dyn RawScorer + 'a>> {
-    new_stoppable_raw_scorer(
-        vector,
-        vector_storage,
-        point_deleted,
-        is_stopped,
-        hardware_counter,
-    )
-}
-
 pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>>(
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -328,28 +297,24 @@ pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_scorer_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_scorer_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_scorer_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -363,7 +328,6 @@ fn new_scorer_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -376,7 +340,6 @@ fn new_scorer_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
@@ -388,7 +351,6 @@ fn new_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -401,7 +363,6 @@ fn new_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -414,7 +375,6 @@ fn new_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -427,7 +387,6 @@ fn new_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -437,7 +396,6 @@ pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -445,28 +403,24 @@ pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_scorer_byte_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_scorer_byte_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_scorer_byte_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -480,7 +434,6 @@ fn new_scorer_byte_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -493,7 +446,6 @@ fn new_scorer_byte_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
@@ -505,7 +457,6 @@ fn new_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -518,7 +469,6 @@ fn new_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -531,7 +481,6 @@ fn new_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -544,7 +493,6 @@ fn new_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -554,7 +502,6 @@ pub fn raw_scorer_half_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -562,28 +509,24 @@ pub fn raw_scorer_half_impl<'a, TVectorStorage: DenseVectorStorage<VectorElement
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_scorer_half_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_scorer_half_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_scorer_half_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -597,7 +540,6 @@ fn new_scorer_half_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter_cell: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -610,7 +552,6 @@ fn new_scorer_half_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
@@ -622,7 +563,6 @@ fn new_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -635,7 +575,6 @@ fn new_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -648,7 +587,6 @@ fn new_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -661,7 +599,6 @@ fn new_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -671,7 +608,6 @@ pub fn raw_scorer_from_query_scorer<'a, TVector, TQueryScorer>(
     query_scorer: TQueryScorer,
     point_deleted: &'a BitSlice,
     vec_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
 ) -> OperationResult<Box<dyn RawScorer + 'a>>
 where
     TVector: ?Sized + 'a,
@@ -681,7 +617,6 @@ where
         query_scorer,
         point_deleted,
         vec_deleted,
-        is_stopped,
         vector: std::marker::PhantomData,
     }))
 }
@@ -690,7 +625,6 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage<VectorElemen
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -698,28 +632,24 @@ pub fn raw_multi_scorer_impl<'a, TVectorStorage: MultiVectorStorage<VectorElemen
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -733,7 +663,6 @@ fn new_multi_scorer_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -746,7 +675,6 @@ fn new_multi_scorer_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
@@ -758,7 +686,6 @@ fn new_multi_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -771,7 +698,6 @@ fn new_multi_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -785,7 +711,6 @@ fn new_multi_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -799,7 +724,6 @@ fn new_multi_scorer_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -809,7 +733,6 @@ pub fn raw_multi_scorer_byte_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -817,28 +740,24 @@ pub fn raw_multi_scorer_byte_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_byte_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_byte_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_byte_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -852,7 +771,6 @@ fn new_multi_scorer_byte_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -865,7 +783,6 @@ fn new_multi_scorer_byte_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
@@ -877,7 +794,6 @@ fn new_multi_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -890,7 +806,6 @@ fn new_multi_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -904,7 +819,6 @@ fn new_multi_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -918,7 +832,6 @@ fn new_multi_scorer_byte_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -928,7 +841,6 @@ pub fn raw_multi_scorer_half_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     match vector_storage.distance() {
@@ -936,28 +848,24 @@ pub fn raw_multi_scorer_half_impl<'a, TVectorStorage: MultiVectorStorage<VectorE
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Euclid => new_multi_scorer_half_with_metric::<EuclidMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Dot => new_multi_scorer_half_with_metric::<DotProductMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
         Distance::Manhattan => new_multi_scorer_half_with_metric::<ManhattanMetric, _>(
             query,
             vector_storage,
             point_deleted,
-            is_stopped,
             hardware_counter,
         ),
     }
@@ -971,7 +879,6 @@ fn new_multi_scorer_half_with_metric<
     query: QueryVector,
     vector_storage: &'a TVectorStorage,
     point_deleted: &'a BitSlice,
-    is_stopped: &'a AtomicBool,
     hardware_counter: HardwareCounterCell,
 ) -> OperationResult<Box<dyn RawScorer + 'a>> {
     let vec_deleted = vector_storage.deleted_vector_bitslice();
@@ -984,7 +891,6 @@ fn new_multi_scorer_half_with_metric<
             ),
             point_deleted,
             vec_deleted,
-            is_stopped,
         ),
         QueryVector::RecommendBestScore(reco_query) => {
             let reco_query: RecoQuery<MultiDenseVectorInternal> = reco_query.transform_into()?;
@@ -996,7 +902,6 @@ fn new_multi_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::RecommendSumScores(reco_query) => {
@@ -1009,7 +914,6 @@ fn new_multi_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Discovery(discovery_query) => {
@@ -1023,7 +927,6 @@ fn new_multi_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
         QueryVector::Context(context_query) => {
@@ -1037,7 +940,6 @@ fn new_multi_scorer_half_with_metric<
                 ),
                 point_deleted,
                 vec_deleted,
-                is_stopped,
             )
         }
     }
@@ -1049,9 +951,6 @@ where
     TQueryScorer: QueryScorer<TVector>,
 {
     fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize {
-        if self.is_stopped.load(Ordering::Relaxed) {
-            return 0;
-        }
         let mut size: usize = 0;
         for point_id in points.iter().copied() {
             if !self.check_vector(point_id) {
@@ -1074,9 +973,6 @@ where
         &self,
         points: &mut dyn Iterator<Item = PointOffsetType>,
     ) -> Vec<ScoredPointOffset> {
-        if self.is_stopped.load(Ordering::Relaxed) {
-            return vec![];
-        }
         let mut scores = vec![];
         for point_id in points {
             scores.push(ScoredPointOffset {
@@ -1103,9 +999,10 @@ where
         &self,
         points: &mut dyn Iterator<Item = PointOffsetType>,
         top: usize,
-    ) -> Vec<ScoredPointOffset> {
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<Vec<ScoredPointOffset>> {
         if top == 0 {
-            return vec![];
+            return Ok(vec![]);
         }
 
         let mut pq = FixedLengthPriorityQueue::new(top);
@@ -1116,9 +1013,7 @@ where
         loop {
             let mut chunk_size = 0;
             for point_id in &mut *points {
-                if self.is_stopped.load(Ordering::Relaxed) {
-                    break;
-                }
+                check_process_stopped(is_stopped)?;
                 if !self.check_vector(point_id) {
                     continue;
                 }
@@ -1144,12 +1039,16 @@ where
             }
         }
 
-        pq.into_sorted_vec()
+        Ok(pq.into_sorted_vec())
     }
 
-    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset> {
+    fn peek_top_all(
+        &self,
+        top: usize,
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<Vec<ScoredPointOffset>> {
         let mut point_ids = 0..self.point_deleted.len() as PointOffsetType;
-        self.peek_top_iter(&mut point_ids, top)
+        self.peek_top_iter(&mut point_ids, top, is_stopped)
     }
 }
 

