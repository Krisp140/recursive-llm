# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
new file mode 100644
index 000000000..398480521
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -0,0 +1,290 @@
+/* eslint-disable react-hooks/rules-of-hooks */
+import {
+	BaseBoxShapeUtil,
+	HTMLContainer,
+	TLImageShape,
+	TLOnDoubleClickHandler,
+	TLShapePartial,
+	Vec2d,
+	deepCopy,
+	imageShapeMigrations,
+	imageShapeProps,
+	toDomPrecision,
+	useIsCropping,
+	useValue,
+} from '@tldraw/editor'
+import { useEffect, useState } from 'react'
+import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
+
+const loadImage = async (url: string): Promise<HTMLImageElement> => {
+	return new Promise((resolve, reject) => {
+		const image = new Image()
+		image.onload = () => resolve(image)
+		image.onerror = () => reject(new Error('Failed to load image'))
+		image.crossOrigin = 'anonymous'
+		image.src = url
+	})
+}
+
+const getStateFrame = async (url: string) => {
+	const image = await loadImage(url)
+
+	const canvas = document.createElement('canvas')
+	canvas.width = image.width
+	canvas.height = image.height
+
+	const ctx = canvas.getContext('2d')
+	if (!ctx) return
+
+	ctx.drawImage(image, 0, 0)
+	return canvas.toDataURL()
+}
+
+async function getDataURIFromURL(url: string): Promise<string> {
+	const response = await fetch(url)
+	const blob = await response.blob()
+	return new Promise((resolve, reject) => {
+		const reader = new FileReader()
+		reader.onloadend = () => resolve(reader.result as string)
+		reader.onerror = reject
+		reader.readAsDataURL(blob)
+	})
+}
+
+/** @public */
+export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
+	static override type = 'image' as const
+	static override props = imageShapeProps
+	static override migrations = imageShapeMigrations
+
+	override isAspectRatioLocked = () => true
+	override canCrop = () => true
+
+	override getDefaultProps(): TLImageShape['props'] {
+		return {
+			w: 100,
+			h: 100,
+			assetId: null,
+			playing: true,
+			url: '',
+			crop: null,
+		}
+	}
+
+	component(shape: TLImageShape) {
+		const containerStyle = getContainerStyle(shape)
+		const isCropping = useIsCropping(shape.id)
+		const prefersReducedMotion = usePrefersReducedMotion()
+		const [staticFrameSrc, setStaticFrameSrc] = useState('')
+
+		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : undefined
+
+		if (asset?.type === 'bookmark') {
+			throw Error("Bookmark assets can't be rendered as images")
+		}
+
+		const isSelected = useValue(
+			'onlySelectedShape',
+			() => shape.id === this.editor.onlySelectedShape?.id,
+			[this.editor]
+		)
+
+		const showCropPreview =
+			isSelected &&
+			isCropping &&
+			this.editor.isInAny('select.crop', 'select.cropping', 'select.pointing_crop_handle')
+
+		// We only want to reduce motion for mimeTypes that have motion
+		const reduceMotion =
+			prefersReducedMotion &&
+			(asset?.props.mimeType?.includes('video') || asset?.props.mimeType?.includes('gif'))
+
+		useEffect(() => {
+			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {
+				let cancelled = false
+				const run = async () => {
+					const newStaticFrame = await getStateFrame(asset.props.src!)
+					if (cancelled) return
+					if (newStaticFrame) {
+						setStaticFrameSrc(newStaticFrame)
+					}
+				}
+				run()
+
+				return () => {
+					cancelled = true
+				}
+			}
+		}, [prefersReducedMotion, asset?.props])
+
+		return (
+			<>
+				{asset?.props.src && showCropPreview && (
+					<div style={containerStyle}>
+						<div
+							className={`tl-image tl-image-${shape.id}-crop`}
+							style={{
+								opacity: 0.1,
+								backgroundImage: `url(${
+									!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
+								})`,
+							}}
+							draggable={false}
+						/>
+					</div>
+				)}
+				<HTMLContainer id={shape.id} style={{ overflow: 'hidden' }}>
+					<div className="tl-image-container" style={containerStyle}>
+						{asset?.props.src ? (
+							<div
+								className={`tl-image tl-image-${shape.id}`}
+								style={{
+									backgroundImage: `url(${
+										!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
+									})`,
+								}}
+								draggable={false}
+							/>
+						) : null}
+						{asset?.props.isAnimated && !shape.props.playing && (
+							<div className="tl-image__tg">GIF</div>
+						)}
+					</div>
+				</HTMLContainer>
+				{'url' in shape.props && shape.props.url && (
+					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+				)}
+			</>
+		)
+	}
+
+	indicator(shape: TLImageShape) {
+		const isCropping = useIsCropping(shape.id)
+		if (isCropping) {
+			return null
+		}
+		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
+	}
+
+	override async toSvg(shape: TLImageShape) {
+		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : null
+
+		let src = asset?.props.src || ''
+		if (src && src.startsWith('http')) {
+			// If it's a remote image, we need to fetch it and convert it to a data URI
+			src = (await getDataURIFromURL(src)) || ''
+		}
+
+		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
+		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src)
+		const containerStyle = getContainerStyle(shape)
+		const crop = shape.props.crop
+		if (containerStyle && crop) {
+			const { transform, width, height } = containerStyle
+			const points = [
+				new Vec2d(crop.topLeft.x * width, crop.topLeft.y * height),
+				new Vec2d(crop.bottomRight.x * width, crop.topLeft.y * height),
+				new Vec2d(crop.bottomRight.x * width, crop.bottomRight.y * height),
+				new Vec2d(crop.topLeft.x * width, crop.bottomRight.y * height),
+			]
+			const innerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+			innerElement.style.clipPath = `polygon(${points.map((p) => `${p.x}px ${p.y}px`).join(',')})`
+			image.setAttribute('width', width.toString())
+			image.setAttribute('height', height.toString())
+			image.style.transform = transform
+			innerElement.appendChild(image)
+			g.appendChild(innerElement)
+		} else {
+			image.setAttribute('width', shape.props.w.toString())
+			image.setAttribute('height', shape.props.h.toString())
+			g.appendChild(image)
+		}
+
+		return g
+	}
+
+	override onDoubleClick = (shape: TLImageShape) => {
+		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : undefined
+
+		if (!asset) return
+
+		const canPlay =
+			asset.props.src && 'mimeType' in asset.props && asset.props.mimeType === 'image/gif'
+
+		if (!canPlay) return
+
+		this.editor.updateShapes([
+			{
+				type: 'image',
+				id: shape.id,
+				props: {
+					playing: !shape.props.playing,
+				},
+			},
+		])
+	}
+
+	override onDoubleClickEdge: TLOnDoubleClickHandler<TLImageShape> = (shape) => {
+		const props = shape.props
+		if (!props) return
+
+		if (this.editor.croppingId !== shape.id) {
+			return
+		}
+
+		const crop = deepCopy(props.crop) || {
+			topLeft: { x: 0, y: 0 },
+			bottomRight: { x: 1, y: 1 },
+		}
+
+		// The true asset dimensions
+		const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
+		const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
+
+		const pointDelta = new Vec2d(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)
+
+		const partial: TLShapePartial<TLImageShape> = {
+			id: shape.id,
+			type: shape.type,
+			x: shape.x - pointDelta.x,
+			y: shape.y - pointDelta.y,
+			props: {
+				crop: {
+					topLeft: { x: 0, y: 0 },
+					bottomRight: { x: 1, y: 1 },
+				},
+				w,
+				h,
+			},
+		}
+
+		this.editor.updateShapes([partial])
+	}
+}
+
+/**
+ * When an image is cropped we need to translate the image to show the portion withing the cropped
+ * area. We do this by translating the image by the negative of the top left corner of the crop
+ * area.
+ *
+ * @param shape - Shape The image shape for which to get the container style
+ * @returns - Styles to apply to the image container
+ */
+function getContainerStyle(shape: TLImageShape) {
+	const crop = shape.props.crop
+	const topLeft = crop?.topLeft
+	if (!topLeft) return
+
+	const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
+	const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
+
+	const offsetX = -topLeft.x * w
+	const offsetY = -topLeft.y * h
+	return {
+		transform: `translate(${offsetX}px, ${offsetY}px)`,
+		width: w,
+		height: h,
+	}
+}

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 398480521..15d0f11a6 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -78,7 +78,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
 
-		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : undefined
+		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
 		if (asset?.type === 'bookmark') {
 			throw Error("Bookmark assets can't be rendered as images")
@@ -169,7 +169,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 	override async toSvg(shape: TLImageShape) {
 		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : null
+		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null
 
 		let src = asset?.props.src || ''
 		if (src && src.startsWith('http')) {
@@ -206,7 +206,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 
 	override onDoubleClick = (shape: TLImageShape) => {
-		const asset = shape.props.assetId ? this.editor.getAssetById(shape.props.assetId) : undefined
+		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
 		if (!asset) return
 
@@ -230,7 +230,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const props = shape.props
 		if (!props) return
 
-		if (this.editor.croppingId !== shape.id) {
+		if (this.editor.croppingShapeId !== shape.id) {
 			return
 		}
 

commit 7a8e47cf8c07c2888bfc564ff00513c26aedd2d2
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Oct 3 15:26:24 2023 +0100

    [fix] Image size (#2002)
    
    This PR fixes an issue where images would overflow the shape's true
    height or width.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create an image shape.
    2. Resize the image shape and look at the edges.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 15d0f11a6..1079c5557 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -123,7 +123,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				{asset?.props.src && showCropPreview && (
 					<div style={containerStyle}>
 						<div
-							className={`tl-image tl-image-${shape.id}-crop`}
+							className="tl-image"
 							style={{
 								opacity: 0.1,
 								backgroundImage: `url(${
@@ -138,7 +138,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					<div className="tl-image-container" style={containerStyle}>
 						{asset?.props.src ? (
 							<div
-								className={`tl-image tl-image-${shape.id}`}
+								className="tl-image"
 								style={{
 									backgroundImage: `url(${
 										!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
@@ -181,7 +181,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src)
 		const containerStyle = getContainerStyle(shape)
 		const crop = shape.props.crop
-		if (containerStyle && crop) {
+		if (containerStyle.transform && crop) {
 			const { transform, width, height } = containerStyle
 			const points = [
 				new Vec2d(crop.topLeft.x * width, crop.topLeft.y * height),
@@ -275,7 +275,12 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 function getContainerStyle(shape: TLImageShape) {
 	const crop = shape.props.crop
 	const topLeft = crop?.topLeft
-	if (!topLeft) return
+	if (!topLeft) {
+		return {
+			width: shape.props.w,
+			height: shape.props.h,
+		}
+	}
 
 	const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
 	const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h

commit 21ac5749d0e584f384f92e85ab3f7ff1310b7698
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Oct 17 13:17:12 2023 +0100

    fix cropped image size (#2097)
    
    closes #2080
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Release Notes
    
    - Fixes a rendering issue where cropped images were sometimes bleeding
    outside their bounds.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 1079c5557..3c1485d7c 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -134,7 +134,10 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						/>
 					</div>
 				)}
-				<HTMLContainer id={shape.id} style={{ overflow: 'hidden' }}>
+				<HTMLContainer
+					id={shape.id}
+					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
+				>
 					<div className="tl-image-container" style={containerStyle}>
 						{asset?.props.src ? (
 							<div

commit 5719cc76c12c379d700e59912edb74127ded218e
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Tue Oct 31 13:34:23 2023 +0000

    [android] Fix text labels and link button getting misaligned (#2132)
    
    Fixes https://github.com/tldraw/tldraw/issues/2131
    
    Before:
    
    
    https://github.com/tldraw/tldraw/assets/15892272/c64d4ac5-6665-4c41-bf20-a5dbecdf4e1f
    
    After:
    
    ![2023-10-31 at 12 20 21 - Chocolate
    Dragonfly](https://github.com/tldraw/tldraw/assets/15892272/2b8ec620-8602-48ec-a0c1-e203b7eb1f38)
    
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. On android, make a geo shape.
    2. Add a text label to it.
    3. Add a link to it.
    4. Resize it.
    5. Make sure the label and link don't wiggle around.
    6. Repeat with a link on an image shape.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixed a bug where labels and links could lose alignment on android.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 3c1485d7c..e4107e971 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -154,10 +154,10 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							<div className="tl-image__tg">GIF</div>
 						)}
 					</div>
+					{'url' in shape.props && shape.props.url && (
+						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+					)}
 				</HTMLContainer>
-				{'url' in shape.props && shape.props.url && (
-					<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
-				)}
 			</>
 		)
 	}

commit 7ffda2335ce1c9b20e453436db438b08d03e9a87
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 14:31:27 2023 +0000

    No impure getters pt3 (#2203)
    
    Follow up to #2189 and #2202
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index e4107e971..5cc885f0e 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -86,7 +86,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		const isSelected = useValue(
 			'onlySelectedShape',
-			() => shape.id === this.editor.onlySelectedShape?.id,
+			() => shape.id === this.editor.getOnlySelectedShape()?.id,
 			[this.editor]
 		)
 

commit 6f872c796afd6cf538ce81d35c5a40dcccbe7013
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 11:57:43 2023 +0000

    No impure getters pt6 (#2218)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 5cc885f0e..23503cfe3 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -155,7 +155,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						)}
 					</div>
 					{'url' in shape.props && shape.props.url && (
-						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />
+						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
 					)}
 				</HTMLContainer>
 			</>

commit dc0f6ae0f25518342de828498998c5c7241da7b0
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 16:32:27 2023 +0000

    No impure getters pt8 (#2221)
    
    follow up to #2189
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 23503cfe3..576db5d90 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -233,7 +233,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const props = shape.props
 		if (!props) return
 
-		if (this.editor.croppingShapeId !== shape.id) {
+		if (this.editor.getCroppingShapeId() !== shape.id) {
 			return
 		}
 

commit dcf2ad98209beb2fdf173c2baeaadcf4bab2463b
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Dec 5 16:15:05 2023 +0100

    Fix exporting of cropped images. (#2268)
    
    Open this PR in different browsers, and you will see that the svg below
    will render differently in different browsers. The svg was exported from
    our staging.
    
    Seems like Chrome handles `clip-path` when set via the style differently
    than Safari and Firefox. I've reworked the logic so that it now uses a
    `clip-path` definition and applies that to the image.
    
    
    ![shape_xPSLLIG9yQkqAACrv1OxE](https://github.com/tldraw/tldraw/assets/2523721/4d0baba3-f5bf-4e78-96fe-aaa91ead107f)
    
    Also fixes a bunch of issues when copy pasting via the menu. It seems
    like we can't store the write function to a variable:
    
    ![image](https://github.com/tldraw/tldraw/assets/2523721/8d38edaf-8d63-462b-9f1a-c38960add7d7)
    
    
    Fixes https://github.com/tldraw/tldraw/issues/2254
    
    ### Before
    ![CleanShot 2023-11-30 at 09 30
    24](https://github.com/tldraw/tldraw/assets/2523721/93c06d5f-bfb2-4d97-8819-a8560c770304)
    
    ### After
    ![CleanShot 2023-11-30 at 09 30
    55](https://github.com/tldraw/tldraw/assets/2523721/29e0f699-d0e8-4fb2-b90e-1d14ee609e52)
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add an image, apply crop to it (best if you crop from all sides, just
    to make sure)
    2. Copy as png and make sure the image is correctly cropped in the
    created image.
    
    
    ### Release Notes
    
    - Fix exporting of cropped images.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 576db5d90..5aaba2250 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -186,14 +186,29 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const crop = shape.props.crop
 		if (containerStyle.transform && crop) {
 			const { transform, width, height } = containerStyle
+			const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
+			const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height
+
 			const points = [
-				new Vec2d(crop.topLeft.x * width, crop.topLeft.y * height),
-				new Vec2d(crop.bottomRight.x * width, crop.topLeft.y * height),
-				new Vec2d(crop.bottomRight.x * width, crop.bottomRight.y * height),
-				new Vec2d(crop.topLeft.x * width, crop.bottomRight.y * height),
+				new Vec2d(0, 0),
+				new Vec2d(croppedWidth, 0),
+				new Vec2d(croppedWidth, croppedHeight),
+				new Vec2d(0, croppedHeight),
 			]
+
+			const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')
+			polygon.setAttribute('points', points.map((p) => `${p.x},${p.y}`).join(' '))
+
+			const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')
+			clipPath.setAttribute('id', 'cropClipPath')
+			clipPath.appendChild(polygon)
+
+			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')
+			defs.appendChild(clipPath)
+			g.appendChild(defs)
+
 			const innerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-			innerElement.style.clipPath = `polygon(${points.map((p) => `${p.x}px ${p.y}px`).join(',')})`
+			innerElement.setAttribute('clip-path', 'url(#cropClipPath)')
 			image.setAttribute('width', width.toString())
 			image.setAttribute('height', height.toString())
 			image.style.transform = transform

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 5aaba2250..7ab4c26b2 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -5,7 +5,7 @@ import {
 	TLImageShape,
 	TLOnDoubleClickHandler,
 	TLShapePartial,
-	Vec2d,
+	Vec,
 	deepCopy,
 	imageShapeMigrations,
 	imageShapeProps,
@@ -190,10 +190,10 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height
 
 			const points = [
-				new Vec2d(0, 0),
-				new Vec2d(croppedWidth, 0),
-				new Vec2d(croppedWidth, croppedHeight),
-				new Vec2d(0, croppedHeight),
+				new Vec(0, 0),
+				new Vec(croppedWidth, 0),
+				new Vec(croppedWidth, croppedHeight),
+				new Vec(0, croppedHeight),
 			]
 
 			const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')
@@ -261,7 +261,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
 		const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
 
-		const pointDelta = new Vec2d(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)
+		const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)
 
 		const partial: TLShapePartial<TLImageShape> = {
 			id: shape.id,

commit 7ac003cc0589161d664c6d64a346dab224dc8d5d
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Jan 30 11:11:10 2024 +0100

    Fix svg exporting for images with not fully qualified url (`/tldraw.png` or `./tldraw.png`) (#2676)
    
    Local images (like in our Local images example) could not be exported as
    svg. We need to base64 encode them, but our check only matched images
    with a `http` prefix, which local images like `/tldraw.png` don't have.
    
    Fixes an issue reported here
    
    https://discord.com/channels/859816885297741824/1198343938155745280/1198343938155745280
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Use our Local images example.
    2. Export as svg.
    3. The export should correctly show the image.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fix the svg export for images that have a local url.
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 7ab4c26b2..7f2656952 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -170,12 +170,16 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
 
+	shouldGetDataURI(src: string) {
+		return src && (src.startsWith('http') || src.startsWith('/') || src.startsWith('./'))
+	}
+
 	override async toSvg(shape: TLImageShape) {
 		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null
 
 		let src = asset?.props.src || ''
-		if (src && src.startsWith('http')) {
+		if (this.shouldGetDataURI(src)) {
 			// If it's a remote image, we need to fetch it and convert it to a data URI
 			src = (await getDataURIFromURL(src)) || ''
 		}

commit 4cc823e22eab5d9e751a32c958e83d28d9eb8ec4
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Mar 1 18:16:27 2024 +0000

    Show a broken image for files without assets (#2990)
    
    This PR shows a broken state for images or video shapes without assets.
    It deletes assets when pasted content fails to generate a new asset for
    the shape. It includes some mild refactoring to the image shape.
    Previously, shapes that had no corresponding assets would be
    transparent. This PR preserves the transparent state for shapes with
    assets but without source data (ie loading assets).
    
    After:
    <img width="1062" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/81ad6953-a45f-4cc2-9f39-559009621a82">
    <img width="1158" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/40d15158-d201-458f-b555-6f3d8708a283">
    
    Before:
    <img width="1178" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/2bed5b3c-cf1f-48be-9c68-d15fdccb9c99">
    
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create an image / video
    2. Delete its asset
    
    ### Release Notes
    
    - Better handling of broken images / videos.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 7f2656952..784a4db90 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -10,37 +10,12 @@ import {
 	imageShapeMigrations,
 	imageShapeProps,
 	toDomPrecision,
-	useIsCropping,
-	useValue,
 } from '@tldraw/editor'
 import { useEffect, useState } from 'react'
+import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
-const loadImage = async (url: string): Promise<HTMLImageElement> => {
-	return new Promise((resolve, reject) => {
-		const image = new Image()
-		image.onload = () => resolve(image)
-		image.onerror = () => reject(new Error('Failed to load image'))
-		image.crossOrigin = 'anonymous'
-		image.src = url
-	})
-}
-
-const getStateFrame = async (url: string) => {
-	const image = await loadImage(url)
-
-	const canvas = document.createElement('canvas')
-	canvas.width = image.width
-	canvas.height = image.height
-
-	const ctx = canvas.getContext('2d')
-	if (!ctx) return
-
-	ctx.drawImage(image, 0, 0)
-	return canvas.toDataURL()
-}
-
 async function getDataURIFromURL(url: string): Promise<string> {
 	const response = await fetch(url)
 	const blob = await response.blob()
@@ -73,23 +48,47 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 
 	component(shape: TLImageShape) {
-		const containerStyle = getContainerStyle(shape)
-		const isCropping = useIsCropping(shape.id)
+		const isCropping = this.editor.getCroppingShapeId() === shape.id
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
 
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
+		const isSelected = shape.id === this.editor.getOnlySelectedShape()?.id
+
+		useEffect(() => {
+			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {
+				let cancelled = false
+				const url = asset.props.src
+				if (!url) return
+
+				const image = new Image()
+				image.onload = () => {
+					if (cancelled) return
+
+					const canvas = document.createElement('canvas')
+					canvas.width = image.width
+					canvas.height = image.height
+
+					const ctx = canvas.getContext('2d')
+					if (!ctx) return
+
+					ctx.drawImage(image, 0, 0)
+					setStaticFrameSrc(canvas.toDataURL())
+				}
+				image.crossOrigin = 'anonymous'
+				image.src = url
+
+				return () => {
+					cancelled = true
+				}
+			}
+		}, [prefersReducedMotion, asset?.props])
+
 		if (asset?.type === 'bookmark') {
 			throw Error("Bookmark assets can't be rendered as images")
 		}
 
-		const isSelected = useValue(
-			'onlySelectedShape',
-			() => shape.id === this.editor.getOnlySelectedShape()?.id,
-			[this.editor]
-		)
-
 		const showCropPreview =
 			isSelected &&
 			isCropping &&
@@ -100,27 +99,35 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			prefersReducedMotion &&
 			(asset?.props.mimeType?.includes('video') || asset?.props.mimeType?.includes('gif'))
 
-		useEffect(() => {
-			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {
-				let cancelled = false
-				const run = async () => {
-					const newStaticFrame = await getStateFrame(asset.props.src!)
-					if (cancelled) return
-					if (newStaticFrame) {
-						setStaticFrameSrc(newStaticFrame)
-					}
-				}
-				run()
+		const containerStyle = getCroppedContainerStyle(shape)
 
-				return () => {
-					cancelled = true
-				}
-			}
-		}, [prefersReducedMotion, asset?.props])
+		if (!asset?.props.src) {
+			return (
+				<HTMLContainer
+					id={shape.id}
+					style={{
+						overflow: 'hidden',
+						width: shape.props.w,
+						height: shape.props.h,
+						color: 'var(--color-text-3)',
+						backgroundColor: asset ? 'transparent' : 'var(--color-low)',
+						border: asset ? 'none' : '1px solid var(--color-low-border)',
+					}}
+				>
+					<div className="tl-image-container" style={containerStyle}>
+						{asset ? null : <BrokenAssetIcon />}
+					</div>
+					)
+					{'url' in shape.props && shape.props.url && (
+						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
+					)}
+				</HTMLContainer>
+			)
+		}
 
 		return (
 			<>
-				{asset?.props.src && showCropPreview && (
+				{showCropPreview && (
 					<div style={containerStyle}>
 						<div
 							className="tl-image"
@@ -139,22 +146,21 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
 				>
 					<div className="tl-image-container" style={containerStyle}>
-						{asset?.props.src ? (
-							<div
-								className="tl-image"
-								style={{
-									backgroundImage: `url(${
-										!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
-									})`,
-								}}
-								draggable={false}
-							/>
-						) : null}
-						{asset?.props.isAnimated && !shape.props.playing && (
+						<div
+							className="tl-image"
+							style={{
+								backgroundImage: `url(${
+									!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
+								})`,
+							}}
+							draggable={false}
+						/>
+						{asset.props.isAnimated && !shape.props.playing && (
 							<div className="tl-image__tg">GIF</div>
 						)}
 					</div>
-					{'url' in shape.props && shape.props.url && (
+					)
+					{shape.props.url && (
 						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
 					)}
 				</HTMLContainer>
@@ -163,30 +169,26 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 
 	indicator(shape: TLImageShape) {
-		const isCropping = useIsCropping(shape.id)
-		if (isCropping) {
-			return null
-		}
+		const isCropping = this.editor.getCroppingShapeId() === shape.id
+		if (isCropping) return null
 		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
 
-	shouldGetDataURI(src: string) {
-		return src && (src.startsWith('http') || src.startsWith('/') || src.startsWith('./'))
-	}
-
 	override async toSvg(shape: TLImageShape) {
 		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null
 
+		if (!asset) return g
+
 		let src = asset?.props.src || ''
-		if (this.shouldGetDataURI(src)) {
+		if (src.startsWith('http') || src.startsWith('/') || src.startsWith('./')) {
 			// If it's a remote image, we need to fetch it and convert it to a data URI
 			src = (await getDataURIFromURL(src)) || ''
 		}
 
 		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
 		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src)
-		const containerStyle = getContainerStyle(shape)
+		const containerStyle = getCroppedContainerStyle(shape)
 		const crop = shape.props.crop
 		if (containerStyle.transform && crop) {
 			const { transform, width, height } = containerStyle
@@ -294,7 +296,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
  * @param shape - Shape The image shape for which to get the container style
  * @returns - Styles to apply to the image container
  */
-function getContainerStyle(shape: TLImageShape) {
+function getCroppedContainerStyle(shape: TLImageShape) {
 	const crop = shape.props.crop
 	const topLeft = crop?.topLeft
 	if (!topLeft) {

commit dba6d4c414fa571519e252d581e3489101280acc
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Mar 12 09:10:18 2024 +0000

    chore: cleanup multiple uses of FileReader (#3110)
    
    from
    https://discord.com/channels/859816885297741824/1006133967642177556/1213038401465618433
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 784a4db90..c521124e3 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -1,6 +1,7 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
+	FileHelpers,
 	HTMLContainer,
 	TLImageShape,
 	TLOnDoubleClickHandler,
@@ -19,12 +20,7 @@ import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 async function getDataURIFromURL(url: string): Promise<string> {
 	const response = await fetch(url)
 	const blob = await response.blob()
-	return new Promise((resolve, reject) => {
-		const reader = new FileReader()
-		reader.onloadend = () => resolve(reader.result as string)
-		reader.onerror = reject
-		reader.readAsDataURL(blob)
-	})
+	return FileHelpers.fileToBase64(blob)
 }
 
 /** @public */

commit 0a48aea7bb042ceaebf692e04cbdd0c97074d709
Author: alex <alex@dytry.ch>
Date:   Tue Mar 12 16:51:29 2024 +0000

    fixup file helpers (#3130)
    
    We had a couple regressions in #3110: first a missing `await` was
    causing fonts not to get properly embedded in exports. second, some
    `readAsText` calls were replaced with `readAsDataURL` calls.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index c521124e3..18003f450 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -20,7 +20,7 @@ import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 async function getDataURIFromURL(url: string): Promise<string> {
 	const response = await fetch(url)
 	const blob = await response.blob()
-	return FileHelpers.fileToBase64(blob)
+	return FileHelpers.blobToDataUrl(blob)
 }
 
 /** @public */

commit d7b80baa316237ee2ad982d4ae96df2ecc795065
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Mar 18 17:16:09 2024 +0000

    use native structuredClone on node, cloudflare workers, and in tests (#3166)
    
    Currently, we only use native `structuredClone` in the browser, falling
    back to `JSON.parse(JSON.stringify(...))` elsewhere, despite Node
    supporting `structuredClone` [since
    v17](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    and Cloudflare Workers supporting it [since
    2022](https://blog.cloudflare.com/standards-compliant-workers-api/).
    This PR adjusts our shim to use the native `structuredClone` on all
    platforms, if available.
    
    Additionally, `jsdom` doesn't implement `structuredClone`, a bug [open
    since 2022](https://github.com/jsdom/jsdom/issues/3363). This PR patches
    `jsdom` environment in all packages/apps that use it for tests.
    
    Also includes a driveby removal of `deepCopy`, a function that is
    strictly inferior to `structuredClone`.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [x] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. A smoke test would be enough
    
    - [ ] Unit Tests
    - [x] End to end tests

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 18003f450..28dea94ea 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -7,9 +7,9 @@ import {
 	TLOnDoubleClickHandler,
 	TLShapePartial,
 	Vec,
-	deepCopy,
 	imageShapeMigrations,
 	imageShapeProps,
+	structuredClone,
 	toDomPrecision,
 } from '@tldraw/editor'
 import { useEffect, useState } from 'react'
@@ -254,7 +254,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			return
 		}
 
-		const crop = deepCopy(props.crop) || {
+		const crop = structuredClone(props.crop) || {
 			topLeft: { x: 0, y: 0 },
 			bottomRight: { x: 1, y: 1 },
 		}

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 28dea94ea..8a7a05ddf 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -171,10 +171,9 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 
 	override async toSvg(shape: TLImageShape) {
-		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null
 
-		if (!asset) return g
+		if (!asset) return null
 
 		let src = asset?.props.src || ''
 		if (src.startsWith('http') || src.startsWith('/') || src.startsWith('./')) {
@@ -182,8 +181,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			src = (await getDataURIFromURL(src)) || ''
 		}
 
-		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
-		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src)
 		const containerStyle = getCroppedContainerStyle(shape)
 		const crop = shape.props.crop
 		if (containerStyle.transform && crop) {
@@ -198,31 +195,22 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				new Vec(0, croppedHeight),
 			]
 
-			const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')
-			polygon.setAttribute('points', points.map((p) => `${p.x},${p.y}`).join(' '))
-
-			const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')
-			clipPath.setAttribute('id', 'cropClipPath')
-			clipPath.appendChild(polygon)
-
-			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')
-			defs.appendChild(clipPath)
-			g.appendChild(defs)
-
-			const innerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-			innerElement.setAttribute('clip-path', 'url(#cropClipPath)')
-			image.setAttribute('width', width.toString())
-			image.setAttribute('height', height.toString())
-			image.style.transform = transform
-			innerElement.appendChild(image)
-			g.appendChild(innerElement)
+			const cropClipId = `cropClipPath_${shape.id.replace(':', '_')}`
+			return (
+				<>
+					<defs>
+						<clipPath id={cropClipId}>
+							<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />
+						</clipPath>
+					</defs>
+					<g clipPath="url(#{cropClipId})">
+						<image href={src} width={width} height={height} style={{ transform }} />
+					</g>
+				</>
+			)
 		} else {
-			image.setAttribute('width', shape.props.w.toString())
-			image.setAttribute('height', shape.props.h.toString())
-			g.appendChild(image)
+			return <image href={src} width={shape.props.w} height={shape.props.h} />
 		}
-
-		return g
 	}
 
 	override onDoubleClick = (shape: TLImageShape) => {

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 8a7a05ddf..4d2ae51a6 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -50,7 +50,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
-		const isSelected = shape.id === this.editor.getOnlySelectedShape()?.id
+		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 
 		useEffect(() => {
 			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {

commit d2d3e582e5c71bb15a710ed890270db728971ba6
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon May 13 09:29:43 2024 +0100

    assets: rework mime-type detection to be consistent/centralized; add support for webp/webm, apng, avif (#3730)
    
    As I started working on image LOD stuff and wrapping my head around the
    codebase, this was bothering me.
    - there are missing popular types, especially WebP
    - there are places where we're copy/pasting the same list of types but
    they can get out-of-date with each other (also, one place described
    supporting webm but we didn't actually do that)
    
    This adds animated apng/avif detection as well (alongside our animated
    gif detection). Furthermore, it moves the gif logic to be alongside the
    png logic (they were in separate packages unnecessarily)
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Release Notes
    
    - Images: unify list of acceptable types and expand to include webp,
    webm, apng, avif

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 4d2ae51a6..a69c9a660 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -3,6 +3,7 @@ import {
 	BaseBoxShapeUtil,
 	FileHelpers,
 	HTMLContainer,
+	MediaHelpers,
 	TLImageShape,
 	TLOnDoubleClickHandler,
 	TLShapePartial,
@@ -43,6 +44,17 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		}
 	}
 
+	isAnimated(shape: TLImageShape) {
+		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
+
+		if (!asset) return false
+
+		return (
+			('mimeType' in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType)) ||
+			('isAnimated' in asset.props && asset.props.isAnimated)
+		)
+	}
+
 	component(shape: TLImageShape) {
 		const isCropping = this.editor.getCroppingShapeId() === shape.id
 		const prefersReducedMotion = usePrefersReducedMotion()
@@ -53,7 +65,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 
 		useEffect(() => {
-			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {
+			if (asset?.props.src && this.isAnimated(shape)) {
 				let cancelled = false
 				const url = asset.props.src
 				if (!url) return
@@ -79,7 +91,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					cancelled = true
 				}
 			}
-		}, [prefersReducedMotion, asset?.props])
+		}, [prefersReducedMotion, asset?.props, shape])
 
 		if (asset?.type === 'bookmark') {
 			throw Error("Bookmark assets can't be rendered as images")
@@ -92,8 +104,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		// We only want to reduce motion for mimeTypes that have motion
 		const reduceMotion =
-			prefersReducedMotion &&
-			(asset?.props.mimeType?.includes('video') || asset?.props.mimeType?.includes('gif'))
+			prefersReducedMotion && (asset?.props.mimeType?.includes('video') || this.isAnimated(shape))
 
 		const containerStyle = getCroppedContainerStyle(shape)
 
@@ -151,7 +162,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							}}
 							draggable={false}
 						/>
-						{asset.props.isAnimated && !shape.props.playing && (
+						{this.isAnimated(shape) && !shape.props.playing && (
 							<div className="tl-image__tg">GIF</div>
 						)}
 					</div>
@@ -218,8 +229,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		if (!asset) return
 
-		const canPlay =
-			asset.props.src && 'mimeType' in asset.props && asset.props.mimeType === 'image/gif'
+		const canPlay = asset.props.src && this.isAnimated(shape)
 
 		if (!canPlay) return
 

commit 93cfd250e9987351e3115b24af36ff2ab3471f6f
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Tue May 28 10:49:28 2024 +0100

    Fix cropped image export (#3837)
    
    Fix cropped images not exporting right
    
    <img width="780" alt="image"
    src="https://github.com/tldraw/tldraw/assets/15892272/41928af4-f222-4b71-bbcd-90b9df375019">
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Make an image shape.
    2. Crop it.
    3. Export it.
    4. Check it looks right.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixed cropped images not exporting properly

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index a69c9a660..2336bb4a9 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -214,7 +214,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />
 						</clipPath>
 					</defs>
-					<g clipPath="url(#{cropClipId})">
+					<g clipPath={`url(#${cropClipId})`}>
 						<image href={src} width={width} height={height} style={{ transform }} />
 					</g>
 				</>

commit b7bc2dbbce6a3c53c4ed7c95201c2f82ad5df4ef
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jun 5 11:52:10 2024 +0100

    security: don't send referrer paths for images and bookmarks (#3881)
    
    We're currently sending `referrer` with path for image/bookmark
    requests. We shouldn't do that as it exposes the rooms to other servers.
    
    ## `<img>`
    - `<img>` tags have the right referrerpolicy to be
    `strict-origin-when-cross-origin`:
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#referrerpolicy
    - _however_, because we use React, it looks like react creates a raw DOM
    node and adds properties one by one and it loses the default
    referrerpolicy it would otherwise get! So, in `BookmarkShapeUtil` we
    explicitly state the `referrerpolicy`
    - `background-image` does the right thing 👍
    - _also_, I added this to places we do programmatic `new Image()`
    
    ## `fetch`
    - _however_, fetch does not! wtf.
    https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    
    it's almost a footnote in this section of the docs
    (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options)
    that `no-referrer-when-downgrade` is the default.
    
    ## `new Image()`
    ugh, but _also_ doing a programmatic `new Image()` doesn't do the right
    thing and we need to set the referrerpolicy here as well
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test on staging that referrer with path isn't being sent anymore.
    
    ### Release Notes
    
    - Security: fix referrer being sent for bookmarks and images.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 2336bb4a9..99a342fdf 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -19,7 +19,7 @@ import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 async function getDataURIFromURL(url: string): Promise<string> {
-	const response = await fetch(url)
+	const response = await fetch(url, { referrerPolicy: 'strict-origin-when-cross-origin' })
 	const blob = await response.blob()
 	return FileHelpers.blobToDataUrl(blob)
 }
@@ -85,6 +85,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					setStaticFrameSrc(canvas.toDataURL())
 				}
 				image.crossOrigin = 'anonymous'
+				image.referrerPolicy = 'strict-origin-when-cross-origin'
 				image.src = url
 
 				return () => {

commit 25dcc29803938c61f1cebe2fdbb0595e21820677
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Jun 11 07:13:03 2024 +0100

    Cropping undo/redo UX (#3891)
    
    This PR aims to improve the UX around undo/redo and cropping. Before the
    PR if you do some cropping, then stop cropping, then hit `undo`, you
    will end up back in the cropping state and it will undo each of your
    resize/translate cropping operations individually. This is weird 🙅🏼 It
    should just undo the whole sequence of changes that happened during
    cropping.
    
    To achieve that, this PR introduces a new history method called
    `squashToMark`, which strips out all the marks between the current head
    of the undo stack and the mark id you pass in.
    
    This PR also makes the default history record mode of
    `updateCurrentPageState` to `ignore` like it already was for
    `updateInstanceState`. The fact that it was recording changes to the
    `croppingShapeId` was the reason that hitting undo would put you back
    into the cropping state.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 99a342fdf..a9c8ea30d 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -98,10 +98,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			throw Error("Bookmark assets can't be rendered as images")
 		}
 
-		const showCropPreview =
-			isSelected &&
-			isCropping &&
-			this.editor.isInAny('select.crop', 'select.cropping', 'select.pointing_crop_handle')
+		const showCropPreview = isSelected && isCropping && this.editor.isIn('select.crop')
 
 		// We only want to reduce motion for mimeTypes that have motion
 		const reduceMotion =

commit 3adae06d9c1db0b047bf44d2dc216841bcbc6ce8
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 14:59:25 2024 +0100

    security: enforce use of our fetch function and its default referrerpolicy (#3884)
    
    followup to https://github.com/tldraw/tldraw/pull/3881 to enforce this
    in the codebase
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index a9c8ea30d..897a63ee2 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -3,11 +3,13 @@ import {
 	BaseBoxShapeUtil,
 	FileHelpers,
 	HTMLContainer,
+	Image,
 	MediaHelpers,
 	TLImageShape,
 	TLOnDoubleClickHandler,
 	TLShapePartial,
 	Vec,
+	fetch,
 	imageShapeMigrations,
 	imageShapeProps,
 	structuredClone,
@@ -19,7 +21,7 @@ import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 async function getDataURIFromURL(url: string): Promise<string> {
-	const response = await fetch(url, { referrerPolicy: 'strict-origin-when-cross-origin' })
+	const response = await fetch(url)
 	const blob = await response.blob()
 	return FileHelpers.blobToDataUrl(blob)
 }
@@ -70,7 +72,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				const url = asset.props.src
 				if (!url) return
 
-				const image = new Image()
+				const image = Image()
 				image.onload = () => {
 					if (cancelled) return
 

commit 6c846716c343e1ad40839f0f2bab758f58b4284d
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 15:17:09 2024 +0100

    assets: make option to transform urls dynamically / LOD (#3827)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3764
    
    This continues the idea kicked off in
    https://github.com/tldraw/tldraw/pull/3684 to explore LOD and takes it
    in a different direction.
    
    Several things here to call out:
    - our dotcom version would start to use Cloudflare's image transforms
    - we don't rewrite non-image assets
    - we debounce zooming so that we're not swapping out images while
    zooming (it creates jank)
    - we load different images based on steps of .25 (maybe we want to make
    this more, like 0.33). Feels like 0.5 might be a bit too much but we can
    play around with it.
    - we take into account network connection speed. if you're on 3g, for
    example, we have the size of the image.
    - dpr is taken into account - in our case, Cloudflare handles it. But if
    it wasn't Cloudflare, we could add it to our width equation.
    - we use Cloudflare's `fit=scale-down` setting to never scale _up_ an
    image.
    - we don't swap the image in until we've finished loading it
    programatically (to avoid a blank image while it loads)
    
    TODO
    - [x] We need to enable Cloudflare's pricing on image transforms btw
    @steveruizok 😉 - this won't work quite yet until we do that.
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [x] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test images on staging, small, medium, large, mega
    2. Test videos on staging
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Assets: make option to transform urls dynamically to provide different
    sized images on demand.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 897a63ee2..bc31e6338 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -18,6 +18,7 @@ import {
 import { useEffect, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { useAsset } from '../shared/useAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 async function getDataURIFromURL(url: string): Promise<string> {
@@ -61,15 +62,35 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const isCropping = this.editor.getCroppingShapeId() === shape.id
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
+		const [loadedSrc, setLoadedSrc] = useState('')
+		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
+		const { asset, url } = useAsset(shape.props.assetId, shape.props.w)
 
-		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
+		useEffect(() => {
+			// If an image is not animated (that's handled below), then we preload the image
+			// because we might have different source urls for different zoom levels.
+			// Preloading the image ensures that the browser caches the image and doesn't
+			// cause visual flickering when the image is loaded.
+			if (url && !this.isAnimated(shape)) {
+				let cancelled = false
+				if (!url) return
 
-		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
+				const image = Image()
+				image.onload = () => {
+					if (cancelled) return
+					setLoadedSrc(url)
+				}
+				image.src = url
+
+				return () => {
+					cancelled = true
+				}
+			}
+		}, [url, shape])
 
 		useEffect(() => {
-			if (asset?.props.src && this.isAnimated(shape)) {
+			if (url && this.isAnimated(shape)) {
 				let cancelled = false
-				const url = asset.props.src
 				if (!url) return
 
 				const image = Image()
@@ -85,6 +106,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 					ctx.drawImage(image, 0, 0)
 					setStaticFrameSrc(canvas.toDataURL())
+					setLoadedSrc(url)
 				}
 				image.crossOrigin = 'anonymous'
 				image.referrerPolicy = 'strict-origin-when-cross-origin'
@@ -94,7 +116,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					cancelled = true
 				}
 			}
-		}, [prefersReducedMotion, asset?.props, shape])
+		}, [prefersReducedMotion, url, shape])
 
 		if (asset?.type === 'bookmark') {
 			throw Error("Bookmark assets can't be rendered as images")
@@ -108,7 +130,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		const containerStyle = getCroppedContainerStyle(shape)
 
-		if (!asset?.props.src) {
+		if (!url) {
 			return (
 				<HTMLContainer
 					id={shape.id}
@@ -141,7 +163,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							style={{
 								opacity: 0.1,
 								backgroundImage: `url(${
-									!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
+									!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc
 								})`,
 							}}
 							draggable={false}
@@ -157,7 +179,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							className="tl-image"
 							style={{
 								backgroundImage: `url(${
-									!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
+									!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc
 								})`,
 							}}
 							draggable={false}

commit 69e6dbc407d2ad76d0cec0e002da88f5533e8d57
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Jun 13 09:43:38 2024 +0100

    images: avoid double request for animated images (#3924)
    
    right now, for animated images, we end up doing _two_ requests because
    we're trying to create a static frame if someone wants to pause the
    animation.
    
    <img width="1479" alt="Screenshot 2024-06-11 at 16 26 28"
    src="https://github.com/tldraw/tldraw/assets/469604/d3d8b93c-7349-4a7f-ba5d-be005a87f2ae">
    
    
    the problem is that the two requests are slightly different:
    1.) there's one request via a JS `Image` call that sets a
    `crossorigin="anonymous"`
    2.) the other request is the basic image request via setting a
    background-image, but this doesn't specify a crossorigin, hence it
    causes a separate request.
    
    this converts the image rendering to not use a div+background-image but
    to use a regular image tag and make the crossorigin consistent for
    animated images. you'll note that we _don't_ set crossorigin for
    non-animated and that's because for the new Cloudflare images the
    headers don't send back access-control headers (at the moment, until we
    want to set up workers).
    
    drive-by cleanup to remove `strict-origin-when-cross-origin` that should
    have been removed in https://github.com/tldraw/tldraw/pull/3884
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    ### Release Notes
    
    - Images: avoid double request for animated images.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index bc31e6338..131b339cc 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -109,7 +109,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					setLoadedSrc(url)
 				}
 				image.crossOrigin = 'anonymous'
-				image.referrerPolicy = 'strict-origin-when-cross-origin'
 				image.src = url
 
 				return () => {
@@ -158,13 +157,15 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			<>
 				{showCropPreview && (
 					<div style={containerStyle}>
-						<div
+						<img
 							className="tl-image"
+							// We don't set crossOrigin for non-animated images because
+							// for Cloudflare we don't currenly have that set up.
+							crossOrigin={this.isAnimated(shape) ? 'anonymous' : undefined}
+							src={!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc}
+							referrerPolicy="strict-origin-when-cross-origin"
 							style={{
 								opacity: 0.1,
-								backgroundImage: `url(${
-									!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc
-								})`,
 							}}
 							draggable={false}
 						/>
@@ -175,13 +176,13 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
 				>
 					<div className="tl-image-container" style={containerStyle}>
-						<div
+						<img
 							className="tl-image"
-							style={{
-								backgroundImage: `url(${
-									!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc
-								})`,
-							}}
+							// We don't set crossOrigin for non-animated images because
+							// for Cloudflare we don't currenly have that set up.
+							crossOrigin={this.isAnimated(shape) ? 'anonymous' : undefined}
+							src={!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc}
+							referrerPolicy="strict-origin-when-cross-origin"
 							draggable={false}
 						/>
 						{this.isAnimated(shape) && !shape.props.playing && (

commit 73c2b1088a1c4ab308fd6f71e5148bffc74c546b
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Fri Jun 14 11:01:50 2024 +0100

    image: follow-up fixes for LOD (#3934)
    
    couple fixes and improvements for the LOD work.
    
    - add `format=auto` for Cloudflare to send back more modern image
    formats
    - fix the broken asset logic that regressed (should not have looked at
    `url`)
    - fix stray parenthesis, omg
    - rm the `useValueDebounced` function in lieu of just debouncing the
    resolver. the problem was that the initial load in a multiplayer room
    has a zoom of 1 but then the real zoom comes in (via the url) and so we
    would double load all images 😬. this switches the debouncing to the
    resolving stage, not making it tied to the zoom specifically.
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 131b339cc..d9eb3a710 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -73,7 +73,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			// cause visual flickering when the image is loaded.
 			if (url && !this.isAnimated(shape)) {
 				let cancelled = false
-				if (!url) return
 
 				const image = Image()
 				image.onload = () => {
@@ -91,7 +90,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		useEffect(() => {
 			if (url && this.isAnimated(shape)) {
 				let cancelled = false
-				if (!url) return
 
 				const image = Image()
 				image.onload = () => {
@@ -129,7 +127,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		const containerStyle = getCroppedContainerStyle(shape)
 
-		if (!url) {
+		// This is specifically `asset?.props.src` and not `url` because we're looking for broken assets.
+		if (!asset?.props.src) {
 			return (
 				<HTMLContainer
 					id={shape.id}
@@ -145,7 +144,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					<div className="tl-image-container" style={containerStyle}>
 						{asset ? null : <BrokenAssetIcon />}
 					</div>
-					)
 					{'url' in shape.props && shape.props.url && (
 						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
 					)}
@@ -153,6 +151,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			)
 		}
 
+		if (!loadedSrc) return null
+
 		return (
 			<>
 				{showCropPreview && (
@@ -189,7 +189,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 							<div className="tl-image__tg">GIF</div>
 						)}
 					</div>
-					)
 					{shape.props.url && (
 						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
 					)}

commit 735161c4a81fb617805ffb7f76a274954ec1d2f4
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Fri Jun 14 11:23:52 2024 +0100

    assets: store in indexedDB, not as base64 (#3836)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3745
    
    As I look at LOD holistically and whether we have multiple sources when
    working locally, I learned that our system used base64 encoding of
    assets directly. Issue https://github.com/tldraw/tldraw/issues/3728
    
    <img width="1350" alt="assetstore"
    src="https://github.com/tldraw/tldraw/assets/469604/e7b41e29-6656-4d9b-b462-72d43b98f3f7">
    
    
    The motivations and benefits are:
    - store size: not having a huge base64 blobs injected in room data
    - perf on loading snapshot: this helps with loading the room data more
    quickly
    - multiple sources: furthermore, if we do decide to have multiple
    sources locally (for each asset), then we won't get a multiplicative
    effect of even larger JSON blobs that have lots of base64 data in them
    - encoding/decoding perf: this also saves the (slow) step of having to
    base64 encode/decode our assets, we can just strictly with work with
    blobs.
    
    
    Todo:
    - [x] decodes video and images
    - [x] make sure it syncs to other tabs
    - [x] make sure it syncs to other multiplayer room
    - [x] fix tests
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test the shit out of uploading/downloading video/image assets,
    locally+multiplayer.
    
    - [ ] Need to fix current tests and write new ones
    
    ### Release Notes
    
    - Assets: store as reference to blob in indexedDB instead of storing
    directly as base64 in the snapshot.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index d9eb3a710..802f45333 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -67,11 +67,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const { asset, url } = useAsset(shape.props.assetId, shape.props.w)
 
 		useEffect(() => {
-			// If an image is not animated (that's handled below), then we preload the image
-			// because we might have different source urls for different zoom levels.
+			// We preload the image because we might have different source urls for different
+			// zoom levels.
 			// Preloading the image ensures that the browser caches the image and doesn't
 			// cause visual flickering when the image is loaded.
-			if (url && !this.isAnimated(shape)) {
+			if (url) {
 				let cancelled = false
 
 				const image = Image()
@@ -204,12 +204,22 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 
 	override async toSvg(shape: TLImageShape) {
-		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null
+		if (!shape.props.assetId) return null
+
+		const asset = this.editor.getAsset(shape.props.assetId)
 
 		if (!asset) return null
 
-		let src = asset?.props.src || ''
-		if (src.startsWith('http') || src.startsWith('/') || src.startsWith('./')) {
+		let src = await this.editor.resolveAssetUrl(shape.props.assetId, {
+			shouldResolveToOriginalImage: true,
+		})
+		if (!src) return null
+		if (
+			src.startsWith('blob:') ||
+			src.startsWith('http') ||
+			src.startsWith('/') ||
+			src.startsWith('./')
+		) {
 			// If it's a remote image, we need to fetch it and convert it to a data URI
 			src = (await getDataURIFromURL(src)) || ''
 		}

commit ca3ef619ad07c5cc7d1cb11a4ea9a56eba3bfe4e
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 18 12:39:20 2024 +0100

    lod: dont resize images that are culled (#3970)
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 802f45333..0ce00e7dc 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -64,7 +64,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
 		const [loadedSrc, setLoadedSrc] = useState('')
 		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
-		const { asset, url } = useAsset(shape.props.assetId, shape.props.w)
+		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
 
 		useEffect(() => {
 			// We preload the image because we might have different source urls for different

commit 9a3afa2e2aff52d219e605f9850b46e786fe0b5c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 9 12:01:03 2024 +0100

    Flip images (#4113)
    
    This PR adds the ability to flip images.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Test plan
    
    1. Resize an image shape
    2. Select an image shape and use the flip X / flip Y options in the
    context menu.
    
    - [x] Unit tests
    
    ### Release notes
    
    - Adds the ability to flip images.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 0ce00e7dc..5507e590d 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -7,14 +7,17 @@ import {
 	MediaHelpers,
 	TLImageShape,
 	TLOnDoubleClickHandler,
+	TLOnResizeHandler,
 	TLShapePartial,
 	Vec,
 	fetch,
 	imageShapeMigrations,
 	imageShapeProps,
+	resizeBox,
 	structuredClone,
 	toDomPrecision,
 } from '@tldraw/editor'
+import classNames from 'classnames'
 import { useEffect, useState } from 'react'
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
@@ -44,9 +47,26 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			playing: true,
 			url: '',
 			crop: null,
+			flipX: false,
+			flipY: false,
 		}
 	}
 
+	override onResize: TLOnResizeHandler<any> = (shape: TLImageShape, info) => {
+		let resized: TLImageShape = resizeBox(shape, info)
+		const { flipX, flipY } = info.initialShape.props
+
+		resized = {
+			...resized,
+			props: {
+				...resized.props,
+				flipX: info.scaleX < 0 !== flipX,
+				flipY: info.scaleY < 0 !== flipY,
+			},
+		}
+		return resized
+	}
+
 	isAnimated(shape: TLImageShape) {
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
@@ -177,7 +197,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				>
 					<div className="tl-image-container" style={containerStyle}>
 						<img
-							className="tl-image"
+							className={classNames('tl-image', {
+								'tl-flip-x': shape.props.flipX && !shape.props.flipY,
+								'tl-flip-y': shape.props.flipY && !shape.props.flipX,
+								'tl-flip-xy': shape.props.flipY && shape.props.flipX,
+							})}
 							// We don't set crossOrigin for non-animated images because
 							// for Cloudflare we don't currenly have that set up.
 							crossOrigin={this.isAnimated(shape) ? 'anonymous' : undefined}

commit 965bc10997725a7e2e1484767165253d4352b21a
Author: alex <alex@dytry.ch>
Date:   Wed Jul 10 14:00:18 2024 +0100

    [1/4] Blob storage in TLStore (#4068)
    
    Reworks the store to include information about how blob assets
    (images/videos) are stored/retrieved. This replaces the old
    internal-only `assetOptions` prop, and supplements the existing
    `registerExternalAssetHandler` API.
    
    Previously, `registerExternalAssetHandler` had two responsibilities:
    1. Extracting asset metadata
    2. Uploading the asset and returning its URL
    
    Existing `registerExternalAssetHandler` implementation will still work,
    but now uploading is the responsibility of a new `editor.uploadAsset`
    method which calls the new store-based upload method. Our default asset
    handlers extract metadata, then call that new API. I think this is a
    pretty big improvement over what we had before: overriding uploads was a
    pretty common ask, but doing so meant having to copy paste our metadata
    extraction which felt pretty fragile. Just in this codebase, we had a
    bunch of very slightly different metadata extraction code-paths that had
    been copy-pasted around then diverged over time. Now, you can change how
    uploads work without having to mess with metadata extraction and
    vice-versa.
    
    As part of this we also:
    1. merge the old separate asset indexeddb store with the main one.
    because this warrants some pretty big migration stuff, i refactored our
    indexed-db helpers to work around an instance instead of being free
    functions
    2. move our existing asset stuff over to the new approach
    3. add a new hook in `sync-react` to create a demo store with the new
    assets
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    Introduce a new `assets` option for the store, describing how to save
    and retrieve asset blobs like images & videos from e.g. a user-content
    CDN. These are accessible through `editor.uploadAsset` and
    `editor.resolveAssetUrl`. This supplements the existing
    `registerExternalAssetHandler` API: `registerExternalAssetHandler` is
    for customising metadata extraction, and should call
    `editor.uploadAsset` to save assets. Existing
    `registerExternalAssetHandler` calls will still work, but if you're only
    using them to configure uploads and don't want to customise metadata
    extraction, consider switching to the new `assets` store prop.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 5507e590d..44649be23 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -235,7 +235,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		if (!asset) return null
 
 		let src = await this.editor.resolveAssetUrl(shape.props.assetId, {
-			shouldResolveToOriginalImage: true,
+			shouldResolveToOriginal: true,
 		})
 		if (!src) return null
 		if (

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 44649be23..396d9dd12 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -6,8 +6,7 @@ import {
 	Image,
 	MediaHelpers,
 	TLImageShape,
-	TLOnDoubleClickHandler,
-	TLOnResizeHandler,
+	TLResizeInfo,
 	TLShapePartial,
 	Vec,
 	fetch,
@@ -36,8 +35,12 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	static override props = imageShapeProps
 	static override migrations = imageShapeMigrations
 
-	override isAspectRatioLocked = () => true
-	override canCrop = () => true
+	override isAspectRatioLocked() {
+		return true
+	}
+	override canCrop() {
+		return true
+	}
 
 	override getDefaultProps(): TLImageShape['props'] {
 		return {
@@ -52,7 +55,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		}
 	}
 
-	override onResize: TLOnResizeHandler<any> = (shape: TLImageShape, info) => {
+	override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
 		let resized: TLImageShape = resizeBox(shape, info)
 		const { flipX, flipY } = info.initialShape.props
 
@@ -280,7 +283,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		}
 	}
 
-	override onDoubleClick = (shape: TLImageShape) => {
+	override onDoubleClick(shape: TLImageShape) {
 		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
 
 		if (!asset) return
@@ -300,7 +303,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		])
 	}
 
-	override onDoubleClickEdge: TLOnDoubleClickHandler<TLImageShape> = (shape) => {
+	override onDoubleClickEdge(shape: TLImageShape) {
 		const props = shape.props
 		if (!props) return
 

commit 88f7b572e5f7f1075e73c4d56f9ab7994a5c1268
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Aug 1 17:49:14 2024 +0100

    images: show ghost preview image whilst uploading (#3988)
    
    This adds feedback that an upload is happening, both for images and
    videos. For images, it creates a ghost image whilst uploading. For
    videos, it has the spinner (because creating the object blobs seems too
    memory heavy, but I could be convinced). The majority of the work was
    shifting `defaultExternalContentHandlers.ts` so that it's asynchronously
    creates the assets instead of synchronously when adding new assets.
    
    Also:
    - consolidated some asset creation logic around media, there was some
    duplication across the codebase
    - useMultiplayerAssets was unnecessary actually, got rid of it!
    
    Images:
    
    
    https://github.com/tldraw/tldraw/assets/469604/2633d7f1-121c-4d5f-8212-99bcd57a4ba9
    
    
    Videos:
    
    
    https://github.com/tldraw/tldraw/assets/469604/01cfa7b3-8863-45ab-b479-0a15683aa520
    
    Fixes https://github.com/tldraw/tldraw/issues/1567
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Release Notes
    
    - Media: add image and video upload indicators.
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 396d9dd12..716036d1c 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -85,31 +85,10 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const isCropping = this.editor.getCroppingShapeId() === shape.id
 		const prefersReducedMotion = usePrefersReducedMotion()
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
-		const [loadedSrc, setLoadedSrc] = useState('')
+		const [loadedUrl, setLoadedUrl] = useState<null | string>(null)
 		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
 
-		useEffect(() => {
-			// We preload the image because we might have different source urls for different
-			// zoom levels.
-			// Preloading the image ensures that the browser caches the image and doesn't
-			// cause visual flickering when the image is loaded.
-			if (url) {
-				let cancelled = false
-
-				const image = Image()
-				image.onload = () => {
-					if (cancelled) return
-					setLoadedSrc(url)
-				}
-				image.src = url
-
-				return () => {
-					cancelled = true
-				}
-			}
-		}, [url, shape])
-
 		useEffect(() => {
 			if (url && this.isAnimated(shape)) {
 				let cancelled = false
@@ -127,7 +106,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 					ctx.drawImage(image, 0, 0)
 					setStaticFrameSrc(canvas.toDataURL())
-					setLoadedSrc(url)
+					setLoadedUrl(url)
 				}
 				image.crossOrigin = 'anonymous'
 				image.src = url
@@ -150,8 +129,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		const containerStyle = getCroppedContainerStyle(shape)
 
-		// This is specifically `asset?.props.src` and not `url` because we're looking for broken assets.
-		if (!asset?.props.src) {
+		const nextSrc = url === loadedUrl ? null : url
+		const loadedSrc = !shape.props.playing || reduceMotion ? staticFrameSrc : loadedUrl
+
+		// This logic path is for when it's broken/missing asset.
+		if (!url && !asset?.props.src) {
 			return (
 				<HTMLContainer
 					id={shape.id}
@@ -160,11 +142,14 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						width: shape.props.w,
 						height: shape.props.h,
 						color: 'var(--color-text-3)',
-						backgroundColor: asset ? 'transparent' : 'var(--color-low)',
-						border: asset ? 'none' : '1px solid var(--color-low-border)',
+						backgroundColor: 'var(--color-low)',
+						border: '1px solid var(--color-low-border)',
 					}}
 				>
-					<div className="tl-image-container" style={containerStyle}>
+					<div
+						className={classNames('tl-image-container', asset && 'tl-image-container-loading')}
+						style={containerStyle}
+					>
 						{asset ? null : <BrokenAssetIcon />}
 					</div>
 					{'url' in shape.props && shape.props.url && (
@@ -174,22 +159,20 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			)
 		}
 
-		if (!loadedSrc) return null
+		// We don't set crossOrigin for non-animated images because for Cloudflare we don't currently
+		// have that set up.
+		const crossOrigin = this.isAnimated(shape) ? 'anonymous' : undefined
 
 		return (
 			<>
-				{showCropPreview && (
+				{showCropPreview && loadedSrc && (
 					<div style={containerStyle}>
 						<img
 							className="tl-image"
-							// We don't set crossOrigin for non-animated images because
-							// for Cloudflare we don't currenly have that set up.
-							crossOrigin={this.isAnimated(shape) ? 'anonymous' : undefined}
-							src={!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc}
+							crossOrigin={crossOrigin}
+							src={loadedSrc}
 							referrerPolicy="strict-origin-when-cross-origin"
-							style={{
-								opacity: 0.1,
-							}}
+							style={{ opacity: 0.1 }}
 							draggable={false}
 						/>
 					</div>
@@ -198,20 +181,42 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 					id={shape.id}
 					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
 				>
-					<div className="tl-image-container" style={containerStyle}>
-						<img
-							className={classNames('tl-image', {
-								'tl-flip-x': shape.props.flipX && !shape.props.flipY,
-								'tl-flip-y': shape.props.flipY && !shape.props.flipX,
-								'tl-flip-xy': shape.props.flipY && shape.props.flipX,
-							})}
-							// We don't set crossOrigin for non-animated images because
-							// for Cloudflare we don't currenly have that set up.
-							crossOrigin={this.isAnimated(shape) ? 'anonymous' : undefined}
-							src={!shape.props.playing || reduceMotion ? staticFrameSrc : loadedSrc}
-							referrerPolicy="strict-origin-when-cross-origin"
-							draggable={false}
-						/>
+					<div className={classNames('tl-image-container')} style={containerStyle}>
+						{/* We have two images: the currently loaded image, and the next image that
+						we're waiting to load. we keep the loaded image mounted whilst we're waiting
+						for the next one by storing the loaded URL in state. We use `key` props with
+						the src of the image so that when the next image is ready, the previous one will
+						be unmounted and the next will be shown with the browser having to remount a
+						fresh image and decoded it again from the cache. */}
+						{loadedSrc && (
+							<img
+								key={loadedSrc}
+								className={classNames('tl-image', {
+									'tl-flip-x': shape.props.flipX && !shape.props.flipY,
+									'tl-flip-y': shape.props.flipY && !shape.props.flipX,
+									'tl-flip-xy': shape.props.flipY && shape.props.flipX,
+								})}
+								crossOrigin={crossOrigin}
+								src={loadedSrc}
+								referrerPolicy="strict-origin-when-cross-origin"
+								draggable={false}
+							/>
+						)}
+						{nextSrc && (
+							<img
+								key={nextSrc}
+								className={classNames('tl-image', 'tl-image-next', {
+									'tl-flip-x': shape.props.flipX && !shape.props.flipY,
+									'tl-flip-y': shape.props.flipY && !shape.props.flipX,
+									'tl-flip-xy': shape.props.flipY && shape.props.flipX,
+								})}
+								crossOrigin={crossOrigin}
+								src={nextSrc}
+								referrerPolicy="strict-origin-when-cross-origin"
+								draggable={false}
+								onLoad={() => setLoadedUrl(nextSrc)}
+							/>
+						)}
 						{this.isAnimated(shape) && !shape.props.playing && (
 							<div className="tl-image__tg">GIF</div>
 						)}

commit 9dfe11641c8ce660134af5a403915c260b944162
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Aug 2 14:50:32 2024 +0200

    Fix flipping of cropped images (#4337)
    
    Fixes an issue with using the Flip horizontal / vertical feature.
    
    We need to change the crop positions based on the flip: if the crop is
    on the left and we then flip horizontally it now needs to be on the
    right.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Before
    
    
    https://github.com/user-attachments/assets/489ad837-7d16-48a3-a250-a64f578c890e
    
    ### After
    
    
    https://github.com/user-attachments/assets/e5c27cff-f872-444c-9573-c1c6e862d88e
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fix flipping of cropped shapes. The crop was applied to the wrong part
    of the picture.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 716036d1c..29c433157 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -67,6 +67,23 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				flipY: info.scaleY < 0 !== flipY,
 			},
 		}
+		if (shape.props.crop && info.mode === 'scale_shape') {
+			const { topLeft, bottomRight } = shape.props.crop
+			// Vertical flip
+			if (info.scaleY === -1) {
+				resized.props.crop = {
+					topLeft: { x: topLeft.x, y: 1 - bottomRight.y },
+					bottomRight: { x: bottomRight.x, y: 1 - topLeft.y },
+				}
+			}
+			// Horizontal flip
+			if (info.scaleX === -1) {
+				resized.props.crop = {
+					topLeft: { x: 1 - bottomRight.x, y: topLeft.y },
+					bottomRight: { x: 1 - topLeft.x, y: bottomRight.y },
+				}
+			}
+		}
 		return resized
 	}
 

commit 46fec0b2ee8230c3f943e8f26ffaacf45aa21f17
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Sat Aug 3 13:06:02 2024 +0100

    Interpolation: draw/highlight points, discrete props (#4241)
    
    Draw shapes and highlighter shape points now animate between states.
    
    ![2024-07-22 at 13 44 45 - Teal
    Sparrow](https://github.com/user-attachments/assets/92de6f2c-7b84-415e-b81b-94264a1341d9)
    
    There is some repetition of logic between the function that animates
    draw points and the one that animates lines. However, I felt that the
    structure of draw shapes and lines is different enough that generalising
    the function would add complexity and sacrifice readability, and didn't
    seem worth it just to remove a small amount of repetition. Very happy to
    change that should anyone disagree.
    
    Image shape crop property animates to the new position
    
    ![2024-07-22 at 15 39 30 - Purple
    Cattle](https://github.com/user-attachments/assets/fb108a48-6ed0-4f49-a232-fa806c78aa97)
    
    
    Discrete props (props that don't have continuous values to animate
    along) now change in the middle of the animation. It's likely that
    continuous animation will be happening at the same time, making the
    change in the middle of that movement helps smooth over the abruptness
    of that change.
    
    This is what it looks like if they change at the start:
    
    ![2024-07-18 at 13 11 32 - Amaranth
    Primate](https://github.com/user-attachments/assets/50570507-0b0a-4f61-a710-a180b7ddb00f)
    
    
    This is what it looks like when the props change halfway:
    
    ![2024-07-18 at 13 12 40 - Teal
    Gerbil](https://github.com/user-attachments/assets/48a28e62-901a-45db-8d30-4a5a18b5960f)
    
    
    The text usually changes at the halfway mark, but if there's no text to
    begin with, then any text in the end shape is streamed in:
    
    ![2024-07-18 at 15 18 34 - Tan
    Catshark](https://github.com/user-attachments/assets/ed59122c-7f52-4f57-94d5-9382ff8d62b1)
    
    Question: Do we want tests for this?
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Animate a shape between different states
    2. It should change its discrete props at the midway point of the
    animation, and animate smoothly for continuous values such as dimension
    or position.
    
    ### Release notes
    
    - Added getInterpolated props method for all shapes, including draw and
    highlighter.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 29c433157..4c268c8b2 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -6,18 +6,21 @@ import {
 	Image,
 	MediaHelpers,
 	TLImageShape,
+	TLImageShapeProps,
 	TLResizeInfo,
 	TLShapePartial,
 	Vec,
 	fetch,
 	imageShapeMigrations,
 	imageShapeProps,
+	lerp,
 	resizeBox,
 	structuredClone,
 	toDomPrecision,
 } from '@tldraw/editor'
 import classNames from 'classnames'
 import { useEffect, useState } from 'react'
+
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { useAsset } from '../shared/useAsset'
@@ -361,6 +364,35 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		this.editor.updateShapes([partial])
 	}
+	override getInterpolatedProps(
+		startShape: TLImageShape,
+		endShape: TLImageShape,
+		t: number
+	): TLImageShapeProps {
+		function interpolateCrop(
+			startShape: TLImageShape,
+			endShape: TLImageShape
+		): TLImageShapeProps['crop'] {
+			if (startShape.props.crop === null && endShape.props.crop === null) return null
+
+			const startTL = startShape.props.crop?.topLeft || { x: 0, y: 0 }
+			const startBR = startShape.props.crop?.bottomRight || { x: 1, y: 1 }
+			const endTL = endShape.props.crop?.topLeft || { x: 0, y: 0 }
+			const endBR = endShape.props.crop?.bottomRight || { x: 1, y: 1 }
+
+			return {
+				topLeft: { x: lerp(startTL.x, endTL.x, t), y: lerp(startTL.y, endTL.y, t) },
+				bottomRight: { x: lerp(startBR.x, endBR.x, t), y: lerp(startBR.y, endBR.y, t) },
+			}
+		}
+
+		return {
+			...(t > 0.5 ? endShape.props : startShape.props),
+			w: lerp(startShape.props.w, endShape.props.w, t),
+			h: lerp(startShape.props.h, endShape.props.h, t),
+			crop: interpolateCrop(startShape, endShape),
+		}
+	}
 }
 
 /**

commit 2d8df071dda8d750f3e146cac8b1da3d254c3b64
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Aug 5 21:04:10 2024 +0200

    Fix issues with resizing cropped images (#4350)
    
    While working on #4337 I also discovered two other issues:
    * Preview of the whole image (including the cropped out part) was
    incorrect when shapes were flipped. We weren't applying the scaling
    styles to the preview.
    * When resizing the shapes via the handles the same issue as in #4337
    could occur. We also need to flip the crop if resizing causes the image
    to flip.
    
    ### Before
    
    
    https://github.com/user-attachments/assets/f6b35e72-579c-4b4f-a981-9bceaca4260d
    
    ### After
    
    
    https://github.com/user-attachments/assets/dce79223-18c9-4d3c-ab45-fc888cb2baa5
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create an image with a crop.
    2. Use resizing handles to make it flip. The cropped part should stay
    the same.
    3. Also check the preview of the cropped area when the image is flipped.
    It should also be flipped.
    
    ### Release notes
    
    - Fix a bug with cropped and flipped images and their previews.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 4c268c8b2..5042953fd 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -61,31 +61,39 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
 		let resized: TLImageShape = resizeBox(shape, info)
 		const { flipX, flipY } = info.initialShape.props
+		const { scaleX, scaleY, mode } = info
 
 		resized = {
 			...resized,
 			props: {
 				...resized.props,
-				flipX: info.scaleX < 0 !== flipX,
-				flipY: info.scaleY < 0 !== flipY,
+				flipX: scaleX < 0 !== flipX,
+				flipY: scaleY < 0 !== flipY,
 			},
 		}
-		if (shape.props.crop && info.mode === 'scale_shape') {
-			const { topLeft, bottomRight } = shape.props.crop
-			// Vertical flip
-			if (info.scaleY === -1) {
-				resized.props.crop = {
-					topLeft: { x: topLeft.x, y: 1 - bottomRight.y },
-					bottomRight: { x: bottomRight.x, y: 1 - topLeft.y },
-				}
-			}
-			// Horizontal flip
-			if (info.scaleX === -1) {
-				resized.props.crop = {
-					topLeft: { x: 1 - bottomRight.x, y: topLeft.y },
-					bottomRight: { x: 1 - topLeft.x, y: bottomRight.y },
-				}
-			}
+		if (!shape.props.crop) return resized
+
+		const flipCropHorizontally =
+			// We used the flip horizontally feature
+			(mode === 'scale_shape' && scaleX === -1) ||
+			// We resized the shape past it's bounds, so it flipped
+			(mode === 'resize_bounds' && flipX !== resized.props.flipX)
+		const flipCropVertically =
+			// We used the flip vertically feature
+			(mode === 'scale_shape' && scaleY === -1) ||
+			// We resized the shape past it's bounds, so it flipped
+			(mode === 'resize_bounds' && flipY !== resized.props.flipY)
+
+		const { topLeft, bottomRight } = shape.props.crop
+		resized.props.crop = {
+			topLeft: {
+				x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
+				y: flipCropVertically ? 1 - bottomRight.y : topLeft.y,
+			},
+			bottomRight: {
+				x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
+				y: flipCropVertically ? 1 - topLeft.y : bottomRight.y,
+			},
 		}
 		return resized
 	}
@@ -188,7 +196,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				{showCropPreview && loadedSrc && (
 					<div style={containerStyle}>
 						<img
-							className="tl-image"
+							className={classNames('tl-image', {
+								'tl-flip-x': shape.props.flipX && !shape.props.flipY,
+								'tl-flip-y': shape.props.flipY && !shape.props.flipX,
+								'tl-flip-xy': shape.props.flipY && shape.props.flipX,
+							})}
 							crossOrigin={crossOrigin}
 							src={loadedSrc}
 							referrerPolicy="strict-origin-when-cross-origin"

commit a7a2cfbef1a1174b7a208edad73abd1683e60d3c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Aug 10 21:11:28 2024 +0100

    Update READMEs. (#4377)
    
    This PR:
    - updates the descriptions for our Nextjs and Vite templates
    - adds some licensing information
    - replaces the word whilst with while
    - updates copyright notices to 2024
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 5042953fd..1dbc49b04 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -215,7 +215,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				>
 					<div className={classNames('tl-image-container')} style={containerStyle}>
 						{/* We have two images: the currently loaded image, and the next image that
-						we're waiting to load. we keep the loaded image mounted whilst we're waiting
+						we're waiting to load. we keep the loaded image mounted while we're waiting
 						for the next one by storing the loaded URL in state. We use `key` props with
 						the src of the image so that when the next image is ready, the previous one will
 						be unmounted and the next will be shown with the browser having to remount a

commit e716f404dbc25cdc790b32f5d510084b27240f37
Author: alex <alex@dytry.ch>
Date:   Tue Aug 27 17:23:34 2024 +0100

    Fix exports for dark mode frames and flipped images (#4424)
    
    These weren't getting handled correctly before.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Flipped images are now respected in exports
    - Dark mode frames are exported with the correct label color
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 1dbc49b04..5df3f2978 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -196,15 +196,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				{showCropPreview && loadedSrc && (
 					<div style={containerStyle}>
 						<img
-							className={classNames('tl-image', {
-								'tl-flip-x': shape.props.flipX && !shape.props.flipY,
-								'tl-flip-y': shape.props.flipY && !shape.props.flipX,
-								'tl-flip-xy': shape.props.flipY && shape.props.flipX,
-							})}
+							className="tl-image"
+							style={{ ...getFlipStyle(shape), opacity: 0.1 }}
 							crossOrigin={crossOrigin}
 							src={loadedSrc}
 							referrerPolicy="strict-origin-when-cross-origin"
-							style={{ opacity: 0.1 }}
 							draggable={false}
 						/>
 					</div>
@@ -223,11 +219,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						{loadedSrc && (
 							<img
 								key={loadedSrc}
-								className={classNames('tl-image', {
-									'tl-flip-x': shape.props.flipX && !shape.props.flipY,
-									'tl-flip-y': shape.props.flipY && !shape.props.flipX,
-									'tl-flip-xy': shape.props.flipY && shape.props.flipX,
-								})}
+								className="tl-image"
+								style={getFlipStyle(shape)}
 								crossOrigin={crossOrigin}
 								src={loadedSrc}
 								referrerPolicy="strict-origin-when-cross-origin"
@@ -237,11 +230,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						{nextSrc && (
 							<img
 								key={nextSrc}
-								className={classNames('tl-image', 'tl-image-next', {
-									'tl-flip-x': shape.props.flipX && !shape.props.flipY,
-									'tl-flip-y': shape.props.flipY && !shape.props.flipX,
-									'tl-flip-xy': shape.props.flipY && shape.props.flipX,
-								})}
+								className="tl-image"
+								style={getFlipStyle(shape)}
 								crossOrigin={crossOrigin}
 								src={nextSrc}
 								referrerPolicy="strict-origin-when-cross-origin"
@@ -291,7 +281,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const containerStyle = getCroppedContainerStyle(shape)
 		const crop = shape.props.crop
 		if (containerStyle.transform && crop) {
-			const { transform, width, height } = containerStyle
+			const { transform: cropTransform, width, height } = containerStyle
 			const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
 			const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height
 
@@ -303,6 +293,9 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			]
 
 			const cropClipId = `cropClipPath_${shape.id.replace(':', '_')}`
+
+			const flip = getFlipStyle(shape, { width, height })
+
 			return (
 				<>
 					<defs>
@@ -311,12 +304,28 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 						</clipPath>
 					</defs>
 					<g clipPath={`url(#${cropClipId})`}>
-						<image href={src} width={width} height={height} style={{ transform }} />
+						<image
+							href={src}
+							width={width}
+							height={height}
+							style={
+								flip
+									? { ...flip, transform: `${cropTransform} ${flip.transform}` }
+									: { transform: cropTransform }
+							}
+						/>
 					</g>
 				</>
 			)
 		} else {
-			return <image href={src} width={shape.props.w} height={shape.props.h} />
+			return (
+				<image
+					href={src}
+					width={shape.props.w}
+					height={shape.props.h}
+					style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })}
+				/>
+			)
 		}
 	}
 
@@ -436,3 +445,19 @@ function getCroppedContainerStyle(shape: TLImageShape) {
 		height: h,
 	}
 }
+
+function getFlipStyle(shape: TLImageShape, size?: { width: number; height: number }) {
+	const { flipX, flipY } = shape.props
+	if (!flipX && !flipY) return undefined
+
+	const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`
+	const translate = size
+		? `translate(${flipX ? size.width : 0}px, ${flipY ? size.height : 0}px)`
+		: ''
+
+	return {
+		transform: `${translate} ${scale}`,
+		// in SVG, flipping around the center doesn't work so we use explicit width/height
+		transformOrigin: size ? '0 0' : 'center center',
+	}
+}

commit 374f8152cb0636a36bdc19f02da628611849ef57
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Sep 10 15:07:05 2024 +0100

    images: dont stop playing a gif on double click (#4451)
    
    Double-clicking currently pauses gif's which is odd. This changes is so
    that you can unpause them (if they were stopped for reduced motion
    reasons). But they can't be paused.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Images: dbl-clicking doesn't stop gifs
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 5df3f2978..91f3fa8e3 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -158,7 +158,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const containerStyle = getCroppedContainerStyle(shape)
 
 		const nextSrc = url === loadedUrl ? null : url
-		const loadedSrc = !shape.props.playing || reduceMotion ? staticFrameSrc : loadedUrl
+		const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl
 
 		// This logic path is for when it's broken/missing asset.
 		if (!url && !asset?.props.src) {
@@ -239,9 +239,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 								onLoad={() => setLoadedUrl(nextSrc)}
 							/>
 						)}
-						{this.isAnimated(shape) && !shape.props.playing && (
-							<div className="tl-image__tg">GIF</div>
-						)}
 					</div>
 					{shape.props.url && (
 						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
@@ -329,26 +326,6 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		}
 	}
 
-	override onDoubleClick(shape: TLImageShape) {
-		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
-
-		if (!asset) return
-
-		const canPlay = asset.props.src && this.isAnimated(shape)
-
-		if (!canPlay) return
-
-		this.editor.updateShapes([
-			{
-				type: 'image',
-				id: shape.id,
-				props: {
-					playing: !shape.props.playing,
-				},
-			},
-		])
-	}
-
 	override onDoubleClickEdge(shape: TLImageShape) {
 		const props = shape.props
 		if (!props) return

commit 7d81da31f4368656a9454107fd84be186d7a296c
Author: alex <alex@dytry.ch>
Date:   Tue Sep 24 11:22:11 2024 +0100

    publish useAsset, tweak docs (#4590)
    
    This was hidden and some of the docs around it were out of date.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    - Publish the `useAsset` media asset helper

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 91f3fa8e3..2e8ab5129 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -115,7 +115,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		const [staticFrameSrc, setStaticFrameSrc] = useState('')
 		const [loadedUrl, setLoadedUrl] = useState<null | string>(null)
 		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
-		const { asset, url } = useAsset(shape.id, shape.props.assetId, shape.props.w)
+		const { asset, url } = useAsset({
+			shapeId: shape.id,
+			assetId: shape.props.assetId,
+			width: shape.props.w,
+		})
 
 		useEffect(() => {
 			if (url && this.isAnimated(shape)) {

commit 804a87fe10dee58d8fb0b4ef1182ce49790e8e1f
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Sep 30 14:24:10 2024 +0100

    chore: refactor safe id (#4618)
    
    just a little thing that was driving me nuts :P
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 2e8ab5129..21c3523e9 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -15,6 +15,7 @@ import {
 	imageShapeProps,
 	lerp,
 	resizeBox,
+	sanitizeId,
 	structuredClone,
 	toDomPrecision,
 } from '@tldraw/editor'
@@ -293,7 +294,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				new Vec(0, croppedHeight),
 			]
 
-			const cropClipId = `cropClipPath_${shape.id.replace(':', '_')}`
+			const cropClipId = `cropClipPath_${sanitizeId(shape.id)}`
 
 			const flip = getFlipStyle(shape, { width, height })
 

commit d5f4c1d05bb834ab5623d19d418e31e4ab5afa66
Author: alex <alex@dytry.ch>
Date:   Wed Oct 9 15:55:15 2024 +0100

    make sure DOM IDs are globally unique (#4694)
    
    There are a lot of places where we currently derive a DOM ID from a
    shape ID. This works fine (ish) on tldraw.com, but doesn't work for a
    lot of developer use-cases: if there are multiple tldraw instances or
    exports happening, for example. This is because the DOM expects IDs to
    be globally unique. If there are multiple elements with the same ID in
    the dom, only the first is ever used. This can cause issues if e.g.
    
    1. i have a shape with a clip-path determined by the shape ID
    2. i export that shape and add the resulting SVG to the dom. now, there
    are two clip paths with the same ID, but they're the same
    3. I change the shape - and now, the ID is referring to the export, so i
    get weird rendering issues.
    
    This diff attempts to resolve this issue and prevent it from happening
    again by introducing a new `SafeId` type, and helpers for generating and
    working with `SafeId`s. in tldraw, jsx using the `id` attribute will now
    result in a type error if the value isn't a safe ID. This doesn't affect
    library consumers writing JSX.
    
    As part of this, I've removed the ID that were added to certain shapes.
    Instead, all shapes now have a `data-shape-id` attribute on their
    wrapper.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Exports and other tldraw instances no longer can affect how each other
    are rendered
    - **BREAKING:** the `id` attribute that was present on some shapes in
    the dom has been removed. there's now a data-shape-id attribute on every
    shape wrapper instead though.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 21c3523e9..76c9aa271 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -15,9 +15,9 @@ import {
 	imageShapeProps,
 	lerp,
 	resizeBox,
-	sanitizeId,
 	structuredClone,
 	toDomPrecision,
+	useUniqueSafeId,
 } from '@tldraw/editor'
 import classNames from 'classnames'
 import { useEffect, useState } from 'react'
@@ -280,55 +280,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			src = (await getDataURIFromURL(src)) || ''
 		}
 
-		const containerStyle = getCroppedContainerStyle(shape)
-		const crop = shape.props.crop
-		if (containerStyle.transform && crop) {
-			const { transform: cropTransform, width, height } = containerStyle
-			const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
-			const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height
-
-			const points = [
-				new Vec(0, 0),
-				new Vec(croppedWidth, 0),
-				new Vec(croppedWidth, croppedHeight),
-				new Vec(0, croppedHeight),
-			]
-
-			const cropClipId = `cropClipPath_${sanitizeId(shape.id)}`
-
-			const flip = getFlipStyle(shape, { width, height })
-
-			return (
-				<>
-					<defs>
-						<clipPath id={cropClipId}>
-							<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />
-						</clipPath>
-					</defs>
-					<g clipPath={`url(#${cropClipId})`}>
-						<image
-							href={src}
-							width={width}
-							height={height}
-							style={
-								flip
-									? { ...flip, transform: `${cropTransform} ${flip.transform}` }
-									: { transform: cropTransform }
-							}
-						/>
-					</g>
-				</>
-			)
-		} else {
-			return (
-				<image
-					href={src}
-					width={shape.props.w}
-					height={shape.props.h}
-					style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })}
-				/>
-			)
-		}
+		return <SvgImage shape={shape} src={src} />
 	}
 
 	override onDoubleClickEdge(shape: TLImageShape) {
@@ -443,3 +395,54 @@ function getFlipStyle(shape: TLImageShape, size?: { width: number; height: numbe
 		transformOrigin: size ? '0 0' : 'center center',
 	}
 }
+
+function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
+	const cropClipId = useUniqueSafeId()
+	const containerStyle = getCroppedContainerStyle(shape)
+	const crop = shape.props.crop
+	if (containerStyle.transform && crop) {
+		const { transform: cropTransform, width, height } = containerStyle
+		const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
+		const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height
+
+		const points = [
+			new Vec(0, 0),
+			new Vec(croppedWidth, 0),
+			new Vec(croppedWidth, croppedHeight),
+			new Vec(0, croppedHeight),
+		]
+
+		const flip = getFlipStyle(shape, { width, height })
+
+		return (
+			<>
+				<defs>
+					<clipPath id={cropClipId}>
+						<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />
+					</clipPath>
+				</defs>
+				<g clipPath={`url(#${cropClipId})`}>
+					<image
+						href={src}
+						width={width}
+						height={height}
+						style={
+							flip
+								? { ...flip, transform: `${cropTransform} ${flip.transform}` }
+								: { transform: cropTransform }
+						}
+					/>
+				</g>
+			</>
+		)
+	} else {
+		return (
+			<image
+				href={src}
+				width={shape.props.w}
+				height={shape.props.h}
+				style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })}
+			/>
+		)
+	}
+}

commit 29d7ecaa7c0d2bc67190f20efd5c1ba47305ce14
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Sat Oct 12 16:12:12 2024 +0100

    lod: memoize media assets so that zoom level doesn't re-render constantly (#4659)
    
    Related to a discussion on Discord:
    https://discord.com/channels/859816885297741824/1290992999186169898/1291681011758792756
    
    This works to memoize the rendering of the core part of the image/video
    react components b/c the `useValue` hook inside `useAsset` is called so
    often. If there's a better way to do this @SomeHats I'm all ears!
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improve performance of image/video rendering.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 76c9aa271..ba8412451 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -1,6 +1,6 @@
-/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
+	Editor,
 	FileHelpers,
 	HTMLContainer,
 	Image,
@@ -17,14 +17,16 @@ import {
 	resizeBox,
 	structuredClone,
 	toDomPrecision,
+	useEditor,
 	useUniqueSafeId,
+	useValue,
 } from '@tldraw/editor'
 import classNames from 'classnames'
-import { useEffect, useState } from 'react'
+import { memo, useEffect, useState } from 'react'
 
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
-import { useAsset } from '../shared/useAsset'
+import { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
 async function getDataURIFromURL(url: string): Promise<string> {
@@ -99,158 +101,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		return resized
 	}
 
-	isAnimated(shape: TLImageShape) {
-		const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : undefined
-
-		if (!asset) return false
-
-		return (
-			('mimeType' in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType)) ||
-			('isAnimated' in asset.props && asset.props.isAnimated)
-		)
-	}
-
 	component(shape: TLImageShape) {
-		const isCropping = this.editor.getCroppingShapeId() === shape.id
-		const prefersReducedMotion = usePrefersReducedMotion()
-		const [staticFrameSrc, setStaticFrameSrc] = useState('')
-		const [loadedUrl, setLoadedUrl] = useState<null | string>(null)
-		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
-		const { asset, url } = useAsset({
-			shapeId: shape.id,
-			assetId: shape.props.assetId,
-			width: shape.props.w,
-		})
-
-		useEffect(() => {
-			if (url && this.isAnimated(shape)) {
-				let cancelled = false
-
-				const image = Image()
-				image.onload = () => {
-					if (cancelled) return
-
-					const canvas = document.createElement('canvas')
-					canvas.width = image.width
-					canvas.height = image.height
-
-					const ctx = canvas.getContext('2d')
-					if (!ctx) return
-
-					ctx.drawImage(image, 0, 0)
-					setStaticFrameSrc(canvas.toDataURL())
-					setLoadedUrl(url)
-				}
-				image.crossOrigin = 'anonymous'
-				image.src = url
-
-				return () => {
-					cancelled = true
-				}
-			}
-		}, [prefersReducedMotion, url, shape])
-
-		if (asset?.type === 'bookmark') {
-			throw Error("Bookmark assets can't be rendered as images")
-		}
-
-		const showCropPreview = isSelected && isCropping && this.editor.isIn('select.crop')
-
-		// We only want to reduce motion for mimeTypes that have motion
-		const reduceMotion =
-			prefersReducedMotion && (asset?.props.mimeType?.includes('video') || this.isAnimated(shape))
-
-		const containerStyle = getCroppedContainerStyle(shape)
-
-		const nextSrc = url === loadedUrl ? null : url
-		const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl
-
-		// This logic path is for when it's broken/missing asset.
-		if (!url && !asset?.props.src) {
-			return (
-				<HTMLContainer
-					id={shape.id}
-					style={{
-						overflow: 'hidden',
-						width: shape.props.w,
-						height: shape.props.h,
-						color: 'var(--color-text-3)',
-						backgroundColor: 'var(--color-low)',
-						border: '1px solid var(--color-low-border)',
-					}}
-				>
-					<div
-						className={classNames('tl-image-container', asset && 'tl-image-container-loading')}
-						style={containerStyle}
-					>
-						{asset ? null : <BrokenAssetIcon />}
-					</div>
-					{'url' in shape.props && shape.props.url && (
-						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
-					)}
-				</HTMLContainer>
-			)
-		}
-
-		// We don't set crossOrigin for non-animated images because for Cloudflare we don't currently
-		// have that set up.
-		const crossOrigin = this.isAnimated(shape) ? 'anonymous' : undefined
-
-		return (
-			<>
-				{showCropPreview && loadedSrc && (
-					<div style={containerStyle}>
-						<img
-							className="tl-image"
-							style={{ ...getFlipStyle(shape), opacity: 0.1 }}
-							crossOrigin={crossOrigin}
-							src={loadedSrc}
-							referrerPolicy="strict-origin-when-cross-origin"
-							draggable={false}
-						/>
-					</div>
-				)}
-				<HTMLContainer
-					id={shape.id}
-					style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
-				>
-					<div className={classNames('tl-image-container')} style={containerStyle}>
-						{/* We have two images: the currently loaded image, and the next image that
-						we're waiting to load. we keep the loaded image mounted while we're waiting
-						for the next one by storing the loaded URL in state. We use `key` props with
-						the src of the image so that when the next image is ready, the previous one will
-						be unmounted and the next will be shown with the browser having to remount a
-						fresh image and decoded it again from the cache. */}
-						{loadedSrc && (
-							<img
-								key={loadedSrc}
-								className="tl-image"
-								style={getFlipStyle(shape)}
-								crossOrigin={crossOrigin}
-								src={loadedSrc}
-								referrerPolicy="strict-origin-when-cross-origin"
-								draggable={false}
-							/>
-						)}
-						{nextSrc && (
-							<img
-								key={nextSrc}
-								className="tl-image"
-								style={getFlipStyle(shape)}
-								crossOrigin={crossOrigin}
-								src={nextSrc}
-								referrerPolicy="strict-origin-when-cross-origin"
-								draggable={false}
-								onLoad={() => setLoadedUrl(nextSrc)}
-							/>
-						)}
-					</div>
-					{shape.props.url && (
-						<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.getZoomLevel()} />
-					)}
-				</HTMLContainer>
-			</>
-		)
+		return <ImageShape shape={shape} />
 	}
 
 	indicator(shape: TLImageShape) {
@@ -350,6 +202,161 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	}
 }
 
+const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape }) {
+	const editor = useEditor()
+
+	const { asset, url } = useImageOrVideoAsset({
+		shapeId: shape.id,
+		assetId: shape.props.assetId,
+	})
+
+	const prefersReducedMotion = usePrefersReducedMotion()
+	const [staticFrameSrc, setStaticFrameSrc] = useState('')
+	const [loadedUrl, setLoadedUrl] = useState<null | string>(null)
+
+	const isAnimated = getIsAnimated(editor, shape)
+
+	useEffect(() => {
+		if (url && isAnimated) {
+			let cancelled = false
+
+			const image = Image()
+			image.onload = () => {
+				if (cancelled) return
+
+				const canvas = document.createElement('canvas')
+				canvas.width = image.width
+				canvas.height = image.height
+
+				const ctx = canvas.getContext('2d')
+				if (!ctx) return
+
+				ctx.drawImage(image, 0, 0)
+				setStaticFrameSrc(canvas.toDataURL())
+				setLoadedUrl(url)
+			}
+			image.crossOrigin = 'anonymous'
+			image.src = url
+
+			return () => {
+				cancelled = true
+			}
+		}
+	}, [editor, isAnimated, prefersReducedMotion, url])
+
+	const showCropPreview = useValue(
+		'show crop preview',
+		() =>
+			shape.id === editor.getOnlySelectedShapeId() &&
+			editor.getCroppingShapeId() === shape.id &&
+			editor.isIn('select.crop'),
+		[editor, shape.id]
+	)
+
+	// We only want to reduce motion for mimeTypes that have motion
+	const reduceMotion =
+		prefersReducedMotion && (asset?.props.mimeType?.includes('video') || isAnimated)
+
+	const containerStyle = getCroppedContainerStyle(shape)
+
+	const nextSrc = url === loadedUrl ? null : url
+	const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl
+
+	// This logic path is for when it's broken/missing asset.
+	if (!url && !asset?.props.src) {
+		return (
+			<HTMLContainer
+				id={shape.id}
+				style={{
+					overflow: 'hidden',
+					width: shape.props.w,
+					height: shape.props.h,
+					color: 'var(--color-text-3)',
+					backgroundColor: 'var(--color-low)',
+					border: '1px solid var(--color-low-border)',
+				}}
+			>
+				<div
+					className={classNames('tl-image-container', asset && 'tl-image-container-loading')}
+					style={containerStyle}
+				>
+					{asset ? null : <BrokenAssetIcon />}
+				</div>
+				{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}
+			</HTMLContainer>
+		)
+	}
+
+	// We don't set crossOrigin for non-animated images because for Cloudflare we don't currently
+	// have that set up.
+	const crossOrigin = isAnimated ? 'anonymous' : undefined
+
+	return (
+		<>
+			{showCropPreview && loadedSrc && (
+				<div style={containerStyle}>
+					<img
+						className="tl-image"
+						style={{ ...getFlipStyle(shape), opacity: 0.1 }}
+						crossOrigin={crossOrigin}
+						src={loadedSrc}
+						referrerPolicy="strict-origin-when-cross-origin"
+						draggable={false}
+					/>
+				</div>
+			)}
+			<HTMLContainer
+				id={shape.id}
+				style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
+			>
+				<div className={classNames('tl-image-container')} style={containerStyle}>
+					{/* We have two images: the currently loaded image, and the next image that
+					we're waiting to load. we keep the loaded image mounted while we're waiting
+					for the next one by storing the loaded URL in state. We use `key` props with
+					the src of the image so that when the next image is ready, the previous one will
+					be unmounted and the next will be shown with the browser having to remount a
+					fresh image and decoded it again from the cache. */}
+					{loadedSrc && (
+						<img
+							key={loadedSrc}
+							className="tl-image"
+							style={getFlipStyle(shape)}
+							crossOrigin={crossOrigin}
+							src={loadedSrc}
+							referrerPolicy="strict-origin-when-cross-origin"
+							draggable={false}
+						/>
+					)}
+					{nextSrc && (
+						<img
+							key={nextSrc}
+							className="tl-image"
+							style={getFlipStyle(shape)}
+							crossOrigin={crossOrigin}
+							src={nextSrc}
+							referrerPolicy="strict-origin-when-cross-origin"
+							draggable={false}
+							onLoad={() => setLoadedUrl(nextSrc)}
+						/>
+					)}
+				</div>
+				{shape.props.url && <HyperlinkButton url={shape.props.url} />}
+			</HTMLContainer>
+		</>
+	)
+})
+
+function getIsAnimated(editor: Editor, shape: TLImageShape) {
+	const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : undefined
+
+	if (!asset) return false
+
+	return (
+		('mimeType' in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType)) ||
+		('isAnimated' in asset.props && asset.props.isAnimated)
+	)
+}
+
 /**
  * When an image is cropped we need to translate the image to show the portion withing the cropped
  * area. We do this by translating the image by the negative of the top left corner of the crop

commit 5ed55f12f0508edec34292d7c1bdd08b4e8c21a1
Author: alex <alex@dytry.ch>
Date:   Mon Jan 20 18:19:00 2025 +0000

    Exports DX pass (#5114)
    
    Over the last few weeks we've had a lot of requests on discord around
    asset resolution, exports, and the two together. Some of the APIs here
    have evolved and change independently of each other over time, so I
    wanted to take a pass at making them make sense with each other a bit
    more. There are a few things going on in this diff:
    
    1. **BREAKING** The export/copy-as JSON option has been removed. I think
    this was only ever there as a debug helper, and it's impossible to
    actually make use of the JSON once copied (it's not the same as .tldr
    json which confuses people).
    2. `exportToBlob` is deprecated in favour of a new `Editor.toImage`
    method. `exportToBlob` has been the canonical 'turn the canvas into an
    image' helper for a while, but it has quite a weird looking signature
    and isn't very discoverable.
    3. the `copyAs` and `exportAs` helpers have had a couple of args merged
    into the options bag for consistency.
    4. The `jpeg` format has been removed from `copyAs`. This is technically
    a breaking API change, but since it never actually worked anyway due to
    browser limitations i think its fine.
    5. SVG exports now resolve assets according to how they'll be used:
    - if it's for an SVG, we still use the existing
    `shouldResolveToOriginal` behaviour
    - if it's for a bitmap export, we request an image downscaled according
    to the size it will appear in that resulting bitmap.
    6. Better reference docs for several APIs around this stuff.
    7. **BREAKING** the `useImageOrVideoAsset` hook now requires passing in
    `width`, instead of reading `shape.props.w`. This is so it can be used
    with shapes other than our own. Whilst this is technically a breaking
    change, this limitation means its unlikely that it was used with many
    custom shapes in practice.
    8. The clamping that we used to apply in to `steppedScreenScale` in
    `resolveAssetUrl` has been moved to our own implementations of
    `TLAssetStore`. This is so implementors can make their own decisions
    about the range of scalings they might want to use.
    9. The `steppedScreenScale` limit changed from 1/8 to 1/32. This is
    because when testing with full res photos from a modern smartphone, we
    were still downloading a 1000+px image in order to render it at a few
    hundred px across (and also we don't pay anything for these right now).
    Happy to change now/in the future if this doesn't seem right though.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    #### Breaking changes / user facing changes
    - The copy/export as JSON option has been removed. Data copied/exported
    from here could not be used anyway. If you need this in your app, look
    into `Editor.getContentFromCurrentPage`.
    - `useImageOrVideoAssetUrl` now expects a `width` parameter representing
    the rendered width of the asset.
    - `Editor.getSvgElement` and `Editor.getSvgString` will now export all
    shapes on the current page instead of returning undefined when passed an
    empty array of shape ids.
    
    #### Product improvement
    - When exporting to an image, image assets are now downloaded at a
    resolution appropriate for how they will appear in the export.
    
    #### API changes
    - There's a new `Editor.toImage` method that makes creating an image
    from your canvas easier. (`exportToBlob` is deprecated in favour of it)
    - `SvgExportContext` now exposes the `scale` and `pixelRatio` options of
    the current export
    - `SvgExportContext` now has a `resolveAssetUrl` method to resolve an
    asset at a resolution appropriate for the export.
    - `copyAs(editor, ids, format, opts)` has been deprecated in favour of
    `copyAs(editor, ids, opts)`.
    - `exportAs(editor, ids, format, name, opts)` has been deprecated in
    favour of `exportAs(editor, ids, opts)`

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index ba8412451..27272bf76 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -5,6 +5,7 @@ import {
 	HTMLContainer,
 	Image,
 	MediaHelpers,
+	SvgExportContext,
 	TLImageShape,
 	TLImageShapeProps,
 	TLResizeInfo,
@@ -111,16 +112,14 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
 
-	override async toSvg(shape: TLImageShape) {
+	override async toSvg(shape: TLImageShape, ctx: SvgExportContext) {
 		if (!shape.props.assetId) return null
 
 		const asset = this.editor.getAsset(shape.props.assetId)
 
 		if (!asset) return null
 
-		let src = await this.editor.resolveAssetUrl(shape.props.assetId, {
-			shouldResolveToOriginal: true,
-		})
+		let src = await ctx.resolveAssetUrl(shape.props.assetId, shape.props.w)
 		if (!src) return null
 		if (
 			src.startsWith('blob:') ||
@@ -208,6 +207,7 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 	const { asset, url } = useImageOrVideoAsset({
 		shapeId: shape.id,
 		assetId: shape.props.assetId,
+		width: shape.props.w,
 	})
 
 	const prefersReducedMotion = usePrefersReducedMotion()

commit 276d0a73fb26c8ba9fdb0e07b5d208ca58caf699
Author: Trygve Aaberge <trygve.aaberge@autodesk.com>
Date:   Tue Jan 28 15:57:16 2025 +0100

    Use the uncropped width when requesting an image shape asset (#5300)
    
    This fixes an issue where the more you cropped an image, the lower scale
    the image would be resolved to. However, when cropping the image is
    still rendered at the same size, it just shows only a part of the image.
    Therefore use the uncropped size when resolving the asset instead, so it
    keeps the correct scale.
    
    Fixes #5299
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Have an asset store that scales assets
    2. Create an image shape
    3. Crop the image
    4. Observe that the more you crop the image, the lower scale it gets
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug where a cropped image would use lower scaled assets the
    more it was cropped.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 27272bf76..44f3a4032 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -27,6 +27,7 @@ import { memo, useEffect, useState } from 'react'
 
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
+import { getUncroppedSize } from '../shared/crop'
 import { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'
 import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'
 
@@ -119,7 +120,8 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 
 		if (!asset) return null
 
-		let src = await ctx.resolveAssetUrl(shape.props.assetId, shape.props.w)
+		const { w } = getUncroppedSize(shape.props, shape.props.crop)
+		let src = await ctx.resolveAssetUrl(shape.props.assetId, w)
 		if (!src) return null
 		if (
 			src.startsWith('blob:') ||
@@ -148,8 +150,7 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		}
 
 		// The true asset dimensions
-		const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
-		const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
+		const { w, h } = getUncroppedSize(shape.props, crop)
 
 		const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)
 
@@ -204,10 +205,11 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape }) {
 	const editor = useEditor()
 
+	const { w } = getUncroppedSize(shape.props, shape.props.crop)
 	const { asset, url } = useImageOrVideoAsset({
 		shapeId: shape.id,
 		assetId: shape.props.assetId,
-		width: shape.props.w,
+		width: w,
 	})
 
 	const prefersReducedMotion = usePrefersReducedMotion()
@@ -375,9 +377,7 @@ function getCroppedContainerStyle(shape: TLImageShape) {
 		}
 	}
 
-	const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
-	const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
-
+	const { w, h } = getUncroppedSize(shape.props, crop)
 	const offsetX = -topLeft.x * w
 	const offsetY = -topLeft.y * h
 	return {

commit 7bd13bef2242ee7fe295607dfa87c248b6c0537c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Feb 25 16:43:51 2025 +0000

    [botcom] Fix slow export menu in big files (#5435)
    
    This PR fixes an issue where large files or files with GIFs / large
    images could freeze when opening the export menu.
    
    
    https://github.com/user-attachments/assets/af0b21c2-d50b-4106-bef6-7738868f863e
    
    ## GIFs
    
    Previously, we were inlining the entire GIF when creating an SVG. We now
    only inline the first frame. This was a crashing bug previously.
    
    ## Images / asset caching
    
    Previously, we were loading a URL for each image or video shape. We now
    cache the result of the previous generation, so that we only load one
    image per asset. This is especially important for GIFs because the work
    to generate the export image src associated with the asset was
    expensive.
    
    ## File size
    
    Previously, the image shown in the export panel could be very very large
    depending on the size of the canvas.
    
    **Problem**
    
    When we export images, we do so at 100% resolution. For large canvases,
    that can result in images which are very large (e.g. 5000x5000px or
    larger). Creating and displaying such a large image can be extremely
    hard on resources.
    
    **Solution**
    
    In this PR, we find a **scale** for the image based on the common bounds
    of the selected shapes, then apply that scale to keep the image small
    (under 500x500 pixels). We also use png instead of svg as the output
    format, which for small but dense images should work better. Together,
    these lead to preview images for even very large files (4000 draw
    shapes) being relatively quick. The actual exports are unaffected and
    slower.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Visit a very large file.
    2. Open the export menu.
    
    ### Release notes
    
    - Fixed a bug with export menu performance.

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index 44f3a4032..f3f6b8cc5 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -6,11 +6,14 @@ import {
 	Image,
 	MediaHelpers,
 	SvgExportContext,
+	TLAsset,
+	TLAssetId,
 	TLImageShape,
 	TLImageShapeProps,
 	TLResizeInfo,
 	TLShapePartial,
 	Vec,
+	WeakCache,
 	fetch,
 	imageShapeMigrations,
 	imageShapeProps,
@@ -37,6 +40,8 @@ async function getDataURIFromURL(url: string): Promise<string> {
 	return FileHelpers.blobToDataUrl(blob)
 }
 
+const imageSvgExportCache = new WeakCache<TLAsset, Promise<string | null>>()
+
 /** @public */
 export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 	static override type = 'image' as const
@@ -121,17 +126,29 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		if (!asset) return null
 
 		const { w } = getUncroppedSize(shape.props, shape.props.crop)
-		let src = await ctx.resolveAssetUrl(shape.props.assetId, w)
+
+		const src = await imageSvgExportCache.get(asset, async () => {
+			let src = await ctx.resolveAssetUrl(asset.id, w)
+			if (!src) return null
+			if (
+				src.startsWith('blob:') ||
+				src.startsWith('http') ||
+				src.startsWith('/') ||
+				src.startsWith('./')
+			) {
+				// If it's a remote image, we need to fetch it and convert it to a data URI
+				src = (await getDataURIFromURL(src)) || ''
+			}
+
+			// If it's animated then we need to get the first frame
+			if (getIsAnimated(this.editor, asset.id)) {
+				const { promise } = getFirstFrameOfAnimatedImage(src)
+				src = await promise
+			}
+			return src
+		})
+
 		if (!src) return null
-		if (
-			src.startsWith('blob:') ||
-			src.startsWith('http') ||
-			src.startsWith('/') ||
-			src.startsWith('./')
-		) {
-			// If it's a remote image, we need to fetch it and convert it to a data URI
-			src = (await getDataURIFromURL(src)) || ''
-		}
 
 		return <SvgImage shape={shape} src={src} />
 	}
@@ -216,32 +233,19 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 	const [staticFrameSrc, setStaticFrameSrc] = useState('')
 	const [loadedUrl, setLoadedUrl] = useState<null | string>(null)
 
-	const isAnimated = getIsAnimated(editor, shape)
+	const isAnimated = asset && getIsAnimated(editor, asset.id)
 
 	useEffect(() => {
 		if (url && isAnimated) {
-			let cancelled = false
-
-			const image = Image()
-			image.onload = () => {
-				if (cancelled) return
-
-				const canvas = document.createElement('canvas')
-				canvas.width = image.width
-				canvas.height = image.height
+			const { promise, cancel } = getFirstFrameOfAnimatedImage(url)
 
-				const ctx = canvas.getContext('2d')
-				if (!ctx) return
-
-				ctx.drawImage(image, 0, 0)
-				setStaticFrameSrc(canvas.toDataURL())
+			promise.then((dataUrl) => {
+				setStaticFrameSrc(dataUrl)
 				setLoadedUrl(url)
-			}
-			image.crossOrigin = 'anonymous'
-			image.src = url
+			})
 
 			return () => {
-				cancelled = true
+				cancel()
 			}
 		}
 	}, [editor, isAnimated, prefersReducedMotion, url])
@@ -348,8 +352,8 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 	)
 })
 
-function getIsAnimated(editor: Editor, shape: TLImageShape) {
-	const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : undefined
+function getIsAnimated(editor: Editor, assetId: TLAssetId) {
+	const asset = assetId ? editor.getAsset(assetId) : undefined
 
 	if (!asset) return false
 
@@ -407,6 +411,7 @@ function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
 	const cropClipId = useUniqueSafeId()
 	const containerStyle = getCroppedContainerStyle(shape)
 	const crop = shape.props.crop
+
 	if (containerStyle.transform && crop) {
 		const { transform: cropTransform, width, height } = containerStyle
 		const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
@@ -453,3 +458,28 @@ function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
 		)
 	}
 }
+
+function getFirstFrameOfAnimatedImage(url: string) {
+	let cancelled = false
+
+	const promise = new Promise<string>((resolve) => {
+		const image = Image()
+		image.onload = () => {
+			if (cancelled) return
+
+			const canvas = document.createElement('canvas')
+			canvas.width = image.width
+			canvas.height = image.height
+
+			const ctx = canvas.getContext('2d')
+			if (!ctx) return
+
+			ctx.drawImage(image, 0, 0)
+			resolve(canvas.toDataURL())
+		}
+		image.crossOrigin = 'anonymous'
+		image.src = url
+	})
+
+	return { promise, cancel: () => (cancelled = true) }
+}

commit 4ecb34d3434dbd9ad3119d4dfc66b7af4e598faf
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Apr 7 22:05:44 2025 +0100

    a11y: announce shapes as they're visited (#5773)
    
    Building off of https://github.com/tldraw/tldraw/pull/5634 and
    https://github.com/tldraw/tldraw/pull/5761 this is adding a11y live text
    to be read aloud when visiting a shape.
    
    We add an overridable method for shapes to customize this called
    `getAriaLiveText`.
    Furthermore, we lay the groundwork here to start letting media shapes
    have `altText`.
    Drive-by fix of `heart` being missing in `geo-styles` list.
    Also, drive-by fix of us calling our Image button "Asset" (what are we
    selling financial instruments here? :P) "Media" is a better word for
    this button, more human.
    
    Some of the i18n translation is funky. It's a shortcoming of our current
    system that we don't support interpolation :-/
    It sucks, and we'll revisit in the future.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - a11y: announce shapes as they're visited
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
index f3f6b8cc5..93d0a9370 100644
--- a/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx
@@ -65,9 +65,14 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 			crop: null,
 			flipX: false,
 			flipY: false,
+			altText: '',
 		}
 	}
 
+	override getAriaDescriptor(shape: TLImageShape) {
+		return shape.props.altText
+	}
+
 	override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
 		let resized: TLImageShape = resizeBox(shape, info)
 		const { flipX, flipY } = info.initialShape.props

