# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/DeferredFace.zig

commit 141182aa1371f356b9c6115fc05eba64ff75894c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Sep 16 15:06:00 2022 -0700

    start adding fontconfig conditional compilation

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
new file mode 100644
index 00000000..0a3f974f
--- /dev/null
+++ b/src/font/DeferredFace.zig
@@ -0,0 +1,37 @@
+//! A deferred face represents a single font face with all the information
+//! necessary to load it, but defers loading the full face until it is
+//! needed.
+//!
+//! This allows us to have many fallback fonts to look for glyphs, but
+//! only load them if they're really needed.
+const DeferredFace = @This();
+
+const std = @import("std");
+const assert = std.debug.assert;
+const fontconfig = @import("fontconfig");
+const options = @import("main.zig").options;
+const Face = @import("main.zig").Face;
+
+/// The loaded face (once loaded).
+face: ?Face = null,
+
+/// Fontconfig
+fc: if (options.fontconfig) Fontconfig else void = undefined,
+
+/// Fontconfig specific data. This is only present if building with fontconfig.
+pub const Fontconfig = struct {
+    pattern: *fontconfig.Pattern,
+    charset: *fontconfig.CharSet,
+    langset: *fontconfig.LangSet,
+};
+
+pub fn deinit(self: *DeferredFace) void {
+    if (self.face) |*face| face.deinit();
+
+    self.* = undefined;
+}
+
+/// Returns true if the face has been loaded.
+pub inline fn loaded(self: DeferredFace) bool {
+    return self.face != null;
+}

commit 1c1da63c7e634bc84ce386987a46e376b4c2225b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Sep 16 15:29:13 2022 -0700

    deferred face hasCodepoint

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 0a3f974f..dc3c46d5 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -11,6 +11,7 @@ const assert = std.debug.assert;
 const fontconfig = @import("fontconfig");
 const options = @import("main.zig").options;
 const Face = @import("main.zig").Face;
+const Presentation = @import("main.zig").Presentation;
 
 /// The loaded face (once loaded).
 face: ?Face = null,
@@ -35,3 +36,42 @@ pub fn deinit(self: *DeferredFace) void {
 pub inline fn loaded(self: DeferredFace) bool {
     return self.face != null;
 }
+
+/// Returns true if this face can satisfy the given codepoint and
+/// presentation. If presentation is null, then it just checks if the
+/// codepoint is present at all.
+///
+/// This should not require the face to be loaded IF we're using a
+/// discovery mechanism (i.e. fontconfig). If no discovery is used,
+/// the face is always expected to be loaded.
+pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
+    // If we have the face, use the face.
+    if (self.face) |face| {
+        if (p) |desired| if (face.presentation != desired) return false;
+        return face.glyphIndex(cp) != null;
+    }
+
+    // If we are using fontconfig, use the fontconfig metadata to
+    // avoid loading the face.
+    if (options.fontconfig) {
+        // Check if char exists
+        if (!self.fc.charset.hasChar(cp)) return false;
+
+        // If we have a presentation, check it matches
+        if (p) |desired| {
+            const emoji_lang = "und-zsye";
+            const actual: Presentation = if (self.fc.langset.hasLang(emoji_lang))
+                .emoji
+            else
+                .text;
+
+            return desired == actual;
+        }
+
+        return true;
+    }
+
+    // This is unreachable because discovery mechanisms terminate, and
+    // if we're not using a discovery mechanism, the face MUST be loaded.
+    unreachable;
+}

commit ac26c20e94c8098df90f126ab28069a390bcb30a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 17 09:21:23 2022 -0700

    font discovery builds up a set of deferred faces

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index dc3c46d5..e5e4cc13 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -17,18 +17,23 @@ const Presentation = @import("main.zig").Presentation;
 face: ?Face = null,
 
 /// Fontconfig
-fc: if (options.fontconfig) Fontconfig else void = undefined,
+fc: if (options.fontconfig) ?Fontconfig else void = if (options.fontconfig) null else {},
 
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
     pattern: *fontconfig.Pattern,
-    charset: *fontconfig.CharSet,
-    langset: *fontconfig.LangSet,
+    charset: *const fontconfig.CharSet,
+    langset: *const fontconfig.LangSet,
+
+    pub fn deinit(self: *Fontconfig) void {
+        self.pattern.destroy();
+        self.* = undefined;
+    }
 };
 
 pub fn deinit(self: *DeferredFace) void {
     if (self.face) |*face| face.deinit();
-
+    if (options.fontconfig) if (self.fc) |*fc| fc.deinit();
     self.* = undefined;
 }
 
@@ -54,21 +59,23 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     // If we are using fontconfig, use the fontconfig metadata to
     // avoid loading the face.
     if (options.fontconfig) {
-        // Check if char exists
-        if (!self.fc.charset.hasChar(cp)) return false;
+        if (self.fc) |fc| {
+            // Check if char exists
+            if (!fc.charset.hasChar(cp)) return false;
 
-        // If we have a presentation, check it matches
-        if (p) |desired| {
-            const emoji_lang = "und-zsye";
-            const actual: Presentation = if (self.fc.langset.hasLang(emoji_lang))
-                .emoji
-            else
-                .text;
+            // If we have a presentation, check it matches
+            if (p) |desired| {
+                const emoji_lang = "und-zsye";
+                const actual: Presentation = if (fc.langset.hasLang(emoji_lang))
+                    .emoji
+                else
+                    .text;
 
-            return desired == actual;
-        }
+                return desired == actual;
+            }
 
-        return true;
+            return true;
+        }
     }
 
     // This is unreachable because discovery mechanisms terminate, and

commit 92251ed913cf7b36103d41da2dc832831c764808
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 17 09:29:34 2022 -0700

    font group works with deferred faces exclusively

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index e5e4cc13..43efbcb7 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -13,6 +13,8 @@ const options = @import("main.zig").options;
 const Face = @import("main.zig").Face;
 const Presentation = @import("main.zig").Presentation;
 
+const Library = @import("main.zig").Library;
+
 /// The loaded face (once loaded).
 face: ?Face = null,
 
@@ -31,6 +33,12 @@ pub const Fontconfig = struct {
     }
 };
 
+/// Initialize a deferred face that is already pre-loaded. The deferred face
+/// takes ownership over the loaded face, deinit will deinit the loaded face.
+pub fn initLoaded(face: Face) DeferredFace {
+    return .{ .face = face };
+}
+
 pub fn deinit(self: *DeferredFace) void {
     if (self.face) |*face| face.deinit();
     if (options.fontconfig) if (self.fc) |*fc| fc.deinit();
@@ -82,3 +90,19 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     // if we're not using a discovery mechanism, the face MUST be loaded.
     unreachable;
 }
+
+test {
+    const testing = std.testing;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    errdefer face.deinit();
+
+    var def = initLoaded(face);
+    defer def.deinit();
+
+    try testing.expect(def.hasCodepoint(' ', null));
+}

commit bc9a0a36a8e21c02a8369b8e5c7cb733ac089acb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 17 10:05:26 2022 -0700

    store requested size alongside deferred font for loading

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 43efbcb7..8a4eb993 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -23,10 +23,21 @@ fc: if (options.fontconfig) ?Fontconfig else void = if (options.fontconfig) null
 
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
+    /// The pattern for this font. This must be the "render prepared" pattern.
+    /// (i.e. call FcFontRenderPrepare).
     pattern: *fontconfig.Pattern,
+
+    /// Charset and Langset are used for quick lookup if a codepoint and
+    /// presentation style are supported. They can be derived from pattern
+    /// but are cached since they're frequently used.
     charset: *const fontconfig.CharSet,
     langset: *const fontconfig.LangSet,
 
+    /// The requested size in points for this font. This is used for loading.
+    /// This can't be derived from pattern because the requested size may
+    /// differ from the size the font advertises supported.
+    req_size: u16,
+
     pub fn deinit(self: *Fontconfig) void {
         self.pattern.destroy();
         self.* = undefined;

commit 88a4cb65f3dee1245c3dd42328b2df06a77686ab
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Sep 23 12:09:40 2022 -0700

    src/font: working on initiaizing deferred fonts from fc

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 8a4eb993..7c82cb5d 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -61,6 +61,31 @@ pub inline fn loaded(self: DeferredFace) bool {
     return self.face != null;
 }
 
+pub fn load(self: *DeferredFace) !void {
+    // No-op if we already loaded
+    if (self.face != null) return;
+
+    if (options.fontconfig) {
+        try self.loadFontconfig();
+        return;
+    }
+
+    unreachable;
+}
+
+fn loadFontconfig(self: *DeferredFace) !void {
+    assert(self.face == null);
+    const fc = self.fc.?;
+
+    // Filename and index for our face so we can load it
+    const filename = (try fc.pattern.get(.file, 0)).string;
+    const face_index = (try fc.pattern.get(.index, 0)).integer;
+
+    self.face = try Face.initFile(filename, face_index, .{
+        .points = fc.req_size,
+    });
+}
+
 /// Returns true if this face can satisfy the given codepoint and
 /// presentation. If presentation is null, then it just checks if the
 /// codepoint is present at all.

commit b11ed06fc27986257211c59883e9e6c6602cdcf8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 24 06:24:51 2022 -0700

    font: test loading deferred face for fontconfig

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 7c82cb5d..4693ed5b 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -10,11 +10,10 @@ const std = @import("std");
 const assert = std.debug.assert;
 const fontconfig = @import("fontconfig");
 const options = @import("main.zig").options;
+const Library = @import("main.zig").Library;
 const Face = @import("main.zig").Face;
 const Presentation = @import("main.zig").Presentation;
 
-const Library = @import("main.zig").Library;
-
 /// The loaded face (once loaded).
 face: ?Face = null,
 
@@ -61,19 +60,22 @@ pub inline fn loaded(self: DeferredFace) bool {
     return self.face != null;
 }
 
-pub fn load(self: *DeferredFace) !void {
+/// Load the deferred font face. This does nothing if the face is loaded.
+pub fn load(self: *DeferredFace, lib: Library) !void {
     // No-op if we already loaded
     if (self.face != null) return;
 
     if (options.fontconfig) {
-        try self.loadFontconfig();
+        try self.loadFontconfig(lib);
         return;
     }
 
+    // Unreachable because we must be already loaded or have the
+    // proper configuration for one of the other deferred mechanisms.
     unreachable;
 }
 
-fn loadFontconfig(self: *DeferredFace) !void {
+fn loadFontconfig(self: *DeferredFace, lib: Library) !void {
     assert(self.face == null);
     const fc = self.fc.?;
 
@@ -81,7 +83,7 @@ fn loadFontconfig(self: *DeferredFace) !void {
     const filename = (try fc.pattern.get(.file, 0)).string;
     const face_index = (try fc.pattern.get(.index, 0)).integer;
 
-    self.face = try Face.initFile(filename, face_index, .{
+    self.face = try Face.initFile(lib, filename, face_index, .{
         .points = fc.req_size,
     });
 }
@@ -127,7 +129,7 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     unreachable;
 }
 
-test {
+test "preloaded" {
     const testing = std.testing;
     const testFont = @import("test.zig").fontRegular;
 
@@ -142,3 +144,29 @@ test {
 
     try testing.expect(def.hasCodepoint(' ', null));
 }
+
+test "fontconfig" {
+    if (!options.fontconfig) return error.SkipZigTest;
+
+    const discovery = @import("main.zig").discovery;
+    const testing = std.testing;
+
+    // Load freetype
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    // Get a deferred face from fontconfig
+    var def = def: {
+        var fc = discovery.Fontconfig.init();
+        var it = try fc.discover(.{ .family = "monospace", .size = 12 });
+        defer it.deinit();
+        break :def (try it.next()).?;
+    };
+    defer def.deinit();
+    try testing.expect(!def.loaded());
+
+    // Load it and verify it works
+    try def.load(lib);
+    try testing.expect(def.hasCodepoint(' ', null));
+    try testing.expect(def.face.?.glyphIndex(' ') != null);
+}

commit b6a4fff6d8d141f6738e0d01efcfb7518e8f1602
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 29 11:57:29 2022 -0700

    search for fonts on startup

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 4693ed5b..b6bef738 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -32,11 +32,6 @@ pub const Fontconfig = struct {
     charset: *const fontconfig.CharSet,
     langset: *const fontconfig.LangSet,
 
-    /// The requested size in points for this font. This is used for loading.
-    /// This can't be derived from pattern because the requested size may
-    /// differ from the size the font advertises supported.
-    req_size: u16,
-
     pub fn deinit(self: *Fontconfig) void {
         self.pattern.destroy();
         self.* = undefined;
@@ -60,13 +55,28 @@ pub inline fn loaded(self: DeferredFace) bool {
     return self.face != null;
 }
 
+/// Returns the name of this face. The memory is always owned by the
+/// face so it doesn't have to be freed.
+pub fn name(self: DeferredFace) ![:0]const u8 {
+    if (options.fontconfig) {
+        if (self.fc) |fc|
+            return (try fc.pattern.get(.fullname, 0)).string;
+    }
+
+    return "TODO: built-in font names";
+}
+
 /// Load the deferred font face. This does nothing if the face is loaded.
-pub fn load(self: *DeferredFace, lib: Library) !void {
+pub fn load(
+    self: *DeferredFace,
+    lib: Library,
+    size: Face.DesiredSize,
+) !void {
     // No-op if we already loaded
     if (self.face != null) return;
 
     if (options.fontconfig) {
-        try self.loadFontconfig(lib);
+        try self.loadFontconfig(lib, size);
         return;
     }
 
@@ -75,7 +85,11 @@ pub fn load(self: *DeferredFace, lib: Library) !void {
     unreachable;
 }
 
-fn loadFontconfig(self: *DeferredFace, lib: Library) !void {
+fn loadFontconfig(
+    self: *DeferredFace,
+    lib: Library,
+    size: Face.DesiredSize,
+) !void {
     assert(self.face == null);
     const fc = self.fc.?;
 
@@ -83,9 +97,7 @@ fn loadFontconfig(self: *DeferredFace, lib: Library) !void {
     const filename = (try fc.pattern.get(.file, 0)).string;
     const face_index = (try fc.pattern.get(.index, 0)).integer;
 
-    self.face = try Face.initFile(lib, filename, face_index, .{
-        .points = fc.req_size,
-    });
+    self.face = try Face.initFile(lib, filename, face_index, size);
 }
 
 /// Returns true if this face can satisfy the given codepoint and
@@ -165,8 +177,12 @@ test "fontconfig" {
     defer def.deinit();
     try testing.expect(!def.loaded());
 
+    // Verify we can get the name
+    const n = try def.name();
+    try testing.expect(n.len > 0);
+
     // Load it and verify it works
-    try def.load(lib);
+    try def.load(lib, .{ .points = 12 });
     try testing.expect(def.hasCodepoint(' ', null));
     try testing.expect(def.face.?.glyphIndex(' ') != null);
 }

commit 12c9482d48790c3a2b3b01dbc349a6a06339ac14
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 1 22:21:30 2022 -0700

    Mac Font Discovery with CoreText (#17)
    
    This implements font discovery so the `--font-family` flag works for macOS. Fonts are looked up using the Core Text API so any installed font on the Mac system can be used.
    
    We still use FreeType for rendering, and CoreText doesn't _quite_ give us all the information we need to build the exact face in FreeType. So a TODO after this is to now implement glyph _rendering_ using Core Text and Core Graphics. Until then, a couple fonts don't quite work (i.e. Monaco, a big one!) but many do!

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index b6bef738..f2ff2820 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -9,6 +9,7 @@ const DeferredFace = @This();
 const std = @import("std");
 const assert = std.debug.assert;
 const fontconfig = @import("fontconfig");
+const macos = @import("macos");
 const options = @import("main.zig").options;
 const Library = @import("main.zig").Library;
 const Face = @import("main.zig").Face;
@@ -20,6 +21,9 @@ face: ?Face = null,
 /// Fontconfig
 fc: if (options.fontconfig) ?Fontconfig else void = if (options.fontconfig) null else {},
 
+/// CoreText
+ct: if (options.coretext) ?CoreText else void = if (options.coretext) null else {},
+
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
     /// The pattern for this font. This must be the "render prepared" pattern.
@@ -38,6 +42,17 @@ pub const Fontconfig = struct {
     }
 };
 
+/// CoreText specific data. This is only present when building with CoreText.
+pub const CoreText = struct {
+    /// The initialized font
+    font: *macos.text.Font,
+
+    pub fn deinit(self: *CoreText) void {
+        self.font.release();
+        self.* = undefined;
+    }
+};
+
 /// Initialize a deferred face that is already pre-loaded. The deferred face
 /// takes ownership over the loaded face, deinit will deinit the loaded face.
 pub fn initLoaded(face: Face) DeferredFace {
@@ -47,6 +62,7 @@ pub fn initLoaded(face: Face) DeferredFace {
 pub fn deinit(self: *DeferredFace) void {
     if (self.face) |*face| face.deinit();
     if (options.fontconfig) if (self.fc) |*fc| fc.deinit();
+    if (options.coretext) if (self.ct) |*ct| ct.deinit();
     self.* = undefined;
 }
 
@@ -63,6 +79,13 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
             return (try fc.pattern.get(.fullname, 0)).string;
     }
 
+    if (options.coretext) {
+        if (self.ct) |ct| {
+            const display_name = ct.font.copyDisplayName();
+            return display_name.cstringPtr(.utf8) orelse "<unsupported internal encoding>";
+        }
+    }
+
     return "TODO: built-in font names";
 }
 
@@ -80,6 +103,11 @@ pub fn load(
         return;
     }
 
+    if (options.coretext) {
+        try self.loadCoreText(lib, size);
+        return;
+    }
+
     // Unreachable because we must be already loaded or have the
     // proper configuration for one of the other deferred mechanisms.
     unreachable;
@@ -100,6 +128,45 @@ fn loadFontconfig(
     self.face = try Face.initFile(lib, filename, face_index, size);
 }
 
+fn loadCoreText(
+    self: *DeferredFace,
+    lib: Library,
+    size: Face.DesiredSize,
+) !void {
+    assert(self.face == null);
+    const ct = self.ct.?;
+
+    // Get the URL for the font so we can get the filepath
+    const url = ct.font.copyAttribute(.url);
+    defer url.release();
+
+    // Get the path from the URL
+    const path = url.copyPath() orelse return error.FontHasNoFile;
+    defer path.release();
+
+    // URL decode the path
+    const blank = try macos.foundation.String.createWithBytes("", .utf8, false);
+    defer blank.release();
+    const decoded = try macos.foundation.URL.createStringByReplacingPercentEscapes(
+        path,
+        blank,
+    );
+    defer decoded.release();
+
+    // Decode into a c string. 1024 bytes should be enough for anybody.
+    var buf: [1024]u8 = undefined;
+    const path_slice = decoded.cstring(buf[0..1023], .utf8) orelse
+        return error.FontPathCantDecode;
+
+    // Freetype requires null-terminated. We always leave space at
+    // the end for a zero so we set that up here.
+    buf[path_slice.len] = 0;
+
+    // TODO: face index 0 is not correct long term and we should switch
+    // to using CoreText for rendering, too.
+    self.face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
+}
+
 /// Returns true if this face can satisfy the given codepoint and
 /// presentation. If presentation is null, then it just checks if the
 /// codepoint is present at all.
@@ -136,6 +203,20 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
         }
     }
 
+    // If we are using coretext, we check the loaded CT font.
+    if (options.coretext) {
+        if (self.ct) |ct| {
+            // Turn UTF-32 into UTF-16 for CT API
+            var unichars: [2]u16 = undefined;
+            const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
+            const len: usize = if (pair) 2 else 1;
+
+            // Get our glyphs
+            var glyphs = [2]macos.graphics.Glyph{ 0, 0 };
+            return ct.font.getGlyphsForCharacters(unichars[0..len], glyphs[0..len]);
+        }
+    }
+
     // This is unreachable because discovery mechanisms terminate, and
     // if we're not using a discovery mechanism, the face MUST be loaded.
     unreachable;
@@ -186,3 +267,34 @@ test "fontconfig" {
     try testing.expect(def.hasCodepoint(' ', null));
     try testing.expect(def.face.?.glyphIndex(' ') != null);
 }
+
+test "coretext" {
+    if (!options.coretext) return error.SkipZigTest;
+
+    const discovery = @import("main.zig").discovery;
+    const testing = std.testing;
+
+    // Load freetype
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    // Get a deferred face from fontconfig
+    var def = def: {
+        var fc = discovery.CoreText.init();
+        var it = try fc.discover(.{ .family = "Monaco", .size = 12 });
+        defer it.deinit();
+        break :def (try it.next()).?;
+    };
+    defer def.deinit();
+    try testing.expect(!def.loaded());
+    try testing.expect(def.hasCodepoint(' ', null));
+
+    // Verify we can get the name
+    const n = try def.name();
+    try testing.expect(n.len > 0);
+
+    // Load it and verify it works
+    try def.load(lib, .{ .points = 12 });
+    try testing.expect(def.hasCodepoint(' ', null));
+    try testing.expect(def.face.?.glyphIndex(' ') != null);
+}

commit f41cbf228beccbe8acf852aead5c7f268f0fd8b0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 2 09:41:37 2022 -0700

    font: set "backend" enum vs booleans

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index f2ff2820..02012a72 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -19,10 +19,12 @@ const Presentation = @import("main.zig").Presentation;
 face: ?Face = null,
 
 /// Fontconfig
-fc: if (options.fontconfig) ?Fontconfig else void = if (options.fontconfig) null else {},
+fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
+    if (options.backend == .fontconfig_freetype) null else {},
 
 /// CoreText
-ct: if (options.coretext) ?CoreText else void = if (options.coretext) null else {},
+ct: if (options.backend == .coretext) ?CoreText else void =
+    if (options.backend == .coretext) null else {},
 
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
@@ -61,8 +63,11 @@ pub fn initLoaded(face: Face) DeferredFace {
 
 pub fn deinit(self: *DeferredFace) void {
     if (self.face) |*face| face.deinit();
-    if (options.fontconfig) if (self.fc) |*fc| fc.deinit();
-    if (options.coretext) if (self.ct) |*ct| ct.deinit();
+    switch (options.backend) {
+        .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
+        .coretext => if (self.ct) |*ct| ct.deinit(),
+        .freetype => {},
+    }
     self.* = undefined;
 }
 
@@ -74,16 +79,16 @@ pub inline fn loaded(self: DeferredFace) bool {
 /// Returns the name of this face. The memory is always owned by the
 /// face so it doesn't have to be freed.
 pub fn name(self: DeferredFace) ![:0]const u8 {
-    if (options.fontconfig) {
-        if (self.fc) |fc|
-            return (try fc.pattern.get(.fullname, 0)).string;
-    }
+    switch (options.backend) {
+        .fontconfig_freetype => if (self.fc) |fc|
+            return (try fc.pattern.get(.fullname, 0)).string,
 
-    if (options.coretext) {
-        if (self.ct) |ct| {
+        .coretext => if (self.ct) |ct| {
             const display_name = ct.font.copyDisplayName();
             return display_name.cstringPtr(.utf8) orelse "<unsupported internal encoding>";
-        }
+        },
+
+        .freetype => {},
     }
 
     return "TODO: built-in font names";
@@ -98,19 +103,21 @@ pub fn load(
     // No-op if we already loaded
     if (self.face != null) return;
 
-    if (options.fontconfig) {
-        try self.loadFontconfig(lib, size);
-        return;
-    }
+    switch (options.backend) {
+        .fontconfig_freetype => {
+            try self.loadFontconfig(lib, size);
+            return;
+        },
 
-    if (options.coretext) {
-        try self.loadCoreText(lib, size);
-        return;
-    }
+        .coretext => {
+            try self.loadCoreText(lib, size);
+            return;
+        },
 
-    // Unreachable because we must be already loaded or have the
-    // proper configuration for one of the other deferred mechanisms.
-    unreachable;
+        // Unreachable because we must be already loaded or have the
+        // proper configuration for one of the other deferred mechanisms.
+        .freetype => unreachable,
+    }
 }
 
 fn loadFontconfig(
@@ -181,40 +188,44 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
         return face.glyphIndex(cp) != null;
     }
 
-    // If we are using fontconfig, use the fontconfig metadata to
-    // avoid loading the face.
-    if (options.fontconfig) {
-        if (self.fc) |fc| {
-            // Check if char exists
-            if (!fc.charset.hasChar(cp)) return false;
-
-            // If we have a presentation, check it matches
-            if (p) |desired| {
-                const emoji_lang = "und-zsye";
-                const actual: Presentation = if (fc.langset.hasLang(emoji_lang))
-                    .emoji
-                else
-                    .text;
-
-                return desired == actual;
+    switch (options.backend) {
+        .fontconfig_freetype => {
+            // If we are using fontconfig, use the fontconfig metadata to
+            // avoid loading the face.
+            if (self.fc) |fc| {
+                // Check if char exists
+                if (!fc.charset.hasChar(cp)) return false;
+
+                // If we have a presentation, check it matches
+                if (p) |desired| {
+                    const emoji_lang = "und-zsye";
+                    const actual: Presentation = if (fc.langset.hasLang(emoji_lang))
+                        .emoji
+                    else
+                        .text;
+
+                    return desired == actual;
+                }
+
+                return true;
             }
+        },
+
+        .coretext => {
+            // If we are using coretext, we check the loaded CT font.
+            if (self.ct) |ct| {
+                // Turn UTF-32 into UTF-16 for CT API
+                var unichars: [2]u16 = undefined;
+                const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
+                const len: usize = if (pair) 2 else 1;
+
+                // Get our glyphs
+                var glyphs = [2]macos.graphics.Glyph{ 0, 0 };
+                return ct.font.getGlyphsForCharacters(unichars[0..len], glyphs[0..len]);
+            }
+        },
 
-            return true;
-        }
-    }
-
-    // If we are using coretext, we check the loaded CT font.
-    if (options.coretext) {
-        if (self.ct) |ct| {
-            // Turn UTF-32 into UTF-16 for CT API
-            var unichars: [2]u16 = undefined;
-            const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
-            const len: usize = if (pair) 2 else 1;
-
-            // Get our glyphs
-            var glyphs = [2]macos.graphics.Glyph{ 0, 0 };
-            return ct.font.getGlyphsForCharacters(unichars[0..len], glyphs[0..len]);
-        }
+        .freetype => {},
     }
 
     // This is unreachable because discovery mechanisms terminate, and
@@ -239,7 +250,7 @@ test "preloaded" {
 }
 
 test "fontconfig" {
-    if (!options.fontconfig) return error.SkipZigTest;
+    if (options.backend != .fontconfig_freetype) return error.SkipZigTest;
 
     const discovery = @import("main.zig").discovery;
     const testing = std.testing;
@@ -269,7 +280,7 @@ test "fontconfig" {
 }
 
 test "coretext" {
-    if (!options.coretext) return error.SkipZigTest;
+    if (options.backend != .coretext) return error.SkipZigTest;
 
     const discovery = @import("main.zig").discovery;
     const testing = std.testing;

commit 71ec50993096eda18001f802e84a2c28ddfa044d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:19:21 2022 -0700

    Make font face a compile time interface, stub for coretext

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 02012a72..19585be5 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -10,6 +10,7 @@ const std = @import("std");
 const assert = std.debug.assert;
 const fontconfig = @import("fontconfig");
 const macos = @import("macos");
+const font = @import("main.zig");
 const options = @import("main.zig").options;
 const Library = @import("main.zig").Library;
 const Face = @import("main.zig").Face;
@@ -98,7 +99,7 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
 pub fn load(
     self: *DeferredFace,
     lib: Library,
-    size: Face.DesiredSize,
+    size: font.face.DesiredSize,
 ) !void {
     // No-op if we already loaded
     if (self.face != null) return;
@@ -123,7 +124,7 @@ pub fn load(
 fn loadFontconfig(
     self: *DeferredFace,
     lib: Library,
-    size: Face.DesiredSize,
+    size: font.face.DesiredSize,
 ) !void {
     assert(self.face == null);
     const fc = self.fc.?;
@@ -138,7 +139,7 @@ fn loadFontconfig(
 fn loadCoreText(
     self: *DeferredFace,
     lib: Library,
-    size: Face.DesiredSize,
+    size: font.face.DesiredSize,
 ) !void {
     assert(self.face == null);
     const ct = self.ct.?;

commit 723db8be2f242f527a0d33891bbd21f8cbee239a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:55:22 2022 -0700

    font: coretext face presentation

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 19585be5..a3131d55 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -111,7 +111,13 @@ pub fn load(
         },
 
         .coretext => {
-            try self.loadCoreText(lib, size);
+            // It is possible to use CoreText with Freetype so we support
+            // both here.
+            switch (font.Face) {
+                font.face.freetype.Face => try self.loadCoreTextFreetype(lib, size),
+                else => unreachable,
+            }
+
             return;
         },
 
@@ -136,7 +142,7 @@ fn loadFontconfig(
     self.face = try Face.initFile(lib, filename, face_index, size);
 }
 
-fn loadCoreText(
+fn loadCoreTextFreetype(
     self: *DeferredFace,
     lib: Library,
     size: font.face.DesiredSize,

commit f393049988be016dd46525492e1d51673954a99a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 11:25:54 2022 -0700

    fix compilation

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index a3131d55..ed4a4517 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -114,7 +114,7 @@ pub fn load(
             // It is possible to use CoreText with Freetype so we support
             // both here.
             switch (font.Face) {
-                font.face.freetype.Face => try self.loadCoreTextFreetype(lib, size),
+                @import("face/freetype.zig").Face => try self.loadCoreTextFreetype(lib, size),
                 else => unreachable,
             }
 

commit 9c99a49ac57975f38e0a6c499208dcf5a3708918
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 11:28:28 2022 -0700

    font: deferred face can load core text backend

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index ed4a4517..0407ec3c 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -115,6 +115,7 @@ pub fn load(
             // both here.
             switch (font.Face) {
                 @import("face/freetype.zig").Face => try self.loadCoreTextFreetype(lib, size),
+                @import("face/coretext.zig").Face => try self.loadCoreText(lib, size),
                 else => unreachable,
             }
 
@@ -142,6 +143,17 @@ fn loadFontconfig(
     self.face = try Face.initFile(lib, filename, face_index, size);
 }
 
+fn loadCoreText(
+    self: *DeferredFace,
+    lib: Library,
+    size: font.face.DesiredSize,
+) !void {
+    _ = lib;
+    assert(self.face == null);
+    const ct = self.ct.?;
+    self.face = try Face.initFontCopy(ct.font, size);
+}
+
 fn loadCoreTextFreetype(
     self: *DeferredFace,
     lib: Library,

commit 2e1bc7bb016f4b19ac06a491df68c64aef46e057
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 16 20:47:21 2022 -0700

    Bring back freetype font bitmap conversion
    
    Monaco on Mac is mono

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 0407ec3c..64a9f6e9 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -190,6 +190,7 @@ fn loadCoreTextFreetype(
 
     // TODO: face index 0 is not correct long term and we should switch
     // to using CoreText for rendering, too.
+    //std.log.warn("path={s}", .{path_slice});
     self.face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
 }
 

commit b858aea1241206fa2d2c510a0ef13017a31d7b6d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 30 15:05:09 2022 -0800

    Start scaffolding web_canvas backend

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 64a9f6e9..9ae816fa 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -68,6 +68,8 @@ pub fn deinit(self: *DeferredFace) void {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
         .coretext => if (self.ct) |*ct| ct.deinit(),
         .freetype => {},
+        // TODO
+        .web_canvas => unreachable,
     }
     self.* = undefined;
 }
@@ -90,6 +92,9 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
         },
 
         .freetype => {},
+
+        // TODO
+        .web_canvas => unreachable,
     }
 
     return "TODO: built-in font names";
@@ -122,6 +127,9 @@ pub fn load(
             return;
         },
 
+        // TODO
+        .web_canvas => unreachable,
+
         // Unreachable because we must be already loaded or have the
         // proper configuration for one of the other deferred mechanisms.
         .freetype => unreachable,
@@ -245,6 +253,9 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
             }
         },
 
+        // TODO
+        .web_canvas => unreachable,
+
         .freetype => {},
     }
 

commit 2a74330911bb9cb000f5c2671b0854da683e505d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 5 16:08:20 2022 -0800

    font: begin making Group work with wasm

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 9ae816fa..0c8fd709 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -24,8 +24,8 @@ fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
     if (options.backend == .fontconfig_freetype) null else {},
 
 /// CoreText
-ct: if (options.backend == .coretext) ?CoreText else void =
-    if (options.backend == .coretext) null else {},
+ct: if (font.Discover == font.discovery.CoreText) ?CoreText else void =
+    if (font.Discover == font.discovery.CoreText) null else {},
 
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
@@ -66,7 +66,7 @@ pub fn deinit(self: *DeferredFace) void {
     if (self.face) |*face| face.deinit();
     switch (options.backend) {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
-        .coretext => if (self.ct) |*ct| ct.deinit(),
+        .coretext, .coretext_freetype => if (self.ct) |*ct| ct.deinit(),
         .freetype => {},
         // TODO
         .web_canvas => unreachable,
@@ -86,7 +86,7 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.fullname, 0)).string,
 
-        .coretext => if (self.ct) |ct| {
+        .coretext, .coretext_freetype => if (self.ct) |ct| {
             const display_name = ct.font.copyDisplayName();
             return display_name.cstringPtr(.utf8) orelse "<unsupported internal encoding>";
         },
@@ -116,14 +116,12 @@ pub fn load(
         },
 
         .coretext => {
-            // It is possible to use CoreText with Freetype so we support
-            // both here.
-            switch (font.Face) {
-                @import("face/freetype.zig").Face => try self.loadCoreTextFreetype(lib, size),
-                @import("face/coretext.zig").Face => try self.loadCoreText(lib, size),
-                else => unreachable,
-            }
+            try self.loadCoreText(lib, size);
+            return;
+        },
 
+        .coretext_freetype => {
+            try self.loadCoreTextFreetype(lib, size);
             return;
         },
 
@@ -239,7 +237,7 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
             }
         },
 
-        .coretext => {
+        .coretext, .coretext_freetype => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
                 // Turn UTF-32 into UTF-16 for CT API

commit 52915012516d05beee86772840d2c6b4b71d0b6f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 5 20:28:50 2022 -0800

    font: DeferredFace is wasm-compatible

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 0c8fd709..23d8598a 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -8,6 +8,7 @@ const DeferredFace = @This();
 
 const std = @import("std");
 const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
 const fontconfig = @import("fontconfig");
 const macos = @import("macos");
 const font = @import("main.zig");
@@ -16,6 +17,8 @@ const Library = @import("main.zig").Library;
 const Face = @import("main.zig").Face;
 const Presentation = @import("main.zig").Presentation;
 
+const log = std.log.scoped(.deferred_face);
+
 /// The loaded face (once loaded).
 face: ?Face = null,
 
@@ -27,6 +30,10 @@ fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
 ct: if (font.Discover == font.discovery.CoreText) ?CoreText else void =
     if (font.Discover == font.discovery.CoreText) null else {},
 
+/// Canvas
+wc: if (options.backend == .web_canvas) ?WebCanvas else void =
+    if (options.backend == .web_canvas) null else {},
+
 /// Fontconfig specific data. This is only present if building with fontconfig.
 pub const Fontconfig = struct {
     /// The pattern for this font. This must be the "render prepared" pattern.
@@ -56,6 +63,20 @@ pub const CoreText = struct {
     }
 };
 
+/// WebCanvas specific data. This is only present when building with canvas.
+pub const WebCanvas = struct {
+    /// The allocator to use for fonts
+    alloc: Allocator,
+
+    /// The string to use for the "font" attribute for the canvas
+    font_str: [:0]const u8,
+
+    pub fn deinit(self: *WebCanvas) void {
+        self.alloc.free(self.font_str);
+        self.* = undefined;
+    }
+};
+
 /// Initialize a deferred face that is already pre-loaded. The deferred face
 /// takes ownership over the loaded face, deinit will deinit the loaded face.
 pub fn initLoaded(face: Face) DeferredFace {
@@ -68,8 +89,7 @@ pub fn deinit(self: *DeferredFace) void {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
         .coretext, .coretext_freetype => if (self.ct) |*ct| ct.deinit(),
         .freetype => {},
-        // TODO
-        .web_canvas => unreachable,
+        .web_canvas => if (self.wc) |*wc| wc.deinit(),
     }
     self.* = undefined;
 }
@@ -83,6 +103,8 @@ pub inline fn loaded(self: DeferredFace) bool {
 /// face so it doesn't have to be freed.
 pub fn name(self: DeferredFace) ![:0]const u8 {
     switch (options.backend) {
+        .freetype => {},
+
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.fullname, 0)).string,
 
@@ -91,10 +113,7 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
             return display_name.cstringPtr(.utf8) orelse "<unsupported internal encoding>";
         },
 
-        .freetype => {},
-
-        // TODO
-        .web_canvas => unreachable,
+        .web_canvas => if (self.wc) |wc| return wc.font_str,
     }
 
     return "TODO: built-in font names";
@@ -125,8 +144,10 @@ pub fn load(
             return;
         },
 
-        // TODO
-        .web_canvas => unreachable,
+        .web_canvas => {
+            try self.loadWebCanvas(size);
+            return;
+        },
 
         // Unreachable because we must be already loaded or have the
         // proper configuration for one of the other deferred mechanisms.
@@ -200,6 +221,15 @@ fn loadCoreTextFreetype(
     self.face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
 }
 
+fn loadWebCanvas(
+    self: *DeferredFace,
+    size: font.face.DesiredSize,
+) !void {
+    assert(self.face == null);
+    const wc = self.wc.?;
+    self.face = try Face.initNamed(wc.alloc, wc.font_str, size);
+}
+
 /// Returns true if this face can satisfy the given codepoint and
 /// presentation. If presentation is null, then it just checks if the
 /// codepoint is present at all.
@@ -251,8 +281,9 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
             }
         },
 
-        // TODO
-        .web_canvas => unreachable,
+        // Canvas always has the codepoint because we have no way of
+        // really checking and we let the browser handle it.
+        .web_canvas => return true,
 
         .freetype => {},
     }
@@ -262,6 +293,57 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     unreachable;
 }
 
+/// The wasm-compatible API.
+pub const Wasm = struct {
+    const wasm = @import("../os/wasm.zig");
+    const alloc = wasm.alloc;
+
+    export fn deferred_face_new(ptr: [*]const u8, len: usize) ?*DeferredFace {
+        return deferred_face_new_(ptr, len) catch |err| {
+            log.warn("error creating deferred face err={}", .{err});
+            return null;
+        };
+    }
+
+    fn deferred_face_new_(ptr: [*]const u8, len: usize) !*DeferredFace {
+        var font_str = try alloc.dupeZ(u8, ptr[0..len]);
+        errdefer alloc.free(font_str);
+
+        var face: DeferredFace = .{
+            .wc = .{
+                .alloc = alloc,
+                .font_str = font_str,
+            },
+        };
+        errdefer face.deinit();
+
+        var result = try alloc.create(DeferredFace);
+        errdefer alloc.destroy(result);
+        result.* = face;
+        return result;
+    }
+
+    export fn deferred_face_free(ptr: ?*DeferredFace) void {
+        if (ptr) |v| {
+            v.deinit();
+            alloc.destroy(v);
+        }
+    }
+
+    export fn deferred_face_load(self: *DeferredFace, pts: u16) void {
+        self.load(.{}, .{ .points = pts }) catch |err| {
+            log.warn("error loading deferred face err={}", .{err});
+            return;
+        };
+    }
+
+    /// Caller should not free this, the face is owned by the deferred face.
+    export fn deferred_face_face(self: *DeferredFace) ?*Face {
+        assert(self.loaded());
+        return &self.face.?;
+    }
+};
+
 test "preloaded" {
     const testing = std.testing;
     const testFont = @import("test.zig").fontRegular;

commit 6aa212707ee9a8e7e3a801c7e8fa268eb7ec1063
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 6 10:55:42 2022 -0800

    font: web canvas can render emoji

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 23d8598a..38edd28b 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -71,6 +71,9 @@ pub const WebCanvas = struct {
     /// The string to use for the "font" attribute for the canvas
     font_str: [:0]const u8,
 
+    /// The presentation for this font.
+    presentation: Presentation,
+
     pub fn deinit(self: *WebCanvas) void {
         self.alloc.free(self.font_str);
         self.* = undefined;
@@ -227,7 +230,7 @@ fn loadWebCanvas(
 ) !void {
     assert(self.face == null);
     const wc = self.wc.?;
-    self.face = try Face.initNamed(wc.alloc, wc.font_str, size);
+    self.face = try Face.initNamed(wc.alloc, wc.font_str, size, wc.presentation);
 }
 
 /// Returns true if this face can satisfy the given codepoint and
@@ -283,7 +286,13 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
 
         // Canvas always has the codepoint because we have no way of
         // really checking and we let the browser handle it.
-        .web_canvas => return true,
+        .web_canvas => {
+            if (self.wc) |wc| {
+                if (p) |desired| if (wc.presentation != desired) return false;
+            }
+
+            return true;
+        },
 
         .freetype => {},
     }
@@ -298,14 +307,14 @@ pub const Wasm = struct {
     const wasm = @import("../os/wasm.zig");
     const alloc = wasm.alloc;
 
-    export fn deferred_face_new(ptr: [*]const u8, len: usize) ?*DeferredFace {
-        return deferred_face_new_(ptr, len) catch |err| {
+    export fn deferred_face_new(ptr: [*]const u8, len: usize, presentation: u16) ?*DeferredFace {
+        return deferred_face_new_(ptr, len, presentation) catch |err| {
             log.warn("error creating deferred face err={}", .{err});
             return null;
         };
     }
 
-    fn deferred_face_new_(ptr: [*]const u8, len: usize) !*DeferredFace {
+    fn deferred_face_new_(ptr: [*]const u8, len: usize, presentation: u16) !*DeferredFace {
         var font_str = try alloc.dupeZ(u8, ptr[0..len]);
         errdefer alloc.free(font_str);
 
@@ -313,6 +322,7 @@ pub const Wasm = struct {
             .wc = .{
                 .alloc = alloc,
                 .font_str = font_str,
+                .presentation = @intToEnum(font.Presentation, presentation),
             },
         };
         errdefer face.deinit();

commit 0c9a9b1f9164103f5b8774518183aebcfe193018
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 7 19:20:04 2022 -0800

    font: web canvas face has to render to check presentation for cp
    
    Since we have no way to detect our presentation (text/emoji), we need to
    actually render the glyph that is being requested to double-check that
    the glyph matches our supported presentation.
    
    We do this because the browser will render fallback fonts for a glyph if
    it can't find one in the named font.

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 38edd28b..94fd7bd1 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -286,12 +286,29 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
 
         // Canvas always has the codepoint because we have no way of
         // really checking and we let the browser handle it.
-        .web_canvas => {
-            if (self.wc) |wc| {
-                if (p) |desired| if (wc.presentation != desired) return false;
-            }
-
-            return true;
+        .web_canvas => if (self.wc) |wc| {
+            // Fast-path if we have a specific presentation and we
+            // don't match, then it is definitely not this face.
+            if (p) |desired| if (wc.presentation != desired) return false;
+
+            // Slow-path: we initialize the font, render it, and check
+            // if it works and the presentation matches.
+            var face = Face.initNamed(
+                wc.alloc,
+                wc.font_str,
+                .{ .points = 12 },
+                wc.presentation,
+            ) catch |err| {
+                log.warn("failed to init face for codepoint check " ++
+                    "face={s} err={}", .{
+                    wc.font_str,
+                    err,
+                });
+
+                return false;
+            };
+            defer face.deinit();
+            return face.glyphIndex(cp) != null;
         },
 
         .freetype => {},

commit 01de38b20d94436492e351a75e2f29e9bab3aac9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 22:03:27 2023 -0700

    font: if CoreText needs to allocate, stack allocate and log

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 94fd7bd1..a91589b5 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -113,7 +113,21 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
 
         .coretext, .coretext_freetype => if (self.ct) |ct| {
             const display_name = ct.font.copyDisplayName();
-            return display_name.cstringPtr(.utf8) orelse "<unsupported internal encoding>";
+            return display_name.cstringPtr(.utf8) orelse unsupported: {
+                // "NULL if the internal storage of theString does not allow
+                // this to be returned efficiently." In this case, we need
+                // to allocate. But we can't return an allocated string because
+                // we don't have an allocator. Let's use the stack and log it.
+                var buf: [1024]u8 = undefined;
+                const buf_name = display_name.cstring(&buf, .utf8) orelse
+                    "<not enough internal storage space>";
+
+                log.info(
+                    "CoreText font required too much space to copy, value = {s}",
+                    .{buf_name},
+                );
+                break :unsupported "<CoreText internal storage limited, see logs>";
+            };
         },
 
         .web_canvas => if (self.wc) |wc| return wc.font_str,

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index a91589b5..a8a3ec34 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -353,7 +353,7 @@ pub const Wasm = struct {
             .wc = .{
                 .alloc = alloc,
                 .font_str = font_str,
-                .presentation = @intToEnum(font.Presentation, presentation),
+                .presentation = @enumFromInt(font.Presentation, presentation),
             },
         };
         errdefer face.deinit();

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index a8a3ec34..7625876e 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -353,7 +353,7 @@ pub const Wasm = struct {
             .wc = .{
                 .alloc = alloc,
                 .font_str = font_str,
-                .presentation = @enumFromInt(font.Presentation, presentation),
+                .presentation = @enumFromInt(presentation),
             },
         };
         errdefer face.deinit();

commit 4bf8a0d1491ad1b31843e610b11dd908de0426dc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 15:48:42 2023 -0700

    font: support skew transform for auto-italics

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 7625876e..31957377 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -19,6 +19,17 @@ const Presentation = @import("main.zig").Presentation;
 
 const log = std.log.scoped(.deferred_face);
 
+/// The struct used for deferred face state.
+///
+/// TODO: Change the "fc", "ct", "wc" fields in @This to just use one field
+/// with the state since there should be no world in which multiple are used.
+const FaceState = switch (options.backend) {
+    .freetype => void,
+    .fontconfig_freetype => Fontconfig,
+    .coretext_freetype, .coretext => CoreText,
+    .web_canvas => WebCanvas,
+};
+
 /// The loaded face (once loaded).
 face: ?Face = null,
 
@@ -61,6 +72,22 @@ pub const CoreText = struct {
         self.font.release();
         self.* = undefined;
     }
+
+    /// Auto-italicize the font by applying a skew.
+    pub fn italicize(self: *const CoreText) !CoreText {
+        const skew = macos.graphics.AffineTransform{
+            .a = 1,
+            .b = 0,
+            .c = 0.267949, // approx. tan(15)
+            .d = 1,
+            .tx = 0,
+            .ty = 0,
+        };
+
+        const ct_font = try self.font.copyWithAttributes(0.0, &skew, null);
+        errdefer ct_font.release();
+        return .{ .font = ct_font };
+    }
 };
 
 /// WebCanvas specific data. This is only present when building with canvas.
@@ -333,6 +360,40 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     unreachable;
 }
 
+/// Returns true if our deferred font implementation supports auto-itacilization.
+pub fn canItalicize() bool {
+    return @hasDecl(FaceState, "italicize") and @hasDecl(Face, "italicize");
+}
+
+/// Returns a new deferred face with the italicized version of this face
+/// by applying a skew. This is NOT TRUE italics. You should use the discovery
+/// mechanism to try to find an italic font. This is a fallback for when
+/// that fails.
+pub fn italicize(self: *const DeferredFace) !?DeferredFace {
+    if (comptime !canItalicize()) return null;
+
+    var result: DeferredFace = .{};
+
+    if (self.face) |face| {
+        result.face = try face.italicize();
+    }
+
+    switch (options.backend) {
+        .freetype => {},
+        .fontconfig_freetype => if (self.fc) |*fc| {
+            result.fc = try fc.italicize();
+        },
+        .coretext, .coretext_freetype => if (self.ct) |*ct| {
+            result.ct = try ct.italicize();
+        },
+        .web_canvas => if (self.wc) |*wc| {
+            result.wc = try wc.italicize();
+        },
+    }
+
+    return result;
+}
+
 /// The wasm-compatible API.
 pub const Wasm = struct {
     const wasm = @import("../os/wasm.zig");

commit 8113ad13930ac19fcb5a62490d37877aff910478
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 15:58:52 2023 -0700

    font: share skew matrix for core text

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 31957377..f5f43c48 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -75,16 +75,7 @@ pub const CoreText = struct {
 
     /// Auto-italicize the font by applying a skew.
     pub fn italicize(self: *const CoreText) !CoreText {
-        const skew = macos.graphics.AffineTransform{
-            .a = 1,
-            .b = 0,
-            .c = 0.267949, // approx. tan(15)
-            .d = 1,
-            .tx = 0,
-            .ty = 0,
-        };
-
-        const ct_font = try self.font.copyWithAttributes(0.0, &skew, null);
+        const ct_font = try self.font.copyWithAttributes(0.0, &Face.italic_skew, null);
         errdefer ct_font.release();
         return .{ .font = ct_font };
     }

commit ad6c2b6cc8eaefad06fb5edfce741de8bf110fe0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 13:16:42 2023 -0700

    font: move auto-italicization to Group

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index f5f43c48..4ebfe5ad 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -72,13 +72,6 @@ pub const CoreText = struct {
         self.font.release();
         self.* = undefined;
     }
-
-    /// Auto-italicize the font by applying a skew.
-    pub fn italicize(self: *const CoreText) !CoreText {
-        const ct_font = try self.font.copyWithAttributes(0.0, &Face.italic_skew, null);
-        errdefer ct_font.release();
-        return .{ .font = ct_font };
-    }
 };
 
 /// WebCanvas specific data. This is only present when building with canvas.
@@ -351,40 +344,6 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
     unreachable;
 }
 
-/// Returns true if our deferred font implementation supports auto-itacilization.
-pub fn canItalicize() bool {
-    return @hasDecl(FaceState, "italicize") and @hasDecl(Face, "italicize");
-}
-
-/// Returns a new deferred face with the italicized version of this face
-/// by applying a skew. This is NOT TRUE italics. You should use the discovery
-/// mechanism to try to find an italic font. This is a fallback for when
-/// that fails.
-pub fn italicize(self: *const DeferredFace) !?DeferredFace {
-    if (comptime !canItalicize()) return null;
-
-    var result: DeferredFace = .{};
-
-    if (self.face) |face| {
-        result.face = try face.italicize();
-    }
-
-    switch (options.backend) {
-        .freetype => {},
-        .fontconfig_freetype => if (self.fc) |*fc| {
-            result.fc = try fc.italicize();
-        },
-        .coretext, .coretext_freetype => if (self.ct) |*ct| {
-            result.ct = try ct.italicize();
-        },
-        .web_canvas => if (self.wc) |*wc| {
-            result.wc = try wc.italicize();
-        },
-    }
-
-    return result;
-}
-
 /// The wasm-compatible API.
 pub const Wasm = struct {
     const wasm = @import("../os/wasm.zig");

commit 167bf6f0980c312fdff0d4eedb6ad3ecdfa39d26
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 13:28:46 2023 -0700

    font: DeferredFace can no longer represent a loaded face

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 4ebfe5ad..27e0c040 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -30,9 +30,6 @@ const FaceState = switch (options.backend) {
     .web_canvas => WebCanvas,
 };
 
-/// The loaded face (once loaded).
-face: ?Face = null,
-
 /// Fontconfig
 fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
     if (options.backend == .fontconfig_freetype) null else {},
@@ -91,14 +88,7 @@ pub const WebCanvas = struct {
     }
 };
 
-/// Initialize a deferred face that is already pre-loaded. The deferred face
-/// takes ownership over the loaded face, deinit will deinit the loaded face.
-pub fn initLoaded(face: Face) DeferredFace {
-    return .{ .face = face };
-}
-
 pub fn deinit(self: *DeferredFace) void {
-    if (self.face) |*face| face.deinit();
     switch (options.backend) {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
         .coretext, .coretext_freetype => if (self.ct) |*ct| ct.deinit(),
@@ -108,11 +98,6 @@ pub fn deinit(self: *DeferredFace) void {
     self.* = undefined;
 }
 
-/// Returns true if the face has been loaded.
-pub inline fn loaded(self: DeferredFace) bool {
-    return self.face != null;
-}
-
 /// Returns the name of this face. The memory is always owned by the
 /// face so it doesn't have to be freed.
 pub fn name(self: DeferredFace) ![:0]const u8 {
@@ -152,69 +137,48 @@ pub fn load(
     self: *DeferredFace,
     lib: Library,
     size: font.face.DesiredSize,
-) !void {
-    // No-op if we already loaded
-    if (self.face != null) return;
-
-    switch (options.backend) {
-        .fontconfig_freetype => {
-            try self.loadFontconfig(lib, size);
-            return;
-        },
-
-        .coretext => {
-            try self.loadCoreText(lib, size);
-            return;
-        },
-
-        .coretext_freetype => {
-            try self.loadCoreTextFreetype(lib, size);
-            return;
-        },
-
-        .web_canvas => {
-            try self.loadWebCanvas(size);
-            return;
-        },
+) !Face {
+    return switch (options.backend) {
+        .fontconfig_freetype => try self.loadFontconfig(lib, size),
+        .coretext => try self.loadCoreText(lib, size),
+        .coretext_freetype => try self.loadCoreTextFreetype(lib, size),
+        .web_canvas => try self.loadWebCanvas(size),
 
         // Unreachable because we must be already loaded or have the
         // proper configuration for one of the other deferred mechanisms.
         .freetype => unreachable,
-    }
+    };
 }
 
 fn loadFontconfig(
     self: *DeferredFace,
     lib: Library,
     size: font.face.DesiredSize,
-) !void {
-    assert(self.face == null);
+) !Face {
     const fc = self.fc.?;
 
     // Filename and index for our face so we can load it
     const filename = (try fc.pattern.get(.file, 0)).string;
     const face_index = (try fc.pattern.get(.index, 0)).integer;
 
-    self.face = try Face.initFile(lib, filename, face_index, size);
+    return try Face.initFile(lib, filename, face_index, size);
 }
 
 fn loadCoreText(
     self: *DeferredFace,
     lib: Library,
     size: font.face.DesiredSize,
-) !void {
+) !Face {
     _ = lib;
-    assert(self.face == null);
     const ct = self.ct.?;
-    self.face = try Face.initFontCopy(ct.font, size);
+    return try Face.initFontCopy(ct.font, size);
 }
 
 fn loadCoreTextFreetype(
     self: *DeferredFace,
     lib: Library,
     size: font.face.DesiredSize,
-) !void {
-    assert(self.face == null);
+) !Face {
     const ct = self.ct.?;
 
     // Get the URL for the font so we can get the filepath
@@ -246,16 +210,15 @@ fn loadCoreTextFreetype(
     // TODO: face index 0 is not correct long term and we should switch
     // to using CoreText for rendering, too.
     //std.log.warn("path={s}", .{path_slice});
-    self.face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
+    return try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
 }
 
 fn loadWebCanvas(
     self: *DeferredFace,
     size: font.face.DesiredSize,
-) !void {
-    assert(self.face == null);
+) !Face {
     const wc = self.wc.?;
-    self.face = try Face.initNamed(wc.alloc, wc.font_str, size, wc.presentation);
+    return try Face.initNamed(wc.alloc, wc.font_str, size, wc.presentation);
 }
 
 /// Returns true if this face can satisfy the given codepoint and
@@ -266,12 +229,6 @@ fn loadWebCanvas(
 /// discovery mechanism (i.e. fontconfig). If no discovery is used,
 /// the face is always expected to be loaded.
 pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
-    // If we have the face, use the face.
-    if (self.face) |face| {
-        if (p) |desired| if (face.presentation != desired) return false;
-        return face.glyphIndex(cp) != null;
-    }
-
     switch (options.backend) {
         .fontconfig_freetype => {
             // If we are using fontconfig, use the fontconfig metadata to
@@ -388,30 +345,8 @@ pub const Wasm = struct {
             return;
         };
     }
-
-    /// Caller should not free this, the face is owned by the deferred face.
-    export fn deferred_face_face(self: *DeferredFace) ?*Face {
-        assert(self.loaded());
-        return &self.face.?;
-    }
 };
 
-test "preloaded" {
-    const testing = std.testing;
-    const testFont = @import("test.zig").fontRegular;
-
-    var lib = try Library.init();
-    defer lib.deinit();
-
-    var face = try Face.init(lib, testFont, .{ .points = 12 });
-    errdefer face.deinit();
-
-    var def = initLoaded(face);
-    defer def.deinit();
-
-    try testing.expect(def.hasCodepoint(' ', null));
-}
-
 test "fontconfig" {
     if (options.backend != .fontconfig_freetype) return error.SkipZigTest;
 
@@ -430,7 +365,6 @@ test "fontconfig" {
         break :def (try it.next()).?;
     };
     defer def.deinit();
-    try testing.expect(!def.loaded());
 
     // Verify we can get the name
     const n = try def.name();
@@ -460,7 +394,6 @@ test "coretext" {
         break :def (try it.next()).?;
     };
     defer def.deinit();
-    try testing.expect(!def.loaded());
     try testing.expect(def.hasCodepoint(' ', null));
 
     // Verify we can get the name
@@ -468,7 +401,6 @@ test "coretext" {
     try testing.expect(n.len > 0);
 
     // Load it and verify it works
-    try def.load(lib, .{ .points = 12 });
-    try testing.expect(def.hasCodepoint(' ', null));
-    try testing.expect(def.face.?.glyphIndex(' ') != null);
+    const face = try def.load(lib, .{ .points = 12 });
+    try testing.expect(face.glyphIndex(' ') != null);
 }

commit b51ef704f49e260802c0597a8927bb5780f4d886
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 14:40:59 2023 -0700

    font: DeferredFace.name takes a buffer

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 27e0c040..60ac4145 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -100,7 +100,7 @@ pub fn deinit(self: *DeferredFace) void {
 
 /// Returns the name of this face. The memory is always owned by the
 /// face so it doesn't have to be freed.
-pub fn name(self: DeferredFace) ![:0]const u8 {
+pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {
     switch (options.backend) {
         .freetype => {},
 
@@ -114,22 +114,15 @@ pub fn name(self: DeferredFace) ![:0]const u8 {
                 // this to be returned efficiently." In this case, we need
                 // to allocate. But we can't return an allocated string because
                 // we don't have an allocator. Let's use the stack and log it.
-                var buf: [1024]u8 = undefined;
-                const buf_name = display_name.cstring(&buf, .utf8) orelse
-                    "<not enough internal storage space>";
-
-                log.info(
-                    "CoreText font required too much space to copy, value = {s}",
-                    .{buf_name},
-                );
-                break :unsupported "<CoreText internal storage limited, see logs>";
+                break :unsupported display_name.cstring(buf, .utf8) orelse
+                    return error.OutOfMemory;
             };
         },
 
         .web_canvas => if (self.wc) |wc| return wc.font_str,
     }
 
-    return "TODO: built-in font names";
+    return "";
 }
 
 /// Load the deferred font face. This does nothing if the face is loaded.
@@ -397,7 +390,8 @@ test "coretext" {
     try testing.expect(def.hasCodepoint(' ', null));
 
     // Verify we can get the name
-    const n = try def.name();
+    var buf: [1024]u8 = undefined;
+    const n = try def.name(&buf);
     try testing.expect(n.len > 0);
 
     // Load it and verify it works

commit c15cf6d9f138d94e5437ac23f2a2ae5f1248ec34
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 14:57:05 2023 -0700

    font: fontconfig adaptations to new api

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 60ac4145..6d0d6fe3 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -360,13 +360,13 @@ test "fontconfig" {
     defer def.deinit();
 
     // Verify we can get the name
-    const n = try def.name();
+    var buf: [1024]u8 = undefined;
+    const n = try def.name(&buf);
     try testing.expect(n.len > 0);
 
     // Load it and verify it works
-    try def.load(lib, .{ .points = 12 });
-    try testing.expect(def.hasCodepoint(' ', null));
-    try testing.expect(def.face.?.glyphIndex(' ') != null);
+    const face = try def.load(lib, .{ .points = 12 });
+    try testing.expect(face.glyphIndex(' ') != null);
 }
 
 test "coretext" {

commit 1ee5b7f91c7e8d715110fe928a74e2ad60b19fce
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 27 19:58:25 2023 -0700

    font: freetype supports font variation settings

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 6d0d6fe3..acf5ba93 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -54,6 +54,9 @@ pub const Fontconfig = struct {
     charset: *const fontconfig.CharSet,
     langset: *const fontconfig.LangSet,
 
+    /// Variations to apply to this font.
+    variations: []const font.face.Variation,
+
     pub fn deinit(self: *Fontconfig) void {
         self.pattern.destroy();
         self.* = undefined;
@@ -154,7 +157,10 @@ fn loadFontconfig(
     const filename = (try fc.pattern.get(.file, 0)).string;
     const face_index = (try fc.pattern.get(.index, 0)).integer;
 
-    return try Face.initFile(lib, filename, face_index, size);
+    var face = try Face.initFile(lib, filename, face_index, size);
+    errdefer face.deinit();
+    try face.setVariations(fc.variations);
+    return face;
 }
 
 fn loadCoreText(

commit a2236d1ceb6c3f6d4fbe8d0247b955321449300f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 13 14:23:07 2023 -0700

    font: fallback search must verify presentation

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index acf5ba93..63d303d2 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -254,6 +254,12 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
         .coretext, .coretext_freetype => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
+                if (p) |desired_p| {
+                    const traits = ct.font.getSymbolicTraits();
+                    const actual_p: Presentation = if (traits.color_glyphs) .emoji else .text;
+                    if (actual_p != desired_p) return false;
+                }
+
                 // Turn UTF-32 into UTF-16 for CT API
                 var unichars: [2]u16 = undefined;
                 const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);

commit 2fb14eee09fa4cd368fb05731acd6d661ba6f785
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 24 08:22:50 2023 -0700

    font: CoreText discovery searches monospace only by default

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 63d303d2..c7146128 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -101,6 +101,28 @@ pub fn deinit(self: *DeferredFace) void {
     self.* = undefined;
 }
 
+/// Returns the family name of the font.
+pub fn familyName(self: DeferredFace, buf: []u8) ![]const u8 {
+    switch (options.backend) {
+        .freetype => {},
+
+        .fontconfig_freetype => if (self.fc) |fc|
+            return (try fc.pattern.get(.family, 0)).string,
+
+        .coretext, .coretext_freetype => if (self.ct) |ct| {
+            const family_name = ct.font.copyAttribute(.family_name);
+            return family_name.cstringPtr(.utf8) orelse unsupported: {
+                break :unsupported family_name.cstring(buf, .utf8) orelse
+                    return error.OutOfMemory;
+            };
+        },
+
+        .web_canvas => if (self.wc) |wc| return wc.font_str,
+    }
+
+    return "";
+}
+
 /// Returns the name of this face. The memory is always owned by the
 /// face so it doesn't have to be freed.
 pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {

commit 1127330b3a10dfa3da82dff9358501b7d8ed8c11
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 3 09:17:41 2023 -0700

    font/coretext: score discovered fonts

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index c7146128..e513989e 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -408,6 +408,7 @@ test "coretext" {
 
     const discovery = @import("main.zig").discovery;
     const testing = std.testing;
+    const alloc = testing.allocator;
 
     // Load freetype
     var lib = try Library.init();
@@ -416,7 +417,7 @@ test "coretext" {
     // Get a deferred face from fontconfig
     var def = def: {
         var fc = discovery.CoreText.init();
-        var it = try fc.discover(.{ .family = "Monaco", .size = 12 });
+        var it = try fc.discover(alloc, .{ .family = "Monaco", .size = 12 });
         defer it.deinit();
         break :def (try it.next()).?;
     };

commit 15e6c07bd953b1bc863a9a2295a1af4cbeb87ccd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 3 09:18:40 2023 -0700

    font/fontconfig: adhere to correct function signature

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index e513989e..bddf012a 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -379,6 +379,7 @@ test "fontconfig" {
 
     const discovery = @import("main.zig").discovery;
     const testing = std.testing;
+    const alloc = testing.allocator;
 
     // Load freetype
     var lib = try Library.init();
@@ -387,7 +388,7 @@ test "fontconfig" {
     // Get a deferred face from fontconfig
     var def = def: {
         var fc = discovery.Fontconfig.init();
-        var it = try fc.discover(.{ .family = "monospace", .size = 12 });
+        var it = try fc.discover(alloc, .{ .family = "monospace", .size = 12 });
         defer it.deinit();
         break :def (try it.next()).?;
     };

commit 54b9b45a7fa61a47c6ae1480a95adb7d4755efc8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 17:23:57 2023 -0700

    font: rework font init to use a struct with modifiersets everywhere

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index bddf012a..24353700 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -192,7 +192,8 @@ fn loadCoreText(
 ) !Face {
     _ = lib;
     const ct = self.ct.?;
-    return try Face.initFontCopy(ct.font, size);
+    // TODO: make options
+    return try Face.initFontCopy(ct.font, .{ .size = size });
 }
 
 fn loadCoreTextFreetype(

commit 2563a195a15ec61fa50b797fd054f64c47b60515
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 21:42:03 2023 -0700

    font: wire up all the metric modifiers

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 24353700..6456f8d2 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -154,13 +154,13 @@ pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {
 pub fn load(
     self: *DeferredFace,
     lib: Library,
-    size: font.face.DesiredSize,
+    opts: font.face.Options,
 ) !Face {
     return switch (options.backend) {
-        .fontconfig_freetype => try self.loadFontconfig(lib, size),
-        .coretext => try self.loadCoreText(lib, size),
-        .coretext_freetype => try self.loadCoreTextFreetype(lib, size),
-        .web_canvas => try self.loadWebCanvas(size),
+        .fontconfig_freetype => try self.loadFontconfig(lib, opts),
+        .coretext => try self.loadCoreText(lib, opts),
+        .coretext_freetype => try self.loadCoreTextFreetype(lib, opts),
+        .web_canvas => try self.loadWebCanvas(opts),
 
         // Unreachable because we must be already loaded or have the
         // proper configuration for one of the other deferred mechanisms.
@@ -171,7 +171,7 @@ pub fn load(
 fn loadFontconfig(
     self: *DeferredFace,
     lib: Library,
-    size: font.face.DesiredSize,
+    opts: font.face.Options,
 ) !Face {
     const fc = self.fc.?;
 
@@ -179,7 +179,7 @@ fn loadFontconfig(
     const filename = (try fc.pattern.get(.file, 0)).string;
     const face_index = (try fc.pattern.get(.index, 0)).integer;
 
-    var face = try Face.initFile(lib, filename, face_index, size);
+    var face = try Face.initFile(lib, filename, face_index, opts);
     errdefer face.deinit();
     try face.setVariations(fc.variations);
     return face;
@@ -188,18 +188,17 @@ fn loadFontconfig(
 fn loadCoreText(
     self: *DeferredFace,
     lib: Library,
-    size: font.face.DesiredSize,
+    opts: font.face.Options,
 ) !Face {
     _ = lib;
     const ct = self.ct.?;
-    // TODO: make options
-    return try Face.initFontCopy(ct.font, .{ .size = size });
+    return try Face.initFontCopy(ct.font, opts);
 }
 
 fn loadCoreTextFreetype(
     self: *DeferredFace,
     lib: Library,
-    size: font.face.DesiredSize,
+    opts: font.face.Options,
 ) !Face {
     const ct = self.ct.?;
 
@@ -232,15 +231,15 @@ fn loadCoreTextFreetype(
     // TODO: face index 0 is not correct long term and we should switch
     // to using CoreText for rendering, too.
     //std.log.warn("path={s}", .{path_slice});
-    return try Face.initFile(lib, buf[0..path_slice.len :0], 0, size);
+    return try Face.initFile(lib, buf[0..path_slice.len :0], 0, opts);
 }
 
 fn loadWebCanvas(
     self: *DeferredFace,
-    size: font.face.DesiredSize,
+    opts: font.face.Options,
 ) !Face {
     const wc = self.wc.?;
-    return try Face.initNamed(wc.alloc, wc.font_str, size, wc.presentation);
+    return try Face.initNamed(wc.alloc, wc.font_str, opts, wc.presentation);
 }
 
 /// Returns true if this face can satisfy the given codepoint and

commit 16cfb142004625abdcd63bea0cce980e65224a10
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 21:48:51 2023 -0700

    font: modify font compiles for freetype

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 6456f8d2..70dfafe7 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -181,7 +181,7 @@ fn loadFontconfig(
 
     var face = try Face.initFile(lib, filename, face_index, opts);
     errdefer face.deinit();
-    try face.setVariations(fc.variations);
+    try face.setVariations(fc.variations, opts);
     return face;
 }
 
@@ -400,7 +400,7 @@ test "fontconfig" {
     try testing.expect(n.len > 0);
 
     // Load it and verify it works
-    const face = try def.load(lib, .{ .points = 12 });
+    const face = try def.load(lib, .{ .size = .{ .points = 12 } });
     try testing.expect(face.glyphIndex(' ') != null);
 }
 

commit 7a0b8a6781d7b0ce941b03a9b45b9b8f71f055e0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 5 08:08:04 2023 -0700

    font: fix failing macos tests

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 70dfafe7..9d97952f 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -431,6 +431,6 @@ test "coretext" {
     try testing.expect(n.len > 0);
 
     // Load it and verify it works
-    const face = try def.load(lib, .{ .points = 12 });
+    const face = try def.load(lib, .{ .size = .{ .points = 12 } });
     try testing.expect(face.glyphIndex(' ') != null);
 }

commit 44a48f62f1f3888d9f91f5592effdfeed9041f9a
Author: Krzysztof Wolicki <der.teufel.mail@gmail.com>
Date:   Fri Nov 17 15:40:59 2023 +0100

    change unmodified `var`s to `const`s in anticipation of zig changes

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 9d97952f..6ff7f392 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -341,7 +341,7 @@ pub const Wasm = struct {
     }
 
     fn deferred_face_new_(ptr: [*]const u8, len: usize, presentation: u16) !*DeferredFace {
-        var font_str = try alloc.dupeZ(u8, ptr[0..len]);
+        const font_str = try alloc.dupeZ(u8, ptr[0..len]);
         errdefer alloc.free(font_str);
 
         var face: DeferredFace = .{
@@ -353,7 +353,7 @@ pub const Wasm = struct {
         };
         errdefer face.deinit();
 
-        var result = try alloc.create(DeferredFace);
+        const result = try alloc.create(DeferredFace);
         errdefer alloc.destroy(result);
         result.* = face;
         return result;

commit 5546469c37dfb82e950ff205322caf6607f691e1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 30 09:48:44 2024 -0700

    font: remove unused struct

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 6ff7f392..e68988e9 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -19,17 +19,6 @@ const Presentation = @import("main.zig").Presentation;
 
 const log = std.log.scoped(.deferred_face);
 
-/// The struct used for deferred face state.
-///
-/// TODO: Change the "fc", "ct", "wc" fields in @This to just use one field
-/// with the state since there should be no world in which multiple are used.
-const FaceState = switch (options.backend) {
-    .freetype => void,
-    .fontconfig_freetype => Fontconfig,
-    .coretext_freetype, .coretext => CoreText,
-    .web_canvas => WebCanvas,
-};
-
 /// Fontconfig
 fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
     if (options.backend == .fontconfig_freetype) null else {},

commit 107235474787498468b709f0a239b07bcc3d899e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 30 14:03:38 2024 -0700

    build: add -Dfont-backend=coretext_harfbuzz to force Harfbuzz w/ CT

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index e68988e9..8a576751 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -83,7 +83,7 @@ pub const WebCanvas = struct {
 pub fn deinit(self: *DeferredFace) void {
     switch (options.backend) {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
-        .coretext, .coretext_freetype => if (self.ct) |*ct| ct.deinit(),
+        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |*ct| ct.deinit(),
         .freetype => {},
         .web_canvas => if (self.wc) |*wc| wc.deinit(),
     }
@@ -98,7 +98,7 @@ pub fn familyName(self: DeferredFace, buf: []u8) ![]const u8 {
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.family, 0)).string,
 
-        .coretext, .coretext_freetype => if (self.ct) |ct| {
+        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |ct| {
             const family_name = ct.font.copyAttribute(.family_name);
             return family_name.cstringPtr(.utf8) orelse unsupported: {
                 break :unsupported family_name.cstring(buf, .utf8) orelse
@@ -121,7 +121,7 @@ pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.fullname, 0)).string,
 
-        .coretext, .coretext_freetype => if (self.ct) |ct| {
+        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |ct| {
             const display_name = ct.font.copyDisplayName();
             return display_name.cstringPtr(.utf8) orelse unsupported: {
                 // "NULL if the internal storage of theString does not allow
@@ -147,7 +147,7 @@ pub fn load(
 ) !Face {
     return switch (options.backend) {
         .fontconfig_freetype => try self.loadFontconfig(lib, opts),
-        .coretext => try self.loadCoreText(lib, opts),
+        .coretext, .coretext_harfbuzz => try self.loadCoreText(lib, opts),
         .coretext_freetype => try self.loadCoreTextFreetype(lib, opts),
         .web_canvas => try self.loadWebCanvas(opts),
 
@@ -262,7 +262,7 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
             }
         },
 
-        .coretext, .coretext_freetype => {
+        .coretext, .coretext_freetype, .coretext_harfbuzz => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
                 if (p) |desired_p| {

commit 851b1fe2ac0cfd1e183c2caf7bd7605a2da8652e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 1 10:24:41 2024 -0700

    font: noop shaper

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 8a576751..de4293ba 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -83,9 +83,13 @@ pub const WebCanvas = struct {
 pub fn deinit(self: *DeferredFace) void {
     switch (options.backend) {
         .fontconfig_freetype => if (self.fc) |*fc| fc.deinit(),
-        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |*ct| ct.deinit(),
         .freetype => {},
         .web_canvas => if (self.wc) |*wc| wc.deinit(),
+        .coretext,
+        .coretext_freetype,
+        .coretext_harfbuzz,
+        .coretext_noshape,
+        => if (self.ct) |*ct| ct.deinit(),
     }
     self.* = undefined;
 }
@@ -98,7 +102,11 @@ pub fn familyName(self: DeferredFace, buf: []u8) ![]const u8 {
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.family, 0)).string,
 
-        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |ct| {
+        .coretext,
+        .coretext_freetype,
+        .coretext_harfbuzz,
+        .coretext_noshape,
+        => if (self.ct) |ct| {
             const family_name = ct.font.copyAttribute(.family_name);
             return family_name.cstringPtr(.utf8) orelse unsupported: {
                 break :unsupported family_name.cstring(buf, .utf8) orelse
@@ -121,7 +129,11 @@ pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {
         .fontconfig_freetype => if (self.fc) |fc|
             return (try fc.pattern.get(.fullname, 0)).string,
 
-        .coretext, .coretext_freetype, .coretext_harfbuzz => if (self.ct) |ct| {
+        .coretext,
+        .coretext_freetype,
+        .coretext_harfbuzz,
+        .coretext_noshape,
+        => if (self.ct) |ct| {
             const display_name = ct.font.copyDisplayName();
             return display_name.cstringPtr(.utf8) orelse unsupported: {
                 // "NULL if the internal storage of theString does not allow
@@ -147,7 +159,7 @@ pub fn load(
 ) !Face {
     return switch (options.backend) {
         .fontconfig_freetype => try self.loadFontconfig(lib, opts),
-        .coretext, .coretext_harfbuzz => try self.loadCoreText(lib, opts),
+        .coretext, .coretext_harfbuzz, .coretext_noshape => try self.loadCoreText(lib, opts),
         .coretext_freetype => try self.loadCoreTextFreetype(lib, opts),
         .web_canvas => try self.loadWebCanvas(opts),
 
@@ -262,7 +274,11 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
             }
         },
 
-        .coretext, .coretext_freetype, .coretext_harfbuzz => {
+        .coretext,
+        .coretext_freetype,
+        .coretext_harfbuzz,
+        .coretext_noshape,
+        => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
                 if (p) |desired_p| {

commit fa45c18a6aeea18132a6b8d5943ccf6df046bea1
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed May 8 15:00:28 2024 -0400

    fix point size type

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index de4293ba..8051895a 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -371,7 +371,7 @@ pub const Wasm = struct {
         }
     }
 
-    export fn deferred_face_load(self: *DeferredFace, pts: u16) void {
+    export fn deferred_face_load(self: *DeferredFace, pts: f32) void {
         self.load(.{}, .{ .points = pts }) catch |err| {
             log.warn("error loading deferred face err={}", .{err});
             return;

commit 326659c522536e9215afbc64feb9e6015d5e7fa8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:09:05 2024 -0700

    font: handle presentation at glyph layer

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 8051895a..94fbab44 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -281,6 +281,7 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
         => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
+                // TODO(mixed-fonts): handle presentation on a glyph level
                 if (p) |desired_p| {
                     const traits = ct.font.getSymbolicTraits();
                     const actual_p: Presentation = if (traits.color_glyphs) .emoji else .text;

commit 6a8dc12ae146cf2d6890d7378bf60c6191a21e10
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:54:05 2024 -0700

    font: remove deferred face todo, note why

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 94fbab44..fc7c8137 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -281,7 +281,12 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
         => {
             // If we are using coretext, we check the loaded CT font.
             if (self.ct) |ct| {
-                // TODO(mixed-fonts): handle presentation on a glyph level
+                // This presentation check isn't as detailed as isColorGlyph
+                // because forced presentation modes are only used for emoji and
+                // emoji should always have color glyphs set. This can be
+                // more correct by using the isColorGlyph logic but I'd want
+                // to find a font that actualy requires this so we can write
+                // a test for it before changing it.
                 if (p) |desired_p| {
                     const traits = ct.font.getSymbolicTraits();
                     const actual_p: Presentation = if (traits.color_glyphs) .emoji else .text;

commit f9be02a20f9f77649efad3f6fda3dd15639ef252
Author: ukasz Niemier <lukasz@niemier.pl>
Date:   Mon Aug 5 13:56:57 2024 +0200

    chore: clean up typos

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index fc7c8137..84b5700f 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -285,7 +285,7 @@ pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
                 // because forced presentation modes are only used for emoji and
                 // emoji should always have color glyphs set. This can be
                 // more correct by using the isColorGlyph logic but I'd want
-                // to find a font that actualy requires this so we can write
+                // to find a font that actually requires this so we can write
                 // a test for it before changing it.
                 if (p) |desired_p| {
                     const traits = ct.font.getSymbolicTraits();

commit def4abf6a9efd51ca0857e185b329b67518e1cc0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 24 20:33:58 2024 -0700

    font: support variations for coretext_freetype backend

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index 84b5700f..db9e2362 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -107,7 +107,8 @@ pub fn familyName(self: DeferredFace, buf: []u8) ![]const u8 {
         .coretext_harfbuzz,
         .coretext_noshape,
         => if (self.ct) |ct| {
-            const family_name = ct.font.copyAttribute(.family_name);
+            const family_name = ct.font.copyAttribute(.family_name) orelse
+                return "unknown";
             return family_name.cstringPtr(.utf8) orelse unsupported: {
                 break :unsupported family_name.cstring(buf, .utf8) orelse
                     return error.OutOfMemory;
@@ -204,7 +205,8 @@ fn loadCoreTextFreetype(
     const ct = self.ct.?;
 
     // Get the URL for the font so we can get the filepath
-    const url = ct.font.copyAttribute(.url);
+    const url = ct.font.copyAttribute(.url) orelse
+        return error.FontHasNoFile;
     defer url.release();
 
     // Get the path from the URL
@@ -229,10 +231,50 @@ fn loadCoreTextFreetype(
     // the end for a zero so we set that up here.
     buf[path_slice.len] = 0;
 
-    // TODO: face index 0 is not correct long term and we should switch
-    // to using CoreText for rendering, too.
+    // Face index 0 is not always correct. We don't ship this configuration
+    // in a release build. Users should use the pure CoreText builds.
     //std.log.warn("path={s}", .{path_slice});
-    return try Face.initFile(lib, buf[0..path_slice.len :0], 0, opts);
+    var face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, opts);
+    errdefer face.deinit();
+
+    // If our ct font has variations, apply them to the face.
+    if (ct.font.copyAttribute(.variation)) |variations| vars: {
+        defer variations.release();
+        if (variations.getCount() == 0) break :vars;
+
+        // This configuration is just used for testing so we don't want to
+        // have to pass a full allocator through so use the stack. We
+        // shouldn't have a lot of variations and if we do we should use
+        // another mechanism.
+        //
+        // On macOS the default stack size for a thread is 512KB and the main
+        // thread gets megabytes so 16KB is a safe stack allocation.
+        var data: [1024 * 16]u8 = undefined;
+        var fba = std.heap.FixedBufferAllocator.init(&data);
+        const alloc = fba.allocator();
+
+        var face_vars = std.ArrayList(font.face.Variation).init(alloc);
+        const kav = try variations.getKeysAndValues(alloc);
+        for (kav.keys, kav.values) |key, value| {
+            const num: *const macos.foundation.Number = @ptrCast(key.?);
+            const val: *const macos.foundation.Number = @ptrCast(value.?);
+
+            var num_i32: i32 = undefined;
+            if (!num.getValue(.sint32, &num_i32)) continue;
+
+            var val_f64: f64 = undefined;
+            if (!val.getValue(.float64, &val_f64)) continue;
+
+            try face_vars.append(.{
+                .id = @bitCast(num_i32),
+                .value = val_f64,
+            });
+        }
+
+        try face.setVariations(face_vars.items, opts);
+    }
+
+    return face;
 }
 
 fn loadWebCanvas(

commit e08eeb2b2ad810c4db22530a181858caee834b22
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 5 16:13:53 2024 -0800

    coretext: set variations on deferred face load
    
    This commit makes CoreText behave a lot like FreeType where we set the
    variation axes on the deferred face load. This fixes a bug where the
    `slnt` variation axis could not be set with CoreText with the Monaspace
    Argon Variable font.
    
    This was a bug found in Discord. Specifically, with the Monaspace Argon
    Variable font, the `slnt` variation axis could not be set with CoreText.
    I'm not sure _exactly_ what causes this but I suspect it has to do with
    the `slnt` axis being a negative value. I'm not sure if this is a bug
    with CoreText or not.
    
    What was happening was that with CoreText, we set the variation axes
    during discovery and expect them to be preserved in the resulting
    discovered faces. That seems to be true with the `wght` axis but not the
    `slnt` axis for whatever reason.

diff --git a/src/font/DeferredFace.zig b/src/font/DeferredFace.zig
index db9e2362..3ee10438 100644
--- a/src/font/DeferredFace.zig
+++ b/src/font/DeferredFace.zig
@@ -57,6 +57,11 @@ pub const CoreText = struct {
     /// The initialized font
     font: *macos.text.Font,
 
+    /// Variations to apply to this font. We apply the variations to the
+    /// search descriptor but sometimes when the font collection is
+    /// made the variation axes are reset so we have to reapply them.
+    variations: []const font.face.Variation,
+
     pub fn deinit(self: *CoreText) void {
         self.font.release();
         self.* = undefined;
@@ -194,7 +199,10 @@ fn loadCoreText(
 ) !Face {
     _ = lib;
     const ct = self.ct.?;
-    return try Face.initFontCopy(ct.font, opts);
+    var face = try Face.initFontCopy(ct.font, opts);
+    errdefer face.deinit();
+    try face.setVariations(ct.variations, opts);
+    return face;
 }
 
 fn loadCoreTextFreetype(
@@ -236,43 +244,7 @@ fn loadCoreTextFreetype(
     //std.log.warn("path={s}", .{path_slice});
     var face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, opts);
     errdefer face.deinit();
-
-    // If our ct font has variations, apply them to the face.
-    if (ct.font.copyAttribute(.variation)) |variations| vars: {
-        defer variations.release();
-        if (variations.getCount() == 0) break :vars;
-
-        // This configuration is just used for testing so we don't want to
-        // have to pass a full allocator through so use the stack. We
-        // shouldn't have a lot of variations and if we do we should use
-        // another mechanism.
-        //
-        // On macOS the default stack size for a thread is 512KB and the main
-        // thread gets megabytes so 16KB is a safe stack allocation.
-        var data: [1024 * 16]u8 = undefined;
-        var fba = std.heap.FixedBufferAllocator.init(&data);
-        const alloc = fba.allocator();
-
-        var face_vars = std.ArrayList(font.face.Variation).init(alloc);
-        const kav = try variations.getKeysAndValues(alloc);
-        for (kav.keys, kav.values) |key, value| {
-            const num: *const macos.foundation.Number = @ptrCast(key.?);
-            const val: *const macos.foundation.Number = @ptrCast(value.?);
-
-            var num_i32: i32 = undefined;
-            if (!num.getValue(.sint32, &num_i32)) continue;
-
-            var val_f64: f64 = undefined;
-            if (!val.getValue(.float64, &val_f64)) continue;
-
-            try face_vars.append(.{
-                .id = @bitCast(num_i32),
-                .value = val_f64,
-            });
-        }
-
-        try face.setVariations(face_vars.items, opts);
-    }
+    try face.setVariations(ct.variations, opts);
 
     return face;
 }

