# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/index/hnsw_index/graph_links.rs

commit a465679fb8235659492a22685e98bce6e95622b1
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Nov 8 13:42:50 2022 +0400

    Hnsw links storage (#1171)
    
    * hnsw compact links storage
    
    * dump links memsize
    
    * are you happy fmt
    
    * fix build
    
    * calculate capacity and add shrink
    
    * fmt
    
    * remove garbage
    
    * fix unit tests
    
    * default values for graph layers
    
    * remove obsolete fields
    
    * add comments
    
    * more comments
    
    * use one flattened links structure
    
    * refactor and add unit tests
    
    * move merge into graph builder
    
    * fix messages in test_hnsw_graph_properties

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
new file mode 100644
index 000000000..1292b6580
--- /dev/null
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -0,0 +1,269 @@
+use std::ops::Range;
+
+use serde::{Deserialize, Serialize};
+
+use crate::types::PointOffsetType;
+
+/*
+Links data for whole graph layers.
+
+                                    sorted
+                     points:        points:
+points to lvl        012345         142350
+     0 -> 0
+     1 -> 4    lvl4:  7       lvl4: 7
+     2 -> 2    lvl3:  Z  Y    lvl3: ZY
+     3 -> 2    lvl2:  abcd    lvl2: adbc
+     4 -> 3    lvl1:  ABCDE   lvl1: ADBCE
+     5 -> 1    lvl0: 123456   lvl0: 123456  <- lvl 0 is not sorted
+
+
+lvl offset:        6       11     15     17
+                   │       │      │      │
+                   │       │      │      │
+                   ▼       ▼      ▼      ▼
+indexes:  012345   6789A   BCDE   FG     H
+
+flatten:  123456   ADBCE   adbc   ZY     7
+                   ▲ ▲ ▲   ▲ ▲    ▲      ▲
+                   │ │ │   │ │    │      │
+                   │ │ │   │ │    │      │
+                   │ │ │   │ │    │      │
+reindex:           142350  142350 142350 142350  (same for each level)
+
+
+for lvl > 0:
+links offset = level_offsets[level] + offsets[reindex[point_id]]
+*/
+#[derive(Deserialize, Serialize, Debug, Default, Clone)]
+pub struct GraphLinks {
+    // all flattened links of all levels
+    links: Vec<PointOffsetType>,
+    // all ranges in `links`. each range is `links[offsets[i]..offsets[i+1]]`
+    // ranges are sorted by level
+    offsets: Vec<usize>,
+    // start offet of each level in `offsets`
+    level_offsets: Vec<usize>,
+    // for level 1 and above: reindex[point_id] = index of point_id in offsets
+    reindex: Vec<PointOffsetType>,
+}
+
+impl GraphLinks {
+    // Convert from graph layers builder links
+    // `Vec<Vec<Vec<_>>>` means:
+    // vector of points -> vector of layers for specific point -> vector of links for specific point and layer
+    pub fn from_vec(edges: &Vec<Vec<Vec<PointOffsetType>>>) -> Self {
+        if edges.is_empty() {
+            return Self::default();
+        }
+
+        // create map from index in `offsets` to point_id
+        let mut back_index: Vec<usize> = (0..edges.len()).collect();
+        // sort by max layer and use this map to build `Self.reindex`
+        back_index.sort_unstable_by_key(|&i| edges[i].len());
+        back_index.reverse();
+
+        // `reindex` is map from point id to index in `Self.offsets`
+        let mut reindex = vec![0; back_index.len()];
+        for i in 0..back_index.len() {
+            reindex[back_index[i]] = i as PointOffsetType;
+        }
+
+        let mut graph_links = GraphLinks {
+            links: Vec::new(),
+            offsets: vec![0],
+            level_offsets: Vec::new(),
+            reindex,
+        };
+
+        // because back_index is sorted by point`s max layer, we can retrieve max level from `point_id = back_index[0]`
+        let levels_count = edges[back_index[0]].len();
+
+        // fill level 0 links. level 0 is required
+        debug_assert!(levels_count > 0);
+        graph_links.fill_level_links(0, 0..edges.len(), edges);
+
+        // fill other levels links
+        for level in 1..levels_count {
+            let point_id_iter = back_index
+                .iter()
+                .cloned()
+                .take_while(|&point_id| level < edges[point_id].len());
+            graph_links.fill_level_links(level, point_id_iter, edges);
+        }
+
+        graph_links
+    }
+
+    // Convert into graph builder format
+    pub fn to_vec(&self) -> Vec<Vec<Vec<PointOffsetType>>> {
+        let mut result = Vec::new();
+        let num_points = self.num_points();
+        for i in 0..num_points {
+            let mut layers = Vec::new();
+            let num_levels = self.point_level(i as PointOffsetType) + 1;
+            for level in 0..num_levels {
+                let links = self.links(i as PointOffsetType, level).to_vec();
+                layers.push(links);
+            }
+            result.push(layers);
+        }
+        result
+    }
+
+    pub fn links(&self, point_id: PointOffsetType, level: usize) -> &[PointOffsetType] {
+        if level == 0 {
+            self.get_links_at_zero_level(point_id)
+        } else {
+            self.get_links_at_nonzero_level(point_id, level)
+        }
+    }
+
+    pub fn num_points(&self) -> usize {
+        self.reindex.len()
+    }
+
+    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
+        let reindexed_point_id = self.reindex[point_id as usize] as usize;
+        // level 0 is always present, start checking from level 1. Stop checking when level is incorrect
+        for level in 1.. {
+            if let Some(offsets_range) = self.get_level_offsets_range(level) {
+                if offsets_range.start + reindexed_point_id >= offsets_range.end {
+                    // incorrect level because point_id is out of range
+                    return level - 1;
+                }
+            } else {
+                // incorrect level because this level is larger that avaliable levels
+                return level - 1;
+            }
+        }
+        unreachable!()
+    }
+
+    fn get_links_at_zero_level(&self, point_id: PointOffsetType) -> &[PointOffsetType] {
+        let start = self.offsets[point_id as usize];
+        let end = self.offsets[point_id as usize + 1];
+        &self.links[start..end]
+    }
+
+    fn get_links_at_nonzero_level(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+    ) -> &[PointOffsetType] {
+        debug_assert!(level > 0);
+        let reindexed_point_id = self.reindex[point_id as usize] as usize;
+        let layer_offsets_start = self.level_offsets[level];
+        let start = self.offsets[layer_offsets_start + reindexed_point_id];
+        let end = self.offsets[layer_offsets_start + reindexed_point_id + 1];
+        &self.links[start..end]
+    }
+
+    fn get_level_offsets_range(&self, level: usize) -> Option<Range<usize>> {
+        if level < self.level_offsets.len() {
+            let layer_offsets_start = self.level_offsets[level];
+            let layer_offsets_end = if level + 1 < self.level_offsets.len() {
+                // `level` is not last, next level_offsets is end of range
+                self.level_offsets[level + 1]
+            } else {
+                // `level` is last, next `offsets.len()` is end of range
+                self.offsets.len() - 1
+            };
+            Some(layer_offsets_start..layer_offsets_end)
+        } else {
+            None
+        }
+    }
+
+    fn fill_level_links<I>(
+        &mut self,
+        level: usize,
+        level_points_iter: I,
+        edges: &[Vec<Vec<PointOffsetType>>],
+    ) where
+        I: Iterator<Item = usize>,
+    {
+        self.level_offsets.push(self.offsets.len() - 1);
+
+        for point_id in level_points_iter {
+            let links = &edges[point_id][level];
+            self.links.extend_from_slice(links);
+            self.offsets.push(self.links.len());
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use rand::Rng;
+
+    use super::*;
+    use crate::types::PointOffsetType;
+
+    #[test]
+    fn test_graph_links_construction() {
+        // no points
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // 2 points without any links
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![]], vec![vec![]]];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // one link at level 0
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![1]], vec![vec![0]]];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // 3 levels with no links at second level
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
+            vec![vec![1, 2]],
+            vec![vec![0, 2], vec![], vec![2]],
+            vec![vec![0, 1], vec![], vec![1]],
+        ];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // 3 levels with no links at last level
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
+            vec![vec![1, 2], vec![2], vec![]],
+            vec![vec![0, 2], vec![1], vec![]],
+            vec![vec![0, 1]],
+        ];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // 4 levels with random unexists links
+        let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
+            vec![vec![1, 2, 5, 6]],
+            vec![vec![0, 2, 7, 8], vec![], vec![34, 45, 10]],
+            vec![vec![0, 1, 1, 2], vec![3, 5, 9], vec![9, 8], vec![9], vec![]],
+            vec![vec![0, 1, 5, 6], vec![1, 5, 0]],
+            vec![vec![0, 1, 9, 18], vec![1, 5, 6], vec![5], vec![9]],
+        ];
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+
+        // fully random links
+        let mut rng = rand::thread_rng();
+        let points_count = 100;
+        let max_levels_count = 10;
+        let links: Vec<Vec<Vec<PointOffsetType>>> = (0..points_count)
+            .map(|_| {
+                let levels_count = rng.gen_range(1..max_levels_count);
+                (0..levels_count)
+                    .map(|_| {
+                        let links_count = rng.gen_range(0..max_levels_count);
+                        (0..links_count)
+                            .map(|_| rng.gen_range(0..points_count) as PointOffsetType)
+                            .collect()
+                    })
+                    .collect()
+            })
+            .collect();
+        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        assert_eq!(links, cmp_links);
+    }
+}

commit 5e3416e2cef6d0a6af14407a057f84b175c15f77
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Nov 25 14:47:52 2022 +0400

    Hnsw links memmap (#1211)
    
    * add on disk key
    
    * remove obsolete graph initialization
    
    * remove obsolete max level
    
    * update openapi
    
    * graph links trait
    
    * use mmap option
    
    * same format for ram and mmap
    
    * fix segment unit tests
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix ci and add mmap test
    
    * review fixes
    
    * remove unused try-from
    
    * fix version compatibility
    
    * avoid loading from disk during conversion
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 1292b6580..bae4184b7 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,9 +1,28 @@
+use std::cmp::max;
+use std::fs::OpenOptions;
+use std::mem::size_of;
 use std::ops::Range;
+use std::path::{Path, PathBuf};
 
-use serde::{Deserialize, Serialize};
+use memmap2::{Mmap, MmapMut};
 
+use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::types::PointOffsetType;
 
+pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
+
+fn transmute_from_u8<T>(data: &[u8]) -> &[T] {
+    let len = data.len() / size_of::<T>();
+    let ptr = data.as_ptr() as *const T;
+    unsafe { std::slice::from_raw_parts(ptr, len) }
+}
+
+fn transmute_from_u8_mut<T>(data: &mut [u8]) -> &mut [T] {
+    let len = data.len() / size_of::<T>();
+    let ptr = data.as_mut_ptr() as *mut T;
+    unsafe { std::slice::from_raw_parts_mut(ptr, len) }
+}
+
 /*
 Links data for whole graph layers.
 
@@ -35,26 +54,112 @@ reindex:           142350  142350 142350 142350  (same for each level)
 for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
-#[derive(Deserialize, Serialize, Debug, Default, Clone)]
-pub struct GraphLinks {
-    // all flattened links of all levels
-    links: Vec<PointOffsetType>,
-    // all ranges in `links`. each range is `links[offsets[i]..offsets[i+1]]`
-    // ranges are sorted by level
-    offsets: Vec<usize>,
-    // start offet of each level in `offsets`
-    level_offsets: Vec<usize>,
-    // for level 1 and above: reindex[point_id] = index of point_id in offsets
+
+#[derive(Default)]
+struct GraphLinksFileHeader {
+    pub point_count: u64,
+    pub levels_count: u64,
+    pub total_links_len: u64,
+    pub total_offsets_len: u64,
+}
+
+fn reindex_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
+    let reindex_range = header.get_reindex_range();
+    let reindex_byte_slice = &data[reindex_range];
+    transmute_from_u8(reindex_byte_slice)
+}
+
+fn links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
+    let links_range = header.get_links_range();
+    let links_byte_slice = &data[links_range];
+    transmute_from_u8(links_byte_slice)
+}
+
+fn offsets_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [u64] {
+    let offsets_range = header.get_offsets_range();
+    let offsets_byte_slice = &data[offsets_range];
+    transmute_from_u8(offsets_byte_slice)
+}
+
+fn level_offsets(data: &[u8], header: &GraphLinksFileHeader) -> Vec<u64> {
+    let level_offsets_range = header.get_level_offsets_range();
+    let level_offsets_byte_slice = &data[level_offsets_range];
+    let level_offsets: &[u64] = transmute_from_u8(level_offsets_byte_slice);
+    level_offsets.to_vec()
+}
+
+impl GraphLinksFileHeader {
+    pub fn raw_size() -> usize {
+        size_of::<u64>() * 4
+    }
+
+    pub fn serialize_bytes_to(&self, raw_data: &mut [u8]) {
+        let byte_slice = &mut raw_data[0..Self::raw_size()];
+        let arr: &mut [u64] = transmute_from_u8_mut(byte_slice);
+        arr[0] = self.point_count;
+        arr[1] = self.levels_count;
+        arr[2] = self.total_links_len;
+        arr[3] = self.total_offsets_len;
+    }
+
+    pub fn deserialize_bytes_from(raw_data: &[u8]) -> GraphLinksFileHeader {
+        let byte_slice = &raw_data[0..Self::raw_size()];
+        let arr: &[u64] = transmute_from_u8(byte_slice);
+        GraphLinksFileHeader {
+            point_count: arr[0],
+            levels_count: arr[1],
+            total_links_len: arr[2],
+            total_offsets_len: arr[3],
+        }
+    }
+
+    pub fn get_data_size(&self) -> u64 {
+        self.get_offsets_range().end as u64
+    }
+
+    pub fn get_level_offsets_range(&self) -> Range<usize> {
+        // level offsets are stored after header
+        // but we might want to have some extra space for future changes
+        let start = max(64, Self::raw_size());
+        start..start + self.levels_count as usize * size_of::<u64>()
+    }
+
+    pub fn get_reindex_range(&self) -> Range<usize> {
+        let start = self.get_level_offsets_range().end;
+        start..start + self.point_count as usize * size_of::<PointOffsetType>()
+    }
+
+    pub fn get_links_range(&self) -> Range<usize> {
+        let start = self.get_reindex_range().end;
+        start..start + self.total_links_len as usize * size_of::<PointOffsetType>()
+    }
+
+    pub fn get_offsets_range(&self) -> Range<usize> {
+        let start = self.get_links_range().end;
+        start..start + self.total_offsets_len as usize * size_of::<u64>()
+    }
+}
+
+pub struct GraphLinksConverter {
+    edges: Vec<Vec<Vec<PointOffsetType>>>,
     reindex: Vec<PointOffsetType>,
+    back_index: Vec<usize>,
+    total_links_len: usize,
+    total_offsets_len: usize,
+    path: Option<PathBuf>,
 }
 
-impl GraphLinks {
-    // Convert from graph layers builder links
-    // `Vec<Vec<Vec<_>>>` means:
-    // vector of points -> vector of layers for specific point -> vector of links for specific point and layer
-    pub fn from_vec(edges: &Vec<Vec<Vec<PointOffsetType>>>) -> Self {
+impl GraphLinksConverter {
+    pub fn new(edges: Vec<Vec<Vec<PointOffsetType>>>) -> Self {
         if edges.is_empty() {
-            return Self::default();
+            return Self {
+                edges,
+                reindex: Vec::new(),
+                back_index: Vec::new(),
+                total_links_len: 0,
+                total_offsets_len: 1,
+                path: None,
+            };
         }
 
         // create map from index in `offsets` to point_id
@@ -69,62 +174,184 @@ impl GraphLinks {
             reindex[back_index[i]] = i as PointOffsetType;
         }
 
-        let mut graph_links = GraphLinks {
-            links: Vec::new(),
-            offsets: vec![0],
-            level_offsets: Vec::new(),
+        // estimate size of `links` and `offsets`
+        let mut total_links_len = 0;
+        let mut total_offsets_len = 1;
+        for point in edges.iter() {
+            for layer in point.iter() {
+                total_links_len += layer.len();
+                total_offsets_len += 1;
+            }
+        }
+
+        Self {
+            edges,
             reindex,
-        };
+            back_index,
+            total_links_len,
+            total_offsets_len,
+            path: None,
+        }
+    }
 
-        // because back_index is sorted by point`s max layer, we can retrieve max level from `point_id = back_index[0]`
-        let levels_count = edges[back_index[0]].len();
-
-        // fill level 0 links. level 0 is required
-        debug_assert!(levels_count > 0);
-        graph_links.fill_level_links(0, 0..edges.len(), edges);
-
-        // fill other levels links
-        for level in 1..levels_count {
-            let point_id_iter = back_index
-                .iter()
-                .cloned()
-                .take_while(|&point_id| level < edges[point_id].len());
-            graph_links.fill_level_links(level, point_id_iter, edges);
+    pub fn set_path(&mut self, path: PathBuf) {
+        self.path = Some(path);
+    }
+
+    fn get_header(&self) -> GraphLinksFileHeader {
+        GraphLinksFileHeader {
+            point_count: self.reindex.len() as u64,
+            levels_count: self.get_levels_count() as u64,
+            total_links_len: self.total_links_len as u64,
+            total_offsets_len: self.total_offsets_len as u64,
         }
+    }
 
-        graph_links
+    /// Size of compacted graph in bytes.
+    pub fn data_size(&self) -> u64 {
+        self.get_header().get_data_size()
     }
 
-    // Convert into graph builder format
-    pub fn to_vec(&self) -> Vec<Vec<Vec<PointOffsetType>>> {
-        let mut result = Vec::new();
-        let num_points = self.num_points();
-        for i in 0..num_points {
-            let mut layers = Vec::new();
-            let num_levels = self.point_level(i as PointOffsetType) + 1;
-            for level in 0..num_levels {
-                let links = self.links(i as PointOffsetType, level).to_vec();
-                layers.push(links);
+    pub fn serialize_to(&self, bytes_data: &mut [u8]) {
+        let header = GraphLinksFileHeader {
+            point_count: self.reindex.len() as u64,
+            levels_count: self.get_levels_count() as u64,
+            total_links_len: self.total_links_len as u64,
+            total_offsets_len: self.total_offsets_len as u64,
+        };
+
+        header.serialize_bytes_to(bytes_data);
+
+        {
+            let reindex_range = header.get_reindex_range();
+            let reindex_byte_slice = &mut bytes_data[reindex_range];
+            let reindex_slice: &mut [PointOffsetType] = transmute_from_u8_mut(reindex_byte_slice);
+            reindex_slice.copy_from_slice(&self.reindex);
+        }
+
+        let mut level_offsets = Vec::new();
+        {
+            let links_range = header.get_links_range();
+            let offsets_range = header.get_offsets_range();
+            let union_range = links_range.start..offsets_range.end;
+            let (links_mmap, offsets_mmap) = bytes_data[union_range]
+                .as_mut()
+                .split_at_mut(links_range.len());
+            let links_mmap: &mut [PointOffsetType] = transmute_from_u8_mut(links_mmap);
+            let offsets_mmap: &mut [u64] = transmute_from_u8_mut(offsets_mmap);
+            offsets_mmap[0] = 0;
+
+            let mut links_pos = 0;
+            let mut offsets_pos = 1;
+            for level in 0..header.levels_count as usize {
+                level_offsets.push(offsets_pos as u64 - 1);
+                self.iterate_level_points(level, |_, links| {
+                    links_mmap[links_pos..links_pos + links.len()].copy_from_slice(links);
+                    links_pos += links.len();
+
+                    offsets_mmap[offsets_pos] = links_pos as u64;
+                    offsets_pos += 1;
+                });
             }
-            result.push(layers);
         }
-        result
+
+        {
+            let level_offsets_range = header.get_level_offsets_range();
+            let level_offsets_byte_slice = &mut bytes_data[level_offsets_range];
+            let level_offsets_slice: &mut [u64] = transmute_from_u8_mut(level_offsets_byte_slice);
+            level_offsets_slice.copy_from_slice(&level_offsets);
+        }
     }
 
-    pub fn links(&self, point_id: PointOffsetType, level: usize) -> &[PointOffsetType] {
+    pub fn to_bytes(&self) -> Vec<u8> {
+        let mut bytes = vec![0; self.data_size() as usize];
+        self.serialize_to(&mut bytes);
+        bytes
+    }
+
+    pub fn save_as(&mut self, path: &Path) -> OperationResult<()> {
+        self.path = Some(path.to_path_buf());
+        let tmp_path = path.with_extension("tmp");
+        {
+            let file = OpenOptions::new()
+                .read(true)
+                .write(true)
+                .create(true)
+                .open(tmp_path.as_path())?;
+
+            file.set_len(self.data_size())?;
+            let m = unsafe { MmapMut::map_mut(&file) };
+            let mut mmap = m?;
+
+            self.serialize_to(&mut mmap);
+
+            mmap.flush()?;
+        }
+        std::fs::rename(tmp_path, path)?;
+
+        Ok(())
+    }
+
+    pub fn get_levels_count(&self) -> usize {
+        if self.back_index.is_empty() {
+            return 0;
+        }
+        // because back_index is sorted by point`s max layer, we can retrieve max level from `point_id = back_index[0]`
+        self.edges[self.back_index[0]].len()
+    }
+
+    pub fn iterate_level_points<F>(&self, level: usize, mut f: F)
+    where
+        F: FnMut(usize, &Vec<PointOffsetType>),
+    {
+        let edges_len = self.edges.len();
         if level == 0 {
-            self.get_links_at_zero_level(point_id)
+            (0..edges_len).for_each(|point_id| f(point_id, &self.edges[point_id][0]));
         } else {
-            self.get_links_at_nonzero_level(point_id, level)
+            for i in 0..edges_len {
+                let point_id = self.back_index[i];
+                if level >= self.edges[point_id].len() {
+                    break;
+                }
+                f(point_id, &self.edges[point_id][level]);
+            }
         }
     }
+}
 
-    pub fn num_points(&self) -> usize {
-        self.reindex.len()
+pub trait GraphLinks: Default {
+    fn load_from_file(path: &Path) -> OperationResult<Self>;
+
+    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self>;
+
+    fn offsets_len(&self) -> usize;
+
+    fn levels_count(&self) -> usize;
+
+    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType];
+
+    fn get_links_range(&self, idx: usize) -> Range<usize>;
+
+    fn get_level_offset(&self, level: usize) -> usize;
+
+    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType;
+
+    fn num_points(&self) -> usize;
+
+    fn links(&self, point_id: PointOffsetType, level: usize) -> &[PointOffsetType] {
+        if level == 0 {
+            let links_range = self.get_links_range(point_id as usize);
+            self.get_links(links_range)
+        } else {
+            let reindexed_point_id = self.reindex(point_id) as usize;
+            let layer_offsets_start = self.get_level_offset(level);
+            let links_range = self.get_links_range(layer_offsets_start + reindexed_point_id);
+            self.get_links(links_range)
+        }
     }
 
-    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
-        let reindexed_point_id = self.reindex[point_id as usize] as usize;
+    fn point_level(&self, point_id: PointOffsetType) -> usize {
+        let reindexed_point_id = self.reindex(point_id) as usize;
         // level 0 is always present, start checking from level 1. Stop checking when level is incorrect
         for level in 1.. {
             if let Some(offsets_range) = self.get_level_offsets_range(level) {
@@ -140,81 +367,275 @@ impl GraphLinks {
         unreachable!()
     }
 
-    fn get_links_at_zero_level(&self, point_id: PointOffsetType) -> &[PointOffsetType] {
-        let start = self.offsets[point_id as usize];
-        let end = self.offsets[point_id as usize + 1];
-        &self.links[start..end]
-    }
-
-    fn get_links_at_nonzero_level(
-        &self,
-        point_id: PointOffsetType,
-        level: usize,
-    ) -> &[PointOffsetType] {
-        debug_assert!(level > 0);
-        let reindexed_point_id = self.reindex[point_id as usize] as usize;
-        let layer_offsets_start = self.level_offsets[level];
-        let start = self.offsets[layer_offsets_start + reindexed_point_id];
-        let end = self.offsets[layer_offsets_start + reindexed_point_id + 1];
-        &self.links[start..end]
-    }
-
     fn get_level_offsets_range(&self, level: usize) -> Option<Range<usize>> {
-        if level < self.level_offsets.len() {
-            let layer_offsets_start = self.level_offsets[level];
-            let layer_offsets_end = if level + 1 < self.level_offsets.len() {
+        if level < self.levels_count() {
+            let layer_offsets_start = self.get_level_offset(level);
+            let layer_offsets_end = if level + 1 < self.levels_count() {
                 // `level` is not last, next level_offsets is end of range
-                self.level_offsets[level + 1]
+                self.get_level_offset(level + 1)
             } else {
                 // `level` is last, next `offsets.len()` is end of range
-                self.offsets.len() - 1
+                self.offsets_len() - 1
             };
             Some(layer_offsets_start..layer_offsets_end)
         } else {
             None
         }
     }
+}
 
-    fn fill_level_links<I>(
-        &mut self,
-        level: usize,
-        level_points_iter: I,
-        edges: &[Vec<Vec<PointOffsetType>>],
-    ) where
-        I: Iterator<Item = usize>,
-    {
-        self.level_offsets.push(self.offsets.len() - 1);
+#[derive(Default)]
+pub struct GraphLinksRam {
+    // all flattened links of all levels
+    links: Vec<PointOffsetType>,
+    // all ranges in `links`. each range is `links[offsets[i]..offsets[i+1]]`
+    // ranges are sorted by level
+    offsets: Vec<u64>,
+    // start offset of each level in `offsets`
+    level_offsets: Vec<u64>,
+    // for level 1 and above: reindex[point_id] = index of point_id in offsets
+    reindex: Vec<PointOffsetType>,
+}
 
-        for point_id in level_points_iter {
-            let links = &edges[point_id][level];
-            self.links.extend_from_slice(links);
-            self.offsets.push(self.links.len());
+impl GraphLinksRam {
+    pub fn load_from_memory(data: &[u8]) -> Self {
+        let header = GraphLinksFileHeader::deserialize_bytes_from(data);
+        let links = links_slice(data, &header).to_vec();
+        let offsets = offsets_slice(data, &header).to_vec();
+        let level_offsets = level_offsets(data, &header);
+        let reindex = reindex_slice(data, &header).to_vec();
+        Self {
+            links,
+            offsets,
+            level_offsets,
+            reindex,
         }
     }
 }
 
+impl GraphLinks for GraphLinksRam {
+    fn load_from_file(path: &Path) -> OperationResult<Self> {
+        let file = OpenOptions::new()
+            .read(true)
+            .write(false)
+            .create(false)
+            .open(path)?;
+
+        let mmap = unsafe { Mmap::map(&file)? };
+
+        Ok(Self::load_from_memory(&mmap))
+    }
+
+    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
+        let mut data = vec![0; converter.data_size() as usize];
+        converter.serialize_to(&mut data);
+        drop(converter);
+        Ok(GraphLinksRam::load_from_memory(&data))
+    }
+
+    fn offsets_len(&self) -> usize {
+        self.offsets.len()
+    }
+
+    fn levels_count(&self) -> usize {
+        self.level_offsets.len()
+    }
+
+    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType] {
+        &self.links[range]
+    }
+
+    fn get_links_range(&self, idx: usize) -> Range<usize> {
+        let start = self.offsets[idx];
+        let end = self.offsets[idx + 1];
+        start as usize..end as usize
+    }
+
+    fn get_level_offset(&self, level: usize) -> usize {
+        self.level_offsets[level] as usize
+    }
+
+    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
+        self.reindex[point_id as usize]
+    }
+
+    fn num_points(&self) -> usize {
+        self.reindex.len()
+    }
+}
+
+#[derive(Default)]
+pub struct GraphLinksMmap {
+    mmap: Option<Mmap>,
+    header: GraphLinksFileHeader,
+    level_offsets: Vec<u64>,
+}
+
+impl GraphLinksMmap {
+    fn get_reindex_slice(&self) -> &[PointOffsetType] {
+        if let Some(mmap) = &self.mmap {
+            reindex_slice(mmap, &self.header)
+        } else {
+            panic!("{}", MMAP_PANIC_MESSAGE);
+        }
+    }
+
+    fn get_links_slice(&self) -> &[PointOffsetType] {
+        if let Some(mmap) = &self.mmap {
+            links_slice(mmap, &self.header)
+        } else {
+            panic!("{}", "Mmap links are not loaded");
+        }
+    }
+
+    fn get_offsets_slice(&self) -> &[u64] {
+        if let Some(mmap) = &self.mmap {
+            offsets_slice(mmap, &self.header)
+        } else {
+            panic!("{}", MMAP_PANIC_MESSAGE);
+        }
+    }
+}
+
+impl GraphLinks for GraphLinksMmap {
+    fn load_from_file(path: &Path) -> OperationResult<Self> {
+        let file = OpenOptions::new()
+            .read(true)
+            .write(false)
+            .create(false)
+            .open(path)?;
+
+        let mmap = unsafe { Mmap::map(&file)? };
+        let header = GraphLinksFileHeader::deserialize_bytes_from(&mmap);
+        let level_offsets = level_offsets(&mmap, &header);
+
+        Ok(Self {
+            mmap: Some(mmap),
+            header,
+            level_offsets,
+        })
+    }
+
+    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
+        if let Some(path) = converter.path {
+            GraphLinksMmap::load_from_file(&path)
+        } else {
+            Err(OperationError::service_error(
+                "HNSW links Data needs to be saved to file before it can be loaded as mmap",
+            ))
+        }
+    }
+
+    fn offsets_len(&self) -> usize {
+        self.header.get_offsets_range().len() / size_of::<u64>()
+    }
+
+    fn levels_count(&self) -> usize {
+        self.level_offsets.len()
+    }
+
+    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType] {
+        &self.get_links_slice()[range]
+    }
+
+    fn get_links_range(&self, idx: usize) -> Range<usize> {
+        let offsets_slice = self.get_offsets_slice();
+        offsets_slice[idx as usize] as usize..offsets_slice[idx as usize + 1] as usize
+    }
+
+    fn get_level_offset(&self, level: usize) -> usize {
+        self.level_offsets[level] as usize
+    }
+
+    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
+        self.get_reindex_slice()[point_id as usize]
+    }
+
+    fn num_points(&self) -> usize {
+        self.header.point_count as usize
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use rand::Rng;
+    use tempfile::Builder;
 
     use super::*;
     use crate::types::PointOffsetType;
 
+    fn to_vec<TGraphLinks: GraphLinks>(links: &TGraphLinks) -> Vec<Vec<Vec<PointOffsetType>>> {
+        let mut result = Vec::new();
+        let num_points = links.num_points();
+        for i in 0..num_points {
+            let mut layers = Vec::new();
+            let num_levels = links.point_level(i as PointOffsetType) + 1;
+            for level in 0..num_levels {
+                let links = links.links(i as PointOffsetType, level).to_vec();
+                layers.push(links);
+            }
+            result.push(layers);
+        }
+        result
+    }
+
+    fn random_links(
+        points_count: usize,
+        max_levels_count: usize,
+    ) -> Vec<Vec<Vec<PointOffsetType>>> {
+        let mut rng = rand::thread_rng();
+        (0..points_count)
+            .map(|_| {
+                let levels_count = rng.gen_range(1..max_levels_count);
+                (0..levels_count)
+                    .map(|_| {
+                        let links_count = rng.gen_range(0..max_levels_count);
+                        (0..links_count)
+                            .map(|_| rng.gen_range(0..points_count) as PointOffsetType)
+                            .collect()
+                    })
+                    .collect()
+            })
+            .collect()
+    }
+
+    fn test_save_load<A, B>(points_count: usize, max_levels_count: usize)
+    where
+        A: GraphLinks,
+        B: GraphLinks,
+    {
+        let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
+        let links_file = path.path().join("links.bin");
+        let links = random_links(points_count, max_levels_count);
+        {
+            let mut links_converter = GraphLinksConverter::new(links.clone());
+            links_converter.save_as(&links_file).unwrap();
+        }
+        let cmp_links = to_vec(&B::load_from_file(&links_file).unwrap());
+        assert_eq!(links, cmp_links);
+    }
+
     #[test]
     fn test_graph_links_construction() {
         // no points
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // 2 points without any links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![]], vec![vec![]]];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // one link at level 0
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![1]], vec![vec![0]]];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // 3 levels with no links at second level
@@ -223,7 +644,9 @@ mod tests {
             vec![vec![0, 2], vec![], vec![2]],
             vec![vec![0, 1], vec![], vec![1]],
         ];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // 3 levels with no links at last level
@@ -232,7 +655,9 @@ mod tests {
             vec![vec![0, 2], vec![1], vec![]],
             vec![vec![0, 1]],
         ];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // 4 levels with random unexists links
@@ -243,27 +668,24 @@ mod tests {
             vec![vec![0, 1, 5, 6], vec![1, 5, 0]],
             vec![vec![0, 1, 9, 18], vec![1, 5, 6], vec![5], vec![9]],
         ];
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
 
         // fully random links
-        let mut rng = rand::thread_rng();
-        let points_count = 100;
-        let max_levels_count = 10;
-        let links: Vec<Vec<Vec<PointOffsetType>>> = (0..points_count)
-            .map(|_| {
-                let levels_count = rng.gen_range(1..max_levels_count);
-                (0..levels_count)
-                    .map(|_| {
-                        let links_count = rng.gen_range(0..max_levels_count);
-                        (0..links_count)
-                            .map(|_| rng.gen_range(0..points_count) as PointOffsetType)
-                            .collect()
-                    })
-                    .collect()
-            })
-            .collect();
-        let cmp_links = GraphLinks::from_vec(&links).to_vec();
+        let links = random_links(100, 10);
+        let cmp_links = to_vec(
+            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
+        );
         assert_eq!(links, cmp_links);
     }
+
+    #[test]
+    fn test_graph_links_mmap_ram_compability() {
+        test_save_load::<GraphLinksRam, GraphLinksRam>(1000, 10);
+        test_save_load::<GraphLinksMmap, GraphLinksRam>(1000, 10);
+        test_save_load::<GraphLinksRam, GraphLinksMmap>(1000, 10);
+        test_save_load::<GraphLinksMmap, GraphLinksMmap>(1000, 10);
+    }
 }

commit 9702054127430851aa927b59bdc2926adbe203d0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 16 10:53:51 2022 +0100

    Clippy for Rust 1.66 (#1284)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index bae4184b7..d5ad0e38e 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -540,7 +540,7 @@ impl GraphLinks for GraphLinksMmap {
 
     fn get_links_range(&self, idx: usize) -> Range<usize> {
         let offsets_slice = self.get_offsets_slice();
-        offsets_slice[idx as usize] as usize..offsets_slice[idx as usize + 1] as usize
+        offsets_slice[idx] as usize..offsets_slice[idx + 1] as usize
     }
 
     fn get_level_offset(&self, level: usize) -> usize {

commit 3ef66f1e967cab8fa80c02fac8f087e91c108269
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 6 12:02:57 2023 +0100

    Add configuration option to select "memory advice" used for memmapped storage
    
    - Add a simple abstraction/wrapper over `memmap2::Advice` and a global switch
      to select "memory advice" used for memmapped storage to the `segment` crate
    - Add `mmap_advice` configuration option to the `storage::types::StorageConfig`
    - Implement `search-points` benchmark

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index d5ad0e38e..52d3395ef 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -7,6 +7,7 @@ use std::path::{Path, PathBuf};
 use memmap2::{Mmap, MmapMut};
 
 use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::madvise;
 use crate::types::PointOffsetType;
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
@@ -506,6 +507,8 @@ impl GraphLinks for GraphLinksMmap {
             .open(path)?;
 
         let mmap = unsafe { Mmap::map(&file)? };
+        madvise::madvise(&mmap, madvise::get_global())?;
+
         let header = GraphLinksFileHeader::deserialize_bytes_from(&mmap);
         let level_offsets = level_offsets(&mmap, &header);
 

commit 7dc36370c6f7a19a58919d9d5e5a90aec3dc4219
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Apr 21 11:33:45 2023 +0200

    fix Clippy 1.69 lint 'type parameter goes unused in function definition'

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 52d3395ef..ef3d43c0e 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -602,10 +602,10 @@ mod tests {
             .collect()
     }
 
-    fn test_save_load<A, B>(points_count: usize, max_levels_count: usize)
+    /// Test that random links can be saved by `GraphLinksConverter` and loaded correctly by a GraphLinks impl.
+    fn test_save_load<A>(points_count: usize, max_levels_count: usize)
     where
         A: GraphLinks,
-        B: GraphLinks,
     {
         let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
         let links_file = path.path().join("links.bin");
@@ -614,7 +614,7 @@ mod tests {
             let mut links_converter = GraphLinksConverter::new(links.clone());
             links_converter.save_as(&links_file).unwrap();
         }
-        let cmp_links = to_vec(&B::load_from_file(&links_file).unwrap());
+        let cmp_links = to_vec(&A::load_from_file(&links_file).unwrap());
         assert_eq!(links, cmp_links);
     }
 
@@ -685,10 +685,8 @@ mod tests {
     }
 
     #[test]
-    fn test_graph_links_mmap_ram_compability() {
-        test_save_load::<GraphLinksRam, GraphLinksRam>(1000, 10);
-        test_save_load::<GraphLinksMmap, GraphLinksRam>(1000, 10);
-        test_save_load::<GraphLinksRam, GraphLinksMmap>(1000, 10);
-        test_save_load::<GraphLinksMmap, GraphLinksMmap>(1000, 10);
+    fn test_graph_links_mmap_ram_compatibility() {
+        test_save_load::<GraphLinksRam>(1000, 10);
+        test_save_load::<GraphLinksMmap>(1000, 10);
     }
 }

commit 93d784f269eb54eeec7e1c68e925119241eeeebb
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue May 2 20:54:13 2023 +0200

    Improve handling out-of-RAM errors during Qdrant startup (#1777)
    
    * WIP: Start working on out-of-RAM errors handling [skip ci]
    
    * Implement basic handling of out-of-RAM errors during Qdrant startup
    
    * Try to fix CI fail by allowing both V1 and V2 cgroups
    
    * Try to fix CI fail by improving cgroups handling
    
    * Fix cgroups path detection/handling (+ some minor stylistic changes)
    
    * fixup! Fix cgroups path detection/handling (+ some minor stylistic changes)
    
    * Add test
    
    * Enable low RAM test
    
    * fixup! Add test
    
    * free memory checks
    
    * rm unused function
    
    * Oom fallback script (#1809)
    
    * add recover mode in qdrant + script for handelling OOM
    
    * fix clippy
    
    * reformat entrypoint.sh
    
    * fix test
    
    * add logging to test
    
    * fix test
    
    * fix test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index ef3d43c0e..ec1a8d33a 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -64,29 +64,31 @@ struct GraphLinksFileHeader {
     pub total_offsets_len: u64,
 }
 
-fn reindex_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
+fn get_reindex_slice<'a>(
+    data: &'a [u8],
+    header: &'a GraphLinksFileHeader,
+) -> &'a [PointOffsetType] {
     let reindex_range = header.get_reindex_range();
     let reindex_byte_slice = &data[reindex_range];
     transmute_from_u8(reindex_byte_slice)
 }
 
-fn links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
+fn get_links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
     let links_range = header.get_links_range();
     let links_byte_slice = &data[links_range];
     transmute_from_u8(links_byte_slice)
 }
 
-fn offsets_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [u64] {
+fn get_offsets_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [u64] {
     let offsets_range = header.get_offsets_range();
     let offsets_byte_slice = &data[offsets_range];
     transmute_from_u8(offsets_byte_slice)
 }
 
-fn level_offsets(data: &[u8], header: &GraphLinksFileHeader) -> Vec<u64> {
+fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [u64] {
     let level_offsets_range = header.get_level_offsets_range();
     let level_offsets_byte_slice = &data[level_offsets_range];
-    let level_offsets: &[u64] = transmute_from_u8(level_offsets_byte_slice);
-    level_offsets.to_vec()
+    transmute_from_u8(level_offsets_byte_slice)
 }
 
 impl GraphLinksFileHeader {
@@ -399,18 +401,38 @@ pub struct GraphLinksRam {
 }
 
 impl GraphLinksRam {
-    pub fn load_from_memory(data: &[u8]) -> Self {
+    pub fn load_from_memory(data: &[u8]) -> OperationResult<Self> {
         let header = GraphLinksFileHeader::deserialize_bytes_from(data);
-        let links = links_slice(data, &header).to_vec();
-        let offsets = offsets_slice(data, &header).to_vec();
-        let level_offsets = level_offsets(data, &header);
-        let reindex = reindex_slice(data, &header).to_vec();
-        Self {
+
+        let mut links: Vec<PointOffsetType> = Vec::new();
+        let mut offsets: Vec<u64> = Vec::new();
+        let mut level_offsets: Vec<u64> = Vec::new();
+        let mut reindex: Vec<PointOffsetType> = Vec::new();
+
+        let link_slice = get_links_slice(data, &header);
+        links.try_reserve_exact(link_slice.len())?;
+        links.extend_from_slice(link_slice);
+
+        let offsets_slice = get_offsets_slice(data, &header);
+        offsets.try_reserve_exact(offsets_slice.len())?;
+        offsets.extend_from_slice(offsets_slice);
+
+        let level_offsets_slice = get_level_offsets(data, &header);
+        level_offsets.try_reserve_exact(level_offsets_slice.len())?;
+        level_offsets.extend_from_slice(level_offsets_slice);
+
+        let reindex_slice = get_reindex_slice(data, &header);
+        reindex.try_reserve_exact(reindex_slice.len())?;
+        reindex.extend_from_slice(reindex_slice);
+
+        let graph_links = Self {
             links,
             offsets,
             level_offsets,
             reindex,
-        }
+        };
+
+        Ok(graph_links)
     }
 }
 
@@ -424,14 +446,15 @@ impl GraphLinks for GraphLinksRam {
 
         let mmap = unsafe { Mmap::map(&file)? };
 
-        Ok(Self::load_from_memory(&mmap))
+        Self::load_from_memory(&mmap)
     }
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
         let mut data = vec![0; converter.data_size() as usize];
         converter.serialize_to(&mut data);
         drop(converter);
-        Ok(GraphLinksRam::load_from_memory(&data))
+
+        Self::load_from_memory(&data)
     }
 
     fn offsets_len(&self) -> usize {
@@ -475,7 +498,7 @@ pub struct GraphLinksMmap {
 impl GraphLinksMmap {
     fn get_reindex_slice(&self) -> &[PointOffsetType] {
         if let Some(mmap) = &self.mmap {
-            reindex_slice(mmap, &self.header)
+            get_reindex_slice(mmap, &self.header)
         } else {
             panic!("{}", MMAP_PANIC_MESSAGE);
         }
@@ -483,7 +506,7 @@ impl GraphLinksMmap {
 
     fn get_links_slice(&self) -> &[PointOffsetType] {
         if let Some(mmap) = &self.mmap {
-            links_slice(mmap, &self.header)
+            get_links_slice(mmap, &self.header)
         } else {
             panic!("{}", "Mmap links are not loaded");
         }
@@ -491,7 +514,7 @@ impl GraphLinksMmap {
 
     fn get_offsets_slice(&self) -> &[u64] {
         if let Some(mmap) = &self.mmap {
-            offsets_slice(mmap, &self.header)
+            get_offsets_slice(mmap, &self.header)
         } else {
             panic!("{}", MMAP_PANIC_MESSAGE);
         }
@@ -510,7 +533,7 @@ impl GraphLinks for GraphLinksMmap {
         madvise::madvise(&mmap, madvise::get_global())?;
 
         let header = GraphLinksFileHeader::deserialize_bytes_from(&mmap);
-        let level_offsets = level_offsets(&mmap, &header);
+        let level_offsets = get_level_offsets(&mmap, &header).to_vec();
 
         Ok(Self {
             mmap: Some(mmap),

commit 313ad8ea0b927042d30a349cf49e6e9e56c51ca1
Author: Ikko Eltociear Ashimine <eltociear@gmail.com>
Date:   Mon May 8 05:05:52 2023 +0900

    Fix typo in graph_links.rs (#1854)
    
    avaliable -> available

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index ec1a8d33a..27e483ca0 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -363,7 +363,7 @@ pub trait GraphLinks: Default {
                     return level - 1;
                 }
             } else {
-                // incorrect level because this level is larger that avaliable levels
+                // incorrect level because this level is larger that available levels
                 return level - 1;
             }
         }

commit 45ae3e048b15f10e71b5825a9fc00ee7b7676390
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue May 9 18:01:01 2023 +0200

    Dynamic mmap vector storage (#1838)
    
    * wip: chunked mmap
    
    * Fix typo
    
    * insert and get methods
    
    * dynamic bitvec
    
    * clippy
    
    * wip: vector storage
    
    * wip: fmt
    
    * wip: mmap chunks
    
    * wip: mmap problems
    
    * Share transmuted mutable reference over mmap
    
    * option to enable appendable mmap vectors
    
    * fmt
    
    * rename storage status file
    
    * update tests
    
    * fix get deleted value range
    
    * add recovery to vector storage tests
    
    * add flush to tests
    
    * fix transmute from immutable to mutable
    
    * make transmuted pointer private
    
    * remove unused unsafe functions
    
    * force WAL flush if wait=true
    
    * move wal flush into updater thread
    
    * remove flush from update api
    
    * Minimize pub visibility for specialized/dangerous functions
    
    * Allocate vector with predefined capacity
    
    * Inline format parameters
    
    * Assert we have multiple chunks while testing, test is useless otherwise
    
    * Remove unnecessary scope
    
    * Remove unnecessary dereference
    
    * Random bool has 0.5 as standard distribution, use iter::repeat_with
    
    * Replace RemovableMmap::new with Default derive
    
    * Rename len to num_flags
    
    * Use Option replace as it is convention alongside take
    
    * Add FileId enum to replace error prone manual ID rotating
    
    * Use debug_assert_eq where applicable
    
    * Refactor drop and set to replace
    
    * Change default chunk size for chunked mmap vectors to 32MB
    
    This change is made as per GitHub review, because allocating a few
    storages with 128MB would take a significant amount of time and storage.
    
    See: https://github.com/qdrant/qdrant/pull/1838#discussion_r1187215475
    
    * Replace for-loops with iterators
    
    * Draft: add typed mmap to improve code safety (#1860)
    
    * Add typed mmap
    
    * Replace some crude mmap usages with typed mmap
    
    * Use typed mmap for deleted flags
    
    * Simplify dynamic mmap flags a lot with new typed mmap, remove flags option
    
    * Reformat
    
    * Remove old mmap functions that are now unused
    
    * Reimplement mmap locking for mmap_vectors
    
    * Add MmapBitSlice tests
    
    * Replace MmapChunk with new typed mmap
    
    * Update docs
    
    * Clean-up
    
    * Disable alignment assertions on Windows for now
    
    * Rename mmap lock to mlock to prevent confusion with lockable types
    
    * one more small test
    
    * Some review fixes
    
    * Add aliasing note
    
    * Add basic error handling in typed mmap constructors
    
    * Use typed mmap error handling throughout project
    
    * Move mmap type module to common
    
    * Fix transmute functions being unsound
    
    See https://github.com/qdrant/qdrant/pull/1860#discussion_r1188593854
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 27e483ca0..72853d455 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -6,24 +6,13 @@ use std::path::{Path, PathBuf};
 
 use memmap2::{Mmap, MmapMut};
 
+use crate::common::mmap_ops;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::madvise;
 use crate::types::PointOffsetType;
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
 
-fn transmute_from_u8<T>(data: &[u8]) -> &[T] {
-    let len = data.len() / size_of::<T>();
-    let ptr = data.as_ptr() as *const T;
-    unsafe { std::slice::from_raw_parts(ptr, len) }
-}
-
-fn transmute_from_u8_mut<T>(data: &mut [u8]) -> &mut [T] {
-    let len = data.len() / size_of::<T>();
-    let ptr = data.as_mut_ptr() as *mut T;
-    unsafe { std::slice::from_raw_parts_mut(ptr, len) }
-}
-
 /*
 Links data for whole graph layers.
 
@@ -70,25 +59,25 @@ fn get_reindex_slice<'a>(
 ) -> &'a [PointOffsetType] {
     let reindex_range = header.get_reindex_range();
     let reindex_byte_slice = &data[reindex_range];
-    transmute_from_u8(reindex_byte_slice)
+    mmap_ops::transmute_from_u8_to_slice(reindex_byte_slice)
 }
 
 fn get_links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
     let links_range = header.get_links_range();
     let links_byte_slice = &data[links_range];
-    transmute_from_u8(links_byte_slice)
+    mmap_ops::transmute_from_u8_to_slice(links_byte_slice)
 }
 
 fn get_offsets_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [u64] {
     let offsets_range = header.get_offsets_range();
     let offsets_byte_slice = &data[offsets_range];
-    transmute_from_u8(offsets_byte_slice)
+    mmap_ops::transmute_from_u8_to_slice(offsets_byte_slice)
 }
 
 fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [u64] {
     let level_offsets_range = header.get_level_offsets_range();
     let level_offsets_byte_slice = &data[level_offsets_range];
-    transmute_from_u8(level_offsets_byte_slice)
+    mmap_ops::transmute_from_u8_to_slice(level_offsets_byte_slice)
 }
 
 impl GraphLinksFileHeader {
@@ -98,7 +87,7 @@ impl GraphLinksFileHeader {
 
     pub fn serialize_bytes_to(&self, raw_data: &mut [u8]) {
         let byte_slice = &mut raw_data[0..Self::raw_size()];
-        let arr: &mut [u64] = transmute_from_u8_mut(byte_slice);
+        let arr: &mut [u64] = mmap_ops::transmute_from_u8_to_mut_slice(byte_slice);
         arr[0] = self.point_count;
         arr[1] = self.levels_count;
         arr[2] = self.total_links_len;
@@ -107,7 +96,7 @@ impl GraphLinksFileHeader {
 
     pub fn deserialize_bytes_from(raw_data: &[u8]) -> GraphLinksFileHeader {
         let byte_slice = &raw_data[0..Self::raw_size()];
-        let arr: &[u64] = transmute_from_u8(byte_slice);
+        let arr: &[u64] = mmap_ops::transmute_from_u8_to_slice(byte_slice);
         GraphLinksFileHeader {
             point_count: arr[0],
             levels_count: arr[1],
@@ -228,7 +217,8 @@ impl GraphLinksConverter {
         {
             let reindex_range = header.get_reindex_range();
             let reindex_byte_slice = &mut bytes_data[reindex_range];
-            let reindex_slice: &mut [PointOffsetType] = transmute_from_u8_mut(reindex_byte_slice);
+            let reindex_slice: &mut [PointOffsetType] =
+                mmap_ops::transmute_from_u8_to_mut_slice(reindex_byte_slice);
             reindex_slice.copy_from_slice(&self.reindex);
         }
 
@@ -240,8 +230,9 @@ impl GraphLinksConverter {
             let (links_mmap, offsets_mmap) = bytes_data[union_range]
                 .as_mut()
                 .split_at_mut(links_range.len());
-            let links_mmap: &mut [PointOffsetType] = transmute_from_u8_mut(links_mmap);
-            let offsets_mmap: &mut [u64] = transmute_from_u8_mut(offsets_mmap);
+            let links_mmap: &mut [PointOffsetType] =
+                mmap_ops::transmute_from_u8_to_mut_slice(links_mmap);
+            let offsets_mmap: &mut [u64] = mmap_ops::transmute_from_u8_to_mut_slice(offsets_mmap);
             offsets_mmap[0] = 0;
 
             let mut links_pos = 0;
@@ -261,7 +252,8 @@ impl GraphLinksConverter {
         {
             let level_offsets_range = header.get_level_offsets_range();
             let level_offsets_byte_slice = &mut bytes_data[level_offsets_range];
-            let level_offsets_slice: &mut [u64] = transmute_from_u8_mut(level_offsets_byte_slice);
+            let level_offsets_slice: &mut [u64] =
+                mmap_ops::transmute_from_u8_to_mut_slice(level_offsets_byte_slice);
             level_offsets_slice.copy_from_slice(&level_offsets);
         }
     }

commit 324274866bb930af78cebf18d072da003e41a7e2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Jun 5 11:28:46 2023 +0200

    Add `prefault_mmap_pages` method to the `GraphLinksMmap` (#1791) (#2012)
    
    * Add `prefault_mmap_pages` method to the `HNSWIndex`
    
    * Add name to the thread spawned by `Segment::prefault_mmap_pages`

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 72853d455..e000a308c 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -3,6 +3,7 @@ use std::fs::OpenOptions;
 use std::mem::size_of;
 use std::ops::Range;
 use std::path::{Path, PathBuf};
+use std::sync::Arc;
 
 use memmap2::{Mmap, MmapMut};
 
@@ -482,7 +483,7 @@ impl GraphLinks for GraphLinksRam {
 
 #[derive(Default)]
 pub struct GraphLinksMmap {
-    mmap: Option<Mmap>,
+    mmap: Option<Arc<Mmap>>,
     header: GraphLinksFileHeader,
     level_offsets: Vec<u64>,
 }
@@ -511,6 +512,10 @@ impl GraphLinksMmap {
             panic!("{}", MMAP_PANIC_MESSAGE);
         }
     }
+
+    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
+        mmap_ops::PrefaultMmapPages::new(self.mmap.clone()?, Some(path)).into()
+    }
 }
 
 impl GraphLinks for GraphLinksMmap {
@@ -528,7 +533,7 @@ impl GraphLinks for GraphLinksMmap {
         let level_offsets = get_level_offsets(&mmap, &header).to_vec();
 
         Ok(Self {
-            mmap: Some(mmap),
+            mmap: Some(Arc::new(mmap)),
             header,
             level_offsets,
         })

commit eae93b27767a784e1b07179ccdc9948e2caf9c80
Author: Damien Castelltort <dcastelltort@gmail.com>
Date:   Wed Jun 21 22:53:19 2023 +0200

    Configurable location of temporary snapshot files (#1960)
    
    * Issue 1905: Configurable location for the tmp snapshot files
    
    * Apply suggestions from code review
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * fix code review suggestions
    
    * clippy fix
    
    * Propagate temp path, use configured dir for snapshot creation
    
    * Use real temp dir in snapshot tests
    
    * Mention default temporary snapshot file path in configuration
    
    * Use temp everywhere rather than a mix of temp and tmp
    
    * Use consistent naming for temporary snapshot directories
    
    * Extract logic for temporary storage path into toc method
    
    * Resolve clippy warnings
    
    * Apply suggestions from code review
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index e000a308c..81f53fee6 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -267,13 +267,13 @@ impl GraphLinksConverter {
 
     pub fn save_as(&mut self, path: &Path) -> OperationResult<()> {
         self.path = Some(path.to_path_buf());
-        let tmp_path = path.with_extension("tmp");
+        let temp_path = path.with_extension("tmp");
         {
             let file = OpenOptions::new()
                 .read(true)
                 .write(true)
                 .create(true)
-                .open(tmp_path.as_path())?;
+                .open(temp_path.as_path())?;
 
             file.set_len(self.data_size())?;
             let m = unsafe { MmapMut::map_mut(&file) };
@@ -283,7 +283,7 @@ impl GraphLinksConverter {
 
             mmap.flush()?;
         }
-        std::fs::rename(tmp_path, path)?;
+        std::fs::rename(temp_path, path)?;
 
         Ok(())
     }

commit d131388ce1e0c2d4dd60223f9e099a7be0bf390a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jul 19 11:56:58 2023 +0200

    fix usage of try_reserve_exact (#2286)
    
    * fix usage of try_reserve_exact
    
    * fix usage of all try_reserve_exact
    
    * review refactor

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 81f53fee6..b47354be8 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -8,6 +8,7 @@ use std::sync::Arc;
 use memmap2::{Mmap, MmapMut};
 
 use crate::common::mmap_ops;
+use crate::common::vector_utils::TrySetCapacityExact;
 use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::madvise;
 use crate::types::PointOffsetType;
@@ -403,19 +404,19 @@ impl GraphLinksRam {
         let mut reindex: Vec<PointOffsetType> = Vec::new();
 
         let link_slice = get_links_slice(data, &header);
-        links.try_reserve_exact(link_slice.len())?;
+        links.try_set_capacity_exact(link_slice.len())?;
         links.extend_from_slice(link_slice);
 
         let offsets_slice = get_offsets_slice(data, &header);
-        offsets.try_reserve_exact(offsets_slice.len())?;
+        offsets.try_set_capacity_exact(offsets_slice.len())?;
         offsets.extend_from_slice(offsets_slice);
 
         let level_offsets_slice = get_level_offsets(data, &header);
-        level_offsets.try_reserve_exact(level_offsets_slice.len())?;
+        level_offsets.try_set_capacity_exact(level_offsets_slice.len())?;
         level_offsets.extend_from_slice(level_offsets_slice);
 
         let reindex_slice = get_reindex_slice(data, &header);
-        reindex.try_reserve_exact(reindex_slice.len())?;
+        reindex.try_set_capacity_exact(reindex_slice.len())?;
         reindex.extend_from_slice(reindex_slice);
 
         let graph_links = Self {

commit 58d060542ebcbef0a4eba817c8b419f3426a7d1a
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Sep 13 12:19:05 2023 +0200

    Misc. improvements to GraphLinks (#2651)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index b47354be8..bb4bd5c97 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -207,12 +207,7 @@ impl GraphLinksConverter {
     }
 
     pub fn serialize_to(&self, bytes_data: &mut [u8]) {
-        let header = GraphLinksFileHeader {
-            point_count: self.reindex.len() as u64,
-            levels_count: self.get_levels_count() as u64,
-            total_links_len: self.total_links_len as u64,
-            total_offsets_len: self.total_offsets_len as u64,
-        };
+        let header = self.get_header();
 
         header.serialize_bytes_to(bytes_data);
 
@@ -224,7 +219,8 @@ impl GraphLinksConverter {
             reindex_slice.copy_from_slice(&self.reindex);
         }
 
-        let mut level_offsets = Vec::new();
+        let header_levels_count = header.levels_count as usize;
+        let mut level_offsets = Vec::with_capacity(header_levels_count);
         {
             let links_range = header.get_links_range();
             let offsets_range = header.get_offsets_range();
@@ -239,7 +235,7 @@ impl GraphLinksConverter {
 
             let mut links_pos = 0;
             let mut offsets_pos = 1;
-            for level in 0..header.levels_count as usize {
+            for level in 0..header_levels_count {
                 level_offsets.push(offsets_pos as u64 - 1);
                 self.iterate_level_points(level, |_, links| {
                     links_mmap[links_pos..links_pos + links.len()].copy_from_slice(links);

commit a18573b26503d33b89bb076c346196b6517d5a4e
Author: Josh Soref <2119212+jsoref@users.noreply.github.com>
Date:   Thu Sep 14 05:38:23 2023 -0400

    Spelling (#2658)
    
    * spelling: accumulating
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: and
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: back
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: batching
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: been
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: benchmark
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: collections
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: confusion
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: consensus
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: decrease
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: equal
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: github
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: minimal
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: nonexistent
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: oversampling
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: paths
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: points
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: prevent
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: protobuf
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: proxied
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: randomness
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    * spelling: recover
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
    
    ---------
    
    Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index bb4bd5c97..e9d1dbc98 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -680,7 +680,7 @@ mod tests {
         );
         assert_eq!(links, cmp_links);
 
-        // 4 levels with random unexists links
+        // 4 levels with random nonexistent links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
             vec![vec![1, 2, 5, 6]],
             vec![vec![0, 2, 7, 8], vec![], vec![34, 45, 10]],

commit abd0d57d5d73e5530f5f356a86c7c4b478be9561
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 25 11:30:50 2023 +0200

    Introduce Memory common module (#2712)
    
    * Introduce Memory common module
    
    * fix Windaube build
    
    * move mmap_ops as well

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index e9d1dbc98..6623a31e2 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -6,11 +6,10 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use memmap2::{Mmap, MmapMut};
+use memory::{madvise, mmap_ops};
 
-use crate::common::mmap_ops;
 use crate::common::vector_utils::TrySetCapacityExact;
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::madvise;
 use crate::types::PointOffsetType;
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 6623a31e2..7efd567a3 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -5,12 +5,12 @@ use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use common::types::PointOffsetType;
 use memmap2::{Mmap, MmapMut};
 use memory::{madvise, mmap_ops};
 
 use crate::common::vector_utils::TrySetCapacityExact;
 use crate::entry::entry_point::{OperationError, OperationResult};
-use crate::types::PointOffsetType;
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
 
@@ -581,7 +581,6 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
-    use crate::types::PointOffsetType;
 
     fn to_vec<TGraphLinks: GraphLinks>(links: &TGraphLinks) -> Vec<Vec<Vec<PointOffsetType>>> {
         let mut result = Vec::new();

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 7efd567a3..534bfcafd 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -9,8 +9,8 @@ use common::types::PointOffsetType;
 use memmap2::{Mmap, MmapMut};
 use memory::{madvise, mmap_ops};
 
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::vector_utils::TrySetCapacityExact;
-use crate::entry::entry_point::{OperationError, OperationResult};
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
 

commit 7d0e4e76ff495e1d8c7b30a2bff03f996129d8ff
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Feb 8 07:24:47 2024 -0300

    Fix clippy 1.77 lints: explicitly set truncate flag on file creation (#3561)
    
    * add `truncate(true)` where unspecified
    
    * remove unused `WriteGuard` wrapper
    
    * Don't truncate if we explicitly set the size later
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 534bfcafd..917b79c03 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -269,9 +269,11 @@ impl GraphLinksConverter {
                 .read(true)
                 .write(true)
                 .create(true)
+                // Don't truncate because we explicitly set the length later
+                .truncate(false)
                 .open(temp_path.as_path())?;
-
             file.set_len(self.data_size())?;
+
             let m = unsafe { MmapMut::map_mut(&file) };
             let mut mmap = m?;
 

commit cdf6eaab69a74e5a8cd75205aa0d0fa577c8e939
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Mar 13 21:09:56 2024 +0100

    Fix `GraphLinksConverter::serialize_to` data alignment issues (#3806)
    
    * Assert data alignment in `transmute_from_u8*` functions
    
    * WIP: Switch `transmute_from_u8*` alignment asserts from `debug_assert` to `assert`...
    
    ...to make sure *all* tests running on CI will enforce the alignment
    
    * Add descriptive message to alignment assertions
    
    * Fix alignment in graph links file (#3807)
    
    * fix alignment in graph links file
    
    * fix alignment while reading
    
    * Revert "fix alignment while reading"
    
    This reverts commit e2d1cee890cf5c59b1f239c45a99fa62fd86a825.
    
    * Revert "Revert "fix alignment while reading""
    
    This reverts commit 7a4fdc9aea14c0ed294ece83b7c390e8bac699fb.
    
    * small refactor
    
    * Switch `transmute_from_u8*` alignment asserts back to `debug_assert`
    
    Additionally:
    - Remove extra `0x` from slice address in assert messages
    
    * Trim offsets padding bytes from the end of `links_mmap` slice
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 917b79c03..a5ce41a21 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,6 +1,6 @@
 use std::cmp::max;
 use std::fs::OpenOptions;
-use std::mem::size_of;
+use std::mem::{self, size_of};
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -52,6 +52,7 @@ struct GraphLinksFileHeader {
     pub levels_count: u64,
     pub total_links_len: u64,
     pub total_offsets_len: u64,
+    pub offsets_padding: u64,
 }
 
 fn get_reindex_slice<'a>(
@@ -69,10 +70,18 @@ fn get_links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a
     mmap_ops::transmute_from_u8_to_slice(links_byte_slice)
 }
 
-fn get_offsets_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [u64] {
+fn get_offsets_iter<'a>(
+    data: &'a [u8],
+    header: &'a GraphLinksFileHeader,
+) -> impl Iterator<Item = u64> + 'a {
     let offsets_range = header.get_offsets_range();
-    let offsets_byte_slice = &data[offsets_range];
-    mmap_ops::transmute_from_u8_to_slice(offsets_byte_slice)
+    data[offsets_range]
+        .chunks_exact(mem::size_of::<u64>())
+        .map(|chunk| {
+            // unwrap is safe because we know that chunk is always 8 bytes
+            let bytes: [u8; 8] = chunk.try_into().unwrap();
+            u64::from_ne_bytes(bytes)
+        })
 }
 
 fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [u64] {
@@ -82,8 +91,28 @@ fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [
 }
 
 impl GraphLinksFileHeader {
+    pub fn new(
+        point_count: usize,
+        levels_count: usize,
+        total_links_len: usize,
+        total_offsets_len: usize,
+    ) -> GraphLinksFileHeader {
+        let offsets_padding = if (point_count + total_links_len) % 2 == 0 {
+            0
+        } else {
+            4
+        };
+        GraphLinksFileHeader {
+            point_count: point_count as u64,
+            levels_count: levels_count as u64,
+            total_links_len: total_links_len as u64,
+            total_offsets_len: total_offsets_len as u64,
+            offsets_padding,
+        }
+    }
+
     pub fn raw_size() -> usize {
-        size_of::<u64>() * 4
+        size_of::<u64>() * 5
     }
 
     pub fn serialize_bytes_to(&self, raw_data: &mut [u8]) {
@@ -93,6 +122,7 @@ impl GraphLinksFileHeader {
         arr[1] = self.levels_count;
         arr[2] = self.total_links_len;
         arr[3] = self.total_offsets_len;
+        arr[4] = self.offsets_padding;
     }
 
     pub fn deserialize_bytes_from(raw_data: &[u8]) -> GraphLinksFileHeader {
@@ -103,6 +133,7 @@ impl GraphLinksFileHeader {
             levels_count: arr[1],
             total_links_len: arr[2],
             total_offsets_len: arr[3],
+            offsets_padding: arr[4],
         }
     }
 
@@ -128,7 +159,7 @@ impl GraphLinksFileHeader {
     }
 
     pub fn get_offsets_range(&self) -> Range<usize> {
-        let start = self.get_links_range().end;
+        let start = self.get_links_range().end + self.offsets_padding as usize;
         start..start + self.total_offsets_len as usize * size_of::<u64>()
     }
 }
@@ -192,12 +223,12 @@ impl GraphLinksConverter {
     }
 
     fn get_header(&self) -> GraphLinksFileHeader {
-        GraphLinksFileHeader {
-            point_count: self.reindex.len() as u64,
-            levels_count: self.get_levels_count() as u64,
-            total_links_len: self.total_links_len as u64,
-            total_offsets_len: self.total_offsets_len as u64,
-        }
+        GraphLinksFileHeader::new(
+            self.reindex.len(),
+            self.get_levels_count(),
+            self.total_links_len,
+            self.total_offsets_len,
+        )
     }
 
     /// Size of compacted graph in bytes.
@@ -224,9 +255,10 @@ impl GraphLinksConverter {
             let links_range = header.get_links_range();
             let offsets_range = header.get_offsets_range();
             let union_range = links_range.start..offsets_range.end;
-            let (links_mmap, offsets_mmap) = bytes_data[union_range]
+            let (links_mmap, offsets_with_padding_mmap) = bytes_data[union_range]
                 .as_mut()
                 .split_at_mut(links_range.len());
+            let offsets_mmap = &mut offsets_with_padding_mmap[header.offsets_padding as _..];
             let links_mmap: &mut [PointOffsetType] =
                 mmap_ops::transmute_from_u8_to_mut_slice(links_mmap);
             let offsets_mmap: &mut [u64] = mmap_ops::transmute_from_u8_to_mut_slice(offsets_mmap);
@@ -404,9 +436,8 @@ impl GraphLinksRam {
         links.try_set_capacity_exact(link_slice.len())?;
         links.extend_from_slice(link_slice);
 
-        let offsets_slice = get_offsets_slice(data, &header);
-        offsets.try_set_capacity_exact(offsets_slice.len())?;
-        offsets.extend_from_slice(offsets_slice);
+        offsets.try_set_capacity_exact(header.get_offsets_range().len() / size_of::<u64>())?;
+        offsets.extend(get_offsets_iter(data, &header));
 
         let level_offsets_slice = get_level_offsets(data, &header);
         level_offsets.try_set_capacity_exact(level_offsets_slice.len())?;
@@ -499,16 +530,17 @@ impl GraphLinksMmap {
         if let Some(mmap) = &self.mmap {
             get_links_slice(mmap, &self.header)
         } else {
-            panic!("{}", "Mmap links are not loaded");
+            panic!("{}", MMAP_PANIC_MESSAGE);
         }
     }
 
-    fn get_offsets_slice(&self) -> &[u64] {
-        if let Some(mmap) = &self.mmap {
-            get_offsets_slice(mmap, &self.header)
-        } else {
-            panic!("{}", MMAP_PANIC_MESSAGE);
-        }
+    fn get_links_offset(offsets_data: &[u8], idx: usize) -> usize {
+        let begin = mem::size_of::<u64>() * idx;
+        let end = begin + mem::size_of::<u64>();
+        let bytes = &offsets_data[begin..end];
+        // unwrap is safe because we know that bytes slice is always 8 bytes
+        let bytes: [u8; 8] = bytes.try_into().unwrap();
+        u64::from_ne_bytes(bytes) as usize
     }
 
     pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
@@ -560,8 +592,14 @@ impl GraphLinks for GraphLinksMmap {
     }
 
     fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let offsets_slice = self.get_offsets_slice();
-        offsets_slice[idx] as usize..offsets_slice[idx + 1] as usize
+        let offsets_range = self.header.get_offsets_range();
+        let mmap: &[u8] = if let Some(mmap) = &self.mmap {
+            &mmap[offsets_range]
+        } else {
+            panic!("{}", MMAP_PANIC_MESSAGE);
+        };
+
+        Self::get_links_offset(mmap, idx)..Self::get_links_offset(mmap, idx + 1)
     }
 
     fn get_level_offset(&self, level: usize) -> usize {

commit a06d20fb58a70f369c3a3b40178b726a291e6423
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 8 07:51:59 2024 +0000

    Remove dead code (#4623)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index a5ce41a21..6b555295c 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -218,10 +218,6 @@ impl GraphLinksConverter {
         }
     }
 
-    pub fn set_path(&mut self, path: PathBuf) {
-        self.path = Some(path);
-    }
-
     fn get_header(&self) -> GraphLinksFileHeader {
         GraphLinksFileHeader::new(
             self.reindex.len(),
@@ -287,12 +283,6 @@ impl GraphLinksConverter {
         }
     }
 
-    pub fn to_bytes(&self) -> Vec<u8> {
-        let mut bytes = vec![0; self.data_size() as usize];
-        self.serialize_to(&mut bytes);
-        bytes
-    }
-
     pub fn save_as(&mut self, path: &Path) -> OperationResult<()> {
         self.path = Some(path.to_path_buf());
         let temp_path = path.with_extension("tmp");

commit 54c0d94f5ab76ca80a69b7d60dfedf7d7e2b32c2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Jul 9 14:19:42 2024 +0200

    Derive/implement `fmt::Debug` for `Segment` (#4632)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 6b555295c..4f18da9ff 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -46,7 +46,7 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
-#[derive(Default)]
+#[derive(Debug, Default)]
 struct GraphLinksFileHeader {
     pub point_count: u64,
     pub levels_count: u64,
@@ -400,7 +400,7 @@ pub trait GraphLinks: Default {
     }
 }
 
-#[derive(Default)]
+#[derive(Debug, Default)]
 pub struct GraphLinksRam {
     // all flattened links of all levels
     links: Vec<PointOffsetType>,
@@ -500,7 +500,7 @@ impl GraphLinks for GraphLinksRam {
     }
 }
 
-#[derive(Default)]
+#[derive(Debug, Default)]
 pub struct GraphLinksMmap {
     mmap: Option<Arc<Mmap>>,
     header: GraphLinksFileHeader,

commit fdec05f99a0c728e4661105e9769c42ba887fa24
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Nov 7 10:54:14 2024 +0000

    GraphLinksMmap: remove Option (#5374)
    
    * Introduce GraphLayerData
    
    * trait GraphLinks: do not require Default

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 4f18da9ff..0d056af26 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -335,7 +335,7 @@ impl GraphLinksConverter {
     }
 }
 
-pub trait GraphLinks: Default {
+pub trait GraphLinks: Sized {
     fn load_from_file(path: &Path) -> OperationResult<Self>;
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self>;
@@ -400,7 +400,7 @@ pub trait GraphLinks: Default {
     }
 }
 
-#[derive(Debug, Default)]
+#[derive(Debug)]
 pub struct GraphLinksRam {
     // all flattened links of all levels
     links: Vec<PointOffsetType>,
@@ -500,28 +500,20 @@ impl GraphLinks for GraphLinksRam {
     }
 }
 
-#[derive(Debug, Default)]
+#[derive(Debug)]
 pub struct GraphLinksMmap {
-    mmap: Option<Arc<Mmap>>,
+    mmap: Arc<Mmap>,
     header: GraphLinksFileHeader,
     level_offsets: Vec<u64>,
 }
 
 impl GraphLinksMmap {
     fn get_reindex_slice(&self) -> &[PointOffsetType] {
-        if let Some(mmap) = &self.mmap {
-            get_reindex_slice(mmap, &self.header)
-        } else {
-            panic!("{}", MMAP_PANIC_MESSAGE);
-        }
+        get_reindex_slice(&self.mmap, &self.header)
     }
 
     fn get_links_slice(&self) -> &[PointOffsetType] {
-        if let Some(mmap) = &self.mmap {
-            get_links_slice(mmap, &self.header)
-        } else {
-            panic!("{}", MMAP_PANIC_MESSAGE);
-        }
+        get_links_slice(&self.mmap, &self.header)
     }
 
     fn get_links_offset(offsets_data: &[u8], idx: usize) -> usize {
@@ -533,8 +525,8 @@ impl GraphLinksMmap {
         u64::from_ne_bytes(bytes) as usize
     }
 
-    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
-        mmap_ops::PrefaultMmapPages::new(self.mmap.clone()?, Some(path)).into()
+    pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
+        mmap_ops::PrefaultMmapPages::new(Arc::clone(&self.mmap), Some(path))
     }
 }
 
@@ -553,7 +545,7 @@ impl GraphLinks for GraphLinksMmap {
         let level_offsets = get_level_offsets(&mmap, &header).to_vec();
 
         Ok(Self {
-            mmap: Some(Arc::new(mmap)),
+            mmap: Arc::new(mmap),
             header,
             level_offsets,
         })
@@ -583,12 +575,7 @@ impl GraphLinks for GraphLinksMmap {
 
     fn get_links_range(&self, idx: usize) -> Range<usize> {
         let offsets_range = self.header.get_offsets_range();
-        let mmap: &[u8] = if let Some(mmap) = &self.mmap {
-            &mmap[offsets_range]
-        } else {
-            panic!("{}", MMAP_PANIC_MESSAGE);
-        };
-
+        let mmap: &[u8] = &self.mmap[offsets_range];
         Self::get_links_offset(mmap, idx)..Self::get_links_offset(mmap, idx + 1)
     }
 

commit 2fb5f12ea7455cf5a70d41813f2e56f7b4617e78
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Nov 15 05:19:55 2024 +0000

    Introduce GraphLinksRef (#5377)
    
    * GraphLinksView
    
    * GraphLinks::links: return iterator instead of slice

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 0d056af26..54c0297d7 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,6 +1,6 @@
 use std::cmp::max;
 use std::fs::OpenOptions;
-use std::mem::{self, size_of};
+use std::io::Read as _;
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -46,7 +46,7 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
-#[derive(Debug, Default)]
+#[derive(Clone, Debug, Default)]
 struct GraphLinksFileHeader {
     pub point_count: u64,
     pub levels_count: u64,
@@ -55,35 +55,6 @@ struct GraphLinksFileHeader {
     pub offsets_padding: u64,
 }
 
-fn get_reindex_slice<'a>(
-    data: &'a [u8],
-    header: &'a GraphLinksFileHeader,
-) -> &'a [PointOffsetType] {
-    let reindex_range = header.get_reindex_range();
-    let reindex_byte_slice = &data[reindex_range];
-    mmap_ops::transmute_from_u8_to_slice(reindex_byte_slice)
-}
-
-fn get_links_slice<'a>(data: &'a [u8], header: &'a GraphLinksFileHeader) -> &'a [PointOffsetType] {
-    let links_range = header.get_links_range();
-    let links_byte_slice = &data[links_range];
-    mmap_ops::transmute_from_u8_to_slice(links_byte_slice)
-}
-
-fn get_offsets_iter<'a>(
-    data: &'a [u8],
-    header: &'a GraphLinksFileHeader,
-) -> impl Iterator<Item = u64> + 'a {
-    let offsets_range = header.get_offsets_range();
-    data[offsets_range]
-        .chunks_exact(mem::size_of::<u64>())
-        .map(|chunk| {
-            // unwrap is safe because we know that chunk is always 8 bytes
-            let bytes: [u8; 8] = chunk.try_into().unwrap();
-            u64::from_ne_bytes(bytes)
-        })
-}
-
 fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [u64] {
     let level_offsets_range = header.get_level_offsets_range();
     let level_offsets_byte_slice = &data[level_offsets_range];
@@ -340,111 +311,41 @@ pub trait GraphLinks: Sized {
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self>;
 
-    fn offsets_len(&self) -> usize;
-
-    fn levels_count(&self) -> usize;
-
-    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType];
-
-    fn get_links_range(&self, idx: usize) -> Range<usize>;
-
-    fn get_level_offset(&self, level: usize) -> usize;
-
-    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType;
-
     fn num_points(&self) -> usize;
 
-    fn links(&self, point_id: PointOffsetType, level: usize) -> &[PointOffsetType] {
-        if level == 0 {
-            let links_range = self.get_links_range(point_id as usize);
-            self.get_links(links_range)
-        } else {
-            let reindexed_point_id = self.reindex(point_id) as usize;
-            let layer_offsets_start = self.get_level_offset(level);
-            let links_range = self.get_links_range(layer_offsets_start + reindexed_point_id);
-            self.get_links(links_range)
-        }
-    }
-
-    fn point_level(&self, point_id: PointOffsetType) -> usize {
-        let reindexed_point_id = self.reindex(point_id) as usize;
-        // level 0 is always present, start checking from level 1. Stop checking when level is incorrect
-        for level in 1.. {
-            if let Some(offsets_range) = self.get_level_offsets_range(level) {
-                if offsets_range.start + reindexed_point_id >= offsets_range.end {
-                    // incorrect level because point_id is out of range
-                    return level - 1;
-                }
-            } else {
-                // incorrect level because this level is larger that available levels
-                return level - 1;
-            }
-        }
-        unreachable!()
-    }
+    fn links(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+    ) -> impl Iterator<Item = PointOffsetType>;
 
-    fn get_level_offsets_range(&self, level: usize) -> Option<Range<usize>> {
-        if level < self.levels_count() {
-            let layer_offsets_start = self.get_level_offset(level);
-            let layer_offsets_end = if level + 1 < self.levels_count() {
-                // `level` is not last, next level_offsets is end of range
-                self.get_level_offset(level + 1)
-            } else {
-                // `level` is last, next `offsets.len()` is end of range
-                self.offsets_len() - 1
-            };
-            Some(layer_offsets_start..layer_offsets_end)
-        } else {
-            None
-        }
-    }
+    fn point_level(&self, point_id: PointOffsetType) -> usize;
 }
 
 #[derive(Debug)]
 pub struct GraphLinksRam {
-    // all flattened links of all levels
-    links: Vec<PointOffsetType>,
-    // all ranges in `links`. each range is `links[offsets[i]..offsets[i+1]]`
-    // ranges are sorted by level
-    offsets: Vec<u64>,
-    // start offset of each level in `offsets`
+    data: Vec<u8>,
+    header: GraphLinksFileHeader,
     level_offsets: Vec<u64>,
-    // for level 1 and above: reindex[point_id] = index of point_id in offsets
-    reindex: Vec<PointOffsetType>,
 }
 
 impl GraphLinksRam {
-    pub fn load_from_memory(data: &[u8]) -> OperationResult<Self> {
-        let header = GraphLinksFileHeader::deserialize_bytes_from(data);
-
-        let mut links: Vec<PointOffsetType> = Vec::new();
-        let mut offsets: Vec<u64> = Vec::new();
-        let mut level_offsets: Vec<u64> = Vec::new();
-        let mut reindex: Vec<PointOffsetType> = Vec::new();
-
-        let link_slice = get_links_slice(data, &header);
-        links.try_set_capacity_exact(link_slice.len())?;
-        links.extend_from_slice(link_slice);
-
-        offsets.try_set_capacity_exact(header.get_offsets_range().len() / size_of::<u64>())?;
-        offsets.extend(get_offsets_iter(data, &header));
-
-        let level_offsets_slice = get_level_offsets(data, &header);
-        level_offsets.try_set_capacity_exact(level_offsets_slice.len())?;
-        level_offsets.extend_from_slice(level_offsets_slice);
-
-        let reindex_slice = get_reindex_slice(data, &header);
-        reindex.try_set_capacity_exact(reindex_slice.len())?;
-        reindex.extend_from_slice(reindex_slice);
-
-        let graph_links = Self {
-            links,
-            offsets,
+    fn from_bytes(data: Vec<u8>) -> Self {
+        let header = GraphLinksFileHeader::deserialize_bytes_from(&data);
+        let level_offsets = get_level_offsets(&data, &header).to_vec();
+        Self {
+            data,
+            header,
             level_offsets,
-            reindex,
-        };
+        }
+    }
 
-        Ok(graph_links)
+    fn view(&self) -> GraphLinksView {
+        GraphLinksView {
+            data: &self.data,
+            header: &self.header,
+            level_offsets: &self.level_offsets,
+        }
     }
 }
 
@@ -455,10 +356,13 @@ impl GraphLinks for GraphLinksRam {
             .write(false)
             .create(false)
             .open(path)?;
+        let len = file.metadata()?.len();
 
-        let mmap = unsafe { Mmap::map(&file)? };
+        let mut data = Vec::new();
+        data.try_set_capacity_exact(len as usize)?;
+        file.take(len).read_to_end(&mut data)?;
 
-        Self::load_from_memory(&mmap)
+        Ok(Self::from_bytes(data))
     }
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
@@ -466,37 +370,23 @@ impl GraphLinks for GraphLinksRam {
         converter.serialize_to(&mut data);
         drop(converter);
 
-        Self::load_from_memory(&data)
-    }
-
-    fn offsets_len(&self) -> usize {
-        self.offsets.len()
-    }
-
-    fn levels_count(&self) -> usize {
-        self.level_offsets.len()
-    }
-
-    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType] {
-        &self.links[range]
-    }
-
-    fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let start = self.offsets[idx];
-        let end = self.offsets[idx + 1];
-        start as usize..end as usize
+        Ok(Self::from_bytes(data))
     }
 
-    fn get_level_offset(&self, level: usize) -> usize {
-        self.level_offsets[level] as usize
+    fn num_points(&self) -> usize {
+        self.header.point_count as usize
     }
 
-    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
-        self.reindex[point_id as usize]
+    fn links(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+    ) -> impl Iterator<Item = PointOffsetType> {
+        self.view().links(point_id, level)
     }
 
-    fn num_points(&self) -> usize {
-        self.reindex.len()
+    fn point_level(&self, point_id: PointOffsetType) -> usize {
+        self.view().point_level(point_id)
     }
 }
 
@@ -508,26 +398,17 @@ pub struct GraphLinksMmap {
 }
 
 impl GraphLinksMmap {
-    fn get_reindex_slice(&self) -> &[PointOffsetType] {
-        get_reindex_slice(&self.mmap, &self.header)
-    }
-
-    fn get_links_slice(&self) -> &[PointOffsetType] {
-        get_links_slice(&self.mmap, &self.header)
-    }
-
-    fn get_links_offset(offsets_data: &[u8], idx: usize) -> usize {
-        let begin = mem::size_of::<u64>() * idx;
-        let end = begin + mem::size_of::<u64>();
-        let bytes = &offsets_data[begin..end];
-        // unwrap is safe because we know that bytes slice is always 8 bytes
-        let bytes: [u8; 8] = bytes.try_into().unwrap();
-        u64::from_ne_bytes(bytes) as usize
-    }
-
     pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
         mmap_ops::PrefaultMmapPages::new(Arc::clone(&self.mmap), Some(path))
     }
+
+    fn view(&self) -> GraphLinksView {
+        GraphLinksView {
+            data: &self.mmap,
+            header: &self.header,
+            level_offsets: &self.level_offsets,
+        }
+    }
 }
 
 impl GraphLinks for GraphLinksMmap {
@@ -553,7 +434,7 @@ impl GraphLinks for GraphLinksMmap {
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
         if let Some(path) = converter.path {
-            GraphLinksMmap::load_from_file(&path)
+            Self::load_from_file(&path)
         } else {
             Err(OperationError::service_error(
                 "HNSW links Data needs to be saved to file before it can be loaded as mmap",
@@ -561,39 +442,109 @@ impl GraphLinks for GraphLinksMmap {
         }
     }
 
-    fn offsets_len(&self) -> usize {
-        self.header.get_offsets_range().len() / size_of::<u64>()
+    fn num_points(&self) -> usize {
+        self.header.point_count as usize
     }
 
-    fn levels_count(&self) -> usize {
-        self.level_offsets.len()
+    fn links(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+    ) -> impl Iterator<Item = PointOffsetType> {
+        self.view().links(point_id, level)
     }
 
-    fn get_links(&self, range: Range<usize>) -> &[PointOffsetType] {
-        &self.get_links_slice()[range]
+    fn point_level(&self, point_id: PointOffsetType) -> usize {
+        self.view().point_level(point_id)
     }
+}
 
-    fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let offsets_range = self.header.get_offsets_range();
-        let mmap: &[u8] = &self.mmap[offsets_range];
-        Self::get_links_offset(mmap, idx)..Self::get_links_offset(mmap, idx + 1)
+#[derive(Debug)]
+struct GraphLinksView<'a> {
+    data: &'a [u8],
+    header: &'a GraphLinksFileHeader,
+    level_offsets: &'a [u64],
+}
+
+impl<'a> GraphLinksView<'a> {
+    fn links(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+    ) -> impl Iterator<Item = PointOffsetType> + 'a {
+        let idx = if level == 0 {
+            point_id as usize
+        } else {
+            self.level_offsets[level] as usize + self.reindex(point_id) as usize
+        };
+        let links_range = self.get_links_range(idx);
+        self.get_links(links_range).iter().copied()
+    }
+
+    fn point_level(&self, point_id: PointOffsetType) -> usize {
+        let reindexed_point_id = self.reindex(point_id) as usize;
+        // level 0 is always present, start checking from level 1. Stop checking when level is incorrect
+        for level in 1.. {
+            if let Some(offsets_range) = self.get_level_offsets_range(level) {
+                if offsets_range.start + reindexed_point_id >= offsets_range.end {
+                    // incorrect level because point_id is out of range
+                    return level - 1;
+                }
+            } else {
+                // incorrect level because this level is larger that available levels
+                return level - 1;
+            }
+        }
+        unreachable!()
+    }
+
+    fn get_level_offsets_range(&self, level: usize) -> Option<Range<usize>> {
+        if level < self.level_offsets.len() {
+            let layer_offsets_start = self.level_offsets[level] as usize;
+            let layer_offsets_end = if level + 1 < self.level_offsets.len() {
+                // `level` is not last, next level_offsets is end of range
+                self.level_offsets[level + 1] as usize
+            } else {
+                // `level` is last, next `offsets.len()` is end of range
+                self.header.get_offsets_range().len() / size_of::<u64>() - 1
+            };
+            Some(layer_offsets_start..layer_offsets_end)
+        } else {
+            None
+        }
+    }
+
+    fn get_links_offset(offsets_data: &[u8], idx: usize) -> usize {
+        let begin = size_of::<u64>() * idx;
+        let end = begin + size_of::<u64>();
+        let bytes = &offsets_data[begin..end];
+        // unwrap is safe because we know that bytes slice is always 8 bytes
+        let bytes: [u8; 8] = bytes.try_into().unwrap();
+        u64::from_ne_bytes(bytes) as usize
     }
 
-    fn get_level_offset(&self, level: usize) -> usize {
-        self.level_offsets[level] as usize
+    fn get_links_range(&self, idx: usize) -> Range<usize> {
+        let offsets_range = self.header.get_offsets_range();
+        let data: &[u8] = &self.data[offsets_range];
+        Self::get_links_offset(data, idx)..Self::get_links_offset(data, idx + 1)
     }
 
     fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
-        self.get_reindex_slice()[point_id as usize]
+        let reindex_range = self.header.get_reindex_range();
+        let reindex_byte_slice = &self.data[reindex_range];
+        mmap_ops::transmute_from_u8_to_slice(reindex_byte_slice)[point_id as usize]
     }
 
-    fn num_points(&self) -> usize {
-        self.header.point_count as usize
+    fn get_links(&self, range: Range<usize>) -> &'a [PointOffsetType] {
+        let links_range = self.header.get_links_range();
+        let links_byte_slice = &self.data[links_range];
+        &mmap_ops::transmute_from_u8_to_slice(links_byte_slice)[range]
     }
 }
 
 #[cfg(test)]
 mod tests {
+    use itertools::Itertools as _;
     use rand::Rng;
     use tempfile::Builder;
 
@@ -606,7 +557,7 @@ mod tests {
             let mut layers = Vec::new();
             let num_levels = links.point_level(i as PointOffsetType) + 1;
             for level in 0..num_levels {
-                let links = links.links(i as PointOffsetType, level).to_vec();
+                let links = links.links(i as PointOffsetType, level).collect_vec();
                 layers.push(links);
             }
             result.push(layers);

commit 1db3cfaa36820c6a9ff7a7fa33b61019d08134ec
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Nov 26 21:35:26 2024 +0000

    GraphLinks::for_each_link (#5490)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 54c0297d7..c37ec72ac 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -313,13 +313,21 @@ pub trait GraphLinks: Sized {
 
     fn num_points(&self) -> usize;
 
-    fn links(
+    fn for_each_link(
         &self,
         point_id: PointOffsetType,
         level: usize,
-    ) -> impl Iterator<Item = PointOffsetType>;
+        f: impl FnMut(PointOffsetType),
+    );
 
     fn point_level(&self, point_id: PointOffsetType) -> usize;
+
+    #[cfg(test)]
+    fn links_vec(&self, point_id: PointOffsetType, level: usize) -> Vec<PointOffsetType> {
+        let mut links = Vec::new();
+        self.for_each_link(point_id, level, |link| links.push(link));
+        links
+    }
 }
 
 #[derive(Debug)]
@@ -377,12 +385,13 @@ impl GraphLinks for GraphLinksRam {
         self.header.point_count as usize
     }
 
-    fn links(
+    fn for_each_link(
         &self,
         point_id: PointOffsetType,
         level: usize,
-    ) -> impl Iterator<Item = PointOffsetType> {
-        self.view().links(point_id, level)
+        f: impl FnMut(PointOffsetType),
+    ) {
+        self.view().for_each_link(point_id, level, f)
     }
 
     fn point_level(&self, point_id: PointOffsetType) -> usize {
@@ -446,12 +455,13 @@ impl GraphLinks for GraphLinksMmap {
         self.header.point_count as usize
     }
 
-    fn links(
+    fn for_each_link(
         &self,
         point_id: PointOffsetType,
         level: usize,
-    ) -> impl Iterator<Item = PointOffsetType> {
-        self.view().links(point_id, level)
+        f: impl FnMut(PointOffsetType),
+    ) {
+        self.view().for_each_link(point_id, level, f)
     }
 
     fn point_level(&self, point_id: PointOffsetType) -> usize {
@@ -467,18 +477,21 @@ struct GraphLinksView<'a> {
 }
 
 impl<'a> GraphLinksView<'a> {
-    fn links(
+    fn for_each_link(
         &self,
         point_id: PointOffsetType,
         level: usize,
-    ) -> impl Iterator<Item = PointOffsetType> + 'a {
+        mut f: impl FnMut(PointOffsetType),
+    ) {
         let idx = if level == 0 {
             point_id as usize
         } else {
             self.level_offsets[level] as usize + self.reindex(point_id) as usize
         };
         let links_range = self.get_links_range(idx);
-        self.get_links(links_range).iter().copied()
+        for &link in self.get_links(links_range) {
+            f(link);
+        }
     }
 
     fn point_level(&self, point_id: PointOffsetType) -> usize {
@@ -544,7 +557,6 @@ impl<'a> GraphLinksView<'a> {
 
 #[cfg(test)]
 mod tests {
-    use itertools::Itertools as _;
     use rand::Rng;
     use tempfile::Builder;
 
@@ -557,7 +569,7 @@ mod tests {
             let mut layers = Vec::new();
             let num_levels = links.point_level(i as PointOffsetType) + 1;
             for level in 0..num_levels {
-                let links = links.links(i as PointOffsetType, level).collect_vec();
+                let links = links.links_vec(i as PointOffsetType, level);
                 layers.push(links);
             }
             result.push(layers);

commit df7a70bd939b84858dae1c57155c62810f8c7986
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Nov 27 21:37:17 2024 +0000

    Refactor `GraphLinksConverter` (#5491)
    
    * Introduce HEADER_SIZE = 64
    
    * GraphLinksConverter: rewrite
    
    * Split GraphLinksFileHeader into GraphLinksFileInfo

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index c37ec72ac..f39a7d653 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,13 +1,15 @@
-use std::cmp::max;
-use std::fs::OpenOptions;
-use std::io::Read as _;
+use std::cmp::Reverse;
+use std::fs::{File, OpenOptions};
+use std::io::{Read as _, Write};
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
 use common::types::PointOffsetType;
-use memmap2::{Mmap, MmapMut};
+use common::zeros::WriteZerosExt as _;
+use memmap2::Mmap;
 use memory::{madvise, mmap_ops};
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::vector_utils::TrySetCapacityExact;
@@ -46,92 +48,66 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
+const HEADER_SIZE: usize = 64;
+
 #[derive(Clone, Debug, Default)]
-struct GraphLinksFileHeader {
-    pub point_count: u64,
-    pub levels_count: u64,
-    pub total_links_len: u64,
-    pub total_offsets_len: u64,
-    pub offsets_padding: u64,
+struct GraphLinksFileInfo {
+    point_count: usize,
+    reindex_start: usize,
+    links_start: usize,
+    offsets_start: usize,
+    offsets_end: usize,
 }
 
-fn get_level_offsets<'a>(data: &'a [u8], header: &GraphLinksFileHeader) -> &'a [u64] {
-    let level_offsets_range = header.get_level_offsets_range();
-    let level_offsets_byte_slice = &data[level_offsets_range];
-    mmap_ops::transmute_from_u8_to_slice(level_offsets_byte_slice)
+#[derive(AsBytes, FromBytes, FromZeroes)]
+#[repr(C)]
+struct GraphLinksFileHeader {
+    point_count: u64,
+    levels_count: u64,
+    total_links_len: u64,
+    total_offsets_len: u64,
+    offsets_padding: u64, // 0 or 4
 }
 
-impl GraphLinksFileHeader {
-    pub fn new(
-        point_count: usize,
-        levels_count: usize,
-        total_links_len: usize,
-        total_offsets_len: usize,
-    ) -> GraphLinksFileHeader {
-        let offsets_padding = if (point_count + total_links_len) % 2 == 0 {
-            0
-        } else {
-            4
-        };
-        GraphLinksFileHeader {
-            point_count: point_count as u64,
-            levels_count: levels_count as u64,
-            total_links_len: total_links_len as u64,
-            total_offsets_len: total_offsets_len as u64,
-            offsets_padding,
-        }
-    }
-
-    pub fn raw_size() -> usize {
-        size_of::<u64>() * 5
-    }
-
-    pub fn serialize_bytes_to(&self, raw_data: &mut [u8]) {
-        let byte_slice = &mut raw_data[0..Self::raw_size()];
-        let arr: &mut [u64] = mmap_ops::transmute_from_u8_to_mut_slice(byte_slice);
-        arr[0] = self.point_count;
-        arr[1] = self.levels_count;
-        arr[2] = self.total_links_len;
-        arr[3] = self.total_offsets_len;
-        arr[4] = self.offsets_padding;
-    }
-
-    pub fn deserialize_bytes_from(raw_data: &[u8]) -> GraphLinksFileHeader {
-        let byte_slice = &raw_data[0..Self::raw_size()];
-        let arr: &[u64] = mmap_ops::transmute_from_u8_to_slice(byte_slice);
-        GraphLinksFileHeader {
-            point_count: arr[0],
-            levels_count: arr[1],
-            total_links_len: arr[2],
-            total_offsets_len: arr[3],
-            offsets_padding: arr[4],
-        }
+impl GraphLinksFileInfo {
+    pub fn load(data: &[u8]) -> Option<GraphLinksFileInfo> {
+        let header = GraphLinksFileHeader::ref_from_prefix(data)?;
+
+        let reindex_start = HEADER_SIZE + header.levels_count as usize * size_of::<u64>();
+        let links_start =
+            reindex_start + header.point_count as usize * size_of::<PointOffsetType>();
+        let offsets_start = links_start
+            + header.total_links_len as usize * size_of::<PointOffsetType>()
+            + header.offsets_padding as usize;
+        let offsets_end = offsets_start + header.total_offsets_len as usize * size_of::<u64>();
+
+        Some(GraphLinksFileInfo {
+            point_count: header.point_count as usize,
+            reindex_start,
+            links_start,
+            offsets_start,
+            offsets_end,
+        })
     }
 
-    pub fn get_data_size(&self) -> u64 {
-        self.get_offsets_range().end as u64
+    pub fn level_offsets(&self) -> Range<usize> {
+        HEADER_SIZE..self.reindex_start
     }
 
-    pub fn get_level_offsets_range(&self) -> Range<usize> {
-        // level offsets are stored after header
-        // but we might want to have some extra space for future changes
-        let start = max(64, Self::raw_size());
-        start..start + self.levels_count as usize * size_of::<u64>()
+    pub fn get_level_offsets<'a>(&self, data: &'a [u8]) -> &'a [u64] {
+        u64::slice_from(&data[self.level_offsets()]).unwrap()
     }
 
-    pub fn get_reindex_range(&self) -> Range<usize> {
-        let start = self.get_level_offsets_range().end;
-        start..start + self.point_count as usize * size_of::<PointOffsetType>()
+    pub fn reindex_range(&self) -> Range<usize> {
+        self.reindex_start..self.links_start
     }
 
-    pub fn get_links_range(&self) -> Range<usize> {
-        let start = self.get_reindex_range().end;
-        start..start + self.total_links_len as usize * size_of::<PointOffsetType>()
+    pub fn links_range(&self) -> Range<usize> {
+        self.links_start..self.offsets_start
     }
 
-    pub fn get_offsets_range(&self) -> Range<usize> {
-        let start = self.get_links_range().end + self.offsets_padding as usize;
-        start..start + self.total_offsets_len as usize * size_of::<u64>()
+    pub fn offsets_range(&self) -> Range<usize> {
+        self.offsets_start..self.offsets_end
     }
 }
 
@@ -142,6 +118,8 @@ pub struct GraphLinksConverter {
     total_links_len: usize,
     total_offsets_len: usize,
     path: Option<PathBuf>,
+    level_offsets: Vec<u64>,
+    point_count_by_level: Vec<u64>,
 }
 
 impl GraphLinksConverter {
@@ -154,14 +132,15 @@ impl GraphLinksConverter {
                 total_links_len: 0,
                 total_offsets_len: 1,
                 path: None,
+                level_offsets: Vec::new(),
+                point_count_by_level: Vec::new(),
             };
         }
 
         // create map from index in `offsets` to point_id
         let mut back_index: Vec<usize> = (0..edges.len()).collect();
         // sort by max layer and use this map to build `Self.reindex`
-        back_index.sort_unstable_by_key(|&i| edges[i].len());
-        back_index.reverse();
+        back_index.sort_unstable_by_key(|&i| Reverse(edges[i].len()));
 
         // `reindex` is map from point id to index in `Self.offsets`
         let mut reindex = vec![0; back_index.len()];
@@ -169,141 +148,125 @@ impl GraphLinksConverter {
             reindex[back_index[i]] = i as PointOffsetType;
         }
 
+        let levels_count = back_index
+            .first()
+            .map_or(0, |&point_id| edges[point_id].len());
+        let mut point_count_by_level = vec![0; levels_count];
+
         // estimate size of `links` and `offsets`
         let mut total_links_len = 0;
-        let mut total_offsets_len = 1;
         for point in edges.iter() {
-            for layer in point.iter() {
-                total_links_len += layer.len();
-                total_offsets_len += 1;
-            }
+            point_count_by_level[point.len() - 1] += 1;
+            total_links_len += point.iter().map(Vec::len).sum::<usize>();
+        }
+
+        let mut total_offsets_len = 0;
+        let mut suffix_sum = point_count_by_level.iter().sum::<u64>();
+        let mut level_offsets = Vec::with_capacity(levels_count);
+        for &value in point_count_by_level.iter() {
+            level_offsets.push(total_offsets_len);
+            total_offsets_len += suffix_sum;
+            suffix_sum -= value;
         }
+        total_offsets_len += 1;
 
         Self {
             edges,
             reindex,
             back_index,
             total_links_len,
-            total_offsets_len,
+            total_offsets_len: total_offsets_len as usize,
             path: None,
+            level_offsets,
+            point_count_by_level,
         }
     }
 
-    fn get_header(&self) -> GraphLinksFileHeader {
-        GraphLinksFileHeader::new(
-            self.reindex.len(),
-            self.get_levels_count(),
-            self.total_links_len,
-            self.total_offsets_len,
-        )
-    }
-
     /// Size of compacted graph in bytes.
-    pub fn data_size(&self) -> u64 {
-        self.get_header().get_data_size()
-    }
+    pub fn data_size(&self) -> usize {
+        HEADER_SIZE
+            + self.point_count_by_level.len() * size_of::<u64>()
+            + self.reindex.len() * size_of::<PointOffsetType>()
+            + self.total_links_len * size_of::<PointOffsetType>()
+            + self.offsets_padding()
+            + self.total_offsets_len * size_of::<u64>()
+    }
+
+    fn offsets_padding(&self) -> usize {
+        (self.total_links_len + self.reindex.len()) % 2 * size_of::<u32>()
+    }
+
+    fn serialize_to_vec(&self) -> Vec<u8> {
+        let size = self.data_size();
+        let mut data = Vec::with_capacity(size);
+        // Unwrap should be the safe as `impl Write` for `Vec` never fails.
+        self.serialize_to_writer(&mut data).unwrap();
+        debug_assert_eq!(data.len(), size);
+        data
+    }
+
+    fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
+        let header = GraphLinksFileHeader {
+            point_count: self.reindex.len() as u64,
+            levels_count: self.point_count_by_level.len() as u64,
+            total_links_len: self.total_links_len as u64,
+            total_offsets_len: self.total_offsets_len as u64,
+            offsets_padding: self.offsets_padding() as u64,
+        };
 
-    pub fn serialize_to(&self, bytes_data: &mut [u8]) {
-        let header = self.get_header();
+        // 1. header
+        writer.write_all(header.as_bytes())?;
 
-        header.serialize_bytes_to(bytes_data);
+        // 2. header padding
+        writer.write_zeros(HEADER_SIZE - size_of::<GraphLinksFileHeader>())?;
 
-        {
-            let reindex_range = header.get_reindex_range();
-            let reindex_byte_slice = &mut bytes_data[reindex_range];
-            let reindex_slice: &mut [PointOffsetType] =
-                mmap_ops::transmute_from_u8_to_mut_slice(reindex_byte_slice);
-            reindex_slice.copy_from_slice(&self.reindex);
-        }
+        // 3. level_offsets
+        writer.write_all(self.level_offsets.as_bytes())?;
 
-        let header_levels_count = header.levels_count as usize;
-        let mut level_offsets = Vec::with_capacity(header_levels_count);
-        {
-            let links_range = header.get_links_range();
-            let offsets_range = header.get_offsets_range();
-            let union_range = links_range.start..offsets_range.end;
-            let (links_mmap, offsets_with_padding_mmap) = bytes_data[union_range]
-                .as_mut()
-                .split_at_mut(links_range.len());
-            let offsets_mmap = &mut offsets_with_padding_mmap[header.offsets_padding as _..];
-            let links_mmap: &mut [PointOffsetType] =
-                mmap_ops::transmute_from_u8_to_mut_slice(links_mmap);
-            let offsets_mmap: &mut [u64] = mmap_ops::transmute_from_u8_to_mut_slice(offsets_mmap);
-            offsets_mmap[0] = 0;
-
-            let mut links_pos = 0;
-            let mut offsets_pos = 1;
-            for level in 0..header_levels_count {
-                level_offsets.push(offsets_pos as u64 - 1);
-                self.iterate_level_points(level, |_, links| {
-                    links_mmap[links_pos..links_pos + links.len()].copy_from_slice(links);
-                    links_pos += links.len();
-
-                    offsets_mmap[offsets_pos] = links_pos as u64;
-                    offsets_pos += 1;
-                });
+        // 4. reindex
+        writer.write_all(self.reindex.as_bytes())?;
+
+        let mut offsets = Vec::with_capacity(header.total_offsets_len as usize);
+        offsets.push(0);
+
+        // 5. links
+        let mut links_pos = 0;
+        let mut write_links = |links: &[PointOffsetType]| {
+            writer.write_all(links.as_bytes())?;
+            links_pos += links.len();
+            offsets.push(links_pos as u64);
+            std::io::Result::Ok(())
+        };
+        for point in &self.edges {
+            write_links(&point[0])?;
+        }
+        for level in 1..header.levels_count as usize {
+            let count = self.point_count_by_level.iter().skip(level).sum::<u64>() as usize;
+            for i in 0..count {
+                write_links(&self.edges[self.back_index[i]][level])?;
             }
         }
 
-        {
-            let level_offsets_range = header.get_level_offsets_range();
-            let level_offsets_byte_slice = &mut bytes_data[level_offsets_range];
-            let level_offsets_slice: &mut [u64] =
-                mmap_ops::transmute_from_u8_to_mut_slice(level_offsets_byte_slice);
-            level_offsets_slice.copy_from_slice(&level_offsets);
-        }
+        debug_assert_eq!(links_pos, self.total_links_len);
+
+        // 6. padding for offsets
+        writer.write_zeros(self.offsets_padding())?;
+
+        // 7. offsets
+        writer.write_all(offsets.as_bytes())?;
+
+        Ok(())
     }
 
     pub fn save_as(&mut self, path: &Path) -> OperationResult<()> {
         self.path = Some(path.to_path_buf());
         let temp_path = path.with_extension("tmp");
-        {
-            let file = OpenOptions::new()
-                .read(true)
-                .write(true)
-                .create(true)
-                // Don't truncate because we explicitly set the length later
-                .truncate(false)
-                .open(temp_path.as_path())?;
-            file.set_len(self.data_size())?;
-
-            let m = unsafe { MmapMut::map_mut(&file) };
-            let mut mmap = m?;
-
-            self.serialize_to(&mut mmap);
-
-            mmap.flush()?;
-        }
+        let file = File::create(temp_path.as_path())?;
+        let mut buf = std::io::BufWriter::new(file);
+        self.serialize_to_writer(&mut buf)?;
         std::fs::rename(temp_path, path)?;
-
         Ok(())
     }
-
-    pub fn get_levels_count(&self) -> usize {
-        if self.back_index.is_empty() {
-            return 0;
-        }
-        // because back_index is sorted by point`s max layer, we can retrieve max level from `point_id = back_index[0]`
-        self.edges[self.back_index[0]].len()
-    }
-
-    pub fn iterate_level_points<F>(&self, level: usize, mut f: F)
-    where
-        F: FnMut(usize, &Vec<PointOffsetType>),
-    {
-        let edges_len = self.edges.len();
-        if level == 0 {
-            (0..edges_len).for_each(|point_id| f(point_id, &self.edges[point_id][0]));
-        } else {
-            for i in 0..edges_len {
-                let point_id = self.back_index[i];
-                if level >= self.edges[point_id].len() {
-                    break;
-                }
-                f(point_id, &self.edges[point_id][level]);
-            }
-        }
-    }
 }
 
 pub trait GraphLinks: Sized {
@@ -333,17 +296,17 @@ pub trait GraphLinks: Sized {
 #[derive(Debug)]
 pub struct GraphLinksRam {
     data: Vec<u8>,
-    header: GraphLinksFileHeader,
+    info: GraphLinksFileInfo,
     level_offsets: Vec<u64>,
 }
 
 impl GraphLinksRam {
     fn from_bytes(data: Vec<u8>) -> Self {
-        let header = GraphLinksFileHeader::deserialize_bytes_from(&data);
-        let level_offsets = get_level_offsets(&data, &header).to_vec();
+        let info = GraphLinksFileInfo::load(&data).unwrap();
+        let level_offsets = info.get_level_offsets(&data).to_vec();
         Self {
             data,
-            header,
+            info,
             level_offsets,
         }
     }
@@ -351,7 +314,7 @@ impl GraphLinksRam {
     fn view(&self) -> GraphLinksView {
         GraphLinksView {
             data: &self.data,
-            header: &self.header,
+            info: &self.info,
             level_offsets: &self.level_offsets,
         }
     }
@@ -374,15 +337,11 @@ impl GraphLinks for GraphLinksRam {
     }
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
-        let mut data = vec![0; converter.data_size() as usize];
-        converter.serialize_to(&mut data);
-        drop(converter);
-
-        Ok(Self::from_bytes(data))
+        Ok(Self::from_bytes(converter.serialize_to_vec()))
     }
 
     fn num_points(&self) -> usize {
-        self.header.point_count as usize
+        self.info.point_count
     }
 
     fn for_each_link(
@@ -402,7 +361,7 @@ impl GraphLinks for GraphLinksRam {
 #[derive(Debug)]
 pub struct GraphLinksMmap {
     mmap: Arc<Mmap>,
-    header: GraphLinksFileHeader,
+    info: GraphLinksFileInfo,
     level_offsets: Vec<u64>,
 }
 
@@ -414,7 +373,7 @@ impl GraphLinksMmap {
     fn view(&self) -> GraphLinksView {
         GraphLinksView {
             data: &self.mmap,
-            header: &self.header,
+            info: &self.info,
             level_offsets: &self.level_offsets,
         }
     }
@@ -431,12 +390,12 @@ impl GraphLinks for GraphLinksMmap {
         let mmap = unsafe { Mmap::map(&file)? };
         madvise::madvise(&mmap, madvise::get_global())?;
 
-        let header = GraphLinksFileHeader::deserialize_bytes_from(&mmap);
-        let level_offsets = get_level_offsets(&mmap, &header).to_vec();
+        let info = GraphLinksFileInfo::load(&mmap).unwrap();
+        let level_offsets = info.get_level_offsets(&mmap).to_vec();
 
         Ok(Self {
             mmap: Arc::new(mmap),
-            header,
+            info,
             level_offsets,
         })
     }
@@ -452,7 +411,7 @@ impl GraphLinks for GraphLinksMmap {
     }
 
     fn num_points(&self) -> usize {
-        self.header.point_count as usize
+        self.info.point_count
     }
 
     fn for_each_link(
@@ -472,7 +431,7 @@ impl GraphLinks for GraphLinksMmap {
 #[derive(Debug)]
 struct GraphLinksView<'a> {
     data: &'a [u8],
-    header: &'a GraphLinksFileHeader,
+    info: &'a GraphLinksFileInfo,
     level_offsets: &'a [u64],
 }
 
@@ -519,7 +478,7 @@ impl<'a> GraphLinksView<'a> {
                 self.level_offsets[level + 1] as usize
             } else {
                 // `level` is last, next `offsets.len()` is end of range
-                self.header.get_offsets_range().len() / size_of::<u64>() - 1
+                self.info.offsets_range().len() / size_of::<u64>() - 1
             };
             Some(layer_offsets_start..layer_offsets_end)
         } else {
@@ -527,31 +486,22 @@ impl<'a> GraphLinksView<'a> {
         }
     }
 
-    fn get_links_offset(offsets_data: &[u8], idx: usize) -> usize {
-        let begin = size_of::<u64>() * idx;
-        let end = begin + size_of::<u64>();
-        let bytes = &offsets_data[begin..end];
-        // unwrap is safe because we know that bytes slice is always 8 bytes
-        let bytes: [u8; 8] = bytes.try_into().unwrap();
-        u64::from_ne_bytes(bytes) as usize
-    }
-
     fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let offsets_range = self.header.get_offsets_range();
-        let data: &[u8] = &self.data[offsets_range];
-        Self::get_links_offset(data, idx)..Self::get_links_offset(data, idx + 1)
+        let offsets = u64::slice_from(&self.data[self.info.offsets_range()]).unwrap();
+        offsets[idx] as usize..offsets[idx + 1] as usize
     }
 
     fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
-        let reindex_range = self.header.get_reindex_range();
-        let reindex_byte_slice = &self.data[reindex_range];
-        mmap_ops::transmute_from_u8_to_slice(reindex_byte_slice)[point_id as usize]
+        let idx = &self.data[self.info.reindex_range()];
+        PointOffsetType::slice_from(idx).unwrap()[point_id as usize]
     }
 
     fn get_links(&self, range: Range<usize>) -> &'a [PointOffsetType] {
-        let links_range = self.header.get_links_range();
-        let links_byte_slice = &self.data[links_range];
-        &mmap_ops::transmute_from_u8_to_slice(links_byte_slice)[range]
+        let idx = &self.data[self.info.links_range()];
+        PointOffsetType::slice_from(idx)
+            .unwrap()
+            .get(range)
+            .unwrap()
     }
 }
 

commit 4abd77158aa514efb6284b1668e8f02a7b9418f1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Dec 10 00:13:03 2024 +0100

    use fsync instead of flush (#5629)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index f39a7d653..b15ac504a 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -262,8 +262,9 @@ impl GraphLinksConverter {
         self.path = Some(path.to_path_buf());
         let temp_path = path.with_extension("tmp");
         let file = File::create(temp_path.as_path())?;
-        let mut buf = std::io::BufWriter::new(file);
+        let mut buf = std::io::BufWriter::new(&file);
         self.serialize_to_writer(&mut buf)?;
+        file.sync_all()?;
         std::fs::rename(temp_path, path)?;
         Ok(())
     }

commit f8f9af04474321e6c7b4fc4a292766021c5078d6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Dec 10 00:23:44 2024 +0000

    GraphLinksConverter: take `m` and `compressed` arguments (#5489)
    
    * GraphLinksConverter: take `m` and `compressed` arguments
    
    * Add m0 parameter
    
    * Fixup
    
    * LinkCompressionExperimentalSetting

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index b15ac504a..13ccceb55 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -123,7 +123,12 @@ pub struct GraphLinksConverter {
 }
 
 impl GraphLinksConverter {
-    pub fn new(edges: Vec<Vec<Vec<PointOffsetType>>>) -> Self {
+    pub fn new(
+        edges: Vec<Vec<Vec<PointOffsetType>>>,
+        _compressed: bool,
+        _m: usize,
+        _m0: usize,
+    ) -> Self {
         if edges.is_empty() {
             return Self {
                 edges,
@@ -506,9 +511,19 @@ impl<'a> GraphLinksView<'a> {
     }
 }
 
+/// Sort the first `m` values in `links` and return them. Used to compare stored
+/// links where the order of the first `m` links is not preserved.
+#[cfg(test)]
+pub(super) fn normalize_links(m: usize, mut links: Vec<PointOffsetType>) -> Vec<PointOffsetType> {
+    let first = links.len().min(m);
+    links[..first].sort_unstable();
+    links
+}
+
 #[cfg(test)]
 mod tests {
     use rand::Rng;
+    use rstest::rstest;
     use tempfile::Builder;
 
     use super::*;
@@ -531,14 +546,18 @@ mod tests {
     fn random_links(
         points_count: usize,
         max_levels_count: usize,
+        m: usize,
+        m0: usize,
     ) -> Vec<Vec<Vec<PointOffsetType>>> {
         let mut rng = rand::thread_rng();
         (0..points_count)
             .map(|_| {
                 let levels_count = rng.gen_range(1..max_levels_count);
                 (0..levels_count)
-                    .map(|_| {
-                        let links_count = rng.gen_range(0..max_levels_count);
+                    .map(|level| {
+                        let mut max_links_count = if level == 0 { m0 } else { m };
+                        max_links_count *= 2; // Simulate additional payload links.
+                        let links_count = rng.gen_range(0..max_links_count);
                         (0..links_count)
                             .map(|_| rng.gen_range(0..points_count) as PointOffsetType)
                             .collect()
@@ -548,44 +567,94 @@ mod tests {
             .collect()
     }
 
+    fn compare_links(
+        mut left: Vec<Vec<Vec<PointOffsetType>>>,
+        mut right: Vec<Vec<Vec<PointOffsetType>>>,
+        compressed: bool,
+        m: usize,
+        m0: usize,
+    ) {
+        for links in [&mut left, &mut right].iter_mut() {
+            links.iter_mut().for_each(|levels| {
+                levels
+                    .iter_mut()
+                    .enumerate()
+                    .for_each(|(level_idx, links)| {
+                        *links = normalize_links(
+                            if compressed {
+                                if level_idx == 0 {
+                                    m0
+                                } else {
+                                    m
+                                }
+                            } else {
+                                0
+                            },
+                            std::mem::take(links),
+                        );
+                    })
+            });
+        }
+        assert_eq!(left, right);
+    }
+
     /// Test that random links can be saved by `GraphLinksConverter` and loaded correctly by a GraphLinks impl.
-    fn test_save_load<A>(points_count: usize, max_levels_count: usize)
-    where
+    fn test_save_load<A>(
+        points_count: usize,
+        max_levels_count: usize,
+        compressed: bool,
+        m: usize,
+        m0: usize,
+    ) where
         A: GraphLinks,
     {
         let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
         let links_file = path.path().join("links.bin");
-        let links = random_links(points_count, max_levels_count);
+        let links = random_links(points_count, max_levels_count, m, m0);
         {
-            let mut links_converter = GraphLinksConverter::new(links.clone());
+            let mut links_converter = GraphLinksConverter::new(links.clone(), compressed, m, m0);
             links_converter.save_as(&links_file).unwrap();
         }
         let cmp_links = to_vec(&A::load_from_file(&links_file).unwrap());
-        assert_eq!(links, cmp_links);
-    }
+        compare_links(links, cmp_links, compressed, m, m0);
+    }
+
+    #[rstest]
+    #[case::uncompressed(false)]
+    #[case::compressed(true)]
+    fn test_graph_links_construction(#[case] compressed: bool) {
+        let m = 2;
+        let m0 = m * 2;
+
+        let make_cmp_links = |links: Vec<Vec<Vec<PointOffsetType>>>,
+                              m: usize,
+                              m0: usize|
+         -> Vec<Vec<Vec<PointOffsetType>>> {
+            to_vec(
+                &GraphLinksRam::from_converter(GraphLinksConverter::new(
+                    links.clone(),
+                    compressed,
+                    m,
+                    m0,
+                ))
+                .unwrap(),
+            )
+        };
 
-    #[test]
-    fn test_graph_links_construction() {
         // no points
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // 2 points without any links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![]], vec![vec![]]];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // one link at level 0
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![1]], vec![vec![0]]];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // 3 levels with no links at second level
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -593,10 +662,8 @@ mod tests {
             vec![vec![0, 2], vec![], vec![2]],
             vec![vec![0, 1], vec![], vec![1]],
         ];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // 3 levels with no links at last level
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -604,10 +671,8 @@ mod tests {
             vec![vec![0, 2], vec![1], vec![]],
             vec![vec![0, 1]],
         ];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // 4 levels with random nonexistent links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -617,22 +682,24 @@ mod tests {
             vec![vec![0, 1, 5, 6], vec![1, 5, 0]],
             vec![vec![0, 1, 9, 18], vec![1, 5, 6], vec![5], vec![9]],
         ];
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
 
         // fully random links
-        let links = random_links(100, 10);
-        let cmp_links = to_vec(
-            &GraphLinksRam::from_converter(GraphLinksConverter::new(links.clone())).unwrap(),
-        );
-        assert_eq!(links, cmp_links);
+        let m = 8;
+        let m0 = m * 2;
+        let links = random_links(100, 10, m, m0);
+        let cmp_links = make_cmp_links(links.clone(), m, m0);
+        compare_links(links, cmp_links, compressed, m, m0);
     }
 
     #[test]
     fn test_graph_links_mmap_ram_compatibility() {
-        test_save_load::<GraphLinksRam>(1000, 10);
-        test_save_load::<GraphLinksMmap>(1000, 10);
+        let m = 8;
+        let m0 = m * 2;
+        test_save_load::<GraphLinksRam>(1000, 10, true, m, m0);
+        test_save_load::<GraphLinksMmap>(1000, 10, true, m, m0);
+        test_save_load::<GraphLinksRam>(1000, 10, false, m, m0);
+        test_save_load::<GraphLinksMmap>(1000, 10, false, m, m0);
     }
 }

commit f0a7d13ab027f4a0f4fc8bf2ef751337c0207c21
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Dec 14 22:09:33 2024 +0000

    zerocopy: 0.7 -> 0.8 (#5639)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 13ccceb55..ebd65d56d 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -9,7 +9,7 @@ use common::types::PointOffsetType;
 use common::zeros::WriteZerosExt as _;
 use memmap2::Mmap;
 use memory::{madvise, mmap_ops};
-use zerocopy::{AsBytes, FromBytes, FromZeroes};
+use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
 
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::vector_utils::TrySetCapacityExact;
@@ -59,7 +59,7 @@ struct GraphLinksFileInfo {
     offsets_end: usize,
 }
 
-#[derive(AsBytes, FromBytes, FromZeroes)]
+#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
 #[repr(C)]
 struct GraphLinksFileHeader {
     point_count: u64,
@@ -71,7 +71,7 @@ struct GraphLinksFileHeader {
 
 impl GraphLinksFileInfo {
     pub fn load(data: &[u8]) -> Option<GraphLinksFileInfo> {
-        let header = GraphLinksFileHeader::ref_from_prefix(data)?;
+        let (header, _) = GraphLinksFileHeader::ref_from_prefix(data).ok()?;
 
         let reindex_start = HEADER_SIZE + header.levels_count as usize * size_of::<u64>();
         let links_start =
@@ -95,7 +95,7 @@ impl GraphLinksFileInfo {
     }
 
     pub fn get_level_offsets<'a>(&self, data: &'a [u8]) -> &'a [u64] {
-        u64::slice_from(&data[self.level_offsets()]).unwrap()
+        <[u64]>::ref_from_bytes(&data[self.level_offsets()]).unwrap()
     }
 
     pub fn reindex_range(&self) -> Range<usize> {
@@ -493,18 +493,18 @@ impl<'a> GraphLinksView<'a> {
     }
 
     fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let offsets = u64::slice_from(&self.data[self.info.offsets_range()]).unwrap();
+        let offsets = <[u64]>::ref_from_bytes(&self.data[self.info.offsets_range()]).unwrap();
         offsets[idx] as usize..offsets[idx + 1] as usize
     }
 
     fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
         let idx = &self.data[self.info.reindex_range()];
-        PointOffsetType::slice_from(idx).unwrap()[point_id as usize]
+        <[PointOffsetType]>::ref_from_bytes(idx).unwrap()[point_id as usize]
     }
 
     fn get_links(&self, range: Range<usize>) -> &'a [PointOffsetType] {
         let idx = &self.data[self.info.links_range()];
-        PointOffsetType::slice_from(idx)
+        <[PointOffsetType]>::ref_from_bytes(idx)
             .unwrap()
             .get(range)
             .unwrap()

commit 5c072a2d2609c595e4bb60b50964b62bf79f6c03
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Dec 18 11:29:34 2024 +0000

    Implement links compression (#5492)
    
    * common::bitpacking::packed_bits
    
    * BitWriter::new(): append, don't clear the buffer
    
    * common::bitpacking_links
    
    * Implement links compression
    
    * Update

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index ebd65d56d..cd57d279b 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,14 +1,19 @@
 use std::cmp::Reverse;
 use std::fs::{File, OpenOptions};
 use std::io::{Read as _, Write};
+use std::mem::take;
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use common::bitpacking::packed_bits;
+use common::bitpacking_links::{for_each_packed_link, pack_links, MIN_BITS_PER_VALUE};
 use common::types::PointOffsetType;
 use common::zeros::WriteZerosExt as _;
+use itertools::Either;
 use memmap2::Mmap;
 use memory::{madvise, mmap_ops};
+use zerocopy::little_endian::U64;
 use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
 
 use crate::common::operation_error::{OperationError, OperationResult};
@@ -50,44 +55,127 @@ links offset = level_offsets[level] + offsets[reindex[point_id]]
 
 const HEADER_SIZE: usize = 64;
 
-#[derive(Clone, Debug, Default)]
+#[derive(Clone, Debug)]
 struct GraphLinksFileInfo {
     point_count: usize,
     reindex_start: usize,
     links_start: usize,
     offsets_start: usize,
     offsets_end: usize,
+    compression: Option<CompressionInfo>,
 }
 
+#[derive(Clone, Debug)]
+struct CompressionInfo {
+    m: usize,
+    m0: usize,
+    bits_per_unsorted: u8,
+}
+
+/// File header for the plain format.
 #[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
 #[repr(C)]
-struct GraphLinksFileHeader {
+struct HeaderPlain {
     point_count: u64,
     levels_count: u64,
-    total_links_len: u64,
-    total_offsets_len: u64,
-    offsets_padding: u64, // 0 or 4
+    total_links_count: u64,
+    total_offset_count: u64,
+    /// Either 0 or 4.
+    offsets_padding_bytes: u64,
+    zero_padding: [u8; 24],
 }
 
+/// File header for the compressed format.
+#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
+#[repr(C)]
+struct HeaderCompressed {
+    point_count: U64,
+    /// Should be [`HEADER_VERSION_COMPRESSED`].
+    ///
+    /// Deliberately placed at the same offset as [`HeaderPlain::levels_count`]
+    /// and set to an impossibly large number to make old Qdrant versions fail
+    /// fast when trying to read the new format.
+    version: U64,
+    levels_count: U64,
+    total_links_bytes: U64,
+    total_offset_count: U64,
+    m: U64,
+    m0: U64,
+    zero_padding: [u8; 8],
+}
+
+const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;
+
 impl GraphLinksFileInfo {
-    pub fn load(data: &[u8]) -> Option<GraphLinksFileInfo> {
-        let (header, _) = GraphLinksFileHeader::ref_from_prefix(data).ok()?;
-
-        let reindex_start = HEADER_SIZE + header.levels_count as usize * size_of::<u64>();
-        let links_start =
-            reindex_start + header.point_count as usize * size_of::<PointOffsetType>();
-        let offsets_start = links_start
-            + header.total_links_len as usize * size_of::<PointOffsetType>()
-            + header.offsets_padding as usize;
-        let offsets_end = offsets_start + header.total_offsets_len as usize * size_of::<u64>();
-
-        Some(GraphLinksFileInfo {
-            point_count: header.point_count as usize,
-            reindex_start,
-            links_start,
-            offsets_start,
-            offsets_end,
-        })
+    pub fn load(data: &[u8]) -> OperationResult<GraphLinksFileInfo> {
+        let levels_count_or_version = data
+            .get(size_of::<u64>()..)
+            .and_then(|x| U64::ref_from_prefix(x).ok())
+            .ok_or_else(Self::error_unsufficent_size)?
+            .0
+            .get();
+
+        // Header for the plain format lacks the version field, but we can be
+        // sure that it contains no more than 2^32 levels.
+        let is_plain = u64::from_le(levels_count_or_version) <= 1 << 32;
+
+        match levels_count_or_version {
+            _ if is_plain => {
+                let (header, _) = HeaderPlain::ref_from_prefix(data)
+                    .map_err(|_| Self::error_unsufficent_size())?;
+                let reindex_start = HEADER_SIZE + header.levels_count as usize * size_of::<u64>();
+                let links_start =
+                    reindex_start + header.point_count as usize * size_of::<PointOffsetType>();
+                let offsets_start = links_start
+                    + header.total_links_count as usize * size_of::<PointOffsetType>()
+                    + header.offsets_padding_bytes as usize;
+                Ok(GraphLinksFileInfo {
+                    point_count: header.point_count as usize,
+                    reindex_start,
+                    links_start,
+                    offsets_start,
+                    offsets_end: offsets_start
+                        + header.total_offset_count as usize * size_of::<u64>(),
+                    compression: None,
+                })
+            }
+            HEADER_VERSION_COMPRESSED => {
+                let (header, _) = HeaderCompressed::ref_from_prefix(data)
+                    .map_err(|_| Self::error_unsufficent_size())?;
+                debug_assert_eq!(header.version.get(), HEADER_VERSION_COMPRESSED);
+                let point_count = header.point_count.get() as usize;
+                let reindex_start =
+                    HEADER_SIZE + header.levels_count.get() as usize * size_of::<u64>();
+                let links_start = reindex_start
+                    + header.point_count.get() as usize * size_of::<PointOffsetType>();
+                let offsets_start = (links_start + header.total_links_bytes.get() as usize)
+                    .next_multiple_of(size_of::<u64>());
+                Ok(GraphLinksFileInfo {
+                    point_count,
+                    reindex_start,
+                    links_start,
+                    offsets_start,
+                    offsets_end: offsets_start
+                        + header.total_offset_count.get() as usize * size_of::<u64>(),
+                    compression: Some(CompressionInfo {
+                        m: header.m.get() as usize,
+                        m0: header.m0.get() as usize,
+                        bits_per_unsorted: MIN_BITS_PER_VALUE.max(packed_bits(
+                            u32::try_from(point_count.saturating_sub(1)).map_err(|_| {
+                                OperationError::service_error("Too many points in GraphLinks file")
+                            })?,
+                        )),
+                    }),
+                })
+            }
+            _ => Err(OperationError::service_error(
+                "Unsupported version of GraphLinks file",
+            )),
+        }
+    }
+
+    fn error_unsufficent_size() -> OperationError {
+        OperationError::service_error("Unsufficent file size for GraphLinks file")
     }
 
     pub fn level_offsets(&self) -> Range<usize> {
@@ -112,36 +200,24 @@ impl GraphLinksFileInfo {
 }
 
 pub struct GraphLinksConverter {
-    edges: Vec<Vec<Vec<PointOffsetType>>>,
+    compressed: bool,
+    m: usize,
+    m0: usize,
+    links: Vec<u8>,
+    offsets: Vec<u64>,
     reindex: Vec<PointOffsetType>,
-    back_index: Vec<usize>,
-    total_links_len: usize,
-    total_offsets_len: usize,
     path: Option<PathBuf>,
     level_offsets: Vec<u64>,
-    point_count_by_level: Vec<u64>,
+    offsets_padding: usize,
 }
 
 impl GraphLinksConverter {
     pub fn new(
-        edges: Vec<Vec<Vec<PointOffsetType>>>,
-        _compressed: bool,
-        _m: usize,
-        _m0: usize,
+        mut edges: Vec<Vec<Vec<PointOffsetType>>>,
+        compressed: bool,
+        m: usize,
+        m0: usize,
     ) -> Self {
-        if edges.is_empty() {
-            return Self {
-                edges,
-                reindex: Vec::new(),
-                back_index: Vec::new(),
-                total_links_len: 0,
-                total_offsets_len: 1,
-                path: None,
-                level_offsets: Vec::new(),
-                point_count_by_level: Vec::new(),
-            };
-        }
-
         // create map from index in `offsets` to point_id
         let mut back_index: Vec<usize> = (0..edges.len()).collect();
         // sort by max layer and use this map to build `Self.reindex`
@@ -157,17 +233,13 @@ impl GraphLinksConverter {
             .first()
             .map_or(0, |&point_id| edges[point_id].len());
         let mut point_count_by_level = vec![0; levels_count];
-
-        // estimate size of `links` and `offsets`
-        let mut total_links_len = 0;
-        for point in edges.iter() {
+        for point in &edges {
             point_count_by_level[point.len() - 1] += 1;
-            total_links_len += point.iter().map(Vec::len).sum::<usize>();
         }
 
         let mut total_offsets_len = 0;
-        let mut suffix_sum = point_count_by_level.iter().sum::<u64>();
         let mut level_offsets = Vec::with_capacity(levels_count);
+        let mut suffix_sum = point_count_by_level.iter().sum::<u64>();
         for &value in point_count_by_level.iter() {
             level_offsets.push(total_offsets_len);
             total_offsets_len += suffix_sum;
@@ -175,90 +247,96 @@ impl GraphLinksConverter {
         }
         total_offsets_len += 1;
 
+        let mut links = Vec::new();
+        let mut offsets = Vec::with_capacity(total_offsets_len as usize);
+        offsets.push(0);
+        let bits_per_unsorted = packed_bits(u32::try_from(edges.len().saturating_sub(1)).unwrap())
+            .max(MIN_BITS_PER_VALUE);
+
+        for level in 0..levels_count {
+            let count = point_count_by_level.iter().skip(level).sum::<u64>() as usize;
+            let (sorted_count, iter) = match level {
+                0 => (m0, Either::Left(0..count)),
+                _ => (m, Either::Right(back_index[..count].iter().copied())),
+            };
+            iter.for_each(|id| {
+                let raw_links = take(&mut edges[id][level]);
+                if compressed {
+                    pack_links(&mut links, raw_links, bits_per_unsorted, sorted_count);
+                    offsets.push(links.len() as u64);
+                } else {
+                    links.extend_from_slice(raw_links.as_bytes());
+                    offsets.push((links.len() as u64) / size_of::<PointOffsetType>() as u64);
+                }
+            });
+        }
+
+        let offsets_padding = {
+            let len = links.len() + reindex.as_bytes().len();
+            len.next_multiple_of(size_of::<u64>()) - len
+        };
+
         Self {
-            edges,
+            compressed,
+            m,
+            m0,
+            links,
+            offsets,
             reindex,
-            back_index,
-            total_links_len,
-            total_offsets_len: total_offsets_len as usize,
             path: None,
             level_offsets,
-            point_count_by_level,
+            offsets_padding,
         }
     }
 
     /// Size of compacted graph in bytes.
-    pub fn data_size(&self) -> usize {
+    fn data_size(&self) -> usize {
         HEADER_SIZE
-            + self.point_count_by_level.len() * size_of::<u64>()
-            + self.reindex.len() * size_of::<PointOffsetType>()
-            + self.total_links_len * size_of::<PointOffsetType>()
-            + self.offsets_padding()
-            + self.total_offsets_len * size_of::<u64>()
-    }
-
-    fn offsets_padding(&self) -> usize {
-        (self.total_links_len + self.reindex.len()) % 2 * size_of::<u32>()
+            + self.level_offsets.as_bytes().len()
+            + self.reindex.as_bytes().len()
+            + self.links.len()
+            + self.offsets_padding
+            + self.offsets.as_bytes().len()
     }
 
     fn serialize_to_vec(&self) -> Vec<u8> {
-        let size = self.data_size();
-        let mut data = Vec::with_capacity(size);
+        let mut data = Vec::with_capacity(self.data_size());
         // Unwrap should be the safe as `impl Write` for `Vec` never fails.
         self.serialize_to_writer(&mut data).unwrap();
-        debug_assert_eq!(data.len(), size);
+        debug_assert_eq!(data.len(), self.data_size());
         data
     }
 
     fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
-        let header = GraphLinksFileHeader {
-            point_count: self.reindex.len() as u64,
-            levels_count: self.point_count_by_level.len() as u64,
-            total_links_len: self.total_links_len as u64,
-            total_offsets_len: self.total_offsets_len as u64,
-            offsets_padding: self.offsets_padding() as u64,
-        };
-
-        // 1. header
-        writer.write_all(header.as_bytes())?;
-
-        // 2. header padding
-        writer.write_zeros(HEADER_SIZE - size_of::<GraphLinksFileHeader>())?;
+        if self.compressed {
+            let header = HeaderCompressed {
+                version: HEADER_VERSION_COMPRESSED.into(),
+                point_count: U64::new(self.reindex.len() as u64),
+                total_links_bytes: U64::new(self.links.len() as u64),
+                total_offset_count: U64::new(self.offsets.len() as u64),
+                levels_count: U64::new(self.level_offsets.len() as u64),
+                m: U64::new(self.m as u64),
+                m0: U64::new(self.m0 as u64),
+                zero_padding: [0; 8],
+            };
+            writer.write_all(header.as_bytes())?;
+        } else {
+            let header = HeaderPlain {
+                point_count: self.reindex.len() as u64,
+                levels_count: self.level_offsets.len() as u64,
+                total_links_count: self.links.len() as u64 / size_of::<PointOffsetType>() as u64,
+                total_offset_count: self.offsets.len() as u64,
+                offsets_padding_bytes: self.offsets_padding as u64,
+                zero_padding: [0; 24],
+            };
+            writer.write_all(header.as_bytes())?;
+        }
 
-        // 3. level_offsets
         writer.write_all(self.level_offsets.as_bytes())?;
-
-        // 4. reindex
         writer.write_all(self.reindex.as_bytes())?;
-
-        let mut offsets = Vec::with_capacity(header.total_offsets_len as usize);
-        offsets.push(0);
-
-        // 5. links
-        let mut links_pos = 0;
-        let mut write_links = |links: &[PointOffsetType]| {
-            writer.write_all(links.as_bytes())?;
-            links_pos += links.len();
-            offsets.push(links_pos as u64);
-            std::io::Result::Ok(())
-        };
-        for point in &self.edges {
-            write_links(&point[0])?;
-        }
-        for level in 1..header.levels_count as usize {
-            let count = self.point_count_by_level.iter().skip(level).sum::<u64>() as usize;
-            for i in 0..count {
-                write_links(&self.edges[self.back_index[i]][level])?;
-            }
-        }
-
-        debug_assert_eq!(links_pos, self.total_links_len);
-
-        // 6. padding for offsets
-        writer.write_zeros(self.offsets_padding())?;
-
-        // 7. offsets
-        writer.write_all(offsets.as_bytes())?;
+        writer.write_all(&self.links)?;
+        writer.write_zeros(self.offsets_padding)?;
+        writer.write_all(self.offsets.as_bytes())?;
 
         Ok(())
     }
@@ -275,6 +353,40 @@ impl GraphLinksConverter {
     }
 }
 
+pub fn convert_to_compressed(path: &Path, m: usize, m0: usize) -> OperationResult<()> {
+    let start = std::time::Instant::now();
+
+    let links = GraphLinksMmap::load_from_file(path)?;
+    if links.info.compression.is_some() {
+        return Ok(());
+    }
+
+    let edges = (0..links.num_points())
+        .map(|point_id| {
+            let num_levels = links.point_level(point_id as PointOffsetType) + 1;
+            (0..num_levels)
+                .map(|level| links.links_vec(point_id as PointOffsetType, level))
+                .collect::<Vec<_>>()
+        })
+        .collect();
+    drop(links);
+    let mut converter = GraphLinksConverter::new(edges, true, m, m0);
+
+    let original_size = path.metadata()?.len();
+    converter.save_as(path)?;
+    let new_size = path.metadata()?.len();
+
+    log::debug!(
+        "Compressed HNSW graph links in {:.1?}: {:.1}MB -> {:.1}MB ({:.1}%)",
+        start.elapsed(),
+        original_size as f64 / 1024.0 / 1024.0,
+        new_size as f64 / 1024.0 / 1024.0,
+        new_size as f64 / original_size as f64 * 100.0,
+    );
+
+    Ok(())
+}
+
 pub trait GraphLinks: Sized {
     fn load_from_file(path: &Path) -> OperationResult<Self>;
 
@@ -291,7 +403,6 @@ pub trait GraphLinks: Sized {
 
     fn point_level(&self, point_id: PointOffsetType) -> usize;
 
-    #[cfg(test)]
     fn links_vec(&self, point_id: PointOffsetType, level: usize) -> Vec<PointOffsetType> {
         let mut links = Vec::new();
         self.for_each_link(point_id, level, |link| links.push(link));
@@ -441,7 +552,7 @@ struct GraphLinksView<'a> {
     level_offsets: &'a [u64],
 }
 
-impl<'a> GraphLinksView<'a> {
+impl GraphLinksView<'_> {
     fn for_each_link(
         &self,
         point_id: PointOffsetType,
@@ -453,9 +564,30 @@ impl<'a> GraphLinksView<'a> {
         } else {
             self.level_offsets[level] as usize + self.reindex(point_id) as usize
         };
-        let links_range = self.get_links_range(idx);
-        for &link in self.get_links(links_range) {
-            f(link);
+        let all_links = &self.data[self.info.links_range()];
+
+        let offsets = <[u64]>::ref_from_bytes(&self.data[self.info.offsets_range()]).unwrap();
+        let offset0 = offsets[idx];
+        let offset1 = offsets[idx + 1];
+
+        let links_range = (offset0 as usize)..(offset1 as usize);
+
+        if let Some(compression) = &self.info.compression {
+            for_each_packed_link(
+                &all_links[links_range],
+                compression.bits_per_unsorted,
+                if level == 0 {
+                    compression.m0
+                } else {
+                    compression.m
+                },
+                f,
+            );
+        } else {
+            let all_links = <[PointOffsetType]>::ref_from_bytes(all_links).unwrap();
+            for &link in &all_links[links_range] {
+                f(link);
+            }
         }
     }
 
@@ -492,23 +624,10 @@ impl<'a> GraphLinksView<'a> {
         }
     }
 
-    fn get_links_range(&self, idx: usize) -> Range<usize> {
-        let offsets = <[u64]>::ref_from_bytes(&self.data[self.info.offsets_range()]).unwrap();
-        offsets[idx] as usize..offsets[idx + 1] as usize
-    }
-
     fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
         let idx = &self.data[self.info.reindex_range()];
         <[PointOffsetType]>::ref_from_bytes(idx).unwrap()[point_id as usize]
     }
-
-    fn get_links(&self, range: Range<usize>) -> &'a [PointOffsetType] {
-        let idx = &self.data[self.info.links_range()];
-        <[PointOffsetType]>::ref_from_bytes(idx)
-            .unwrap()
-            .get(range)
-            .unwrap()
-    }
 }
 
 /// Sort the first `m` values in `links` and return them. Used to compare stored

commit 9fca663adb00140e0e5a80b2d21dfeafeb274d37
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Dec 18 21:02:27 2024 +0000

    Update hnsw_search_graph benchmark (#5666)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index cd57d279b..134928304 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -299,7 +299,7 @@ impl GraphLinksConverter {
             + self.offsets.as_bytes().len()
     }
 
-    fn serialize_to_vec(&self) -> Vec<u8> {
+    pub fn serialize_to_vec(&self) -> Vec<u8> {
         let mut data = Vec::with_capacity(self.data_size());
         // Unwrap should be the safe as `impl Write` for `Vec` never fails.
         self.serialize_to_writer(&mut data).unwrap();
@@ -361,16 +361,7 @@ pub fn convert_to_compressed(path: &Path, m: usize, m0: usize) -> OperationResul
         return Ok(());
     }
 
-    let edges = (0..links.num_points())
-        .map(|point_id| {
-            let num_levels = links.point_level(point_id as PointOffsetType) + 1;
-            (0..num_levels)
-                .map(|level| links.links_vec(point_id as PointOffsetType, level))
-                .collect::<Vec<_>>()
-        })
-        .collect();
-    drop(links);
-    let mut converter = GraphLinksConverter::new(edges, true, m, m0);
+    let mut converter = GraphLinksConverter::new(links.into_edges(), true, m, m0);
 
     let original_size = path.metadata()?.len();
     converter.save_as(path)?;
@@ -392,6 +383,8 @@ pub trait GraphLinks: Sized {
 
     fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self>;
 
+    fn compressed(&self) -> bool;
+
     fn num_points(&self) -> usize;
 
     fn for_each_link(
@@ -408,6 +401,21 @@ pub trait GraphLinks: Sized {
         self.for_each_link(point_id, level, |link| links.push(link));
         links
     }
+
+    /// Convert the graph links to a vector of edges, suitable for passing into
+    /// [`GraphLinksConverter::new`] or using in tests.
+    fn into_edges(self) -> Vec<Vec<Vec<PointOffsetType>>> {
+        let mut edges = Vec::new();
+        for point_id in 0..self.num_points() {
+            let num_levels = self.point_level(point_id as PointOffsetType) + 1;
+            let mut levels = Vec::with_capacity(num_levels);
+            for level in 0..num_levels {
+                levels.push(self.links_vec(point_id as PointOffsetType, level));
+            }
+            edges.push(levels);
+        }
+        edges
+    }
 }
 
 #[derive(Debug)]
@@ -418,7 +426,7 @@ pub struct GraphLinksRam {
 }
 
 impl GraphLinksRam {
-    fn from_bytes(data: Vec<u8>) -> Self {
+    pub fn from_bytes(data: Vec<u8>) -> Self {
         let info = GraphLinksFileInfo::load(&data).unwrap();
         let level_offsets = info.get_level_offsets(&data).to_vec();
         Self {
@@ -457,6 +465,10 @@ impl GraphLinks for GraphLinksRam {
         Ok(Self::from_bytes(converter.serialize_to_vec()))
     }
 
+    fn compressed(&self) -> bool {
+        self.info.compression.is_some()
+    }
+
     fn num_points(&self) -> usize {
         self.info.point_count
     }
@@ -527,6 +539,10 @@ impl GraphLinks for GraphLinksMmap {
         }
     }
 
+    fn compressed(&self) -> bool {
+        self.info.compression.is_some()
+    }
+
     fn num_points(&self) -> usize {
         self.info.point_count
     }
@@ -647,21 +663,6 @@ mod tests {
 
     use super::*;
 
-    fn to_vec<TGraphLinks: GraphLinks>(links: &TGraphLinks) -> Vec<Vec<Vec<PointOffsetType>>> {
-        let mut result = Vec::new();
-        let num_points = links.num_points();
-        for i in 0..num_points {
-            let mut layers = Vec::new();
-            let num_levels = links.point_level(i as PointOffsetType) + 1;
-            for level in 0..num_levels {
-                let links = links.links_vec(i as PointOffsetType, level);
-                layers.push(links);
-            }
-            result.push(layers);
-        }
-        result
-    }
-
     fn random_links(
         points_count: usize,
         max_levels_count: usize,
@@ -734,7 +735,7 @@ mod tests {
             let mut links_converter = GraphLinksConverter::new(links.clone(), compressed, m, m0);
             links_converter.save_as(&links_file).unwrap();
         }
-        let cmp_links = to_vec(&A::load_from_file(&links_file).unwrap());
+        let cmp_links = A::load_from_file(&links_file).unwrap().into_edges();
         compare_links(links, cmp_links, compressed, m, m0);
     }
 
@@ -749,15 +750,14 @@ mod tests {
                               m: usize,
                               m0: usize|
          -> Vec<Vec<Vec<PointOffsetType>>> {
-            to_vec(
-                &GraphLinksRam::from_converter(GraphLinksConverter::new(
-                    links.clone(),
-                    compressed,
-                    m,
-                    m0,
-                ))
-                .unwrap(),
-            )
+            GraphLinksRam::from_converter(GraphLinksConverter::new(
+                links.clone(),
+                compressed,
+                m,
+                m0,
+            ))
+            .unwrap()
+            .into_edges()
         };
 
         // no points

commit 01326480419e31926c1a6c3223c5a4dc54ea748f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Dec 23 18:59:53 2024 +0000

    GraphLinks: replace trait with enum (#5651)
    
    * GraphLinks: replace trait with enum
    
    * Vec::with_capacity

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 134928304..18e20644f 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -2,15 +2,14 @@ use std::cmp::Reverse;
 use std::fs::{File, OpenOptions};
 use std::io::{Read as _, Write};
 use std::mem::take;
-use std::ops::Range;
-use std::path::{Path, PathBuf};
+use std::path::Path;
 use std::sync::Arc;
 
 use common::bitpacking::packed_bits;
 use common::bitpacking_links::{for_each_packed_link, pack_links, MIN_BITS_PER_VALUE};
 use common::types::PointOffsetType;
 use common::zeros::WriteZerosExt as _;
-use itertools::Either;
+use itertools::{Either, Itertools as _};
 use memmap2::Mmap;
 use memory::{madvise, mmap_ops};
 use zerocopy::little_endian::U64;
@@ -53,23 +52,29 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
-const HEADER_SIZE: usize = 64;
-
 #[derive(Clone, Debug)]
-struct GraphLinksFileInfo {
-    point_count: usize,
-    reindex_start: usize,
-    links_start: usize,
-    offsets_start: usize,
-    offsets_end: usize,
-    compression: Option<CompressionInfo>,
+struct GraphLinksView<'a> {
+    reindex: &'a [PointOffsetType],
+    offsets: &'a [u64],
+    compression: CompressionInfo<'a>,
+    /// Level offsets, copied into RAM for faster access.
+    /// Has at least two elements:
+    /// - `GraphLinksConverter` always writes `0` as the first element.
+    /// - Additional element is added during deserialization.
+    level_offsets: Vec<u64>,
 }
 
 #[derive(Clone, Debug)]
-struct CompressionInfo {
-    m: usize,
-    m0: usize,
-    bits_per_unsorted: u8,
+enum CompressionInfo<'a> {
+    Uncompressed {
+        links: &'a [u32],
+    },
+    Compressed {
+        compressed_links: &'a [u8],
+        m: usize,
+        m0: usize,
+        bits_per_unsorted: u8,
+    },
 }
 
 /// File header for the plain format.
@@ -106,8 +111,8 @@ struct HeaderCompressed {
 
 const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;
 
-impl GraphLinksFileInfo {
-    pub fn load(data: &[u8]) -> OperationResult<GraphLinksFileInfo> {
+impl GraphLinksView<'_> {
+    fn load(data: &[u8]) -> OperationResult<GraphLinksView> {
         let levels_count_or_version = data
             .get(size_of::<u64>()..)
             .and_then(|x| U64::ref_from_prefix(x).ok())
@@ -115,87 +120,144 @@ impl GraphLinksFileInfo {
             .0
             .get();
 
-        // Header for the plain format lacks the version field, but we can be
-        // sure that it contains no more than 2^32 levels.
-        let is_plain = u64::from_le(levels_count_or_version) <= 1 << 32;
-
         match levels_count_or_version {
-            _ if is_plain => {
-                let (header, _) = HeaderPlain::ref_from_prefix(data)
-                    .map_err(|_| Self::error_unsufficent_size())?;
-                let reindex_start = HEADER_SIZE + header.levels_count as usize * size_of::<u64>();
-                let links_start =
-                    reindex_start + header.point_count as usize * size_of::<PointOffsetType>();
-                let offsets_start = links_start
-                    + header.total_links_count as usize * size_of::<PointOffsetType>()
-                    + header.offsets_padding_bytes as usize;
-                Ok(GraphLinksFileInfo {
-                    point_count: header.point_count as usize,
-                    reindex_start,
-                    links_start,
-                    offsets_start,
-                    offsets_end: offsets_start
-                        + header.total_offset_count as usize * size_of::<u64>(),
-                    compression: None,
-                })
-            }
-            HEADER_VERSION_COMPRESSED => {
-                let (header, _) = HeaderCompressed::ref_from_prefix(data)
-                    .map_err(|_| Self::error_unsufficent_size())?;
-                debug_assert_eq!(header.version.get(), HEADER_VERSION_COMPRESSED);
-                let point_count = header.point_count.get() as usize;
-                let reindex_start =
-                    HEADER_SIZE + header.levels_count.get() as usize * size_of::<u64>();
-                let links_start = reindex_start
-                    + header.point_count.get() as usize * size_of::<PointOffsetType>();
-                let offsets_start = (links_start + header.total_links_bytes.get() as usize)
-                    .next_multiple_of(size_of::<u64>());
-                Ok(GraphLinksFileInfo {
-                    point_count,
-                    reindex_start,
-                    links_start,
-                    offsets_start,
-                    offsets_end: offsets_start
-                        + header.total_offset_count.get() as usize * size_of::<u64>(),
-                    compression: Some(CompressionInfo {
-                        m: header.m.get() as usize,
-                        m0: header.m0.get() as usize,
-                        bits_per_unsorted: MIN_BITS_PER_VALUE.max(packed_bits(
-                            u32::try_from(point_count.saturating_sub(1)).map_err(|_| {
-                                OperationError::service_error("Too many points in GraphLinks file")
-                            })?,
-                        )),
-                    }),
-                })
-            }
+            // Header for the plain format lacks the version field, but we can
+            // be sure that it contains no more than 2^32 levels.
+            _ if u64::from_le(levels_count_or_version) <= 1 << 32 => Self::load_plain(data),
+            HEADER_VERSION_COMPRESSED => Self::load_compressed(data),
             _ => Err(OperationError::service_error(
                 "Unsupported version of GraphLinks file",
             )),
         }
     }
 
-    fn error_unsufficent_size() -> OperationError {
-        OperationError::service_error("Unsufficent file size for GraphLinks file")
+    fn load_plain(data: &[u8]) -> OperationResult<GraphLinksView> {
+        let (header, data) =
+            HeaderPlain::ref_from_prefix(data).map_err(|_| Self::error_unsufficent_size())?;
+        let (level_offsets, data) =
+            Self::read_level_offsets(data, header.levels_count, header.total_offset_count)?;
+        let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count)?;
+        let (links, data) = Self::get_slice::<u32>(data, header.total_links_count)?;
+        let (_, data) = Self::get_slice::<u8>(data, header.offsets_padding_bytes)?;
+        let (offsets, _bytes) = Self::get_slice::<u64>(data, header.total_offset_count)?;
+        Ok(GraphLinksView {
+            reindex,
+            offsets,
+            compression: CompressionInfo::Uncompressed { links },
+            level_offsets,
+        })
     }
 
-    pub fn level_offsets(&self) -> Range<usize> {
-        HEADER_SIZE..self.reindex_start
+    fn load_compressed(data: &[u8]) -> OperationResult<GraphLinksView> {
+        let (header, data) =
+            HeaderCompressed::ref_from_prefix(data).map_err(|_| Self::error_unsufficent_size())?;
+        debug_assert_eq!(header.version.get(), HEADER_VERSION_COMPRESSED);
+        let (level_offsets, data) = Self::read_level_offsets(
+            data,
+            header.levels_count.get(),
+            header.total_offset_count.get(),
+        )?;
+        let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count.get())?;
+        let (compressed_links, data) = Self::get_slice::<u8>(data, header.total_links_bytes.get())?;
+        let offsets_padding = {
+            let len = compressed_links.len() + reindex.as_bytes().len();
+            len.next_multiple_of(size_of::<u64>()) - len
+        };
+        let (_, data) = Self::get_slice::<u8>(data, offsets_padding as u64)?;
+        let (offsets, _bytes) = Self::get_slice::<u64>(data, header.total_offset_count.get())?;
+        Ok(GraphLinksView {
+            reindex,
+            offsets,
+            compression: CompressionInfo::Compressed {
+                compressed_links,
+                m: header.m.get() as usize,
+                m0: header.m0.get() as usize,
+                bits_per_unsorted: MIN_BITS_PER_VALUE.max(packed_bits(
+                    u32::try_from(header.point_count.get().saturating_sub(1)).map_err(|_| {
+                        OperationError::service_error("Too many points in GraphLinks file")
+                    })?,
+                )),
+            },
+            level_offsets,
+        })
     }
 
-    pub fn get_level_offsets<'a>(&self, data: &'a [u8]) -> &'a [u64] {
-        <[u64]>::ref_from_bytes(&data[self.level_offsets()]).unwrap()
+    fn read_level_offsets(
+        bytes: &[u8],
+        levels_count: u64,
+        total_offset_count: u64,
+    ) -> OperationResult<(Vec<u64>, &[u8])> {
+        let (level_offsets, bytes) = Self::get_slice::<u64>(bytes, levels_count)?;
+        let mut result = Vec::with_capacity(level_offsets.len() + 1);
+        result.extend_from_slice(level_offsets);
+        result.push(total_offset_count.checked_sub(1).ok_or_else(|| {
+            OperationError::service_error(
+                "Total offset count should be at least 1 in GraphLinks file",
+            )
+        })?);
+        Ok((result, bytes))
     }
 
-    pub fn reindex_range(&self) -> Range<usize> {
-        self.reindex_start..self.links_start
+    fn get_slice<T: FromBytes + Immutable>(
+        data: &[u8],
+        length: u64,
+    ) -> OperationResult<(&[T], &[u8])> {
+        <[T]>::ref_from_prefix_with_elems(data, length as usize)
+            .map_err(|_| Self::error_unsufficent_size())
     }
 
-    pub fn links_range(&self) -> Range<usize> {
-        self.links_start..self.offsets_start
+    fn error_unsufficent_size() -> OperationError {
+        OperationError::service_error("Unsufficent file size for GraphLinks file")
     }
 
-    pub fn offsets_range(&self) -> Range<usize> {
-        self.offsets_start..self.offsets_end
+    fn for_each_link(
+        &self,
+        point_id: PointOffsetType,
+        level: usize,
+        f: impl FnMut(PointOffsetType),
+    ) {
+        let idx = if level == 0 {
+            point_id as usize
+        } else {
+            self.level_offsets[level] as usize + self.reindex[point_id as usize] as usize
+        };
+        let links_range = self.offsets[idx] as usize..self.offsets[idx + 1] as usize;
+
+        match self.compression {
+            CompressionInfo::Uncompressed { links } => {
+                links[links_range].iter().copied().for_each(f)
+            }
+            CompressionInfo::Compressed {
+                compressed_links,
+                m,
+                m0,
+                bits_per_unsorted,
+            } => {
+                for_each_packed_link(
+                    &compressed_links[links_range],
+                    bits_per_unsorted,
+                    if level == 0 { m0 } else { m },
+                    f,
+                );
+            }
+        }
+    }
+
+    fn point_level(&self, point_id: PointOffsetType) -> usize {
+        let reindexed_point_id = u64::from(self.reindex[point_id as usize]);
+        for (level, (&a, &b)) in self
+            .level_offsets
+            .iter()
+            .skip(1)
+            .tuple_windows()
+            .enumerate()
+        {
+            if reindexed_point_id >= b - a {
+                return level;
+            }
+        }
+        // See the doc comment on `level_offsets`.
+        self.level_offsets.len() - 2
     }
 }
 
@@ -206,7 +268,6 @@ pub struct GraphLinksConverter {
     links: Vec<u8>,
     offsets: Vec<u64>,
     reindex: Vec<PointOffsetType>,
-    path: Option<PathBuf>,
     level_offsets: Vec<u64>,
     offsets_padding: usize,
 }
@@ -283,28 +344,28 @@ impl GraphLinksConverter {
             links,
             offsets,
             reindex,
-            path: None,
             level_offsets,
             offsets_padding,
         }
     }
 
-    /// Size of compacted graph in bytes.
-    fn data_size(&self) -> usize {
-        HEADER_SIZE
-            + self.level_offsets.as_bytes().len()
+    pub fn to_graph_links_ram(&self) -> GraphLinks {
+        let size = if self.compressed {
+            size_of::<HeaderCompressed>()
+        } else {
+            size_of::<HeaderPlain>()
+        } + self.level_offsets.as_bytes().len()
             + self.reindex.as_bytes().len()
             + self.links.len()
             + self.offsets_padding
-            + self.offsets.as_bytes().len()
-    }
+            + self.offsets.as_bytes().len();
 
-    pub fn serialize_to_vec(&self) -> Vec<u8> {
-        let mut data = Vec::with_capacity(self.data_size());
+        let mut data = Vec::with_capacity(size);
         // Unwrap should be the safe as `impl Write` for `Vec` never fails.
         self.serialize_to_writer(&mut data).unwrap();
-        debug_assert_eq!(data.len(), self.data_size());
-        data
+        debug_assert_eq!(data.len(), size);
+        // Unwrap should be safe as we just created the data.
+        GraphLinks::try_new(GraphLinksEnum::Ram(data), |x| x.load_view()).unwrap()
     }
 
     fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
@@ -341,8 +402,7 @@ impl GraphLinksConverter {
         Ok(())
     }
 
-    pub fn save_as(&mut self, path: &Path) -> OperationResult<()> {
-        self.path = Some(path.to_path_buf());
+    pub fn save_as(&self, path: &Path) -> OperationResult<()> {
         let temp_path = path.with_extension("tmp");
         let file = File::create(temp_path.as_path())?;
         let mut buf = std::io::BufWriter::new(&file);
@@ -356,15 +416,13 @@ impl GraphLinksConverter {
 pub fn convert_to_compressed(path: &Path, m: usize, m0: usize) -> OperationResult<()> {
     let start = std::time::Instant::now();
 
-    let links = GraphLinksMmap::load_from_file(path)?;
-    if links.info.compression.is_some() {
+    let links = GraphLinks::load_from_file(path, true)?;
+    if links.compressed() {
         return Ok(());
     }
 
-    let mut converter = GraphLinksConverter::new(links.into_edges(), true, m, m0);
-
     let original_size = path.metadata()?.len();
-    converter.save_as(path)?;
+    GraphLinksConverter::new(links.into_edges(), true, m, m0).save_as(path)?;
     let new_size = path.metadata()?.len();
 
     log::debug!(
@@ -378,176 +436,69 @@ pub fn convert_to_compressed(path: &Path, m: usize, m0: usize) -> OperationResul
     Ok(())
 }
 
-pub trait GraphLinks: Sized {
-    fn load_from_file(path: &Path) -> OperationResult<Self>;
-
-    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self>;
-
-    fn compressed(&self) -> bool;
-
-    fn num_points(&self) -> usize;
-
-    fn for_each_link(
-        &self,
-        point_id: PointOffsetType,
-        level: usize,
-        f: impl FnMut(PointOffsetType),
-    );
-
-    fn point_level(&self, point_id: PointOffsetType) -> usize;
-
-    fn links_vec(&self, point_id: PointOffsetType, level: usize) -> Vec<PointOffsetType> {
-        let mut links = Vec::new();
-        self.for_each_link(point_id, level, |link| links.push(link));
-        links
+self_cell::self_cell! {
+    pub struct GraphLinks {
+        owner: GraphLinksEnum,
+        #[covariant]
+        dependent: GraphLinksView,
     }
 
-    /// Convert the graph links to a vector of edges, suitable for passing into
-    /// [`GraphLinksConverter::new`] or using in tests.
-    fn into_edges(self) -> Vec<Vec<Vec<PointOffsetType>>> {
-        let mut edges = Vec::new();
-        for point_id in 0..self.num_points() {
-            let num_levels = self.point_level(point_id as PointOffsetType) + 1;
-            let mut levels = Vec::with_capacity(num_levels);
-            for level in 0..num_levels {
-                levels.push(self.links_vec(point_id as PointOffsetType, level));
-            }
-            edges.push(levels);
-        }
-        edges
-    }
+    impl {Debug}
 }
 
 #[derive(Debug)]
-pub struct GraphLinksRam {
-    data: Vec<u8>,
-    info: GraphLinksFileInfo,
-    level_offsets: Vec<u64>,
+enum GraphLinksEnum {
+    Ram(Vec<u8>),
+    Mmap(Arc<Mmap>),
 }
 
-impl GraphLinksRam {
-    pub fn from_bytes(data: Vec<u8>) -> Self {
-        let info = GraphLinksFileInfo::load(&data).unwrap();
-        let level_offsets = info.get_level_offsets(&data).to_vec();
-        Self {
-            data,
-            info,
-            level_offsets,
-        }
-    }
-
-    fn view(&self) -> GraphLinksView {
-        GraphLinksView {
-            data: &self.data,
-            info: &self.info,
-            level_offsets: &self.level_offsets,
-        }
+impl GraphLinksEnum {
+    fn load_view(&self) -> OperationResult<GraphLinksView> {
+        let data = match self {
+            GraphLinksEnum::Ram(data) => data.as_slice(),
+            GraphLinksEnum::Mmap(mmap) => &mmap[..],
+        };
+        GraphLinksView::load(data)
     }
 }
 
-impl GraphLinks for GraphLinksRam {
-    fn load_from_file(path: &Path) -> OperationResult<Self> {
+impl GraphLinks {
+    pub fn load_from_file(path: &Path, on_disk: bool) -> OperationResult<Self> {
         let file = OpenOptions::new()
             .read(true)
             .write(false)
             .create(false)
             .open(path)?;
-        let len = file.metadata()?.len();
-
-        let mut data = Vec::new();
-        data.try_set_capacity_exact(len as usize)?;
-        file.take(len).read_to_end(&mut data)?;
-
-        Ok(Self::from_bytes(data))
-    }
-
-    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
-        Ok(Self::from_bytes(converter.serialize_to_vec()))
-    }
-
-    fn compressed(&self) -> bool {
-        self.info.compression.is_some()
-    }
-
-    fn num_points(&self) -> usize {
-        self.info.point_count
-    }
-
-    fn for_each_link(
-        &self,
-        point_id: PointOffsetType,
-        level: usize,
-        f: impl FnMut(PointOffsetType),
-    ) {
-        self.view().for_each_link(point_id, level, f)
-    }
-
-    fn point_level(&self, point_id: PointOffsetType) -> usize {
-        self.view().point_level(point_id)
-    }
-}
-
-#[derive(Debug)]
-pub struct GraphLinksMmap {
-    mmap: Arc<Mmap>,
-    info: GraphLinksFileInfo,
-    level_offsets: Vec<u64>,
-}
-
-impl GraphLinksMmap {
-    pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
-        mmap_ops::PrefaultMmapPages::new(Arc::clone(&self.mmap), Some(path))
-    }
-
-    fn view(&self) -> GraphLinksView {
-        GraphLinksView {
-            data: &self.mmap,
-            info: &self.info,
-            level_offsets: &self.level_offsets,
+        if on_disk {
+            let len = file.metadata()?.len();
+            let mut data = Vec::new();
+            data.try_set_capacity_exact(len as usize)?;
+            file.take(len).read_to_end(&mut data)?;
+            Self::try_new(GraphLinksEnum::Ram(data), |x| x.load_view())
+        } else {
+            let mmap = unsafe { Mmap::map(&file)? };
+            madvise::madvise(&mmap, madvise::get_global())?;
+            Self::try_new(GraphLinksEnum::Mmap(Arc::new(mmap)), |x| x.load_view())
         }
     }
-}
-
-impl GraphLinks for GraphLinksMmap {
-    fn load_from_file(path: &Path) -> OperationResult<Self> {
-        let file = OpenOptions::new()
-            .read(true)
-            .write(false)
-            .create(false)
-            .open(path)?;
 
-        let mmap = unsafe { Mmap::map(&file)? };
-        madvise::madvise(&mmap, madvise::get_global())?;
-
-        let info = GraphLinksFileInfo::load(&mmap).unwrap();
-        let level_offsets = info.get_level_offsets(&mmap).to_vec();
-
-        Ok(Self {
-            mmap: Arc::new(mmap),
-            info,
-            level_offsets,
-        })
+    fn view(&self) -> &GraphLinksView {
+        self.borrow_dependent()
     }
 
-    fn from_converter(converter: GraphLinksConverter) -> OperationResult<Self> {
-        if let Some(path) = converter.path {
-            Self::load_from_file(&path)
-        } else {
-            Err(OperationError::service_error(
-                "HNSW links Data needs to be saved to file before it can be loaded as mmap",
-            ))
-        }
+    pub fn compressed(&self) -> bool {
+        matches!(self.view().compression, CompressionInfo::Compressed { .. })
     }
 
-    fn compressed(&self) -> bool {
-        self.info.compression.is_some()
+    pub fn on_disk(&self) -> bool {
+        matches!(self.borrow_owner(), GraphLinksEnum::Ram(_))
     }
 
-    fn num_points(&self) -> usize {
-        self.info.point_count
+    pub fn num_points(&self) -> usize {
+        self.view().reindex.len()
     }
 
-    fn for_each_link(
+    pub fn for_each_link(
         &self,
         point_id: PointOffsetType,
         level: usize,
@@ -556,94 +507,40 @@ impl GraphLinks for GraphLinksMmap {
         self.view().for_each_link(point_id, level, f)
     }
 
-    fn point_level(&self, point_id: PointOffsetType) -> usize {
+    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
         self.view().point_level(point_id)
     }
-}
 
-#[derive(Debug)]
-struct GraphLinksView<'a> {
-    data: &'a [u8],
-    info: &'a GraphLinksFileInfo,
-    level_offsets: &'a [u64],
-}
-
-impl GraphLinksView<'_> {
-    fn for_each_link(
-        &self,
-        point_id: PointOffsetType,
-        level: usize,
-        mut f: impl FnMut(PointOffsetType),
-    ) {
-        let idx = if level == 0 {
-            point_id as usize
-        } else {
-            self.level_offsets[level] as usize + self.reindex(point_id) as usize
-        };
-        let all_links = &self.data[self.info.links_range()];
-
-        let offsets = <[u64]>::ref_from_bytes(&self.data[self.info.offsets_range()]).unwrap();
-        let offset0 = offsets[idx];
-        let offset1 = offsets[idx + 1];
-
-        let links_range = (offset0 as usize)..(offset1 as usize);
-
-        if let Some(compression) = &self.info.compression {
-            for_each_packed_link(
-                &all_links[links_range],
-                compression.bits_per_unsorted,
-                if level == 0 {
-                    compression.m0
-                } else {
-                    compression.m
-                },
-                f,
-            );
-        } else {
-            let all_links = <[PointOffsetType]>::ref_from_bytes(all_links).unwrap();
-            for &link in &all_links[links_range] {
-                f(link);
-            }
-        }
+    pub fn links_vec(&self, point_id: PointOffsetType, level: usize) -> Vec<PointOffsetType> {
+        let mut links = Vec::new();
+        self.for_each_link(point_id, level, |link| links.push(link));
+        links
     }
 
-    fn point_level(&self, point_id: PointOffsetType) -> usize {
-        let reindexed_point_id = self.reindex(point_id) as usize;
-        // level 0 is always present, start checking from level 1. Stop checking when level is incorrect
-        for level in 1.. {
-            if let Some(offsets_range) = self.get_level_offsets_range(level) {
-                if offsets_range.start + reindexed_point_id >= offsets_range.end {
-                    // incorrect level because point_id is out of range
-                    return level - 1;
-                }
-            } else {
-                // incorrect level because this level is larger that available levels
-                return level - 1;
+    /// Convert the graph links to a vector of edges, suitable for passing into
+    /// [`GraphLinksConverter::new`] or using in tests.
+    pub fn into_edges(self) -> Vec<Vec<Vec<PointOffsetType>>> {
+        let mut edges = Vec::with_capacity(self.num_points());
+        for point_id in 0..self.num_points() {
+            let num_levels = self.point_level(point_id as PointOffsetType) + 1;
+            let mut levels = Vec::with_capacity(num_levels);
+            for level in 0..num_levels {
+                levels.push(self.links_vec(point_id as PointOffsetType, level));
             }
+            edges.push(levels);
         }
-        unreachable!()
+        edges
     }
 
-    fn get_level_offsets_range(&self, level: usize) -> Option<Range<usize>> {
-        if level < self.level_offsets.len() {
-            let layer_offsets_start = self.level_offsets[level] as usize;
-            let layer_offsets_end = if level + 1 < self.level_offsets.len() {
-                // `level` is not last, next level_offsets is end of range
-                self.level_offsets[level + 1] as usize
-            } else {
-                // `level` is last, next `offsets.len()` is end of range
-                self.info.offsets_range().len() / size_of::<u64>() - 1
-            };
-            Some(layer_offsets_start..layer_offsets_end)
-        } else {
-            None
+    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
+        match self.borrow_owner() {
+            GraphLinksEnum::Mmap(mmap) => Some(mmap_ops::PrefaultMmapPages::new(
+                Arc::clone(mmap),
+                Some(path.to_owned()),
+            )),
+            GraphLinksEnum::Ram(_) => None,
         }
     }
-
-    fn reindex(&self, point_id: PointOffsetType) -> PointOffsetType {
-        let idx = &self.data[self.info.reindex_range()];
-        <[PointOffsetType]>::ref_from_bytes(idx).unwrap()[point_id as usize]
-    }
 }
 
 /// Sort the first `m` values in `links` and return them. Used to compare stored
@@ -719,23 +616,23 @@ mod tests {
     }
 
     /// Test that random links can be saved by `GraphLinksConverter` and loaded correctly by a GraphLinks impl.
-    fn test_save_load<A>(
+    fn test_save_load(
         points_count: usize,
         max_levels_count: usize,
+        on_disk: bool,
         compressed: bool,
         m: usize,
         m0: usize,
-    ) where
-        A: GraphLinks,
-    {
+    ) {
         let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
         let links_file = path.path().join("links.bin");
         let links = random_links(points_count, max_levels_count, m, m0);
-        {
-            let mut links_converter = GraphLinksConverter::new(links.clone(), compressed, m, m0);
-            links_converter.save_as(&links_file).unwrap();
-        }
-        let cmp_links = A::load_from_file(&links_file).unwrap().into_edges();
+        GraphLinksConverter::new(links.clone(), compressed, m, m0)
+            .save_as(&links_file)
+            .unwrap();
+        let cmp_links = GraphLinks::load_from_file(&links_file, on_disk)
+            .unwrap()
+            .into_edges();
         compare_links(links, cmp_links, compressed, m, m0);
     }
 
@@ -750,14 +647,9 @@ mod tests {
                               m: usize,
                               m0: usize|
          -> Vec<Vec<Vec<PointOffsetType>>> {
-            GraphLinksRam::from_converter(GraphLinksConverter::new(
-                links.clone(),
-                compressed,
-                m,
-                m0,
-            ))
-            .unwrap()
-            .into_edges()
+            GraphLinksConverter::new(links, compressed, m, m0)
+                .to_graph_links_ram()
+                .into_edges()
         };
 
         // no points
@@ -816,9 +708,9 @@ mod tests {
     fn test_graph_links_mmap_ram_compatibility() {
         let m = 8;
         let m0 = m * 2;
-        test_save_load::<GraphLinksRam>(1000, 10, true, m, m0);
-        test_save_load::<GraphLinksMmap>(1000, 10, true, m, m0);
-        test_save_load::<GraphLinksRam>(1000, 10, false, m, m0);
-        test_save_load::<GraphLinksMmap>(1000, 10, false, m, m0);
+        test_save_load(1000, 10, true, true, m, m0);
+        test_save_load(1000, 10, false, true, m, m0);
+        test_save_load(1000, 10, true, false, m, m0);
+        test_save_load(1000, 10, false, false, m, m0);
     }
 }

commit 7ec92c2a6900308722ca7eec0c9ea231279b0244
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Dec 30 11:15:44 2024 +0000

    Compress offsets in `links.bin` (#5700)
    
    * Add common::bitpacking_ordered
    
    * Offset compression

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 18e20644f..cb1628862 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -7,6 +7,7 @@ use std::sync::Arc;
 
 use common::bitpacking::packed_bits;
 use common::bitpacking_links::{for_each_packed_link, pack_links, MIN_BITS_PER_VALUE};
+use common::bitpacking_ordered;
 use common::types::PointOffsetType;
 use common::zeros::WriteZerosExt as _;
 use itertools::{Either, Itertools as _};
@@ -52,10 +53,9 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
-#[derive(Clone, Debug)]
+#[derive(Debug)]
 struct GraphLinksView<'a> {
     reindex: &'a [PointOffsetType],
-    offsets: &'a [u64],
     compression: CompressionInfo<'a>,
     /// Level offsets, copied into RAM for faster access.
     /// Has at least two elements:
@@ -64,13 +64,15 @@ struct GraphLinksView<'a> {
     level_offsets: Vec<u64>,
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug)]
 enum CompressionInfo<'a> {
     Uncompressed {
         links: &'a [u32],
+        offsets: &'a [u64],
     },
     Compressed {
         compressed_links: &'a [u8],
+        offsets: bitpacking_ordered::Reader<'a>,
         m: usize,
         m0: usize,
         bits_per_unsorted: u8,
@@ -92,7 +94,7 @@ struct HeaderPlain {
 
 /// File header for the compressed format.
 #[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
-#[repr(C)]
+#[repr(C, align(8))]
 struct HeaderCompressed {
     point_count: U64,
     /// Should be [`HEADER_VERSION_COMPRESSED`].
@@ -103,10 +105,10 @@ struct HeaderCompressed {
     version: U64,
     levels_count: U64,
     total_links_bytes: U64,
-    total_offset_count: U64,
+    offsets_parameters: bitpacking_ordered::Parameters,
     m: U64,
     m0: U64,
-    zero_padding: [u8; 8],
+    zero_padding: [u8; 5],
 }
 
 const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;
@@ -142,8 +144,7 @@ impl GraphLinksView<'_> {
         let (offsets, _bytes) = Self::get_slice::<u64>(data, header.total_offset_count)?;
         Ok(GraphLinksView {
             reindex,
-            offsets,
-            compression: CompressionInfo::Uncompressed { links },
+            compression: CompressionInfo::Uncompressed { links, offsets },
             level_offsets,
         })
     }
@@ -155,21 +156,19 @@ impl GraphLinksView<'_> {
         let (level_offsets, data) = Self::read_level_offsets(
             data,
             header.levels_count.get(),
-            header.total_offset_count.get(),
+            header.offsets_parameters.length.get(),
         )?;
         let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count.get())?;
         let (compressed_links, data) = Self::get_slice::<u8>(data, header.total_links_bytes.get())?;
-        let offsets_padding = {
-            let len = compressed_links.len() + reindex.as_bytes().len();
-            len.next_multiple_of(size_of::<u64>()) - len
-        };
-        let (_, data) = Self::get_slice::<u8>(data, offsets_padding as u64)?;
-        let (offsets, _bytes) = Self::get_slice::<u64>(data, header.total_offset_count.get())?;
+        let (offsets, _bytes) = bitpacking_ordered::Reader::new(header.offsets_parameters, data)
+            .map_err(|e| {
+                OperationError::service_error(format!("Can't create decompressor: {e}"))
+            })?;
         Ok(GraphLinksView {
             reindex,
-            offsets,
             compression: CompressionInfo::Compressed {
                 compressed_links,
+                offsets,
                 m: header.m.get() as usize,
                 m0: header.m0.get() as usize,
                 bits_per_unsorted: MIN_BITS_PER_VALUE.max(packed_bits(
@@ -221,18 +220,21 @@ impl GraphLinksView<'_> {
         } else {
             self.level_offsets[level] as usize + self.reindex[point_id as usize] as usize
         };
-        let links_range = self.offsets[idx] as usize..self.offsets[idx + 1] as usize;
 
         match self.compression {
-            CompressionInfo::Uncompressed { links } => {
+            CompressionInfo::Uncompressed { links, offsets } => {
+                let links_range = offsets[idx] as usize..offsets[idx + 1] as usize;
                 links[links_range].iter().copied().for_each(f)
             }
             CompressionInfo::Compressed {
                 compressed_links,
+                ref offsets,
                 m,
                 m0,
                 bits_per_unsorted,
             } => {
+                let links_range =
+                    offsets.get(idx).unwrap() as usize..offsets.get(idx + 1).unwrap() as usize;
                 for_each_packed_link(
                     &compressed_links[links_range],
                     bits_per_unsorted,
@@ -262,14 +264,23 @@ impl GraphLinksView<'_> {
 }
 
 pub struct GraphLinksConverter {
-    compressed: bool,
     m: usize,
     m0: usize,
     links: Vec<u8>,
-    offsets: Vec<u64>,
+    kind: GraphLinksConverterKind,
     reindex: Vec<PointOffsetType>,
     level_offsets: Vec<u64>,
-    offsets_padding: usize,
+}
+
+enum GraphLinksConverterKind {
+    Uncompressed {
+        offsets_padding: usize,
+        offsets: Vec<u64>,
+    },
+    Compressed {
+        compressed_offsets: Vec<u8>,
+        offsets_parameters: bitpacking_ordered::Parameters,
+    },
 }
 
 impl GraphLinksConverter {
@@ -332,33 +343,44 @@ impl GraphLinksConverter {
             });
         }
 
-        let offsets_padding = {
+        let kind = if compressed {
+            let (compressed_offsets, offsets_parameters) = bitpacking_ordered::compress(&offsets);
+            GraphLinksConverterKind::Compressed {
+                compressed_offsets,
+                offsets_parameters,
+            }
+        } else {
             let len = links.len() + reindex.as_bytes().len();
-            len.next_multiple_of(size_of::<u64>()) - len
+            GraphLinksConverterKind::Uncompressed {
+                offsets_padding: len.next_multiple_of(size_of::<u64>()) - len,
+                offsets,
+            }
         };
 
         Self {
-            compressed,
             m,
             m0,
             links,
-            offsets,
+            kind,
             reindex,
             level_offsets,
-            offsets_padding,
         }
     }
 
     pub fn to_graph_links_ram(&self) -> GraphLinks {
-        let size = if self.compressed {
-            size_of::<HeaderCompressed>()
-        } else {
-            size_of::<HeaderPlain>()
-        } + self.level_offsets.as_bytes().len()
+        let size = self.level_offsets.as_bytes().len()
             + self.reindex.as_bytes().len()
             + self.links.len()
-            + self.offsets_padding
-            + self.offsets.as_bytes().len();
+            + (match &self.kind {
+                GraphLinksConverterKind::Uncompressed {
+                    offsets_padding: padding,
+                    offsets,
+                } => size_of::<HeaderPlain>() + padding + offsets.as_bytes().len(),
+                GraphLinksConverterKind::Compressed {
+                    compressed_offsets,
+                    offsets_parameters: _,
+                } => size_of::<HeaderCompressed>() + compressed_offsets.len(),
+            });
 
         let mut data = Vec::with_capacity(size);
         // Unwrap should be the safe as `impl Write` for `Vec` never fails.
@@ -369,35 +391,58 @@ impl GraphLinksConverter {
     }
 
     fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
-        if self.compressed {
-            let header = HeaderCompressed {
-                version: HEADER_VERSION_COMPRESSED.into(),
-                point_count: U64::new(self.reindex.len() as u64),
-                total_links_bytes: U64::new(self.links.len() as u64),
-                total_offset_count: U64::new(self.offsets.len() as u64),
-                levels_count: U64::new(self.level_offsets.len() as u64),
-                m: U64::new(self.m as u64),
-                m0: U64::new(self.m0 as u64),
-                zero_padding: [0; 8],
-            };
-            writer.write_all(header.as_bytes())?;
-        } else {
-            let header = HeaderPlain {
-                point_count: self.reindex.len() as u64,
-                levels_count: self.level_offsets.len() as u64,
-                total_links_count: self.links.len() as u64 / size_of::<PointOffsetType>() as u64,
-                total_offset_count: self.offsets.len() as u64,
-                offsets_padding_bytes: self.offsets_padding as u64,
-                zero_padding: [0; 24],
-            };
-            writer.write_all(header.as_bytes())?;
+        match &self.kind {
+            GraphLinksConverterKind::Uncompressed {
+                offsets_padding,
+                offsets,
+            } => {
+                let header = HeaderPlain {
+                    point_count: self.reindex.len() as u64,
+                    levels_count: self.level_offsets.len() as u64,
+                    total_links_count: self.links.len() as u64
+                        / size_of::<PointOffsetType>() as u64,
+                    total_offset_count: offsets.len() as u64,
+                    offsets_padding_bytes: *offsets_padding as u64,
+                    zero_padding: [0; 24],
+                };
+                writer.write_all(header.as_bytes())?;
+            }
+            GraphLinksConverterKind::Compressed {
+                compressed_offsets: _,
+                offsets_parameters,
+            } => {
+                let header = HeaderCompressed {
+                    version: HEADER_VERSION_COMPRESSED.into(),
+                    point_count: U64::new(self.reindex.len() as u64),
+                    total_links_bytes: U64::new(self.links.len() as u64),
+                    offsets_parameters: *offsets_parameters,
+                    levels_count: U64::new(self.level_offsets.len() as u64),
+                    m: U64::new(self.m as u64),
+                    m0: U64::new(self.m0 as u64),
+                    zero_padding: [0; 5],
+                };
+                writer.write_all(header.as_bytes())?;
+            }
         }
 
         writer.write_all(self.level_offsets.as_bytes())?;
         writer.write_all(self.reindex.as_bytes())?;
         writer.write_all(&self.links)?;
-        writer.write_zeros(self.offsets_padding)?;
-        writer.write_all(self.offsets.as_bytes())?;
+        match &self.kind {
+            GraphLinksConverterKind::Uncompressed {
+                offsets_padding: padding,
+                offsets,
+            } => {
+                writer.write_zeros(*padding)?;
+                writer.write_all(offsets.as_bytes())?;
+            }
+            GraphLinksConverterKind::Compressed {
+                compressed_offsets,
+                offsets_parameters: _,
+            } => {
+                writer.write_all(compressed_offsets)?;
+            }
+        }
 
         Ok(())
     }

commit 95ce711032f258024e1b2d53cb500af593a8bceb
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jan 6 19:30:12 2025 +0000

    Fix unaligned reads for graph links offsets (#5738)

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index cb1628862..471e9c3b6 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -13,7 +13,8 @@ use common::zeros::WriteZerosExt as _;
 use itertools::{Either, Itertools as _};
 use memmap2::Mmap;
 use memory::{madvise, mmap_ops};
-use zerocopy::little_endian::U64;
+use zerocopy::little_endian::U64 as LittleU64;
+use zerocopy::native_endian::U64 as NativeU64;
 use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
 
 use crate::common::operation_error::{OperationError, OperationResult};
@@ -68,7 +69,7 @@ struct GraphLinksView<'a> {
 enum CompressionInfo<'a> {
     Uncompressed {
         links: &'a [u32],
-        offsets: &'a [u64],
+        offsets: &'a [NativeU64],
     },
     Compressed {
         compressed_links: &'a [u8],
@@ -96,18 +97,18 @@ struct HeaderPlain {
 #[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
 #[repr(C, align(8))]
 struct HeaderCompressed {
-    point_count: U64,
+    point_count: LittleU64,
     /// Should be [`HEADER_VERSION_COMPRESSED`].
     ///
     /// Deliberately placed at the same offset as [`HeaderPlain::levels_count`]
     /// and set to an impossibly large number to make old Qdrant versions fail
     /// fast when trying to read the new format.
-    version: U64,
-    levels_count: U64,
-    total_links_bytes: U64,
+    version: LittleU64,
+    levels_count: LittleU64,
+    total_links_bytes: LittleU64,
     offsets_parameters: bitpacking_ordered::Parameters,
-    m: U64,
-    m0: U64,
+    m: LittleU64,
+    m0: LittleU64,
     zero_padding: [u8; 5],
 }
 
@@ -117,7 +118,7 @@ impl GraphLinksView<'_> {
     fn load(data: &[u8]) -> OperationResult<GraphLinksView> {
         let levels_count_or_version = data
             .get(size_of::<u64>()..)
-            .and_then(|x| U64::ref_from_prefix(x).ok())
+            .and_then(|x| LittleU64::ref_from_prefix(x).ok())
             .ok_or_else(Self::error_unsufficent_size)?
             .0
             .get();
@@ -141,7 +142,7 @@ impl GraphLinksView<'_> {
         let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count)?;
         let (links, data) = Self::get_slice::<u32>(data, header.total_links_count)?;
         let (_, data) = Self::get_slice::<u8>(data, header.offsets_padding_bytes)?;
-        let (offsets, _bytes) = Self::get_slice::<u64>(data, header.total_offset_count)?;
+        let (offsets, _bytes) = Self::get_slice::<NativeU64>(data, header.total_offset_count)?;
         Ok(GraphLinksView {
             reindex,
             compression: CompressionInfo::Uncompressed { links, offsets },
@@ -223,7 +224,7 @@ impl GraphLinksView<'_> {
 
         match self.compression {
             CompressionInfo::Uncompressed { links, offsets } => {
-                let links_range = offsets[idx] as usize..offsets[idx + 1] as usize;
+                let links_range = offsets[idx].get() as usize..offsets[idx + 1].get() as usize;
                 links[links_range].iter().copied().for_each(f)
             }
             CompressionInfo::Compressed {
@@ -413,12 +414,12 @@ impl GraphLinksConverter {
             } => {
                 let header = HeaderCompressed {
                     version: HEADER_VERSION_COMPRESSED.into(),
-                    point_count: U64::new(self.reindex.len() as u64),
-                    total_links_bytes: U64::new(self.links.len() as u64),
+                    point_count: LittleU64::new(self.reindex.len() as u64),
+                    total_links_bytes: LittleU64::new(self.links.len() as u64),
                     offsets_parameters: *offsets_parameters,
-                    levels_count: U64::new(self.level_offsets.len() as u64),
-                    m: U64::new(self.m as u64),
-                    m0: U64::new(self.m0 as u64),
+                    levels_count: LittleU64::new(self.level_offsets.len() as u64),
+                    m: LittleU64::new(self.m as u64),
+                    m0: LittleU64::new(self.m0 as u64),
                     zero_padding: [0; 5],
                 };
                 writer.write_all(header.as_bytes())?;

commit 8b5667d57bf6268240f61e50c459f4a4af3aa43e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jan 7 13:17:20 2025 +0000

    Separate file for compressed links; variant 2 (#5749)
    
    * fix load of the graph links mmap
    
    * decide compression based on filename rather than bit hacking
    
    * fix test
    
    * fix conversion: always create a new file for compressed links
    
    * fix conversion: adjust compressed flag after conversion
    
    * fix test (again)
    
    * Fixes
    
    * let GraphLayers manage its own files
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 471e9c3b6..e844982e2 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,6 +1,6 @@
 use std::cmp::Reverse;
-use std::fs::{File, OpenOptions};
-use std::io::{Read as _, Write};
+use std::fs::File;
+use std::io::Write;
 use std::mem::take;
 use std::path::Path;
 use std::sync::Arc;
@@ -12,13 +12,14 @@ use common::types::PointOffsetType;
 use common::zeros::WriteZerosExt as _;
 use itertools::{Either, Itertools as _};
 use memmap2::Mmap;
-use memory::{madvise, mmap_ops};
+use memory::madvise::{Advice, AdviceSetting};
+use memory::mmap_ops;
+use memory::mmap_ops::open_read_mmap;
 use zerocopy::little_endian::U64 as LittleU64;
 use zerocopy::native_endian::U64 as NativeU64;
 use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
 
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::common::vector_utils::TrySetCapacityExact;
 
 pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
 
@@ -80,6 +81,12 @@ enum CompressionInfo<'a> {
     },
 }
 
+#[derive(Debug, Clone, Copy, Eq, PartialEq)]
+pub enum GraphLinksFormat {
+    Plain,
+    Compressed,
+}
+
 /// File header for the plain format.
 #[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
 #[repr(C)]
@@ -115,22 +122,10 @@ struct HeaderCompressed {
 const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;
 
 impl GraphLinksView<'_> {
-    fn load(data: &[u8]) -> OperationResult<GraphLinksView> {
-        let levels_count_or_version = data
-            .get(size_of::<u64>()..)
-            .and_then(|x| LittleU64::ref_from_prefix(x).ok())
-            .ok_or_else(Self::error_unsufficent_size)?
-            .0
-            .get();
-
-        match levels_count_or_version {
-            // Header for the plain format lacks the version field, but we can
-            // be sure that it contains no more than 2^32 levels.
-            _ if u64::from_le(levels_count_or_version) <= 1 << 32 => Self::load_plain(data),
-            HEADER_VERSION_COMPRESSED => Self::load_compressed(data),
-            _ => Err(OperationError::service_error(
-                "Unsupported version of GraphLinks file",
-            )),
+    fn load(data: &[u8], format: GraphLinksFormat) -> OperationResult<GraphLinksView> {
+        match format {
+            GraphLinksFormat::Compressed => Self::load_compressed(data),
+            GraphLinksFormat::Plain => Self::load_plain(data),
         }
     }
 
@@ -287,7 +282,7 @@ enum GraphLinksConverterKind {
 impl GraphLinksConverter {
     pub fn new(
         mut edges: Vec<Vec<Vec<PointOffsetType>>>,
-        compressed: bool,
+        format: GraphLinksFormat,
         m: usize,
         m0: usize,
     ) -> Self {
@@ -334,27 +329,34 @@ impl GraphLinksConverter {
             };
             iter.for_each(|id| {
                 let raw_links = take(&mut edges[id][level]);
-                if compressed {
-                    pack_links(&mut links, raw_links, bits_per_unsorted, sorted_count);
-                    offsets.push(links.len() as u64);
-                } else {
-                    links.extend_from_slice(raw_links.as_bytes());
-                    offsets.push((links.len() as u64) / size_of::<PointOffsetType>() as u64);
+                match format {
+                    GraphLinksFormat::Compressed => {
+                        pack_links(&mut links, raw_links, bits_per_unsorted, sorted_count);
+                        offsets.push(links.len() as u64);
+                    }
+                    GraphLinksFormat::Plain => {
+                        links.extend_from_slice(raw_links.as_bytes());
+                        offsets.push((links.len() as u64) / size_of::<PointOffsetType>() as u64);
+                    }
                 }
             });
         }
 
-        let kind = if compressed {
-            let (compressed_offsets, offsets_parameters) = bitpacking_ordered::compress(&offsets);
-            GraphLinksConverterKind::Compressed {
-                compressed_offsets,
-                offsets_parameters,
+        let kind = match format {
+            GraphLinksFormat::Compressed => {
+                let (compressed_offsets, offsets_parameters) =
+                    bitpacking_ordered::compress(&offsets);
+                GraphLinksConverterKind::Compressed {
+                    compressed_offsets,
+                    offsets_parameters,
+                }
             }
-        } else {
-            let len = links.len() + reindex.as_bytes().len();
-            GraphLinksConverterKind::Uncompressed {
-                offsets_padding: len.next_multiple_of(size_of::<u64>()) - len,
-                offsets,
+            GraphLinksFormat::Plain => {
+                let len = links.len() + reindex.as_bytes().len();
+                GraphLinksConverterKind::Uncompressed {
+                    offsets_padding: len.next_multiple_of(size_of::<u64>()) - len,
+                    offsets,
+                }
             }
         };
 
@@ -369,6 +371,11 @@ impl GraphLinksConverter {
     }
 
     pub fn to_graph_links_ram(&self) -> GraphLinks {
+        let format = match &self.kind {
+            GraphLinksConverterKind::Uncompressed { .. } => GraphLinksFormat::Plain,
+            GraphLinksConverterKind::Compressed { .. } => GraphLinksFormat::Compressed,
+        };
+
         let size = self.level_offsets.as_bytes().len()
             + self.reindex.as_bytes().len()
             + self.links.len()
@@ -388,7 +395,7 @@ impl GraphLinksConverter {
         self.serialize_to_writer(&mut data).unwrap();
         debug_assert_eq!(data.len(), size);
         // Unwrap should be safe as we just created the data.
-        GraphLinks::try_new(GraphLinksEnum::Ram(data), |x| x.load_view()).unwrap()
+        GraphLinks::try_new(GraphLinksEnum::Ram(data), |x| x.load_view(format)).unwrap()
     }
 
     fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
@@ -459,29 +466,6 @@ impl GraphLinksConverter {
     }
 }
 
-pub fn convert_to_compressed(path: &Path, m: usize, m0: usize) -> OperationResult<()> {
-    let start = std::time::Instant::now();
-
-    let links = GraphLinks::load_from_file(path, true)?;
-    if links.compressed() {
-        return Ok(());
-    }
-
-    let original_size = path.metadata()?.len();
-    GraphLinksConverter::new(links.into_edges(), true, m, m0).save_as(path)?;
-    let new_size = path.metadata()?.len();
-
-    log::debug!(
-        "Compressed HNSW graph links in {:.1?}: {:.1}MB -> {:.1}MB ({:.1}%)",
-        start.elapsed(),
-        original_size as f64 / 1024.0 / 1024.0,
-        new_size as f64 / 1024.0 / 1024.0,
-        new_size as f64 / original_size as f64 * 100.0,
-    );
-
-    Ok(())
-}
-
 self_cell::self_cell! {
     pub struct GraphLinks {
         owner: GraphLinksEnum,
@@ -499,41 +483,37 @@ enum GraphLinksEnum {
 }
 
 impl GraphLinksEnum {
-    fn load_view(&self) -> OperationResult<GraphLinksView> {
+    fn load_view(&self, format: GraphLinksFormat) -> OperationResult<GraphLinksView> {
         let data = match self {
             GraphLinksEnum::Ram(data) => data.as_slice(),
             GraphLinksEnum::Mmap(mmap) => &mmap[..],
         };
-        GraphLinksView::load(data)
+        GraphLinksView::load(data, format)
     }
 }
 
 impl GraphLinks {
-    pub fn load_from_file(path: &Path, on_disk: bool) -> OperationResult<Self> {
-        let file = OpenOptions::new()
-            .read(true)
-            .write(false)
-            .create(false)
-            .open(path)?;
-        if on_disk {
-            let len = file.metadata()?.len();
-            let mut data = Vec::new();
-            data.try_set_capacity_exact(len as usize)?;
-            file.take(len).read_to_end(&mut data)?;
-            Self::try_new(GraphLinksEnum::Ram(data), |x| x.load_view())
-        } else {
-            let mmap = unsafe { Mmap::map(&file)? };
-            madvise::madvise(&mmap, madvise::get_global())?;
-            Self::try_new(GraphLinksEnum::Mmap(Arc::new(mmap)), |x| x.load_view())
-        }
+    pub fn load_from_file(
+        path: &Path,
+        on_disk: bool,
+        format: GraphLinksFormat,
+    ) -> OperationResult<Self> {
+        let populate = !on_disk;
+        let mmap = open_read_mmap(path, AdviceSetting::Advice(Advice::Random), populate)?;
+        Self::try_new(GraphLinksEnum::Mmap(Arc::new(mmap)), |x| {
+            x.load_view(format)
+        })
     }
 
     fn view(&self) -> &GraphLinksView {
         self.borrow_dependent()
     }
 
-    pub fn compressed(&self) -> bool {
-        matches!(self.view().compression, CompressionInfo::Compressed { .. })
+    pub fn format(&self) -> GraphLinksFormat {
+        match self.view().compression {
+            CompressionInfo::Uncompressed { .. } => GraphLinksFormat::Plain,
+            CompressionInfo::Compressed { .. } => GraphLinksFormat::Compressed,
+        }
     }
 
     pub fn on_disk(&self) -> bool {
@@ -633,7 +613,7 @@ mod tests {
     fn compare_links(
         mut left: Vec<Vec<Vec<PointOffsetType>>>,
         mut right: Vec<Vec<Vec<PointOffsetType>>>,
-        compressed: bool,
+        format: GraphLinksFormat,
         m: usize,
         m0: usize,
     ) {
@@ -644,14 +624,15 @@ mod tests {
                     .enumerate()
                     .for_each(|(level_idx, links)| {
                         *links = normalize_links(
-                            if compressed {
-                                if level_idx == 0 {
-                                    m0
-                                } else {
-                                    m
+                            match format {
+                                GraphLinksFormat::Compressed => {
+                                    if level_idx == 0 {
+                                        m0
+                                    } else {
+                                        m
+                                    }
                                 }
-                            } else {
-                                0
+                                GraphLinksFormat::Plain => 0,
                             },
                             std::mem::take(links),
                         );
@@ -666,26 +647,26 @@ mod tests {
         points_count: usize,
         max_levels_count: usize,
         on_disk: bool,
-        compressed: bool,
+        format: GraphLinksFormat,
         m: usize,
         m0: usize,
     ) {
         let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
         let links_file = path.path().join("links.bin");
         let links = random_links(points_count, max_levels_count, m, m0);
-        GraphLinksConverter::new(links.clone(), compressed, m, m0)
+        GraphLinksConverter::new(links.clone(), format, m, m0)
             .save_as(&links_file)
             .unwrap();
-        let cmp_links = GraphLinks::load_from_file(&links_file, on_disk)
+        let cmp_links = GraphLinks::load_from_file(&links_file, on_disk, format)
             .unwrap()
             .into_edges();
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
     }
 
     #[rstest]
-    #[case::uncompressed(false)]
-    #[case::compressed(true)]
-    fn test_graph_links_construction(#[case] compressed: bool) {
+    #[case::uncompressed(GraphLinksFormat::Plain)]
+    #[case::compressed(GraphLinksFormat::Compressed)]
+    fn test_graph_links_construction(#[case] format: GraphLinksFormat) {
         let m = 2;
         let m0 = m * 2;
 
@@ -693,7 +674,7 @@ mod tests {
                               m: usize,
                               m0: usize|
          -> Vec<Vec<Vec<PointOffsetType>>> {
-            GraphLinksConverter::new(links, compressed, m, m0)
+            GraphLinksConverter::new(links, format, m, m0)
                 .to_graph_links_ram()
                 .into_edges()
         };
@@ -701,17 +682,17 @@ mod tests {
         // no points
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // 2 points without any links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![]], vec![vec![]]];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // one link at level 0
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![vec![vec![1]], vec![vec![0]]];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // 3 levels with no links at second level
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -720,7 +701,7 @@ mod tests {
             vec![vec![0, 1], vec![], vec![1]],
         ];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // 3 levels with no links at last level
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -729,7 +710,7 @@ mod tests {
             vec![vec![0, 1]],
         ];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // 4 levels with random nonexistent links
         let links: Vec<Vec<Vec<PointOffsetType>>> = vec![
@@ -740,23 +721,23 @@ mod tests {
             vec![vec![0, 1, 9, 18], vec![1, 5, 6], vec![5], vec![9]],
         ];
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
 
         // fully random links
         let m = 8;
         let m0 = m * 2;
         let links = random_links(100, 10, m, m0);
         let cmp_links = make_cmp_links(links.clone(), m, m0);
-        compare_links(links, cmp_links, compressed, m, m0);
+        compare_links(links, cmp_links, format, m, m0);
     }
 
     #[test]
     fn test_graph_links_mmap_ram_compatibility() {
         let m = 8;
         let m0 = m * 2;
-        test_save_load(1000, 10, true, true, m, m0);
-        test_save_load(1000, 10, false, true, m, m0);
-        test_save_load(1000, 10, true, false, m, m0);
-        test_save_load(1000, 10, false, false, m, m0);
+        test_save_load(1000, 10, true, GraphLinksFormat::Compressed, m, m0);
+        test_save_load(1000, 10, false, GraphLinksFormat::Compressed, m, m0);
+        test_save_load(1000, 10, true, GraphLinksFormat::Plain, m, m0);
+        test_save_load(1000, 10, false, GraphLinksFormat::Plain, m, m0);
     }
 }

commit 3af89000a03f782e7c7dce55c9f6c670558dcfda
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 17 11:21:21 2025 +0000

    Rearrange graph_links.rs (#5788)
    
    - Rename `GraphLinksConverter` to `GraphLinksSerializer`.
    - Extract some structs from `graph_links.rs` into additional files:
      - `graph_links/header.rs`: `HeaderPlain` and `HeaderCompressed`.
      - `graph_links/serializer.rs`: for `GraphLinksSerializer`.
      - `graph_links/view.rs`: `GraphLinksView`.
    - In `header.rs`, remove `HeaderCompressed::version` doc comment about
      `HEADER_VERSION_COMPRESSED` as being outdated after merging #5749.
    - Add doc comment to `GraphLinksView`.
    - In `view.rs`/`GraphLinksView`, move some associated functions to the
      module level:
      - `read_level_offsets`
      - `get_slice`
      - `error_unsufficent_size`

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index e844982e2..e979c9589 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -1,27 +1,20 @@
-use std::cmp::Reverse;
-use std::fs::File;
-use std::io::Write;
-use std::mem::take;
 use std::path::Path;
 use std::sync::Arc;
 
-use common::bitpacking::packed_bits;
-use common::bitpacking_links::{for_each_packed_link, pack_links, MIN_BITS_PER_VALUE};
-use common::bitpacking_ordered;
 use common::types::PointOffsetType;
-use common::zeros::WriteZerosExt as _;
-use itertools::{Either, Itertools as _};
 use memmap2::Mmap;
 use memory::madvise::{Advice, AdviceSetting};
 use memory::mmap_ops;
 use memory::mmap_ops::open_read_mmap;
-use zerocopy::little_endian::U64 as LittleU64;
-use zerocopy::native_endian::U64 as NativeU64;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
 
-use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::operation_error::OperationResult;
 
-pub const MMAP_PANIC_MESSAGE: &str = "Mmap links are not loaded";
+mod header;
+mod serializer;
+mod view;
+
+pub use serializer::GraphLinksSerializer;
+use view::{CompressionInfo, GraphLinksView};
 
 /*
 Links data for whole graph layers.
@@ -55,417 +48,12 @@ for lvl > 0:
 links offset = level_offsets[level] + offsets[reindex[point_id]]
 */
 
-#[derive(Debug)]
-struct GraphLinksView<'a> {
-    reindex: &'a [PointOffsetType],
-    compression: CompressionInfo<'a>,
-    /// Level offsets, copied into RAM for faster access.
-    /// Has at least two elements:
-    /// - `GraphLinksConverter` always writes `0` as the first element.
-    /// - Additional element is added during deserialization.
-    level_offsets: Vec<u64>,
-}
-
-#[derive(Debug)]
-enum CompressionInfo<'a> {
-    Uncompressed {
-        links: &'a [u32],
-        offsets: &'a [NativeU64],
-    },
-    Compressed {
-        compressed_links: &'a [u8],
-        offsets: bitpacking_ordered::Reader<'a>,
-        m: usize,
-        m0: usize,
-        bits_per_unsorted: u8,
-    },
-}
-
 #[derive(Debug, Clone, Copy, Eq, PartialEq)]
 pub enum GraphLinksFormat {
     Plain,
     Compressed,
 }
 
-/// File header for the plain format.
-#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
-#[repr(C)]
-struct HeaderPlain {
-    point_count: u64,
-    levels_count: u64,
-    total_links_count: u64,
-    total_offset_count: u64,
-    /// Either 0 or 4.
-    offsets_padding_bytes: u64,
-    zero_padding: [u8; 24],
-}
-
-/// File header for the compressed format.
-#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
-#[repr(C, align(8))]
-struct HeaderCompressed {
-    point_count: LittleU64,
-    /// Should be [`HEADER_VERSION_COMPRESSED`].
-    ///
-    /// Deliberately placed at the same offset as [`HeaderPlain::levels_count`]
-    /// and set to an impossibly large number to make old Qdrant versions fail
-    /// fast when trying to read the new format.
-    version: LittleU64,
-    levels_count: LittleU64,
-    total_links_bytes: LittleU64,
-    offsets_parameters: bitpacking_ordered::Parameters,
-    m: LittleU64,
-    m0: LittleU64,
-    zero_padding: [u8; 5],
-}
-
-const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;
-
-impl GraphLinksView<'_> {
-    fn load(data: &[u8], format: GraphLinksFormat) -> OperationResult<GraphLinksView> {
-        match format {
-            GraphLinksFormat::Compressed => Self::load_compressed(data),
-            GraphLinksFormat::Plain => Self::load_plain(data),
-        }
-    }
-
-    fn load_plain(data: &[u8]) -> OperationResult<GraphLinksView> {
-        let (header, data) =
-            HeaderPlain::ref_from_prefix(data).map_err(|_| Self::error_unsufficent_size())?;
-        let (level_offsets, data) =
-            Self::read_level_offsets(data, header.levels_count, header.total_offset_count)?;
-        let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count)?;
-        let (links, data) = Self::get_slice::<u32>(data, header.total_links_count)?;
-        let (_, data) = Self::get_slice::<u8>(data, header.offsets_padding_bytes)?;
-        let (offsets, _bytes) = Self::get_slice::<NativeU64>(data, header.total_offset_count)?;
-        Ok(GraphLinksView {
-            reindex,
-            compression: CompressionInfo::Uncompressed { links, offsets },
-            level_offsets,
-        })
-    }
-
-    fn load_compressed(data: &[u8]) -> OperationResult<GraphLinksView> {
-        let (header, data) =
-            HeaderCompressed::ref_from_prefix(data).map_err(|_| Self::error_unsufficent_size())?;
-        debug_assert_eq!(header.version.get(), HEADER_VERSION_COMPRESSED);
-        let (level_offsets, data) = Self::read_level_offsets(
-            data,
-            header.levels_count.get(),
-            header.offsets_parameters.length.get(),
-        )?;
-        let (reindex, data) = Self::get_slice::<PointOffsetType>(data, header.point_count.get())?;
-        let (compressed_links, data) = Self::get_slice::<u8>(data, header.total_links_bytes.get())?;
-        let (offsets, _bytes) = bitpacking_ordered::Reader::new(header.offsets_parameters, data)
-            .map_err(|e| {
-                OperationError::service_error(format!("Can't create decompressor: {e}"))
-            })?;
-        Ok(GraphLinksView {
-            reindex,
-            compression: CompressionInfo::Compressed {
-                compressed_links,
-                offsets,
-                m: header.m.get() as usize,
-                m0: header.m0.get() as usize,
-                bits_per_unsorted: MIN_BITS_PER_VALUE.max(packed_bits(
-                    u32::try_from(header.point_count.get().saturating_sub(1)).map_err(|_| {
-                        OperationError::service_error("Too many points in GraphLinks file")
-                    })?,
-                )),
-            },
-            level_offsets,
-        })
-    }
-
-    fn read_level_offsets(
-        bytes: &[u8],
-        levels_count: u64,
-        total_offset_count: u64,
-    ) -> OperationResult<(Vec<u64>, &[u8])> {
-        let (level_offsets, bytes) = Self::get_slice::<u64>(bytes, levels_count)?;
-        let mut result = Vec::with_capacity(level_offsets.len() + 1);
-        result.extend_from_slice(level_offsets);
-        result.push(total_offset_count.checked_sub(1).ok_or_else(|| {
-            OperationError::service_error(
-                "Total offset count should be at least 1 in GraphLinks file",
-            )
-        })?);
-        Ok((result, bytes))
-    }
-
-    fn get_slice<T: FromBytes + Immutable>(
-        data: &[u8],
-        length: u64,
-    ) -> OperationResult<(&[T], &[u8])> {
-        <[T]>::ref_from_prefix_with_elems(data, length as usize)
-            .map_err(|_| Self::error_unsufficent_size())
-    }
-
-    fn error_unsufficent_size() -> OperationError {
-        OperationError::service_error("Unsufficent file size for GraphLinks file")
-    }
-
-    fn for_each_link(
-        &self,
-        point_id: PointOffsetType,
-        level: usize,
-        f: impl FnMut(PointOffsetType),
-    ) {
-        let idx = if level == 0 {
-            point_id as usize
-        } else {
-            self.level_offsets[level] as usize + self.reindex[point_id as usize] as usize
-        };
-
-        match self.compression {
-            CompressionInfo::Uncompressed { links, offsets } => {
-                let links_range = offsets[idx].get() as usize..offsets[idx + 1].get() as usize;
-                links[links_range].iter().copied().for_each(f)
-            }
-            CompressionInfo::Compressed {
-                compressed_links,
-                ref offsets,
-                m,
-                m0,
-                bits_per_unsorted,
-            } => {
-                let links_range =
-                    offsets.get(idx).unwrap() as usize..offsets.get(idx + 1).unwrap() as usize;
-                for_each_packed_link(
-                    &compressed_links[links_range],
-                    bits_per_unsorted,
-                    if level == 0 { m0 } else { m },
-                    f,
-                );
-            }
-        }
-    }
-
-    fn point_level(&self, point_id: PointOffsetType) -> usize {
-        let reindexed_point_id = u64::from(self.reindex[point_id as usize]);
-        for (level, (&a, &b)) in self
-            .level_offsets
-            .iter()
-            .skip(1)
-            .tuple_windows()
-            .enumerate()
-        {
-            if reindexed_point_id >= b - a {
-                return level;
-            }
-        }
-        // See the doc comment on `level_offsets`.
-        self.level_offsets.len() - 2
-    }
-}
-
-pub struct GraphLinksConverter {
-    m: usize,
-    m0: usize,
-    links: Vec<u8>,
-    kind: GraphLinksConverterKind,
-    reindex: Vec<PointOffsetType>,
-    level_offsets: Vec<u64>,
-}
-
-enum GraphLinksConverterKind {
-    Uncompressed {
-        offsets_padding: usize,
-        offsets: Vec<u64>,
-    },
-    Compressed {
-        compressed_offsets: Vec<u8>,
-        offsets_parameters: bitpacking_ordered::Parameters,
-    },
-}
-
-impl GraphLinksConverter {
-    pub fn new(
-        mut edges: Vec<Vec<Vec<PointOffsetType>>>,
-        format: GraphLinksFormat,
-        m: usize,
-        m0: usize,
-    ) -> Self {
-        // create map from index in `offsets` to point_id
-        let mut back_index: Vec<usize> = (0..edges.len()).collect();
-        // sort by max layer and use this map to build `Self.reindex`
-        back_index.sort_unstable_by_key(|&i| Reverse(edges[i].len()));
-
-        // `reindex` is map from point id to index in `Self.offsets`
-        let mut reindex = vec![0; back_index.len()];
-        for i in 0..back_index.len() {
-            reindex[back_index[i]] = i as PointOffsetType;
-        }
-
-        let levels_count = back_index
-            .first()
-            .map_or(0, |&point_id| edges[point_id].len());
-        let mut point_count_by_level = vec![0; levels_count];
-        for point in &edges {
-            point_count_by_level[point.len() - 1] += 1;
-        }
-
-        let mut total_offsets_len = 0;
-        let mut level_offsets = Vec::with_capacity(levels_count);
-        let mut suffix_sum = point_count_by_level.iter().sum::<u64>();
-        for &value in point_count_by_level.iter() {
-            level_offsets.push(total_offsets_len);
-            total_offsets_len += suffix_sum;
-            suffix_sum -= value;
-        }
-        total_offsets_len += 1;
-
-        let mut links = Vec::new();
-        let mut offsets = Vec::with_capacity(total_offsets_len as usize);
-        offsets.push(0);
-        let bits_per_unsorted = packed_bits(u32::try_from(edges.len().saturating_sub(1)).unwrap())
-            .max(MIN_BITS_PER_VALUE);
-
-        for level in 0..levels_count {
-            let count = point_count_by_level.iter().skip(level).sum::<u64>() as usize;
-            let (sorted_count, iter) = match level {
-                0 => (m0, Either::Left(0..count)),
-                _ => (m, Either::Right(back_index[..count].iter().copied())),
-            };
-            iter.for_each(|id| {
-                let raw_links = take(&mut edges[id][level]);
-                match format {
-                    GraphLinksFormat::Compressed => {
-                        pack_links(&mut links, raw_links, bits_per_unsorted, sorted_count);
-                        offsets.push(links.len() as u64);
-                    }
-                    GraphLinksFormat::Plain => {
-                        links.extend_from_slice(raw_links.as_bytes());
-                        offsets.push((links.len() as u64) / size_of::<PointOffsetType>() as u64);
-                    }
-                }
-            });
-        }
-
-        let kind = match format {
-            GraphLinksFormat::Compressed => {
-                let (compressed_offsets, offsets_parameters) =
-                    bitpacking_ordered::compress(&offsets);
-                GraphLinksConverterKind::Compressed {
-                    compressed_offsets,
-                    offsets_parameters,
-                }
-            }
-            GraphLinksFormat::Plain => {
-                let len = links.len() + reindex.as_bytes().len();
-                GraphLinksConverterKind::Uncompressed {
-                    offsets_padding: len.next_multiple_of(size_of::<u64>()) - len,
-                    offsets,
-                }
-            }
-        };
-
-        Self {
-            m,
-            m0,
-            links,
-            kind,
-            reindex,
-            level_offsets,
-        }
-    }
-
-    pub fn to_graph_links_ram(&self) -> GraphLinks {
-        let format = match &self.kind {
-            GraphLinksConverterKind::Uncompressed { .. } => GraphLinksFormat::Plain,
-            GraphLinksConverterKind::Compressed { .. } => GraphLinksFormat::Compressed,
-        };
-
-        let size = self.level_offsets.as_bytes().len()
-            + self.reindex.as_bytes().len()
-            + self.links.len()
-            + (match &self.kind {
-                GraphLinksConverterKind::Uncompressed {
-                    offsets_padding: padding,
-                    offsets,
-                } => size_of::<HeaderPlain>() + padding + offsets.as_bytes().len(),
-                GraphLinksConverterKind::Compressed {
-                    compressed_offsets,
-                    offsets_parameters: _,
-                } => size_of::<HeaderCompressed>() + compressed_offsets.len(),
-            });
-
-        let mut data = Vec::with_capacity(size);
-        // Unwrap should be the safe as `impl Write` for `Vec` never fails.
-        self.serialize_to_writer(&mut data).unwrap();
-        debug_assert_eq!(data.len(), size);
-        // Unwrap should be safe as we just created the data.
-        GraphLinks::try_new(GraphLinksEnum::Ram(data), |x| x.load_view(format)).unwrap()
-    }
-
-    fn serialize_to_writer(&self, writer: &mut impl Write) -> std::io::Result<()> {
-        match &self.kind {
-            GraphLinksConverterKind::Uncompressed {
-                offsets_padding,
-                offsets,
-            } => {
-                let header = HeaderPlain {
-                    point_count: self.reindex.len() as u64,
-                    levels_count: self.level_offsets.len() as u64,
-                    total_links_count: self.links.len() as u64
-                        / size_of::<PointOffsetType>() as u64,
-                    total_offset_count: offsets.len() as u64,
-                    offsets_padding_bytes: *offsets_padding as u64,
-                    zero_padding: [0; 24],
-                };
-                writer.write_all(header.as_bytes())?;
-            }
-            GraphLinksConverterKind::Compressed {
-                compressed_offsets: _,
-                offsets_parameters,
-            } => {
-                let header = HeaderCompressed {
-                    version: HEADER_VERSION_COMPRESSED.into(),
-                    point_count: LittleU64::new(self.reindex.len() as u64),
-                    total_links_bytes: LittleU64::new(self.links.len() as u64),
-                    offsets_parameters: *offsets_parameters,
-                    levels_count: LittleU64::new(self.level_offsets.len() as u64),
-                    m: LittleU64::new(self.m as u64),
-                    m0: LittleU64::new(self.m0 as u64),
-                    zero_padding: [0; 5],
-                };
-                writer.write_all(header.as_bytes())?;
-            }
-        }
-
-        writer.write_all(self.level_offsets.as_bytes())?;
-        writer.write_all(self.reindex.as_bytes())?;
-        writer.write_all(&self.links)?;
-        match &self.kind {
-            GraphLinksConverterKind::Uncompressed {
-                offsets_padding: padding,
-                offsets,
-            } => {
-                writer.write_zeros(*padding)?;
-                writer.write_all(offsets.as_bytes())?;
-            }
-            GraphLinksConverterKind::Compressed {
-                compressed_offsets,
-                offsets_parameters: _,
-            } => {
-                writer.write_all(compressed_offsets)?;
-            }
-        }
-
-        Ok(())
-    }
-
-    pub fn save_as(&self, path: &Path) -> OperationResult<()> {
-        let temp_path = path.with_extension("tmp");
-        let file = File::create(temp_path.as_path())?;
-        let mut buf = std::io::BufWriter::new(&file);
-        self.serialize_to_writer(&mut buf)?;
-        file.sync_all()?;
-        std::fs::rename(temp_path, path)?;
-        Ok(())
-    }
-}
-
 self_cell::self_cell! {
     pub struct GraphLinks {
         owner: GraphLinksEnum,
@@ -544,7 +132,7 @@ impl GraphLinks {
     }
 
     /// Convert the graph links to a vector of edges, suitable for passing into
-    /// [`GraphLinksConverter::new`] or using in tests.
+    /// [`GraphLinksSerializer::new`] or using in tests.
     pub fn into_edges(self) -> Vec<Vec<Vec<PointOffsetType>>> {
         let mut edges = Vec::with_capacity(self.num_points());
         for point_id in 0..self.num_points() {
@@ -642,7 +230,8 @@ mod tests {
         assert_eq!(left, right);
     }
 
-    /// Test that random links can be saved by `GraphLinksConverter` and loaded correctly by a GraphLinks impl.
+    /// Test that random links can be saved by [`GraphLinksSerializer`] and
+    /// loaded correctly by a [`GraphLinks`] impl.
     fn test_save_load(
         points_count: usize,
         max_levels_count: usize,
@@ -654,7 +243,7 @@ mod tests {
         let path = Builder::new().prefix("graph_dir").tempdir().unwrap();
         let links_file = path.path().join("links.bin");
         let links = random_links(points_count, max_levels_count, m, m0);
-        GraphLinksConverter::new(links.clone(), format, m, m0)
+        GraphLinksSerializer::new(links.clone(), format, m, m0)
             .save_as(&links_file)
             .unwrap();
         let cmp_links = GraphLinks::load_from_file(&links_file, on_disk, format)
@@ -674,7 +263,7 @@ mod tests {
                               m: usize,
                               m0: usize|
          -> Vec<Vec<Vec<PointOffsetType>>> {
-            GraphLinksConverter::new(links, format, m, m0)
+            GraphLinksSerializer::new(links, format, m, m0)
                 .to_graph_links_ram()
                 .into_edges()
         };

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index e979c9589..4fb57e314 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -180,17 +180,17 @@ mod tests {
         m: usize,
         m0: usize,
     ) -> Vec<Vec<Vec<PointOffsetType>>> {
-        let mut rng = rand::thread_rng();
+        let mut rng = rand::rng();
         (0..points_count)
             .map(|_| {
-                let levels_count = rng.gen_range(1..max_levels_count);
+                let levels_count = rng.random_range(1..max_levels_count);
                 (0..levels_count)
                     .map(|level| {
                         let mut max_links_count = if level == 0 { m0 } else { m };
                         max_links_count *= 2; // Simulate additional payload links.
-                        let links_count = rng.gen_range(0..max_links_count);
+                        let links_count = rng.random_range(0..max_links_count);
                         (0..links_count)
-                            .map(|_| rng.gen_range(0..points_count) as PointOffsetType)
+                            .map(|_| rng.random_range(0..points_count) as PointOffsetType)
                             .collect()
                     })
                     .collect()

commit c164adcb820233d0592af31cdf748c8e08b98948
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 31 12:10:16 2025 +0000

    Turn for_each_packed_link into iterator (#5897)
    
    * More cases for `bitpacking_links::tests`
    
    * Turn `for_each_packed_link` into iterator
    
    * Test `check_iterator_fold` and `check_exact_size_iterator_len`
    
    * Drop `for_each_packed_link` and use `iterate_packed_links`
    
    * Introduce `LinksIterator` for `segment`

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 4fb57e314..1368b1689 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -14,7 +14,7 @@ mod serializer;
 mod view;
 
 pub use serializer::GraphLinksSerializer;
-use view::{CompressionInfo, GraphLinksView};
+use view::{CompressionInfo, GraphLinksView, LinksIterator};
 
 /*
 Links data for whole graph layers.
@@ -118,17 +118,16 @@ impl GraphLinks {
         level: usize,
         f: impl FnMut(PointOffsetType),
     ) {
-        self.view().for_each_link(point_id, level, f)
+        self.links(point_id, level).for_each(f);
     }
 
-    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
-        self.view().point_level(point_id)
+    #[inline]
+    pub fn links(&self, point_id: PointOffsetType, level: usize) -> LinksIterator {
+        self.view().links(point_id, level)
     }
 
-    pub fn links_vec(&self, point_id: PointOffsetType, level: usize) -> Vec<PointOffsetType> {
-        let mut links = Vec::new();
-        self.for_each_link(point_id, level, |link| links.push(link));
-        links
+    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
+        self.view().point_level(point_id)
     }
 
     /// Convert the graph links to a vector of edges, suitable for passing into
@@ -139,7 +138,7 @@ impl GraphLinks {
             let num_levels = self.point_level(point_id as PointOffsetType) + 1;
             let mut levels = Vec::with_capacity(num_levels);
             for level in 0..num_levels {
-                levels.push(self.links_vec(point_id as PointOffsetType, level));
+                levels.push(self.links(point_id as PointOffsetType, level).collect());
             }
             edges.push(levels);
         }

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 1368b1689..396168040 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -3,8 +3,7 @@ use std::sync::Arc;
 
 use common::types::PointOffsetType;
 use memmap2::Mmap;
-use memory::madvise::{Advice, AdviceSetting};
-use memory::mmap_ops;
+use memory::madvise::{Advice, AdviceSetting, Madviseable};
 use memory::mmap_ops::open_read_mmap;
 
 use crate::common::operation_error::OperationResult;
@@ -145,14 +144,14 @@ impl GraphLinks {
         edges
     }
 
-    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
+    /// Populate the disk cache with data, if applicable.
+    /// This is a blocking operation.
+    pub fn populate(&self) -> OperationResult<()> {
         match self.borrow_owner() {
-            GraphLinksEnum::Mmap(mmap) => Some(mmap_ops::PrefaultMmapPages::new(
-                Arc::clone(mmap),
-                Some(path.to_owned()),
-            )),
-            GraphLinksEnum::Ram(_) => None,
-        }
+            GraphLinksEnum::Mmap(mmap) => mmap.populate(),
+            GraphLinksEnum::Ram(_) => {}
+        };
+        Ok(())
     }
 }
 

commit 7a1a96e22be04e68ed899c3cd4f0e366f8db327e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 18:56:53 2025 +0000

    Incremental HNSW index building: append-only case  (#6325)
    
    * Pass FeatureFlags into VectorIndexBuildArgs
    
    * Incremental HNSW index building: append-only case
    
    * Use debug_assert
    
    * first_few_ids
    
    * Check deleted_point_count
    
    * Drop unused method

diff --git a/lib/segment/src/index/hnsw_index/graph_links.rs b/lib/segment/src/index/hnsw_index/graph_links.rs
index 396168040..47fc1e2e2 100644
--- a/lib/segment/src/index/hnsw_index/graph_links.rs
+++ b/lib/segment/src/index/hnsw_index/graph_links.rs
@@ -13,7 +13,8 @@ mod serializer;
 mod view;
 
 pub use serializer::GraphLinksSerializer;
-use view::{CompressionInfo, GraphLinksView, LinksIterator};
+pub use view::LinksIterator;
+use view::{CompressionInfo, GraphLinksView};
 
 /*
 Links data for whole graph layers.

