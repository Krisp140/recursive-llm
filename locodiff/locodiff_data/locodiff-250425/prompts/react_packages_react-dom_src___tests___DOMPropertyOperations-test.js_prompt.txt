# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/DOMPropertyOperations-test.js

commit 313611572b6567d229367ed20ff63d1bca8610bb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 19:50:24 2017 +0100

    Reorganize code structure (#11288)
    
    * Move files and tests to more meaningful places
    
    * Fix the build
    
    Now that we import reconciler via react-reconciler, I needed to make a few tweaks.
    
    * Update sizes
    
    * Move @preventMunge directive to FB header
    
    * Revert unintentional change
    
    * Fix Flow coverage
    
    I forgot to @flow-ify those files. This uncovered some issues.
    
    * Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    
    Like a rat in a cage
    Pulling minimum wage
    Prettier, I love you but you're bringing me down
    
    Prettier, you're safer and you're wasting my time
    Our records all show you were filthy but fine
    But they shuttered your stores
    When you opened the doors
    To the cops who were bored once they'd run out of crime
    
    Prettier, you're perfect, oh, please don't change a thing
    Your mild billionaire mayor's now convinced he's a king
    So the boring collect
    I mean all disrespect
    In the neighborhood bars I'd once dreamt I would drink
    
    Prettier, I love you but you're freaking me out
    There's a ton of the twist but we're fresh out of shout
    Like a death in the hall
    That you hear through your wall
    Prettier, I love you but you're freaking me out
    
    Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    Like a death of the heart
    Jesus, where do I start?
    But you're still the one pool where I'd happily drown
    
    And oh! Take me off your mailing list
    For kids who think it still exists
    Yes, for those who think it still exists
    Maybe I'm wrong and maybe you're right
    Maybe I'm wrong and maybe you're right
    Maybe you're right, maybe I'm wrong
    And just maybe you're right
    
    And oh! Maybe mother told you true
    And there'll always be somebody there for you
    And you'll never be alone
    But maybe she's wrong and maybe I'm right
    And just maybe she's wrong
    Maybe she's wrong and maybe I'm right
    And if so, here's this song!

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
new file mode 100644
index 0000000000..7f544506a5
--- /dev/null
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -0,0 +1,173 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+describe('DOMPropertyOperations', () => {
+  var React;
+  var ReactDOM;
+
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+  });
+
+  describe('setValueForProperty', () => {
+    it('should set values as properties by default', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div title="Tip!" />, container);
+      expect(container.firstChild.title).toBe('Tip!');
+    });
+
+    it('should set values as attributes if necessary', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div role="#" />, container);
+      expect(container.firstChild.getAttribute('role')).toBe('#');
+      expect(container.firstChild.role).toBeUndefined();
+    });
+
+    it('should set values as namespace attributes if necessary', () => {
+      var container = document.createElement('svg');
+      ReactDOM.render(<image xlinkHref="about:blank" />, container);
+      expect(
+        container.firstChild.getAttributeNS(
+          'http://www.w3.org/1999/xlink',
+          'href',
+        ),
+      ).toBe('about:blank');
+    });
+
+    it('should set values as boolean properties', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div disabled="disabled" />, container);
+      expect(container.firstChild.getAttribute('disabled')).toBe('');
+      ReactDOM.render(<div disabled={true} />, container);
+      expect(container.firstChild.getAttribute('disabled')).toBe('');
+      ReactDOM.render(<div disabled={false} />, container);
+      expect(container.firstChild.getAttribute('disabled')).toBe(null);
+      ReactDOM.render(<div disabled={true} />, container);
+      ReactDOM.render(<div disabled={null} />, container);
+      expect(container.firstChild.getAttribute('disabled')).toBe(null);
+      ReactDOM.render(<div disabled={true} />, container);
+      ReactDOM.render(<div disabled={undefined} />, container);
+      expect(container.firstChild.getAttribute('disabled')).toBe(null);
+    });
+
+    it('should convert attribute values to string first', () => {
+      // Browsers default to this behavior, but some test environments do not.
+      // This ensures that we have consistent behavior.
+      var obj = {
+        toString: function() {
+          return 'css-class';
+        },
+      };
+
+      var container = document.createElement('div');
+      ReactDOM.render(<div className={obj} />, container);
+      expect(container.firstChild.getAttribute('class')).toBe('css-class');
+    });
+
+    it('should not remove empty attributes for special properties', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<input value="" />, container);
+      expect(container.firstChild.getAttribute('value')).toBe('');
+      expect(container.firstChild.value).toBe('');
+    });
+
+    it('should remove for falsey boolean properties', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div allowFullScreen={false} />, container);
+      expect(container.firstChild.hasAttribute('allowFullScreen')).toBe(false);
+    });
+
+    it('should remove when setting custom attr to null', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div data-foo="bar" />, container);
+      expect(container.firstChild.hasAttribute('data-foo')).toBe(true);
+      ReactDOM.render(<div data-foo={null} />, container);
+      expect(container.firstChild.hasAttribute('data-foo')).toBe(false);
+    });
+
+    it('should set className to empty string instead of null', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div className="selected" />, container);
+      expect(container.firstChild.className).toBe('selected');
+      ReactDOM.render(<div className={null} />, container);
+      // className should be '', not 'null' or null (which becomes 'null' in
+      // some browsers)
+      expect(container.firstChild.className).toBe('');
+      expect(container.firstChild.getAttribute('class')).toBe(null);
+    });
+
+    it('should remove property properly for boolean properties', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div hidden={true} />, container);
+      expect(container.firstChild.hasAttribute('hidden')).toBe(true);
+      ReactDOM.render(<div hidden={false} />, container);
+      expect(container.firstChild.hasAttribute('hidden')).toBe(false);
+    });
+  });
+
+  describe('value mutation method', function() {
+    it('should update an empty attribute to zero', function() {
+      var container = document.createElement('div');
+      ReactDOM.render(
+        <input type="radio" value="" onChange={function() {}} />,
+        container,
+      );
+      spyOn(container.firstChild, 'setAttribute');
+      ReactDOM.render(
+        <input type="radio" value={0} onChange={function() {}} />,
+        container,
+      );
+      expect(container.firstChild.setAttribute.calls.count()).toBe(1);
+    });
+
+    it('should always assign the value attribute for non-inputs', function() {
+      var container = document.createElement('div');
+      ReactDOM.render(<progress />, container);
+      spyOn(container.firstChild, 'setAttribute');
+      ReactDOM.render(<progress value={30} />, container);
+      ReactDOM.render(<progress value="30" />, container);
+      expect(container.firstChild.setAttribute.calls.count()).toBe(2);
+    });
+  });
+
+  describe('deleteValueForProperty', () => {
+    it('should remove attributes for normal properties', () => {
+      var container = document.createElement('div');
+      ReactDOM.render(<div title="foo" />, container);
+      expect(container.firstChild.getAttribute('title')).toBe('foo');
+      ReactDOM.render(<div />, container);
+      expect(container.firstChild.getAttribute('title')).toBe(null);
+    });
+
+    it('should not remove attributes for special properties', () => {
+      var container = document.createElement('div');
+      spyOn(console, 'error');
+      ReactDOM.render(
+        <input type="text" value="foo" onChange={function() {}} />,
+        container,
+      );
+      expect(container.firstChild.getAttribute('value')).toBe('foo');
+      expect(container.firstChild.value).toBe('foo');
+      ReactDOM.render(
+        <input type="text" onChange={function() {}} />,
+        container,
+      );
+      expect(container.firstChild.getAttribute('value')).toBe('foo');
+      expect(container.firstChild.value).toBe('foo');
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'A component is changing a controlled input of type text to be uncontrolled',
+      );
+    });
+  });
+});

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 7f544506a5..343adc0531 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -151,7 +151,7 @@ describe('DOMPropertyOperations', () => {
 
     it('should not remove attributes for special properties', () => {
       var container = document.createElement('div');
-      spyOn(console, 'error');
+      spyOnDev(console, 'error');
       ReactDOM.render(
         <input type="text" value="foo" onChange={function() {}} />,
         container,
@@ -164,10 +164,12 @@ describe('DOMPropertyOperations', () => {
       );
       expect(container.firstChild.getAttribute('value')).toBe('foo');
       expect(container.firstChild.value).toBe('foo');
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'A component is changing a controlled input of type text to be uncontrolled',
-      );
+      if (__DEV__) {
+        expect(console.error.calls.count()).toBe(1);
+        expect(console.error.calls.argsFor(0)[0]).toContain(
+          'A component is changing a controlled input of type text to be uncontrolled',
+        );
+      }
     });
   });
 });

commit 53ab1948b5bb1da29f121d7f32afa0bea42bffd0
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Nov 28 14:06:26 2017 -0800

    Blacklist spyOn(). Add explicit spyOnProd() and spyOnDevAndProd() (#11691)
    
    * Blacklist spyOn(). Add explicit spyOnProd() and spyOnDevAndProd()
    
    * Wording tweak.
    
    * Fixed lint no-shadow warning

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 343adc0531..7c53588314 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -122,7 +122,7 @@ describe('DOMPropertyOperations', () => {
         <input type="radio" value="" onChange={function() {}} />,
         container,
       );
-      spyOn(container.firstChild, 'setAttribute');
+      spyOnDevAndProd(container.firstChild, 'setAttribute');
       ReactDOM.render(
         <input type="radio" value={0} onChange={function() {}} />,
         container,
@@ -133,7 +133,7 @@ describe('DOMPropertyOperations', () => {
     it('should always assign the value attribute for non-inputs', function() {
       var container = document.createElement('div');
       ReactDOM.render(<progress />, container);
-      spyOn(container.firstChild, 'setAttribute');
+      spyOnDevAndProd(container.firstChild, 'setAttribute');
       ReactDOM.render(<progress value={30} />, container);
       ReactDOM.render(<progress value="30" />, container);
       expect(container.firstChild.setAttribute.calls.count()).toBe(2);

commit 48616e591fe23c0b89b0823c3ec99bae2d7b6853
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Tue Dec 5 16:29:22 2017 -0200

    react-dom: convert packages/react-dom/src/__tests__ (#11776)

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 7c53588314..8cdf53f1c4 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -10,8 +10,8 @@
 'use strict';
 
 describe('DOMPropertyOperations', () => {
-  var React;
-  var ReactDOM;
+  let React;
+  let ReactDOM;
 
   beforeEach(() => {
     jest.resetModules();
@@ -21,20 +21,20 @@ describe('DOMPropertyOperations', () => {
 
   describe('setValueForProperty', () => {
     it('should set values as properties by default', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div title="Tip!" />, container);
       expect(container.firstChild.title).toBe('Tip!');
     });
 
     it('should set values as attributes if necessary', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div role="#" />, container);
       expect(container.firstChild.getAttribute('role')).toBe('#');
       expect(container.firstChild.role).toBeUndefined();
     });
 
     it('should set values as namespace attributes if necessary', () => {
-      var container = document.createElement('svg');
+      const container = document.createElement('svg');
       ReactDOM.render(<image xlinkHref="about:blank" />, container);
       expect(
         container.firstChild.getAttributeNS(
@@ -45,7 +45,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should set values as boolean properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div disabled="disabled" />, container);
       expect(container.firstChild.getAttribute('disabled')).toBe('');
       ReactDOM.render(<div disabled={true} />, container);
@@ -63,32 +63,32 @@ describe('DOMPropertyOperations', () => {
     it('should convert attribute values to string first', () => {
       // Browsers default to this behavior, but some test environments do not.
       // This ensures that we have consistent behavior.
-      var obj = {
+      const obj = {
         toString: function() {
           return 'css-class';
         },
       };
 
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div className={obj} />, container);
       expect(container.firstChild.getAttribute('class')).toBe('css-class');
     });
 
     it('should not remove empty attributes for special properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<input value="" />, container);
       expect(container.firstChild.getAttribute('value')).toBe('');
       expect(container.firstChild.value).toBe('');
     });
 
     it('should remove for falsey boolean properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div allowFullScreen={false} />, container);
       expect(container.firstChild.hasAttribute('allowFullScreen')).toBe(false);
     });
 
     it('should remove when setting custom attr to null', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div data-foo="bar" />, container);
       expect(container.firstChild.hasAttribute('data-foo')).toBe(true);
       ReactDOM.render(<div data-foo={null} />, container);
@@ -96,7 +96,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should set className to empty string instead of null', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div className="selected" />, container);
       expect(container.firstChild.className).toBe('selected');
       ReactDOM.render(<div className={null} />, container);
@@ -107,7 +107,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should remove property properly for boolean properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div hidden={true} />, container);
       expect(container.firstChild.hasAttribute('hidden')).toBe(true);
       ReactDOM.render(<div hidden={false} />, container);
@@ -117,7 +117,7 @@ describe('DOMPropertyOperations', () => {
 
   describe('value mutation method', function() {
     it('should update an empty attribute to zero', function() {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(
         <input type="radio" value="" onChange={function() {}} />,
         container,
@@ -131,7 +131,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should always assign the value attribute for non-inputs', function() {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<progress />, container);
       spyOnDevAndProd(container.firstChild, 'setAttribute');
       ReactDOM.render(<progress value={30} />, container);
@@ -142,7 +142,7 @@ describe('DOMPropertyOperations', () => {
 
   describe('deleteValueForProperty', () => {
     it('should remove attributes for normal properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       ReactDOM.render(<div title="foo" />, container);
       expect(container.firstChild.getAttribute('title')).toBe('foo');
       ReactDOM.render(<div />, container);
@@ -150,7 +150,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should not remove attributes for special properties', () => {
-      var container = document.createElement('div');
+      const container = document.createElement('div');
       spyOnDev(console, 'error');
       ReactDOM.render(
         <input type="text" value="foo" onChange={function() {}} />,

commit b5334a44e99c32ca26f7d65ca8312e13f7b7f4b7
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Jan 2 11:06:41 2018 -0800

    toWarnInDev matcher; throw on unexpected console.error (#11786)
    
    * Added toWarnInDev matcher and connected to 1 test
    * Added .toLowPriorityWarnDev() matcher
    * Reply Jest spy with custom spy. Unregister spy after toWarnDev() so unexpected console.error/warn calls will fail tests.
    * console warn/error throws immediately in tests by default (if not spied on)
    * Pass-thru console message before erroring to make it easier to identify
    * More robustly handle unexpected warnings within try/catch
    * Error message includes remaining expected warnings in addition to unexpected warning

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 8cdf53f1c4..bb7ce8ca54 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -151,25 +151,22 @@ describe('DOMPropertyOperations', () => {
 
     it('should not remove attributes for special properties', () => {
       const container = document.createElement('div');
-      spyOnDev(console, 'error');
       ReactDOM.render(
         <input type="text" value="foo" onChange={function() {}} />,
         container,
       );
       expect(container.firstChild.getAttribute('value')).toBe('foo');
       expect(container.firstChild.value).toBe('foo');
-      ReactDOM.render(
-        <input type="text" onChange={function() {}} />,
-        container,
+      expect(() =>
+        ReactDOM.render(
+          <input type="text" onChange={function() {}} />,
+          container,
+        ),
+      ).toWarnDev(
+        'A component is changing a controlled input of type text to be uncontrolled',
       );
       expect(container.firstChild.getAttribute('value')).toBe('foo');
       expect(container.firstChild.value).toBe('foo');
-      if (__DEV__) {
-        expect(console.error.calls.count()).toBe(1);
-        expect(console.error.calls.argsFor(0)[0]).toContain(
-          'A component is changing a controlled input of type text to be uncontrolled',
-        );
-      }
     });
   });
 });

commit d289d4b634749861199556e42174a3f4a3ce2b16
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 4 18:57:30 2018 +0000

    Update to Jest 22 (#11956)
    
    * Bump deps to Jest 22
    
    * Prevent jsdom from logging intentionally thrown errors
    
    This relies on our existing special field that we use to mute errors.
    Perhaps, it would be better to instead rely on preventDefault() directly.
    I outlined a possible strategy here: https://github.com/facebook/react/issues/11098#issuecomment-355032539
    
    * Update snapshots
    
    * Mock out a method called by ReactART that now throws
    
    * Calling .click() no longer works, dispatch event instead
    
    * Fix incorrect SVG element creation in test
    
    * Render SVG elements inside <svg> to avoid extra warnings
    
    * Fix range input test to use numeric value
    
    * Fix creating SVG element in test
    
    * Replace brittle test that relied on jsdom behavior
    
    The test passed in jsdom due to its implementation details.
    
    The original intention was to test the mutation method, but it was removed a while ago.
    
    Following @nhunzaker's suggestion, I moved the tests to ReactDOMInput and adjusted them to not rely on implementation details.
    
    * Add a workaround for the expected extra client-side warning
    
    This is a bit ugly but it's just two places. I think we can live with this.
    
    * Only warn once for mismatches caused by bad attribute casing
    
    We used to warn both about bad casing and about a mismatch.
    The mismatch warning was a bit confusing. We didn't know we warned twice because jsdom didn't faithfully emulate SVG.
    
    This changes the behavior to only leave the warning about bad casing if that's what caused the mismatch.
    It also adjusts the test to have an expectation that matches the real world behavior.
    
    * Add an expected warning per comment in the same test

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index bb7ce8ca54..aabb3e995f 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -34,7 +34,10 @@ describe('DOMPropertyOperations', () => {
     });
 
     it('should set values as namespace attributes if necessary', () => {
-      const container = document.createElement('svg');
+      const container = document.createElementNS(
+        'http://www.w3.org/2000/svg',
+        'svg',
+      );
       ReactDOM.render(<image xlinkHref="about:blank" />, container);
       expect(
         container.firstChild.getAttributeNS(
@@ -113,22 +116,6 @@ describe('DOMPropertyOperations', () => {
       ReactDOM.render(<div hidden={false} />, container);
       expect(container.firstChild.hasAttribute('hidden')).toBe(false);
     });
-  });
-
-  describe('value mutation method', function() {
-    it('should update an empty attribute to zero', function() {
-      const container = document.createElement('div');
-      ReactDOM.render(
-        <input type="radio" value="" onChange={function() {}} />,
-        container,
-      );
-      spyOnDevAndProd(container.firstChild, 'setAttribute');
-      ReactDOM.render(
-        <input type="radio" value={0} onChange={function() {}} />,
-        container,
-      );
-      expect(container.firstChild.setAttribute.calls.count()).toBe(1);
-    });
 
     it('should always assign the value attribute for non-inputs', function() {
       const container = document.createElement('div');

commit dcc854bcc3c940ca583565ce25200ca618c05bf0
Author: Airam <airamrguez@users.noreply.github.com>
Date:   Sat Apr 28 21:52:30 2018 +0200

    prevent removing attributes on custom component tags (#12702)

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index aabb3e995f..08874222d5 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -155,5 +155,11 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.getAttribute('value')).toBe('foo');
       expect(container.firstChild.value).toBe('foo');
     });
+
+    it('should not remove attributes for custom component tag', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(<my-icon size="5px" />, container);
+      expect(container.firstChild.getAttribute('size')).toBe('5px');
+    });
   });
 });

commit aa85b0fd5ffc92de38720c29833a54c67285abfb
Author: Simen Bekkhus <sbekkhus91@gmail.com>
Date:   Tue May 29 00:03:15 2018 +0200

    Upgrade to Jest 23 (#12894)
    
    * Upgrade to Jest 23 beta
    
    * prefer `.toHaveBeenCalledTimes`
    
    * 23 stable

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 08874222d5..1fba16247e 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -123,7 +123,7 @@ describe('DOMPropertyOperations', () => {
       spyOnDevAndProd(container.firstChild, 'setAttribute');
       ReactDOM.render(<progress value={30} />, container);
       ReactDOM.render(<progress value="30" />, container);
-      expect(container.firstChild.setAttribute.calls.count()).toBe(2);
+      expect(container.firstChild.setAttribute).toHaveBeenCalledTimes(2);
     });
   });
 

commit 171e0b7d447a20b7cc90808a95478c6e5b8b6af0
Author: Nicole Levy <seriff@protonmail.com>
Date:   Tue Jul 17 17:46:43 2018 -0400

    Fix â€œno onChange handlerâ€ warning to fire on falsy values ("", 0, false) too (#12628)
    
    * throw warning for falsey `value` prop
    
    * add nop onChange handler to tests for `value` prop
    
    * prettier
    
    * check for falsey checked
    
    * fix tests for `checked` prop
    
    * new tests for `value` prop
    
    * test formatting
    
    * forgot 0 (:
    
    * test for falsey `checked` prop
    
    * add null check
    
    * Update ReactDOMInput-test.js
    
    * revert unneeded change
    
    * prettier
    
    * Update DOMPropertyOperations-test.js
    
    * Update ReactDOMInput-test.js
    
    * Update ReactDOMSelect-test.js
    
    * Fixes and tests
    
    * Remove unnecessary changes

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 1fba16247e..56319c95d7 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -79,7 +79,7 @@ describe('DOMPropertyOperations', () => {
 
     it('should not remove empty attributes for special properties', () => {
       const container = document.createElement('div');
-      ReactDOM.render(<input value="" />, container);
+      ReactDOM.render(<input value="" onChange={() => {}} />, container);
       expect(container.firstChild.getAttribute('value')).toBe('');
       expect(container.firstChild.value).toBe('');
     });

commit f943423231f7b82d3502d237580786a57324bead
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Aug 31 15:54:39 2018 +0100

    Add a more precise regression test for #6219

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 56319c95d7..c70bc06a25 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -77,13 +77,25 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.getAttribute('class')).toBe('css-class');
     });
 
-    it('should not remove empty attributes for special properties', () => {
+    it('should not remove empty attributes for special input properties', () => {
       const container = document.createElement('div');
       ReactDOM.render(<input value="" onChange={() => {}} />, container);
       expect(container.firstChild.getAttribute('value')).toBe('');
       expect(container.firstChild.value).toBe('');
     });
 
+    it('should not remove empty attributes for special option properties', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(
+        <select>
+          <option value="">empty</option>
+        </select>,
+        container,
+      );
+      // Regression test for https://github.com/facebook/react/issues/6219
+      expect(container.firstChild.firstChild.value).toBe('');
+    });
+
     it('should remove for falsey boolean properties', () => {
       const container = document.createElement('div');
       ReactDOM.render(<div allowFullScreen={false} />, container);

commit 0f050ad7cccfc15323dc58c630dbc0963ff15285
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Aug 31 15:57:02 2018 +0100

    Make regression test better

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index c70bc06a25..b42e4a7b1a 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -89,11 +89,13 @@ describe('DOMPropertyOperations', () => {
       ReactDOM.render(
         <select>
           <option value="">empty</option>
+          <option>filled</option>
         </select>,
         container,
       );
       // Regression test for https://github.com/facebook/react/issues/6219
       expect(container.firstChild.firstChild.value).toBe('');
+      expect(container.firstChild.lastChild.value).toBe('filled');
     });
 
     it('should remove for falsey boolean properties', () => {

commit 0d3fc9de1019fcc69d3be0add555ea47f364059c
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Fri Aug 31 16:09:29 2018 +0100

    Add regression test for #6119

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index b42e4a7b1a..c4438a3bdd 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -139,6 +139,15 @@ describe('DOMPropertyOperations', () => {
       ReactDOM.render(<progress value="30" />, container);
       expect(container.firstChild.setAttribute).toHaveBeenCalledTimes(2);
     });
+
+    it('should return the progress to intermediate state on null value', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(<progress value={30} />, container);
+      ReactDOM.render(<progress value={null} />, container);
+      // Ensure we move progress back to an indeterminate state.
+      // Regression test for https://github.com/facebook/react/issues/6119
+      expect(container.firstChild.hasAttribute('value')).toBe(false);
+    });
   });
 
   describe('deleteValueForProperty', () => {

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: HÃ©ctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index c4438a3bdd..3f6e0ff8a8 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit a079011f95033758c17f1d7c2ee44d9cc80623f2
Author: Nathan Hunzaker <nate.hunzaker@gmail.com>
Date:   Wed Sep 12 11:29:23 2018 -0700

    ðŸ”¥ Stop syncing the value attribute on inputs (behind a feature flag) (#13526)
    
    * :fire: Stop syncing the value attribute on inputs
    
    * Eliminate some additional checks
    
    * Remove initialValue and initialWrapper from wrapperState flow type
    
    * Update tests with new sync logic, reduce some operations
    
    * Update tests, add some caveats for SSR mismatches
    
    * Revert newline change
    
    * Remove unused type
    
    * Call toString to safely type string values
    
    * Add disableInputAttributeSyncing feature flag
    
    Reverts tests to original state, adds attribute sync feature flag,
    then moves all affected tests to ReactFire-test.js.
    
    * Revert position of types in toStringValues
    
    * Invert flag on number input blur
    
    * Add clarification why double blur is necessary
    
    * Update ReactFire number cases to be more explicite about blur
    
    * Move comments to reduce diff size
    
    * Add comments to clarify behavior in each branch
    
    * There is no need to assign a different checked behavior in Fire
    
    * Use checked reference
    
    * Format
    
    * Avoid precomputing stringable values
    
    * Revert getToStringValue comment
    
    * Revert placement of undefined in getToStringValue
    
    * Do not eagerly stringify value
    
    * Unify Fire test cases with normal ones
    
    * Revert toString change. Only assign unsynced values when not nully

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 3f6e0ff8a8..16821b1b3f 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -9,6 +9,9 @@
 
 'use strict';
 
+// Set by `yarn test-fire`.
+const {disableInputAttributeSyncing} = require('shared/ReactFeatureFlags');
+
 describe('DOMPropertyOperations', () => {
   let React;
   let ReactDOM;
@@ -80,7 +83,11 @@ describe('DOMPropertyOperations', () => {
     it('should not remove empty attributes for special input properties', () => {
       const container = document.createElement('div');
       ReactDOM.render(<input value="" onChange={() => {}} />, container);
-      expect(container.firstChild.getAttribute('value')).toBe('');
+      if (disableInputAttributeSyncing) {
+        expect(container.firstChild.hasAttribute('value')).toBe(false);
+      } else {
+        expect(container.firstChild.getAttribute('value')).toBe('');
+      }
       expect(container.firstChild.value).toBe('');
     });
 
@@ -165,7 +172,11 @@ describe('DOMPropertyOperations', () => {
         <input type="text" value="foo" onChange={function() {}} />,
         container,
       );
-      expect(container.firstChild.getAttribute('value')).toBe('foo');
+      if (disableInputAttributeSyncing) {
+        expect(container.firstChild.hasAttribute('value')).toBe(false);
+      } else {
+        expect(container.firstChild.getAttribute('value')).toBe('foo');
+      }
       expect(container.firstChild.value).toBe('foo');
       expect(() =>
         ReactDOM.render(
@@ -175,7 +186,11 @@ describe('DOMPropertyOperations', () => {
       ).toWarnDev(
         'A component is changing a controlled input of type text to be uncontrolled',
       );
-      expect(container.firstChild.getAttribute('value')).toBe('foo');
+      if (disableInputAttributeSyncing) {
+        expect(container.firstChild.hasAttribute('value')).toBe(false);
+      } else {
+        expect(container.firstChild.getAttribute('value')).toBe('foo');
+      }
       expect(container.firstChild.value).toBe('foo');
     });
 

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 16821b1b3f..c5536129b5 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -183,7 +183,7 @@ describe('DOMPropertyOperations', () => {
           <input type="text" onChange={function() {}} />,
           container,
         ),
-      ).toWarnDev(
+      ).toErrorDev(
         'A component is changing a controlled input of type text to be uncontrolled',
       );
       if (disableInputAttributeSyncing) {

commit 03de849af03996b7477420c97de7741ce1214149
Author: Carl Vitullo <vcarl@users.noreply.github.com>
Date:   Tue Apr 7 18:19:56 2020 -0400

    Make uncontrolled -> controlled warning clearer (#17070)
    
    * Make uncontrolled -> controlled warning clearer
    
    * Update phrasing, mirror for opposite direction
    
    * Remove unused substitution
    
    * Update warning tests
    
    * Literally got these backwards, womp womp
    
    * Rerere-fix tests

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index c5536129b5..2959274d1c 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -184,7 +184,7 @@ describe('DOMPropertyOperations', () => {
           container,
         ),
       ).toErrorDev(
-        'A component is changing a controlled input of type text to be uncontrolled',
+        'A component is changing a controlled input to be uncontrolled',
       );
       if (disableInputAttributeSyncing) {
         expect(container.firstChild.hasAttribute('value')).toBe(false);

commit 24dd07bd269590ee5024b7f0f1906887d256ea86
Author: Joey Arhar <josepharhar@gmail.com>
Date:   Wed Dec 8 07:11:42 2021 -0800

    Add custom element property support behind a flag (#22184)
    
    * custom element props
    
    * custom element events
    
    * use function type for on*
    
    * tests, htmlFor
    
    * className
    
    * fix ReactDOMComponent-test
    
    * started on adding feature flag
    
    * added feature flag to all feature flag files
    
    * everything passes
    
    * tried to fix getPropertyInfo
    
    * used @gate and __experimental__
    
    * remove flag gating for test which already passes
    
    * fix onClick test
    
    * add __EXPERIMENTAL__ to www flags, rename eventProxy
    
    * Add innerText and textContent to reservedProps
    
    * Emit warning when assigning to read only properties in client
    
    * Revert "Emit warning when assigning to read only properties in client"
    
    This reverts commit 1a093e584ce50e2e634aa743e04f9cb8fc2b3f7d.
    
    * Emit warning when assigning to read only properties during hydration
    
    * yarn prettier-all
    
    * Gate hydration warning test on flag
    
    * Fix gating in hydration warning test
    
    * Fix assignment to boolean properties
    
    * Replace _listeners with random suffix matching
    
    * Improve gating for hydration warning test
    
    * Add outerText and outerHTML to server warning properties
    
    * remove nameLower logic
    
    * fix capture event listener test
    
    * Add coverage for changing custom event listeners
    
    * yarn prettier-all
    
    * yarn lint --fix
    
    * replace getCustomElementEventHandlersFromNode with getFiberCurrentPropsFromNode
    
    * Remove previous value when adding event listener
    
    * flow, lint, prettier
    
    * Add dispatchEvent to make sure nothing crashes
    
    * Add state change to reserved attribute tests
    
    * Add missing feature flag test gate
    
    * Reimplement SSR changes in ReactDOMServerFormatConfig
    
    * Test hydration for objects and functions
    
    * add missing test gate
    
    * remove extraneous comment
    
    * Add attribute->property test

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 2959274d1c..28776b1eb6 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -155,6 +155,355 @@ describe('DOMPropertyOperations', () => {
       // Regression test for https://github.com/facebook/react/issues/6119
       expect(container.firstChild.hasAttribute('value')).toBe(false);
     });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element custom events lowercase', () => {
+      const oncustomevent = jest.fn();
+      function Test() {
+        return <my-custom-element oncustomevent={oncustomevent} />;
+      }
+      const container = document.createElement('div');
+      ReactDOM.render(<Test />, container);
+      container
+        .querySelector('my-custom-element')
+        .dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element custom events uppercase', () => {
+      const oncustomevent = jest.fn();
+      function Test() {
+        return <my-custom-element onCustomevent={oncustomevent} />;
+      }
+      const container = document.createElement('div');
+      ReactDOM.render(<Test />, container);
+      container
+        .querySelector('my-custom-element')
+        .dispatchEvent(new Event('Customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element custom event with dash in name', () => {
+      const oncustomevent = jest.fn();
+      function Test() {
+        return <my-custom-element oncustom-event={oncustomevent} />;
+      }
+      const container = document.createElement('div');
+      ReactDOM.render(<Test />, container);
+      container
+        .querySelector('my-custom-element')
+        .dispatchEvent(new Event('custom-event'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element remove event handler', () => {
+      const oncustomevent = jest.fn();
+      function Test(props) {
+        return <my-custom-element oncustomevent={props.handler} />;
+      }
+
+      const container = document.createElement('div');
+      ReactDOM.render(<Test handler={oncustomevent} />, container);
+      const customElement = container.querySelector('my-custom-element');
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+
+      ReactDOM.render(<Test handler={false} />, container);
+      // Make sure that the second render didn't create a new element. We want
+      // to make sure removeEventListener actually gets called on the same element.
+      expect(customElement).toBe(customElement);
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+
+      ReactDOM.render(<Test handler={oncustomevent} />, container);
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(2);
+
+      const oncustomevent2 = jest.fn();
+      ReactDOM.render(<Test handler={oncustomevent2} />, container);
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(2);
+      expect(oncustomevent2).toHaveBeenCalledTimes(1);
+    });
+
+    it('custom elements shouldnt have non-functions for on* attributes treated as event listeners', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(
+        <my-custom-element
+          onstring={'hello'}
+          onobj={{hello: 'world'}}
+          onarray={['one', 'two']}
+          ontrue={true}
+          onfalse={false}
+        />,
+        container,
+      );
+      const customElement = container.querySelector('my-custom-element');
+      expect(customElement.getAttribute('onstring')).toBe('hello');
+      expect(customElement.getAttribute('onobj')).toBe('[object Object]');
+      expect(customElement.getAttribute('onarray')).toBe('one,two');
+      expect(customElement.getAttribute('ontrue')).toBe('true');
+      expect(customElement.getAttribute('onfalse')).toBe('false');
+
+      // Dispatch the corresponding event names to make sure that nothing crashes.
+      customElement.dispatchEvent(new Event('string'));
+      customElement.dispatchEvent(new Event('obj'));
+      customElement.dispatchEvent(new Event('array'));
+      customElement.dispatchEvent(new Event('true'));
+      customElement.dispatchEvent(new Event('false'));
+    });
+
+    it('custom elements should still have onClick treated like regular elements', () => {
+      let syntheticClickEvent = null;
+      const syntheticEventHandler = jest.fn(
+        event => (syntheticClickEvent = event),
+      );
+      let nativeClickEvent = null;
+      const nativeEventHandler = jest.fn(event => (nativeClickEvent = event));
+      function Test() {
+        return <my-custom-element onClick={syntheticEventHandler} />;
+      }
+
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<Test />, container);
+
+      const customElement = container.querySelector('my-custom-element');
+      customElement.onclick = nativeEventHandler;
+      container.querySelector('my-custom-element').click();
+
+      expect(nativeEventHandler).toHaveBeenCalledTimes(1);
+      expect(syntheticEventHandler).toHaveBeenCalledTimes(1);
+      expect(syntheticClickEvent.nativeEvent).toBe(nativeClickEvent);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom elements should allow custom events with capture event listeners', () => {
+      const oncustomeventCapture = jest.fn();
+      const oncustomevent = jest.fn();
+      function Test() {
+        return (
+          <my-custom-element
+            oncustomeventCapture={oncustomeventCapture}
+            oncustomevent={oncustomevent}>
+            <div />
+          </my-custom-element>
+        );
+      }
+      const container = document.createElement('div');
+      ReactDOM.render(<Test />, container);
+      container
+        .querySelector('my-custom-element > div')
+        .dispatchEvent(new Event('customevent', {bubbles: false}));
+      expect(oncustomeventCapture).toHaveBeenCalledTimes(1);
+      expect(oncustomevent).toHaveBeenCalledTimes(0);
+    });
+
+    it('innerHTML should not work on custom elements', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(<my-custom-element innerHTML="foo" />, container);
+      const customElement = container.querySelector('my-custom-element');
+      expect(customElement.getAttribute('innerHTML')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+
+      // Render again to verify the update codepath doesn't accidentally let
+      // something through.
+      ReactDOM.render(<my-custom-element innerHTML="bar" />, container);
+      expect(customElement.getAttribute('innerHTML')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('innerText should not work on custom elements', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(<my-custom-element innerText="foo" />, container);
+      const customElement = container.querySelector('my-custom-element');
+      expect(customElement.getAttribute('innerText')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+
+      // Render again to verify the update codepath doesn't accidentally let
+      // something through.
+      ReactDOM.render(<my-custom-element innerText="bar" />, container);
+      expect(customElement.getAttribute('innerText')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('textContent should not work on custom elements', () => {
+      const container = document.createElement('div');
+      ReactDOM.render(<my-custom-element textContent="foo" />, container);
+      const customElement = container.querySelector('my-custom-element');
+      expect(customElement.getAttribute('textContent')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+
+      // Render again to verify the update codepath doesn't accidentally let
+      // something through.
+      ReactDOM.render(<my-custom-element textContent="bar" />, container);
+      expect(customElement.getAttribute('textContent')).toBe(null);
+      expect(customElement.hasChildNodes()).toBe(false);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('values should not be converted to booleans when assigning into custom elements', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element />, container);
+      const customElement = container.querySelector('my-custom-element');
+      customElement.foo = null;
+
+      // true => string
+      ReactDOM.render(<my-custom-element foo={true} />, container);
+      expect(customElement.foo).toBe(true);
+      ReactDOM.render(<my-custom-element foo="bar" />, container);
+      expect(customElement.foo).toBe('bar');
+
+      // false => string
+      ReactDOM.render(<my-custom-element foo={false} />, container);
+      expect(customElement.foo).toBe(false);
+      ReactDOM.render(<my-custom-element foo="bar" />, container);
+      expect(customElement.foo).toBe('bar');
+
+      // true => null
+      ReactDOM.render(<my-custom-element foo={true} />, container);
+      expect(customElement.foo).toBe(true);
+      ReactDOM.render(<my-custom-element foo={null} />, container);
+      expect(customElement.foo).toBe(null);
+
+      // false => null
+      ReactDOM.render(<my-custom-element foo={false} />, container);
+      expect(customElement.foo).toBe(false);
+      ReactDOM.render(<my-custom-element foo={null} />, container);
+      expect(customElement.foo).toBe(null);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element custom event handlers assign multiple types', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const oncustomevent = jest.fn();
+
+      // First render with string
+      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      const customelement = container.querySelector('my-custom-element');
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(0);
+      expect(customelement.oncustomevent).toBe(undefined);
+      expect(customelement.getAttribute('oncustomevent')).toBe('foo');
+
+      // string => event listener
+      ReactDOM.render(
+        <my-custom-element oncustomevent={oncustomevent} />,
+        container,
+      );
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+      expect(customelement.oncustomevent).toBe(undefined);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+
+      // event listener => string
+      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+      expect(customelement.oncustomevent).toBe(undefined);
+      expect(customelement.getAttribute('oncustomevent')).toBe('foo');
+
+      // string => nothing
+      ReactDOM.render(<my-custom-element />, container);
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+      expect(customelement.oncustomevent).toBe(undefined);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+
+      // nothing => event listener
+      ReactDOM.render(
+        <my-custom-element oncustomevent={oncustomevent} />,
+        container,
+      );
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(2);
+      expect(customelement.oncustomevent).toBe(undefined);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element custom event handlers assign multiple types with setter', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const oncustomevent = jest.fn();
+
+      // First render with nothing
+      ReactDOM.render(<my-custom-element />, container);
+      const customelement = container.querySelector('my-custom-element');
+      // Install a setter to activate the `in` heuristic
+      Object.defineProperty(customelement, 'oncustomevent', {
+        set: function(x) {
+          this._oncustomevent = x;
+        },
+        get: function() {
+          return this._oncustomevent;
+        },
+      });
+      expect(customelement.oncustomevent).toBe(undefined);
+
+      // nothing => event listener
+      ReactDOM.render(
+        <my-custom-element oncustomevent={oncustomevent} />,
+        container,
+      );
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+      expect(customelement.oncustomevent).toBe(null);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+
+      // event listener => string
+      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(1);
+      expect(customelement.oncustomevent).toBe('foo');
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+
+      // string => event listener
+      ReactDOM.render(
+        <my-custom-element oncustomevent={oncustomevent} />,
+        container,
+      );
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(2);
+      expect(customelement.oncustomevent).toBe(null);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+
+      // event listener => nothing
+      ReactDOM.render(<my-custom-element />, container);
+      customelement.dispatchEvent(new Event('customevent'));
+      expect(oncustomevent).toHaveBeenCalledTimes(2);
+      expect(customelement.oncustomevent).toBe(null);
+      expect(customelement.getAttribute('oncustomevent')).toBe(null);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('assigning to a custom element property should not remove attributes', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element foo="one" />, container);
+      const customElement = container.querySelector('my-custom-element');
+      expect(customElement.getAttribute('foo')).toBe('one');
+
+      // Install a setter to activate the `in` heuristic
+      Object.defineProperty(customElement, 'foo', {
+        set: function(x) {
+          this._foo = x;
+        },
+        get: function() {
+          return this._foo;
+        },
+      });
+      ReactDOM.render(<my-custom-element foo="two" />, container);
+      expect(customElement.foo).toBe('two');
+      expect(customElement.getAttribute('foo')).toBe('one');
+    });
   });
 
   describe('deleteValueForProperty', () => {

commit a87adefecdff672d5261e93945c227ad72c5444c
Author: Joey Arhar <jarhar@chromium.org>
Date:   Wed Jan 12 13:12:07 2022 -0700

    Allow functions to be passed to custom element setters (#23042)
    
    This is part of the new custom element features that were implemented
    here:
    https://github.com/facebook/react/commit/24dd07bd269590ee5024b7f0f1906887d256ea86
    
    When a custom element has a setter for a property and passes the `in`
    heuristic, the value passed to the react property should be assigned
    directly to the custom element's property, regardless of the type of the
    value. However, it was discovered that this isn't working with
    functions. This patch makes it work with functions.
    
    Fixes https://github.com/facebook/react/issues/23041

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 28776b1eb6..99f92cba9b 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -504,6 +504,35 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.foo).toBe('two');
       expect(customElement.getAttribute('foo')).toBe('one');
     });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element properties should accept functions', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element />, container);
+      const customElement = container.querySelector('my-custom-element');
+
+      // Install a setter to activate the `in` heuristic
+      Object.defineProperty(customElement, 'foo', {
+        set: function(x) {
+          this._foo = x;
+        },
+        get: function() {
+          return this._foo;
+        },
+      });
+      function myFunction() {
+        return 'this is myFunction';
+      }
+      ReactDOM.render(<my-custom-element foo={myFunction} />, container);
+      expect(customElement.foo).toBe(myFunction);
+
+      // Also remove and re-add the property for good measure
+      ReactDOM.render(<my-custom-element />, container);
+      expect(customElement.foo).toBe(null);
+      ReactDOM.render(<my-custom-element foo={myFunction} />, container);
+      expect(customElement.foo).toBe(myFunction);
+    });
   });
 
   describe('deleteValueForProperty', () => {

commit 05a55a4b09b7b7c8f63778fb8252a001ca66f8d7
Author: Joey Arhar <jarhar@chromium.org>
Date:   Wed Jan 19 12:34:07 2022 -0700

    Fix change events for custom elements (#22938)
    
    * Bypass react event system for custom elements
    
    * Going to try fixing react event system instead
    
    * finally got it to call onChange, but perhaps too many times
    
    * update test
    
    * Removed ReactDOMComponent changes, now works but still doubles for bubbles
    
    * Maybe i should only support bubbling events
    
    * removed some old stuff
    
    * cleaned up changeeventplugin stuff
    
    * prettier, lint
    
    * removed changeeventplugin stuff
    
    * remove unneeded gate for onInput test
    
    * Go back to using ChangeEventPlugin
    
    * Add input+change test
    
    * lint
    
    * Move logic to shouldUseChangeEvent
    
    * use memoizedProps instead of pendingProps
    
    * Run form control behavior before custom element behavior
    
    * add bubbling test
    
    * forgot to append container to body
    
    * add child event target test
    
    * expand <input is=...> test expectations
    
    * Make tests more realistic
    
    * Add extra test
    
    * Add missing gating
    
    * Actually fix gating
    
    Co-authored-by: Dan Abramov <dan.abramov@me.com>

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 99f92cba9b..ab5ca9a549 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -22,6 +22,17 @@ describe('DOMPropertyOperations', () => {
     ReactDOM = require('react-dom');
   });
 
+  // Sets a value in a way that React doesn't see,
+  // so that a subsequent "change" event will trigger the event handler.
+  const setUntrackedValue = Object.getOwnPropertyDescriptor(
+    HTMLInputElement.prototype,
+    'value',
+  ).set;
+  const setUntrackedChecked = Object.getOwnPropertyDescriptor(
+    HTMLInputElement.prototype,
+    'checked',
+  ).set;
+
   describe('setValueForProperty', () => {
     it('should set values as properties by default', () => {
       const container = document.createElement('div');
@@ -280,6 +291,575 @@ describe('DOMPropertyOperations', () => {
       expect(syntheticClickEvent.nativeEvent).toBe(nativeClickEvent);
     });
 
+    // @gate enableCustomElementPropertySupport
+    it('custom elements should have working onChange event listeners', () => {
+      let reactChangeEvent = null;
+      const eventHandler = jest.fn(event => (reactChangeEvent = event));
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element onChange={eventHandler} />, container);
+      const customElement = container.querySelector('my-custom-element');
+      let expectedHandlerCallCount = 0;
+
+      const changeEvent = new Event('change', {bubbles: true});
+      customElement.dispatchEvent(changeEvent);
+      expectedHandlerCallCount++;
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+      expect(reactChangeEvent.nativeEvent).toBe(changeEvent);
+
+      // Also make sure that removing and re-adding the event listener works
+      ReactDOM.render(<my-custom-element />, container);
+      customElement.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+      ReactDOM.render(<my-custom-element onChange={eventHandler} />, container);
+      customElement.dispatchEvent(new Event('change', {bubbles: true}));
+      expectedHandlerCallCount++;
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+    });
+
+    it('custom elements should have working onInput event listeners', () => {
+      let reactInputEvent = null;
+      const eventHandler = jest.fn(event => (reactInputEvent = event));
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element onInput={eventHandler} />, container);
+      const customElement = container.querySelector('my-custom-element');
+      let expectedHandlerCallCount = 0;
+
+      const inputEvent = new Event('input', {bubbles: true});
+      customElement.dispatchEvent(inputEvent);
+      expectedHandlerCallCount++;
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+      expect(reactInputEvent.nativeEvent).toBe(inputEvent);
+
+      // Also make sure that removing and re-adding the event listener works
+      ReactDOM.render(<my-custom-element />, container);
+      customElement.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+      ReactDOM.render(<my-custom-element onInput={eventHandler} />, container);
+      customElement.dispatchEvent(new Event('input', {bubbles: true}));
+      expectedHandlerCallCount++;
+      expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom elements should have separate onInput and onChange handling', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const inputEventHandler = jest.fn();
+      const changeEventHandler = jest.fn();
+      ReactDOM.render(
+        <my-custom-element
+          onInput={inputEventHandler}
+          onChange={changeEventHandler}
+        />,
+        container,
+      );
+      const customElement = container.querySelector('my-custom-element');
+
+      customElement.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(inputEventHandler).toHaveBeenCalledTimes(1);
+      expect(changeEventHandler).toHaveBeenCalledTimes(0);
+
+      customElement.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(inputEventHandler).toHaveBeenCalledTimes(1);
+      expect(changeEventHandler).toHaveBeenCalledTimes(1);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom elements should be able to remove and re-add custom event listeners', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const eventHandler = jest.fn();
+      ReactDOM.render(
+        <my-custom-element oncustomevent={eventHandler} />,
+        container,
+      );
+
+      const customElement = container.querySelector('my-custom-element');
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(eventHandler).toHaveBeenCalledTimes(1);
+
+      ReactDOM.render(<my-custom-element />, container);
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(eventHandler).toHaveBeenCalledTimes(1);
+
+      ReactDOM.render(
+        <my-custom-element oncustomevent={eventHandler} />,
+        container,
+      );
+      customElement.dispatchEvent(new Event('customevent'));
+      expect(eventHandler).toHaveBeenCalledTimes(2);
+    });
+
+    it('<input is=...> should have the same onChange/onInput/onClick behavior as <input>', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const regularOnInputHandler = jest.fn();
+      const regularOnChangeHandler = jest.fn();
+      const regularOnClickHandler = jest.fn();
+      const customOnInputHandler = jest.fn();
+      const customOnChangeHandler = jest.fn();
+      const customOnClickHandler = jest.fn();
+      function clearMocks() {
+        regularOnInputHandler.mockClear();
+        regularOnChangeHandler.mockClear();
+        regularOnClickHandler.mockClear();
+        customOnInputHandler.mockClear();
+        customOnChangeHandler.mockClear();
+        customOnClickHandler.mockClear();
+      }
+      ReactDOM.render(
+        <div>
+          <input
+            onInput={regularOnInputHandler}
+            onChange={regularOnChangeHandler}
+            onClick={regularOnClickHandler}
+          />
+          <input
+            is="my-custom-element"
+            onInput={customOnInputHandler}
+            onChange={customOnChangeHandler}
+            onClick={customOnClickHandler}
+          />
+        </div>,
+        container,
+      );
+
+      const regularInput = container.querySelector(
+        'input:not([is=my-custom-element])',
+      );
+      const customInput = container.querySelector(
+        'input[is=my-custom-element]',
+      );
+      expect(regularInput).not.toBe(customInput);
+
+      // Typing should trigger onInput and onChange for both kinds of inputs.
+      clearMocks();
+      setUntrackedValue.call(regularInput, 'hello');
+      regularInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      setUntrackedValue.call(customInput, 'hello');
+      customInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+
+      // The native change event itself does not produce extra React events.
+      clearMocks();
+      regularInput.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      customInput.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+
+      // The click event is handled by both inputs.
+      clearMocks();
+      regularInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(1);
+      customInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(1);
+
+      // Typing again should trigger onInput and onChange for both kinds of inputs.
+      clearMocks();
+      setUntrackedValue.call(regularInput, 'goodbye');
+      regularInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      setUntrackedValue.call(customInput, 'goodbye');
+      customInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+    });
+
+    it('<input type=radio is=...> should have the same onChange/onInput/onClick behavior as <input type=radio>', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const regularOnInputHandler = jest.fn();
+      const regularOnChangeHandler = jest.fn();
+      const regularOnClickHandler = jest.fn();
+      const customOnInputHandler = jest.fn();
+      const customOnChangeHandler = jest.fn();
+      const customOnClickHandler = jest.fn();
+      function clearMocks() {
+        regularOnInputHandler.mockClear();
+        regularOnChangeHandler.mockClear();
+        regularOnClickHandler.mockClear();
+        customOnInputHandler.mockClear();
+        customOnChangeHandler.mockClear();
+        customOnClickHandler.mockClear();
+      }
+      ReactDOM.render(
+        <div>
+          <input
+            type="radio"
+            onInput={regularOnInputHandler}
+            onChange={regularOnChangeHandler}
+            onClick={regularOnClickHandler}
+          />
+          <input
+            is="my-custom-element"
+            type="radio"
+            onInput={customOnInputHandler}
+            onChange={customOnChangeHandler}
+            onClick={customOnClickHandler}
+          />
+        </div>,
+        container,
+      );
+
+      const regularInput = container.querySelector(
+        'input:not([is=my-custom-element])',
+      );
+      const customInput = container.querySelector(
+        'input[is=my-custom-element]',
+      );
+      expect(regularInput).not.toBe(customInput);
+
+      // Clicking should trigger onClick and onChange on both inputs.
+      clearMocks();
+      setUntrackedChecked.call(regularInput, true);
+      regularInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(1);
+      setUntrackedChecked.call(customInput, true);
+      customInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(1);
+
+      // The native input event only produces a React onInput event.
+      clearMocks();
+      regularInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      customInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+
+      // Clicking again should trigger onClick and onChange on both inputs.
+      clearMocks();
+      setUntrackedChecked.call(regularInput, false);
+      regularInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(1);
+      setUntrackedChecked.call(customInput, false);
+      customInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(1);
+    });
+
+    it('<select is=...> should have the same onChange/onInput/onClick behavior as <select>', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const regularOnInputHandler = jest.fn();
+      const regularOnChangeHandler = jest.fn();
+      const regularOnClickHandler = jest.fn();
+      const customOnInputHandler = jest.fn();
+      const customOnChangeHandler = jest.fn();
+      const customOnClickHandler = jest.fn();
+      function clearMocks() {
+        regularOnInputHandler.mockClear();
+        regularOnChangeHandler.mockClear();
+        regularOnClickHandler.mockClear();
+        customOnInputHandler.mockClear();
+        customOnChangeHandler.mockClear();
+        customOnClickHandler.mockClear();
+      }
+      ReactDOM.render(
+        <div>
+          <select
+            onInput={regularOnInputHandler}
+            onChange={regularOnChangeHandler}
+            onClick={regularOnClickHandler}
+          />
+          <select
+            is="my-custom-element"
+            onInput={customOnInputHandler}
+            onChange={customOnChangeHandler}
+            onClick={customOnClickHandler}
+          />
+        </div>,
+        container,
+      );
+
+      const regularSelect = container.querySelector(
+        'select:not([is=my-custom-element])',
+      );
+      const customSelect = container.querySelector(
+        'select[is=my-custom-element]',
+      );
+      expect(regularSelect).not.toBe(customSelect);
+
+      // Clicking should only trigger onClick on both inputs.
+      clearMocks();
+      regularSelect.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(1);
+      customSelect.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(1);
+
+      // Native input event should only trigger onInput on both inputs.
+      clearMocks();
+      regularSelect.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      customSelect.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(1);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(0);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+
+      // Native change event should trigger onChange.
+      clearMocks();
+      regularSelect.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(regularOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(regularOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(regularOnClickHandler).toHaveBeenCalledTimes(0);
+      customSelect.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(customOnInputHandler).toHaveBeenCalledTimes(0);
+      expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
+      expect(customOnClickHandler).toHaveBeenCalledTimes(0);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('onChange/onInput/onClick on div with various types of children', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const onChangeHandler = jest.fn();
+      const onInputHandler = jest.fn();
+      const onClickHandler = jest.fn();
+      function clearMocks() {
+        onChangeHandler.mockClear();
+        onInputHandler.mockClear();
+        onClickHandler.mockClear();
+      }
+      ReactDOM.render(
+        <div
+          onChange={onChangeHandler}
+          onInput={onInputHandler}
+          onClick={onClickHandler}>
+          <my-custom-element />
+          <input />
+          <input is="my-custom-element" />
+        </div>,
+        container,
+      );
+      const customElement = container.querySelector('my-custom-element');
+      const regularInput = container.querySelector(
+        'input:not([is="my-custom-element"])',
+      );
+      const customInput = container.querySelector(
+        'input[is="my-custom-element"]',
+      );
+      expect(regularInput).not.toBe(customInput);
+
+      // Custom element has no special logic for input/change.
+      clearMocks();
+      customElement.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      customElement.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      customElement.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+
+      // Regular input treats browser input as onChange.
+      clearMocks();
+      setUntrackedValue.call(regularInput, 'hello');
+      regularInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      regularInput.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      regularInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+
+      // Custom input treats browser input as onChange.
+      clearMocks();
+      setUntrackedValue.call(customInput, 'hello');
+      customInput.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      customInput.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      customInput.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+    });
+
+    it('custom element onChange/onInput/onClick with event target input child', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const onChangeHandler = jest.fn();
+      const onInputHandler = jest.fn();
+      const onClickHandler = jest.fn();
+      ReactDOM.render(
+        <my-custom-element
+          onChange={onChangeHandler}
+          onInput={onInputHandler}
+          onClick={onClickHandler}>
+          <input />
+        </my-custom-element>,
+        container,
+      );
+
+      const input = container.querySelector('input');
+      setUntrackedValue.call(input, 'hello');
+      input.dispatchEvent(new Event('input', {bubbles: true}));
+      // Simulated onChange from the child's input event
+      // bubbles to the parent custom element.
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      // Consequently, the native change event is ignored.
+      input.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      input.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+    });
+
+    it('custom element onChange/onInput/onClick with event target div child', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const onChangeHandler = jest.fn();
+      const onInputHandler = jest.fn();
+      const onClickHandler = jest.fn();
+      ReactDOM.render(
+        <my-custom-element
+          onChange={onChangeHandler}
+          onInput={onInputHandler}
+          onClick={onClickHandler}>
+          <div />
+        </my-custom-element>,
+        container,
+      );
+
+      const div = container.querySelector('div');
+      div.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+
+      div.dispatchEvent(new Event('change', {bubbles: true}));
+      // React always ignores change event invoked on non-custom and non-input targets.
+      // So change event emitted on a div does not propagate upwards.
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+
+      div.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+    });
+
+    it('div onChange/onInput/onClick with event target div child', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const onChangeHandler = jest.fn();
+      const onInputHandler = jest.fn();
+      const onClickHandler = jest.fn();
+      ReactDOM.render(
+        <div
+          onChange={onChangeHandler}
+          onInput={onInputHandler}
+          onClick={onClickHandler}>
+          <div />
+        </div>,
+        container,
+      );
+
+      const div = container.querySelector('div > div');
+      div.dispatchEvent(new Event('input', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+
+      div.dispatchEvent(new Event('change', {bubbles: true}));
+      // React always ignores change event invoked on non-custom and non-input targets.
+      // So change event emitted on a div does not propagate upwards.
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+
+      div.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+    });
+
+    // @gate enableCustomElementPropertySupport
+    it('custom element onChange/onInput/onClick with event target custom element child', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const onChangeHandler = jest.fn();
+      const onInputHandler = jest.fn();
+      const onClickHandler = jest.fn();
+      ReactDOM.render(
+        <my-custom-element
+          onChange={onChangeHandler}
+          onInput={onInputHandler}
+          onClick={onClickHandler}>
+          <other-custom-element />
+        </my-custom-element>,
+        container,
+      );
+
+      const customChild = container.querySelector('other-custom-element');
+      customChild.dispatchEvent(new Event('input', {bubbles: true}));
+      // There is no simulated onChange, only raw onInput is dispatched.
+      expect(onChangeHandler).toBeCalledTimes(0);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      // The native change event propagates to the parent as onChange.
+      customChild.dispatchEvent(new Event('change', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(0);
+      customChild.dispatchEvent(new Event('click', {bubbles: true}));
+      expect(onChangeHandler).toBeCalledTimes(1);
+      expect(onInputHandler).toBeCalledTimes(1);
+      expect(onClickHandler).toBeCalledTimes(1);
+    });
+
     // @gate enableCustomElementPropertySupport
     it('custom elements should allow custom events with capture event listeners', () => {
       const oncustomeventCapture = jest.fn();

commit 82c64e1a49239158c0daa7f0d603d2ad2ee667a9
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Fri May 20 19:10:43 2022 +0200

    Match Preact behavior for boolean props on custom elements (#24541)
    
    * Log unexpected warnings when testing with ReactDOMServerIntegrationTestUtils
    
    * Add test
    
    Following https://github.com/facebook/react/issues/9230#issuecomment-322007671 except that `foo={true}` renders an empty string.
    See https://github.com/facebook/react/issues/9230#issuecomment-1123464720 for rationale.
    
    * Match Preact behavior for boolean props on custom elements
    
    * Poke CircleCI

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index ab5ca9a549..73e3b4b49b 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -10,7 +10,10 @@
 'use strict';
 
 // Set by `yarn test-fire`.
-const {disableInputAttributeSyncing} = require('shared/ReactFeatureFlags');
+const {
+  enableCustomElementPropertySupport,
+  disableInputAttributeSyncing,
+} = require('shared/ReactFeatureFlags');
 
 describe('DOMPropertyOperations', () => {
   let React;
@@ -256,8 +259,12 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.getAttribute('onstring')).toBe('hello');
       expect(customElement.getAttribute('onobj')).toBe('[object Object]');
       expect(customElement.getAttribute('onarray')).toBe('one,two');
-      expect(customElement.getAttribute('ontrue')).toBe('true');
-      expect(customElement.getAttribute('onfalse')).toBe('false');
+      expect(customElement.getAttribute('ontrue')).toBe(
+        enableCustomElementPropertySupport ? '' : 'true',
+      );
+      expect(customElement.getAttribute('onfalse')).toBe(
+        enableCustomElementPropertySupport ? null : 'false',
+      );
 
       // Dispatch the corresponding event names to make sure that nothing crashes.
       customElement.dispatchEvent(new Event('string'));
@@ -959,6 +966,21 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.foo).toBe(null);
     });
 
+    // @gate enableCustomElementPropertySupport
+    it('boolean props should not be stringified in attributes', () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      ReactDOM.render(<my-custom-element foo={true} />, container);
+      const customElement = container.querySelector('my-custom-element');
+
+      expect(customElement.getAttribute('foo')).toBe('');
+
+      // true => false
+      ReactDOM.render(<my-custom-element foo={false} />, container);
+
+      expect(customElement.getAttribute('foo')).toBe(null);
+    });
+
     // @gate enableCustomElementPropertySupport
     it('custom element custom event handlers assign multiple types', () => {
       const container = document.createElement('div');

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 73e3b4b49b..c06b7b52d7 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index c06b7b52d7..bf523c4494 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -84,7 +84,7 @@ describe('DOMPropertyOperations', () => {
       // Browsers default to this behavior, but some test environments do not.
       // This ensures that we have consistent behavior.
       const obj = {
-        toString: function() {
+        toString: function () {
           return 'css-class';
         },
       };
@@ -152,7 +152,7 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.hasAttribute('hidden')).toBe(false);
     });
 
-    it('should always assign the value attribute for non-inputs', function() {
+    it('should always assign the value attribute for non-inputs', function () {
       const container = document.createElement('div');
       ReactDOM.render(<progress />, container);
       spyOnDevAndProd(container.firstChild, 'setAttribute');
@@ -1041,10 +1041,10 @@ describe('DOMPropertyOperations', () => {
       const customelement = container.querySelector('my-custom-element');
       // Install a setter to activate the `in` heuristic
       Object.defineProperty(customelement, 'oncustomevent', {
-        set: function(x) {
+        set: function (x) {
           this._oncustomevent = x;
         },
-        get: function() {
+        get: function () {
           return this._oncustomevent;
         },
       });
@@ -1095,10 +1095,10 @@ describe('DOMPropertyOperations', () => {
 
       // Install a setter to activate the `in` heuristic
       Object.defineProperty(customElement, 'foo', {
-        set: function(x) {
+        set: function (x) {
           this._foo = x;
         },
-        get: function() {
+        get: function () {
           return this._foo;
         },
       });
@@ -1116,10 +1116,10 @@ describe('DOMPropertyOperations', () => {
 
       // Install a setter to activate the `in` heuristic
       Object.defineProperty(customElement, 'foo', {
-        set: function(x) {
+        set: function (x) {
           this._foo = x;
         },
-        get: function() {
+        get: function () {
           return this._foo;
         },
       });
@@ -1149,7 +1149,7 @@ describe('DOMPropertyOperations', () => {
     it('should not remove attributes for special properties', () => {
       const container = document.createElement('div');
       ReactDOM.render(
-        <input type="text" value="foo" onChange={function() {}} />,
+        <input type="text" value="foo" onChange={function () {}} />,
         container,
       );
       if (disableInputAttributeSyncing) {
@@ -1160,7 +1160,7 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.value).toBe('foo');
       expect(() =>
         ReactDOM.render(
-          <input type="text" onChange={function() {}} />,
+          <input type="text" onChange={function () {}} />,
           container,
         ),
       ).toErrorDev(

commit e5146cb5250be1a4e66511af91549859b36ed488
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Sun Apr 9 18:06:16 2023 -0400

    Refactor some controlled component stuff (#26573)
    
    This is mainly renaming some stuff. The behavior change is
    hasOwnProperty to nullish check.
    
    I had a bigger refactor that was a dead-end but might as well land this
    part and see if I can pick it up later.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index bf523c4494..67d6f7bd46 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1166,11 +1166,7 @@ describe('DOMPropertyOperations', () => {
       ).toErrorDev(
         'A component is changing a controlled input to be uncontrolled',
       );
-      if (disableInputAttributeSyncing) {
-        expect(container.firstChild.hasAttribute('value')).toBe(false);
-      } else {
-        expect(container.firstChild.getAttribute('value')).toBe('foo');
-      }
+      expect(container.firstChild.hasAttribute('value')).toBe(false);
       expect(container.firstChild.value).toBe('foo');
     });
 

commit b433c379d55d9684945217c7d375de1082a1abb8
Author: Sophie Alpert <git@sophiebits.com>
Date:   Tue Apr 18 10:49:32 2023 -0700

    Fix input tracking bug (#26627)
    
    In
    https://github.com/facebook/react/pull/26573/commits/2019ddc75f448292ffa6429d7625514af192631b,
    we changed to set .defaultValue before .value on updates. In some cases,
    setting .defaultValue causes .value to change, and since we only set
    .value if it has the wrong value, this resulted in us not assigning to
    .value, which resulted in inputValueTracking not knowing the right
    value. See new test added.
    
    My fix here is to (a) move the value setting back up first and (b)
    narrowing the fix in the aforementioned PR to newly remove the value
    attribute only if it defaultValue was previously present in props.
    
    The second half is necessary because for types where the value property
    and attribute are indelibly linked (hidden checkbox radio submit image
    reset button, i.e. spec modes default or default/on from
    https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default),
    we can't remove the value attribute after setting .value, because that
    will undo the assignment we just did! That is, not having (b) makes all
    of those types fail to handle updating props.value.
    
    This code is incredibly hard to think about but I think this is right
    (or at least, as right as the old code was) because we set .value here
    only if the nextProps.value != null, and we now remove defaultValue only
    if lastProps.defaultValue != null. These can't happen at the same time
    because we have long warned if value and defaultValue are simultaneously
    specified, and also if a component switches between controlled and
    uncontrolled.
    
    Also, it fixes the test in https://github.com/facebook/react/pull/26626.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 67d6f7bd46..bf523c4494 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1166,7 +1166,11 @@ describe('DOMPropertyOperations', () => {
       ).toErrorDev(
         'A component is changing a controlled input to be uncontrolled',
       );
-      expect(container.firstChild.hasAttribute('value')).toBe(false);
+      if (disableInputAttributeSyncing) {
+        expect(container.firstChild.hasAttribute('value')).toBe(false);
+      } else {
+        expect(container.firstChild.getAttribute('value')).toBe('foo');
+      }
       expect(container.firstChild.value).toBe('foo');
     });
 

commit ef2859d50bb6b4b31b304f4fe4bb43dc273a9b54
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 9 15:30:27 2024 -0500

    Convert DOMPropertyOperations-test to createRoot (#27911)
    
    Convert DOMPropertyOperations-test to createRoot
    
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/27911).
    * #27914
    * __->__ #27911

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index bf523c4494..87885ca07b 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -17,12 +17,14 @@ const {
 
 describe('DOMPropertyOperations', () => {
   let React;
-  let ReactDOM;
+  let ReactDOMClient;
+  let act;
 
   beforeEach(() => {
     jest.resetModules();
     React = require('react');
-    ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
+    ({act} = require('internal-test-utils'));
   });
 
   // Sets a value in a way that React doesn't see,
@@ -37,25 +39,34 @@ describe('DOMPropertyOperations', () => {
   ).set;
 
   describe('setValueForProperty', () => {
-    it('should set values as properties by default', () => {
+    it('should set values as properties by default', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div title="Tip!" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div title="Tip!" />);
+      });
       expect(container.firstChild.title).toBe('Tip!');
     });
 
-    it('should set values as attributes if necessary', () => {
+    it('should set values as attributes if necessary', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div role="#" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div role="#" />);
+      });
       expect(container.firstChild.getAttribute('role')).toBe('#');
       expect(container.firstChild.role).toBeUndefined();
     });
 
-    it('should set values as namespace attributes if necessary', () => {
+    it('should set values as namespace attributes if necessary', async () => {
       const container = document.createElementNS(
         'http://www.w3.org/2000/svg',
         'svg',
       );
-      ReactDOM.render(<image xlinkHref="about:blank" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<image xlinkHref="about:blank" />);
+      });
       expect(
         container.firstChild.getAttributeNS(
           'http://www.w3.org/1999/xlink',
@@ -64,23 +75,38 @@ describe('DOMPropertyOperations', () => {
       ).toBe('about:blank');
     });
 
-    it('should set values as boolean properties', () => {
+    it('should set values as boolean properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div disabled="disabled" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div disabled="disabled" />);
+      });
       expect(container.firstChild.getAttribute('disabled')).toBe('');
-      ReactDOM.render(<div disabled={true} />, container);
+      await act(() => {
+        root.render(<div disabled={true} />);
+      });
       expect(container.firstChild.getAttribute('disabled')).toBe('');
-      ReactDOM.render(<div disabled={false} />, container);
+      await act(() => {
+        root.render(<div disabled={false} />);
+      });
       expect(container.firstChild.getAttribute('disabled')).toBe(null);
-      ReactDOM.render(<div disabled={true} />, container);
-      ReactDOM.render(<div disabled={null} />, container);
+      await act(() => {
+        root.render(<div disabled={true} />);
+      });
+      await act(() => {
+        root.render(<div disabled={null} />);
+      });
       expect(container.firstChild.getAttribute('disabled')).toBe(null);
-      ReactDOM.render(<div disabled={true} />, container);
-      ReactDOM.render(<div disabled={undefined} />, container);
+      await act(() => {
+        root.render(<div disabled={true} />);
+      });
+      await act(() => {
+        root.render(<div disabled={undefined} />);
+      });
       expect(container.firstChild.getAttribute('disabled')).toBe(null);
     });
 
-    it('should convert attribute values to string first', () => {
+    it('should convert attribute values to string first', async () => {
       // Browsers default to this behavior, but some test environments do not.
       // This ensures that we have consistent behavior.
       const obj = {
@@ -90,13 +116,19 @@ describe('DOMPropertyOperations', () => {
       };
 
       const container = document.createElement('div');
-      ReactDOM.render(<div className={obj} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div className={obj} />);
+      });
       expect(container.firstChild.getAttribute('class')).toBe('css-class');
     });
 
-    it('should not remove empty attributes for special input properties', () => {
+    it('should not remove empty attributes for special input properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<input value="" onChange={() => {}} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<input value="" onChange={() => {}} />);
+      });
       if (disableInputAttributeSyncing) {
         expect(container.firstChild.hasAttribute('value')).toBe(false);
       } else {
@@ -105,79 +137,114 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.value).toBe('');
     });
 
-    it('should not remove empty attributes for special option properties', () => {
+    it('should not remove empty attributes for special option properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(
-        <select>
-          <option value="">empty</option>
-          <option>filled</option>
-        </select>,
-        container,
-      );
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(
+          <select>
+            <option value="">empty</option>
+            <option>filled</option>
+          </select>,
+        );
+      });
       // Regression test for https://github.com/facebook/react/issues/6219
       expect(container.firstChild.firstChild.value).toBe('');
       expect(container.firstChild.lastChild.value).toBe('filled');
     });
 
-    it('should remove for falsey boolean properties', () => {
+    it('should remove for falsey boolean properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div allowFullScreen={false} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div allowFullScreen={false} />);
+      });
       expect(container.firstChild.hasAttribute('allowFullScreen')).toBe(false);
     });
 
-    it('should remove when setting custom attr to null', () => {
+    it('should remove when setting custom attr to null', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div data-foo="bar" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div data-foo="bar" />);
+      });
       expect(container.firstChild.hasAttribute('data-foo')).toBe(true);
-      ReactDOM.render(<div data-foo={null} />, container);
+      await act(() => {
+        root.render(<div data-foo={null} />);
+      });
       expect(container.firstChild.hasAttribute('data-foo')).toBe(false);
     });
 
-    it('should set className to empty string instead of null', () => {
+    it('should set className to empty string instead of null', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div className="selected" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div className="selected" />);
+      });
       expect(container.firstChild.className).toBe('selected');
-      ReactDOM.render(<div className={null} />, container);
+      await act(() => {
+        root.render(<div className={null} />);
+      });
       // className should be '', not 'null' or null (which becomes 'null' in
       // some browsers)
       expect(container.firstChild.className).toBe('');
       expect(container.firstChild.getAttribute('class')).toBe(null);
     });
 
-    it('should remove property properly for boolean properties', () => {
+    it('should remove property properly for boolean properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div hidden={true} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div hidden={true} />);
+      });
       expect(container.firstChild.hasAttribute('hidden')).toBe(true);
-      ReactDOM.render(<div hidden={false} />, container);
+      await act(() => {
+        root.render(<div hidden={false} />);
+      });
       expect(container.firstChild.hasAttribute('hidden')).toBe(false);
     });
 
-    it('should always assign the value attribute for non-inputs', function () {
+    it('should always assign the value attribute for non-inputs', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<progress />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<progress />);
+      });
       spyOnDevAndProd(container.firstChild, 'setAttribute');
-      ReactDOM.render(<progress value={30} />, container);
-      ReactDOM.render(<progress value="30" />, container);
+      await act(() => {
+        root.render(<progress value={30} />);
+      });
+      await act(() => {
+        root.render(<progress value="30" />);
+      });
       expect(container.firstChild.setAttribute).toHaveBeenCalledTimes(2);
     });
 
-    it('should return the progress to intermediate state on null value', () => {
+    it('should return the progress to intermediate state on null value', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<progress value={30} />, container);
-      ReactDOM.render(<progress value={null} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<progress value={30} />);
+      });
+      await act(() => {
+        root.render(<progress value={null} />);
+      });
       // Ensure we move progress back to an indeterminate state.
       // Regression test for https://github.com/facebook/react/issues/6119
       expect(container.firstChild.hasAttribute('value')).toBe(false);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element custom events lowercase', () => {
+    it('custom element custom events lowercase', async () => {
       const oncustomevent = jest.fn();
       function Test() {
         return <my-custom-element oncustomevent={oncustomevent} />;
       }
       const container = document.createElement('div');
-      ReactDOM.render(<Test />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test />);
+      });
       container
         .querySelector('my-custom-element')
         .dispatchEvent(new Event('customevent'));
@@ -185,13 +252,16 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element custom events uppercase', () => {
+    it('custom element custom events uppercase', async () => {
       const oncustomevent = jest.fn();
       function Test() {
         return <my-custom-element onCustomevent={oncustomevent} />;
       }
       const container = document.createElement('div');
-      ReactDOM.render(<Test />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test />);
+      });
       container
         .querySelector('my-custom-element')
         .dispatchEvent(new Event('Customevent'));
@@ -199,13 +269,16 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element custom event with dash in name', () => {
+    it('custom element custom event with dash in name', async () => {
       const oncustomevent = jest.fn();
       function Test() {
         return <my-custom-element oncustom-event={oncustomevent} />;
       }
       const container = document.createElement('div');
-      ReactDOM.render(<Test />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test />);
+      });
       container
         .querySelector('my-custom-element')
         .dispatchEvent(new Event('custom-event'));
@@ -213,48 +286,59 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element remove event handler', () => {
+    it('custom element remove event handler', async () => {
       const oncustomevent = jest.fn();
       function Test(props) {
         return <my-custom-element oncustomevent={props.handler} />;
       }
 
       const container = document.createElement('div');
-      ReactDOM.render(<Test handler={oncustomevent} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test handler={oncustomevent} />);
+      });
       const customElement = container.querySelector('my-custom-element');
       customElement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
 
-      ReactDOM.render(<Test handler={false} />, container);
+      await act(() => {
+        root.render(<Test handler={false} />);
+      });
       // Make sure that the second render didn't create a new element. We want
       // to make sure removeEventListener actually gets called on the same element.
       expect(customElement).toBe(customElement);
       customElement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
 
-      ReactDOM.render(<Test handler={oncustomevent} />, container);
+      await act(() => {
+        root.render(<Test handler={oncustomevent} />);
+      });
       customElement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
 
       const oncustomevent2 = jest.fn();
-      ReactDOM.render(<Test handler={oncustomevent2} />, container);
+      await act(() => {
+        root.render(<Test handler={oncustomevent2} />);
+      });
       customElement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
       expect(oncustomevent2).toHaveBeenCalledTimes(1);
     });
 
-    it('custom elements shouldnt have non-functions for on* attributes treated as event listeners', () => {
+    it('custom elements shouldnt have non-functions for on* attributes treated as event listeners', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(
-        <my-custom-element
-          onstring={'hello'}
-          onobj={{hello: 'world'}}
-          onarray={['one', 'two']}
-          ontrue={true}
-          onfalse={false}
-        />,
-        container,
-      );
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(
+          <my-custom-element
+            onstring={'hello'}
+            onobj={{hello: 'world'}}
+            onarray={['one', 'two']}
+            ontrue={true}
+            onfalse={false}
+          />,
+        );
+      });
       const customElement = container.querySelector('my-custom-element');
       expect(customElement.getAttribute('onstring')).toBe('hello');
       expect(customElement.getAttribute('onobj')).toBe('[object Object]');
@@ -274,7 +358,7 @@ describe('DOMPropertyOperations', () => {
       customElement.dispatchEvent(new Event('false'));
     });
 
-    it('custom elements should still have onClick treated like regular elements', () => {
+    it('custom elements should still have onClick treated like regular elements', async () => {
       let syntheticClickEvent = null;
       const syntheticEventHandler = jest.fn(
         event => (syntheticClickEvent = event),
@@ -287,7 +371,10 @@ describe('DOMPropertyOperations', () => {
 
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<Test />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test />);
+      });
 
       const customElement = container.querySelector('my-custom-element');
       customElement.onclick = nativeEventHandler;
@@ -299,12 +386,15 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom elements should have working onChange event listeners', () => {
+    it('custom elements should have working onChange event listeners', async () => {
       let reactChangeEvent = null;
       const eventHandler = jest.fn(event => (reactChangeEvent = event));
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element onChange={eventHandler} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element onChange={eventHandler} />);
+      });
       const customElement = container.querySelector('my-custom-element');
       let expectedHandlerCallCount = 0;
 
@@ -315,21 +405,28 @@ describe('DOMPropertyOperations', () => {
       expect(reactChangeEvent.nativeEvent).toBe(changeEvent);
 
       // Also make sure that removing and re-adding the event listener works
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       customElement.dispatchEvent(new Event('change', {bubbles: true}));
       expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
-      ReactDOM.render(<my-custom-element onChange={eventHandler} />, container);
+      await act(() => {
+        root.render(<my-custom-element onChange={eventHandler} />);
+      });
       customElement.dispatchEvent(new Event('change', {bubbles: true}));
       expectedHandlerCallCount++;
       expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
     });
 
-    it('custom elements should have working onInput event listeners', () => {
+    it('custom elements should have working onInput event listeners', async () => {
       let reactInputEvent = null;
       const eventHandler = jest.fn(event => (reactInputEvent = event));
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element onInput={eventHandler} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element onInput={eventHandler} />);
+      });
       const customElement = container.querySelector('my-custom-element');
       let expectedHandlerCallCount = 0;
 
@@ -340,28 +437,34 @@ describe('DOMPropertyOperations', () => {
       expect(reactInputEvent.nativeEvent).toBe(inputEvent);
 
       // Also make sure that removing and re-adding the event listener works
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       customElement.dispatchEvent(new Event('input', {bubbles: true}));
       expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
-      ReactDOM.render(<my-custom-element onInput={eventHandler} />, container);
+      await act(() => {
+        root.render(<my-custom-element onInput={eventHandler} />);
+      });
       customElement.dispatchEvent(new Event('input', {bubbles: true}));
       expectedHandlerCallCount++;
       expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom elements should have separate onInput and onChange handling', () => {
+    it('custom elements should have separate onInput and onChange handling', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const inputEventHandler = jest.fn();
       const changeEventHandler = jest.fn();
-      ReactDOM.render(
-        <my-custom-element
-          onInput={inputEventHandler}
-          onChange={changeEventHandler}
-        />,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <my-custom-element
+            onInput={inputEventHandler}
+            onChange={changeEventHandler}
+          />,
+        );
+      });
       const customElement = container.querySelector('my-custom-element');
 
       customElement.dispatchEvent(new Event('input', {bubbles: true}));
@@ -374,34 +477,36 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom elements should be able to remove and re-add custom event listeners', () => {
+    it('custom elements should be able to remove and re-add custom event listeners', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const eventHandler = jest.fn();
-      ReactDOM.render(
-        <my-custom-element oncustomevent={eventHandler} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={eventHandler} />);
+      });
 
       const customElement = container.querySelector('my-custom-element');
       customElement.dispatchEvent(new Event('customevent'));
       expect(eventHandler).toHaveBeenCalledTimes(1);
 
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       customElement.dispatchEvent(new Event('customevent'));
       expect(eventHandler).toHaveBeenCalledTimes(1);
 
-      ReactDOM.render(
-        <my-custom-element oncustomevent={eventHandler} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={eventHandler} />);
+      });
       customElement.dispatchEvent(new Event('customevent'));
       expect(eventHandler).toHaveBeenCalledTimes(2);
     });
 
-    it('<input is=...> should have the same onChange/onInput/onClick behavior as <input>', () => {
+    it('<input is=...> should have the same onChange/onInput/onClick behavior as <input>', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const regularOnInputHandler = jest.fn();
       const regularOnChangeHandler = jest.fn();
       const regularOnClickHandler = jest.fn();
@@ -416,22 +521,23 @@ describe('DOMPropertyOperations', () => {
         customOnChangeHandler.mockClear();
         customOnClickHandler.mockClear();
       }
-      ReactDOM.render(
-        <div>
-          <input
-            onInput={regularOnInputHandler}
-            onChange={regularOnChangeHandler}
-            onClick={regularOnClickHandler}
-          />
-          <input
-            is="my-custom-element"
-            onInput={customOnInputHandler}
-            onChange={customOnChangeHandler}
-            onClick={customOnClickHandler}
-          />
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div>
+            <input
+              onInput={regularOnInputHandler}
+              onChange={regularOnChangeHandler}
+              onClick={regularOnClickHandler}
+            />
+            <input
+              is="my-custom-element"
+              onInput={customOnInputHandler}
+              onChange={customOnChangeHandler}
+              onClick={customOnClickHandler}
+            />
+          </div>,
+        );
+      });
 
       const regularInput = container.querySelector(
         'input:not([is=my-custom-element])',
@@ -490,9 +596,10 @@ describe('DOMPropertyOperations', () => {
       expect(customOnClickHandler).toHaveBeenCalledTimes(0);
     });
 
-    it('<input type=radio is=...> should have the same onChange/onInput/onClick behavior as <input type=radio>', () => {
+    it('<input type=radio is=...> should have the same onChange/onInput/onClick behavior as <input type=radio>', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const regularOnInputHandler = jest.fn();
       const regularOnChangeHandler = jest.fn();
       const regularOnClickHandler = jest.fn();
@@ -507,24 +614,25 @@ describe('DOMPropertyOperations', () => {
         customOnChangeHandler.mockClear();
         customOnClickHandler.mockClear();
       }
-      ReactDOM.render(
-        <div>
-          <input
-            type="radio"
-            onInput={regularOnInputHandler}
-            onChange={regularOnChangeHandler}
-            onClick={regularOnClickHandler}
-          />
-          <input
-            is="my-custom-element"
-            type="radio"
-            onInput={customOnInputHandler}
-            onChange={customOnChangeHandler}
-            onClick={customOnClickHandler}
-          />
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div>
+            <input
+              type="radio"
+              onInput={regularOnInputHandler}
+              onChange={regularOnChangeHandler}
+              onClick={regularOnClickHandler}
+            />
+            <input
+              is="my-custom-element"
+              type="radio"
+              onInput={customOnInputHandler}
+              onChange={customOnChangeHandler}
+              onClick={customOnClickHandler}
+            />
+          </div>,
+        );
+      });
 
       const regularInput = container.querySelector(
         'input:not([is=my-custom-element])',
@@ -572,9 +680,10 @@ describe('DOMPropertyOperations', () => {
       expect(customOnClickHandler).toHaveBeenCalledTimes(1);
     });
 
-    it('<select is=...> should have the same onChange/onInput/onClick behavior as <select>', () => {
+    it('<select is=...> should have the same onChange/onInput/onClick behavior as <select>', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const regularOnInputHandler = jest.fn();
       const regularOnChangeHandler = jest.fn();
       const regularOnClickHandler = jest.fn();
@@ -589,22 +698,23 @@ describe('DOMPropertyOperations', () => {
         customOnChangeHandler.mockClear();
         customOnClickHandler.mockClear();
       }
-      ReactDOM.render(
-        <div>
-          <select
-            onInput={regularOnInputHandler}
-            onChange={regularOnChangeHandler}
-            onClick={regularOnClickHandler}
-          />
-          <select
-            is="my-custom-element"
-            onInput={customOnInputHandler}
-            onChange={customOnChangeHandler}
-            onClick={customOnClickHandler}
-          />
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div>
+            <select
+              onInput={regularOnInputHandler}
+              onChange={regularOnChangeHandler}
+              onClick={regularOnClickHandler}
+            />
+            <select
+              is="my-custom-element"
+              onInput={customOnInputHandler}
+              onChange={customOnChangeHandler}
+              onClick={customOnClickHandler}
+            />
+          </div>,
+        );
+      });
 
       const regularSelect = container.querySelector(
         'select:not([is=my-custom-element])',
@@ -649,9 +759,10 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('onChange/onInput/onClick on div with various types of children', () => {
+    it('onChange/onInput/onClick on div with various types of children', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const onChangeHandler = jest.fn();
       const onInputHandler = jest.fn();
       const onClickHandler = jest.fn();
@@ -660,17 +771,18 @@ describe('DOMPropertyOperations', () => {
         onInputHandler.mockClear();
         onClickHandler.mockClear();
       }
-      ReactDOM.render(
-        <div
-          onChange={onChangeHandler}
-          onInput={onInputHandler}
-          onClick={onClickHandler}>
-          <my-custom-element />
-          <input />
-          <input is="my-custom-element" />
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div
+            onChange={onChangeHandler}
+            onInput={onInputHandler}
+            onClick={onClickHandler}>
+            <my-custom-element />
+            <input />
+            <input is="my-custom-element" />
+          </div>,
+        );
+      });
       const customElement = container.querySelector('my-custom-element');
       const regularInput = container.querySelector(
         'input:not([is="my-custom-element"])',
@@ -728,21 +840,23 @@ describe('DOMPropertyOperations', () => {
       expect(onClickHandler).toBeCalledTimes(1);
     });
 
-    it('custom element onChange/onInput/onClick with event target input child', () => {
+    it('custom element onChange/onInput/onClick with event target input child', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const onChangeHandler = jest.fn();
       const onInputHandler = jest.fn();
       const onClickHandler = jest.fn();
-      ReactDOM.render(
-        <my-custom-element
-          onChange={onChangeHandler}
-          onInput={onInputHandler}
-          onClick={onClickHandler}>
-          <input />
-        </my-custom-element>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <my-custom-element
+            onChange={onChangeHandler}
+            onInput={onInputHandler}
+            onClick={onClickHandler}>
+            <input />
+          </my-custom-element>,
+        );
+      });
 
       const input = container.querySelector('input');
       setUntrackedValue.call(input, 'hello');
@@ -763,21 +877,23 @@ describe('DOMPropertyOperations', () => {
       expect(onClickHandler).toBeCalledTimes(1);
     });
 
-    it('custom element onChange/onInput/onClick with event target div child', () => {
+    it('custom element onChange/onInput/onClick with event target div child', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const onChangeHandler = jest.fn();
       const onInputHandler = jest.fn();
       const onClickHandler = jest.fn();
-      ReactDOM.render(
-        <my-custom-element
-          onChange={onChangeHandler}
-          onInput={onInputHandler}
-          onClick={onClickHandler}>
-          <div />
-        </my-custom-element>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <my-custom-element
+            onChange={onChangeHandler}
+            onInput={onInputHandler}
+            onClick={onClickHandler}>
+            <div />
+          </my-custom-element>,
+        );
+      });
 
       const div = container.querySelector('div');
       div.dispatchEvent(new Event('input', {bubbles: true}));
@@ -798,21 +914,23 @@ describe('DOMPropertyOperations', () => {
       expect(onClickHandler).toBeCalledTimes(1);
     });
 
-    it('div onChange/onInput/onClick with event target div child', () => {
+    it('div onChange/onInput/onClick with event target div child', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const onChangeHandler = jest.fn();
       const onInputHandler = jest.fn();
       const onClickHandler = jest.fn();
-      ReactDOM.render(
-        <div
-          onChange={onChangeHandler}
-          onInput={onInputHandler}
-          onClick={onClickHandler}>
-          <div />
-        </div>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <div
+            onChange={onChangeHandler}
+            onInput={onInputHandler}
+            onClick={onClickHandler}>
+            <div />
+          </div>,
+        );
+      });
 
       const div = container.querySelector('div > div');
       div.dispatchEvent(new Event('input', {bubbles: true}));
@@ -834,21 +952,23 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element onChange/onInput/onClick with event target custom element child', () => {
+    it('custom element onChange/onInput/onClick with event target custom element child', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const onChangeHandler = jest.fn();
       const onInputHandler = jest.fn();
       const onClickHandler = jest.fn();
-      ReactDOM.render(
-        <my-custom-element
-          onChange={onChangeHandler}
-          onInput={onInputHandler}
-          onClick={onClickHandler}>
-          <other-custom-element />
-        </my-custom-element>,
-        container,
-      );
+      await act(() => {
+        root.render(
+          <my-custom-element
+            onChange={onChangeHandler}
+            onInput={onInputHandler}
+            onClick={onClickHandler}>
+            <other-custom-element />
+          </my-custom-element>,
+        );
+      });
 
       const customChild = container.querySelector('other-custom-element');
       customChild.dispatchEvent(new Event('input', {bubbles: true}));
@@ -868,7 +988,7 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom elements should allow custom events with capture event listeners', () => {
+    it('custom elements should allow custom events with capture event listeners', async () => {
       const oncustomeventCapture = jest.fn();
       const oncustomevent = jest.fn();
       function Test() {
@@ -881,7 +1001,10 @@ describe('DOMPropertyOperations', () => {
         );
       }
       const container = document.createElement('div');
-      ReactDOM.render(<Test />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<Test />);
+      });
       container
         .querySelector('my-custom-element > div')
         .dispatchEvent(new Event('customevent', {bubbles: false}));
@@ -889,106 +1012,148 @@ describe('DOMPropertyOperations', () => {
       expect(oncustomevent).toHaveBeenCalledTimes(0);
     });
 
-    it('innerHTML should not work on custom elements', () => {
+    it('innerHTML should not work on custom elements', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<my-custom-element innerHTML="foo" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element innerHTML="foo" />);
+      });
       const customElement = container.querySelector('my-custom-element');
       expect(customElement.getAttribute('innerHTML')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
 
       // Render again to verify the update codepath doesn't accidentally let
       // something through.
-      ReactDOM.render(<my-custom-element innerHTML="bar" />, container);
+      await act(() => {
+        root.render(<my-custom-element innerHTML="bar" />);
+      });
       expect(customElement.getAttribute('innerHTML')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('innerText should not work on custom elements', () => {
+    it('innerText should not work on custom elements', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<my-custom-element innerText="foo" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element innerText="foo" />);
+      });
       const customElement = container.querySelector('my-custom-element');
       expect(customElement.getAttribute('innerText')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
 
       // Render again to verify the update codepath doesn't accidentally let
       // something through.
-      ReactDOM.render(<my-custom-element innerText="bar" />, container);
+      await act(() => {
+        root.render(<my-custom-element innerText="bar" />);
+      });
       expect(customElement.getAttribute('innerText')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('textContent should not work on custom elements', () => {
+    it('textContent should not work on custom elements', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<my-custom-element textContent="foo" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element textContent="foo" />);
+      });
       const customElement = container.querySelector('my-custom-element');
       expect(customElement.getAttribute('textContent')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
 
       // Render again to verify the update codepath doesn't accidentally let
       // something through.
-      ReactDOM.render(<my-custom-element textContent="bar" />, container);
+      await act(() => {
+        root.render(<my-custom-element textContent="bar" />);
+      });
       expect(customElement.getAttribute('textContent')).toBe(null);
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('values should not be converted to booleans when assigning into custom elements', () => {
+    it('values should not be converted to booleans when assigning into custom elements', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       const customElement = container.querySelector('my-custom-element');
       customElement.foo = null;
 
       // true => string
-      ReactDOM.render(<my-custom-element foo={true} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={true} />);
+      });
       expect(customElement.foo).toBe(true);
-      ReactDOM.render(<my-custom-element foo="bar" />, container);
+      await act(() => {
+        root.render(<my-custom-element foo="bar" />);
+      });
       expect(customElement.foo).toBe('bar');
 
       // false => string
-      ReactDOM.render(<my-custom-element foo={false} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={false} />);
+      });
       expect(customElement.foo).toBe(false);
-      ReactDOM.render(<my-custom-element foo="bar" />, container);
+      await act(() => {
+        root.render(<my-custom-element foo="bar" />);
+      });
       expect(customElement.foo).toBe('bar');
 
       // true => null
-      ReactDOM.render(<my-custom-element foo={true} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={true} />);
+      });
       expect(customElement.foo).toBe(true);
-      ReactDOM.render(<my-custom-element foo={null} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={null} />);
+      });
       expect(customElement.foo).toBe(null);
 
       // false => null
-      ReactDOM.render(<my-custom-element foo={false} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={false} />);
+      });
       expect(customElement.foo).toBe(false);
-      ReactDOM.render(<my-custom-element foo={null} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={null} />);
+      });
       expect(customElement.foo).toBe(null);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('boolean props should not be stringified in attributes', () => {
+    it('boolean props should not be stringified in attributes', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element foo={true} />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element foo={true} />);
+      });
       const customElement = container.querySelector('my-custom-element');
 
       expect(customElement.getAttribute('foo')).toBe('');
 
       // true => false
-      ReactDOM.render(<my-custom-element foo={false} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={false} />);
+      });
 
       expect(customElement.getAttribute('foo')).toBe(null);
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element custom event handlers assign multiple types', () => {
+    it('custom element custom event handlers assign multiple types', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const oncustomevent = jest.fn();
 
       // First render with string
-      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={'foo'} />);
+      });
       const customelement = container.querySelector('my-custom-element');
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(0);
@@ -996,34 +1161,36 @@ describe('DOMPropertyOperations', () => {
       expect(customelement.getAttribute('oncustomevent')).toBe('foo');
 
       // string => event listener
-      ReactDOM.render(
-        <my-custom-element oncustomevent={oncustomevent} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={oncustomevent} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
       expect(customelement.oncustomevent).toBe(undefined);
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
 
       // event listener => string
-      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={'foo'} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
       expect(customelement.oncustomevent).toBe(undefined);
       expect(customelement.getAttribute('oncustomevent')).toBe('foo');
 
       // string => nothing
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
       expect(customelement.oncustomevent).toBe(undefined);
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
 
       // nothing => event listener
-      ReactDOM.render(
-        <my-custom-element oncustomevent={oncustomevent} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={oncustomevent} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
       expect(customelement.oncustomevent).toBe(undefined);
@@ -1031,13 +1198,16 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element custom event handlers assign multiple types with setter', () => {
+    it('custom element custom event handlers assign multiple types with setter', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
       const oncustomevent = jest.fn();
 
       // First render with nothing
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       const customelement = container.querySelector('my-custom-element');
       // Install a setter to activate the `in` heuristic
       Object.defineProperty(customelement, 'oncustomevent', {
@@ -1051,34 +1221,36 @@ describe('DOMPropertyOperations', () => {
       expect(customelement.oncustomevent).toBe(undefined);
 
       // nothing => event listener
-      ReactDOM.render(
-        <my-custom-element oncustomevent={oncustomevent} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={oncustomevent} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
       expect(customelement.oncustomevent).toBe(null);
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
 
       // event listener => string
-      ReactDOM.render(<my-custom-element oncustomevent={'foo'} />, container);
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={'foo'} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(1);
       expect(customelement.oncustomevent).toBe('foo');
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
 
       // string => event listener
-      ReactDOM.render(
-        <my-custom-element oncustomevent={oncustomevent} />,
-        container,
-      );
+      await act(() => {
+        root.render(<my-custom-element oncustomevent={oncustomevent} />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
       expect(customelement.oncustomevent).toBe(null);
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
 
       // event listener => nothing
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
       expect(customelement.oncustomevent).toBe(null);
@@ -1086,10 +1258,13 @@ describe('DOMPropertyOperations', () => {
     });
 
     // @gate enableCustomElementPropertySupport
-    it('assigning to a custom element property should not remove attributes', () => {
+    it('assigning to a custom element property should not remove attributes', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element foo="one" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element foo="one" />);
+      });
       const customElement = container.querySelector('my-custom-element');
       expect(customElement.getAttribute('foo')).toBe('one');
 
@@ -1102,16 +1277,21 @@ describe('DOMPropertyOperations', () => {
           return this._foo;
         },
       });
-      ReactDOM.render(<my-custom-element foo="two" />, container);
+      await act(() => {
+        root.render(<my-custom-element foo="two" />);
+      });
       expect(customElement.foo).toBe('two');
       expect(customElement.getAttribute('foo')).toBe('one');
     });
 
     // @gate enableCustomElementPropertySupport
-    it('custom element properties should accept functions', () => {
+    it('custom element properties should accept functions', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
-      ReactDOM.render(<my-custom-element />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       const customElement = container.querySelector('my-custom-element');
 
       // Install a setter to activate the `in` heuristic
@@ -1126,44 +1306,56 @@ describe('DOMPropertyOperations', () => {
       function myFunction() {
         return 'this is myFunction';
       }
-      ReactDOM.render(<my-custom-element foo={myFunction} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={myFunction} />);
+      });
       expect(customElement.foo).toBe(myFunction);
 
       // Also remove and re-add the property for good measure
-      ReactDOM.render(<my-custom-element />, container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
       expect(customElement.foo).toBe(null);
-      ReactDOM.render(<my-custom-element foo={myFunction} />, container);
+      await act(() => {
+        root.render(<my-custom-element foo={myFunction} />);
+      });
       expect(customElement.foo).toBe(myFunction);
     });
   });
 
   describe('deleteValueForProperty', () => {
-    it('should remove attributes for normal properties', () => {
+    it('should remove attributes for normal properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<div title="foo" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<div title="foo" />);
+      });
       expect(container.firstChild.getAttribute('title')).toBe('foo');
-      ReactDOM.render(<div />, container);
+      await act(() => {
+        root.render(<div />);
+      });
       expect(container.firstChild.getAttribute('title')).toBe(null);
     });
 
-    it('should not remove attributes for special properties', () => {
+    it('should not remove attributes for special properties', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(
-        <input type="text" value="foo" onChange={function () {}} />,
-        container,
-      );
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(
+          <input type="text" value="foo" onChange={function () {}} />,
+        );
+      });
       if (disableInputAttributeSyncing) {
         expect(container.firstChild.hasAttribute('value')).toBe(false);
       } else {
         expect(container.firstChild.getAttribute('value')).toBe('foo');
       }
       expect(container.firstChild.value).toBe('foo');
-      expect(() =>
-        ReactDOM.render(
-          <input type="text" onChange={function () {}} />,
-          container,
-        ),
-      ).toErrorDev(
+      await expect(async () => {
+        await act(() => {
+          root.render(<input type="text" onChange={function () {}} />);
+        });
+      }).toErrorDev(
         'A component is changing a controlled input to be uncontrolled',
       );
       if (disableInputAttributeSyncing) {
@@ -1174,9 +1366,12 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.value).toBe('foo');
     });
 
-    it('should not remove attributes for custom component tag', () => {
+    it('should not remove attributes for custom component tag', async () => {
       const container = document.createElement('div');
-      ReactDOM.render(<my-icon size="5px" />, container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-icon size="5px" />);
+      });
       expect(container.firstChild.getAttribute('size')).toBe('5px');
     });
   });

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 87885ca07b..05e1d1234e 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -21,7 +21,6 @@ describe('DOMPropertyOperations', () => {
   let act;
 
   beforeEach(() => {
-    jest.resetModules();
     React = require('react');
     ReactDOMClient = require('react-dom/client');
     ({act} = require('internal-test-utils'));

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 05e1d1234e..87885ca07b 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -21,6 +21,7 @@ describe('DOMPropertyOperations', () => {
   let act;
 
   beforeEach(() => {
+    jest.resetModules();
     React = require('react');
     ReactDOMClient = require('react-dom/client');
     ({act} = require('internal-test-utils'));

commit eb510a33048fabd95d272b1c0b65f941e2909240
Author: Andrey Lunyov <alunyov@meta.com>
Date:   Fri Mar 29 13:06:07 2024 -0400

    Land enableCustomElementPropertySupport for React 19 (#27450)
    
    We've rolled out this flag internally on WWW. This PR removed flag
    `enableCustomElementPropertySupport`
    
    Test plan:
     -- `yarn test`
    
    Co-authored-by: Ricky Hanlon <rickhanlonii@gmail.com>

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 87885ca07b..1ca571df71 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -10,10 +10,7 @@
 'use strict';
 
 // Set by `yarn test-fire`.
-const {
-  enableCustomElementPropertySupport,
-  disableInputAttributeSyncing,
-} = require('shared/ReactFeatureFlags');
+const {disableInputAttributeSyncing} = require('shared/ReactFeatureFlags');
 
 describe('DOMPropertyOperations', () => {
   let React;
@@ -234,7 +231,6 @@ describe('DOMPropertyOperations', () => {
       expect(container.firstChild.hasAttribute('value')).toBe(false);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element custom events lowercase', async () => {
       const oncustomevent = jest.fn();
       function Test() {
@@ -251,7 +247,6 @@ describe('DOMPropertyOperations', () => {
       expect(oncustomevent).toHaveBeenCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element custom events uppercase', async () => {
       const oncustomevent = jest.fn();
       function Test() {
@@ -268,7 +263,6 @@ describe('DOMPropertyOperations', () => {
       expect(oncustomevent).toHaveBeenCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element custom event with dash in name', async () => {
       const oncustomevent = jest.fn();
       function Test() {
@@ -285,7 +279,6 @@ describe('DOMPropertyOperations', () => {
       expect(oncustomevent).toHaveBeenCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element remove event handler', async () => {
       const oncustomevent = jest.fn();
       function Test(props) {
@@ -343,12 +336,8 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.getAttribute('onstring')).toBe('hello');
       expect(customElement.getAttribute('onobj')).toBe('[object Object]');
       expect(customElement.getAttribute('onarray')).toBe('one,two');
-      expect(customElement.getAttribute('ontrue')).toBe(
-        enableCustomElementPropertySupport ? '' : 'true',
-      );
-      expect(customElement.getAttribute('onfalse')).toBe(
-        enableCustomElementPropertySupport ? null : 'false',
-      );
+      expect(customElement.getAttribute('ontrue')).toBe('');
+      expect(customElement.getAttribute('onfalse')).toBe(null);
 
       // Dispatch the corresponding event names to make sure that nothing crashes.
       customElement.dispatchEvent(new Event('string'));
@@ -385,7 +374,6 @@ describe('DOMPropertyOperations', () => {
       expect(syntheticClickEvent.nativeEvent).toBe(nativeClickEvent);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom elements should have working onChange event listeners', async () => {
       let reactChangeEvent = null;
       const eventHandler = jest.fn(event => (reactChangeEvent = event));
@@ -450,7 +438,6 @@ describe('DOMPropertyOperations', () => {
       expect(eventHandler).toHaveBeenCalledTimes(expectedHandlerCallCount);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom elements should have separate onInput and onChange handling', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -476,7 +463,6 @@ describe('DOMPropertyOperations', () => {
       expect(changeEventHandler).toHaveBeenCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom elements should be able to remove and re-add custom event listeners', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -758,7 +744,6 @@ describe('DOMPropertyOperations', () => {
       expect(customOnClickHandler).toHaveBeenCalledTimes(0);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('onChange/onInput/onClick on div with various types of children', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -951,7 +936,6 @@ describe('DOMPropertyOperations', () => {
       expect(onClickHandler).toBeCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element onChange/onInput/onClick with event target custom element child', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -987,7 +971,6 @@ describe('DOMPropertyOperations', () => {
       expect(onClickHandler).toBeCalledTimes(1);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom elements should allow custom events with capture event listeners', async () => {
       const oncustomeventCapture = jest.fn();
       const oncustomevent = jest.fn();
@@ -1031,7 +1014,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('innerText should not work on custom elements', async () => {
       const container = document.createElement('div');
       const root = ReactDOMClient.createRoot(container);
@@ -1051,7 +1033,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('textContent should not work on custom elements', async () => {
       const container = document.createElement('div');
       const root = ReactDOMClient.createRoot(container);
@@ -1071,7 +1052,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.hasChildNodes()).toBe(false);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('values should not be converted to booleans when assigning into custom elements', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -1123,7 +1103,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.foo).toBe(null);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('boolean props should not be stringified in attributes', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -1143,7 +1122,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.getAttribute('foo')).toBe(null);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element custom event handlers assign multiple types', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -1197,7 +1175,6 @@ describe('DOMPropertyOperations', () => {
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element custom event handlers assign multiple types with setter', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -1257,7 +1234,6 @@ describe('DOMPropertyOperations', () => {
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
     });
 
-    // @gate enableCustomElementPropertySupport
     it('assigning to a custom element property should not remove attributes', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);
@@ -1284,7 +1260,6 @@ describe('DOMPropertyOperations', () => {
       expect(customElement.getAttribute('foo')).toBe('one');
     });
 
-    // @gate enableCustomElementPropertySupport
     it('custom element properties should accept functions', async () => {
       const container = document.createElement('div');
       document.body.appendChild(container);

commit 48ec17b865f439754fcdaa289ef0aa98f15a05c2
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Tue Apr 2 11:48:27 2024 -0400

    Differentiate null and undefined in Custom Elements - removing sets to undefined (#28716)
    
    In React DOM, in general, we don't differentiate between `null` and
    `undefined` because we expect to target DOM APIs. When we're setting a
    property on a Custom Element, in the new heuristic, the goal is to allow
    passing whatever data type instead of normalizing it. Switching between
    `undefined` and `null` as an explicit value should therefore be
    respected.
    
    However, in this mode if `undefined` is used for the initial value, we
    don't actually set the property at all. If passing `null` we will now
    initialize it to the value `null`. Meaning `undefined` kind of
    represents the default.
    
    ### Removing Properties
    
    There is a pretty complex edge case which is what should happen when a
    prop used to exist but was removed from the props object. This doesn't
    have any kind of defined semantics. It really should mean - return to
    "default". Because in the declarative world it means the same as if it
    was just created - i.e. we can't just leave it as it was.
    
    The closest might be `delete object.property` but that's not really the
    intended way that properties on custom elements / classes are supposed
    to operate. Additionally, for a property to even hit our heuristic it
    must pass the `in` test and must exist to being with so the default must
    have a value.
    
    Since the point of these properties is to contain any kind of type,
    there isn't really a conceptual default value. E.g. a numeric default
    value might be zero `0` while a default string might be empty `""` and
    default object might `null`. Additionally, the conceptual default can
    really be initialized to anything. There's also varied precedence in the
    ecosystem here and really no consensus. Anything we pick would be kind
    of wrong, so we used to just pick `null`.
    
    _The safest way to consume a Custom Element is to always pass the same
    set of props._
    
    JS does have a concept of a "default value" though and that is described
    as the value `undefined`. That's why default argument / object property
    initializers are initialized if the value is `undefined`.
    
    The problem with using `undefined` as value is that [you shouldn't
    actually ever set the value of a class property to
    `undefined`](https://twitter.com/sebmarkbage/status/1774082540296388752).
    A property should always be initialized to some value. It can't be left
    missing and shouldn't be initialized to the value `undefined` for hidden
    class optimizations. If we just mutate it to be `undefined` it would be
    potentially bad for perf and shouldn't really be the value after
    removing property - it should be returned to default.
    
    Every property should really have a setter to be useful since it is what
    is used to trigger reactivity when it changes. Sometimes you can just
    use the properties passively when something else happens but most of the
    time it should be a setter but to reach parity with DOM it should really
    be always so that the active value can be normalized.
    
    Those setters can have default argument initializers to represent what
    the default value should be. Therefore Custom Element properties should
    be used like this:
    
    ```js
    class CustomElement extends HTMLElement {
      _textLabel = '';
      _price = 0;
      _items = null;
    
      constructor() {
        super();
      }
      set textLabel(value = '') {
        this._textLabel = value;
      }
      get textLabel() {
        return this._textLabel;
      }
      set price(value = 0) {
        this._price = value;
      }
      get price() {
        return this._price;
      }
      set items(value = null) {
        this._items = value;
      }
      get items() {
        return this._items;
      }
    }
    ```
    
    The default initializer can be used to initialize a value back to its
    original default when `undefined` is passed to it. Therefore, we pass
    `undefined`, not because we expect that to be the value of a property
    but because that's the value that represents "return to default".
    
    This fixes #28203 but not really for the reason specified in the issue.
    We don't expect you to actually store the `undefined` value but to use a
    setter to set the property to something else that represents the
    default. When we initialize the element the first time, we won't set
    anything if it's the value `undefined` so we assume that the property
    initializers running in the constructor is going to set the same default
    value as if we set the property to `undefined`.
    
    cc @josepharhar

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index 1ca571df71..e6565d0097 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1230,7 +1230,7 @@ describe('DOMPropertyOperations', () => {
       });
       customelement.dispatchEvent(new Event('customevent'));
       expect(oncustomevent).toHaveBeenCalledTimes(2);
-      expect(customelement.oncustomevent).toBe(null);
+      expect(customelement.oncustomevent).toBe(undefined);
       expect(customelement.getAttribute('oncustomevent')).toBe(null);
     });
 
@@ -1290,12 +1290,33 @@ describe('DOMPropertyOperations', () => {
       await act(() => {
         root.render(<my-custom-element />);
       });
-      expect(customElement.foo).toBe(null);
+      expect(customElement.foo).toBe(undefined);
       await act(() => {
         root.render(<my-custom-element foo={myFunction} />);
       });
       expect(customElement.foo).toBe(myFunction);
     });
+
+    it('switching between null and undefined should update a property', async () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element foo={undefined} />);
+      });
+      const customElement = container.querySelector('my-custom-element');
+      customElement.foo = undefined;
+
+      await act(() => {
+        root.render(<my-custom-element foo={null} />);
+      });
+      expect(customElement.foo).toBe(null);
+
+      await act(() => {
+        root.render(<my-custom-element foo={undefined} />);
+      });
+      expect(customElement.foo).toBe(undefined);
+    });
   });
 
   describe('deleteValueForProperty', () => {
@@ -1349,5 +1370,53 @@ describe('DOMPropertyOperations', () => {
       });
       expect(container.firstChild.getAttribute('size')).toBe('5px');
     });
+
+    it('custom elements should remove by setting undefined to restore defaults', async () => {
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
+      const customElement = container.querySelector('my-custom-element');
+
+      // Non-setter but existing property to active the `in` heuristic
+      customElement.raw = 1;
+
+      // Install a setter to activate the `in` heuristic
+      Object.defineProperty(customElement, 'object', {
+        set: function (value = null) {
+          this._object = value;
+        },
+        get: function () {
+          return this._object;
+        },
+      });
+
+      Object.defineProperty(customElement, 'string', {
+        set: function (value = '') {
+          this._string = value;
+        },
+        get: function () {
+          return this._string;
+        },
+      });
+
+      const obj = {};
+      await act(() => {
+        root.render(<my-custom-element raw={2} object={obj} string="hi" />);
+      });
+      expect(customElement.raw).toBe(2);
+      expect(customElement.object).toBe(obj);
+      expect(customElement.string).toBe('hi');
+
+      // Removing the properties should reset to defaults by passing undefined
+      await act(() => {
+        root.render(<my-custom-element />);
+      });
+      expect(customElement.raw).toBe(undefined);
+      expect(customElement.object).toBe(null);
+      expect(customElement.string).toBe('');
+    });
   });
 });

commit 6f903651283861af4e5a8838b3b74d2a953a0acc
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Mon May 20 13:01:39 2024 -0700

    React DOM: Add support for Popover API (#27981)

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index e6565d0097..fb5281a02a 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -16,12 +16,13 @@ describe('DOMPropertyOperations', () => {
   let React;
   let ReactDOMClient;
   let act;
+  let assertConsoleErrorDev;
 
   beforeEach(() => {
     jest.resetModules();
     React = require('react');
     ReactDOMClient = require('react-dom/client');
-    ({act} = require('internal-test-utils'));
+    ({act, assertConsoleErrorDev} = require('internal-test-utils'));
   });
 
   // Sets a value in a way that React doesn't see,
@@ -1317,6 +1318,33 @@ describe('DOMPropertyOperations', () => {
       });
       expect(customElement.foo).toBe(undefined);
     });
+
+    it('warns when using popoverTarget={HTMLElement}', async () => {
+      const popoverTarget = document.createElement('div');
+      const container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
+
+      await act(() => {
+        root.render(
+          <button key="one" popoverTarget={popoverTarget}>
+            Toggle popover
+          </button>,
+        );
+      });
+
+      assertConsoleErrorDev([
+        'The `popoverTarget` prop expects the ID of an Element as a string. Received [object HTMLDivElement] instead.',
+      ]);
+
+      // Dedupe warning
+      await act(() => {
+        root.render(
+          <button key="two" popoverTarget={popoverTarget}>
+            Toggle popover
+          </button>,
+        );
+      });
+    });
   });
 
   describe('deleteValueForProperty', () => {

commit 277420803947724b43c47bbc47d3a353553868f1
Author: Sebastian MarkbÃ¥ge <sebastian@calyptus.eu>
Date:   Mon Jun 10 18:41:56 2024 -0400

    Remove Warning: prefix and toString on console Arguments (#29839)
    
    Basically make `console.error` and `console.warn` behave like normal -
    when a component stack isn't appended. I need this because I need to be
    able to print rich logs with the component stack option and to be able
    to disable instrumentation completely in `console.createTask`
    environments that don't need it.
    
    Currently we can't print logs with richer objects because they're
    toString:ed first. In practice, pretty much all arguments we log are
    already toString:ed so it's not necessary anyway. Some might be like a
    number. So it would only be a problem if some environment can't handle
    proper consoles but then it's up to that environment to toString it
    before logging.
    
    The `Warning: ` prefix is historic and is both noisy and confusing. It's
    mostly unnecessary since the UI surrounding `console.error` and
    `console.warn` tend to have visual treatment around it anyway. However,
    it's actively misleading when `console.error` gets prefixed with a
    Warning that we consider an error level. There's an argument to be made
    that some of our `console.error` don't make the bar for an error but
    then the argument is to downgrade each of those to `console.warn` - not
    to brand all our actual error logging with `Warning: `.
    
    Apparently something needs to change in React Native before landing this
    because it depends on the prefix somehow which probably doesn't make
    sense already.

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index fb5281a02a..cecc71b45a 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1333,7 +1333,7 @@ describe('DOMPropertyOperations', () => {
       });
 
       assertConsoleErrorDev([
-        'The `popoverTarget` prop expects the ID of an Element as a string. Received [object HTMLDivElement] instead.',
+        'The `popoverTarget` prop expects the ID of an Element as a string. Received HTMLDivElement {} instead.',
       ]);
 
       // Dedupe warning

commit a7c898d83a991c48f3981fcc65d969f1d90d80a1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jan 2 15:28:06 2025 -0500

    [assert helpers] react-dom (pt 1) (#31897)
    
    Converts ~half of react-dom tests

diff --git a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
index cecc71b45a..ef09e49bf3 100644
--- a/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
+++ b/packages/react-dom/src/__tests__/DOMPropertyOperations-test.js
@@ -1333,7 +1333,8 @@ describe('DOMPropertyOperations', () => {
       });
 
       assertConsoleErrorDev([
-        'The `popoverTarget` prop expects the ID of an Element as a string. Received HTMLDivElement {} instead.',
+        'The `popoverTarget` prop expects the ID of an Element as a string. Received HTMLDivElement {} instead.\n' +
+          '    in button (at **)',
       ]);
 
       // Dedupe warning
@@ -1375,13 +1376,17 @@ describe('DOMPropertyOperations', () => {
         expect(container.firstChild.getAttribute('value')).toBe('foo');
       }
       expect(container.firstChild.value).toBe('foo');
-      await expect(async () => {
-        await act(() => {
-          root.render(<input type="text" onChange={function () {}} />);
-        });
-      }).toErrorDev(
-        'A component is changing a controlled input to be uncontrolled',
-      );
+      await act(() => {
+        root.render(<input type="text" onChange={function () {}} />);
+      });
+      assertConsoleErrorDev([
+        'A component is changing a controlled input to be uncontrolled. ' +
+          'This is likely caused by the value changing from a defined to undefined, ' +
+          'which should not happen. Decide between using a controlled or uncontrolled ' +
+          'input element for the lifetime of the component. ' +
+          'More info: https://react.dev/link/controlled-components\n' +
+          '    in input (at **)',
+      ]);
       if (disableInputAttributeSyncing) {
         expect(container.firstChild.hasAttribute('value')).toBe(false);
       } else {

