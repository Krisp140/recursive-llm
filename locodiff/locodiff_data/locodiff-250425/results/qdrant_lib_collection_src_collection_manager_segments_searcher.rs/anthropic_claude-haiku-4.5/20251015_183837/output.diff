
index 8096e53f4..cf8f4441b 100644
--- a/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected):tmp/tmpcrt0zt8i_expected.txt	
+++ b/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual):tmp/tmpo8v_crg9_actual.txt	
@@ -228,7 +228,24 @@ impl SegmentsSearcher {
                 }
 
                 let segments = segments.non_appendable_then_appendable_segments();
-                for locked_segment in segments {
+                let available_point_count = segments
+                    .map(|segment| segment.get().read().available_point_count())
+                    .sum();
+                Some(available_point_count)
+            })
+        };
+
+        let Some(_available_point_count) = task.await? else {
+            return Ok(None);
+        };
+
+        // Fill query context with IDF stats from segments
+        let task = {
+            let segments = segments.clone();
+
+            tokio::task::spawn_blocking(move || {
+                let segments = segments.read();
+                for locked_segment in segments.non_appendable_then_appendable_segments() {
                     let segment = locked_segment.get();
                     let segment_guard = segment.read();
                     segment_guard.fill_query_context(&mut query_context);
@@ -374,6 +391,8 @@ impl SegmentsSearcher {
     /// The points ids can contain duplicates, the records will be fetched only once
     ///
     /// If an id is not found in the segments, it won't be included in the output.
+    ///
+    /// If an id is not found in the segments, it won't be included in the output.
     pub async fn retrieve(
         segments: LockedSegmentHolder,
         points: &[PointIdType],
@@ -592,6 +611,12 @@ struct BatchSearchParams<'a> {
     pub params: Option<&'a SearchParams>,
 }
 
+/// Determines the effective ef limit value for the given parameters.
+fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {
+    // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit
+    poisson_sampling.max(ef_limit).min(limit)
+}
+
 /// Returns suggested search sampling size for a given number of points and required limit.
 fn sampling_limit(
     limit: usize,
@@ -617,12 +642,6 @@ fn sampling_limit(
     effective
 }
 
-/// Determines the effective ef limit value for the given parameters.
-fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {
-    // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit
-    poisson_sampling.max(ef_limit).min(limit)
-}
-
 /// Process sequentially contiguous batches
 ///
 /// # Arguments
@@ -845,7 +864,6 @@ mod tests {
             params: None,
             limit: 5,
             score_threshold: None,
-            offset: 0,
         };
 
         let batch_request = CoreSearchRequestBatch {
