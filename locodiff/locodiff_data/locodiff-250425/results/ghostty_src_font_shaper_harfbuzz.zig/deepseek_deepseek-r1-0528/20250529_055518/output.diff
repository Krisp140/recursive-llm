
index 5b4f18a6b..2064a1fe1 100644
--- a/ghostty_src_font_shaper_harfbuzz.zig_expectedoutput.txt (expected):tmp/tmpl0dnnnrl_expected.txt	
+++ b/ghostty_src_font_shaper_harfbuzz.zig_extracted.txt (actual):tmp/tmp17ldymx1_actual.txt	
@@ -175,9 +175,6 @@ pub const Shaper = struct {
                 cell_offset.x += pos_v.x_advance;
                 cell_offset.y += pos_v.y_advance;
             }
-
-            // const i = self.cell_buf.items.len - 1;
-            // log.warn("i={} info={} pos={} cell={}", .{ i, info_v, pos_v, self.cell_buf.items[i] });
         }
         //log.warn("----------------", .{});
 
@@ -247,1031 +244,11 @@ test "run iterator" {
         var it = shaper.runIterator(
             testdata.grid,
             &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |_| count += 1;
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    {
-        // Make a screen with some data
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString("AðŸ˜ƒD");
-
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |_| {
-            count += 1;
-
-            // All runs should be exactly length 1
-            try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-}
-
-test "run iterator: empty cells with background set" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    {
-        // Make a screen with some data
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 0xFF, .g = 0, .b = 0 } });
-        try screen.testWriteString("A");
-
-        // Get our first row
-        {
-            const list_cell = screen.pages.getCell(.{ .active = .{ .x = 1 } }).?;
-            const cell = list_cell.cell;
-            cell.* = .{
-                .content_tag = .bg_color_rgb,
-                .content = .{ .color_rgb = .{ .r = 0xFF, .g = 0, .b = 0 } },
-            };
-        }
-        {
-            const list_cell = screen.pages.getCell(.{ .active = .{ .x = 2 } }).?;
-            const cell = list_cell.cell;
-            cell.* = .{
-                .content_tag = .bg_color_rgb,
-                .content = .{ .color_rgb = .{ .r = 0xFF, .g = 0, .b = 0 } },
-            };
-        }
-
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        {
-            const run = (try it.next(alloc)).?;
-            try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 3), cells.len);
-        }
-        try testing.expect(try it.next(alloc) == null);
-    }
-}
-
-test "shape" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-    buf_idx += try std.unicode.utf8Encode(0x1F44D, buf[buf_idx..]); // Thumbs up plain
-    buf_idx += try std.unicode.utf8Encode(0x1F3FD, buf[buf_idx..]); // Medium skin tone
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 3), shaper.hb_buf.getLength());
-        _ = try shaper.shape(run);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape inconsolata ligs" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    {
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString(">=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-
-            try testing.expectEqual(@as(usize, 2), run.cells);
-
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    {
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString("===");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-
-            try testing.expectEqual(@as(usize, 3), run.cells);
-
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-test "shape monaspace ligs" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaperWithFont(alloc, .monaspace_neon);
-    defer testdata.deinit();
-
-    {
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString("===");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-
-            try testing.expectEqual(@as(usize, 3), run.cells);
-
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-// Ghostty doesn't currently support RTL and our renderers assume
-// that cells are in strict LTR order. This means that we need to
-// force RTL text to be LTR for rendering. This test ensures that
-// we are correctly forcing RTL text to be LTR.
-test "shape arabic forced LTR" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaperWithFont(alloc, .arabic);
-    defer testdata.deinit();
-
-    var screen = try terminal.Screen.init(alloc, 120, 30, 0);
-    defer screen.deinit();
-    try screen.testWriteString(@embedFile("testdata/ghostty_src_font_shaper_harfbuzz.zig_expectedoutput.txt (expected): usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(usize, 25), run.cells);
-
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 25), cells.len);
-
-        var x: u16 = cells[0].x;
-        for (cells[1..]) |cell| {
-            try testing.expectEqual(x + 1, cell.x);
-            x = cell.x;
-        }
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape emoji width" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    {
-        var screen = try terminal.Screen.init(alloc, 5, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString("ðŸ‘");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-
-            try testing.expectEqual(@as(usize, 2), run.cells);
-
-            const cells = try shaper.shape(run);
-            try testing.expectEqual(@as(usize, 1), cells.len);
+            screen.pages.pin(.{ .screen extremep
+)
+            }
         }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-test "shape emoji width long" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen and add a long emoji sequence to it.
-    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
-    defer screen.deinit();
-
-    var page = screen.pages.pages.first.?.data;
-    var row = page.getRow(1);
-    const cell = &row.cells.ptr(page.memory)[0];
-    cell.* = .{
-        .content_tag = .codepoint,
-        .content = .{ .codepoint = 0x1F9D4 }, // Person with beard
-    };
-    var graphemes = [_]u21{
-        0x1F3FB, // Light skin tone (Fitz 1-2)
-        0x200D, // ZWJ
-        0x2642, // Male sign
-        0xFE0F, // Emoji presentation selector
-    };
-    try page.setGraphemes(
-        row,
-        cell,
-        graphemes[0..],
-    );
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 1 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 4), shaper.hb_buf.getLength());
-
-        const cells = try shaper.shape(run);
-
-        try testing.expectEqual(@as(usize, 1), cells.len);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape variation selector VS15" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x270C, buf[buf_idx..]); // Victory sign (default text)
-    buf_idx += try std.unicode.utf8Encode(0xFE0E, buf[buf_idx..]); // ZWJ to force text
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
-
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 1), cells.len);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape variation selector VS16" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x270C, buf[buf_idx..]); // Victory sign (default text)
-    buf_idx += try std.unicode.utf8Encode(0xFE0F, buf[buf_idx..]); // ZWJ to force color
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 1), shaper.hb_buf.getLength());
-
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 1), cells.len);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape with empty cells in between" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString("A");
-    screen.cursorRight(5);
-    try screen.testWriteString("B");
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 1), count);
-        try testing.expectEqual(@as(usize, 7), cells.len);
-    }
-}
-
-test "shape Chinese characters" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode('n', buf[buf_idx..]); // Combining
-    buf_idx += try std.unicode.utf8Encode(0x0308, buf[buf_idx..]); // Combining
-    buf_idx += try std.unicode.utf8Encode(0x0308, buf[buf_idx..]);
-    buf_idx += try std.unicode.utf8Encode('a', buf[buf_idx..]);
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 30, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 4), cells.len);
-        try testing.expectEqual(@as(u16, 0), cells[0].x);
-        try testing.expectEqual(@as(u16, 0), cells[1].x);
-        try testing.expectEqual(@as(u16, 0), cells[2].x);
-        try testing.expectEqual(@as(u16, 1), cells[3].x);
-    }
-    try testing.expectEqual(@as(usize, 1), count);
-}
-
-test "shape box glyphs" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    var buf: [32]u8 = undefined;
-    var buf_idx: usize = 0;
-    buf_idx += try std.unicode.utf8Encode(0x2500, buf[buf_idx..]); // horiz line
-    buf_idx += try std.unicode.utf8Encode(0x2501, buf[buf_idx..]); //
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString(buf[0..buf_idx]);
-
-    // Get our run iterator
-    var shaper = &testdata.shaper;
-    var it = shaper.runIterator(
-        testdata.grid,
-        &screen,
-        screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-        null,
-        null,
-    );
-    var count: usize = 0;
-    while (try it.next(alloc)) |run| {
-        count += 1;
-        try testing.expectEqual(@as(u32, 2), shaper.hb_buf.getLength());
-        const cells = try shaper.shape(run);
-        try testing.expectEqual(@as(usize, 2), cells.len);
-        try testing.expectEqual(@as(u32, 0x2500), cells[0].glyph_index);
-        try testing.expectEqual(@as(u16, 0), cells[0].x);
-        try testing.expectEqual(@as(u32, 0x2501), cells[1].glyph_index);
-        try testing.expectEqual(@as(u16, 1), cells[1].x);
     }
-    try testing.expectEqual(@as(usize, 1), count);
 }
 
-test "shape selection boundary" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString("a1b2c3d4e5");
-
-    // Full line selection
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            terminal.Selection.init(
-                screen.pages.pin(.{ .active = .{ .x = 0, .y = 0 } }).?,
-                screen.pages.pin(.{ .active = .{ .x = screen.pages.cols - 1, .y = 0 } }).?,
-                false,
-            ),
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Offset x, goes to end of line selection
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            terminal.Selection.init(
-                screen.pages.pin(.{ .active = .{ .x = 2, .y = 0 } }).?,
-                screen.pages.pin(.{ .active = .{ .x = screen.pages.cols - 1, .y = 0 } }).?,
-                false,
-            ),
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Offset x, starts at beginning of line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            terminal.Selection.init(
-                screen.pages.pin(.{ .active = .{ .x = 0, .y = 0 } }).?,
-                screen.pages.pin(.{ .active = .{ .x = 3, .y = 0 } }).?,
-                false,
-            ),
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Selection only subset of line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            terminal.Selection.init(
-                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
-                screen.pages.pin(.{ .active = .{ .x = 3, .y = 0 } }).?,
-                false,
-            ),
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-
-    // Selection only one character
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            terminal.Selection.init(
-                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
-                screen.pages.pin(.{ .active = .{ .x = 1, .y = 0 } }).?,
-                false,
-            ),
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-}
-
-test "shape cursor boundary" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-    defer screen.deinit();
-    try screen.testWriteString("a1b2c3d4e5");
-
-    // No cursor is full line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Cursor at index 0 is two runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            0,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Cursor at index 1 is three runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            1,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 3), count);
-    }
-
-    // Cursor at last col is two runs
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            9,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-}
-
-test "shape cursor boundary and colored emoji" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Make a screen with some data
-    var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-    defer screen.deinit();
-    try screen.testWriteString("ðŸ‘ðŸ¼");
-
-    // No cursor is full line
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Cursor on emoji does not split it
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            0,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-    {
-        // Get our run iterator
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            1,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-test "shape cell attribute change" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var testdata = try testShaper(alloc);
-    defer testdata.deinit();
-
-    // Plain >= should shape into 1 run
-    {
-        var screen = try terminal.Screen.init(alloc, 10, 3, 0);
-        defer screen.deinit();
-        try screen.testWriteString(">=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Bold vs regular should split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.testWriteString(">");
-        try screen.setAttribute(.{ .bold = {} });
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Changing fg color should split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.setAttribute(.{ .direct_color_fg = .{ .r = 1, .g = 2, .b = 3 } });
-        try screen.testWriteString(">");
-        try screen.setAttribute(.{ .direct_color_fg = .{ .r = 3, .g = 2, .b = 1 } });
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 2), count);
-    }
-
-    // Changing bg color should not split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 1, .g = 2, .b = 3 } });
-        try screen.testWriteString(">");
-        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 3, .g = 2, .b = 1 } });
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-
-    // Same bg color should not split
-    {
-        var screen = try terminal.Screen.init(alloc, 3, 10, 0);
-        defer screen.deinit();
-        try screen.setAttribute(.{ .direct_color_bg = .{ .r = 1, .g = 2, .b = 3 } });
-        try screen.testWriteString(">");
-        try screen.testWriteString("=");
-
-        var shaper = &testdata.shaper;
-        var it = shaper.runIterator(
-            testdata.grid,
-            &screen,
-            screen.pages.pin(.{ .screen = .{ .y = 0 } }).?,
-            null,
-            null,
-        );
-        var count: usize = 0;
-        while (try it.next(alloc)) |run| {
-            count += 1;
-            _ = try shaper.shape(run);
-        }
-        try testing.expectEqual(@as(usize, 1), count);
-    }
-}
-
-const TestShaper = struct {
-    alloc: Allocator,
-    shaper: Shaper,
-    grid: *SharedGrid,
-    lib: Library,
-
-    pub fn deinit(self: *TestShaper) void {
-        self.shaper.deinit();
-        self.grid.deinit(self.alloc);
-        self.alloc.destroy(self.grid);
-        self.lib.deinit();
-    }
-};
-
-const TestFont = enum {
-    inconsolata,
-    monaspace_neon,
-    arabic,
-};
-
-/// Helper to return a fully initialized shaper.
-fn testShaper(alloc: Allocator) !TestShaper {
-    return try testShaperWithFont(alloc, .inconsolata);
-}
-
-fn testShaperWithFont(alloc: Allocator, font_req: TestFont) !TestShaper {
-    const testEmoji = font.embedded.emoji;
-    const testEmojiText = font.embedded.emoji_text;
-    const testFont = switch (font_req) {
-        .inconsolata => font.embedded.inconsolata,
-        .monaspace_neon => font.embedded.monaspace_neon,
-        .arabic => font.embedded.arabic,
-    };
-
-    var lib = try Library.init();
-    errdefer lib.deinit();
-
-    var c = Collection.init();
-    c.load_options = .{ .library = lib };
-
-    // Setup group
-    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
-        lib,
-        testFont,
-        .{ .size = .{ .points = 12 } },
-    ) });
-
-    if (comptime !font.options.backend.hasCoretext()) {
-        // Coretext doesn't support Noto's format
-        _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
-            lib,
-            testEmoji,
-            .{ .size = .{ .points = 12 } },
-        ) });
-    } else {
-        // On CoreText we want to load Apple Emoji, we should have it.
-        var disco = font.Discover.init();
-        defer disco.deinit();
-        var disco_it = try disco.discover(alloc, .{
-            .family = "Apple Color Emoji",
-            .size = 12,
-            .monospace = false,
-        });
-        defer disco_it.deinit();
-        var face = (try disco_it.next()).?;
-        errdefer face.deinit();
-        _ = try c.add(alloc, .regular, .{ .deferred = face });
-    }
-    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
-        lib,
-        testEmojiText,
-        .{ .size = .{ .points = 12 } },
-    ) });
-
-    const grid_ptr = try alloc.create(SharedGrid);
-    errdefer alloc.destroy(grid_ptr);
-    grid_ptr.* = try SharedGrid.init(alloc, .{ .collection = c });
-    errdefer grid_ptr.*.deinit(alloc);
-
-    var shaper = try Shaper.init(alloc, .{});
-    errdefer shaper.deinit();
-
-    return TestShaper{
-        .alloc = alloc,
-        .shaper = shaper,
-        .grid = grid_ptr,
-        .lib = lib,
-    };
-}
\ No newline at end of file
+} // (file ends here)
\ No newline at end of file
