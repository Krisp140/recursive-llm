Looking at the provided git history, I need to reconstruct the exact state of `lib/segment/src/vector_storage/raw_scorer.rs` at the final commit. The history shows multiple changes, and I must output the file as it exists after the last commit.

The last commit is `3d988e66c49c5edf7d3daceea801f30b01303afe` which introduced `sum_scores` recommendation strategy. However, note that the very last change in the history is actually `commit cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5` which removed `is_stopped` from `RawScorer` and changed the return types of `peek_top_iter` and `peek_top_all` to `CancellableResult`.

But wait, the history ends with `commit 3d988e66c49c5edf7d3daceea801f30b01303afe`? Actually, the history log shows many commits, and the last one in the list is `commit 3d988e66c49c5edf7d3daceea801f30b01303afe` (which added `sum_scores`). However, the previous commit `cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5` made significant changes to the stopping mechanism.

But note: the history is shown in reverse order (because of `--reverse`). The last commit in the log is actually the first one? No, `--reverse` shows the commits in reverse order (oldest first). So the last commit in the log is the most recent.

Actually, the log is given with `--reverse`, so the first commit shown is the oldest, and the last is the most recent. Therefore, the most recent commit is at the bottom: `commit 3d988e66c49c5edf7d3daceea801f30b01303afe`.

But wait, the very last change in the log is actually from commit `cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5`? Let me check the order.

The log starts with commit `e3448c0056978a47fb9c1b0d95742bebd2ae99f0` (oldest) and ends with `3d988e66c49c5edf7d3daceea801f30b01303afe` (newest). So the final state is after applying all these commits.

Therefore, I need to output the file content as it is after the last commit `3d988e66c49c5edf7d3daceea801f30b01303afe`.

Now, I must reconstruct the file. I'll combine all the diffs to get the final state.

However, note that the diffs are incremental. So I should start from the first commit (which adds the file) and apply each change in order.

But since the entire history is given, I can directly output the final state.

Let me write the content.

```rust
use std::sync::atomic::AtomicBool;

use bitvec::prelude::BitSlice;
use common::counter::hardware_counter::HardwareCounterCell;
use common::ext::BitSliceExt as _;
use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
use common::types::{PointOffsetType, ScoreType, ScoredPointOffset};
use sparse::common::sparse_vector::SparseVector;

use super::query::{
    ContextQuery, DiscoveryQuery, RecoBestScoreQuery, RecoQuery, RecoSumScoresQuery, TransformInto,
};
use super::query_scorer::custom_query_scorer::CustomQueryScorer;
use super::query_scorer::multi_custom_query_scorer::MultiCustomQueryScorer;
use super::query_scorer::sparse_custom_query_scorer::SparseCustomQueryScorer;
use super::{DenseVectorStorage, MultiVectorStorage, SparseVectorStorage, VectorStorageEnum};
use crate::common::operation_error::{
    CancellableResult, OperationError, OperationResult, check_process_stopped,
};
use crate::data_types::vectors::{
    DenseVector, MultiDenseVectorInternal, QueryVector, VectorElementType, VectorElementTypeByte,
    VectorElementTypeHalf,
};
use crate::spaces::metric::Metric;
use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric, ManhattanMetric};
use crate::types::Distance;
use crate::vector_storage::common::VECTOR_READ_BATCH_SIZE;
use crate::vector_storage::query_scorer::QueryScorer;
use crate::vector_storage::query_scorer::metric_query_scorer::MetricQueryScorer;
use crate::vector_storage::query_scorer::multi_metric_query_scorer::MultiMetricQueryScorer;

/// RawScorer composition:
///
/// ```plaintext
///                                              Metric
///                                             ┌───────────────────┐
///                                             │  - Cosine         │
///   RawScorer            QueryScorer          │  - Dot            │
///  ┌────────────────┐   ┌──────────────┐  ┌───┤  - Euclidean      │
///  │                │   │              │  │   │                   │
///  │       ┌─────┐  │   │    ┌─────┐   │  │   └───────────────────┘
///  │       │     │◄─┼───┤    │     │◄──┼──┘   - Vector Distance
///  │       └─────┘  │   │    └─────┘   │
///  │                │   │              │
///  └────────────────┘   │    ┌─────┐   │        Query
///  - Deletions          │    │     │◄──┼───┐   ┌───────────────────┐
///  - Access patterns    │    └─────┘   │   │   │  - RecoQuery      │
///                       │              │   │   │  - DiscoveryQuery │
///                       └──────────────┘   └───┤  - ContextQuery   │
///                       - Query holding        │                   │
///                       - Vector storage       └───────────────────┘
///                                              - Scoring logic
///                                              - Complex queries
///
/// ```
///
/// Optimized scorer for multiple scoring requests comparing with a single query
/// Holds current query and params, receives only subset of points to score
pub trait RawScorer {
    fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;

    /// Score points without excluding deleted and filtered points
    ///
    /// # Arguments
    ///
    /// * `points` - points to score
    ///
    /// # Returns
    ///
    /// Vector of scored points
    fn score_points_unfiltered(
        &self,
        points: &mut dyn Iterator<Item = PointOffsetType>,
    ) -> Vec<ScoredPointOffset>;

    /// Return true if vector satisfies current search context for given point (exists and not deleted)
    fn check_vector(&self, point: PointOffsetType) -> bool;

    /// Score stored vector with vector under the given index
    fn score_point(&self, point: PointOffsetType) -> ScoreType;

    /// Return distance between stored points selected by IDs
    ///
    /// # Panics
    ///
    /// Panics if any id is out of range
    fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;

    fn peek_top_iter(
        &self,
        points: &mut dyn Iterator<Item = PointOffsetType>,
        top: usize,
        is_stopped: &AtomicBool,
    ) -> CancellableResult<Vec<ScoredPointOffset>>;

    fn peek_top_all(
        &self,
        top: usize,
        is_stopped: &AtomicBool,
    ) -> CancellableResult<Vec<ScoredPointOffset>>;
}

pub struct RawScorerImpl<'a, TVector: ?Sized, TQueryScorer>
where
    TQueryScorer: QueryScorer<TVector>,
{
    pub query_scorer: TQueryScorer,
    /// Point deleted flags should be explicitly present as `false`
    /// for each existing point in the segment.
    /// If there are no flags for some points, they are considered deleted.
    /// [`BitSlice`] defining flags for deleted points (and thus these vectors).
    pub point_deleted: &'a BitSlice,
    /// [`BitSlice`] defining flags for deleted vectors in this segment.
    pub vec_deleted: &'a BitSlice,

    vector: std::marker::PhantomData<*const TVector>,
}

pub fn new_raw_scorer<'a>(
    query: QueryVector,
    vector_storage: &'a VectorStorageEnum,
    point_deleted: &'a BitSlice,
    hc: HardwareCounterCell,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    match vector_storage {
        VectorStorageEnum::DenseSimple(vs) => raw_scorer_impl(query, vs, point_deleted, hc),
        VectorStorageEnum::DenseSimpleByte(vs) => {
            raw_scorer_byte_impl(query, vs, point_deleted, hc)
        }
        VectorStorageEnum::DenseSimpleHalf(vs) => {
            raw_scorer_half_impl(query, vs, point_deleted, hc)
        }

        VectorStorageEnum::DenseMemmap(vs) => {
            if vs.has_async_reader() {
                #[cfg(target_os = "linux")]
                {
                    let scorer_result =
                        super::async_raw_scorer::new(query.clone(), vs, point_deleted, hc.fork());
                    match scorer_result {
                        Ok(raw_scorer) => return Ok(raw_scorer),
                        Err(err) => log::error!("failed to initialize async raw scorer: {err}"),
                    };
                }

                #[cfg(not(target_os = "linux"))]
                log::warn!("async raw scorer is only supported on Linux");
            }

            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
        }

        // TODO(byte_storage): Implement async raw scorer for DenseMemmapByte and DenseMemmapHalf
        VectorStorageEnum::DenseMemmapByte(vs) => {
            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseMemmapHalf(vs) => {
            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
        }

        VectorStorageEnum::DenseAppendableMemmap(vs) => {
            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseAppendableMemmapByte(vs) => {
            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseAppendableMemmapHalf(vs) => {
            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseAppendableInRam(vs) => {
            raw_scorer_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseAppendableInRamByte(vs) => {
            raw_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::DenseAppendableInRamHalf(vs) => {
            raw_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::SparseSimple(vs) => raw_sparse_scorer_impl(query, vs, point_deleted, hc),
        VectorStorageEnum::SparseMmap(vs) => raw_sparse_scorer_impl(query, vs, point_deleted, hc),
        VectorStorageEnum::MultiDenseSimple(vs) => {
            raw_multi_scorer_impl(query, vs, point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseSimpleByte(vs) => {
            raw_multi_scorer_byte_impl(query, vs, point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseSimpleHalf(vs) => {
            raw_multi_scorer_half_impl(query, vs, point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableMemmap(vs) => {
            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => {
            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => {
            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableInRam(vs) => {
            raw_multi_scorer_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => {
            raw_multi_scorer_byte_impl(query, vs.as_ref(), point_deleted, hc)
        }
        VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => {
            raw_multi_scorer_half_impl(query, vs.as_ref(), point_deleted, hc)
        }
    }
}

pub fn raw_sparse_scorer_impl<'a, TVectorStorage: SparseVectorStorage>(
    query: QueryVector,
    vector_storage: &'a TVectorStorage,
    point_deleted: &'a BitSlice,
    hardware_counter: HardwareCounterCell,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    let vec_deleted = vector_storage.deleted_vector_bitslice();
    match query {
        QueryVector::Nearest(_vector) => Err(OperationError::service_error(
            "Raw scorer must not be used for nearest queries",
        )),
        QueryVector::RecommendBestScore(reco_query) => {
            let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
            raw_scorer_from_query_scorer(
                SparseCustomQueryScorer::<_, _>::new(
                    RecoBestScoreQuery::from(reco_query),
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::RecommendSumScores(reco_query) => {
            let reco_query: RecoQuery<SparseVector> = reco_query.transform_into()?;
            raw_scorer_from_query_scorer(
                SparseCustomQueryScorer::<_, _>::new(
                    RecoSumScoresQuery::from(reco_query),
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::Discovery(discovery_query) => {
            let discovery_query: DiscoveryQuery<SparseVector> = discovery_query.transform_into()?;
            raw_scorer_from_query_scorer(
                SparseCustomQueryScorer::<_, _>::new(
                    discovery_query,
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::Context(context_query) => {
            let context_query: ContextQuery<SparseVector> = context_query.transform_into()?;
            raw_scorer_from_query_scorer(
                SparseCustomQueryScorer::<_, _>::new(
                    context_query,
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
    }
}

#[cfg(feature = "testing")]
pub fn new_raw_scorer_for_test<'a>(
    vector: QueryVector,
    vector_storage: &'a VectorStorageEnum,
    point_deleted: &'a BitSlice,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    new_raw_scorer(
        vector,
        vector_storage,
        point_deleted,
        HardwareCounterCell::new(),
    )
}

pub fn raw_scorer_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementType>>(
    query: QueryVector,
    vector_storage: &'a TVectorStorage,
    point_deleted: &'a BitSlice,
    hardware_counter: HardwareCounterCell,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    match vector_storage.distance() {
        Distance::Cosine => new_scorer_with_metric::<CosineMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
        Distance::Euclid => new_scorer_with_metric::<EuclidMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
        Distance::Dot => new_scorer_with_metric::<DotProductMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
        Distance::Manhattan => new_scorer_with_metric::<ManhattanMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
    }
}

fn new_scorer_with_metric<
    'a,
    TMetric: Metric<VectorElementType> + 'a,
    TVectorStorage: DenseVectorStorage<VectorElementType>,
>(
    query: QueryVector,
    vector_storage: &'a TVectorStorage,
    point_deleted: &'a BitSlice,
    hardware_counter: HardwareCounterCell,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    let vec_deleted = vector_storage.deleted_vector_bitslice();
    match query {
        QueryVector::Nearest(vector) => raw_scorer_from_query_scorer(
            MetricQueryScorer::<VectorElementType, TMetric, _>::new(
                vector.try_into()?,
                vector_storage,
                hardware_counter,
            ),
            point_deleted,
            vec_deleted,
        ),
        QueryVector::RecommendBestScore(reco_query) => {
            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
            raw_scorer_from_query_scorer(
                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                    RecoBestScoreQuery::from(reco_query),
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::RecommendSumScores(reco_query) => {
            let reco_query: RecoQuery<DenseVector> = reco_query.transform_into()?;
            raw_scorer_from_query_scorer(
                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                    RecoSumScoresQuery::from(reco_query),
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::Discovery(discovery_query) => {
            let discovery_query: DiscoveryQuery<DenseVector> = discovery_query.transform_into()?;
            raw_scorer_from_query_scorer(
                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                    discovery_query,
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
        QueryVector::Context(context_query) => {
            let context_query: ContextQuery<DenseVector> = context_query.transform_into()?;
            raw_scorer_from_query_scorer(
                CustomQueryScorer::<VectorElementType, TMetric, _, _, _>::new(
                    context_query,
                    vector_storage,
                    hardware_counter,
                ),
                point_deleted,
                vec_deleted,
            )
        }
    }
}

pub fn raw_scorer_byte_impl<'a, TVectorStorage: DenseVectorStorage<VectorElementTypeByte>>(
    query: QueryVector,
    vector_storage: &'a TVectorStorage,
    point_deleted: &'a BitSlice,
    hardware_counter: HardwareCounterCell,
) -> OperationResult<Box<dyn RawScorer + 'a>> {
    match vector_storage.distance() {
        Distance::Cosine => new_scorer_byte_with_metric::<CosineMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
        Distance::Euclid => new_scorer_byte_with_metric::<EuclidMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware_counter,
        ),
        Distance::Dot => new_scorer_byte_with_metric::<DotProductMetric, _>(
            query,
            vector_storage,
            point_deleted,
            hardware