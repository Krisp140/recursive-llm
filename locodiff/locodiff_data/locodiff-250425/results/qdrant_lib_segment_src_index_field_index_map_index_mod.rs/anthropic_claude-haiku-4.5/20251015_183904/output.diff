
index 0a4e2d762..409056624 100644
--- a/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected):tmp/tmpn3yvyhot_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual):tmp/tmps4sjnz9f_actual.txt	
@@ -3,6 +3,7 @@ use std::collections::hash_map::Entry;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::iter;
+use std::mem::size_of_val;
 use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::sync::Arc;
@@ -195,7 +196,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
+    fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
         match self {
             MapIndex::Mutable(index) => index.iter_values(),
             MapIndex::Immutable(index) => index.iter_values(),
@@ -302,14 +303,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            MapIndex::Mutable(_) => Vec::new(),
-            MapIndex::Immutable(_) => Vec::new(),
-            MapIndex::Mmap(index) => index.files(),
-        }
-    }
-
     /// Estimates cardinality for `except` clause
     ///
     /// # Arguments
@@ -390,7 +383,8 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
 
         // Minimal amount of points, required to fit all unused values.
         // Cardinality can't be less than this value.
-        let min_not_excluded_by_values = non_excluded_values_count.div_ceil(max_values_per_point);
+        let min_not_excluded_by_values =
+            non_excluded_values_count.div_ceil(max_values_per_point);
 
         let min = min_not_excluded_by_values.max(
             self.get_indexed_points()
@@ -423,6 +417,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    fn files(&self) -> Vec<PathBuf> {
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
+    }
+
     fn except_set<'a, K, A>(
         &'a self,
         excluded: &'a IndexSet<K, A>,
