```rust
// @generated by cargo dev tools; do not edit by hand.

pub mod immutable_map_index;
pub mod mmap_map_index;
pub mod mutable_map_index;

use std::borrow::Borrow;
use std::collections::hash_map::Entry;
use std::fmt::{Debug, Display};
use std::hash::{BuildHasher, Hash};
use std::iter;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use std::sync::Arc;

use ahash::HashMap;
use common::mmap_hashmap::Key;
use common::types::PointOffsetType;
use indexmap::IndexSet;
use itertools::Itertools;
use parking_lot::RwLock;
use rocksdb::DB;
use serde_json::Value;
use smol_str::SmolStr;
use uuid::Uuid;

use crate::common::Flusher;
use crate::common::operation_error::{OperationError, OperationResult};
use crate::counter::hardware_counter::HardwareCounterCell;
use crate::data_types::facets::{FacetHit, FacetValueRef};
use crate::index::field_index::stat_tools::number_of_selected_points;
use crate::index::field_index::{
    CardinalityEstimation, FieldCondition, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition,
    ValueIndexer,
};
use crate::telemetry::PayloadIndexTelemetry;
use crate::types::{
    AnyVariants, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue, PayloadKeyType, UuidIntType,
    ValueVariants,
};

use self::immutable_map_index::ImmutableMapIndex;
use self::mmap_map_index::MmapMapIndex;
use self::mmap_point_to_values::MmapValue;
use self::mutable_map_index::MutableMapIndex;
use super::FieldIndexBuilderTrait;

/// Iterator over point IDs by reference.
pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;
/// Iterator over point IDs by value.
pub type IdIter<'a> = Box<dyn Iterator<Item = PointOffsetType> + 'a>;

/// A key type usable in a MapIndex.
pub trait MapIndexKey: Key + MmapValue + Eq + Display + Debug {
    /// Owned form of the key.
    type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
    /// Convert borrowed to owned.
    fn to_owned(&self) -> Self::Owned;
}

impl MapIndexKey for str {
    type Owned = SmolStr;
    fn to_owned(&self) -> Self::Owned {
        SmolStr::from(self)
    }
}

impl MapIndexKey for IntPayloadType {
    type Owned = IntPayloadType;
    fn to_owned(&self) -> Self::Owned {
        *self
    }
}

impl MapIndexKey for UuidIntType {
    type Owned = UuidIntType;
    fn to_owned(&self) -> Self::Owned {
        *self
    }
}

/// An index mapping payload field values to points.
///
/// Supports a mutable on-disk RocksDB-backed index, an immutable disk-loaded index,
/// and an on-disk or in-ram memory-mapped index.
pub enum MapIndex<N: MapIndexKey + ?Sized> {
    Mutable(MutableMapIndex<N>),
    Immutable(ImmutableMapIndex<N>),
    Mmap(Box<MmapMapIndex<N>>),
}

impl<N: MapIndexKey + ?Sized> MapIndex<N> {
    /// Create a new in-memory (RocksDB + appendable flag) index.
    pub fn new_memory(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
        if is_appendable {
            MapIndex::Mutable(MutableMapIndex::new(db, field_name))
        } else {
            MapIndex::Immutable(ImmutableMapIndex::new(db, field_name))
        }
    }

    /// Load an existing memory map (immutable) index.
    pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {
        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path, is_on_disk)?)))
    }

    /// Builder for a memory (RocksDB) index.
    pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
        MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))
    }

    /// Builder for a memory-map index.
    pub fn mmap_builder(path: &Path, is_on_disk: bool) -> MapIndexMmapBuilder<N> {
        MapIndexMmapBuilder {
            path: path.to_owned(),
            point_to_values: Default::default(),
            values_to_points: Default::default(),
            is_on_disk,
        }
    }

    /// Load or reload from underlying storage.
    pub fn load_from_db(&mut self) -> OperationResult<bool> {
        match self {
            MapIndex::Mutable(index) => index.load_from_db(),
            MapIndex::Immutable(index) => index.load_from_db(),
            MapIndex::Mmap(_) => Ok(true),
        }
    }

    /// Check if any value at `idx` satisfies `check_fn`.
    pub fn check_values_any(
        &self,
        idx: PointOffsetType,
        check_fn: impl Fn(&N) -> bool,
    ) -> bool {
        match self {
            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),
        }
    }

    /// Return stored values for a point.
    pub fn get_values(
        &self,
        idx: PointOffsetType,
    ) -> Option<Box<dyn Iterator<Item = N::Referenced<'_>> + '_>> {
        match self {
            MapIndex::Mutable(index) => Some(Box::new(
                index.get_values(idx)?.map(|v| N::as_referenced(v)),
            )),
            MapIndex::Immutable(index) => Some(Box::new(
                index.get_values(idx)?.map(|v| N::as_referenced(v)),
            )),
            MapIndex::Mmap(index) => Some(Box::new(index.get_values(idx)?)),
        }
    }

    /// Number of values for a point.
    pub fn values_count(&self, idx: PointOffsetType) -> usize {
        match self {
            MapIndex::Mutable(index) => index.values_count(idx).unwrap_or_default(),
            MapIndex::Immutable(index) => index.values_count(idx).unwrap_or_default(),
            MapIndex::Mmap(index) => index.values_count(idx).unwrap_or_default(),
        }
    }

    /// Is the values list empty?
    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {
        self.values_count(idx) == 0
    }

    /// Total indexed points.
    pub fn get_indexed_points(&self) -> usize {
        match self {
            MapIndex::Mutable(index) => index.get_indexed_points(),
            MapIndex::Immutable(index) => index.get_indexed_points(),
            MapIndex::Mmap(index) => index.get_indexed_points(),
        }
    }

    /// Total number of assigned values.
    pub fn get_values_count(&self) -> usize {
        match self {
            MapIndex::Mutable(index) => index.get_values_count(),
            MapIndex::Immutable(index) => index.get_values_count(),
            MapIndex::Mmap(index) => index.get_values_count(),
        }
    }

    /// Unique distinct values count.
    pub fn get_unique_values_count(&self) -> usize {
        match self {
            MapIndex::Mutable(index) => index.get_unique_values_count(),
            MapIndex::Immutable(index) => index.get_unique_values_count(),
            MapIndex::Mmap(index) => index.get_unique_values_count(),
        }
    }

    /// Cardnarity for single value.
    fn match_cardinality(
        &self,
        value: &N,
        _hw_counter: &HardwareCounterCell,
    ) -> CardinalityEstimation {
        let values_count = match self {
            MapIndex::Mutable(index) => index.get_count_for_value(value),
            MapIndex::Immutable(index) => index.get_count_for_value(value),
            MapIndex::Mmap(index) => index.get_count_for_value(value),
        }
        .unwrap_or(0);
        CardinalityEstimation::exact(values_count)
    }

    /// Iterator of points having `value`.
    fn get_iterator(&self, value: &N, _hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {
        match self {
            MapIndex::Mutable(index) => index.get_iterator(value),
            MapIndex::Immutable(index) => index.get_iterator(value),
            MapIndex::Mmap(index) => index.get_iterator(value),
        }
    }

    /// Iterator of all distinct values.
    pub fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
        match self {
            MapIndex::Mutable(index) => index.iter_values(),
            MapIndex::Immutable(index) => index.iter_values(),
            MapIndex::Mmap(index) => index.iter_values(),
        }
    }

    /// Iterator over (value, count).
    pub fn iter_counts_per_value(&self) -> Box<dyn Iterator<Item = (&N, usize)> + '_> {
        match self {
            MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),
            MapIndex::Immutable(index) => Box::new(index.iter_counts_per_value()),
            MapIndex::Mmap(index) => Box::new(index.iter_counts_per_value()),
        }
    }

    /// Iterator over (value, point IDs).
    pub fn iter_values_map<'a>(
        &'a self,
        hw_cell: &'a HardwareCounterCell,
    ) -> Box<dyn Iterator<Item = (&'a N, IdIter<'a>)> + 'a> {
        match self {
            MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
            MapIndex::Immutable(index) => Box::new(index.iter_values_map()),
            MapIndex::Mmap(index) => Box::new(index.iter_values_map(hw_cell)),
        }
    }

    /// Return storage files for mmap variant.
    fn files(&self) -> Vec<PathBuf> {
        match self {
            MapIndex::Mutable(_) => Vec::new(),
            MapIndex::Immutable(_) => Vec::new(),
            MapIndex::Mmap(index) => index.files(),
        }
    }

    /// Return database flusher.
    fn flusher(&self) -> Flusher {
        match self {
            MapIndex::Mutable(index) => index.get_db_wrapper().flusher(),
            MapIndex::Immutable(index) => index.get_db_wrapper().flusher(),
            MapIndex::Mmap(index) => index.flusher(),
        }
    }

    /// Drop underlying column (RocksDB) or noop for mmap.
    fn clear(self) -> OperationResult<()> {
        match self {
            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
            MapIndex::Mmap(index) => index.clear(),
        }
    }

    /// Remove a point assignment.
    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
        match self {
            MapIndex::Mutable(index) => index.remove_point(id),
            MapIndex::Immutable(index) => index.remove_point(id),
            MapIndex::Mmap(index) => {
                index.remove_point(id);
                Ok(())
            }
        }
    }

    /// Cardinality estimation for Except.
    fn except_cardinality<'a>(
        &'a self,
        excluded: impl Iterator<Item = &'a N>,
        hw_counter: &HardwareCounterCell,
    ) -> CardinalityEstimation {
        let total_values = self.get_values_count();
        let total_points = self.get_indexed_points();
        let excluded_counts: Vec<_> = excluded
            .map(|val| match self {
                MapIndex::Mutable(index) => index.get_count_for_value(val).unwrap_or(0),
                MapIndex::Immutable(index) => index.get_count_for_value(val).unwrap_or(0),
                MapIndex::Mmap(index) => index.get_count_for_value(val).unwrap_or(0),
            })
            .collect();
        let total_excluded: usize = excluded_counts.iter().sum();

        let non_excluded_values = total_values.saturating_sub(total_excluded);
        let max_vals_per_point = self.get_unique_values_count().saturating_sub(excluded_counts.len());

        if max_vals_per_point == 0 {
            return CardinalityEstimation::exact(0);
        }

        let min_points_by_vals = non_excluded_values.div_ceil(max_vals_per_point);
        let min = min_points_by_vals.max(total_points.saturating_sub(total_excluded));
        let max_excl = excluded_counts.into_iter().max().unwrap_or(0);
        let max = total_points.saturating_sub(max_excl).min(non_excluded_values);
        let exp = number_of_selected_points(total_points, non_excluded_values).max(min).min(max);

        CardinalityEstimation { primary_clauses: vec![], min, exp, max }
    }

    /// Iterator of points not having any of the excluded values.
    fn except_set<'a, K, A>(
        &'a self,
        excluded: &'a IndexSet<K, A>,
        hw_counter: &'a HardwareCounterCell,
    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
    where
        A: BuildHasher,
        K: Borrow<N> + Hash + Eq,
    {
        Box::new(
            self.iter_values()
                .filter(|key| !excluded.contains((*key).borrow()))
                .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
                .unique(),
        )
    }

    /// Column family name.
    pub fn storage_cf_name(field: &str) -> String {
        format!("{}_map", field)
    }

    /// Encode record for RocksDB.
    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {
        format!("{value}/{idx}")
    }

    /// Decode RocksDB record.
    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {
        const DECODE_ERR: &str = "Index db parsing error: wrong data format";
        let pos = s.rfind('/').ok_or_else(|| OperationError::service_error(DECODE_ERR))?;
        if pos == s.len() - 1 {
            return Err(OperationError::service_error(DECODE_ERR));
        }
        let vs = &s[..pos];
        let val = N::Owned::from_str(vs).map_err(|_| OperationError::service_error(DECODE_ERR))?;
        let is = &s[pos + 1..];
        let id = PointOffsetType::from_str(is).map_err(|_| OperationError::service_error(DECODE_ERR))?;
        Ok((val, id))
    }

    /// Populate mmap pages.
    pub fn populate(&self) -> OperationResult<()> {
        if let MapIndex::Mmap(idx) = self {
            idx.populate()?;
        }
        Ok(())
    }

    /// Clear mmap cache.
    pub fn clear_cache(&self) -> OperationResult<()> {
        if let MapIndex::Mmap(idx) = self {
            idx.clear_cache()?;
        }
        Ok(())
    }

    /// Is mmap on-disk?
    pub fn is_on_disk(&self) -> bool {
        matches!(self, MapIndex::Mmap(idx) if idx.is_on_disk())
    }

    /// Telemetry information.
    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
        PayloadIndexTelemetry {
            field_name: None,
            points_count: self.get_indexed_points(),
            points_values_count: self.get_values_count(),
            histogram_bucket_size: None,
            index_type: match self {
                MapIndex::Mutable(_) => "mutable_map",
                MapIndex::Immutable(_) => "immutable_map",
                MapIndex::Mmap(_) => "mmap_map",
            },
        }
    }

    /// Cardinality estimation for a single value.
    pub fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
        let cnt = match self {
            MapIndex::Mutable(index) => index.get_count_for_value(value).unwrap_or(0),
            MapIndex::Immutable(index) => index.get_count_for_value(value).unwrap_or(0),
            MapIndex::Mmap(index) => index.get_count_for_value(value).unwrap_or(0),
        };
        CardinalityEstimation::exact(cnt)
    }
}

/// Builder for a RocksDB-based index.
pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);

impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexBuilder<N>
where
    MapIndex<N>: PayloadFieldIndex + ValueIndexer,
{
    type FieldIndexType = MapIndex<N>;

    fn init(&mut self) -> OperationResult<()> {
        self.0.get_db_wrapper().recreate_column_family()
    }

    fn add_point(
        &mut self,
        id: PointOffsetType,
        values: &[&Value],
        hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        self.0.add_point(id, values, hw_counter)
    }

    fn finalize(self) -> OperationResult<Self::FieldIndexType> {
        Ok(self.0)
    }
}

/// Builder for a memory-mapped index.
pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {
    path: PathBuf,
    point_to_values: Vec<Vec<N::Owned>>,
    values_to_points: HashMap<N::Owned, Vec<PointOffsetType>>,
    is_on_disk: bool,
}

impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexMmapBuilder<N>
where
    MapIndex<N>: PayloadFieldIndex + ValueIndexer,
    <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
{
    type FieldIndexType = MapIndex<N>;

    fn init(&mut self) -> OperationResult<()> {
        Ok(())
    }

    fn add_point(
        &mut self,
        id: PointOffsetType,
        payload: &[&Value],
        hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        let mut flatten = Vec::new();
        for v in payload.iter() {
            flatten.extend(<MapIndex<N> as ValueIndexer>::get_values(v));
        }
        let owned: Vec<_> = flatten.into_iter().map(Into::into).collect();
        if self.point_to_values.len() <= id as usize {
            self.point_to_values.resize_with(id as usize + 1, Vec::new);
        }
        self.point_to_values[id as usize].extend(owned.clone());

        let mut wb = hw_counter.payload_index_io_write_counter().write_back_counter();
        for val in owned {
            let ent = self.values_to_points.entry(val.clone());
            if let Entry::Vacant(e) = &ent {
                let sz = N::mmapped_size(N::as_referenced(e.key().borrow()));
                wb.incr_delta(sz);
            }
            wb.incr_delta(std::mem::size_of_val(&id));
            ent.or_default().push(id);
        }
        Ok(())
    }

    fn finalize(self) -> OperationResult<Self::FieldIndexType> {
        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::build(
            &self.path,
            self.point_to_values,
            self.values_to_points,
            self.is_on_disk,
        )?)))
    }
}

impl PayloadFieldIndex for MapIndex<str> {
    fn count_indexed_points(&self) -> usize {
        self.get_indexed_points()
    }
    fn load(&mut self) -> OperationResult<bool> {
        self.load_from_db()
    }
    fn cleanup(self) -> OperationResult<()> {
        self.clear()
    }
    fn flusher(&self) -> Flusher {
        MapIndex::flusher(self)
    }
    fn files(&self) -> Vec<PathBuf> {
        self.files()
    }
    fn filter<'a>(
        &'a self,
        condition: &'a FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::String(keyword) => Some(Box::new(
                    self.get_iterator(keyword.as_str(), hw_counter).copied(),
                )),
                _ => None,
            },
            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                AnyVariants::Strings(keywords) => Some(Box::new(
                    keywords
                        .iter()
                        .flat_map(move |kw| {
                            self.get_iterator(kw.as_str(), hw_counter).copied()
                        })
                        .unique(),
                )),
                AnyVariants::Integers(integers) => {
                    if integers.is_empty() {
                        Some(Box::new(iter::empty()))
                    } else {
                        None
                    }
                }
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Strings(keywords) => Some(self.except_set(keywords, hw_counter)),
                AnyVariants::Integers(other) => {
                    if other.is_empty() {
                        Some(Box::new(iter::empty()))
                    } else {
                        None
                    }
                }
            },
            _ => None,
        }
    }
    fn estimate_cardinality(
        &self,
        condition: &FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<CardinalityEstimation> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::String(keyword) => {
                    let mut est = self.match_cardinality(keyword.as_str(), hw_counter);
                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
                    Some(est)
                }
                _ => None,
            },
            Some(Match::Any(MatchAny { any })) => match any {
                AnyVariants::Strings(keywords) => {
                    let v: Vec<_> = keywords
                        .iter()
                        .map(|kw| self.match_cardinality(kw.as_str(), hw_counter))
                        .collect();
                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                }
                AnyVariants::Integers(ints) => {
                    if ints.is_empty() {
                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                    } else {
                        None
                    }
                }
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Strings(keywords) => {
                    Some(self.except_cardinality(keywords.iter().map(|k| k.as_str()), hw_counter))
                }
                AnyVariants::Integers(others) => {
                    if others.is_empty() {
                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                    } else {
                        None
                    }
                }
            },
            _ => None,
        }
    }
    fn payload_blocks(
        &self,
        threshold: usize,
        key: PayloadKeyType,
    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
        Box::new(
            self.iter_values()
                .map(move |v| {
                    (
                        v,
                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                    )
                })
                .filter(move |&(_v, cnt)| cnt > threshold)
                .map(move |(v, cnt)| PayloadBlockCondition {
                    condition: FieldCondition::new_match(key.clone(), v.to_string().into()),
                    cardinality: cnt,
                }),
        )
    }
}

impl PayloadFieldIndex for MapIndex<IntPayloadType> {
    fn count_indexed_points(&self) -> usize {
        self.get_indexed_points()
    }
    fn load(&mut self) -> OperationResult<bool> {
        self.load_from_db()
    }
    fn cleanup(self) -> OperationResult<()> {
        self.clear()
    }
    fn flusher(&self) -> Flusher {
        MapIndex::flusher(self)
    }
    fn files(&self) -> Vec<PathBuf> {
        self.files()
    }
    fn filter<'a>(
        &'a self,
        condition: &'a FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::Integer(integer) => Some(Box::new(self.get_iterator(integer, hw_counter).copied())),
                _ => None,
            },
            Some(Match::Any(MatchAny { any })) => match any {
                AnyVariants::Integers(integers) => Some(Box::new(
                    integers
                        .iter()
                        .flat_map(move |i| self.get_iterator(i, hw_counter).copied())
                        .unique(),
                )),
                AnyVariants::Strings(_) => None,
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),
                AnyVariants::Strings(_) => {
                    if except.is_empty() {
                        Some(Box::new(iter::empty()))
                    } else {
                        None
                    }
                }
            },
            _ => None,
        }
    }
    fn estimate_cardinality(
        &self,
        condition: &FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<CardinalityEstimation> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::Integer(integer) => {
                    let mut est = self.match_cardinality(integer, hw_counter);
                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
                    Some(est)
                }
                _ => None,
            },
            Some(Match::Any(MatchAny { any })) => match any {
                AnyVariants::Integers(integers) => {
                    let v: Vec<_> = integers
                        .iter()
                        .map(|i| self.match_cardinality(i, hw_counter))
                        .collect();
                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                }
                AnyVariants::Strings(_) => None,
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Integers(integers) => Some(self.except_cardinality(integers.iter(), hw_counter)),
                AnyVariants::Strings(_) => {
                    if except.is_empty() {
                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                    } else {
                        None
                    }
                }
            },
            _ => None,
        }
    }
    fn payload_blocks(
        &self,
        threshold: usize,
        key: PayloadKeyType,
    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
        Box::new(
            self.iter_values()
                .map(move |v| {
                    (
                        v,
                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                    )
                })
                .filter(move |&(_v, cnt)| cnt >= threshold)
                .map(move |(v, cnt)| PayloadBlockCondition {
                    condition: FieldCondition::new_match(key.clone(), (*v).into()),
                    cardinality: cnt,
                }),
        )
    }
}

impl PayloadFieldIndex for MapIndex<UuidIntType> {
    fn count_indexed_points(&self) -> usize {
        self.get_indexed_points()
    }
    fn load(&mut self) -> OperationResult<bool> {
        self.load_from_db()
    }
    fn cleanup(self) -> OperationResult<()> {
        self.clear()
    }
    fn flusher(&self) -> Flusher {
        MapIndex::flusher(self)
    }
    fn files(&self) -> Vec<PathBuf> {
        self.files()
    }
    fn filter<'a>(
        &'a self,
        condition: &'a FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::String(s) => {
                    let uuid = Uuid::from_str(s).ok()?;
                    Some(Box::new(self.get_iterator(&uuid.as_u128(), hw_counter).copied()))
                }
                _ => None,
            },
            Some(Match::Any(MatchAny { any })) => match any {
                AnyVariants::Strings(ss) => {
                    let uuids: Result<IndexSet<u128>, _> =
                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
                    let uu = uuids.ok()?;
                    Some(Box::new(
                        uu.into_iter()
                            .flat_map(move |u| self.get_iterator(&u, hw_counter).copied())
                            .unique(),
                    ))
                }
                AnyVariants::Integers(_) => None,
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Strings(ss) => {
                    let uuids: Result<IndexSet<u128>, _> =
                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
                    let uu = uuids.ok()?;
                    Some(Box::new(
                        self.iter_values()
                            .filter(move |key| !uu.contains(*key))
                            .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
                            .unique(),
                    ))
                }
                AnyVariants::Integers(_) => None,
            },
            _ => None,
        }
    }
    fn estimate_cardinality(
        &self,
        condition: &FieldCondition,
        hw_counter: &HardwareCounterCell,
    ) -> Option<CardinalityEstimation> {
        match &condition.r#match {
            Some(Match::Value(MatchValue { value })) => match value {
                ValueVariants::String(s) => {
                    let uuid = Uuid::from_str(s).ok()?;
                    let mut est = self.match_cardinality(&uuid.as_u128(), hw_counter);
                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
                    Some(est)
                }
                _ => None,
            },
            Some(Match::Any(MatchAny { any })) => match any {
                AnyVariants::Strings(ss) => {
                    let uuids: Result<IndexSet<u128>, _> =
                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
                    let uu = uuids.ok()?;
                    let v: Vec<_> = uu.into_iter().map(|u| self.match_cardinality(&u, hw_counter)).collect();
                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                }
                AnyVariants::Integers(_) => None,
            },
            Some(Match::Except(MatchExcept { except })) => match except {
                AnyVariants::Strings(ss) => {
                    let uuids: Result<IndexSet<u128>, _> =
                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
                    let uu = uuids.ok()?;
                    Some(self.except_cardinality(uu.iter(), hw_counter))
                }
                AnyVariants::Integers(_) => None,
            },
            _ => None,
        }
    }
    fn payload_blocks(
        &self,
        threshold: usize,
        key: PayloadKeyType,
    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
        Box::new(
            self.iter_values()
                .map(move |v| {
                    (
                        v,
                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                    )
                })
                .filter(move |&(_v, cnt)| cnt >= threshold)
                .map(move |(v, cnt)| PayloadBlockCondition {
                    condition: FieldCondition::new_match(
                        key.clone(),
                        Uuid::from_u128(*v).to_string().into(),
                    ),
                    cardinality: cnt,
                }),
        )
    }
}

impl ValueIndexer for MapIndex<str> {
    type ValueType = String;
    fn add_many(
        &mut self,
        id: PointOffsetType,
        values: Vec<String>,
        hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        match self {
            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
            _ => Err(OperationError::service_error("Can't add values to this index")),
        }
    }
    fn get_value(value: &Value) -> Option<String> {
        value.as_str().map(|s| s.to_owned())
    }
    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
        self.remove_point(id)
    }
}

impl ValueIndexer for MapIndex<IntPayloadType> {
    type ValueType = IntPayloadType;
    fn add_many(
        &mut self,
        id: PointOffsetType,
        values: Vec<IntPayloadType>,
        hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        match self {
            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
            _ => Err(OperationError::service_error("Can't add values to this index")),
        }
    }
    fn get_value(value: &Value) -> Option<IntPayloadType> {
        value.as_i64()
    }
    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
        self.remove_point(id)
    }
}

impl ValueIndexer for MapIndex<UuidIntType> {
    type ValueType = UuidIntType;
    fn add_many(
        &mut self,
        id: PointOffsetType,
        values: Vec<UuidIntType>,
        hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        match self {
            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
            _ => Err(OperationError::service_error("Can't add values to this index")),
        }
    }
    fn get_value(value: &Value) -> Option<UuidIntType> {
        value.as_str().and_then(|s| Uuid::parse_str(s).ok().map(|u| u.as_u128()))
    }
    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
        self.remove_point(id)
    }
}

impl<N> FacetIndex for MapIndex<N>
where
    N: MapIndexKey + ?Sized,
    for<'a> &'a N: Into<FacetValueRef<'a>>,
    for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,
{
    fn get_point_values(
        &self,
        point_id: PointOffsetType,
    ) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
        self.get_values(point_id).into_iter().flatten().map(Into::into)
    }
    fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
        self.iter_values().map(Into::into)
    }
    fn iter_values_map<'a>(
        &'a self,
        hw_counter: &'a HardwareCounterCell,
    ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {
        self.iter_values_map(hw_counter).map(|(k, it)| (k.into(), it))
    }
    fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
        self.iter_counts_per_value()
            .map(|(v, c)| FacetHit { value: v.into(), count: c })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
    use rstest::rstest;
    use std::collections::HashSet;
    use std::path::Path;
    use tempfile::Builder;

    #[derive(Clone, Copy)]
    enum IndexType {
        Mutable,
        Immutable,
        Mmap,
    }

    fn save_map_index<N>(
        data: &[Vec<N::Owned>],
        path: &Path,
        idx_type: IndexType,
        into_value: impl Fn(&N::Owned) -> Value,
    ) where
        N: MapIndexKey + ?Sized,
        MapIndex<N>: PayloadFieldIndex + ValueIndexer,
        <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
    {
        let hw = HardwareCounterCell::new();
        match idx_type {
            IndexType::Mutable | IndexType::Immutable => {
                let mut bldr = MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), "test");
                bldr.init().unwrap();
                for (i, vals) in data.iter().enumerate() {
                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();
                    let refs: Vec<_> = vs.iter().collect();
                    bldr.add_point(i as _, &refs, &hw).unwrap();
                }
                bldr.finalize().unwrap();
            }
            IndexType::Mmap => {
                let mut bldr = MapIndex::<N>::mmap_builder(path, false);
                bldr.init().unwrap();
                for (i, vals) in data.iter().enumerate() {
                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();
                    let refs: Vec<_> = vs.iter().collect();
                    bldr.add_point(i as _, &refs, &hw).unwrap();
                }
                bldr.finalize().unwrap();
            }
        }
    }

    fn load_map_index<N>(
        data: &[Vec<N::Owned>],
        path: &Path,
        idx_type: IndexType,
    ) -> MapIndex<N>
    where
        N: MapIndexKey + ?Sized,
    {
        let mut idx = match idx_type {
            IndexType::Mutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", true),
            IndexType::Immutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", false),
            IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),
        };
        idx.load_from_db().unwrap();
        for (i, vals) in data.iter().enumerate() {
            let got: HashSet<N> = idx
                .get_values(i as _).unwrap()
                .map(|r| N::to_owned(N::as_referenced(&r)))
                .collect();
            let want: HashSet<N> = vals.iter().cloned().collect();
            assert_eq!(got, want);
        }
        idx
    }

    #[rstest]
    #[case(IndexType::Mutable)]
    #[case(IndexType::Immutable)]
    #[case(IndexType::Mmap)]
    fn test_int_disk_map_index(#[case] idx_type: IndexType) {
        let data = vec![
            vec![1, 2, 3, 4, 5, 6],
            vec![1, 2, 3, 4, 5, 6],
            vec![13, 14, 15, 16, 17, 18],
            vec![19, 20, 21, 22, 23, 24],
            vec![25],
        ];
        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
        save_map_index::<IntPayloadType>(&data, td.path(), idx_type, |v| (*v).into());
        let idx = load_map_index::<IntPayloadType>(&data, td.path(), idx_type);
        let hw = HardwareCounterCell::new();
        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
    }

    #[rstest]
    #[case(IndexType::Mutable)]
    #[case(IndexType::Immutable)]
    #[case(IndexType::Mmap)]
    fn test_string_disk_map_index(#[case] idx_type: IndexType) {
        let data = vec![
            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],
            vec![SmolStr::from("PPMM"), SmolStr::from("QQXX"), SmolStr::from("YYBB")],
            vec![SmolStr::from("FFMM"), SmolStr::from("IICC"), SmolStr::from("IIBB")],
            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],
            vec![SmolStr::from("PPGG")],
        ];
        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());
        let idx = load_map_index::<str>(&data, td.path(), idx_type);
        let hw = HardwareCounterCell::new();
        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
    }

    #[rstest]
    #[case(IndexType::Mutable)]
    #[case(IndexType::Immutable)]
    #[case(IndexType::Mmap)]
    fn test_empty_index(#[case] idx_type: IndexType) {
        let data: Vec<Vec<SmolStr>> = vec![];
        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());
        let idx = load_map_index::<str>(&data, td.path(), idx_type);
        let hw = HardwareCounterCell::new();
        assert!(idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
    }

    #[test]
    fn test_index_non_ascending_insertion() {
        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
        let mut bldr = MapIndex::<IntPayloadType>::mmap_builder(td.path(), false);
        bldr.init().unwrap();
        let data = [vec![1,2,3,4,5,6], vec![25], vec![10,11]];
        let hw = HardwareCounterCell::new();
        for (i, vals) in data.iter().enumerate().rev() {
            let vs: Vec<Value> = vals.iter().map(|&x| x.into()).collect();
            let refs: Vec<_> = vs.iter().collect();
            bldr.add_point(i as _, &refs, &hw).unwrap();
        }
        let idx = bldr.finalize().unwrap();
        for (i, vals) in data.iter().enumerate().rev() {
            let got: Vec<_> = idx.get_values(i as _).unwrap().map(|&x| x as i32).collect();
            assert_eq!(got, *vals);
        }
    }
}
```