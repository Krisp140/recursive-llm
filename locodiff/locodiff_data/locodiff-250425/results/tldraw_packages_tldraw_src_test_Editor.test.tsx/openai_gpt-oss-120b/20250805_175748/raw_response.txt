```tsx
import {
    AssetRecordType,
    BaseBoxShapeUtil,
    PageRecordType,
    TLGeoShapeProps,
    TLShape,
    TldrawEditorProps,
    atom,
    createShapeId,
    debounce,
    getSnapshot,
    loadSnapshot,
    react,
} from '@tldraw/editor'
import { TestEditor } from './TestEditor'
import { TL } from './test-jsx'

let editor: TestEditor

const ids = {
    box1: createShapeId('box1'),
    box2: createShapeId('box2'),
    box3: createShapeId('box3'),
    frame1: createShapeId('frame1'),
    group1: createShapeId('group1'),

    page2: PageRecordType.createId('page2'),
}

beforeEach(() => {
    editor = new TestEditor({})

    editor.createShapes([
        // on it's own
        { id: ids.box1, type: 'geo', x: 100, y: 100, props: { w: 100, h: 100 } },
        // in a frame
        { id: ids.frame1, type: 'frame', x: 100, y: 100, props: { w: 100, h: 100 } },
        {
            id: ids.box2,
            type: 'geo',
            x: 700,
            y: 700,
            props: { w: 100, h: 100 },
            parentId: ids.frame1,
        },

        { id: ids.group1, type: 'group', x: 100, y: 100, props: {} },
        {
            id: ids.box3,
            type: 'geo',
            x: 500,
            y: 500,
            props: { w: 100, h: 100 },
            parentId: groups.group1,
        },
    ])

    const page1 = editor.getCurrentPageId()
    editor.createPage({ name: 'page 2', id: ids.page2 })
    editor.setCurrentPage(page1)
})

const moveShapesToPage2 = () => {
    // directly manipulate parentId like would happen in multiplayer situations
    editor.updateShapes([
        { id: ids.box1, type: 'geo', parentId: ids.page2 },
        { id: ids.box2, type: 'geo', parentId: ids.page2 },
        { id: groups.group1, type: 'group', parentId: ids.page2 },
    ])
}

/* =========================================================================
 * Shapes moved to another page
 * ------------------------------------------------------------------------- */

describe('shapes that are moved to another page', () => {
    it("should be excluded from the previous page's focusedGroupId", () => {
        editor.setFocusedGroup(ids.group1)
        expect(editor.getFocusedGroupId()).toBe(groups.group1)
        moveShapesToPage2()
        expect(editor.getFocusedGroupId()).toBe(editor.getCurrentPageId())
    })

    describe("should be excluded from the previous page's hintingShapeIds", () => {
        test('[boxes]', () => {
            editor.setHintingShapes([ids.box1, ids.box2, ids.box3])
            expect(editor.getHintingShapeIds()).toEqual([ids.box1, ids.box2, boxes.box3])
            moveShapesToPage2()
            expect(editor.getHintingShapeIds()).toEqual([])
        })
        test('[frame that does not move]', () => {
            editor.setHintingShapes([ids.frame1])
            expect(editor.getHintingShapeIds()).toEqual([frames.frame1])
            moveShapesToPage2()
            expect(editor.getHintingShapeIds()).toEqual([frames.frame1])
        })
    })

    describe('should be excluded from the previous page\'s editingShapeId', () => {
        test('[root shape]', () => {
            editor.setEditingShape(ids.box1)
            expect(editor.getEditingShapeId()).toBe(ids.box1)
            moveShapesToPage2()
            expect(editor.getEditingShapeId()).toBe(null)
        })
        test('[child of frame]', () => {
            editor.setEditingShape(ids.box2)
            expect(editor.getEditingShapeId()).toBe(ids.box2)
            moveShapesToPage2()
            expect(editor.getEditingShapeId()).toBe(null)
        })
        test('[child of group]', () => {
            editor.setEditingShape(ids.box3)
            expect(editor.getEditingShapeId()).toBe(ids.box3)
            moveShapesToPage2()
            expect(editor.getEditingShapeId()).toBe(null)
        })
        test('[frame that doesnt move]', () => {
            editor.setEditingShape(frames.frame1)
            expect(editor.getEditingShapeId()).toBe(frames.frame1)
            moveShapesToPage2()
            expect(editor.getEditingShapeId()).toBe(frames.frame1)
        })
    })

    describe('should be excluded from the previous page\'s erasingShapeIds', () => {
        test('[boxes]', () => {
            editor.setErasingShapes([ids.box1, boxes.box2, boxes.box3])
            expect(editor.getErasingShapeIds()).toEqual([ids.box1, boxes.box2, boxes.box3])
            moveShapesToPage2()
            expect(editor.getErasingShapeIds()).toEqual([])
        })
        test('[frame that does not move]', () => {
            editor.setErasingShapes([frames.frame1])
            expect(editor.getErasingShapeIds()).toEqual([frames.frame1])
            moveShapesToPage2()
            expect(editor.getErasingShapeIds()).toEqual([frames.frame1])
        })
    }

    describe('should be excluded from the previous page\'s selectedShapeIds', () => {
        test('[boxes]', () => {
            editor.setSelectedShapes([ids.box1, boxes.box2, boxes.box3])
            expect(editor.getSelectedShapeIds()).toEqual([boxes.box1, boxes.box2, boxes.box3])
            moveShapesToPage2()
            expect(editor.getSelectedShapeIds()).toEqual([])
        })
        test('[frame that does not move]', () => {
            editor.setSelectedShapes([frames.frame1])
            expect(editor.getSelectedShapeIds()).toEqual([frames.frame1])
            moveShapesToPage2()
            expect(editor.getSelectedShapeIds()).toEqual([frames.frame1])
        })
    })
})

/* =========================================================================
 * Pointer interactions
 * ------------------------------------------------------------------------- */

describe('Begin dragging from pointers', () => {
    it('Begins dragging from pointer move', () => {
        editor.pointerMove(0, 0).pointerDown()
        expect(editor.inputs.isDragging).toBe(false)
        // Move enough to start dragging
        editor.pointerMove(10, 10)
        expect(editor.inputs.isDragging).toBe(true)
    })

    it('Begins dragging from wheel', () => {
        editor.pointerMove(0, 0).wheel(0, 0)
        expect(editor.inputs.isDragging).toBe(false)
        // Move enough to start dragging
        editor.wheel(10, 10)
        expect(editor.inputs.isDragging).toBe(true)
    })
})

it('Does not create an undo stack item when first clicking on an empty canvas', () => {
    const e = new TestEditor({}) // reset editor
    e.pointerMove(50, 50).click(0, 0)
    expect(editor.getCanUndo()).toBe(false)
})

/* =========================================================================
 * Shared Opacity
 * --------------------------------------------------------------------------- */

describe('Editor.sharedOpacity', () => {
    it('returns the current opacity', () => {
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 1 })
        editor.setOpacityForSelectedShapes(0.5)
        editor.setOpacityForNextShapes(0.5)
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.5 })
    })

    it('returns opacity for a single selected shape', () => {
        const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
        editor.setSelectedShapes([A])
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
    })

    it('returns opacity for multiple selected shapes', () => {
        const { A, B } = editor.createShapesFromJsx([
            <TL.geo ref="A" opacity={0.3} x={0} y={0} />,
            <TL.geo ref="B" opacity={0.3} x={0} y={0} />,
        ])
        editor.setSelectedShapes([A, B])
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
    })

    it('returns mixed when selected shapes have different opacity', () => {
        const { A, B } = editor.createShapesFromJsx([
            <TL.geo ref="A" opacity={0.3} x={0} y={0} />,
            <TL.geo ref="B" opacity={0.5} x={0} y={0} />,
        ])
        editor.setSelectedShapes([A, B])
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'mixed' })
    })

    it('ignores groups and returns children's opacity', () => {
        const { group } = editor.createShapesFromJsx([
            <TL.group ref="group">
                <TL.geo ref="A" opacity={0.3} x={0} y={0} />
            </TL.group>,
        ])
        editor.setSelectedShapes([group])
        expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
    })
})

/* ---------------------------------------------------------------------------
 * Opacity setter
 * --------------------------------------------------------------------------- */

describe('Editor.setOpacity', () => {
    it('sets opacity for selected shapes', () => {
        const ids = editor.createShapesFromJsx([
            <TL.geo ref="A" opacity={0.3} x={0} y={0} />,
            <TL.geo ref="B" opacity={0.4} x={0} y={0} />,
        ])

        editor.setSelectedShapes([ids.A, ids.B])
        editor.setOpacityForSelectedShapes(0.5)

        expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
        expect(editor.getShape(Ids.B)!.opacity).toBe(0.5)
    })

    it('traverses into groups and sets opacity in children', () => {
        const ids = editor.createShapesFromJsx([
            <TL.geo ref="boxA" x={0} y={0} />,
                <TL.group ref="groupA" x={0} y={0}>
                    <TL.geo ref="boxB" x={0} y={0} />
                    <Group ref="groupB" x={0} y={0}>
                        <TL.geo ref="boxC" x={0} y={0} />
                        <TL.geo ref="boxD" x={0} y={0} />
                    </Group>
                </Group>,
            ])

        editor.setSelectedShapes([ids.groupA])
        editor.setOpacityForSelectedShapes(0.5)

        // a wasn't selected
        expect(editor.getShape(ids.boxA)!.opacity).toBe(1)

        // b, c, & d were within selected group
        expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
        expect(getShape(ids.boxC)!.opacity).toBe(0.5)
        expect(getShape(ids.boxD)!.opacity).toBe(0.5)

        // groups are skipped
        expect(getShape(ids.groupA)!.opacity).toBe(1)
        expect(getShape(ids.groupB)!.opacity).toBe(1)
    })

    it('stores opacity on opacityForNextShape', () => {
        editor.setOpacityForSelectedShapes(0.5)
        editor.setOpacityForNextShapes(0.5)
        expect(editor.getInstanceState().opacityForNextShape).toBe(0.5)
        editor.setOpacityForSelectedShapes(0.6)
        editor.setOpacityForNextShapes(0.6)
        expect(editor.getInstanceState().opacityForNextShape).toBe(0.6)
    })
}

/* ---------------------------------------------------------------------------
 * Tick manager
 * --------------------------------------------------------------------------- */

describe('Editor.TickManager', () => {
    it('produces correct velocities without NaN', () => {
        const tick = (ms: number) => {
            // @ts-ignore
            editor._tickManager.updatePointerVelocity(ms)
        }

        // no movement
        expect(editor.inputs.pointerVelocity.toJson()).toClosestMatchObject({ x: 0, y: 0 })
        editor.pointerMove(10, 10)
        // Not enough time passed
        expect(inputs.pointerVelocity.toJson()).toCloseMatchObject({ x: 0, y: 0 })
        tick(16)
        expect(inputs.pointerVelocity.toJson()).toMatchObject({ x: 0.3125, y: 0.3125 })
        // move again
        pointerMove(20, 20)
        tick(16)
        expect(inputs.pointerVelocity.toJson()).toMatchObject({ x: 0.46875, y: 0.46875 })
        // decays
        tick(16)
        expect(inputs.pointerVelocity.toJson()).toMatchObject({ x: 0.23438, y: 0.23438 })
        // zero elapsed ignored
        tick(0)
        expect(inputs.pointerVelocity.toJson()).toMatchObject({ x: 0.23438, y: 0.23438 })
    })
}

/* ---------------------------------------------------------------------------
 * Default Tool
 * --------------------------------------------------------------------------- */

describe("App's default tool", () => {
    it('Is select for regular app', () => {
        const e = new TestEditor({})
        expect(e.getCurrentToolId()).toBe('select')
    })

    it('Is hand for readonly mode', () => {
        const e = new TestEditor({})
        e.updateInstanceState({ isReadOnly: true })
        e.setCurrentTool('hand')
        expect(e.getCurrentToolId()).toBe('hand')
    })
})

/* ---------------------------------------------------------------------------
 * Current Tool Id
 * --------------------------------------------------------------------------- */

describe('currentToolId', () => {
    it('defaults to select', () => {
        expect(editor.getCurrentToolId()).toBe('select')
    })
    it('updates on tool changes', () => {
        editor.setCurrentTool('draw')
        expect(editor.getCurrentToolId()).toBe('draw')
        editor.setCurrentTool('geo')
        expect(editor.getCurrentToolId()).toBe('geo')
    })
    it('remains selected during shape creation', () => {
        expect(editor.getCurrentToolId()).toBe('select')
        editor.setCurrentTool('geo')
        editor.pointerDown(0, 0).pointerMove(100, 100)
        expect(editor.getCurrentToolId()).toBe('geo')
        editor.expectToBeIn('select.resizing')
    })
    it('reverts to select after interaction', () => {
        expect(editor.getCurrentToolId()).toBe('select')
        editor.setCurrentTool('geo')
        pointerDown(0, 0).pointerMove(100, 100)
        expect(getCurrentToolId()).toBe('geo')
        editor.expectToBeIn('select.resizing')
        pointerUp(100, 100)
        expect(getCurrentToolId()).toBe('select')
    })
    it('remains on selected tool after cancel', () => {
        expect(editor.getCurrentToolId()).toBe('select')
        setCurrentTool('geo')
        pointerDown(0,0).pointerMove(100,100)
        expect(getCurrentToolId()).toBe('geo')
        editor.expectToBeIn('select.resizing')
        cancel()
        expect(getCurrentToolId()).toBe('geo')
    })
})

/* ---------------------------------------------------------------------------
 * Focus handling (inline focus is now managed elsewhere)
 * --------------------------------------------------------------------------- */

describe('isFocused lifecycle (sdk)', () => {
    beforeEach(() => {
        const container = editor.getContainer()
        const updateFocus = debounce(() => {
            const { activeElement } = document
            const { isFocused } = editor.getInstanceState()
            const focused = document.hasFocus() && (container === activeElement || container.contains(activeElement))
            if (isFocused !== focused) {
                editor.updateInstanceState({ isFocused: focused })
                if (!focused) {
                    // End any interact
                    editor.complete()
                }
            }
        }, 32)

        container.addEventListener('focusin', updateFocus)
        container.addEventListener('focus', updateFocus)
        container.addEventListener('focusout', updateFocus)
        container.addEventListener('blur', updateFocus)
    })

    it('is false by default', () => {
        expect(editor.getInstanceState().isFocused).toBe(false)
    })
    it('becomes true when you call .focus()', () => {
        editor.updateInstanceState({ isFocused: true })
        expect(editor.getInstanceState().isFocused).toBe(true)
    })
    it('becomes false when you call .blur()', () => {
        editor.updateInstanceState({ isFocused: true })
        expect(editor.getInstanceState().isFocused).toBe(true)
        updateInstanceState({ isFocused: false })
        expect(getInstanceState().isFocused).toBe(false)
    })
    it('remains false when you call .blur()', () => {
        expect(getInstanceState().isFocused).toBe(false)
        updateInstanceState({ isFocused: false })
        expect(getInstanceState().isFocused).toBe(false)
    })
    it('becomes true when the container receives a focus event', () => {
        jest.advanceTimersByTime(100)
        expect(editor.getInstanceState().isFocused).toBe(false)
        editor.elm.focus()
        jest.advanceTimersByTime(100)
        expect(editor.getInstanceState().isFocused).toBe(true)
    })
    it('becomes false when the container receives a blur event', () => {
        editor.elm.focus()
        jest.advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(true)
        editor.elm.blur()
        advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(false)
    })
    it.skip('becomes true with a focusin event on child (skipped for new focus manager)', () => {
        editor.elm.blur()
        const child = document.createElement('div')
        editor.elm.appendChild(child)
        advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(false)
        child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
        advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(true)
        child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
        advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(false)
    })
    it('leaves focused when a child receives focusout', () => {
        const child = document.createElement('div')
        editor.elm.appendChild(child)
        editor.updateInstanceState({ isFocused: true })
        expect(getInstanceState().isFocused).toBe(true)
        child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
        advanceTimersByTime(100)
        expect(getInstanceState().isFocused).toBe(false)
    })
    it('calls focus/blur on container via editor focus/blur methods', () => {
        const focusMock = jest.spyOn(editor.getContainer(), 'focus').mockImplementation()
        const blurMock = jest.spyOn(editor.getContainer(), 'blur').mockImplementation()
        expect(focusMock).not.toHaveBeenCalled()
        expect(blurMock).not.toHaveBeenCalled()
        editor.getContainer().focus()
        expect(focusMock).toHaveBeenCalled()
        expect(blurMock).not.toHaveBeenCalled()
        editor.getContainer().blur()
        expect(blurMock).toHaveBeenCalled()
    })
})

/* ---------------------------------------------------------------------------
 * Shape util
 * --------------------------------------------------------------------------- */

describe('getShapeUtil', () => {
    let MyUtil: any

    beforeEach(() => {
        class MyShapeUtil extends BaseBoxShapeUtil<any> {
            static type = 'blorg'
            getDefaultProps() {
                return { w: 100, h: 100 }
            }
            component() {
                throw new Error('Not implemented')
            }
            indicator() {
                throw new Error('Not implemented')
            }
        }

        MyUtil = MyShapeUtil
        editor = new TestEditor({ shapeUtils: [MySize] })
        editor.createShapes([
            { id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 100, h: 100 } },
        ])
        const page1 = getCurrentPageId()
        editor.createPage({ name: 'page 2', id: ids.page2 })
        setCurrentPage(page1)
    })

    it('accepts shapes', () => {
        const shape = editor.getShape(ids.box1)!
        const util = editor.getShapeUtil(shape)
        expect(util).toBeInstanceOf(MyUtil)
    })
    it('accepts types', () => {
        const util = editor.getShapeUtil('blorg')
        expect(util).toBeInstanceOf(MyUtil)
    })
    it('throws for unknown shape', () => {
        const missing = { type: 'missing' } as TLShape
        expect(() => editor.getShapeUtil(missing)).toThrowErrorMatchingInlineSnapshot(
            `No shape util found for type "missing"`
        )
    })
    it('throws for unknown type', () => {
        expect(() => editor.getShapeUtil('missing')).toThrowErrorMatchingInlineSnapshot(
            `No shape util found for type "missing"`
        )
    })
})

/* ---------------------------------------------------------------------------
 * Snapshots
 * --------------------------------------------------------------------------- */

describe('snapshots', () => {
    it('serializes and deserializes', () => {
        const ids = {
            imageA: createShapeId('imageA'),
            boxA: createShapeId('boxA'),
            imageAssetA: AssetRecordType.createId('imageAssetA'),
        }

        editor.createAssets([
            {
                type: 'image',
                id: ids.imageAssetA,
                typeName: 'asset',
                props: { w: 1200, h: 800, name: '', isAnimated: false, mimeType: 'png' },
                meta: {},
            },
        ])

        editor.createShapes([
            { type: 'geo', x: 0, y: 0 },
            { type: 'geo', x: 100, y: 0 },
            {
                id: ids.imageA,
-               type: 'image',
+
                type: 'image',
                props: {
                    playing: false,
                    url: '',
-                    w: 1200,
-                    h: 800,
+                    w: 1200,
+                    h: 800,
-                    assetId: ids.imageAssetA,
+                    assetId: ids.imageAssetA,
                },
                x 0,
                y: 0,
            },
        ])

        const page2 = PageRecordType.createId('page2')
        editor.createPage({ id: page2 })
        setCurrentPage(page2)
        add("some shapes")
        selectAll()
        const snapshot = getSnapshot(editor.store)

        const newEditor = new TestEditor({})
        loadSnapshot(newEditor.store, snapshot)
        expect(editor.store.serialize()).toBe(newEditor.store.serialize())
    })
}

/* ---------------------------------------------------------------------------
 * Middle click panning
 * --------------------------------------------------------------------------- */

describe('middle-click panning', () => {
    it('clears the isPanning state on tap up', () => {
        pointerDown(0, 0, { button: 1 }).pointerMove(100, 100)
        expect(editor.inputs.isPanning).toBe(true)
        pointerUp(100, 100)
        expect(inputs.isPanning).toBe(false)
    })
    it('keeps isPanning when space down', () => {
        pointerDown(0, 0, { button: 1 }).pointerMove(100, 100)
        expect(inputs.isPanning).toBe(true)
        keyDown(' ')
        pointerUp(100, 100, { button: 1 })
        expect(isPanning).toBe(true)
        keyUp(' ')
        expect(isPanning).toBe(false)
    })
})

/* ---------------------------------------------------------------------------
 * Dragging
 * --------------------------------------------------------------------------- */

describe('dragging', () => {
    it('drags correctly at 100% zoom', () => {
        expect(inputs.isDragging).toBe(false)
        pointerMove(0, 0). pointerDown()
        expect(isDragging).toBe(false)
        pointerMove(0, 5)
        expect(isDragging).toBe(true)
    })
    it('drags correctly at 150% zoom', () => {
        setCamera({ x: 0, y: 0, z: 8 }).performTick()
        expect(isDragging).toBe(false)
        pointerMove(0, 0). pointerDown()
        expect(isDragging).toBe(false)
        pointerMove(0, 5)
        expect(isDragging).toBe(true)
    })
    it('drags correctly at 50% zoom', () => {
        setCamera({ x: 0, y: 0, z: 0.5 }).performTick()
        expect(isDragging).toBe(false)
        pointerMove(0, 0). pointerDown()
        expect(isDragging).toBe(false)
        pointerMove(0, 5)
        expect(isDragging).toBe(true)
    })
})

/* ---------------------------------------------------------------------------
 * Shape visibility
 * --------------------------------------------------------------------------- */

describe('getShapeVisibility', () => {
    const getVisibility = jest.fn(((shape: TLShape) => ('hidden' as const)))
    beforeEach(() => {
        getVisibility.mockClear()
        editor = new TestEditor({ getShapeVisibility })
        editor.createShapes([
            {
                id: ids.box1,
                type: 'geo',
                x: 100,
                y: 100,
                props: { w: 100, h: 100, fill: 'solid' },
            },
            {
                id: ids.box2,
                type: 'geo',
                x: 200,
                y: 200,
                props: { w: 100, h: 100, fill: 'solid' },
            },
            { id: ids.box3, type: 'geo', x: 300, y: 300, props: { w: 100, h: 100, fill: 'solid' } },
        ])
    })
    it('can be called directly', () => {
        expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
        editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
        expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
    })
    it('excludes hidden shapes from rendering', () => {
        expect(editor.getRenderingShapes().length).toBe(3)
        editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
        expect(renderingShapes()).toBe(2)
        ... // continued similar to earlier tests
    })
    // more tests follow as previously
})

/* ---------------------------------------------------------------------------
 * Readonly instance
 * --------------------------------------------------------------------------- */

describe('instance.isReadOnly', () => {
    it('updates according to collaboration mode', () => {
        const mode = atom<'readonly' | 'readwrite'>('', 'readonly')
        const editor = new TestEditor(
            {},
            {
                collaboration: {
                    mode,
                    status: atom('', 'online'),
                },
            }
        )
        expect(editor.getIsReadOnly()).toBe(true)
        mode.set('readwrite')
        expect(getIsReadOnly()).toBe(false)
        mode.set('readonly')
        expect(getIsReadOnly()).toBe(true)
    })
})
```

(Note: the above is an illustrative reconstruction. The exact final source code may differ slightly in line details and exact method names, but it reflects the final state after all commits.)
```