
index a458d5593..7f97ef2bb 100644
--- a/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_expectedoutput.txt (expected):tmp/tmpmj_dodna_expected.txt	
+++ b/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_extracted.txt (actual):tmp/tmpbhtup64s_actual.txt	
@@ -279,7 +279,7 @@ pub trait SegmentOptimizer {
                         let index_type = match (is_big, config_on_disk) {
                             (true, true) => SparseIndexType::Mmap, // Big and configured on disk
                             (true, false) => SparseIndexType::ImmutableRam, // Big and not on disk nor reached threshold
-                            (false, _) => SparseIndexType::MutableRam,      // Small
+                            (false, _) => SparseIndexType::MutableRam, // Small
                         };
 
                         config.index.index_type = index_type;
@@ -457,6 +457,8 @@ pub trait SegmentOptimizer {
             }
         }
 
+        self.check_cancellation(stopped)?;
+
         // 000 - acquired
         // +++ - blocked on waiting
         //
@@ -516,6 +518,9 @@ pub trait SegmentOptimizer {
         // Point deletions bump the segment version, can cause index changes to be ignored
         let old_optimized_segment_version = optimized_segment.version();
         for (field_name, change) in proxy_changed_indexes.read().iter_ordered() {
+            // Warn: change version might be lower than the segment version,
+            // because we might already applied the change earlier in optimization.
+            // Applied optimizations are not removed from `proxy_index_changes`.
             debug_assert!(
                 change.version() >= old_optimized_segment_version,
                 "proxied index change should have newer version than segment",
@@ -561,6 +566,7 @@ pub trait SegmentOptimizer {
     /// If there were any record changes during the optimization - an additional plain segment will be created.
     ///
     /// Returns id of the created optimized segment. If no optimization was done - returns None
+    ///
     fn optimize(
         &self,
         segments: LockedSegmentHolder,
@@ -722,6 +728,7 @@ pub trait SegmentOptimizer {
             let points_diff = deleted_points
                 .iter()
                 .filter(|&(point_id, _version)| !already_remove_points.contains(point_id));
+            let optimized_segment_version = optimized_segment.version();
             for (&point_id, &versions) in points_diff {
                 // Delete points here with their operation version, that'll bump the optimized
                 // segment version and will ensure we flush the new changes
