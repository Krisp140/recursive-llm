
index c051e53fd..c14d1e8d1 100644
--- a/aider_tests_basic_test_coder.py_expectedoutput.txt (expected):tmp/tmpse9ao1b1_expected.txt	
+++ b/aider_tests_basic_test_coder.py_extracted.txt (actual):tmp/tmpju0g9hek_actual.txt	
@@ -172,101 +172,6 @@ class TestCoder(unittest.TestCase):
 
             self.assertEqual(coder.abs_fnames, set([str(fname.resolve())]))
 
-    def test_skip_duplicate_basename_mentions(self):
-        with GitTemporaryDirectory():
-            io = InputOutput(pretty=False, yes=True)
-            coder = Coder.create(self.GPT35, None, io)
-
-            # Create files with same basename in different directories
-            fname1 = Path("dir1") / "file.txt"
-            fname2 = Path("dir2") / "file.txt"
-            fname3 = Path("dir3") / "unique.txt"
-
-            for fname in [fname1, fname2, fname3]:
-                fname.parent.mkdir(parents=True, exist_ok=True)
-                fname.touch()
-
-            # Add one file to chat
-            coder.add_rel_fname(str(fname1))
-
-            # Mock get_tracked_files to return all files
-            mock = MagicMock()
-            mock.return_value = set([str(fname1), str(fname2), str(fname3)])
-            coder.repo.get_tracked_files = mock
-
-            # Check that file mentions of a pure basename skips files with duplicate basenames
-            mentioned = coder.get_file_mentions(f"Check {fname2.name} and {fname3}")
-            self.assertEqual(mentioned, {str(fname3)})
-
-            # Add a read-only file with same basename
-            coder.abs_read_only_fnames.add(str(fname2.resolve()))
-            mentioned = coder.get_file_mentions(f"Check {fname1} and {fname3}")
-            self.assertEqual(mentioned, {str(fname3)})
-
-    def test_check_for_file_mentions_read_only(self):
-        with GitTemporaryDirectory():
-            io = InputOutput(
-                pretty=False,
-                yes=True,
-            )
-            coder = Coder.create(self.GPT35, None, io)
-
-            fname = Path("readonly_file.txt")
-            fname.touch()
-
-            coder.abs_read_only_fnames.add(str(fname.resolve()))
-
-            # Mock the get_tracked_files method
-            mock = MagicMock()
-            mock.return_value = set([str(fname)])
-            coder.repo.get_tracked_files = mock
-
-            # Call the check_for_file_mentions method
-            result = coder.check_for_file_mentions(f"Please check {fname}!")
-
-            # Assert that the method returns None (user not asked to add the file)
-            self.assertIsNone(result)
-
-            # Assert that abs_fnames is still empty (file not added)
-            self.assertEqual(coder.abs_fnames, set())
-
-    def test_check_for_file_mentions_with_mocked_confirm(self):
-        with GitTemporaryDirectory():
-            io = InputOutput(pretty=False)
-            coder = Coder.create(self.GPT35, None, io)
-
-            # Mock get_file_mentions to return two file names
-            coder.get_file_mentions = MagicMock(return_value=set(["file1.txt", "file2.txt"]))
-
-            # Mock confirm_ask to return False for the first call and True for the second
-            io.confirm_ask = MagicMock(side_effect=[False, True, True])
-
-            # First call to check_for_file_mentions
-            coder.check_for_file_mentions("Please check file1.txt for the info")
-
-            # Assert that confirm_ask was called twice
-            self.assertEqual(io.confirm_ask.call_count, 2)
-
-            # Assert that only file2.txt was added to abs_fnames
-            self.assertEqual(len(coder.abs_fnames), 1)
-            self.assertIn("file2.txt", str(coder.abs_fnames))
-
-            # Reset the mock
-            io.confirm_ask.reset_mock()
-
-            # Second call to check_for_file_mentions
-            coder.check_for_file_mentions("Please check file1.txt and file2.txt again")
-
-            # Assert that confirm_ask was called only once (for file1.txt)
-            self.assertEqual(io.confirm_ask.call_count, 1)
-
-            # Assert that abs_fnames still contains only file2.txt
-            self.assertEqual(len(coder.abs_fnames), 1)
-            self.assertIn("file2.txt", str(coder.abs_fnames))
-
-            # Assert that file1.txt is in ignore_mentions
-            self.assertIn("file1.txt", coder.ignore_mentions)
-
     def test_check_for_subdir_mention(self):
         with GitTemporaryDirectory():
             io = InputOutput(pretty=False, yes=True)
@@ -443,6 +348,101 @@ Once I have these, I can show you precisely how to do the thing.
                         f"Failed for content: {content}, addable_files: {addable_files}",
                     )
 
+    def test_skip_duplicate_basename_mentions(self):
+        with GitTemporaryDirectory():
+            io = InputOutput(pretty=False, yes=True)
+            coder = Coder.create(self.GPT35, None, io)
+
+            # Create files with same basename in different directories
+            fname1 = Path("dir1") / "file.txt"
+            fname2 = Path("dir2") / "file.txt"
+            fname3 = Path("dir3") / "unique.txt"
+
+            for fname in [fname1, fname2, fname3]:
+                fname.parent.mkdir(parents=True, exist_ok=True)
+                fname.touch()
+
+            # Add one file to chat
+            coder.add_rel_fname(str(fname1))
+
+            # Mock get_tracked_files to return all files
+            mock = MagicMock()
+            mock.return_value = set([str(fname1), str(fname2), str(fname3)])
+            coder.repo.get_tracked_files = mock
+
+            # Check that file mentions skip files with duplicate basenames
+            mentioned = coder.get_file_mentions(f"Check {fname2.name} and {fname3}")
+            self.assertEqual(mentioned, {str(fname3)})
+
+            # Add a read-only file with same basename
+            coder.abs_read_only_fnames.add(str(fname2.resolve()))
+            mentioned = coder.get_file_mentions(f"Check {fname1} and {fname3}")
+            self.assertEqual(mentioned, {str(fname3)})
+
+    def test_check_for_file_mentions_read_only(self):
+        with GitTemporaryDirectory():
+            io = InputOutput(
+                pretty=False,
+                yes=True,
+            )
+            coder = Coder.create(self.GPT35, None, io)
+
+            fname = Path("readonly_file.txt")
+            fname.touch()
+
+            coder.abs_read_only_fnames.add(str(fname.resolve()))
+
+            # Mock the get_tracked_files method
+            mock = MagicMock()
+            mock.return_value = set([str(fname)])
+            coder.repo.get_tracked_files = mock
+
+            # Call the check_for_file_mentions method
+            result = coder.check_for_file_mentions(f"Please check {fname}!")
+
+            # Assert that the method returns None (user not asked to add the file)
+            self.assertIsNone(result)
+
+            # Assert that abs_fnames is still empty (file not added)
+            self.assertEqual(coder.abs_fnames, set())
+
+    def test_check_for_file_mentions_with_mocked_confirm(self):
+        with GitTemporaryDirectory():
+            io = InputOutput(pretty=False)
+            coder = Coder.create(self.GPT35, None, io)
+
+            # Mock get_file_mentions to return two file names
+            coder.get_file_mentions = MagicMock(return_value=set(["file1.txt", "file2.txt"]))
+
+            # Mock confirm_ask to return False for the first call and True for the second
+            io.confirm_ask = MagicMock(side_effect=[False, True, True])
+
+            # First call to check_for_file_mentions
+            coder.check_for_file_mentions("Please check file1.txt for the info")
+
+            # Assert that confirm_ask was called twice
+            self.assertEqual(io.confirm_ask.call_count, 2)
+
+            # Assert that only file2.txt was added to abs_fnames
+            self.assertEqual(len(coder.abs_fnames), 1)
+            self.assertIn("file2.txt", str(coder.abs_fnames))
+
+            # Reset the mock
+            io.confirm_ask.reset_mock()
+
+            # Second call to check_for_file_mentions
+            coder.check_for_file_mentions("Please check file1.txt and file2.txt again")
+
+            # Assert that confirm_ask was called only once (for file1.txt)
+            self.assertEqual(io.confirm_ask.call_count, 1)
+
+            # Assert that abs_fnames still contains only file2.txt
+            self.assertEqual(len(coder.abs_fnames), 1)
+            self.assertIn("file2.txt", str(coder.abs_fnames))
+
+            # Assert that file1.txt is in ignore_mentions
+            self.assertIn("file1.txt", coder.ignore_mentions)
+
     def test_run_with_file_deletion(self):
         # Create a few temporary files
 
@@ -809,12 +809,13 @@ two
             repo.git.add(str(fname2))
             repo.git.commit("-m", "initial")
 
+            aignore = Path(".aiderignore")
+            aignore.write_text(f"{fname1}\n{fname2}\ndir\n")
+
             io = InputOutput(yes=True)
 
             fnames = [fname1, fname2, fname3]
 
-            aignore = Path(".aiderignore")
-            aignore.write_text(f"{fname1}\n{fname2}\ndir\n")
             repo = GitRepo(
                 io,
                 fnames,
@@ -1270,6 +1271,10 @@ This command will print 'Hello, World!' to the console."""
                 coder.auto_accept_architect = False
                 coder.verbose = False
                 coder.total_cost = 0
+                coder.cur_messages = []
+                coder.done_messages = []
+                coder.summarizer = MagicMock()
+                coder.summarizer.too_big.return_value = False
 
                 # Mock editor_coder creation and execution
                 mock_editor = MagicMock()
