```python
#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
from collections import defaultdict
from datetime import datetime
from operator import itemgetter
import re
import semver
import yaml
from tqdm import tqdm

website_files = [
    "aider/website/index.html",
    "aider/website/share/index.md",
    "aider/website/_includes/head_custom.html",
    "aider/website/_includes/home.css",
    "aider/website/docs/leaderboards/index.md",
]

exclude_files = [
    "aider/website/install.ps1",
    "aider/website/install.sh",
]

def run(cmd):
    """Run a subprocess command and return its stdout."""
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        check=True,
    )
    return result.stdout

def get_commit_authors(commits):
    """Return a mapping from short commit hash to author name."""
    commit_to_author = {}
    for commit in commits:
        author = run(["git", "show", "-s", "--format=%an", commit]).strip()
        commit_message = run(["git", "show", "-s", "--format=%s", commit]).strip()
        if commit_message.lower().startswith("aider:"):
            author += " (aider)"
        commit_to_author[commit] = author
    return commit_to_author

hash_len = len("44e6fefc2")

def get_all_commit_hashes_between_tags(start_tag, end_tag=None):
    """Get all commit hashes between two tags (or HEAD)."""
    if end_tag:
        res = run(["git", "rev-list", f"{start_tag}..{end_tag}"])
    else:
        res = run(["git", "rev-list", f"{start_tag}..HEAD"])
    if res:
        commit_hashes = res.strip().split("\n")
        return commit_hashes
    return []

def get_all_tags_since(start_tag):
    """Get all version tags ending with `.0` that are newer than start_tag."""
    all_tags = run(["git", "tag", "--sort=v:refname"]).strip().split("\n")
    start_version = semver.Version.parse(start_tag[1:])
    filtered_tags = [
        tag
        for tag in all_tags
        if semver.Version.is_valid(tag[1:]) and semver.Version.parse(tag[1:]) >= start_version
    ]
    return [tag for tag in filtered_tags if tag.endswith(".0")]

def get_latest_version_tag():
    """Return the most recent version tag (e.g., vX.Y.0) if one exists."""
    all_tags = run(["git", "tag", "--sort=-v:refname"]).strip().split("\n")
    for tag in all_tags:
        if semver.Version.is_valid(tag[1:]) and tag.endswith(".0"):
            return tag
    return None

def get_tag_date(tag):
    """Extract the date of a git tag."""
    date_str = run(["git", "log", "-1", "--format=%ai", tag]).strip()
    return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S %z")

def blame(start_tag, end_tag=None):
    """Calculate Aider contribution statistics between two tags."""
    commits = get_all_commit_hashes_between_tags(start_tag, end_tag)
    commits = [commit[:hash_len] for commit in commits]
    authors = get_commit_authors(commits)

    revision = end_tag if end_tag else "HEAD"
    files = run(["git", "ls-tree", "-r", "--name-only", revision]).strip().split("\n")

    # Test files for language fixtures
    test_files = [
        f for f in files
        if f.startswith("tests/fixtures/languages/") and "/test." in f
    ]

    files = [
        f
        for f in files
        if f.endswith((".js", ".py", ".scm", ".sh", "Dockerfile", "Gemfile"))
        or (f.startswith(".github/workflows/") and f.endswith(".yml"))
        or f in website_files
        or f in test_files
        or (f.startswith("aider/resources/") and f.endswith(".yml"))
    ]

    files = [f for f in files if not f.endswith("prompts.py")]
    files = [f for f in files if not f.startswith("tests/fixtures/watch")]
    files = [f for f in files if f not in exclude_files]

    all_file_counts = {}
    grand_total = defaultdict(int)
    aider_total = 0

    for fname in files:
        file_counts = get_counts_for_file(start_tag, end_tag, authors, fname)
        if file_counts:
            all_file_counts[fname] = file_counts
            for author, count in file_counts.items():
                grand_total[author] += count
                if "(aider)" in author.lower():
                    aider_total += count

    total_lines = sum(grand_total.values())
    aider_percentage = (aider_total / total_lines) * 100 if total_lines > 0 else 0

    end_date = get_tag_date(end_tag if end_tag else "HEAD")
    return (
        all_file_counts,
        grand_total,
        total_lines,
        aider_total,
        round(aider_percentage, 2),
        end_date,
    )

def process_all_tags_since(start_tag):
    """Process a series of tag pairs for --all-since."""
    tags = get_all_tags_since(start_tag)
    results = []
    for i in tqdm(range(len(tags) - 1), desc="Processing tags"):
        start_tag, end_tag = tags[i], tags[i + 1]
        all_file_counts, grand_total, total_lines, aider_total, aider_percentage, end_date = \
            blame(start_tag, end_tag)
        results.append(
            {
                "start_tag": start_tag,
                "end_tag": end_tag,
                "end_date": end_date.strftime("%Y-%m-%d"),
                "file_counts": all_file_counts,
                "grand_total": {
                    author: count
                    for author, count in sorted(
                        grand_total.items(),
                        key=itemgetter(1),
                        reverse=True,
                    )
                },
                "total_lines": total_lines,
                "aider_total": aider_total,
                "aider_percentage": round(aider_percentage, 2),
            }
        )
    return results

def get_counts_for_file(start_tag, end_tag, authors, fname):
    """Run git blame for a given file and return per‑author line counts."""
    try:
        if end_tag:
            text = run(
                [
                    "git",
                    "blame",
                    "-M100",
                    "-C100",
                    "-C",
                    "-C",
                    "--abbrev=9",
                    f"{start_tag}..{end_tag}",
                    "--",
                    fname,
                ]
            )
        else:
            text = run(
                [
                    "git",
                    "blame",
                    "-M100",
                    "-C100",
                    "-C",
                    "-C",
                    "--abbrev=9",
                    f"{start_tag}..HEAD",
                    "--",
                    fname,
                ]
            )
        if not text:
            return None
        lines = text.splitlines()
        line_counts = defaultdict(int)
        for line in lines:
            if line.startswith("^"):
                continue
                # skip unassigned
                # Git may prefix lines with '^' for uncommitted lines.
                # Continue to next line
                continue
            hsh = line[:hash_len]
            author = authors.get(hsh, "Unknown")
            line_counts[author] += 1
        return dict(line_counts)
    except subprocess.CalledProcessError as e:
        # File may not exist in this revision range; safely ignore.
        return None

def main():
    parser = argparse.ArgumentParser(description="Get aider/non‑aider blame stats")
    parser.add_argument(
        "start_tag",
        nargs="?",
        help="The tag to start from (optional)",
    )
    parser.add_argument(
        "--end-tag",
        help="The tag to end at (default: HEAD)",
        default=None,
    )
    parser.add_argument(
        "--all-since",
        action="store_true",
        help=(
            "Find all tags since the specified tag and print "
            "aider percentage between each pair of successive tags"
        ),
    )
    parser.add_argument(
        "--output",
        type=str,
        default=None,
        help="Output file to save the YAML results",
    )
    args = parser.parse_args()

    if not args.start_tag:
        args.start_tag = get_latest_version_tag()
        if not args.start_tag:
            print("Error: No valid vX.Y.0 tag found.")
            return

    if args.all_since:
        results = process_all_tags_since(args.start_tag)
        yaml_output = yaml.dump(results, sort_keys=True)
    else:
        (
            all_file_counts,
            grand_total,
            total_lines,
            aider_total,
            aider_percentage,
            end_date,
        ) = blame(args.start_tag, args.end_tag)
        result = {
            "start_tag": args.start_tag,
            "end_tag": args.end_tag or "HEAD",
            "end_date": end_date.strftime("%Y-%m-%d"),
            "file_counts": all_file_counts,
            "grand_total": {
                author: count
                for author, count in sorted(
                    grand_total.items(), key=itemgetter(1), reverse=True
                )
            },
            "total_lines": total_lines,
            "aider_total": aider_total,
            "aider_percentage": round(aider_percentage, 2),
        }
        yaml_output = yaml.dump(result, sort_keys=True)

    if args.output:
        with open(args.output, "w") as f:
            f.write(yaml_output)
    else:
        print(yaml_output)

    if not args.all_since:
        print(f"- Aider wrote {round(aider_percentage)}% of the code in this release.")

if __name__ == "__main__":
    main()
```