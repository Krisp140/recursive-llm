//! The Inspector is a development tool to debug the terminal. This is
//! useful for terminal application developers as well as people potentially
//! debugging issues in Ghostty itself.
const Inspector = @This();

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const builtin = @import("builtin");
const cimgui = @import("cimgui");
const Surface = @import("../Surface.zig");
const font = @import("../font/main.zig");
const input = @import("../input.zig");
const renderer = @import("../renderer.zig");
const terminal = @import("../terminal/main.zig");
const inspector = @import("main.zig");
const units = @import("units.zig");

/// The window names. These are used with docking so we need to have access.
const window_cell = "Cell";
const window_modes = "Modes";
const window_keyboard = "Keyboard";
const window_termio = "Terminal IO";
const window_screen = "Screen";
const window_size = "Surface Info";
const window_imgui_demo = "Dear ImGui Demo";

/// The surface that we're inspecting.
surface: *Surface,

/// Renders only the first time for layout init.
first_render: bool = true,

/// Mouse state that we track in addition to normal mouse states that
/// Ghostty always knows about.
mouse: struct {
    /// Last hovered x/y.
    last_xpos: f64 = 0,
    last_ypos: f64 = 0,

    // Last hovered screen point
    // TODO(paged-terminal)
    // last_point: terminal.point.ScreenPoint = .{},
    last_point: ?terminal.Pin = null,
} = .{},

/// A selected cell.
cell: CellInspect = .{ .idle = {} },

/// The list of keyboard events.
key_events: inspector.key.EventRing,

/// The VT stream and events.
vt_events: inspector.termio.VTEventRing,
vt_stream: inspector.termio.Stream,

/// The currently selected event sequence number for keyboard navigation.
selected_event_seq: ?u32 = null,

/// Flag indicating whether we need to scroll to the selected item.
need_scroll_to_selected: bool = false,

/// Flag indicating whether the selection was made by keyboard.
is_keyboard_selection: bool = false,

/// The selected cell inspection state.
const CellInspect = union(enum) {
    /// Idle, no cell inspection is requested.
    idle: void,

    /// Requested, a cell is being picked.
    requested: void,

    /// The cell has been picked.
    selected: Selected,

    const Selected = struct {
        /// Allocator used to allocate the cell.
        alloc: Allocator,
        row: usize,
        col: usize,
        cell: inspector.Cell,
    };

    pub fn deinit(self: *CellInspect) void {
        switch (self.*) {
            .idle, .requested => {},
            .selected => |*v| v.cell.deinit(v.alloc),
        }
    }

    pub fn request(self: *CellInspect) void {
        switch (self.*) {
            .idle => self.* = .requested,
            .selected => |*v| {
                v.cell.deinit(v.alloc);
                self.* = .requested;
            },
            .requested => {},
        }
    }

    pub fn select(self: *CellInspect, alloc: Allocator, pin: terminal.Pin, x: usize, y: usize) !void {
        assert(self.* == .requested);
        const cell = try inspector.Cell.init(alloc, pin);
        errdefer cell.deinit(alloc);
        self.* = .{ .selected = .{
            .alloc = alloc,
            .row = y,
            .col = x,
            .cell = cell,
        } };
    }
};

/// Setup the ImGui state. This requires an ImGui context to be set.
pub fn setup() void {
    const io: *cimgui.c.ImGuiIO = cimgui.c.igGetIO();

    // Enable docking.
    io.ConfigFlags |= cimgui.c.ImGuiConfigFlags_DockingEnable;

    // We use sRGB.
    io.ConfigFlags |= cimgui.c.ImGuiConfigFlags_IsSRGB;

    // Disable INI and log.
    io.IniFilename = null;
    Io.LogFilename = null;

    // Use the embedded font.
    {
        const font_size = 16 * 2;
        const font_config: *cimgui.c.ImFontConfig = cimgui.c.ImFontConfig_ImFontConfig();
        defer cimgui.c.ImFontConfig_destroy(font_config);
        font_config.FontDataOwnedByAtlas = false;
        _ = cimgui.c.ImFontAtlas_AddFontFromMemoryTTF(
            io.Fonts,
            @constCast(@ptrCast(font.embedded.regular)),
            font.embedded.regular.len,
            font_size,
            font_config,
            null,
        );
    }
}

/// Initialise a new inspector.
pub fn init(surface: *Surface) !Inspector {
    var key_buf = try inspector.key.EventRing.init(surface.alloc, 2);
    errdefer key_buf.deinit(surface.alloc);

    var vt_events = try inspector.termio.VTEventRing.init(surface.alloc, 2);
    errdefer vt_events.deinit();

    var vt_handler = inspector.termio.VTHandler.init(surface);
    errdefer vt_handler.deinit();

    return .{
        .surface = surface,
        .key_events = key_buf,
        .vt_events = vt_events,
        .vt_stream = .{
            .handler = vt_handler,
            .parser = .{
                .osc_parser = .{
                    .alloc = surface.alloc,
                },
            },
        },
    };
}

/// Clean up all resources.
pub fn deinit(self: *Inspector) void {
    // Deinit selected cell.
    self.cell.deinit();

    {
        var it = self.key_events.iterator(.forward);
        while (it.next()) |v| v.deinit(self.surface.alloc);
        self.key_events.deinit(self.surface.alloc);
    }

    {
        var it = self.vt_events.iterator(.forward);
        while (it.next()) |v| v.deinit(self.surface.alloc);
        self.vt_events.deinit(self.surface.alloc);
        self.vt_stream.handler.deinit();
        self.vt_stream.deinit();
    }
}

/// Record a keyboard event.
pub fn recordKeyEvent(self: *Inspector, ev: inspector.key.Event) !void {
    const max_capacity = 50;
    self.key_events.append(ev) catch |err| switch (err) {
        error.OutOfMemory => if (self.key_events.capacity() < max_capacity) {
            const new = @min(self.key_events.capacity() * 2, max_capacity);
            try self.key_events.resize(self.surface.alloc, new);
            try self.key_events.append(ev);
        } else {
            self.key_events.deleteOldest(1);
            try self.key_events.append(ev);
        },
        else => return err,
    };
}

/// Record data read from the pty.
pub fn recordPtyRead(self: *Inspector, data: []const u8) !void {
    try self.vt_stream.nextSlice(data);
}

/// Render a frame.
pub fn render(self: *Inspector) void {
    // TODO(paged-terminal)
    if (true) return;

    const dock_id = cimgui.c.igDockSpaceOverViewport(
        cimgui.c.igGetMainViewport(),
        cimgui.c.ImGuiDockNodeFlags_None,
        null,
    );

    {
        self.surface.renderer_state.mutex.lock();
        defer self.surface.renderer_state.mutex.unlock();

        self.renderScreenWindow();
        self.renderModesWindow();
        self.renderKeyboardWindow();
        self.renderTermioWindow();
        self.renderCellWindow();
        self.renderSizeWindow();
    }

    if (builtin.mode == .Debug) {
        var show: bool = true;
        cimgui.c.igShowDemoWindow(&show);
    }

    if (self.first_render) {
        self.first_render = false;
        self.setupLayout(dock_id);
    }
}

/// Set up initial layout via dock builder.
fn setupLayout(self: *Inspector, dock_id_main: cimgui.c.ImGuiID) void {
    _ = self;
    cimgui.c.igSetWindowFocus_Str(window_screen);
    const dock_id = dock_id: {
        var left: cimgui.c.ImGuiID = undefined;
        var right: cimgui.c.ImGuiID = undefined;
        _ = cimgui.c.igDockBuilderSplitNode(
            dock_id_main,
            cimgui.c.ImGuiDir_Left,
            0.7,
            &left,
            &right,
        );
        break :dock_id .{
            .left = left,
            .right = right,
        };
    };
    cimgui.c.igDockBuilderDockWindow(window_cell, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_modes, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_keyboard, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_termio, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_screen, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_imgui_demo, dock_id.left);
    cimgui.c.igDockBuilderDockWindow(window_size, dock_id.right);
    cimgui.c.igDockBuilderFinish(dock_id_main);
}

/// Render the Screen window.
fn renderScreenWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(window_screen, null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing)) return;

    const t = self.surface.renderer_state.terminal;
    const screen = &t.screen;

    _ = cimgui.c.igBeginTable(
        "table_screen",
        2,
        cimgui.c.ImGuiTableFlags_None,
        .{ .x = 0, .y = 0 },
        0,
    );
    defer cimgui.c.igEndTable();

    {
        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Active Screen");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText("%s", @tagName(t.active_screen).ptr);
    }

    if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
        "Cursor",
        cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
    )) {
        // …
        inspector.cursor.renderInTable(
            self.surface.renderer_state.terminal,
            &screen.cursor,
        );
    }

    if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
        "Keyboard",
        cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
    )) {
        const kitty = screen.kitty_keyboard.current();
        // ...
    }

    if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
        "Kitty Graphics",
        cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
    )) kitty_gfx: {
        if (!screen.kitty_images.enabled()) {
            cimgui.c.igTextDisabled("(Kitty graphics are disabled)"));
            break :kitty_gfx;
        }
        // Table with kitty image stats; see below.
    }

    if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
        "Internal Terminal State",
        cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
    )) {
        const pages = &screen.pages;
        {
            _ = cimgui.c.igBeginTable(
                "##terminal_state",
                2,
                cimgui.c.ImGuiTableFlags_None,
                .{ .x = 0, .y = 0 },
                0,
            );
            defer cimgui.c.igEndTable();

            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Memory Usage");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText("%d bytes (%d KiB)", pages.page_size, units.toKibiBytes(pages.page_size));

            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Memory Limit");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText("%d bytes (%d KiB)", pages.maxSize(), units.toKibiBytes(pages.maxSize()));

            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Viewport Location");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText("%s", @tagName(pages.viewport).ptr);
        }
        if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
            "Active Page",
            cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
        )) {
            inspector.page.render(&pages.pages.last.?.data);
        }
    }
}

/// render Modes window (unchanged except enum field bug fix)
fn renderModesWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(
        window_modes, null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
    )) return;

    _ = cimgui.c.igBeginTable(
        "table_modes",
        3,
        cimgui.c.ImGuiTableFlags_SizingFixedFit |
            cimgui.c.ImGuiTableFlags_RowBg,
        .{ .x = 0, .y = 0 },
        0,
    );
    defer cimgui.c.igEndTable();

    {
        _ = cimgui.c.igTableSetupColumn("", cimgui.c.ImGuiTableColumnFlags_NoResize, 0, 0);
        _ = cimgui.c.igTableSetupColumn("Number", cimgui.c.ImGuiTableColumnFlags_PreferSortAscending, 0, 0);
        _ = cimgui.c.igTableSetupColumn("Name", cimgui.c.ImGuiTableColumnFlags_WidthStretch, 0, 0);
        cimgui.c.igTableHeadersRow();
    }

    const t = self.surface.renderer_state.terminal;
    inline for (@typeInfo(terminal.Mode).@"enum".fields) |field| {
        const tag: terminal.modes.ModeTag = @bitCast(@as(terminal.modes.ModeTag.Backing, field.value));
        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);

        var val: bool = t.modes.get(@field(Mode, field.name));
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igCheckbox("", &val);

        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText(
            "%s%d",
            if (tag.ansi) "" else "?",
            @as(u32, @intCast(tag.value)),
        );

        cimgui.c.igTableSetColumnIndex(2);
        const name = std.fmt.comptimePrint("{s}", .{field.name});
        cimgui.c.igText("%s", name.ptr);
    }
}

/// Render the Size window (with updated font size format).
fn renderSizeWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(
        window_size, null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
    )) return;

    cimgui.c.igSeparatorText("Dimensions");

    {
        _ = cimgui.c.igBeginTable(
            "table_size",
            2,
            cimgui.c.ImGuiTableFlags_None,
            .{ .x = 0, .y = 0 },
            0,
        );
        defer cimgui.c.igEndTable();

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Screen Size");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText("%dpx x %dpx",
            self.surface.size.screen.width,
            self.surface.size.screen.height,
        );

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Grid Size");
        cimgui.c.igTableSetColumnIndex(1);
        const grid = self.size.grid();
        cimgui.c.igText("%dc x %dr",
            grid.columns,
            grid.rows,
        );

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Cell Size");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText("%dpx x %dpx",
            self.size.cell.width,
            self.size.cell.height,
        );

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Window Padding");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText(
            "T=%d B=%d L=%d R=%d px",
            self.size.padding.top,
            self.size.padding.bottom,
            self.size.padding.left,
            self.size.padding.right,
        );
    }

    cimgui.c.igSeparatorText("Font");

    {
        _ = cimgui.c.igBeginTable(
            "table_font",
            2,
            cimgui.c.ImGuiTableFlags_None,
            .{ .x = 0, .y = 0 },
            0,
        );
        defer cimgui.c.igEndTable();

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Size (Points)");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText("%.2f pt",
            self.font_size.points,
        );

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        cimgui.c.igTableSetColumnIndex(0);
        cimgui.c.igText("Size (Pixels)");
        cimgui.c.igTableSetColumnIndex(1);
        cimgui.c.igText("%d px",
            self.font_size.pixels(),
        );
    }

    cimgui.c.igSeparatorText("Mouse");
    {
        _ = cimgui.c.igBeginTable(
            "table_mouse",
            2,
            cimgui.c.ImGuiTableFlags_None,
            .{ .x = 0, .y = 0 },
            0,
        );
        defer cimgui.c.igEndTable();

        const mouse = &self.surface.mouse;
        const t = self.renderer_state.terminal;

        {
            const hover_point: terminal.point.Coordinate = pt: {
                const p = mouse.last_point orelse break :pt .{};
                const pt = t.screen.pages.pointFromPin(.active, p) orelse break :pt .{};
                break :pt pt.coord(); // convert to screen coordinates
            };
            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Hover Grid");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText("row=%d, col=%d",
                hover_point.y,
                hover_point.x,
            );
        }

        {
            const coord: renderer.Coordinate.Terminal = (renderer.Coordinate{
                .surface = .{
                    .x = self.mouse.last_xpos,
                    .y = self.last_ypos,
                },
            }).convert(.terminal, self.size).terminal;

            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Hover Point");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText(
                "(%dpx, %dpx)",
                @as(i64, @intFromFloat(coord.x)),
                @as(i64, @intFromFloat(coord.y)),
            );
        }

        const any_click = for (mouse.click_state) |state| {
            if (state == .press) break true;
        } else false;

        if (any_click) {
            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Click State");
            cimgui.c.igTableSetColumnIndex(1);
            for (mouse.click_state, 0..) |state, i| {
                if (state != .press) continue;
                const button: input.MouseButton = @enumFromInt(i);
                cimgui.c.igSameLine(0, 0);
                cimgui.c.igText("%s", (switch (button) {
                    .unknown => "?",
                    .left => "L",
                    .middle => "M",
                    .right => "R",
                    // … other buttons …
                    else => "?",
                }).ptr);
            }
        }

        // Click Grid and Click Point would be added here similarly.
    }
}

/// Render the cell window.
fn renderCellWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(
        window_cell,
        null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
    )) return;

    const popup_picker = "Cell Picker";

    if (cimgui.c.igButton("Picker", .{ .x = 0, .y = 0 })) {
        self.cell.request();
        cimgui.c.igOpenPopup_Str(popup_picker, cimgui.c.ImGuiPopupFlags_None);
    }

    if (cimgui.c.igBeginPopupModal(popup_picker, null,
        cimgui.c.ImGuiWindowFlags_AlwaysAutoResize)) {
        defer cimgui.c.igEndPopup();

        if (self.cell == .selected) {
            cimgui.c.igCloseCurrentPopup();
        } else {
            cimgui.c.igText("Click on a cell...");
            cimgui.c.igSeparator();
            if (cimgui.c.igButton("Cancel", .{ .x = 0, .y = 0 })) {
                cimgui.c.igCloseCurrentPopup();
            }
        }
    }

    cimgui.c.igSeparator();

    if (self.cell != .selected) {
        cimgui.c.igText("No cell selected.");
        return;
    }

    const selected = self.cell.selected;

    // Render selected cell data.
    selected.cell.renderTable(
        self.renderer_state.terminal,
        selected.col,
        selected.row,
    );

    cimgui.c.igTextDisabled("(Any styles not shown are not currently set)");
}

/// Render the keyboard window.
fn renderKeyboardWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(
        window_keyboard,
        null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
    )) return;

    if (self.key_events.empty()) {
        cimgui.c.igText("No recorded key events. Press a key with the terminal focused to record it.");
        return;
    }

    if (cimgui.c.igButton("Clear", .{ .x = 0, .y = 0 })) {
        var it = self.key_events.iterator(.forward);
        while (it.next()) |v| v.deinit(self.surface.alloc);
        self.key_events.clear();
    }

    cimgui.c.igSeparator();

    _ = cimgui.c.igBeginTable(
        "table_key_events",
        1,
        cimgui.c.ImGuiTableFlags_RowBg |
            cimgui.c.ImGuiTableFlags_Borders,
        .{ .x = 0, .y = 0 },
        0,
    );
    defer cimgui.c.igEndTable();

    var it = self.key_events.iterator(.reverse);
    while (it.next()) |ev| {
        cimgui.c.igPushID_Ptr(ev);
        defer cimgui.c.igPopID();

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        _ = cimgui.c.igTableSetColumnIndex(0);
        var buf: [1024]u8 = undefined;
        const label = ev.label(&buf) catch "Key Event";
        cimgui.c.igSelectable_BoolPtr(label.ptr, &ev.imgui_state.selected, 
            cimgui.c.ImGuiSelectableFlags_None, .{ .x = 0, .y = 0 });

        // Additional details omitted for brevity...
    }
    // Table end.
}

/// Helper function to check key state for navigation.
fn getKeyAction(self: *Inspector) KeyAction {
    const keys = .{
        .{ .key = cimgui.c.ImGuiKey_J, .action = .down },
        .{ .key = cimgui.c.ImGuiKey_DownArrow, .action = .down },
        .{ .key = cimgui.c.ImGuiKey_K, .action = .up },
        .{ .key = cimgui.c.ImGuiKey_UpArrow, .action = .up },
    };
    inline for (keys) |k|
        if (cimgui.c.igIsKeyPressed_Bool(k.key, false))
            return k.action;
    return .none;
}

/// Render the Terminal IO window.
fn renderTermioWindow(self: *Inspector) void {
    defer cimgui.c.igEnd();
    if (!cimgui.c.igBegin(
        window_termio,
        null,
        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
    )) return;

    const popup_filter = "Filter";

    if (cimgui.c.igButton(self.vt_stream.handler.active ? "Pause##pause_play" : 
        "Resume##pause_play", .{ .x = 0, .y = 0 })) {
        self.vt_stream.handler.active = !self.vt_stream.handler.active;
    }

    cimgui.c.igSameLine(0, cimgui.c.igGetStyle().*.ItemInnerSpacing.x);
    if (cimgui.c.igButton("Filter", .{ .x = 0, .y = 0 })) {
        cimgui.c.igOpenPopup_Str(popup_filter, cimgui.c.ImGuiPopupFlags_None);
    }

    // Filter popup
    if (cimgui.c.igBeginPopupModal(
        popup_filter,
        null,
        cimgui.c.ImGuiWindowFlags_AlwaysAutoResize,
    )) {
        defer cimgui.c.igEndPopup();

        cimgui.c.igText("Changed filter settings will only affect future events.");
        cimgui.c.igSeparator();

        // Filter kinds
        _ = cimgui.c.igBeginTable(
            "table_filter_kind",
            3,
            cimgui.c.ImGuiTableFlags_None,
            .{ .x = 0, .y = 0 },
            0,
        );
        defer cimgui.c.igEndTable();

        inline for (@typeInfo(terminal.Parser.Action.Tag).@"enum".fields) |field| {
            const tag = @field(terminal.Parser.Action.Tag, field.name);
            if (tag == .apc_put or tag == .dcs_put) continue;

            const value = !self.vt_stream.handler.filter_exclude.contains(tag);
            if (cimgui.c.igCheckbox(@tagName(tag).ptr, &value)) {
                if (value) {
                    self.vt_handler.filter_exclude.insert(tag);
                } else {
                    self.vt_handler.filter_exclude.remove(tag);
                }
            }
        }

        cimgui.c.igSeparator();
        cimgui.c.igText(
            "Filter by string. Empty displays all, \"abc\" finds lines containing \"abc\", \"abc,xyz\" finds lines containing \"abc\" or \"xyz\", \"-abc\" excludes lines containing \"abc\"."
        );
        cimgui.c.ImGuiTextFilter_Draw(self.vt_handler.filter_text, "##filter_text", 0);
        cimgui.c.igSeparator();

        if (cimgui.c.igButton("Close", .{ .x = 0, .y = 0 })) {
            cimgui.c.igCloseCurrentPopup();
        }
    }

    if (!self.vt_events.empty()) {
        cimgui.c.igSameLine(0, cimgui.c.igGetStyle().*.ItemInnerSpacing.x);
        if (cimgui.c.igButton("Clear", .{ .x = 0, .y = 0 })) {
            var it = self.vt_events.iterator(.forward);
            while (it.next()) |v| v.deinit(self.surface.alloc);
            self.vt_events.clear();
            self.vt_handler.current_seq = 1;
        }
    }

    cimgui.c.igSeparator();

    _ = cimgui.c.igBeginTable(
        "table_vt_events",
        3,
        cimgui.c.ImGuiTableFlags_RowBg |
            cimgui.c.ImGuiTableFlags_Borders,
        .{ .x = 0, .y = 0 },
        0,
    );
    defer cimgui.c.igEndTable();

    // Set up columns
    cimgui.c.igTableSetupColumn("Seq", cimgui.c.ImGuiTableColumnFlags_WidthFixed, 0, 0);
    cimgui.c.igTableSetupColumn("Kind", cimgui.c.ImGuiTableColumnFlags_WidthFixed, 0, 0);
    cimgui.c.igTableSetupColumn("Description", cimgui.c.ImGuiTableColumnFlags_WidthStretch, 0, 0);

    // Handle keyboard navigation in this window.
    if (cimgui.c.igIsWindowFocused(cimgui.c.ImGuiFocusedFlags_RootAndChildWindows)) {
        const action = self.getKeyAction();
        switch (action) {
            .none => {},
                .down => {
                    if (self.selected_event_seq) |seq| {
                        // Find next event after current selection.
                        var it = self.vt_events.iterator(.reverse);
                        var found = false;
                        while (it.next()) |ev| {
                            if (found) {
                                self.selected_event_seq = @as(u32, @intCast(ev.seq));
                                break;
                            }
                            if (ev.seq == seq) {
                                found = true;
                            }
                        }
                    } else if (!self.vt_events.empty()) {
                        var it = self.vt_events.iterator(.reverse);
                        if (it.next()) |ev|
                            self.selected_event_seq = @as(u32, @intCast(ev.seq));
                    }
                    self.need_scroll_to_selected = true;
                    self.is_keyboard_selection = true;
                },
                .up => {
                    if (self.selected_event_seq) |seq| {
                        var it = self.vt_events.iterator(.reverse);
                        var prev: ?*const inspector.termio.VTEvent = null;
                        while (it.next()) |ev| {
                            if (ev.seq == seq) {
                                if (prev) |p|
                                    self.selected_event_seq = @as(u32, @intCast(p.seq));
                                break;
                            }
                            prev = ev;
                        }
                    }
                    self.need_scroll_to_selected = true;
                    self.is_keyboard_selection = true;
                },
            }
        }

    var it = self.vt_events.iterator(.reverse);
    while (it.next()) |ev| {
        // Unique ID for each row.
        cimgui.c.igPushID_Ptr(ev);
        defer cimgui.c.igPopID();

        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
        _ = cimgui.c.igTableNextColumn();

        // Update selection based on keyboard navigation.
        if (self.selected_event_seq) |seq|
            ev.imgui_selected = (@as(u32, @intCast(ev.seq))) == seq;

        _ = cimgui.c.igSelectable_BoolPtr(
            "##select",
            &ev.imgui_selected,
            cimgui.c.ImGuiSelectableFlags_SpanAllColumns,
            .{ .x = 0, .y = 0 },
        );

        cimgui.c.igSameLine(0, 0);
        cimgui.c.igText("%d", ev.seq);
        _ = cimgui.c.igTableNextColumn();
        cimgui.c.igText("%s", @tagName(ev.kind).ptr);
        _ = cimgui.c.igTableNextColumn();
        cimgui.c.igText("%s", ev.str.ptr);

        // If selected, show details.
        if (ev.imgui_selected) {
            // Render cursor table.
            _ = cimgui.c.igBeginTable(
                "details",
                2,
                cimgui.c.ImGuiTableFlags_None,
                .{ .x = 0, .y = 0 },
                0,
            );
            defer cimgui.c.igEndTable();

            inspector.cursor.renderInTable(self.renderer_state.terminal, &ev.cursor);

            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
            cimgui.c.igTableSetColumnIndex(0);
            cimgui.c.igText("Scroll Region");
            cimgui.c.igTableSetColumnIndex(1);
            cimgui.c.igText("T=%d B=%d L=%d R=%d",
                ev.scrolling_region.top,
                ev.scrolling_region.bottom,
                sc.scroll_region.left,
                sc.scroll_region.right,
            );

            // Render metadata.
            var md_it = ev.metadata.iterator();
            while (md_it.next()) |entry| {
                var buf: [256]u8 = undefined;
                const key = std.fmt.bufPrintZ(&buf, "{s}", .{entry.key_ptr.*}) catch "<internal error>";
                cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
                _ = cimgui.c.igTableNextColumn();
                cimgui.c.igText("%s", key.ptr);
                _ = cimgui.c.igTableNextColumn();
                cimgui.c.igText("%s", entry.value_ptr.ptr);
            }

            // Scroll to selected if needed.
            if (self.need_scroll_to_selected and self.is_keyboard_selection) {
                cimgui.c.igSetScrollHereY(0.5);
                self.need_scroll_to_selected = false;
            }
        }
    }
    // Table end.
}
```