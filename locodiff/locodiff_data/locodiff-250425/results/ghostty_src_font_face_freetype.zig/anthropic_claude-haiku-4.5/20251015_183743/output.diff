
index 94dc6911d..82a277939 100644
--- a/ghostty_src_font_face_freetype.zig_expectedoutput.txt (expected):tmp/tmpy6f563_y_expected.txt	
+++ b/ghostty_src_font_face_freetype.zig_extracted.txt (actual):tmp/tmpy150anwa_actual.txt	
@@ -367,7 +367,10 @@ pub const Face = struct {
         // If our atlas format doesn't match, look for conversions if possible.
         const bitmap_converted = if (format == null or atlas.format != format.?) blk: {
             const func = convert.map[bitmap_ft.pixel_mode].get(atlas.format) orelse {
-                log.warn("glyph={} pixel mode={}", .{ glyph_index, bitmap_ft.pixel_mode });
+                log.debug("converting from pixel_mode={} to atlas_format={}", .{
+                    bitmap_ft.pixel_mode,
+                    atlas.format,
+                });
                 return error.UnsupportedPixelMode;
             };
 
@@ -458,7 +461,7 @@ pub const Face = struct {
         // If we resized our bitmap, we need to recalculate some metrics that
         // we use such as the top/left offsets. These need to be scaled by the
         // same ratio as the resize.
-        const glyph_metrics = if (bitmap_resized) |bm| metrics: {
+        const glyph_metrics = if (bitmap_resized) |bm| metrics_: {
             // Our ratio for the resize
             const ratio = ratio: {
                 const new: f64 = @floatFromInt(bm.rows);
@@ -469,7 +472,7 @@ pub const Face = struct {
             var copy = glyph.*;
             copy.bitmap_top = @as(c_int, @intFromFloat(@round(@as(f64, @floatFromInt(copy.bitmap_top)) * ratio)));
             copy.bitmap_left = @as(c_int, @intFromFloat(@round(@as(f64, @floatFromInt(copy.bitmap_left)) * ratio)));
-            break :metrics copy;
+            break :metrics_ copy;
         } else glyph.*;
 
         // Allocate our texture atlas region
@@ -544,7 +547,7 @@ pub const Face = struct {
             // baseline calculation. The baseline calculation is so that everything
             // is properly centered when we render it out into a monospace grid.
             // Note: we add here because our X/Y is actually reversed, adding goes UP.
-            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intCast(metrics.cell_baseline));
+            break :offset_y glyph_metrics.bitmap_top + @as(c_int, @intFromFloat(metrics.cell_baseline));
         };
 
         const offset_x: i32 = offset_x: {
@@ -582,15 +585,6 @@ pub const Face = struct {
         };
     }
 
-    /// Convert 16.6 pixel format to pixels based on the scale factor of the
-    /// current font size.
-    fn unitsToPxY(self: Face, units: i32) i32 {
-        return @intCast(freetype.mulFix(
-            units,
-            @intCast(self.face.handle.*.size.*.metrics.y_scale),
-        ) >> 6);
-    }
-
     /// Convert 26.6 pixel format to f32
     fn f26dot6ToFloat(v: freetype.c.FT_F26Dot6) f32 {
         return @floatFromInt(v >> 6);
