/* eslint-disable react-hooks/rules-of-hooks */
import {
	BaseBoxShapeUtil,
	Box,
	Editor,
	Ellipse2d,
	Geometry2d,
	Group2d,
	HALF_PI,
	HTMLContainer,
	HandleSnapGeometry,
	PI2,
	Polygon2d,
	Polyline2d,
	Stadium2d,
	SvgExportContext,
	TFontFace,
	TLGeoShape,
	TLGeoShapeProps,
	TLResizeInfo,
	TLShapeUtilCanvasSvgDef,
	Vec,
	exhaustiveSwitchError,
	geoShapeMigrations,
	geoShapeProps,
	getDefaultColorTheme,
	getPolygonVertices,
	lerp,
	useValue,
} from '@tldraw/editor';
import { FastPath, isEmptyRichText, renderHtmlFromRichTextForMeasurement, renderPlaintextFromRichText } from '../../utils/text/richText';
import { HyperlinkButton } from '../shared/HyperlinkButton';
import { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel';
import {
	FONT_FAMILIES,
	LABEL_FONT_SIZES,
	LINE_HEIGHT,
	TEXT_PROPS,
} from '../shared/default-shape-constants';
import { getFillDefForCanvas, getFillDefForExport, getFontDefForExport } from '../shared/defaultStyleDefs';
import { useDefaultColorTheme } from '../shared/useDefaultColorTheme';
import { useIsReadyForEditing } from '../shared/useEditablePlainText';
import { GeoShapeBody } from './components/GeoShapeBody';
import {
	cloudOutline,
	getCloudPath,
	getEllipseDrawIndicatorPath,
	getHeartPath,
	getHeartParts,
	getRoundedInkyPolygonPath,
	getRoundedPolygonPoints,
} from './geo-shape-helpers';
import { getLines } from './getLines';

const MIN_SIZE_WITH_LABEL = 17 * 3;

/** @public */
export class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
	static override type = 'geo' as const;
	static override props = geoShapeProps;
	static override migrations = geoShapeMigrations;

	override canEdit() {
		return true;
	}

	override getDefaultProps(): TLGeoShape['props'] {
		return {
			w: 100,
			h: 100,
			geo: 'rectangle',
			color: 'black',
			labelColor: 'black',
			fill: 'none',
			dash: 'draw',
			size: 'm',
			font: 'draw',
			alignment: 'mixed',
			verticalAlignment: 'middle',
			growY: 0,
			url: '',
			scale: 1,
			// Empty rich text will be stored as an empty array of ops
			richText: { type: 'doc', content: [] },
		};
	}

	// Geometry ------------------------------------------------------------------

	override getGeometry(shape: TLGeoShape) {
		const w = Math.max(1, shape.props.w);
		const h = Math.max(1, shape.props.h + shape.props.growY);
		const cx = w / 2;
		const cy = h / 2;
		const isFilled = shape.props.fill !== 'none';
		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;

		let body: Geometry2d;

		switch (shape.props.geo) {
			case 'cloud': {
				body = new Polygon2d({
					points: cloudOutline(
						w,
						h,
						shape.id,
						shape.props.size,
						shape.props.scale
					),
					isFilled,
				});
				break;
			}
			case 'ellipse': {
				body = new Ellipse2d({
					width: w,
					height: h,
					isFilled,
				});
				break;
			}
			case 'heart': {
				const parts = getHeartParts(w, h);
				const points = parts.reduce((acc, part) => {
					acc.push(...part.vertices);
					return acc;
				}, [] as Vec[]);
				body = new Polygon2d({ points, isFilled });
				break;
			}
			default: {
				// default polygon/shape logic
			}
		}

		const labelSize = getLabelSize(this.editor, shape);
		const minWidth = Math.min(100, w / 2);
		const minHeight = Math.min(
			LABEL_FONT_SIZES[shape.props.size] * shape.props.scale * TEXT_PROPS.lineHeight +
				LABEL_PADDING * 2,
			h / 2
		);
		const labelWidth = Math.min(
			w,
			Math.max(
				labelSize.w,
				Math.min(minWidth, Math.max(1, w - 8))
			)
		);
		const labelHeight = Math.min(
			h,
			Math.max(
				labelSize.h,
				Math.min(minHeight, Math.max(1, w - 8))
			)
		);

		const lines = getLines(shape.props, strokeWidth);
		const edges = lines ? lines.map(line => new Polyline2d({ points: line })) : [];

		return new Group2d({
			children: [
				body,
				new Rectangle2d({
					x:
						shape.props.alignment === 'start'
							? 0
							: shape.props.alignment === 'end'
							? w - labelWidth
							: (w - labelWidth) / 2,
					y:
						shape.props.verticalAlignment === 'start'
							? 0
							: props.verticalAlignment === 'end'
							? h - labelHeight
							: (h - labelHeight) / 2,
					width: labelWidth,
					height: labelHeight,
					isFilled: true,
					isLabel: true,
				}),
				...edges,
			],
			isSnappable: false,
		});
	}

	override getHandleSnapGeometry(shape: TLGeoShape): HandleSnapGeometry {
		const geometry = this.getGeometry(shape);
		const outline = geometry.children[0];
		switch (shape.props.geo) {
			case 'arrow-down':
			case 'arrow-left':
			case 'arrow-right':
			case 'arrow-up':
			case 'check-box':
			case 'diamond':
			case 'hexagon':
			case 'octagon':
			case 'pentagon':
			case 'rectangle':
			case 'rhombus':
			case 'rhombus-2':
			case 'star':
			case 'trapezoid':
			case 'triangle':
			case 'x-box':
				return { outline, points: [...outline.getVertices(), geometry.bounds.center] };
			case 'cloud':
			case 'ellipse':
			case 'heart':
			case 'oval':
				return { outline, points: [geometry.bounds.center] };
			default:
				exhaustiveSwitchError(shape.props.geo);
		}
	}

	override getText(shape: TLGeoShape) {
		return renderPlaintextFromRichText(this.editor, shape.props.richText);
	}

	override getFontFaces(shape: TLGeoShape): TLFontFace[] {
		return getFontsFromRichText(this.editor, shape.props.richText, {
			family: `tldraw_${shape.props.font}`,
			weight: 'normal',
			style: 'normal',
		});
	}

	component(shape: TLGeoShape) {
		const { id, type, props } = shape;
		const { fill, font, align, verticalAlign, size, richText } = props;
		const theme = useDefaultColorTheme();
		const { editor } = this;
		const isOnlySelected = useValue(
			'isGeoOnlySelected',
			() => shape.id === editor.getOnlySelectedShapeId(),
			[editor]
		);
		const isReadyForEditing = useIsReadyForEditing(editor, shape.id);
		const isEmpty = isEmptyRichText(richText);
		const showHtmlContainer = isReadyForEditing || !isEmpty;
		const isForceSolid = useValue('force solid', () => editor.getZoomLevel() < 0.2, [
			editor,
		]);

		return (
			<>
				<SVGContainer>
					<GeoShapeBody shape={shape} shouldScale={true} forceSolid={isForceSolid} />
				</SVGContainer>
				{showHtmlContainer && (
					<HTMLContainer
						style={{
							overflow: 'hidden',
							width: shape.props.w,
							height: shape.props.h + props.growY,
						}}
					>
						<RichTextLabel
							shapeId={id}
							type={type}
							font={font}
							alignment={align}
							verticalAlignment={verticalAlign}
							richText={richText}
							isSelected={isOnlySelected}
							labelColor={theme[props.labelColor].solid}
							wrap
						/>
						{shape.props.url && <HyperlinkButton url={shape.props.url} />}
					</HTMLContainer>
				)}
			</>
		);
	}

	override toSvg(shape: TLGeoShape, ctx: SvgExportContext) {
		// Render at base scale (1) for export
		const exportShape = {
			...shape,
			props: {
				...shape.props,
				w: shape.props.w / shape.props.scale,
				h: shape.props.h / shape.props.scale,
			},
		};
		const { props } = exportShape;
		ctx.addExportDef(getFillDefForExport(props.fill));
		ctx.addExportDef(getFontDefForExport(props.font));

		const bounds = new Box(0, 0, props.w, props.h + props.growY);
		const geometry = this.getGeometry(exportShape);
		const body = geometry.getSvgPathData(true);

		const textEl = !isEmptyRichText(props.richText) ? (
			<RichTextSVG
				fontSize={LABEL_FONT_SIZES[props.size]}
				font={props.font}
				alignment={props.align}
				verticalAlignment={props.verticalAlign}
				richText={props.richText}
				labelColor={ctx.theme[props.labelColor].solid}
				bounds={bounds}
				padding={LABEL_PADDING}
			/>
		) : null;

		return (
			<>
				<path d={body} />
				{textEl}
			</>
		);
	}

	// Interpolation ---------------------------------------------------------

	override getInterpolatedProps(
		startShape: TLGeoShape,
		endShape: TLGeoShape,
		t: number
	): TLGeoShapeProps {
		return {
			...(t > 0.5 ? endShape.props : startShape.props),
			w: lerp(startShape.props.w, endShape.props.w, t),
			h: lerp(startShape.props.h, endShape.props.h, t),
			scale: lerp(startShape.props.scale, endShape.props.scale, t),
		};
	}

	// Resize ------------------------------------------------------------------

	override onResize(
		shape: TLGeoShape,
		{ handle, newPoint, scaleX, scaleY, initialShape }
	) {
		const unscaledInitialW = initialShape.props.w / initialShape.props.scale;
		const unscaledInitialH = initialShape.props.h / initialShape.props.scale;
		const unscaledGrowY = initialShape.props.growY / initialShape.props.scale;

		let unscaledW = unscaledInitialW * scaleX;
		let unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY;
		let overShrinkX = 0;
		let overShrinkY = 0;

		if (shape.props.text && renderPlaintextFromRichText(this.editor, shape.props.richText)) {
			const min = MIN_SIZE_WITH_LABEL;
			let newW = Math.max(Math.abs(unscaledW), min);
			let newH = Math.max(Math.abs(unscaledH), min);
			if (newW < min && newH === min) newW = min;
			if (newW === min && newH < min) newH = min;

			const labelSize = getUnscaledLabelSize(this.editor, {
				...shape,
				props: {
					...shape.props,
					w: newW * shape.props.scale,
					h: newH * shape.props.scale,
				},
			});

			const nextW = Math.max(Math.abs(unscaledW), labelSize.w) * Math.sign(unscaledW);
			const nextH = Math.max(Math.abs(unscaledH), labelSize.h) * Math.sign(unscaledH);
			overShrinkX = Math.abs(nextW) - Math.abs(unscaledW);
			overShrinkY = Math.abs(nextH) - Math.abs(unscaledH);

			unscaledW = nextW;
			unscaledH = nextH;
		}

		const scaledW = unscaledW * shape.props.scale;
		const scaledH = unscaledH * shape.props.scale;

		const offset = new Vec(0, 0);
		if (scaleX < 0) offset.x += scaledW;
		if (handle === 'left' || handle === 'top_left' || handle === 'bottom_left')
			offset.x += scaleX < 0 ? -overShrinkX : overShrinkX;

		if (scaleY < 0) offset.y += scaledH;
		if (handle === 'top' || handle === 'top_left' || handle === 'top_right')
			offset.y += scaleY < 0 ? -overShrinkY : overShrinkY;

		const { x, y } = offset.rot(shape.rotation).add(newPoint);

		return {
			x,
			y,
			props: {
				w: Math.max(Math.abs(scaledW), 1),
				h: Math.max(Math.abs(scaledH), 1),
				growY: 0,
			},
		};
	}

	// Creation --------------------------------------------------------------

	override onBeforeCreate(shape: TLGeoShape) {
		if (isEmptyRichText(shape.props.richText)) {
			if (shape.props.growY) {
				return {
					...shape,
					props: {
						...shape.props,
						growY: 0,
					},
				};
			}
			return;
		}
		const prevHeight = shape.props.h / shape.props.scale;
		const nextHeight = getUnscaledLabelSize(this.editor, shape).h;
		const growY = nextHeight > prevHeight ? nextHeight - prevHeight : 0;
		if (growY !== 0) {
			return {
				...shape,
				props: { ...shape.props, growY: growY * shape.props.scale },
			};
		}
	}
```

*(The file continues with onBeforeUpdate, onDoubleClick, etc. â€“ all other methods remain unchanged from the previous version and are omitted for brevity.)*