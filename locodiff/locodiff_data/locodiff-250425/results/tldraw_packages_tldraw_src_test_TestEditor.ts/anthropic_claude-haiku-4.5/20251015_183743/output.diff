
index c20a7cb5a..1f4f9b05a 100644
--- a/tldraw_packages_tldraw_src_test_TestEditor.ts_expectedoutput.txt (expected):tmp/tmp5vpnrzgf_expected.txt	
+++ b/tldraw_packages_tldraw_src_test_TestEditor.ts_extracted.txt (actual):tmp/tmpxxwbe9ar_actual.txt	
@@ -361,7 +361,7 @@ export class TestEditor extends Editor {
 		y = this.inputs.currentScreenPoint.y,
 		options?: Partial<TLPointerEventInfo> | TLShapeId,
 		modifiers?: EventModifiers
-	) {
+	): TLPointerEventInfo {
 		if (typeof options === 'string') {
 			options = { target: 'shape', shape: this.getShape(options) }
 		} else if (options === undefined) {
@@ -564,16 +564,6 @@ export class TestEditor extends Editor {
 		return this
 	}
 
-	pan(offset: VecLike): this {
-		const { isLocked, panSpeed } = this.getCameraOptions()
-		if (isLocked) return this
-		const { x: cx, y: cy, z: cz } = this.getCamera()
-		this.setCamera(new Vec(cx + (offset.x * panSpeed) / cz, cy + (offset.y * panSpeed) / cz, cz), {
-			immediate: true,
-		})
-		return this
-	}
-
 	pinchStart(
 		x = this.inputs.currentScreenPoint.x,
 		y = this.inputs.currentScreenPoint.y,
@@ -618,7 +608,7 @@ export class TestEditor extends Editor {
 			...options,
 			point: { x, y, z },
 			delta: { x: dx, y: dy, z: dz },
-		})
+		}).forceTick()
 		return this
 	}
 
@@ -665,7 +655,11 @@ export class TestEditor extends Editor {
 			.clone()
 			.rotWith(this.getSelectionRotatedPageBounds()!.point, this.getSelectionRotation())
 
-		const targetHandlePoint = Vec.RotWith(handlePoint, this.getSelectionPageCenter()!, angleRadians)
+		const targetHandlePoint = Vec.RotWith(
+			handlePoint,
+			this.getSelectionPageCenter()!,
+			angleRadians
+		)
 
 		this.pointerDown(handlePoint.x, handlePoint.y, { target: 'selection', handle })
 		this.pointerMove(targetHandlePoint.x, targetHandlePoint.y, { shiftKey })
@@ -741,6 +735,16 @@ export class TestEditor extends Editor {
 		return this
 	}
 
+	pan(offset: VecLike): this {
+		const { isLocked, panSpeed } = this.getCameraOptions()
+		if (isLocked) return this
+		const { x: cx, y: cy, z: cz } = this.getCamera()
+		this.setCamera(new Vec(cx + (offset.x * panSpeed) / cz, cy + (offset.y * panSpeed) / cz, cz), {
+			immediate: true,
+		})
+		return this
+	}
+
 	createShapesFromJsx(
 		shapesJsx: React.JSX.Element | React.JSX.Element[]
 	): Record<string, TLShapeId> {
