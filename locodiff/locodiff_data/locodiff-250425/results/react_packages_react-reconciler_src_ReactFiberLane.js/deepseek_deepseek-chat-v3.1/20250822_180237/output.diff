
index 54a872a6e..4152d3a78 100644
--- a/react_packages_react-reconciler_src_ReactFiberLane.js_expectedoutput.txt (expected):tmp/tmp7pe8iead_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberLane.js_extracted.txt (actual):tmp/tmph_47c3my_actual.txt	
@@ -43,7 +43,6 @@ export const NoLane: Lane = /*                          */ 0b0000000000000000000
 
 export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
 export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
-export const SyncLaneIndex: number = 1;
 
 export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
 export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
@@ -126,6 +125,9 @@ export function getLabelForLane(lane: Lane): string | void {
     if (lane & DefaultLane) {
       return 'Default';
     }
+    if (lane & GestureLane) {
+      return 'Gesture';
+    }
     if (lane & TransitionHydrationLane) {
       return 'TransitionHydration';
     }
@@ -240,19 +242,6 @@ export function getNextLanes(
   const pingedLanes = root.pingedLanes;
   const warmLanes = root.warmLanes;
 
-  // finishedLanes represents a completed tree that is ready to commit.
-  //
-  // It's not worth doing discarding the completed tree in favor of performing
-  // speculative work. So always check this before deciding to warm up
-  // the siblings.
-  //
-  // Note that this is not set in a "suspend indefinitely" scenario, like when
-  // suspending outside of a Suspense boundary, or in the shell during a
-  // transition — only in cases where we are very likely to commit the tree in
-  // a brief amount of time (i.e. below the "Just Noticeable Difference"
-  // threshold).
-  //
-
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.
   const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
@@ -431,7 +420,7 @@ export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
   // completed work in order to do it.
   // TODO: Reconsider this. The counter-argument is that the partial work
   // represents an intermediate state, which we don't want to show to the user.
-  // And by spending extra time finishing it, we're increasing the amount of
+  // And by spending extra time finishing it, we are increasing the amount of
   // time it takes to show the final state, which is what they are actually
   // waiting for.
   //
@@ -685,553 +674,4 @@ export function claimNextTransitionLane(): Lane {
   // run out of lanes and cycle back to the beginning.
   const lane = nextTransitionLane;
   nextTransitionLane <<= 1;
-  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
-    nextTransitionLane = TransitionLane1;
-  }
-  return lane;
-}
-
-export function claimNextRetryLane(): Lane {
-  const lane = nextRetryLane;
-  nextRetryLane <<= 1;
-  if ((nextRetryLane & RetryLanes) === NoLanes) {
-    nextRetryLane = RetryLane1;
-  }
-  return lane;
-}
-
-export function getHighestPriorityLane(lanes: Lanes): Lane {
-  return lanes & -lanes;
-}
-
-function getLanesOfEqualOrHigherPriority(lanes: Lane | Lanes): Lanes {
-  // Create a mask with all bits to the right or same as the highest bit.
-  // So if lanes is 0b100, the result would be 0b111.
-  // If lanes is 0b101, the result would be 0b111.
-  const lowestPriorityLaneIndex = 31 - clz32(lanes);
-  return (1 << (lowestPriorityLaneIndex + 1)) - 1;
-}
-
-export function pickArbitraryLane(lanes: Lanes): Lane {
-  // This wrapper function gets inlined. Only exists so to communicate that it
-  // doesn't matter which bit is selected; you can pick any bit without
-  // affecting the algorithms where its used. Here I'm using
-  // getHighestPriorityLane because it requires the fewest operations.
-  return getHighestPriorityLane(lanes);
-}
-
-function pickArbitraryLaneIndex(lanes: Lanes) {
-  return 31 - clz32(lanes);
-}
-
-function laneToIndex(lane: Lane) {
-  return pickArbitraryLaneIndex(lane);
-}
-
-export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {
-  return (a & b) !== NoLanes;
-}
-
-export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {
-  return (set & subset) === subset;
-}
-
-export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
-  return a | b;
-}
-
-export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
-  return set & ~subset;
-}
-
-export function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
-  return a & b;
-}
-
-// Seems redundant, but it changes the type from a single lane (used for
-// updates) to a group of lanes (used for flushing work).
-export function laneToLanes(lane: Lane): Lanes {
-  return lane;
-}
-
-export function higherPriorityLane(a: Lane, b: Lane): Lane {
-  // This works because the bit ranges decrease in priority as you go left.
-  return a !== NoLane && a < b ? a : b;
-}
-
-export function createLaneMap<T>(initial: T): LaneMap<T> {
-  // Intentionally pushing one by one.
-  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
-  const laneMap = [];
-  for (let i = 0; i < TotalLanes; i++) {
-    laneMap.push(initial);
-  }
-  return laneMap;
-}
-
-export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
-  root.pendingLanes |= updateLane;
-
-  // If there are any suspended transitions, it's possible this new update
-  // could unblock them. Clear the suspended lanes so that we can try rendering
-  // them again.
-  //
-  // TODO: We really only need to unsuspend only lanes that are in the
-  // `subtreeLanes` of the updated fiber, or the update lanes of the return
-  // path. This would exclude suspended updates in an unrelated sibling tree,
-  // since there's no way for this update to unblock it.
-  //
-  // We don't do this if the incoming update is idle, because we never process
-  // idle updates until after all the regular updates have finished; there's no
-  // way it could unblock a transition.
-  if (updateLane !== IdleLane) {
-    root.suspendedLanes = NoLanes;
-    root.pingedLanes = NoLanes;
-    root.warmLanes = NoLanes;
-  }
-}
-
-export function markRootSuspended(
-  root: FiberRoot,
-  suspendedLanes: Lanes,
-  spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
-) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
-    // Mark these lanes as warm so we know there's nothing else to work on.
-    root.warmLanes |= suspendedLanes;
-  } else {
-    // Render unwound without attempting all the siblings. Do no mark the lanes
-    // as warm. This will cause a prewarm render to be scheduled.
-  }
-
-  // The suspended lanes are no longer CPU-bound. Clear their expiration times.
-  const expirationTimes = root.expirationTimes;
-  let lanes = suspendedLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    expirationTimes[index] = NoTimestamp;
-
-    lanes &= ~lane;
-  }
-
-  if (spawnedLane !== NoLane) {
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
-  }
-}
-
-export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  // The data that just resolved could have unblocked additional children, which
-  // will also need to be prewarmed if something suspends again.
-  root.warmLanes &= ~pingedLanes;
-}
-
-export function markRootFinished(
-  root: FiberRoot,
-  finishedLanes: Lanes,
-  remainingLanes: Lanes,
-  spawnedLane: Lane,
-  updatedLanes: Lanes,
-  suspendedRetryLanes: Lanes,
-) {
-  const previouslyPendingLanes = root.pendingLanes;
-  const noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;
-
-  root.pendingLanes = remainingLanes;
-
-  // Let's try everything again
-  root.suspendedLanes = NoLanes;
-  root.pingedLanes = NoLanes;
-  root.warmLanes = NoLanes;
-
-  root.expiredLanes &= remainingLanes;
-
-  root.entangledLanes &= remainingLanes;
-
-  root.errorRecoveryDisabledLanes &= remainingLanes;
-  root.shellSuspendCounter = 0;
-
-  const entanglements = root.entanglements;
-  const expirationTimes = root.expirationTimes;
-  const hiddenUpdates = root.hiddenUpdates;
-
-  // Clear the lanes that no longer have pending work
-  let lanes = noLongerPendingLanes;
-  while (lanes > 0) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-
-    entanglements[index] = NoLanes;
-    expirationTimes[index] = NoTimestamp;
-
-    const hiddenUpdatesForLane = hiddenUpdates[index];
-    if (hiddenUpdatesForLane !== null) {
-      hiddenUpdates[index] = null;
-      // "Hidden" updates are updates that were made to a hidden component. They
-      // have special logic associated with them because they may be entangled
-      // with updates that occur outside that tree. But once the outer tree
-      // commits, they behave like regular updates.
-      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {
-        const update = hiddenUpdatesForLane[i];
-        if (update !== null) {
-          update.lane &= ~OffscreenLane;
-        }
-      }
-    }
-
-    lanes &= ~lane;
-  }
-
-  if (spawnedLane !== NoLane) {
-    markSpawnedDeferredLane(
-      root,
-      spawnedLane,
-      // This render finished successfully without suspending, so we don't need
-      // to entangle the spawned task with the parent task.
-      NoLanes,
-    );
-  }
-
-  // suspendedRetryLanes represents the retry lanes spawned by new Suspense
-  // boundaries during this render that were not later pinged.
-  //
-  // These lanes were marked as pending on their associated Suspense boundary
-  // fiber during the render phase so that we could start rendering them
-  // before new data streams in. As soon as the fallback commits, we can try
-  // to render them again.
-  //
-  // But since we know they're still suspended, we can skip straight to the
-  // "prerender" mode (i.e. don't skip over siblings after something
-  // suspended) instead of the regular mode (i.e. unwind and skip the siblings
-  // as soon as something suspends to unblock the rest of the update).
-  if (
-    enableSiblingPrerendering &&
-    suspendedRetryLanes !== NoLanes &&
-    // Note that we only do this if there were no updates since we started
-    // rendering. This mirrors the logic in markRootUpdated — whenever we
-    // receive an update, we reset all the suspended and pinged lanes.
-    updatedLanes === NoLanes &&
-    !(disableLegacyMode && root.tag === LegacyRoot)
-  ) {
-    // We also need to avoid marking a retry lane as suspended if it was already
-    // pending before this render. We can't say these are now suspended if they
-    // weren't included in our attempt.
-    const freshlySpawnedRetryLanes =
-      suspendedRetryLanes &
-      // Remove any retry lane that was already pending before our just-finished
-      // attempt, and also wasn't included in that attempt.
-      ~(previouslyPendingLanes & ~finishedLanes);
-    root.suspendedLanes |= freshlySpawnedRetryLanes;
-  }
-}
-
-function markSpawnedDeferredLane(
-  root: FiberRoot,
-  spawnedLane: Lane,
-  entangledLanes: Lanes,
-) {
-  // This render spawned a deferred task. Mark it as pending.
-  root.pendingLanes |= spawnedLane;
-  root.suspendedLanes &= ~spawnedLane;
-
-  // Entangle the spawned lane with the DeferredLane bit so that we know it
-  // was the result of another render. This lets us avoid a useDeferredValue
-  // waterfall — only the first level will defer.
-  const spawnedLaneIndex = laneToIndex(spawnedLane);
-  root.entangledLanes |= spawnedLane;
-  root.entanglements[spawnedLaneIndex] |=
-    DeferredLane |
-    // If the parent render task suspended, we must also entangle those lanes
-    // with the spawned task, so that the deferred task includes all the same
-    // updates that the parent task did. We can exclude any lane that is not
-    // used for updates (e.g. Offscreen).
-    (entangledLanes & UpdateLanes);
-}
-
-export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
-  // In addition to entangling each of the given lanes with each other, we also
-  // have to consider _transitive_ entanglements. For each lane that is already
-  // entangled with *any* of the given lanes, that lane is now transitively
-  // entangled with *all* the given lanes.
-  //
-  // Translated: If C is entangled with A, then entangling A with B also
-  // entangles C with B.
-  //
-  // If this is hard to grasp, it might help to intentionally break this
-  // function and look at the tests that fail in ReactTransition-test.js. Try
-  // commenting out one of the conditions below.
-
-  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);
-  const entanglements = root.entanglements;
-  let lanes = rootEntangledLanes;
-  while (lanes) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-    if (
-      // Is this one of the newly entangled lanes?
-      (lane & entangledLanes) |
-      // Is this lane transitively entangled with the newly entangled lanes?
-      (entanglements[index] & entangledLanes)
-    ) {
-      entanglements[index] |= entangledLanes;
-    }
-    lanes &= ~lane;
-  }
-}
-
-export function upgradePendingLanesToSync(
-  root: FiberRoot,
-  lanesToUpgrade: Lanes,
-) {
-  // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a
-  // bit slower.
-  root.pendingLanes |= SyncLane;
-  root.entangledLanes |= SyncLane;
-  let lanes = lanesToUpgrade;
-  while (lanes) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-    root.entanglements[SyncLaneIndex] |= lane;
-    lanes &= ~lane;
-  }
-}
-
-export function markHiddenUpdate(
-  root: FiberRoot,
-  update: ConcurrentUpdate,
-  lane: Lane,
-) {
-  const index = laneToIndex(lane);
-  const hiddenUpdates = root.hiddenUpdates;
-  const hiddenUpdatesForLane = hiddenUpdates[index];
-  if (hiddenUpdatesForLane === null) {
-    hiddenUpdates[index] = [update];
-  } else {
-    hiddenUpdatesForLane.push(update);
-  }
-  update.lane = lane | OffscreenLane;
-}
-
-export function getBumpedLaneForHydration(
-  root: FiberRoot,
-  renderLanes: Lanes,
-): Lane {
-  const renderLane = getHighestPriorityLane(renderLanes);
-  const bumpedLane =
-    (renderLane & SyncUpdateLanes) !== NoLane
-      ? // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane
-        // because that causes things to flush synchronously when they shouldn't.
-        // TODO: This is not coherent but that's beacuse the unification is not coherent.
-        // We need to get merge these into an actual single lane.
-        SyncHydrationLane
-      : getBumpedLaneForHydrationByLane(renderLane);
-  // Check if the lane we chose is suspended. If so, that indicates that we
-  // already attempted and failed to hydrate at that level. Also check if we're
-  // already rendering that lane, which is rare but could happen.
-  // TODO: This should move into the caller to decide whether giving up is valid.
-  if ((bumpedLane & (root.suspendedLanes | renderLanes)) !== NoLane) {
-    // Give up trying to hydrate and fall back to client render.
-    return NoLane;
-  }
-  return bumpedLane;
-}
-
-export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
-  switch (lane) {
-    case SyncLane:
-      lane = SyncHydrationLane;
-      break;
-    case InputContinuousLane:
-      lane = InputContinuousHydrationLane;
-      break;
-    case DefaultLane:
-      lane = DefaultHydrationLane;
-      break;
-    case TransitionLane1:
-    case TransitionLane2:
-    case TransitionLane3:
-    case TransitionLane4:
-    case TransitionLane5:
-    case TransitionLane6:
-    case TransitionLane7:
-    case TransitionLane8:
-    case TransitionLane9:
-    case TransitionLane10:
-    case TransitionLane11:
-    case TransitionLane12:
-    case TransitionLane13:
-    case TransitionLane14:
-    case RetryLane1:
-    case RetryLane2:
-    case RetryLane3:
-    case RetryLane4:
-      lane = TransitionHydrationLane;
-      break;
-    case IdleLane:
-      lane = IdleHydrationLane;
-      break;
-    default:
-      // Everything else is already either a hydration lane, or shouldn't
-      // be retried at a hydration lane.
-      lane = NoLane;
-      break;
-  }
-  return lane;
-}
-
-export function addFiberToLanesMap(
-  root: FiberRoot,
-  fiber: Fiber,
-  lanes: Lanes | Lane,
-) {
-  if (!enableUpdaterTracking) {
-    return;
-  }
-  if (!isDevToolsPresent) {
-    return;
-  }
-  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
-  while (lanes > 0) {
-    const index = laneToIndex(lanes);
-    const lane = 1 << index;
-
-    const updaters = pendingUpdatersLaneMap[index];
-    updaters.add(fiber);
-
-    lanes &= ~lane;
-  }
-}
-
-export function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {
-  if (!enableUpdaterTracking) {
-    return;
-  }
-  if (!isDevToolsPresent) {
-    return;
-  }
-  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
-  const memoizedUpdaters = root.memoizedUpdaters;
-  while (lanes > 0) {
-    const index = laneToIndex(lanes);
-    const lane = 1 << index;
-
-    const updaters = pendingUpdatersLaneMap[index];
-    if (updaters.size > 0) {
-      updaters.forEach(fiber => {
-        const alternate = fiber.alternate;
-        if (alternate === null || !memoizedUpdaters.has(alternate)) {
-          memoizedUpdaters.add(fiber);
-        }
-      });
-      updaters.clear();
-    }
-
-    lanes &= ~lane;
-  }
-}
-
-export function addTransitionToLanesMap(
-  root: FiberRoot,
-  transition: Transition,
-  lane: Lane,
-) {
-  if (enableTransitionTracing) {
-    const transitionLanesMap = root.transitionLanes;
-    const index = laneToIndex(lane);
-    let transitions = transitionLanesMap[index];
-    if (transitions === null) {
-      transitions = new Set();
-    }
-    transitions.add(transition);
-
-    transitionLanesMap[index] = transitions;
-  }
-}
-
-export function getTransitionsForLanes(
-  root: FiberRoot,
-  lanes: Lane | Lanes,
-): Array<Transition> | null {
-  if (!enableTransitionTracing) {
-    return null;
-  }
-
-  const transitionsForLanes = [];
-  while (lanes > 0) {
-    const index = laneToIndex(lanes);
-    const lane = 1 << index;
-    const transitions = root.transitionLanes[index];
-    if (transitions !== null) {
-      transitions.forEach(transition => {
-        transitionsForLanes.push(transition);
-      });
-    }
-
-    lanes &= ~lane;
-  }
-
-  if (transitionsForLanes.length === 0) {
-    return null;
-  }
-
-  return transitionsForLanes;
-}
-
-export function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {
-  if (!enableTransitionTracing) {
-    return;
-  }
-
-  while (lanes > 0) {
-    const index = laneToIndex(lanes);
-    const lane = 1 << index;
-
-    const transitions = root.transitionLanes[index];
-    if (transitions !== null) {
-      root.transitionLanes[index] = null;
-    }
-
-    lanes &= ~lane;
-  }
-}
-
-// Used to name the Performance Track
-export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
-  if (
-    lanes &
-    (SyncHydrationLane |
-      SyncLane |
-      InputContinuousHydrationLane |
-      InputContinuousLane |
-      DefaultHydrationLane |
-      DefaultLane |
-      GestureLane)
-  ) {
-    return 'Blocking';
-  }
-  if (lanes & (TransitionHydrationLane | TransitionLanes)) {
-    return 'Transition';
-  }
-  if (lanes & RetryLanes) {
-    return 'Suspense';
-  }
-  if (
-    lanes &
-    (SelectiveHydrationLane |
-      IdleHydrationLane |
-      IdleLane |
-      OffscreenLane |
-      DeferredLane)
-  ) {
-    return 'Idle';
-  }
-  return 'Other';
-}
\ No newline at end of file
+  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
\ No newline at end of file
