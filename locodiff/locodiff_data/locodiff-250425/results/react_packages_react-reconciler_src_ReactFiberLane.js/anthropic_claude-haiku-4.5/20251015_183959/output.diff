
index 54a872a6e..c07991d09 100644
--- a/react_packages_react-reconciler_src_ReactFiberLane.js_expectedoutput.txt (expected):tmp/tmp9__8_7ap_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberLane.js_extracted.txt (actual):tmp/tmp12ccbndh_actual.txt	
@@ -27,7 +27,6 @@ import {
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
   disableLegacyMode,
-  enableSiblingPrerendering,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
@@ -126,6 +125,9 @@ export function getLabelForLane(lane: Lane): string | void {
     if (lane & DefaultLane) {
       return 'Default';
     }
+    if (lane & GestureLane) {
+      return 'Gesture';
+    }
     if (lane & TransitionHydrationLane) {
       return 'TransitionHydration';
     }
@@ -267,13 +269,11 @@ export function getNextLanes(
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -293,13 +293,11 @@ export function getNextLanes(
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = pendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = pendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -338,9 +336,103 @@ export function getNextLanes(
     }
   }
 
+  // When updates are sync by default, we entangle continuous priority updates
+  // and default updates, so they render in the same batch. The only reason
+  // they use separate lanes is because continuous updates should interrupt
+  // transitions, but default updates should not.
+  if ((nextLanes & InputContinuousLane) !== NoLanes) {
+    nextLanes |= pendingLanes & DefaultLane;
+  }
+
+  // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  // TODO: Reconsider this. The counter-argument is that the partial work
+  // represents an intermediate state, which we don't want to show to the user.
+  // And by spending extra time finishing it, we're increasing the amount of
+  // time it takes to show the final state, which is what they are actually
+  // waiting for.
+  //
+  // For those exceptions where entanglement is semantically important,
+  // we should ensure that there is no partial work at the
+  // time we apply the entanglement.
+  const entangledLanes = root.entangledLanes;
+  if (entangledLanes !== NoLanes) {
+    const entanglements = root.entanglements;
+    let lanes = nextLanes & entangledLanes;
+    while (lanes > 0) {
+      const index = pickArbitraryLaneIndex(lanes);
+      const lane = 1 << index;
+
+      nextLanes |= entanglements[index];
+
+      lanes &= ~lane;
+    }
+  }
+
   return nextLanes;
 }
 
+export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
+  let entangledLanes = renderLanes;
+
+  if ((entangledLanes & InputContinuousLane) !== NoLanes) {
+    // When updates are sync by default, we entangle continuous priority updates
+    // and default updates, so they render in the same batch. The only reason
+    // they use separate lanes is because continuous updates should interrupt
+    // transitions, but default updates should not.
+    entangledLanes |= entangledLanes & DefaultLane;
+  }
+
+  // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  // TODO: Reconsider this. The counter-argument is that the partial work
+  // represents an intermediate state, which we don't want to show to the user.
+  // And by spending extra time finishing it, we're increasing the amount of
+  // time it takes to show the final state, which is what they are actually
+  // waiting for.
+  //
+  // For those exceptions where entanglement is semantically important,
+  // we should ensure that there is no partial work at the
+  // time we apply the entanglement.
+  const allEntangledLanes = root.entangledLanes;
+  if (allEntangledLanes !== NoLanes) {
+    const entanglements = root.entanglements;
+    let lanes = entangledLanes & allEntangledLanes;
+    while (lanes > 0) {
+      const index = pickArbitraryLaneIndex(lanes);
+      const lane = 1 << index;
+
+      entangledLanes |= entanglements[index];
+
+      lanes &= ~lane;
+    }
+  }
+
+  return entangledLanes;
+}
+
 export function getNextLanesToFlushSync(
   root: FiberRoot,
   extraLanesToForceSync: Lane | Lanes,
@@ -405,56 +497,6 @@ export function checkIfRootIsPrerendering(
   return (unblockedLanes & renderLanes) === 0;
 }
 
-export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
-  let entangledLanes = renderLanes;
-
-  if ((entangledLanes & InputContinuousLane) !== NoLanes) {
-    // When updates are sync by default, we entangle continuous priority updates
-    // and default updates, so they render in the same batch. The only reason
-    // they use separate lanes is because continuous updates should interrupt
-    // transitions, but default updates should not.
-    entangledLanes |= entangledLanes & DefaultLane;
-  }
-
-  // Check for entangled lanes and add them to the batch.
-  //
-  // A lane is said to be entangled with another when it's not allowed to render
-  // in a batch that does not also include the other lane. Typically we do this
-  // when multiple updates have the same source, and we only want to respond to
-  // the most recent event from that source.
-  //
-  // Note that we apply entanglements *after* checking for partial work above.
-  // This means that if a lane is entangled during an interleaved event while
-  // it's already rendering, we won't interrupt it. This is intentional, since
-  // entanglement is usually "best effort": we'll try our best to render the
-  // lanes in the same batch, but it's not worth throwing out partially
-  // completed work in order to do it.
-  // TODO: Reconsider this. The counter-argument is that the partial work
-  // represents an intermediate state, which we don't want to show to the user.
-  // And by spending extra time finishing it, we're increasing the amount of
-  // time it takes to show the final state, which is what they are actually
-  // waiting for.
-  //
-  // For those exceptions where entanglement is semantically important,
-  // we should ensure that there is no partial work at the
-  // time we apply the entanglement.
-  const allEntangledLanes = root.entangledLanes;
-  if (allEntangledLanes !== NoLanes) {
-    const entanglements = root.entanglements;
-    let lanes = entangledLanes & allEntangledLanes;
-    while (lanes > 0) {
-      const index = pickArbitraryLaneIndex(lanes);
-      const lane = 1 << index;
-
-      entangledLanes |= entanglements[index];
-
-      lanes &= ~lane;
-    }
-  }
-
-  return entangledLanes;
-}
-
 function computeExpirationTime(lane: Lane, currentTime: number) {
   switch (lane) {
     case SyncHydrationLane:
@@ -535,7 +577,6 @@ export function markStarvedLanesAsExpired(
   // Iterate through the pending lanes and check if we've reached their
   // expiration time. If so, we'll assume the update is being starved and mark
   // it as expired to force it to finish.
-  // TODO: We should be able to replace this with upgradePendingLanesToSync
   //
   // We exclude retry lanes because those must always be time sliced, in order
   // to unwrap uncached promises.
@@ -608,8 +649,6 @@ export function includesOnlyRetries(lanes: Lanes): boolean {
   return (lanes & RetryLanes) === lanes;
 }
 export function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {
-  // TODO: Should hydration lanes be included here? This function is only
-  // used in `updateDeferredValueImpl`.
   const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
   return (lanes & UrgentLanes) === NoLanes;
 }
@@ -795,14 +834,12 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
+  didSkipSuspendedSiblings: boolean,
 ) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
+  if (!didSkipSuspendedSiblings) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {
@@ -913,7 +950,6 @@ export function markRootFinished(
   // suspended) instead of the regular mode (i.e. unwind and skip the siblings
   // as soon as something suspends to unblock the rest of the update).
   if (
-    enableSiblingPrerendering &&
     suspendedRetryLanes !== NoLanes &&
     // Note that we only do this if there were no updates since we started
     // rendering. This mirrors the logic in markRootUpdated â€” whenever we
@@ -1055,6 +1091,9 @@ export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
     case DefaultLane:
       lane = DefaultHydrationLane;
       break;
+    case GestureLane:
+      lane = DefaultHydrationLane;
+      break;
     case TransitionLane1:
     case TransitionLane2:
     case TransitionLane3:
