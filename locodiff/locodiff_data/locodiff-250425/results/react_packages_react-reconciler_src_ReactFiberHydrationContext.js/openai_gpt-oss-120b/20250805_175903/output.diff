
index f9932b8c4..dfe80e5a9 100644
--- a/react_packages_react-reconciler_src_ReactFiberHydrationContext.js_expectedoutput.txt (expected):tmp/tmpsxuijm7__expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberHydrationContext.js_extracted.txt (actual):tmp/tmpt1aq8qpp_actual.txt	
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * Copyright (c) Meta, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
@@ -8,6 +8,7 @@
  */
 
 import type {Fiber} from './ReactInternalTypes';
+
 import type {
   Instance,
   TextInstance,
@@ -21,7 +22,16 @@ import type {ActivityState} from './ReactFiberActivityComponent';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {TreeContext} from './ReactFiberTreeContext';
 import type {CapturedValue} from './ReactCapturedValue';
-import type {HydrationDiffNode} from './ReactFiberHydrationDiffs';
+type HydrationDiffNode = {
+  fiber: Fiber,
+  children: Array<HydrationDiffNode>,
+  serverProps: null | {[string]: mixed},
+  serverTail: $ReadOnlyArray<{
+    type: string,
+    key?: mixed,
+  }>,
+  distanceFromLeaf: number,
+};
 
 import {
   HostComponent,
@@ -32,9 +42,15 @@ import {
 } from './ReactWorkTags';
 import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
 
-import {createCapturedValueAtFiber} from './ReactCapturedValue';
+import {
+  createCapturedValueAtFiber,
+  queueRecoverableErrors,
+} from './ReactFiberWorkLoop';
+
+import {
+  createFiberFromDehydratedFragment,
+} from './ReactFiber';
 
-import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
   shouldSetTextContent,
   supportsHydration,
@@ -43,18 +59,21 @@ import {
   getNextHydratableSiblingAfterSingleton,
   getFirstHydratableChild,
   getFirstHydratableChildWithinContainer,
-  getFirstHydratableChildWithinActivityInstance,
-  getFirstHydratableChildWithinSuspenseInstance,
   getFirstHydratableChildWithinSingleton,
+  getFirstHydratableChildWithinSuspenseInstance,
+  getFirstHydratableChildWithinActivityInstance,
   hydrateInstance,
   diffHydratedPropsForDevWarnings,
   describeHydratableInstanceForDevWarnings,
+  getFirstHydratableChildWithinSingleton,
   hydrateTextInstance,
   diffHydratedTextForDevWarnings,
-  hydrateActivityInstance,
   hydrateSuspenseInstance,
-  getNextHydratableInstanceAfterActivityInstance,
+  hydrateActivityInstance,
+  getNextHydratableSibling,
+  getNextHydratableSiblingAfterSingleton,
   getNextHydratableInstanceAfterSuspenseInstance,
+  getNextHydratableInstanceAfterActivityInstance,
   shouldDeleteUnhydratedTailInstances,
   resolveSingletonInstance,
   canHydrateInstance,
@@ -63,86 +82,27 @@ import {
   canHydrateSuspenseInstance,
   canHydrateFormStateMarker,
   isFormStateMarkerMatching,
-  validateHydratableInstance,
-  validateHydratableTextInstance,
 } from './ReactFiberConfig';
+
 import {OffscreenLane} from './ReactFiberLane';
 import {
   getSuspendedTreeContext,
   restoreSuspendedTreeContext,
 } from './ReactFiberTreeContext';
-import {queueRecoverableErrors} from './ReactFiberWorkLoop';
 import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
 import {describeDiff} from './ReactFiberHydrationDiffs';
 import {runWithFiberInDEV} from './ReactCurrentFiber';
 
-// The deepest Fiber on the stack involved in a hydration context.
-// This may have been an insertion or a hydration.
 let hydrationParentFiber: null | Fiber = null;
 let nextHydratableInstance: null | HydratableInstance = null;
 let isHydrating: boolean = false;
 
-// This flag allows for warning supression when we expect there to be mismatches
-// due to earlier mismatches or a suspended fiber.
 let didSuspendOrErrorDEV: boolean = false;
-
-// Hydration differences found that haven't yet been logged.
 let hydrationDiffRootDEV: null | HydrationDiffNode = null;
 
-// Hydration errors that were thrown inside this boundary
 let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
 
-let rootOrSingletonContext = false;
-
-// Builds a common ancestor tree from the root down for collecting diffs.
-function buildHydrationDiffNode(
-  fiber: Fiber,
-  distanceFromLeaf: number,
-): HydrationDiffNode {
-  if (fiber.return === null) {
-    // We're at the root.
-    if (hydrationDiffRootDEV === null) {
-      hydrationDiffRootDEV = {
-        fiber: fiber,
-        children: [],
-        serverProps: undefined,
-        serverTail: [],
-        distanceFromLeaf: distanceFromLeaf,
-      };
-    } else if (hydrationDiffRootDEV.fiber !== fiber) {
-      throw new Error(
-        'Saw multiple hydration diff roots in a pass. This is a bug in React.',
-      );
-    } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {
-      hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;
-    }
-    return hydrationDiffRootDEV;
-  }
-  const siblings = buildHydrationDiffNode(
-    fiber.return,
-    distanceFromLeaf + 1,
-  ).children;
-  // The same node may already exist in the parent. Since we currently always render depth first
-  // and rerender if we suspend or terminate early, if a shared ancestor was added we should still
-  // be inside of that shared ancestor which means it was the last one to be added. If this changes
-  // we may have to scan the whole set.
-  if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {
-    const existing = siblings[siblings.length - 1];
-    if (existing.distanceFromLeaf > distanceFromLeaf) {
-      existing.distanceFromLeaf = distanceFromLeaf;
-    }
-    return existing;
-  }
-  const newNode: HydrationDiffNode = {
-    fiber: fiber,
-    children: [],
-    serverProps: undefined,
-    serverTail: [],
-    distanceFromLeaf: distanceFromLeaf,
-  };
-  siblings.push(newNode);
-  return newNode;
-}
+let rootOrSingletonContext: boolean = false;
 
 function warnIfHydrating() {
   if (__DEV__) {
@@ -156,7 +116,7 @@ function warnIfHydrating() {
 
 export function markDidThrowWhileHydratingDEV() {
   if (__DEV__) {
-    didSuspendOrErrorDEV = true;
+    // dummy, not used in this file.
   }
 }
 
@@ -166,8 +126,9 @@ function enterHydrationState(fiber: Fiber): boolean {
   }
 
   const parentInstance: Container = fiber.stateNode.containerInfo;
-  nextHydratableInstance =
-    getFirstHydratableChildWithinContainer(parentInstance);
+  nextHydratableInstance = getFirstHydratableChildWithinContainer(
+    parentInstance,
+  );
   hydrationParentFiber = fiber;
   isHydrating = true;
   hydrationErrors = null;
@@ -177,16 +138,22 @@ function enterHydrationState(fiber: Fiber): boolean {
   return true;
 }
 
-function reenterHydrationStateFromDehydratedActivityInstance(
+/**
+ * Called by the Suspense component when it knows that it needs to be
+ * re-entered due to a mismatch in the hydration context.
+ *
+ * This re-enters the Hydra state for a Suspense boundary.
+ */
+function reenterHydrationStateFromDehydratedSuspenseInstance(
   fiber: Fiber,
-  activityInstance: ActivityInstance,
+  suspenseInstance: SuspenseInstance,
   treeContext: TreeContext | null,
 ): boolean {
   if (!supportsHydration) {
     return false;
   }
   nextHydratableInstance =
-    getFirstHydratableChildWithinActivityInstance(activityInstance);
+    getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
   hydrationParentFiber = fiber;
   isHydrating = true;
   hydrationErrors = null;
@@ -199,16 +166,22 @@ function reenterHydrationStateFromDehydratedActivityInstance(
   return true;
 }
 
-function reenterHydrationStateFromDehydratedSuspenseInstance(
+/**
+ * Called by an Activity component when it knows that it needs to be
+ * re-entered due to a mismatch in the hydration context.
+ *
+ * This re-enters the Hydra state for an Activity boundary.
+ */
+function reenterHydrationStateFromDehydratedActivityInstance(
   fiber: Fiber,
-  suspenseInstance: SuspenseInstance,
+  activityInstance: ActivityInstance,
   treeContext: TreeContext | null,
 ): boolean {
   if (!supportsHydration) {
     return false;
   }
   nextHydratableInstance =
-    getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
+    getFirstHydratableChildWithinActivityInstance(activityInstance);
   hydrationParentFiber = fiber;
   isHydrating = true;
   hydrationErrors = null;
@@ -221,30 +194,114 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   return true;
 }
 
-function warnNonHydratedInstance(
-  fiber: Fiber,
-  rejectedCandidate: null | HydratableInstance,
+// ---------------------------------------------------------------------------
+// Hydration warning / error handling
+// ---------------------------------------------------------------------------
+
+function warnForDeletedHydratableInstance(
+  parentType: string,
+  child: HydratableInstance,
 ) {
   if (__DEV__) {
-    if (didSuspendOrErrorDEV) {
-      // Inside a boundary that already suspended. We're currently rendering the
-      // siblings of a suspended node. The mismatch may be due to the missing
-      // data, so it's probably a false positive.
-      return;
+    const description = describeHydratableInstanceForDevWarnings(child);
+    if (typeof description === 'string') {
+      console.error(
+        'Did not expect server HTML to contain the text node "%s" in <%s>.',
+        description,
+        parentType,
+      );
+    } else {
+      console.error(
+        'Did not expect server HTML to contain a <%s> in <%s>.',
+        description.type,
+        parentType,
+      );
     }
+  }
+}
 
-    // Add this fiber to the diff tree.
-    const diffNode = buildHydrationDiffNode(fiber, 0);
-    // We use null as a signal that there was no node to match.
-    diffNode.serverProps = null;
-    if (rejectedCandidate !== null) {
-      const description =
-        describeHydratableInstanceForDevWarnings(rejectedCandidate);
-      diffNode.serverTail.push(description);
+function warnForInsertedHydratedElement(parentType: string, tag: string) {
+  if (__DEV__) {
+    console.error(
+      'Expected server HTML to contain a matching <%s> in <%s>.',
+      tag,
+      parentType,
+    );
+  }
+}
+
+function warnForInsertedHydratedText(parentType: string, text: string) {
+  if (__DEV__) {
+    console.error(
+      'Expected server HTML to contain matching text "%s" in <%s>.',
+      text,
+      parentType,
+    );
+  }
+}
+
+export const HydrationMismatchException: mixed = new Error(
+  "Hydration Mismatch Exception: This is not a real error, or otherwise we would hide it from users. If you see this, it's a bug in React.",
+);
+
+function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
+  let diff = '';
+  if (__DEV__) {
+    const diffRoot = hydrationDiffRootDEV;
+    if (diffRoot !== null) {
+      diff = describeDiff(diffRoot);
+      hydrationDiffRootDEV = null;
+    }
+  }
+  const error = new Error(
+    `Hydration failed because the server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n` +
+      '\n' +
+      "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+      "- Variable input such as Date.now() or Math.random() which changes each time.\n" +
+      '- Locale dependent date formatting.\n' +
+      '- External changing data without snapshot.\n' +
+      '- Invalid HTML nesting.\n' +
+      '\n' +
+      'It can also happen if the client has a browser extension that modifies the DOM before React loads.\n' +
+      '\n' +
+      'https://react.dev/link/hydration-mismatch' +
+      diff,
+  );
+  queueHydrationError(createCapturedValueAtFiber(error, fiber));
+  throw HydrationMismatchException;
+}
+
+// ---------------------------------------------------------------------------
+// Claim hydratable instances
+// ---------------------------------------------------------------------------
+
+function claimHydratableSingleton(fiber: Fiber): void {
+  if (supportsSingletons) {
+    if (!isHydrating) {
+      return;
     }
+    const currentRootContainer = getRootHostContainer();
+    const currentHostContext = getHostContext();
+    const instance = (fiber.stateNode = resolveSingletonInstance(
+      fiber.type,
+      fiber.pendingProps,
+      currentRootContainer,
+      currentHostContext,
+      false,
+    ));
+    hydrationParentFiber = fiber;
+    rootOrSingletonContext = true;
+    nextHydratableInstance = getFirstHydratableChildWithinSingleton(
+      fiber.type,
+      instance,
+      nextHydratableInstance,
+    );
   }
 }
 
+/**
+ * Normal case: we are attempting to hydrate a HostComponent.
+ */
 function tryHydrateInstance(
   fiber: Fiber,
   nextInstance: any,
@@ -255,17 +312,15 @@ function tryHydrateInstance(
     nextInstance,
     fiber.type,
     fiber.pendingProps,
-    rootOrSingletonContext,
   );
   if (instance !== null) {
     fiber.stateNode = (instance: Instance);
-
     if (__DEV__) {
       if (!didSuspendOrErrorDEV) {
         const differences = diffHydratedPropsForDevWarnings(
           instance,
           fiber.type,
-          fiber.pendingProps,
+          fiber.memoizedProps,
           hostContext,
         );
         if (differences !== null) {
@@ -274,7 +329,6 @@ function tryHydrateInstance(
         }
       }
     }
-
     hydrationParentFiber = fiber;
     nextHydratableInstance = getFirstHydratableChild(instance);
     rootOrSingletonContext = false;
@@ -283,8 +337,13 @@ function tryHydrateInstance(
   return false;
 }
 
-function tryHydrateText(fiber: Fiber, nextInstance: any) {
-  // fiber is a HostText Fiber
+/**
+ * Normal case: we are attempting to hydrate a HostText.
+ */
+function tryHydrateText(
+  fiber: Fiber,
+  nextInstance: any,
+) {
   const text = fiber.pendingProps;
   const textInstance = canHydrateTextInstance(
     nextInstance,
@@ -294,13 +353,16 @@ function tryHydrateText(fiber: Fiber, nextInstance: any) {
   if (textInstance !== null) {
     fiber.stateNode = (textInstance: TextInstance);
     hydrationParentFiber = fiber;
-    // Text Instances don't have children so there's nothing to hydrate.
+    // Text nodes have no children, so no further hydration.
     nextHydratableInstance = null;
     return true;
   }
   return false;
 }
 
+/**
+ * Normal case: we are attempting to hydrate an Activity.
+ */
 function tryHydrateActivity(
   fiber: Fiber,
   nextInstance: any,
@@ -317,177 +379,117 @@ function tryHydrateActivity(
       retryLane: OffscreenLane,
       hydrationErrors: null,
     };
+
     fiber.memoizedState = activityState;
-    // Store the dehydrated fragment as a child fiber.
-    // This simplifies the code for getHostSibling and deleting nodes,
-    // since it doesn't have to consider all Suspense boundaries and
-    // check if they're dehydrated ones or not.
-    const dehydratedFragment =
-      createFiberFromDehydratedFragment(activityInstance);
+    // We'll deal with the child after the container is re-entered.
+    hydrationParentFiber = fiber;
+    // For Activity, we also store a child fragment fiber.
+    const dehydratedFragment = createFiberFromDehydratedFragment(
+      activityInstance,
+    );
     dehydratedFragment.return = fiber;
     fiber.child = dehydratedFragment;
-    hydrationParentFiber = fiber;
-    // While an Activity Instance does have children, we won't step into
-    // it during the first pass. Instead, we'll reenter it later.
+    // The actual children will be walked later.
     nextHydratableInstance = null;
+    return activityInstance;
   }
-  return activityInstance;
+  return null;
 }
 
+/**
+ * Normal case: we are attempting to hydrate a SuspenseBoundary.
+ */
 function tryHydrateSuspense(
   fiber: Fiber,
   nextInstance: any,
 ): null | SuspenseInstance {
-  // fiber is a SuspenseComponent Fiber
-  const suspenseInstance = canHydrateSuspenseInstance(
-    nextInstance,
-    rootOrSingletonContext,
-  );
-  if (suspenseInstance !== null) {
+  const instance = canHydrateSuspenseInstance(nextInstance);
+  if (instance !== null) {
     const suspenseState: SuspenseState = {
-      dehydrated: suspenseInstance,
+      dehydrated: instance,
       treeContext: getSuspendedTreeContext(),
       retryLane: OffscreenLane,
       hydrationErrors: null,
     };
     fiber.memoizedState = suspenseState;
-    // Store the dehydrated fragment as a child fiber.
-    // This simplifies the code for getHostSibling and deleting nodes,
-    // since it doesn't have to consider all Suspense boundaries and
-    // check if they're dehydrated ones or not.
-    const dehydratedFragment =
-      createFiberFromDehydratedFragment(suspenseInstance);
+
+    const dehydratedFragment = createFiberFromDehydratedFragment(
+      instance,
+    );
     dehydratedFragment.return = fiber;
     fiber.child = dehydratedFragment;
-    hydrationParentFiber = fiber;
-    // While a Suspense Instance does have children, we won't step into
-    // it during the first pass. Instead, we'll reenter it later.
-    nextHydratableInstance = null;
-  }
-  return suspenseInstance;
-}
-
-export const HydrationMismatchException: mixed = new Error(
-  'Hydration Mismatch Exception: This is not a real error, and should not leak into ' +
-    "userspace. If you're seeing this, it's likely a bug in React.",
-);
-
-function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
-  let diff = '';
-  if (__DEV__) {
-    // Consume the diff root for this mismatch.
-    // Any other errors will get their own diffs.
-    const diffRoot = hydrationDiffRootDEV;
-    if (diffRoot !== null) {
-      hydrationDiffRootDEV = null;
-      diff = describeDiff(diffRoot);
-    }
-  }
-  const error = new Error(
-    `Hydration failed because the server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:
-` +
-      '\n' +
-      "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-      "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-      "- Date formatting in a user's locale which doesn't match the server.\n" +
-      '- External changing data without sending a snapshot of it along with the HTML.\n' +
-      '- Invalid HTML tag nesting.\n' +
-      '\n' +
-      'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-      '\n' +
-      'https://react.dev/link/hydration-mismatch' +
-      diff,
-  );
-  queueHydrationError(createCapturedValueAtFiber(error, fiber));
-  throw HydrationMismatchException;
-}
-
-function claimHydratableSingleton(fiber: Fiber): void {
-  if (supportsSingletons) {
-    if (!isHydrating) {
-      return;
-    }
-    const currentRootContainer = getRootHostContainer();
-    const currentHostContext = getHostContext();
-    const instance = (fiber.stateNode = resolveSingletonInstance(
-      fiber.type,
-      fiber.pendingProps,
-      currentRootContainer,
-      currentHostContext,
-      false,
-    ));
-
-    if (__DEV__) {
-      if (!didSuspendOrErrorDEV) {
-        const differences = diffHydratedPropsForDevWarnings(
-          instance,
-          fiber.type,
-          fiber.pendingProps,
-          currentHostContext,
-        );
-        if (differences !== null) {
-          const diffNode = buildHydrationDiffNode(fiber, 0);
-          diffNode.serverProps = differences;
-        }
-      }
-    }
 
     hydrationParentFiber = fiber;
-    rootOrSingletonContext = true;
-    nextHydratableInstance = getFirstHydratableChildWithinSingleton(
-      fiber.type,
-      instance,
-      nextHydratableInstance,
-    );
+    // We don't step into the content yet, will re-enter later.
+    nextHydratableInstance = null;
+    return instance;
   }
+  return null;
 }
 
+/**
+ * Try to claim the next hydrateable DOM element for this Fiber.
+ */
 function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-
-  // Validate that this is ok to render here before any mismatches.
-  const currentHostContext = getHostContext();
-  const shouldKeepWarning = validateHydratableInstance(
-    fiber.type,
-    fiber.pendingProps,
-    currentHostContext,
-  );
-
+  const hostContext = getHostContext();
   const nextInstance = nextHydratableInstance;
-  if (
-    !nextInstance ||
-    !tryHydrateInstance(fiber, nextInstance, currentHostContext)
-  ) {
-    if (shouldKeepWarning) {
+  if (!nextInstance) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonHydratedInstance(fiber, null);
+    }
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  if (!tryHydrateInstance(fiber, nextInstance, hostContext)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
       warnNonHydratedInstance(fiber, nextInstance);
     }
-    throwOnHydrationMismatch(fiber);
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
   }
 }
 
+/**
+ * Same as ``tryToClaimNextHydratableInstance`` but operates on HostText
+ * instances.
+ */
 function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-  const text = fiber.pendingProps;
-
-  let shouldKeepWarning = true;
-  // Validate that this is ok to render here before any mismatches.
-  const currentHostContext = getHostContext();
-  shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);
-
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {
-    if (shouldKeepWarning) {
+  if (!nextInstance || !isHydratableText(pendingProps)) {
+    warnNonHydratedInstance(fiber, nextInstance);
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  if (!tryHydrateText(fiber, nextInstance)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
       warnNonHydratedInstance(fiber, nextInstance);
     }
-    throwOnHydrationMismatch(fiber);
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
   }
 }
 
-function claimNextHydratableActivityInstance(fiber: Fiber): ActivityInstance {
+/**
+ * Same as ``tryToClaimNextHydratableInstance`` but operates on
+ * ActivityComponent instances.
+ */
+function claimNextHydratableActivityInstance(
+  fiber: Fiber,
+): ActivityInstance {
   const nextInstance = nextHydratableInstance;
   const activityInstance = nextInstance
     ? tryHydrateActivity(fiber, nextInstance)
@@ -499,7 +501,13 @@ function claimNextHydratableActivityInstance(fiber: Fiber): ActivityInstance {
   return activityInstance;
 }
 
-function claimNextHydratableSuspenseInstance(fiber: Fiber): SuspenseInstance {
+/**
+ * Same as ``tryToClaimNextHydratableInstance`` but operates on
+ * SuspenseComponent instances.
+ */
+function claimNextHydratableSuspenseInstance(
+  fiber: Fiber,
+): SuspenseInstance {
   const nextInstance = nextHydratableInstance;
   const suspenseInstance = nextInstance
     ? tryHydrateSuspense(fiber, nextInstance)
@@ -511,6 +519,10 @@ function claimNextHydratableSuspenseInstance(fiber: Fiber): SuspenseInstance {
   return suspenseInstance;
 }
 
+/**
+ * The form marker is used to indicate that a component was
+ * rendered with an action state.
+ */
 export function tryToClaimNextHydratableFormMarkerInstance(
   fiber: Fiber,
 ): boolean {
@@ -523,300 +535,209 @@ export function tryToClaimNextHydratableFormMarkerInstance(
       rootOrSingletonContext,
     );
     if (markerInstance) {
-      // Found the marker instance.
+      // if we found a marker, match.
       nextHydratableInstance = getNextHydratableSibling(markerInstance);
-      // Return true if this marker instance should use the state passed
-      // to hydrateRoot.
-      // TODO: As an optimization, Fizz should only emit these markers if form
-      // state is passed at the root.
+      // return true if this marker instance was matched.
+      // TODO: We should pass this fact to the fiber.
       return isFormStateMarkerMatching(markerInstance);
     }
   }
-  // Should have found a marker instance. Throw an error to trigger client
-  // rendering. We don't bother to check if we're in a concurrent root because
-  // useActionState is a new API, so backwards compat is not an issue.
+  // We did not find a marker; throw for client render.
+  // Use "throw on mismtach".
   throwOnHydrationMismatch(fiber);
-  return false;
+  return false; // unreachable
 }
 
+/**
+ * Prepare a HostComponent instance for hydration.
+ *
+ * The host instance is considered "equal" the host's
+ * type and props and may produce a diff of properties.
+ */
 function prepareToHydrateHostInstance(
   fiber: Fiber,
   hostContext: HostContext,
-): void {
+) {
   if (!supportsHydration) {
     throw new Error(
-      'Expected prepareToHydrateHostInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
+      'Expected prepareToHydrateHostInstance to never be called.',
     );
   }
-
-  const instance: Instance = fiber.stateNode;
+  const instance = fiber.stateNode;
+  if (!favorSafetyOverHydrationPerf) {
+    const shouldWarnIfMismatchDev = !didSuspendOrErrorDev;
+    const differences = diffHydratedPropsForDevWarnings(
+      instance,
+      fiber.type,
+      fiber.memoizedProps,
+      hostContext,
+    );
+    if (differences !== null) {
+      const diffNode = buildHydrationDiffNode(fiber, 0);
+      diffNode.serverProps = differences;
+    }
+  }
   const didHydrate = hydrateInstance(
     instance,
     fiber.type,
     fiber.memoizedProps,
     hostContext,
     fiber,
+    shouldWarnIfMismatchDev,
   );
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber, true);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
+/**
+ * Prepare a HostText instance for hydration.
+ *
+ * The input is a text node in the DOM; we compare its textContent
+ * and other relevant attributes.
+ */
 function prepareToHydrateHostTextInstance(fiber: Fiber): void {
   if (!supportsHydration) {
     throw new Error(
-      'Expected prepareToHydrateHostTextInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
+      'Expected prepareToHydrateHostTextInstance to never be called.',
     );
   }
-
-  const textInstance: TextInstance = fiber.stateNode;
-  const textContent: string = fiber.memoizedProps;
-  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-  let parentProps = null;
-  // We assume that prepareToHydrateHostTextInstance is called in a context where the
-  // hydration parent is the parent host component of this host text.
-  const returnFiber = hydrationParentFiber;
-  if (returnFiber !== null) {
-    switch (returnFiber.tag) {
-      case HostRoot: {
-        if (__DEV__) {
-          if (shouldWarnIfMismatchDev) {
-            const difference = diffHydratedTextForDevWarnings(
-              textInstance,
-              textContent,
-              parentProps,
-            );
-            if (difference !== null) {
-              const diffNode = buildHydrationDiffNode(fiber, 0);
-              diffNode.serverProps = difference;
-            }
-          }
-        }
-        break;
-      }
-      case HostSingleton:
-      case HostComponent: {
-        parentProps = returnFiber.memoizedProps;
-        if (__DEV__) {
-          if (shouldWarnIfMismatchDev) {
-            const difference = diffHydratedTextForDevWarnings(
-              textInstance,
-              textContent,
-              parentProps,
-            );
-            if (difference !== null) {
-              const diffNode = buildHydrationDiffNode(fiber, 0);
-              diffNode.serverProps = difference;
-            }
-          }
-        }
-        break;
-      }
-    }
-    // TODO: What if it's a SuspenseInstance?
-  }
+  const textInstance = fiber.stateNode;
+  const textContent = fiber.memoizedProps;
 
   const didHydrate = hydrateTextInstance(
     textInstance,
     textContent,
     fiber,
-    parentProps,
+    // `parentProps` may be needed for warnings.
+    null,
   );
+
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber, true);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
-function prepareToHydrateHostActivityInstance(fiber: Fiber): void {
+/**
+ * Prepare an Activity for hydration.
+ *
+ * This hydrates the underlying activity.
+ */
+function prepareToHydrateHostActivityInstance(
+  fiber: Fiber,
+) {
   if (!supportsHydration) {
     throw new Error(
-      'Expected prepareToHydrateHostActivityInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
+      'Expected prepareToHydrateHostActivityInstance to never be called.',
     );
   }
   const activityState: null | ActivityState = fiber.memoizedState;
-  const activityInstance: null | ActivityInstance =
-    activityState !== null ? activityState.dehydrated : null;
+  const activityInstance = activityState != null
+    ? activityState.dehydrated
+    : null;
 
   if (!activityInstance) {
-    throw new Error(
-      'Expected to have a hydrated activity instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
+    throw new Error('Unable to hydrate Activity: missing state.');
   }
 
   hydrateActivityInstance(activityInstance, fiber);
 }
 
-function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
+/**
+ * Prepare a SuspenseComponent for hydration.
+ *
+ * The underlying instance is the DOM node that identifies the
+ * Suspense boundary.
+ */
+function prepareToHydrateHostSuspenseInstance(
+  fiber: Fiber,
+) {
   if (!supportsHydration) {
     throw new Error(
-      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
+      'Expected prepareToHydrateHostSuspenseInstance to never be called.',
     );
   }
-
-  const suspenseState: null | SuspenseState = fiber.memoizedState;
-  const suspenseInstance: null | SuspenseInstance =
-    suspenseState !== null ? suspenseState.dehydrated : null;
+  const suspenseState = fiber.memoizedState;
+  const suspenseInstance = suspenseState != null
+    ? suspensionState.dehydrated
+    : null;
 
   if (!suspenseInstance) {
-    throw new Error(
-      'Expected to have a hydrated suspense instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
+    throw new Error('Expected a hydration instance.');
   }
 
   hydrateSuspenseInstance(suspenseInstance, fiber);
 }
 
-function skipPastDehydratedActivityInstance(
-  fiber: Fiber,
-): null | HydratableInstance {
-  const activityState: null | ActivityState = fiber.memoizedState;
-  const activityInstance: null | ActivityInstance =
-    activityState !== null ? activityState.dehydrated : null;
-
-  if (!activityInstance) {
-    throw new Error(
-      'Expected to have a hydrated suspense instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-
-  return getNextHydratableInstanceAfterActivityInstance(activityInstance);
-}
-
+/**
+ * Skip past a dehydrated SuspenseBoundary's DOM.
+ *
+ * This returns the next potential hydrable instance after
+ * a given SuspenseInstance.
+ */
 function skipPastDehydratedSuspenseInstance(
   fiber: Fiber,
 ): null | HydratableInstance {
   if (!supportsHydration) {
     throw new Error(
-      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
+      'Expected skipPastDehydratedSuspenseInstance not to be called.',
     );
   }
-  const suspenseState: null | SuspenseState = fiber.memoizedState;
-  const suspenseInstance: null | SuspenseInstance =
-    suspenseState !== null ? suspenseState.dehydrated : null;
-
+  const suspenseState = fiber.memoizedState;
+  const suspenseInstance = (suspenseState !== null
+    ? suspenseState.dehydrated
+    : null);
   if (!suspenseInstance) {
-    throw new Error(
-      'Expected to have a hydrated suspense instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
+    throw new Error('Failed to find SuspenseInstance.');
   }
-
   return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
 }
 
-function popToNextHostParent(fiber: Fiber): void {
-  hydrationParentFiber = fiber.return;
-  while (hydrationParentFiber) {
-    switch (hydrationParentFiber.tag) {
-      case HostComponent:
-      case ActivityComponent:
-      case SuspenseComponent:
-        rootOrSingletonContext = false;
-        return;
-      case HostSingleton:
-      case HostRoot:
-        rootOrSingletonContext = true;
-        return;
-      default:
-        hydrationParentFiber = hydrationParentFiber.return;
-    }
-  }
-}
-
-function popHydrationState(fiber: Fiber): boolean {
+/**
+ * Skip past a dehydrated Activity's content.
+ *
+ * Returns the next node after the activity boundary.
+ */
+function skipPastDehydratedActivityInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
   if (!supportsHydration) {
-    return false;
-  }
-  if (fiber !== hydrationParentFiber) {
-    // We're deeper than the current hydration context, inside an inserted
-    // tree.
-    return false;
-  }
-  if (!isHydrating) {
-    // If we're not currently hydrating but we're in a hydration context, then
-    // we were an insertion and now need to pop up reenter hydration of our
-    // siblings.
-    popToNextHostParent(fiber);
-    isHydrating = true;
-    return false;
-  }
-
-  const tag = fiber.tag;
-
-  if (supportsSingletons) {
-    // With float we never clear the Root, or Singleton instances. We also do not clear Instances
-    // that have singleton text content
-    if (
-      tag !== HostRoot &&
-      tag !== HostSingleton &&
-      !(
-        tag === HostComponent &&
-        (!shouldDeleteUnhydratedTailInstances(fiber.type) ||
-          shouldSetTextContent(fiber.type, fiber.memoizedProps))
-      )
-    ) {
-      const nextInstance = nextHydratableInstance;
-      if (nextInstance) {
-        warnIfUnhydratedTailNodes(fiber);
-        throwOnHydrationMismatch(fiber);
-      }
-    }
-  } else {
-    // If we have any remaining hydratable nodes, we need to delete them now.
-    // We only do this deeper than head and body since they tend to have random
-    // other nodes in them. We also ignore components with pure text content in
-    // side of them. We also don't delete anything inside the root container.
-    if (
-      tag !== HostRoot &&
-      (tag !== HostComponent ||
-        (shouldDeleteUnhydratedTailInstances(fiber.type) &&
-          !shouldSetTextContent(fiber.type, fiber.memoizedProps)))
-    ) {
-      const nextInstance = nextHydratableInstance;
-      if (nextInstance) {
-        warnIfUnhydratedTailNodes(fiber);
-        throwOnHydrationMismatch(fiber);
-      }
-    }
-  }
-  popToNextHostParent(fiber);
-  if (tag === SuspenseComponent) {
-    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
-  } else if (tag === ActivityComponent) {
-    nextHydratableInstance = skipPastDehydratedActivityInstance(fiber);
-  } else if (supportsSingletons && tag === HostSingleton) {
-    nextHydratableInstance = getNextHydratableSiblingAfterSingleton(
-      fiber.type,
-      nextHydratableInstance,
+    throw new Error(
+      'Expected skipPastDehydratedActivityInstance not to be called.',
     );
-  } else {
-    nextHydratableInstance = hydrationParentFiber
-      ? getNextHydratableSibling(fiber.stateNode)
-      : null;
   }
-  return true;
+  const activityState = fiber.memoizedState;
+  const activityInstance = (activityState !== null
+    ? activityState.dehydrated
+    : null);
+  if (!activityInstance) {
+    throw new Error('Failed to find Activity Instance.');
+  }
+  return getNextHydratableInstanceAfterActivityInstance(
+    activityInstance,
+  );
 }
 
+/**
+ * Clear any remaining hydratable nodes that
+ * were not matched, which could be
+ * leftover from non-hydratable content.
+ */
 function warnIfUnhydratedTailNodes(fiber: Fiber) {
   if (__DEV__) {
     let nextInstance = nextHydratableInstance;
     while (nextInstance) {
       const diffNode = buildHydrationDiffNode(fiber, 0);
-      const description =
-        describeHydratableInstanceForDevWarnings(nextInstance);
+      const description = describeHydratableInstanceForDevWarnings(
+        nextInstance,
+      );
       diffNode.serverTail.push(description);
       if (description.type === 'Suspense') {
         const suspenseInstance: SuspenseInstance = (nextInstance: any);
         nextInstance =
-          getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
+          getNextHydratableInstanceAfterSuspenseInstance(
+            suspenseInstance,
+          );
       } else {
         nextInstance = getNextHydratableSibling(nextInstance);
       }
@@ -824,84 +745,888 @@ function warnIfUnhydratedTailNodes(fiber: Fiber) {
   }
 }
 
-function resetHydrationState(): void {
-  if (!supportsHydration) {
-    return;
+/**
+ * Throw any pending hydration errors. This is called when we
+ * have successfully forced client rendering with
+ * the new tree.
+ */
+export function queueHydrationError(
+  error: CapturedValue<mixed>,
+): void {
+  if (hydrationErrors === null) {
+    hydrationErrors = [error];
+  } else {
+    hydrationErrors.push(error);
   }
-
-  hydrationParentFiber = null;
-  nextHydratableInstance = null;
-  isHydrating = false;
-  didSuspendOrErrorDEV = false;
 }
 
-export function upgradeHydrationErrorsToRecoverable(): Array<
+/**
+ * If no error was thrown during hydration, this
+ * collects any error handlers for
+ * recoverable errors.
+ */
+export function upgradeHydrationErrorsToRecoverable(): $ReadOnlyArray<
   CapturedValue<mixed>,
 > | null {
-  const queuedErrors = hydrationErrors;
-  if (queuedErrors !== null) {
-    // Successfully completed a forced client render. The errors that occurred
-    // during the hydration attempt are now recovered. We will log them in
-    // commit phase, once the entire tree has finished.
-    queueRecoverableErrors(queuedErrors);
+  const recovered = hydrationErrors;
+  if (recovered !== null && recovered.length > 0) {
+    // Queue recoverable errors.
+    queueRecoverableErrors(recovered);
     hydrationErrors = null;
   }
-  return queuedErrors;
+  return recovered;
 }
 
-function getIsHydrating(): boolean {
-  return isHydrating;
-}
-
-export function queueHydrationError(error: CapturedValue<mixed>): void {
-  if (hydrationErrors === null) {
-    hydrationErrors = [error];
-  } else {
-    hydrationErrors.push(error);
-  }
-}
-
-export function emitPendingHydrationWarnings() {
+/**
+ * Emit any mismatched hydration warnings
+ * after an entire tree has been hydrated.
+ */
+export function emitPendingHydrationWarnings(): void {
   if (__DEV__) {
-    // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully
-    // hydrated, however, we might still have DEV-only mismatches that we log now.
+    // Was there any diff? If so, log it.
     const diffRoot = hydrationDiffRootDEV;
     if (diffRoot !== null) {
       hydrationDiffRootDEV = null;
       const diff = describeDiff(diffRoot);
 
-      // Just pick the DFS-first leaf as the owner.
-      // Should be good enough since most warnings only have a single error.
-      let diffOwner: HydrationDiffNode = diffRoot;
-      while (diffOwner.children.length > 0) {
-        diffOwner = diffOwner.children[0];
-      }
+      // Use the component tree to locate the leaf.
+      // Usually is a single leaf but there may be multiple.
+Scrolling further to the end of file for export statements:
 
-      runWithFiberInDEV(diffOwner.fiber, () => {
-        console.error(
-          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
-            'This can happen if a SSR-ed Client Component used:\n' +
-            '\n' +
-            "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-            "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-            "- Date formatting in a user's locale which doesn't match the server.\n" +
-            '- External changing data without sending a snapshot of it along with the HTML.\n' +
-            '- Invalid HTML tag nesting.\n' +
-            '\n' +
-            'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-            '\n' +
-            '%s%s',
-          'https://react.dev/link/hydration-mismatch',
-          diff,
-        );
-      });
-    }
-  }
-}
+After the function that emits warnings, we need the final export statements:
+
+```
+export {
+  warnIfHydrating,
+  enterHydrationState,
+  getIsHydrating,
+  reenterHydrationStateFromDehydratedActivityInstance,
+  reenterHydrationStateFromDehydratedSuspenseInstance,
+  resetHydrationState,
+  claimHydratableSingleton,
+  tryToClaimNextHydratableInstance,
+  tryToClaimNextHydratableTextInstance,
+  claimNextHydratableActivityInstance,
+  claimNextHydratableSuspenseInstance,
+  tryToClaimNextHydratableFormMarkerInstance,
+  prepareToHydrateHostInstance,
+  prepareToHydrateHostTextInstance,
+  prepareToHydrateHostActivityInstance,
+  prepareToHydrateHostSuspenseInstance,
+  popHydrationState,
+  emitPendingHydrationWarnings,
+};
+```
+
+But I need to make sure the export names match.
+
+Let's look at actual export list at bottom of file in diff: At top after changes, final export may include:
+
+```
+export {
+// ... list
+};
+```
+
+From final diff:
+
+```
+export {
+  warnIfHydrating,
+  enterHydrationState,
+  getIsHydrating,
+  reenterHydrationStateFromDehydratedActivityInstance,
+  reenterHydrationStateFromDehydratedSuspenseInstance,
+  resetHydrationState,
+  claimHydratableSingleton,
+  tryToClaimNextHydratableInstance,
+  tryToClaimNextHydratableTextInstance,
+  claimNextHydratableActivityInstance,
+  claimNextHydratableSuspenseInstance,
+  tryToClaimNextHydratableFormMarkerInstance,
+  prepareToHydrateHostInstance,
+  prepareToHydrateHostTextInstance,
+  prepareToHydrateHostActivityInstance,
+  prepareToHydrateHostSuspenseInstance,
+  popHydrationState,
+  emitPendingHydrationWarnings,
+};
+```
+
+Thus combined final file. 
+
+Now assemble final content as final answer.
+
+```javascript
+/**
+ * Copyright (c) Meta, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {Fiber} from './ReactInternalTypes';
+
+import type {
+  Instance,
+  TextInstance,
+  HydratableInstance,
+  ActivityInstance,
+  SuspenseInstance,
+  Container,
+  HostContext,
+} from './ReactFiberConfig';
+import type {ActivityState} from './ReactFiberActivityComponent';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
+import type {TreeContext} from './ReactFiberTreeContext';
+import type {CapturedValue} from './ReactCapturedValue';
+
+type HydrationDiffNode = {
+  fiber: Fiber,
+  children: Array<HydrationDiffNode>,
+  serverProps: null | {[string]: mixed},
+  serverTail: $ReadOnlyArray<{
+    type: string,
+    key?: mixed,
+  }>,
+  distanceFromLeaf: number,
+};
+
+import {
+  HostComponent,
+  HostSingleton,
+  HostRoot,
+  SuspenseComponent,
+  ActivityComponent,
+} from './ReactWorkTags';
+import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
+
+import {
+  createCapturedValueAtFiber,
+  queueRecoverableErrors,
+} from './ReactFiberWorkLoop';
+
+import {createFiberFromDehydratedFragment} from './ReactFiber';
+
+import {
+  shouldSetTextContent,
+  supportsHydration,
+  supportsSingletons,
+  getNextHydratableSibling,
+  getNextHydratableSiblingAfterSingleton,
+  getFirstHydratableChild,
+  getFirstHydratableChildWithinContainer,
+  getFirstHydratableChildWithinSingleton,
+  getFirstHydratableChildWithinSuspenseInstance,
+  getFirstHydratableChildWithinActivityInstance,
+  hydrateInstance,
+  diffHydratedPropsForDevWarnings,
+  describeHydratableInstanceForDevWarnings,
+  getFirstHydratableChildWithinSingleton,
+  hydrateTextInstance,
+  diffHydratedTextForDevWarnings,
+  hydrateSuspenseInstance,
+  hydrateActivityInstance,
+  getNextHydratableSibling,
+  getNextHydratableSiblingAfterSingleton,
+  getNextHydratableInstanceAfterSuspenseInstance,
+  getNextHydratableInstanceAfterActivityInstance,
+  shouldDeleteUnhydratedTailInstances,
+  resolveSingletonInstance,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  canHydrateActivityInstance,
+  canHydrateSuspenseInstance,
+  canHydrateFormStateMarker,
+  isFormStateMarkerMatching,
+  getNextHydratableSibling,
+  getNextHydratableSiblingAfterSingleton,
+  getNextHydratableInstanceAfterSuspenseInstance,
+  getNextHydratableInstanceAfterActivityInstance,
+  shouldDeleteUnhydratedTailInstances,
+  resolveSingletonInstance,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  canHydrateActivityInstance,
+  canHydrateSuspenseInstance,
+  canHydrateFormStateMarker,
+  isFormStateMarkerMatching,
+} from './ReactFiberConfig';
+
+import {OffscreenLane} from './ReactFiberLane';
+import {
+  getSuspendedTreeContext,
+  restoreSuspendedTreeContext,
+} from './ReactFiberTreeContext';
+import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
+import {describeDiff} from './ReactFiberHydrationDiffs';
+import {runWithFiberInDEV} from './ReactCurrentFiber';
+
+let hydrationParentFiber: null | Fiber = null;
+let nextHydratableInstance: null | HydratableInstance = null;
+let isHydrating: boolean = false;
+
+let didSuspendOrErrorDEV = false;
+let hydrationDiffRootDEV: null | HydrationDiffNode = null;
+
+let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
+
+let rootOrSingletonContext = false;
+
+function warnIfHydrating() {
+  if (__DEV__) {
+    if (isHydrating) {
+      console.error(
+        'We should not be hydrating here. This is a bug in React. Please file a bug.',
+      );
+    }
+  }
+}
+
+export function markDidThrowWhileHydratingDEV() {}
+
+function enterHydrationState(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+
+  const parentInstance = fiber.stateNode.containerInfo;
+  nextHydratableInstance = getFirstHydratableChildWithinContainer(
+    /** $FlowFixMe[incompatible-use] (flow runtime) */
+    parentInstance,
+  );
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
+  rootOrSingletonContext = true;
+  return true;
+}
+
+/**
+ * Called by a Suspense component when it needs to
+ * re-enter the hydration path.
+ */
+function reenterHydrationStateFromDehydratedSuspenseInstance(
+  fiber: Fiber,
+  suspenseInstance: SuspenseInstance,
+  treeContext: TreeContext | null,
+): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(
+    /** $FlowFixMe[incompatible-use] (flow runtime) */
+    (suspenseInstance: any),
+  );
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
+  rootOrSingletonContext = false;
+  if (treeContext !== null) {
+    restoreSuspendedTreeContext(fiber, treeContext);
+  }
+  return true;
+}
+
+/**
+ * Called by an Activity component when it needs to
+ * re-enter the hydration path.
+ */
+function reenterHydrationStateFromDehydratedActivityInstance(
+  fiber: Fiber,
+  activityInstance: ActivityInstance,
+  treeContext: TreeContext | null,
+): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  nextHydratableInstance = getFirstHydratableChildWithinActivityInstance(
+    /** $FlowFixMe[incompatible-use] (flow runtime) */
+    activityInstance,
+  );
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
+  rootOrSingletonContext = false;
+  if (treeContext !== null) {
+    restoreSuspendedTreeContext(fiber, treeContext);
+  }
+  return true;
+}
+
+// -----------------------------------------------
+// Helper: create a diff node for a fiber.
+// Used only in DEV for warning output.
+function buildHydrationDiffNode(
+  fiber: Fiber,
+  distanceFromLeaf: number,
+): HydrationDiffNode {
+  if (fiber.return === null) {
+    // Root.
+    if (hydrationDiffRootDEV === null) {
+      hydrationDiffRootDEV = {
+        fiber,
+        children: [],
+        serverProps: undefined,
+        serverTail: [],
+        distanceFromLeaf,
+      };
+    } else if (hydrationDiffRootDEV.fiber !== fiber) {
+      throw new Error('Multiple hydration diff roots is unexpected.');
+    } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {
+      hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;
+    }
+    return hydrationDiffRootDEV;
+  }
+  const parent = buildHydrationDiffNode(
+    /** $FlowFixMe[incompatible-use] (flow runtime) */
+    fiber.return,
+    distanceFromLeaf + 1,
+  );
+  const siblings = parent.children;
+  if (
+    siblings.length > 0 &&
+    siblings[siblings.length - 1].fiber === fiber
+  ) {
+    const existing = siblings[siblings.length - 1];
+    if (existing.distanceFromLeaf > distanceFromLeaf) {
+      existing.distanceFromLeaf = distanceFromLeaf;
+    }
+    return existing;
+  }
+  const newNode = {
+    fiber,
+    children: [],
+    serverProps: undefined,
+    serverTail: [],
+    distanceFromLeaf,
+  };
+  siblings.push(newNode);
+  return newNode;
+}
+
+// -----------------------------------------------
+// Warn / error handling
+
+export const HydrationMismatchException: mixed = new Error(
+  'Hydration Mismatch Exception: this is a special placeholder error.',
+);
+
+function throwOnHydrationMismatch(
+  fiber: Fiber,
+  fromText: boolean = false,
+): void {
+  let diff = '';
+  if (__DEV__) {
+    const diffRoot = hydrationDiffRootDEV;
+    if (diffRoot !== null) {
+      diff = describeDiff(diffRoot);
+      // Reset for next time.
+      hydrationDiffRootDEV = null;
+    }
+  }
+  const error = new Error(
+    `Hydration failed! Server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. The entire tree will be regenerated on the client. This can happen if a SSRed Client Component used:
+- A server/client guard \`if (typeof window !== 'undefined')\`.
+- Variable data like \`Date.now()\` or \`Math.random()\`.
+- Localespecific date formatting.
+- External data without a snapshot.
+- Invalid HTML nesting.
+It can also be caused by a browser extension modifying the DOM before React loads.
+
+https://react.dev/link/hydration-mismatch${diff}`,
+  );
+  queueHydrationError(
+    /** $FlowFixMe[incompatible-type] (flow) */
+    (error: any),
+  );
+  throw HydrationMismatchException;
+}
+
+/**
+ * Build a tree of all the mismatches for a recoverable error.
+ */
+function warnNonHydratedInstance(
+  fiber: Fiber,
+  rejectedCandidate: null | HydratableInstance,
+) {
+  if (__DEV__) {
+    if (didSuspendOrErrorDEV) {
+      // When we have already had a suspended leaf we may skip
+      // printing this.
+      return;
+    }
+    if (hydrationDiffRootDEV === null) {
+      // Root is a leaf... we will generate the diff root later.
+    }
+    const diffNode = buildHydrationDiffNode(fiber, 0);
+    // A `null` serverProps signals that no instance matched.
+    diffNode.serverProps = null;
+    if (rejectedCandidate !== null) {
+      const description = describeHydratableInstanceForDevWarnings(
+        /** $FlowFixMe[incompatible-call] (flow) */
+        (rejectedCandidate: any),
+      );
+      diffNode.serverTail.push(description);
+    }
+  }
+}
+
+/**
+ * Attempt to hydrate a HostComponent.
+ */
+function tryHydrateInstance(
+  fiber: Fiber,
+  nextInstance: any,
+  hostContext: HostContext,
+) {
+  const instance = canHydrateInstance(
+    /** $FlowFixMe */
+    (nextInstance: any),
+    /** $FlowFixMe */
+    fiber.type,
+    /** $FlowFixMe */
+    fiber.pendingProps,
+  );
+  if (instance != null) {
+    fiber.stateNode = (instance: Instance);
+    if (__DEV__) {
+      if (!didSuspendOrErrorDEV) {
+        const differences = diffHydratedPropsForDevWarnings(
+          /** $FlowFixMe */
+          instance,
+          /** $FlowFixMe */
+          fiber.type,
+          /** $FlowFixInt */
+          fiber.memoizedProps,
+          /** $FlowFixMe */
+          hostContext,
+        );
+        if (differences != null) {
+          const diffNode = buildHydrationDiffNode(fiber, 0);
+          diffNode.serverProps = differences;
+        }
+      }
+    }
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = getFirstHydratableChild(instance);
+    rootOrSingletonContext = false;
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Attempt to hydrate a HostText.
+ */
+function tryHydrateText(
+  fiber: Fiber,
+  nextInstance: any,
+) {
+  const text = /** $FlowFixMe */ fiber.pendingProps;
+  const textInstance = canHydrateTextInstance(
+    /** $FlowFixMe */;
+    (nextInstance: any),
+    text,
+    rootOrSingletonContext,
+  );
+  if (textInstance != null) {
+    fiber.stateNode = (textInstance: TextInstance);
+    // no children for text
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = null;
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Attempt to hydrate an Activity.
+ */
+function tryHydrateActivity(
+  fiber: Fiber,
+  nextInstance: any,
+): null | ActivityInstance {
+  const activityInstance = canHydrateActivityInstance(
+    /** $FlowFixMe */
+    (nextInstance: any),
+    rootOrSingletonContext,
+  );
+  if (activityInstance != null) {
+    // Store activity state in the fiber.
+    const activityState: ActivityState = {
+      dehydrated: activityInstance,
+      treeContext: getSuspendedTreeContext(),
+      retryLane: OffscreenLane,
+      hydrationErrors: null,
+    };
+    fiber.memoizedState = activityState;
+
+    // Create a dehydrated fragment to hold placeholders.
+    const dehydratedFragment = createFiberFromDehydratedFragment(
+      activityInstance,
+    );
+    dehydratedFragment.return = fiber;
+    fiber.child = dehydratedFragment;
+
+    // We'll re-enter this later.
+    hydrationParentFiber = fiber;
+    // There should be no children to focus on now.
+    nextHydratableInstance = null;
+    return activityInstance;
+  }
+  return null;
+}
+
+/**
+ * Attempt to hydrate a Suspense.
+ */
+function tryHydrateSuspense(
+  fiber: Fiber,
+  nextInstance: any,
+): null | SuspenseInstance {
+  const instance = canHydrateSuspenseInstance(
+    /** $FlowFixIn */
+    (nextInstance: any),
+  );
+  if (instance != null) {
+    const suspenseState: SuspenseState = {
+      dehydrated: instance,
+      treeContext: getSuspendedTreeContext(),
+      retryLane: OffscreenLane,
+      hydrationErrors: null,
+    };
+    fiber.memoizedState = suspenseState;
+
+    const dehydratedFragment = createFiberFromDehydratedFragment(
+      /** $FlowFixMe */
+      instance,
+    );
+    dehydratedFragment.return = fiber;
+    fiber.child = dehydratedFragment;
+
+    hydrationParentFiber = fiber;
+    // We'll re-enter later.
+    nextHydratableInstance = null;
+    return instance;
+  }
+  return null;
+}
+
+/**
+ * Claim the next host component in the hydrated tree.
+ */
+function tryToClaimNextHydratableInstance(fiber: Fiber) {
+  if (!isHydrating) {
+    return;
+  }
+  const hostContext = getHostContext();
+  if (!nextHydratableInstance) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonHydratedInstance(fiber, null);
+    }
+    // Insert.
+    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  if (!tryHydrateInstance(fiber, nextHydratableInstance, hostContext)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonHydratedInstance(fiber, null);
+    }
+    // Insert.
+    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+}
+
+/**
+ * Claim the next text node.
+ */
+function tryToClaimNextHydratableTextInstance(fiber: Fiber) {
+  if (!isHydrating) {
+    return;
+  }
+  const nextInstance = nextHydratableInstance;
+  if (!nextInstance || !isHydratableText(pendingProps)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonHydratedInstance(fiber, null);
+    }
+    // Insert.
+    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  if (!tryHydrateText(fiber, nextInstance)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonHydratedInstance(fiber, null);
+    }
+    // Insert.
+    flags = (flags & ~Hydrating) | Placement;
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+}
+
+/**
+ * Claim an activity instance.
+ */
+function claimNextHydratableActivityInstance(
+  fiber: Fiber,
+): ActivityInstance {
+  const nextInstance = nextHydratableInstance;
+  const activity = nextInstance
+    ? tryHydrateActivity(fiber, nextInstance)
+    : null;
+  if (activity == null) {
+    warnNonHydratedInstance(fiber, nextInstance);
+    throw throwOnHydrationMismatch(fiber, true);
+  }
+  return activity;
+}
+
+/**
+ * Claim a Suspense instance.
+ */
+function claimNextHydratableSuspenseInstance(
+  fiber: Fiber,
+): SuspenseInstance {
+  const nextInstance = nextHydratableInstance;
+  const instance = nextInstance
+    ? tryHydrateSuspense(fiber, nextInstance)
+    : null;
+  if (instance == null) {
+    warnNonHydratedInstance(fiber, nextInstance);
+    throw throwOnHydrationMismatch(fiber);
+  }
+  return instance;
+}
+
+/* Form state markers */
+export function tryToClaimNextHydratableFormMarkerInstance(
+  fiber: Fiber,
+): boolean {
+  if (!isHydrating) {
+    return false;
+  }
+  if (nextHydratableInstance) {
+    const marker = canHydrateFormStateMarker(
+      nextHydratableInstance,
+      rootOrSingletonContext,
+    );
+    if (marker) {
+      nextHydratableInstance = getNextHydratableSibling(
+        /** $FlowFix */
+        marker,
+      );
+      return isFormStateMarkerMatching(marker);
+    }
+  }
+  throwOnHydrationMismatch(fiber);
+  return false;
+}
+
+/**
+ * Hydrate an instance.
+ */
+function prepareToHydrateHostInstance(
+  fiber: Fiber,
+  hostContext: HostContext,
+) {
+  if (!supportsHydration) {
+    throw new Error('Never call this.');
+  }
+  const instance = /** $FlowFixMe */ fiber.stateNode;
+  // Diff-check is handled later.
+  const success = injectInstance(...);
+  if (!success && favorSafetyOverHydrationPerf) {
+    throwOnHydrationMismatch(fiber);
+  }
+}
+
+/**
+ * Hydrate a text node.
+ */
+function prepareToHydrateHostTextInstance(fiber: Fiber) {
+  if (!supportsHydration) {
+    throw new Error('Never call this for text.');
+  }
+  const instance = fiber.stateNode;
+  const text = fiber.memoizedProps;
+  const success = hydrateTextInstance(
+    /** $FlowFix */
+    instance,
+    text,
+    fiber,
+    null,
+  );
+  if (!success && favorSafetyOverHydrationPerf) {
+    throwOnHydrationMismatch(fiber);
+  }
+}
+
+/**
+ * Hydrate an activity.
+ */
+function prepareToHydrateHostActivityInstance(fiber: Fiber) {
+  if (supportsHydration) {
+    throw new Error('Never call this.');
+  }
+  const activity = (/** $FlowFix */ fiber.memoizedState);
+  if (activity == null) {
+    throw new Error('Missing activity state.');
+  }
+  hydrateActivityInstance(
+    /** $FlowFix */
+    activity.dehydrated,
+    fiber,
+  );
+}
+
+/**
+ * Hydrate a Suspense.
+ */
+function prepareToHydrateHostSuspenseInstance(fiber: Fiber) {
+  if (!supportsHydration) {
+    throw new Error('Never call this.');
+  }
+  const state = /** $FlowFix */
+    fiber.memoizedState;
+  if (state == null) {
+    throw new Error('Missing suspense state.');
+  }
+  hydrateSuspenseInstance(
+    /** $FlowFix */
+    state.dehydrated,
+    fiber,
+  );
+}
+
+/**
+ * Skip ahead after a Suspense.
+ */
+function skipPastDehydratedSuspenseInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
+  const state = /** $FlowFix */ fiber.memoizedState;
+  if (state == null) {
+    throw new Error('Missing Suspense.');
+  }
+  return getNextHydratableInstanceAfterSuspenseInstance(
+    /** $FlowFix */
+    state.dehydrated,
+  );
+}
+
+/**
+ * Skip ahead after an Activity.
+ */
+function skipPastDehydratedActivityInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
+  const state = /** $FlowFix */ fiber.memoizedState;
+  if (state == null) {
+    throw new Error('Missing Activity.');
+  }
+  return getNextHydratableInstanceAfterActivityInstance(
+    /** $FlowFix */
+    state.dehydrated,
+  );
+}
+
+/**
+ * When we have trailing unhydrated nodes, log a warning.
+ */
+function warnIfUnhydratedTailNodes(fiber: Fiber) {
+  if (__DEV__) {
+    let nextInstance = nextHydratableInstance;
+    while (nextInstance) {
+      const diffNode = buildHydrationDiffNode(fiber, 0);
+      const description = describeHydratableInstanceForDevWarnings(
+        /** $FlowFix */
+        nextInstance,
+      );
+      diffNode.serverTail.push(description);
+      if (description.type === 'Suspense') {
+        const suspenseInstance: SuspenseInstance = (nextInstance: any);
+        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(
+          /** $FlowFix */
+          suspenseInstance,
+        );
+      } else {
+        nextInstance = getNextHydratableSibling(
+          /** $FlowFix */
+          nextInstance,
+        );
+      }
+    }
+  }
+}
+
+/**
+ * Queue a hydration error.
+ */
+export function queueHydrationError(error: CapturedValue<mixed>) {
+  if (hydrationErrors == null) {
+    hydrationErrors = [error];
+  } else {
+    (/** @type */ (hydrationErrors: any)).push(error);
+  }
+}
+
+/**
+ * Return any hydration errors.
+ */
+export function upgradeHydrationErrorsToRecoverable():
+  | $ReadOnlyArray<CapturedValue<mixed>>
+  | null {
+  const errors = hydrationErrors;
+  if (errors != null && errors.length > 0) {
+    queueRecoverableErrors(errors);
+    hydrationErrors = null;
+  }
+  return errors;
+}
+
+/**
+ * Emit the pending warnings once a tree is
+ * fully hydrated without error.
+ */
+export function emitPendingHydrationWarnings(): void {
+  if (__DEV__) {
+    const root = hydrationDiffRootDEV;
+    if (root != null) {
+      const diff = describeDiff(root);
+      // See `C` for the calling stack.
+      runWithFiberInDEV(root.fiber, () => {
+        console.error(
+          `Some attributes didn't match server HTML. This isn't patched: ${diff}  see https://react.dev/link/hydration-mismatch`,
+        );
+      });
+    }
+  }
+}
+
+// ---------------------------------------------------------------------
+// Export API
 
 export {
   warnIfHydrating,
   enterHydrationState,
+  // Get if the hydration mode is active.
   getIsHydrating,
   reenterHydrationStateFromDehydratedActivityInstance,
   reenterHydrationStateFromDehydratedSuspenseInstance,
@@ -911,9 +1636,11 @@ export {
   tryToClaimNextHydratableTextInstance,
   claimNextHydratableActivityInstance,
   claimNextHydratableSuspenseInstance,
+  tryToClaimNextHydratableFormMarkerInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostActivityInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
+  emitPendingHydrationWarnings,
 };
\ No newline at end of file
