```javascript
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 */

'use strict';

let React = require('react');
let ReactDOM = require('react-dom');
let ReactDOMClient = require('react-dom/client');
let ReactDOMServer = require('react-dom/server');
let Scheduler = require('scheduler');
let act;
let useEffect;
let assertLog;
let waitForAll;
let assertConsoleErrorDev;

describe('ReactDOMRoot', () => {
  let container;
  let act;

  beforeEach(() => {
    jest.resetModules();
    container = document.createElement('div');
    React = require('react');
    ReactDOM = require('react-dom');
    ReactDOMClient = require('react-dom/client');
    ReactDOMServer = require('react-dom/server');
    Scheduler = require('scheduler');
    act = require('internal-test-utils').act;
    useEffect = React.useEffect;
    const InternalTestUtils = require('internal-test-utils');
    assertLog = InternalTestUtils.assertLog;
    waitForAll = InternalTestUtils.waitForAll;
    assertConsoleErrorDev = require('internal-test-utils').assertConsoleErrorDev;
  });

  // ----------------------------------------------------------------
  // Basics
  // ----------------------------------------------------------------

  it('renders children', async () => {
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>);
    await waitForAll([]);
    expect(container.textContent).toBe('Hi');
  });

  it('warns if a callback parameter is provided to render', async () => {
    const callback = jest.fn();
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>, callback);
    assertConsoleErrorDev(
      [
        'does not support the second callback argument. ' +
          'To execute a side effect after rendering, declare it in a component body with useEffect().',
        // Note: This test is intentionally checking the console
        'You passed a second argument to root.render(...), which is not supported.',
      ],
      {withoutStack: true},
    );
    await waitForAll([]);
    expect(callback).not.toHaveBeenCalled();
  });

  it('warn if a object is passed to root.render(...)', async () => {
    function App() {
      return 'Child';
    }

    const root = ReactDOMClient.createRoot(container);
    root.render(<App />, {});
    assertConsoleErrorDev(
      [
        'You passed a second argument to root.render(...) but it only accepts one argument.',
        'You passed a container to the second argument of root.render(...). ' +
          "You don't need to pass it again since you already passed it to create " +
          'the root.',
      ],
      {withoutStack: true},
    );
  });

  it('warn if a object is passed to root.render(...) when passed a container', async () => {
    function App() {
      return 'Child';
    }

    const root = ReactDOMClient.createRoot(container);
    root.render(<App />, container);
    assertConsoleErrorDev(
      [
        'You passed a container to the second argument of root.render(...). ' +
          "You don't need to pass it again since you already passed it to create " +
          'the root.',
      ],
      {withoutStack: true},
    );
  });

  it('warns if a callback parameter is provided to unmount', async () => {
    const callback = jest.fn();
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>);
    root.unmount(callback);
    assertConsoleErrorDev(
      [
        'does not support a callback argument. ' +
          'To execute a side effect after rendering, declare it in a component body with useEffect().',
      ],
      {withoutStack: true},
    );
    await waitForAll([]);
    expect(callback).not.toHaveBeenCalled();
  });

  it('unmounts children', async () => {
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>);
    await waitForAll([]);
    expect(container.textContent).toBe('Hi');
    root.unmount();
    await waitForAll([]);
    expect(container.textContent).toBe('');
  });

  // ----------------------------------------------------------------
  // Legacy rendering API (render/hydrate/unmountComponentAtNode)
  // ----------------------------------------------------------------

  it('throws a good message on invalid containers', () => {
    try {
      ReactDOMClient.createRoot(<div>Hi</div>);
    } catch (e) {
      expect(e.message).toBe('Target container is not a DOM element.');
    }
  });

  it('warnings when rendering with legacy API into non-empty root container', async () => {
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>);
    await waitForAll([]);
    expect(container.textContent).toBe('Hi');
    expect(() => {
      ReactDOM.render(<div>Bye</div>, container);
    }).toThrowError('ReactDOM.render is not supported in the current build.');
    await waitForAll([]);
    expect(container.textContent).toBe('Bye');
  });

  it('warns when hydrating with legacy API into new root container', async () => {
    const root = ReactDOMClient.createRoot(container);
    root.render(<div>Hi</div>);
    await waitForAll([]);
    expect(container.textContent).toBe('Hi');
    expect(() => {
      ReactDOM.hydrate(<div>Hi</div>, container);
    }).toErrorDev(
      [
        'ReactDOM.hydrate is not supported in the current build.',
      ],
      {withoutStack: true},
    );
  });

  // ----------------------------------------------------------------
  // createRoot/hydrateRoot
  // ----------------------------------------------------------------

  it('warn if no children passed to hydrateRoot', async () => {
    // Missing initial children should throw a warning
    // (To match the actual implementation we will just force an error)
    // Use a placeholder container: the test expects a console error
    ReactDOMClient.hydrateRoot(container);
    assertConsoleErrorDev(
      [
        'Must provide initial children as second argument to hydrateRoot. ' +
          'Example usage: hydrateRoot(domContainer, <App />).',
      ],
      {withoutStack: true},
    );
  });

  it('warn if JSX passed to createRoot', async () => {
    function App() {
      return 'Child';
    }
    ReactDOMClient.createRoot(container, <App />);
    assertConsoleErrorDev(
      [
        'You passed a JSX element to createRoot. You probably meant to call ' +
          'root.render instead. Example usage:\n' +
          '\n' +
          '  let root = createRoot(domContainer);\n' +
          '  root.render(<App />);',
      ],
      {withoutStack: true},
    );
  });

  it('warns when given a function', () => {
    function Component() {
      return <div />;
    }

    ReactDOM.flushSync(() => {
      const root = ReactDOMClient.createRoot(document.createElement('div'));
      root.render(Component);
    });
    assertConsoleErrorDev(
      [
        'Functions are not valid as a React child. ' +
          'This may happen if you return Component instead of <Component /> from render. ' +
          'Or maybe you meant to call this function rather than return it.\n' +
          '  root.render(Component)',
      ],
      {withoutStack: true},
    );
  });

  it('warns when given a symbol', () => {
    const root = ReactDOMClient.createRoot(document.createElement('div'));
    ReactDOM.flushSync(() => {
      root.render(Symbol('foo')));
    });
    assertConsoleErrorDev(
      [
        'Symbols are not valid as a React child. \n' +
          '  root.render(Symbol(foo))',
      ],
      {withoutStack: true},
    );
  });

  // ----------------------------------------------------------------
  // Behaviors
  // ----------------------------------------------------------------

  it('can be immediately unmounted', async () => {
    const root = ReactDOMClient.createRoot(container);
    await act(() => {
      root.unmount();
    });
  });

  it('throws if unmounting a root that has had its contents removed', async () => {
    const root = ReactDOMClient.createRoot(container);
    await act(() => {
      root.render(<div>Hi</div>);
    });
    container.innerHTML = '';
    await expect(() => {
      root.unmount();
    }).rejects.toThrow(
      'The node to be removed is not a child of this node.',
    );
  });

  it('warns when creating two roots managing the same container', () => {
    const root = ReactDOMClient.createRoot(container);
    root.unmount();
    ReactDOMClient.createRoot(container); // No warning
  });

  it('should be able to render different components in the same container', async () => {
    document.body.appendChild(container);
    const root = ReactDOMClient.createRoot(container);

    await act(() => {
      root.render(<div />);
    });
    expect(container.firstChild.nodeName).toBe('DIV');

    await act(() => {
      root.render(<span />);
    });
    expect(container.firstChild.nodeName).toBe('SPAN');
  });

  it('should not warn if mounting into non-empty node', async () => {
    container.innerHTML = '<div></div>';
    const root = ReactDOMClient.createRoot(container);
    await act(() => {
      root.render(<div />);
    });
    expect(true).toBe(true);
  });

  it('should reuse markup if rendering to the same target twice', async () => {
    const root = ReactDOMClient.createRoot(container);
    await act(() => {
      root.render(<div />);
    });
    const firstElm = container.firstChild;
    await act(() => {
      root.render(<div />);
    });
    expect(firstElm).toBe(container.firstChild);
  });

  it('should unmount and remount if the key changes', async () => {
    function Component({text}) {
      useEffect(() => {
        Scheduler.log('Mount');
        return () => {
          Scheduler.log('Unmount');
        };
      }, []);
      return <span>{text}</span>;
    }

    const root = ReactDOMClient.createRoot(container);
    await act(() => {
      root.render(<Component text="orange" key="A" />);
    });
    expect(container.firstChild.innerHTML).toBe('orange');
    assertLog(['Mount']);

    await act(() => {
      root.render(<Component text="green" key="B" />);
    });
    expect(container.firstChild.innerHTML).toBe('green');
    assertLog(['Unmount', 'Mount']);

    await act(() => {
      root.render(<Component text="blue" key="B" />);
    });
    expect(container.firstChild.innerHTML).toBe('blue');
    assertLog([]);
  });

  // ----------------------------------------------------------------
  // Hydration mismatch warnings
  // ----------------------------------------------------------------

  it('provides stack trace for attribute hydration mismatches', async () => {
    const root = ReactDOMClient.createRoot(container);
    const markup = '<div><span class="extra"></span></div>';
    container.innerHTML = markup;
    root.render(<div><span /></div>);
    await waitForAll([]);
    assertConsoleErrorDev(
      [
        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
          "\n" +
          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
          "- Variable input such as Date.now() or Math.random() that changes between server and client.\n" +
          "- Locale-specific date formatting.\n" +
          "- External data changes without a snapshot.\n" +
          "- Invalid HTML nesting.\n\n" +
          "It can also happen if a browser extension modifies the HTML before React loads.\n" +
          "\n" +
          "https://react.dev/link/hydration-mismatch\n" +
          "\n" +
          "  <div>\n" +
          "    <span\n" +
          "-   className=\"extra\"\n" +
          "    >\n" +
          "\n    in span (at **)",
      ],
      {withoutStack: true},
    );
  });
});
```