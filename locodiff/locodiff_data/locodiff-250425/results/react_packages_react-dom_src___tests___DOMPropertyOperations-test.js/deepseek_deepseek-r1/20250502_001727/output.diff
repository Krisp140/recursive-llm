
index d9c9c295..79fc417d 100644
--- a/react_packages_react-dom_src___tests___DOMPropertyOperations-test.js_expectedoutput.txt (expected):tmp/tmpj71mu8wb_expected.txt	
+++ b/react_packages_react-dom_src___tests___DOMPropertyOperations-test.js_extracted.txt (actual):tmp/tmpc4qxnfs1_actual.txt	
@@ -456,12 +456,12 @@ describe('DOMPropertyOperations', () => {
       const customElement = container.querySelector('my-custom-element');
 
       customElement.dispatchEvent(new Event('input', {bubbles: true}));
-      expect(inputEventHandler).toHaveBeenCalledTimes(1);
-      expect(changeEventHandler).toHaveBeenCalledTimes(0);
+      expect(inputEventHandler).toBeCalledTimes(1);
+      expect(changeEventHandler).toBeCalledTimes(0);
 
       customElement.dispatchEvent(new Event('change', {bubbles: true}));
-      expect(inputEventHandler).toHaveBeenCalledTimes(1);
-      expect(changeEventHandler).toHaveBeenCalledTimes(1);
+      expect(inputEventHandler).toBeCalledTimes(1);
+      expect(changeEventHandler).toBeCalledTimes(1);
     });
 
     it('custom elements should be able to remove and re-add custom event listeners', async () => {
@@ -642,7 +642,7 @@ describe('DOMPropertyOperations', () => {
       expect(customOnChangeHandler).toHaveBeenCalledTimes(1);
       expect(customOnClickHandler).toHaveBeenCalledTimes(1);
 
-      // The native input event only produces a React onInput event.
+      // Native input event should only trigger onInput on both inputs.
       clearMocks();
       regularInput.dispatchEvent(new Event('input', {bubbles: true}));
       expect(regularOnInputHandler).toHaveBeenCalledTimes(1);
@@ -928,528 +928,4 @@ describe('DOMPropertyOperations', () => {
       // React always ignores change event invoked on non-custom and non-input targets.
       // So change event emitted on a div does not propagate upwards.
       expect(onChangeHandler).toBeCalledTimes(0);
-      expect(onInputHandler).toBeCalledTimes(1);
-      expect(onClickHandler).toBeCalledTimes(0);
-
-      div.dispatchEvent(new Event('click', {bubbles: true}));
-      expect(onChangeHandler).toBeCalledTimes(0);
-      expect(onInputHandler).toBeCalledTimes(1);
-      expect(onClickHandler).toBeCalledTimes(1);
-    });
-
-    it('custom element onChange/onInput/onClick with event target custom element child', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      const onChangeHandler = jest.fn();
-      const onInputHandler = jest.fn();
-      const onClickHandler = jest.fn();
-      await act(() => {
-        root.render(
-          <my-custom-element
-            onChange={onChangeHandler}
-            onInput={onInputHandler}
-            onClick={onClickHandler}>
-            <other-custom-element />
-          </my-custom-element>,
-        );
-      });
-
-      const customChild = container.querySelector('other-custom-element');
-      customChild.dispatchEvent(new Event('input', {bubbles: true}));
-      // There is no simulated onChange, only raw onInput is dispatched.
-      expect(onChangeHandler).toBeCalledTimes(0);
-      expect(onInputHandler).toBeCalledTimes(1);
-      expect(onClickHandler).toBeCalledTimes(0);
-      // The native change event propagates to the parent as onChange.
-      customChild.dispatchEvent(new Event('change', {bubbles: true}));
-      expect(onChangeHandler).toBeCalledTimes(1);
-      expect(onInputHandler).toBeCalledTimes(1);
-      expect(onClickHandler).toBeCalledTimes(0);
-      customChild.dispatchEvent(new Event('click', {bubbles: true}));
-      expect(onChangeHandler).toBeCalledTimes(1);
-      expect(onInputHandler).toBeCalledTimes(1);
-      expect(onClickHandler).toBeCalledTimes(1);
-    });
-
-    it('custom elements should allow custom events with capture event listeners', async () => {
-      const oncustomeventCapture = jest.fn();
-      const oncustomevent = jest.fn();
-      function Test() {
-        return (
-          <my-custom-element
-            oncustomeventCapture={oncustomeventCapture}
-            oncustomevent={oncustomevent}>
-            <div />
-          </my-custom-element>
-        );
-      }
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Test />);
-      });
-      container
-        .querySelector('my-custom-element > div')
-        .dispatchEvent(new Event('customevent', {bubbles: false}));
-      expect(oncustomeventCapture).toHaveBeenCalledTimes(1);
-      expect(oncustomevent).toHaveBeenCalledTimes(0);
-    });
-
-    it('innerHTML should not work on custom elements', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element innerHTML="foo" />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      expect(customElement.getAttribute('innerHTML')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-
-      // Render again to verify the update codepath doesn't accidentally let
-      // something through.
-      await act(() => {
-        root.render(<my-custom-element innerHTML="bar" />);
-      });
-      expect(customElement.getAttribute('innerHTML')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-    });
-
-    it('innerText should not work on custom elements', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element innerText="foo" />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      expect(customElement.getAttribute('innerText')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-
-      // Render again to verify the update codepath doesn't accidentally let
-      // something through.
-      await act(() => {
-        root.render(<my-custom-element innerText="bar" />);
-      });
-      expect(customElement.getAttribute('innerText')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-    });
-
-    it('textContent should not work on custom elements', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element textContent="foo" />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      expect(customElement.getAttribute('textContent')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-
-      // Render again to verify the update codepath doesn't accidentally let
-      // something through.
-      await act(() => {
-        root.render(<my-custom-element textContent="bar" />);
-      });
-      expect(customElement.getAttribute('textContent')).toBe(null);
-      expect(customElement.hasChildNodes()).toBe(false);
-    });
-
-    it('values should not be converted to booleans when assigning into custom elements', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      customElement.foo = null;
-
-      // true => string
-      await act(() => {
-        root.render(<my-custom-element foo={true} />);
-      });
-      expect(customElement.foo).toBe(true);
-      await act(() => {
-        root.render(<my-custom-element foo="bar" />);
-      });
-      expect(customElement.foo).toBe('bar');
-
-      // false => string
-      await act(() => {
-        root.render(<my-custom-element foo={false} />);
-      });
-      expect(customElement.foo).toBe(false);
-      await act(() => {
-        root.render(<my-custom-element foo="bar" />);
-      });
-      expect(customElement.foo).toBe('bar');
-
-      // true => null
-      await act(() => {
-        root.render(<my-custom-element foo={true} />);
-      });
-      expect(customElement.foo).toBe(true);
-      await act(() => {
-        root.render(<my-custom-element foo={null} />);
-      });
-      expect(customElement.foo).toBe(null);
-
-      // false => null
-      await act(() => {
-        root.render(<my-custom-element foo={false} />);
-      });
-      expect(customElement.foo).toBe(false);
-      await act(() => {
-        root.render(<my-custom-element foo={null} />);
-      });
-      expect(customElement.foo).toBe(null);
-    });
-
-    it('boolean props should not be stringified in attributes', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element foo={true} />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-
-      expect(customElement.getAttribute('foo')).toBe('');
-
-      // true => false
-      await act(() => {
-        root.render(<my-custom-element foo={false} />);
-      });
-
-      expect(customElement.getAttribute('foo')).toBe(null);
-    });
-
-    it('custom element custom event handlers assign multiple types', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      const oncustomevent = jest.fn();
-
-      // First render with string
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={'foo'} />);
-      });
-      const customelement = container.querySelector('my-custom-element');
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(0);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe('foo');
-
-      // string => event listener
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={oncustomevent} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(1);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-
-      // event listener => string
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={'foo'} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(1);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe('foo');
-
-      // string => nothing
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(1);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-
-      // nothing => event listener
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={oncustomevent} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(2);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-    });
-
-    it('custom element custom event handlers assign multiple types with setter', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      const oncustomevent = jest.fn();
-
-      // First render with nothing
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      const customelement = container.querySelector('my-custom-element');
-      // Install a setter to activate the `in` heuristic
-      Object.defineProperty(customelement, 'oncustomevent', {
-        set: function (x) {
-          this._oncustomevent = x;
-        },
-        get: function () {
-          return this._oncustomevent;
-        },
-      });
-      expect(customelement.oncustomevent).toBe(undefined);
-
-      // nothing => event listener
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={oncustomevent} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(1);
-      expect(customelement.oncustomevent).toBe(null);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-
-      // event listener => string
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={'foo'} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(1);
-      expect(customelement.oncustomevent).toBe('foo');
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-
-      // string => event listener
-      await act(() => {
-        root.render(<my-custom-element oncustomevent={oncustomevent} />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(2);
-      expect(customelement.oncustomevent).toBe(null);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-
-      // event listener => nothing
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      customelement.dispatchEvent(new Event('customevent'));
-      expect(oncustomevent).toHaveBeenCalledTimes(2);
-      expect(customelement.oncustomevent).toBe(undefined);
-      expect(customelement.getAttribute('oncustomevent')).toBe(null);
-    });
-
-    it('assigning to a custom element property should not remove attributes', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element foo="one" />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      expect(customElement.getAttribute('foo')).toBe('one');
-
-      // Install a setter to activate the `in` heuristic
-      Object.defineProperty(customElement, 'foo', {
-        set: function (x) {
-          this._foo = x;
-        },
-        get: function () {
-          return this._foo;
-        },
-      });
-      await act(() => {
-        root.render(<my-custom-element foo="two" />);
-      });
-      expect(customElement.foo).toBe('two');
-      expect(customElement.getAttribute('foo')).toBe('one');
-    });
-
-    it('custom element properties should accept functions', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-
-      // Install a setter to activate the `in` heuristic
-      Object.defineProperty(customElement, 'foo', {
-        set: function (x) {
-          this._foo = x;
-        },
-        get: function () {
-          return this._foo;
-        },
-      });
-      function myFunction() {
-        return 'this is myFunction';
-      }
-      await act(() => {
-        root.render(<my-custom-element foo={myFunction} />);
-      });
-      expect(customElement.foo).toBe(myFunction);
-
-      // Also remove and re-add the property for good measure
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      expect(customElement.foo).toBe(undefined);
-      await act(() => {
-        root.render(<my-custom-element foo={myFunction} />);
-      });
-      expect(customElement.foo).toBe(myFunction);
-    });
-
-    it('switching between null and undefined should update a property', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element foo={undefined} />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-      customElement.foo = undefined;
-
-      await act(() => {
-        root.render(<my-custom-element foo={null} />);
-      });
-      expect(customElement.foo).toBe(null);
-
-      await act(() => {
-        root.render(<my-custom-element foo={undefined} />);
-      });
-      expect(customElement.foo).toBe(undefined);
-    });
-
-    it('warns when using popoverTarget={HTMLElement}', async () => {
-      const popoverTarget = document.createElement('div');
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-
-      await act(() => {
-        root.render(
-          <button key="one" popoverTarget={popoverTarget}>
-            Toggle popover
-          </button>,
-        );
-      });
-
-      assertConsoleErrorDev([
-        'The `popoverTarget` prop expects the ID of an Element as a string. Received HTMLDivElement {} instead.\n' +
-          '    in button (at **)',
-      ]);
-
-      // Dedupe warning
-      await act(() => {
-        root.render(
-          <button key="two" popoverTarget={popoverTarget}>
-            Toggle popover
-          </button>,
-        );
-      });
-    });
-  });
-
-  describe('deleteValueForProperty', () => {
-    it('should remove attributes for normal properties', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<div title="foo" />);
-      });
-      expect(container.firstChild.getAttribute('title')).toBe('foo');
-      await act(() => {
-        root.render(<div />);
-      });
-      expect(container.firstChild.getAttribute('title')).toBe(null);
-    });
-
-    it('should not remove attributes for special properties', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(
-          <input type="text" value="foo" onChange={function () {}} />,
-        );
-      });
-      if (disableInputAttributeSyncing) {
-        expect(container.firstChild.hasAttribute('value')).toBe(false);
-      } else {
-        expect(container.firstChild.getAttribute('value')).toBe('foo');
-      }
-      expect(container.firstChild.value).toBe('foo');
-      await act(() => {
-        root.render(<input type="text" onChange={function () {}} />);
-      });
-      assertConsoleErrorDev([
-        'A component is changing a controlled input to be uncontrolled. ' +
-          'This is likely caused by the value changing from a defined to undefined, ' +
-          'which should not happen. Decide between using a controlled or uncontrolled ' +
-          'input element for the lifetime of the component. ' +
-          'More info: https://react.dev/link/controlled-components\n' +
-          '    in input (at **)',
-      ]);
-      if (disableInputAttributeSyncing) {
-        expect(container.firstChild.hasAttribute('value')).toBe(false);
-      } else {
-        expect(container.firstChild.getAttribute('value')).toBe('foo');
-      }
-      expect(container.firstChild.value).toBe('foo');
-    });
-
-    it('should not remove attributes for custom component tag', async () => {
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-icon size="5px" />);
-      });
-      expect(container.firstChild.getAttribute('size')).toBe('5px');
-    });
-
-    it('custom elements should remove by setting undefined to restore defaults', async () => {
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      const customElement = container.querySelector('my-custom-element');
-
-      // Non-setter but existing property to active the `in` heuristic
-      customElement.raw = 1;
-
-      // Install a setter to activate the `in` heuristic
-      Object.defineProperty(customElement, 'object', {
-        set: function (value = null) {
-          this._object = value;
-        },
-        get: function () {
-          return this._object;
-        },
-      });
-
-      Object.defineProperty(customElement, 'string', {
-        set: function (value = '') {
-          this._string = value;
-        },
-        get: function () {
-          return this._string;
-        },
-      });
-
-      const obj = {};
-      await act(() => {
-        root.render(<my-custom-element raw={2} object={obj} string="hi" />);
-      });
-      expect(customElement.raw).toBe(2);
-      expect(customElement.object).toBe(obj);
-      expect(customElement.string).toBe('hi');
-
-      // Removing the properties should reset to defaults by passing undefined
-      await act(() => {
-        root.render(<my-custom-element />);
-      });
-      expect(customElement.raw).toBe(undefined);
-      expect(customElement.object).toBe(null);
-      expect(customElement.string).toBe('');
-    });
-  });
-});
\ No newline at end of file
+      expect(onInputHandler).toBeCalledTimes
\ No newline at end of file
