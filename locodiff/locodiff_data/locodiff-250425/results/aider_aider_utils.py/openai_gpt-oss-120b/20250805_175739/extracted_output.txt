import itertools
import os
import platform
import shlex
import subprocess
import sys
import tempfile
import time
from pathlib import Path

from aider.dump import dump  # noqa: F401

IMAGE_EXTENSIONS = {
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".bmp",
    ".tiff",
    ".webp",
    ".pdf",
}


class IgnorantTemporaryDirectory:
    def __init__(self):
        if sys.version_info >= (3, 10):
            self.temp_dir = tempfile.TemporaryDirectory(ignore_cleanup_errors=True)
        else:
            self.temp_dir = tempfile.TemporaryDirectory()

    def __enter__(self):
        return self.temp_dir.__enter__()

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            self.temp_dir.cleanup()
        except (OSError, PermissionError, RecursionError):
            pass  # ignore errors (especially Windows)

    def __getattr__(self, item):
        return getattr(self.temp_dir, item)


class ChdirTemporaryDirectory(IgnorantTemporaryDirectory):
    def __init__(self):
        try:
            self.cwd = os.getcwd()
        except FileNotFoundError:
            self.cwd = None
        super().__init__()

    def __enter__(self):
        res = super().__enter__()
        os.chdir(Path(self.temp_dir.name).resolve())
        return res

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.cwd:
            try:
                os.chdir(self.cwd)
            except FileNotFoundError:
                pass
        super().__exit__(exc_type, exc_val, exc_tb)


class GitTemporaryDirectory(ChdirTemporaryDirectory):
    def __enter__(self):
        dname = super().__enter__()
        self.repo = make_repo(dname)
        return dname

    def __exit__(self, exc_type, exc_val, exc_tb):
        del self.repo
        super().__exit__(exc_type, exc_val, exc_tb)


def make_repo(path=None):
    import git

    if not path:
        path = "."
    repo = git.Repo.init(path)
    repo.config_writer().set_value("user", "name", "Test User").release()
    repo.config_writer().set_value("user", "email", "testuser@example.com").release()
    return repo


def is_image_file(file_name):
    """
    Returns True if the file name ends with a known image extension.
    """
    file_name = str(file_name)  # Convert to string
    return any(file_name.endswith(ext) for ext in IMAGE_EXTENSIONS)


def safe_abs_path(res):
    """Return an absolute path with no Windows 8.3 short path issues."""
    return str(Path(res).resolve())


def format_content(role, content):
    formatted_lines = []
    for line in content.splitlines():
        formatted_lines.append(f"{role} {line}")
    return "\n".join(formatted_lines)


def format_messages(messages, title=None):
    output = []
    if title:
        output.append(f"{title.upper()} {'*' * 50}")

    for msg in messages:
        output.append("-------")
        role = msg["role"].upper()
        content = msg.get("content")
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict):
                    for key, value in item.items():
                        if isinstance(value, dict) and "url" in value:
                            output.append(f"{role} {key.capitalize()} URL: {value['url']}")
                        else:
                            output.append(f"{role} {key}: {value}")
                    # end dict handling
                else:
                    output.append(f"{role} {item}")
        elif isinstance(content, str):
            output.append(format_content(role, content))
        function_call = msg.get("function_call")
        if function_call:
            output.append(f"{role} Function Call: {function_call}")

    return "\n".join(output)


def split_chat_history_markdown(text, include_tool=False):
    """
    Parse a Markdown-formatted chat history into a list of message dicts.
    """
    messages = []
    user = []
    assistant = []
    tool = []
    lines = text.splitlines(keepends=True)

    def append_msg(role, lines):
        content = "".join(lines)
        if content.strip():
            messages.append(dict(role=role, content=content))

    for line in lines:
        if line.startswith("# "):
            continue

        # Tool output (list of images, etc.)
        if line.startswith("> "):
            # end previous assistant content (if any)
            append_msg("assistant", assistant)
            assistant = []
            # the preceding user message
            append_msg("user", user)
            user = []
            # capture tool line
            tool.append(line[2:])
            continue

        if line.startswith("#### "):
            # end previous assistant content (if any)
            append_msg("assistant", assistant)
            assistant = []
            # tool block ends
            append_msg("tool", tool)
            tool = []
            # start a new user block
            user.append(line[5:])
            continue

        # default: accumulate in current assistant block
        assistant.append(line)

    # final flush
    append_msg("assistant", assistant)
    append_msg("user", user)
    append_msg("tool", tool)

    if not include_tool:
        messages = [m for m in messages if m["role"] != "tool"]

    return messages


def find_common_root(abs_fnames):
    try:
        if len(abs_fnames) == 1:
            return safe_abs_path(os.path.dirname(list(abs_fnames)[0]))
        elif abs_fnames:
            return safe_abs_path(os.path.commonpath(list(abs_fnames))))
    except OSError:
        pass
    try:
        return safe_abs_path(os.getcwd())
    except FileNotFoundError:
        return "."


def format_tokens(count):
    if count < 1000:
        return f"{count}"
    elif count < 10000:
        return f"{count / 1000:.1f}k"
    else:
        return f"{round(count / 1000)}k"


def check_pip_install_extra(io, module, prompt, pip_install_cmd, self_update=False):
    """
    Ensure the specified module is installed, prompting the user if necessary.
    """
    if module:
        try:
            __import__(module)
            return True
        except (ImportError, ModuleNotFoundError, RuntimeError):
            pass

    cmd = get_pip_install(pip_install_cmd)

    if prompt:
        io.tool_warning(prompt)

    if self_update and platform.system() == "Windows":
        io.tool_output("Run this command to update:")
        print()
        print(printable_shell_command(cmd))
        return True

    if not io.confirm_ask("Run pip install?", default="y", subject=printable_shell_command(cmd)):
        return

    success, output = run_install(cmd)
    if success:
        if not module:
            return True
        try:
            __import__(module)
            return True
        except (ImportError, ModuleNotFoundError, RuntimeError) as err:
            io.tool_error(str(err))
    io.tool_error(output)
    print()
    print("Install failed, try running this command manually:")
    print(printable_shell_command(cmd))
    return False


def get_pip_install(args):
    cmd = [
        sys.executable,
        "-m",
        "pip",
        "install",
        "--upgrade",
        "--upgrade-strategy",
        "only-if-needed",
    ]
    cmd += args
    return cmd


def run_install(cmd):
    print()
    print("Installing:", printable_shell_command(cmd))

    try:
        output = []
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            universal_newlines=True,
            encoding=sys.stdout.encoding,
            errors="replace",
        )
        spinner = Spinner("Installation in progress...")
        while True:
            char = process.stdout.read(1)
            if not char:
                break
                # accumulate output
                output.append(char)
                spinner.step()
        return_code = process.wait()
        output = "".join(output)

        if return_code == 0:
            print("Installation complete.")
            print()
            return True, output

    except Exception as e:
        print("Error during installation:", e)

    print("\nInstallation failed.")
    return False, output


def printable_shell_command(cmd_list):
    """
    Convert a list of command arguments to a properly shell-escaped string.
    """
    if platform.system() == "Windows":
        return subprocess.list2cmdline(cmd_list)
    else:
        return shlex.join(cmd_list)


def main():
    spinner = Spinner("Running spinner...")
    for _ in range(40):
        time.sleep(0.25)
        spinner.step()
    spinner.end()


if __name__ == "__main__":
    main()